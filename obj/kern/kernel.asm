
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 e0 17 00 	lgdtl  0x17e018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 e0 17 f0       	mov    $0xf017e000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 d7 6b f0 01 	movl   $0x1,0xf06bd7a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 90 84 b0 f0       	mov    $0xf0b08490,%edx
f010006a:	b8 64 45 69 f0       	mov    $0xf0694564,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 64 45 69 f0       	push   $0xf0694564
f010007e:	e8 71 f7 01 00       	call   f011f7f4 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 20 1f 12 f0       	push   $0xf0121f20
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 67 1f 12 f0       	push   $0xf0121f67
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 7b 1f 12 f0       	push   $0xf0121f7b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 8f 1f 12 f0       	push   $0xf0121f8f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 9b 1f 12 f0       	push   $0xf0121f9b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 a3 1f 12 f0       	push   $0xf0121fa3
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 92 8e 00 00       	call   f0108fba <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 67 ee 00 00       	call   f010ef97 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 50 ef 00 00       	call   f010f094 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 2b ef 00 00       	call   f010f07c <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 4b ef 00 00       	call   f010f0ac <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 e2 fb 01 00       	call   f011fd4b <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 b1 1f 12 f0       	push   $0xf0121fb1
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 d1 a5 00 00       	call   f010a74f <env_init>
		ts_init();
f010017e:	e8 b5 c7 00 00       	call   f010c938 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 9b 1f 12 f0       	push   $0xf0121f9b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 c4 1f 12 f0       	push   $0xf0121fc4
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ed 1f 12 f0       	push   $0xf0121fed
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 03 20 12 f0       	push   $0xf0122003
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 20 20 12 f0       	push   $0xf0122020
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 3f 20 12 f0       	push   $0xf012203f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 5c 20 12 f0       	push   $0xf012205c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 80 20 12 f0       	push   $0xf0122080
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 e0 17 f0       	mov    $0xf017e000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 a0 20 12 f0       	push   $0xf01220a0
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 c4 20 12 f0       	push   $0xf01220c4
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 9c da 6b f0 00 	movl   $0x0,0xf06bda9c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 0c 21 12 f0       	push   $0xf012210c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 38 21 12 f0       	push   $0xf0122138
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 5d 21 12 f0       	push   $0xf012215d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 64 21 12 f0       	push   $0xf0122164
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 ac 21 12 f0       	push   $0xf01221ac
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 f4 21 12 f0       	push   $0xf01221f4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 ac 21 12 f0       	push   $0xf01221ac
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 64 21 12 f0       	push   $0xf0122164
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 39 22 12 f0       	push   $0xf0122239
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 5f b0 00 00       	call   f010b3a3 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 40 22 12 f0       	push   $0xf0122240
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 65 22 12 f0       	push   $0xf0122265
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 bb af 00 00       	call   f010b361 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 67 22 12 f0       	push   $0xf0122267
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 71 22 12 f0       	push   $0xf0122271
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 65 22 12 f0       	push   $0xf0122265
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 5d af 00 00       	call   f010b3a3 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 02 af 00 00       	call   f010b361 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 71 22 12 f0       	push   $0xf0122271
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 65 22 12 f0       	push   $0xf0122265
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 eb ae 00 00       	call   f010b3a3 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 90 ae 00 00       	call   f010b361 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 8a 22 12 f0       	push   $0xf012228a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 65 22 12 f0       	push   $0xf0122265
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 a4 45 69 f0       	mov    0xf06945a4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 a8 22 12 f0       	push   $0xf01222a8
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 a4 45 69 f0       	mov    %eax,0xf06945a4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 c7 d5 00 00       	call   f010dc3c <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 a8 45 69 f0 b4 	movl   $0x3b4,0xf06945a8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 a8 45 69 f0 d4 	movl   $0x3d4,0xf06945a8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 ac 45 69 f0       	mov    %eax,0xf06945ac
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f010087a:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		text_length = 0;
f01008a6:	c7 05 a0 45 69 f0 00 	movl   $0x0,0xf06945a0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d b0 45 69 f0 	mov    0xf06945b0,%cx
f01008b7:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d ac 45 69 f0    	mov    0xf06945ac,%ecx
f0100972:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 b0 45 69 f0 	mov    %dx,0xf06945b0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 a0 45 69 f0    	mov    0xf06945a0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 a0 45 69 f0       	mov    %eax,0xf06945a0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 39 ee 01 00       	call   f011f824 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 a8 45 69 f0    	mov    0xf06945a8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 a8 45 69 f0    	mov    0xf06945a8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 e1 17 f0    	mov    -0xfe81ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 e5 17 f0 	mov    -0xfe81ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 a0 45 69 f0    	mov    0xf06945a0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 a0 45 69 f0       	mov    %eax,0xf06945a0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 bb 22 12 f0       	push   $0xf01222bb
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 27 cf 00 00       	call   f010dc3c <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 c4 47 69 f0    	mov    %edx,0xf06947c4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 c0 45 69 f0    	mov    %dl,-0xf96ba40(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 c4 47 69 f0 00 	movl   $0x0,0xf06947c4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 c0 47 69 f0    	mov    0xf06947c0,%edx
f0100d7f:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 c0 47 69 f0    	mov    %edx,0xf06947c0
f0100d96:	8a 80 c0 45 69 f0    	mov    -0xf96ba40(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 c0 47 69 f0 00 	movl   $0x0,0xf06947c0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 c0 47 69 f0    	mov    0xf06947c0,%edx
f0100dd0:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 c0 47 69 f0    	mov    %edx,0xf06947c0
f0100de7:	8a 80 c0 45 69 f0    	mov    -0xf96ba40(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 c0 47 69 f0 00 	movl   $0x0,0xf06947c0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 a4 45 69 f0       	mov    0xf06945a4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 c7 22 12 f0       	push   $0xf01222c7
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 e2 a4 00 00       	call   f010b3a3 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 e4 22 12 f0       	push   $0xf01222e4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 0b 23 12 f0       	push   $0xf012230b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 9b a4 00 00       	call   f010b3a3 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 20 23 12 f0       	push   $0xf0122320
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 0b 23 12 f0       	push   $0xf012230b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 c1 df 01 00       	call   f011ef44 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 0e e6 01 00       	call   f011f606 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 80 bb 6d f0       	push   $0xf06dbb80
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 11 e8 01 00       	call   f011f824 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 4c e5 01 00       	call   f011f606 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 80 bb 6d f0       	push   $0xf06dbb80
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 4f e7 01 00       	call   f011f824 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 8c e6 01 00       	call   f011f7f4 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 4c 23 12 f0       	push   $0xf012234c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 4f 23 12 f0       	push   $0xf012234f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 60 db 6b f0       	push   $0xf06bdb60
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 31 e3 01 00       	call   f011f606 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 46 e3 01 00       	call   f011f655 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 e9 e2 01 00       	call   f011f606 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 5f 23 12 f0       	push   $0xf012235f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 c4 e8 01 00       	call   f011fc1b <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 64 23 12 f0       	push   $0xf0122364
f010137e:	50                   	push   %eax
f010137f:	e8 8e e3 01 00       	call   f011f712 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 68 23 12 f0       	push   $0xf0122368
f0101399:	50                   	push   %eax
f010139a:	e8 73 e3 01 00       	call   f011f712 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 6d 23 12 f0       	push   $0xf012236d
f01013b4:	50                   	push   %eax
f01013b5:	e8 58 e3 01 00       	call   f011f712 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 6d 23 12 f0       	push   $0xf012236d
f01013d5:	50                   	push   %eax
f01013d6:	e8 37 e3 01 00       	call   f011f712 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 df e1 01 00       	call   f011f606 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 e1 e1 01 00       	call   f011f655 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 c0 e1 01 00       	call   f011f655 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 3d e1 01 00       	call   f011f606 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 58 e2 01 00       	call   f011f74a <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 8d e0 01 00       	call   f011f606 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 58 e2 01 00       	call   f011f7f4 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 c3 e0 01 00       	call   f011f683 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 03 e0 01 00       	call   f011f606 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 1b e1 01 00       	call   f011f74a <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 66 df 01 00       	call   f011f606 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 06 df 01 00       	call   f011f606 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 d1 e0 01 00       	call   f011f7f4 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 3c df 01 00       	call   f011f683 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 7e de 01 00       	call   f011f606 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 99 df 01 00       	call   f011f74a <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 e4 dd 01 00       	call   f011f606 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 8a dd 01 00       	call   f011f606 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 55 df 01 00       	call   f011f7f4 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 c0 dd 01 00       	call   f011f683 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 60 db 6b f0       	push   $0xf06bdb60
f0101929:	e8 d8 dc 01 00       	call   f011f606 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 7f dc 01 00       	call   f011f606 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 6c dc 01 00       	call   f011f606 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 60 db 6b f0    	lea    -0xf9424a0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 11 dc 01 00       	call   f011f606 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 60 6b 6d f0    	lea    -0xf9294a0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 06 dc 01 00       	call   f011f824 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 60 b7 6d f0       	push   $0xf06db760
f0101c3a:	e8 e5 db 01 00       	call   f011f824 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 b5 da 01 00       	call   f011f712 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 e5 17 f0       	mov    %eax,0xf017e530
f0101c6f:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 97 db 01 00       	call   f011f824 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 9c da 6b f0       	mov    0xf06bda9c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 77 23 12 f0       	mov    $0xf0122377,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 77 27 12 f0       	mov    $0xf0122777,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 77 2b 12 f0       	mov    $0xf0122b77,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 9c da 6b f0 00 	movl   $0x0,0xf06bda9c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 18 da 6b f0 00 	movl   $0x0,0xf06bda18
f0101d59:	00 00 00 
f0101d5c:	c7 05 1c da 6b f0 00 	movl   $0x0,0xf06bda1c
f0101d63:	00 00 00 
f0101d66:	c7 05 24 da 6b f0 00 	movl   $0x0,0xf06bda24
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 6e da 01 00       	call   f011f7f4 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 71 23 12 f0       	push   $0xf0122371
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 51 98 00 00       	call   f010b630 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 40 db 6b f0       	mov    %eax,0xf06bdb40
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 40 db 6b f0       	mov    0xf06bdb40,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 40 db 6b f0    	mov    %edx,0xf06bdb40
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
f0101e98:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 40 db 6b f0       	mov    %eax,0xf06bdb40
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 40 db 6b f0       	mov    0xf06bdb40,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 40 db 6b f0    	mov    %edx,0xf06bdb40
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
f0101ed4:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 5f 23 12 f0       	push   $0xf012235f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 05 dd 01 00       	call   f011fc1b <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 77 2f 12 f0       	push   $0xf0122f77
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 90 2f 12 f0       	push   $0xf0122f90
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 e1 2f 12 f0       	push   $0xf0122fe1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 fc 2f 12 f0       	push   $0xf0122ffc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 2c 30 12 f0       	push   $0xf012302c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 e1 2f 12 f0       	push   $0xf0122fe1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 56 30 12 f0       	push   $0xf0123056
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f010203b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 60 30 12 f0       	push   $0xf0123060
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 c3 30 12 f0       	push   $0xf01230c3
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 cc 30 12 f0       	push   $0xf01230cc
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f010218b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 e5 17 f0       	add    $0xf017e548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 d4 30 12 f0       	push   $0xf01230d4
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 e1 2f 12 f0       	push   $0xf0122fe1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 24 da 6b f0       	mov    %eax,0xf06bda24

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f0102292:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 34 d4 01 00       	call   f011f712 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010238d:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023a3:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 24 da 6b f0       	mov    %eax,0xf06bda24
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010248c:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01024a2:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 24 da 6b f0       	mov    %eax,0xf06bda24
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 58 d8 6b f0 00 	movl   $0x0,0xf06bd858
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 58 d8 6b f0 02 	movl   $0x2,0xf06bd858
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 58 d8 6b f0 03 	movl   $0x3,0xf06bd858
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 58 d8 6b f0 04 	movl   $0x4,0xf06bd858
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 a4 d7 6b f0 01 	movl   $0x1,0xf06bd7a4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 a4 d7 6b f0 02 	movl   $0x2,0xf06bd7a4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 a4 d7 6b f0 03 	movl   $0x3,0xf06bd7a4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 a4 d7 6b f0 04 	movl   $0x4,0xf06bd7a4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 f4 30 12 f0       	push   $0xf01230f4
f0102662:	6a 56                	push   $0x56
f0102664:	68 1c 31 12 f0       	push   $0xf012311c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 e5 17 f0       	add    $0xf017e544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 9f 39 12 f0       	push   $0xf012399f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 a8 39 12 f0       	push   $0xf01239a8
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 bd 39 12 f0       	push   $0xf01239bd
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 d9 39 12 f0       	push   $0xf01239d9
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 f4 39 12 f0       	push   $0xf01239f4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 05 1f 12 00       	mov    $0x121f05,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 05 1f 12 f0       	push   $0xf0121f05
f010278e:	68 30 3a 12 f0       	push   $0xf0123a30
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 64 45 69 00       	mov    $0x694564,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 64 45 69 f0       	push   $0xf0694564
f01027a9:	68 6c 3a 12 f0       	push   $0xf0123a6c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 90 84 b0 00       	mov    $0xb08490,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 90 84 b0 f0       	push   $0xf0b08490
f01027c4:	68 b4 3a 12 f0       	push   $0xf0123ab4
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 90 84 b0 f0       	mov    $0xf0b08490,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 f0 3a 12 f0       	push   $0xf0123af0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 3c d1 01 00       	call   f011f966 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 fb d0 01 00       	call   f011f966 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 6a 8b 00 00       	call   f010b3f3 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 c5 d0 01 00       	call   f011f966 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 1c 3b 12 f0       	push   $0xf0123b1c
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 3f d0 01 00       	call   f011f966 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 bc cc 01 00       	call   f011f606 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 c1 cf 01 00       	call   f011f966 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 46 3b 12 f0       	push   $0xf0123b46
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 75 cf 01 00       	call   f011f966 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 e4 89 00 00       	call   f010b3f3 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 3f cf 01 00       	call   f011f966 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 46 3b 12 f0       	push   $0xf0123b46
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 60 3b 12 f0       	push   $0xf0123b60
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 ae ce 01 00       	call   f011f966 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 8a 3b 12 f0       	push   $0xf0123b8a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 8d 3b 12 f0       	push   $0xf0123b8d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 51 ce 01 00       	call   f011f966 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 c0 88 00 00       	call   f010b3f3 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 1b ce 01 00       	call   f011f966 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 00 ce 01 00       	call   f011f966 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 8f 3b 12 f0       	push   $0xf0123b8f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 64 cd 01 00       	call   f011f966 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 d3 87 00 00       	call   f010b3f3 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 1d cd 01 00       	call   f011f966 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 22 69 00 00       	call   f01095a7 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 d3 67 00 00       	call   f0109464 <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 a0 3b 12 f0       	push   $0xf0123ba0
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 28 cc 01 00       	call   f011f966 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 97 86 00 00       	call   f010b3f3 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 e1 cb 01 00       	call   f011f966 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 ca 3b 12 f0       	push   $0xf0123bca
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 e4 3b 12 f0       	push   $0xf0123be4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 28 3c 12 f0       	push   $0xf0123c28
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 70 d9 6b f0       	mov    0xf06bd970,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 80 3c 12 f0       	push   $0xf0123c80
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 c0 c0 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 bc 3c 12 f0       	push   $0xf0123cbc
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 11 ca 01 00       	call   f011f966 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 f6 c9 01 00       	call   f011f966 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 db c9 01 00       	call   f011f966 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 3f c0 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 aa c9 01 00       	call   f011f966 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 8d c9 01 00       	call   f011f966 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 72 c9 01 00       	call   f011f966 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 d9 bf 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 68 3d 12 f0       	push   $0xf0123d68
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 2a c9 01 00       	call   f011f966 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 f8 3d 12 f0       	push   $0xf0123df8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 77 bf 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 90 3e 12 f0       	push   $0xf0123e90
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 e8 3e 12 f0       	push   $0xf0123ee8
f010309d:	68 2d 3f 12 f0       	push   $0xf0123f2d
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 42 3f 12 f0       	push   $0xf0123f42
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 e8 3e 12 f0       	push   $0xf0123ee8
f01030bc:	68 2d 3f 12 f0       	push   $0xf0123f2d
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 42 3f 12 f0       	push   $0xf0123f42
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 3e 78 00 00       	call   f010a925 <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 56 3f 12 f0       	push   $0xf0123f56
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 68 3f 12 f0       	push   $0xf0123f68
f0103117:	68 2d 3f 12 f0       	push   $0xf0123f2d
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 42 3f 12 f0       	push   $0xf0123f42
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 98 3f 12 f0       	push   $0xf0123f98
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 70 d9 6b f0 00 	movl   $0x0,0xf06bd970
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 9b c7 01 00       	call   f011f966 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 98 3f 12 f0       	push   $0xf0123f98
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 70 d9 6b f0 00 	movl   $0x0,0xf06bd970
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 b0 3f 12 f0       	push   $0xf0123fb0
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 b1 c6 01 00       	call   f011f966 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 88 bc 00 00       	call   f010ef54 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 10 40 12 f0       	push   $0xf0124010
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 62 bc 00 00       	call   f010ef54 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 54 40 12 f0       	push   $0xf0124054
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 94 40 12 f0       	push   $0xf0124094
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 26 c6 01 00       	call   f011f966 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 76 bc 00 00       	call   f010efc7 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 e8 40 12 f0       	push   $0xf01240e8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 11 bc 00 00       	call   f010ef87 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 1c 41 12 f0       	push   $0xf012411c
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 ff bb 00 00       	call   f010ef97 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 48 41 12 f0       	push   $0xf0124148
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 ed bb 00 00       	call   f010efa7 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 70 41 12 f0       	push   $0xf0124170
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 7a c5 01 00       	call   f011f966 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 a4 41 12 f0       	push   $0xf01241a4
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 26 c5 01 00       	call   f011f966 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 f3 c4 01 00       	call   f011f966 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 dc 41 12 f0       	push   $0xf01241dc
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 84 d6 6b f0    	mov    0xf06bd684,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 09 42 12 f0       	push   $0xf0124209
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 8d 3b 12 f0       	push   $0xf0123b8d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 4e c4 01 00       	call   f011f966 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 33 c4 01 00       	call   f011f966 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 10 42 12 f0       	push   $0xf0124210
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 8d 3b 12 f0       	push   $0xf0123b8d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 4c 42 12 f0       	push   $0xf012424c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 84 d6 6b f0    	mov    0xf06bd684,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 09 42 12 f0       	push   $0xf0124209
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 8d 3b 12 f0       	push   $0xf0123b8d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 80 42 12 f0       	push   $0xf0124280
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 10 42 12 f0       	push   $0xf0124210
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 bc 42 12 f0       	push   $0xf01242bc
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 f5 c2 01 00       	call   f011f966 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 d4 b0 01 00       	call   f011e75a <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 e4 42 12 f0       	push   $0xf01242e4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 0c 43 12 f0       	push   $0xf012430c
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 2c b9 00 00       	call   f010eff5 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 30 43 12 f0       	push   $0xf0124330
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 f3 b8 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 58 43 12 f0       	push   $0xf0124358
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 d0 b8 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 98 43 12 f0       	push   $0xf0124398
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 e3 b8 00 00       	call   f010f010 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 d4 43 12 f0       	push   $0xf01243d4
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 e3 b8 00 00       	call   f010f02b <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 f8 43 12 f0       	push   $0xf01243f8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 28 44 12 f0       	push   $0xf0124428
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 54 44 12 f0       	push   $0xf0124454
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 84 44 12 f0       	push   $0xf0124484
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 b4 44 12 f0       	push   $0xf01244b4
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 e4 44 12 f0       	push   $0xf01244e4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 14 45 12 f0       	push   $0xf0124514
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 40 45 12 f0       	push   $0xf0124540
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 6c 45 12 f0       	push   $0xf012456c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 98 45 12 f0       	push   $0xf0124598
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 c4 45 12 f0       	push   $0xf01245c4
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 f0 45 12 f0       	push   $0xf01245f0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 f0 45 12 f0       	push   $0xf01245f0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 24 46 12 f0       	push   $0xf0124624
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 54 46 12 f0       	push   $0xf0124654
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 84 46 12 f0       	push   $0xf0124684
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 b8 46 12 f0       	push   $0xf01246b8
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 f4 46 12 f0       	push   $0xf01246f4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 24 47 12 f0       	push   $0xf0124724
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 50 47 12 f0       	push   $0xf0124750
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 7c 47 12 f0       	push   $0xf012477c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 ac 47 12 f0       	push   $0xf01247ac
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 c3 b6 00 00       	call   f010f0a2 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 dc 47 12 f0       	push   $0xf01247dc
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 7d b6 00 00       	call   f010f07c <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 18 48 12 f0       	push   $0xf0124818
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 7e b6 00 00       	call   f010f0a2 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 dc 47 12 f0       	push   $0xf01247dc
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 38 b6 00 00       	call   f010f07c <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 3c 48 12 f0       	push   $0xf012483c
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 26 b6 00 00       	call   f010f094 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 01 b6 00 00       	call   f010f07c <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 5c 48 12 f0       	push   $0xf012485c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 ef b5 00 00       	call   f010f094 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 ca b5 00 00       	call   f010f07c <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 00 b6 00 00       	call   f010f0ba <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 78 48 12 f0       	push   $0xf0124878
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 a8 48 12 f0       	push   $0xf01248a8
f0103ada:	e8 1f b9 01 00       	call   f011f3fe <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 74 be 01 00       	call   f011f966 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 ae b5 00 00       	call   f010f0ac <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 b4 b5 00 00       	call   f010f0ba <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 d4 48 12 f0       	push   $0xf01248d4
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 f9 48 12 f0       	push   $0xf01248f9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 69 b5 00 00       	call   f010f0a2 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 14 49 12 f0       	push   $0xf0124914
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 36 b5 00 00       	call   f010f08a <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 64 49 12 f0       	push   $0xf0124964
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 e9 bd 01 00       	call   f011f966 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 23 b5 00 00       	call   f010f0ac <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 29 b5 00 00       	call   f010f0ba <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 d4 48 12 f0       	push   $0xf01248d4
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 ee b4 00 00       	call   f010f0a2 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 14 49 12 f0       	push   $0xf0124914
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 bb b4 00 00       	call   f010f08a <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 64 49 12 f0       	push   $0xf0124964
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 d2 b4 00 00       	call   f010f0ba <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 aa 49 12 f0       	push   $0xf01249aa
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 18 c0 00 00       	call   f010fc2c <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 b1 c1 01 00       	call   f011fdee <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 c2 c2 01 00       	call   f011ff2e <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 c8 49 12 f0       	push   $0xf01249c8
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 df 49 12 f0       	push   $0xf01249df
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 80 d9 6b f0 00 	movl   $0x0,0xf06bd980
f0103c9f:	00 00 00 
f0103ca2:	c7 05 84 d9 6b f0 00 	movl   $0x0,0xf06bd984
f0103ca9:	00 00 00 
f0103cac:	c7 05 8c d9 6b f0 00 	movl   $0x0,0xf06bd98c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 fc 49 12 f0       	push   $0xf01249fc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 df 49 12 f0       	push   $0xf01249df
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103d36:	8b 1d 80 d0 6b f0    	mov    0xf06bd080,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103d68:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103d81:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 80 d0 6b f0    	mov    0xf06bd080,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 90 d9 6b f0       	push   $0xf06bd990
f0103e0a:	e8 36 b8 00 00       	call   f010f645 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 80 d9 6b f0       	mov    0xf06bd980,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 1f 4a 12 f0       	push   $0xf0124a1f
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 df 49 12 f0       	push   $0xf01249df
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 90 d9 6b f0       	push   $0xf06bd990
f0103ed6:	e8 f1 b7 00 00       	call   f010f6cc <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 90 d9 6b f0       	push   $0xf06bd990
f0103efc:	e8 44 b7 00 00       	call   f010f645 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 fc 49 12 f0       	push   $0xf01249fc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 df 49 12 f0       	push   $0xf01249df
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103f5b:	8b 1d 80 d0 6b f0    	mov    0xf06bd080,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103f8d:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103fa6:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 90 d9 6b f0       	push   $0xf06bd990
f0103fd4:	e8 f3 b6 00 00       	call   f010f6cc <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 8b 55 00 00       	call   f01095a7 <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 40 4a 12 f0       	push   $0xf0124a40
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 df 49 12 f0       	push   $0xf01249df
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 7b 51 00 00       	call   f0109204 <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 86 54 00 00       	call   f010954a <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 13 b7 01 00       	call   f011f7f4 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 5c d8 6b f0       	mov    0xf06bd85c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 70 4a 12 f0       	push   $0xf0124a70
f0104192:	68 96 4a 12 f0       	push   $0xf0124a96
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 df 49 12 f0       	push   $0xf01249df
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 70 4a 12 f0       	push   $0xf0124a70
f0104245:	68 96 4a 12 f0       	push   $0xf0124a96
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 df 49 12 f0       	push   $0xf01249df
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 70 4a 12 f0       	push   $0xf0124a70
f010430b:	68 96 4a 12 f0       	push   $0xf0124a96
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 df 49 12 f0       	push   $0xf01249df
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 ac 4a 12 f0       	push   $0xf0124aac
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 df 49 12 f0       	push   $0xf01249df
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 f8 4a 12 f0       	push   $0xf0124af8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 df 49 12 f0       	push   $0xf01249df
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 5c 50 00 00       	call   f01095e3 <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 2f 4f 00 00       	call   f01095a7 <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 78 4d 00 00       	call   f0109464 <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 50 4d 00 00       	call   f0109464 <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 06 4d 00 00       	call   f0109464 <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 5a 4a 00 00       	call   f0109204 <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 78 4d 00 00       	call   f010954a <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 ff af 01 00       	call   f011f7f4 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 52 4d 00 00       	call   f01095a7 <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 90 d9 6b f0       	push   $0xf06bd990
f01048b3:	e8 8d ad 00 00       	call   f010f645 <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 90 d9 6b f0       	push   $0xf06bd990
f01048cb:	e8 fc ad 00 00       	call   f010f6cc <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 02 49 00 00       	call   f0109204 <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 20 4c 00 00       	call   f010954a <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 a7 ae 01 00       	call   f011f7f4 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 70 4a 12 f0       	push   $0xf0124a70
f010496b:	68 96 4a 12 f0       	push   $0xf0124a96
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 df 49 12 f0       	push   $0xf01249df
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 74 4b 12 f0       	push   $0xf0124b74
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 da b3 01 00       	call   f011ff2e <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 68 d9 6b f0 00 	movl   $0x0,0xf06bd968
f0104c05:	00 00 00 
f0104c08:	c7 05 6c d9 6b f0 00 	movl   $0x0,0xf06bd96c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 1b 90 00 00       	call   f010dc3c <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 98 4b 12 f0       	push   $0xf0124b98
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 f4 4b 12 f0       	push   $0xf0124bf4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 98 4b 12 f0       	push   $0xf0124b98
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 f4 4b 12 f0       	push   $0xf0124bf4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 08 4c 12 f0       	push   $0xf0124c08
f0104fbb:	68 16 4c 12 f0       	push   $0xf0124c16
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 44 4c 12 f0       	push   $0xf0124c44
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 67 4c 12 f0       	push   $0xf0124c67
f0105072:	6a 44                	push   $0x44
f0105074:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 08 4c 12 f0       	push   $0xf0124c08
f0105104:	68 16 4c 12 f0       	push   $0xf0124c16
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 67 4c 12 f0       	push   $0xf0124c67
f010512d:	6a 52                	push   $0x52
f010512f:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105227:	e8 19 a4 00 00       	call   f010f645 <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 1e 42 00 00       	call   f0109464 <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 04 42 00 00       	call   f0109464 <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010526b:	e8 5c a4 00 00       	call   f010f6cc <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105284:	e8 d5 a5 00 00       	call   f010f85e <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 88 4c 12 f0       	push   $0xf0124c88
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 c9 4c 12 f0       	push   $0xf0124cc9
f01052b2:	68 16 4c 12 f0       	push   $0xf0124c16
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01052f5:	e8 64 a5 00 00       	call   f010f85e <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 88 4c 12 f0       	push   $0xf0124c88
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 d8 4c 12 f0       	push   $0xf0124cd8
f010532e:	68 16 4c 12 f0       	push   $0xf0124c16
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 67 4c 12 f0       	push   $0xf0124c67
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105453:	e8 06 a4 00 00       	call   f010f85e <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 88 4c 12 f0       	push   $0xf0124c88
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 c9 4c 12 f0       	push   $0xf0124cc9
f0105481:	68 16 4c 12 f0       	push   $0xf0124c16
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 30 d3 6b f0       	push   $0xf06bd330
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01054c3:	e8 96 a3 00 00       	call   f010f85e <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 88 4c 12 f0       	push   $0xf0124c88
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 04 4d 12 f0       	push   $0xf0124d04
f01054fc:	68 16 4c 12 f0       	push   $0xf0124c16
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 67 4c 12 f0       	push   $0xf0124c67
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 34 d3 6b f0       	mov    %eax,0xf06bd334
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 30 d3 6b f0       	mov    %eax,0xf06bd330
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 3c d3 6b f0       	mov    0xf06bd33c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 3c d3 6b f0       	mov    %eax,0xf06bd33c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01055b3:	e8 a6 a2 00 00       	call   f010f85e <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 88 4c 12 f0       	push   $0xf0124c88
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 c9 4c 12 f0       	push   $0xf0124cc9
f01055e1:	68 16 4c 12 f0       	push   $0xf0124c16
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 a8 9a 00 00       	call   f010f0a2 <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 1c 70 00 00       	call   f010c625 <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 40 d3 6b f0       	push   $0xf06bd340
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010563a:	e8 1f a2 00 00       	call   f010f85e <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 88 4c 12 f0       	push   $0xf0124c88
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 30 4d 12 f0       	push   $0xf0124d30
f0105673:	68 16 4c 12 f0       	push   $0xf0124c16
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 67 4c 12 f0       	push   $0xf0124c67
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 44 d3 6b f0       	mov    %eax,0xf06bd344
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 40 d3 6b f0       	mov    %eax,0xf06bd340
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 4c d3 6b f0       	mov    %eax,0xf06bd34c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010572a:	e8 16 9f 00 00       	call   f010f645 <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 5b 4d 12 f0       	push   $0xf0124d5b
f010573d:	68 16 4c 12 f0       	push   $0xf0124c16
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105767:	e8 60 9f 00 00       	call   f010f6cc <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105780:	e8 c0 9e 00 00       	call   f010f645 <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01057d7:	e8 f0 9e 00 00       	call   f010f6cc <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105804:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010581e:	e8 a9 9e 00 00       	call   f010f6cc <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105837:	e8 22 a0 00 00       	call   f010f85e <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105850:	e8 f0 9d 00 00       	call   f010f645 <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f01058b6:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 67 4c 12 f0       	push   $0xf0124c67
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 68 59 00 00       	call   f010b3a3 <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 63 4d 12 f0       	push   $0xf0124d63
f0105a49:	68 16 4c 12 f0       	push   $0xf0124c16
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 85 5a 00 00       	call   f010b524 <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105aad:	e8 1a 9c 00 00       	call   f010f6cc <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105ac6:	e8 7a 9b 00 00       	call   f010f645 <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 74 4d 12 f0       	push   $0xf0124d74
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105b4c:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 9c 4d 12 f0       	push   $0xf0124d9c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 67 4c 12 f0       	push   $0xf0124c67
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 c8 4d 12 f0       	push   $0xf0124dc8
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0105d65:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105d7c:	e8 4b 99 00 00       	call   f010f6cc <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 c6 55 00 00       	call   f010b35b <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ee 4d 12 f0       	push   $0xf0124dee
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 f1 55 00 00       	call   f010b3a3 <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 63 4d 12 f0       	push   $0xf0124d63
f0105dc0:	68 16 4c 12 f0       	push   $0xf0124c16
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 f4 4d 12 f0       	push   $0xf0124df4
f0105df5:	68 16 4c 12 f0       	push   $0xf0124c16
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 18 4e 12 f0       	push   $0xf0124e18
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 29 55 00 00       	call   f010b35b <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ee 4d 12 f0       	push   $0xf0124dee
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 d3 56 00 00       	call   f010b524 <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105e62:	e8 de 97 00 00       	call   f010f645 <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 44 4e 12 f0       	push   $0xf0124e44
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 66 4e 12 f0       	push   $0xf0124e66
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105ecb:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 70 4e 12 f0       	push   $0xf0124e70
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 8c 4e 12 f0       	push   $0xf0124e8c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 c0 4e 12 f0       	push   $0xf0124ec0
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 66 4e 12 f0       	push   $0xf0124e66
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 e8 4e 12 f0       	push   $0xf0124ee8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 8c 4e 12 f0       	push   $0xf0124e8c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 0c 4f 12 f0       	push   $0xf0124f0c
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 66 4e 12 f0       	push   $0xf0124e66
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0106041:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 2e 4f 12 f0       	push   $0xf0124f2e
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010606a:	e8 5d 96 00 00       	call   f010f6cc <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106083:	e8 bd 95 00 00       	call   f010f645 <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 3c d3 6b f0       	mov    0xf06bd33c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 30 d3 6b f0       	push   $0xf06bd330
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01060d7:	e8 f0 95 00 00       	call   f010f6cc <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 4c 4f 12 f0       	push   $0xf0124f4c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106118:	e8 28 95 00 00       	call   f010f645 <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 88 4f 12 f0       	push   $0xf0124f88
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 b4 4f 12 f0       	push   $0xf0124fb4
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 dd 51 00 00       	call   f010b35b <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ee 4d 12 f0       	push   $0xf0124dee
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f01061b1:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 c7 4f 12 f0       	push   $0xf0124fc7
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 8c 4e 12 f0       	push   $0xf0124e8c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 b4 4f 12 f0       	push   $0xf0124fb4
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 67 4c 12 f0       	push   $0xf0124c67
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 5d 50 00 00       	call   f010b35b <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ee 4d 12 f0       	push   $0xf0124dee
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 e8 4e 12 f0       	push   $0xf0124ee8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 8c 4e 12 f0       	push   $0xf0124e8c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 18 50 12 f0       	push   $0xf0125018
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 b4 4f 12 f0       	push   $0xf0124fb4
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 68 4f 00 00       	call   f010b35b <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ee 4d 12 f0       	push   $0xf0124dee
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0106426:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 2e 4f 12 f0       	push   $0xf0124f2e
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 57 4f 00 00       	call   f010b3a3 <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 f4 4d 12 f0       	push   $0xf0124df4
f010646b:	68 16 4c 12 f0       	push   $0xf0124c16
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 18 4e 12 f0       	push   $0xf0124e18
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 b3 4e 00 00       	call   f010b35b <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ee 4d 12 f0       	push   $0xf0124dee
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 64 50 00 00       	call   f010b524 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01064c8:	e8 ff 91 00 00       	call   f010f6cc <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01064e3:	e8 5d 91 00 00       	call   f010f645 <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 67 4c 12 f0       	push   $0xf0124c67
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010664e:	e8 79 90 00 00       	call   f010f6cc <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 68 d9 6b f0       	mov    0xf06bd968,%eax
f0106661:	8b 15 6c d9 6b f0    	mov    0xf06bd96c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 44 50 12 f0       	push   $0xf0125044
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 2b 4c 12 f0       	push   $0xf0124c2b
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 44 50 12 f0       	push   $0xf0125044
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 2b 4c 12 f0       	push   $0xf0124c2b
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 44 50 12 f0       	push   $0xf0125044
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 44 50 12 f0       	push   $0xf0125044
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 2b 4c 12 f0       	push   $0xf0124c2b
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 98 d4 6b f0 00 	movl   $0x0,0xf06bd498
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 30 d3 6b f0       	push   $0xf06bd330
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 40 d3 6b f0       	push   $0xf06bd340
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 58 50 12 f0       	push   $0xf0125058
f0106781:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106786:	e8 89 8e 00 00       	call   f010f614 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 6c 50 12 f0       	push   $0xf012506c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 a2 50 12 f0       	push   $0xf01250a2
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 eb 7f 01 00       	call   f011e7c2 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01067fb:	e8 45 8e 00 00       	call   f010f645 <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f0106808:	8b 04 85 4c e9 17 f0 	mov    -0xfe816b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 8a 4b 00 00       	call   f010b3a3 <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 a5 4b 00 00       	call   f010b3cc <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 93 7f 01 00       	call   f011e7c8 <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 89 4b 00 00       	call   f010b3cc <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 71 4b 00 00       	call   f010b3cc <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 de 4d 00 00       	call   f010b647 <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 b4 50 12 f0       	push   $0xf01250b4
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 a2 50 12 f0       	push   $0xf01250a2
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 e5 4a 00 00       	call   f010b3a3 <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 eb 50 12 f0       	push   $0xf01250eb
f01068d2:	68 05 51 12 f0       	push   $0xf0125105
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 a2 50 12 f0       	push   $0xf01250a2
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 1a 51 12 f0       	push   $0xf012511a
f01068fd:	68 05 51 12 f0       	push   $0xf0125105
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 a2 50 12 f0       	push   $0xf01250a2
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 17 4d 00 00       	call   f010b630 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 a9 4a 00 00       	call   f010b3cc <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106990:	e8 37 8d 00 00       	call   f010f6cc <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 04 da 6b f0 01 	movb   $0x1,0xf06bda04
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 3b 28 00 00       	call   f0109204 <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 50 d3 6b f0       	mov    %eax,0xf06bd350
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 22 28 00 00       	call   f0109204 <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 84 d6 6b f0       	mov    %eax,0xf06bd684
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 30 51 12 f0       	push   $0xf0125130
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 b4 d7 6b f0 00 	movl   $0x0,0xf06bd7b4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 58 51 12 f0       	push   $0xf0125158
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 a2 50 12 f0       	push   $0xf01250a2
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 58 51 12 f0       	push   $0xf0125158
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 a2 50 12 f0       	push   $0xf01250a2
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106ab4:	e8 a5 8d 00 00       	call   f010f85e <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 6c 51 12 f0       	push   $0xf012516c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 a2 50 12 f0       	push   $0xf01250a2
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 c0 48 00 00       	call   f010b3a3 <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106b3d:	e8 1c 8d 00 00       	call   f010f85e <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 b8 51 12 f0       	push   $0xf01251b8
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 a2 50 12 f0       	push   $0xf01250a2
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 58 51 12 f0       	push   $0xf0125158
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 a2 50 12 f0       	push   $0xf01250a2
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106b85:	e8 d4 8c 00 00       	call   f010f85e <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 08 52 12 f0       	push   $0xf0125208
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 a2 50 12 f0       	push   $0xf01250a2
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 58 51 12 f0       	push   $0xf0125158
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 a2 50 12 f0       	push   $0xf01250a2
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 58 51 12 f0       	push   $0xf0125158
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 a2 50 12 f0       	push   $0xf01250a2
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 68 d9 6b f0       	mov    0xf06bd968,%eax
f0106bea:	8b 15 6c d9 6b f0    	mov    0xf06bd96c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 68 d9 6b f0       	mov    %eax,0xf06bd968
f0106bfb:	89 15 6c d9 6b f0    	mov    %edx,0xf06bd96c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 9d 47 00 00       	call   f010b3a3 <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 b1 83 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 86 48 00 00       	call   f010b4c5 <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 55 47 00 00       	call   f010b3a3 <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 24 2a 00 00       	call   f01096a7 <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 21 29 00 00       	call   f01095e3 <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 f7 29 00 00       	call   f0109783 <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 dd 29 00 00       	call   f01097a7 <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 cc 47 69 f0 01 	movl   $0x1,0xf06947cc
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 a0 d4 6b f0       	mov    $0xf06bd4a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 de 58 00 00       	call   f010ca73 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 4c 86 01 00       	call   f011f7f4 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 55 52 12 f0       	push   $0xf0125255
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 6c 52 12 f0       	push   $0xf012526c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 7b 52 12 f0       	push   $0xf012527b
f010727e:	6a 61                	push   $0x61
f0107280:	68 6c 52 12 f0       	push   $0xf012526c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 7c d9 6b f0       	mov    %eax,0xf06bd97c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 84 52 12 f0       	push   $0xf0125284
f0107662:	6a 57                	push   $0x57
f0107664:	68 b8 52 12 f0       	push   $0xf01252b8
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 a4 da 6b f0       	mov    %eax,0xf06bdaa4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 60 17 f0 	movl   $0xf0176000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 84 52 12 f0       	push   $0xf0125284
f0107693:	6a 63                	push   $0x63
f0107695:	68 b8 52 12 f0       	push   $0xf01252b8
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 f6 1e 00 00       	call   f01095e3 <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 58 d5 6b f0    	mov    0xf06bd558,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 c0 d7 6b f0       	mov    %eax,0xf06bd7c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 80 d0 6b f0       	mov    %eax,0xf06bd080
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 c2 63 01 00       	call   f011db64 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 d8 52 12 f0       	push   $0xf01252d8
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 d0 47 69 f0       	mov    %eax,0xf06947d0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 d0 47 69 f0       	mov    0xf06947d0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 84 52 12 f0       	push   $0xf0125284
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 b8 52 12 f0       	push   $0xf01252b8
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 7c d9 6b f0    	mov    0xf06bd97c,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 c6 72 01 00       	call   f011eb37 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 90 d4 6b f0 19 	movl   $0x19,0xf06bd490
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 78 d9 6b f0 90 	movl   $0xf0b08490,0xf06bd978
f0107899:	84 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 78 d9 6b f0       	mov    %eax,0xf06bd978

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 78 d9 6b f0    	mov    0xf06bd978,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 78 d9 6b f0       	mov    %eax,0xf06bd978

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 05 7f 01 00       	call   f011f7f4 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 00 53 12 f0       	push   $0xf0125300
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 b8 52 12 f0       	push   $0xf01252b8
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 84 52 12 f0       	push   $0xf0125284
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 b8 52 12 f0       	push   $0xf01252b8
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 58 d5 6b f0       	mov    %eax,0xf06bd558

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 30 53 12 f0       	push   $0xf0125330
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 53 53 12 f0       	push   $0xf0125353
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 84 52 12 f0       	push   $0xf0125284
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 b8 52 12 f0       	push   $0xf01252b8
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 84 52 12 f0       	push   $0xf0125284
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 b8 52 12 f0       	push   $0xf01252b8
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 70 53 12 f0       	push   $0xf0125370
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 95 53 12 f0       	push   $0xf0125395
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 60 d3 6b f0 00 	movl   $0x0,0xf06bd360
f0107ddc:	00 00 00 
f0107ddf:	c7 05 64 d3 6b f0 00 	movl   $0x0,0xf06bd364
f0107de6:	00 00 00 
f0107de9:	c7 05 6c d3 6b f0 00 	movl   $0x0,0xf06bd36c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 70 d3 6b f0 00 	movl   $0x0,0xf06bd370
f0107dfa:	00 00 00 
f0107dfd:	c7 05 74 d3 6b f0 00 	movl   $0x0,0xf06bd374
f0107e04:	00 00 00 
f0107e07:	c7 05 7c d3 6b f0 00 	movl   $0x0,0xf06bd37c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 af 53 12 f0       	push   $0xf01253af
f0107e19:	68 80 d3 6b f0       	push   $0xf06bd380
f0107e1e:	e8 f1 77 00 00       	call   f010f614 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 5c d8 6b f0 00 	movl   $0xf0001000,0xf06bd85c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 0c da 6b f0 00 	movl   $0xf0002000,0xf06bda0c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 5c d8 6b f0    	mov    0xf06bd85c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 c0 53 12 f0       	push   $0xf01253c0
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 e3 53 12 f0       	push   $0xf01253e3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0107f37:	8b 1d c0 d7 6b f0    	mov    0xf06bd7c0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f0107f69:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0107f82:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 00 54 12 f0       	push   $0xf0125400
f0108012:	6a 68                	push   $0x68
f0108014:	68 e3 53 12 f0       	push   $0xf01253e3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 c0 53 12 f0       	push   $0xf01253c0
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 e3 53 12 f0       	push   $0xf01253e3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0108108:	8b 1d c0 d7 6b f0    	mov    0xf06bd7c0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f010813a:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0108153:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 48 76 01 00       	call   f011f7f4 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 80 d3 6b f0       	push   $0xf06bd380
f01081c0:	e8 99 76 00 00       	call   f010f85e <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 80 d3 6b f0       	push   $0xf06bd380
f01081d9:	e8 67 74 00 00       	call   f010f645 <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 34 54 12 f0       	push   $0xf0125434
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 e3 53 12 f0       	push   $0xf01253e3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 81 54 12 f0       	push   $0xf0125481
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 e3 53 12 f0       	push   $0xf01253e3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 1b 14 00 00       	call   f01096f0 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 80 d3 6b f0       	push   $0xf06bd380
f01082f7:	e8 d0 73 00 00       	call   f010f6cc <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 80 d3 6b f0       	push   $0xf06bd380
f0108314:	e8 45 75 00 00       	call   f010f85e <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 80 d3 6b f0       	push   $0xf06bd380
f010832d:	e8 13 73 00 00       	call   f010f645 <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 c0 53 12 f0       	push   $0xf01253c0
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 e3 53 12 f0       	push   $0xf01253e3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 60 d3 6b f0       	mov    0xf06bd360,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 80 d3 6b f0       	push   $0xf06bd380
f01083b4:	e8 13 73 00 00       	call   f010f6cc <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 77 11 00 00       	call   f01095a7 <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 a0 54 12 f0       	push   $0xf01254a0
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 e3 53 12 f0       	push   $0xf01253e3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 1a 6c 00 00       	call   f010f0c4 <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 c9 10 00 00       	call   f01095a7 <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 a0 54 12 f0       	push   $0xf01254a0
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 e3 53 12 f0       	push   $0xf01253e3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 ab 0c 00 00       	call   f0109204 <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 cf 54 12 f0       	push   $0xf01254cf
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 e3 53 12 f0       	push   $0xf01253e3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 af 0f 00 00       	call   f010954a <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 3f 72 01 00       	call   f011f7f4 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 a0 54 12 f0       	push   $0xf01254a0
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 e3 53 12 f0       	push   $0xf01253e3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 87 71 01 00       	call   f011f7f4 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ec 54 12 f0       	push   $0xf01254ec
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 df 0c 00 00       	call   f01095a7 <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 a0 54 12 f0       	push   $0xf01254a0
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 e3 53 12 f0       	push   $0xf01253e3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 80 d3 6b f0       	push   $0xf06bd380
f0108987:	e8 d2 6e 00 00       	call   f010f85e <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 80 d3 6b f0       	push   $0xf06bd380
f01089a0:	e8 a0 6c 00 00       	call   f010f645 <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 60 d3 6b f0       	mov    0xf06bd360,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 68 d3 6b f0       	mov    0xf06bd368,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 68 d3 6b f0       	mov    %eax,0xf06bd368
f01089e3:	a1 68 d3 6b f0       	mov    0xf06bd368,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 7c d3 6b f0       	mov    0xf06bd37c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 80 d3 6b f0       	push   $0xf06bd380
f0108a08:	e8 bf 6c 00 00       	call   f010f6cc <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 20 d2 6b f0 00 	movl   $0x0,0xf06bd220
f0108a51:	00 00 00 
f0108a54:	c7 05 24 d2 6b f0 00 	movl   $0x0,0xf06bd224
f0108a5b:	00 00 00 
f0108a5e:	c7 05 2c d2 6b f0 00 	movl   $0x0,0xf06bd22c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 1c 55 12 f0       	push   $0xf012551c
f0108a70:	68 30 d2 6b f0       	push   $0xf06bd230
f0108a75:	e8 9a 6b 00 00       	call   f010f614 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 44 01 00 00       	call   f0108bd8 <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 6c d3 6b f0    	mov    0xf06bd36c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 2c 07 00 00       	call   f0109204 <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>

	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 f5 6c 01 00       	call   f011f7f4 <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp


	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share*));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 04                	push   $0x4
f0108b41:	e8 be 06 00 00       	call   f0109204 <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)

	created_share->references=1;
f0108b4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b4f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)((int)created_share & 0x7FFFFFFF); //mask
f0108b56:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b59:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
f0108b5e:	89 c2                	mov    %eax,%edx
f0108b60:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b63:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b65:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b68:	83 ec 0c             	sub    $0xc,%esp
f0108b6b:	50                   	push   %eax
f0108b6c:	e8 3e ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b71:	83 c4 10             	add    $0x10,%esp
f0108b74:	89 c2                	mov    %eax,%edx
f0108b76:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b79:	89 50 54             	mov    %edx,0x54(%eax)
	created_share->ownerID=ownerID;
f0108b7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b7f:	8b 55 08             	mov    0x8(%ebp),%edx
f0108b82:	89 50 04             	mov    %edx,0x4(%eax)

	strncpy(created_share->name, shareName,sizeof(created_share->name) - 1);
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	83 c0 08             	add    $0x8,%eax
f0108b8b:	83 ec 04             	sub    $0x4,%esp
f0108b8e:	6a 3f                	push   $0x3f
f0108b90:	ff 75 0c             	pushl  0xc(%ebp)
f0108b93:	50                   	push   %eax
f0108b94:	e8 ea 6a 01 00       	call   f011f683 <strncpy>
f0108b99:	83 c4 10             	add    $0x10,%esp

	created_share->size=size;
f0108b9c:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ba2:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108ba5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ba8:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bab:	88 50 50             	mov    %dl,0x50(%eax)



	if(created_share==NULL || created_share->framesStorage==NULL)
f0108bae:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108bb2:	74 0a                	je     f0108bbe <create_share+0xb7>
f0108bb4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb7:	8b 40 54             	mov    0x54(%eax),%eax
f0108bba:	85 c0                	test   %eax,%eax
f0108bbc:	75 15                	jne    f0108bd3 <create_share+0xcc>
	{
		kfree((void*)created_share);
f0108bbe:	83 ec 0c             	sub    $0xc,%esp
f0108bc1:	ff 75 e8             	pushl  -0x18(%ebp)
f0108bc4:	e8 9b 08 00 00       	call   f0109464 <kfree>
f0108bc9:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0108bcc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108bd1:	eb 03                	jmp    f0108bd6 <create_share+0xcf>
	}
	return created_share;
f0108bd3:	8b 45 e8             	mov    -0x18(%ebp),%eax

}
f0108bd6:	c9                   	leave  
f0108bd7:	c3                   	ret    

f0108bd8 <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bd8:	55                   	push   %ebp
f0108bd9:	89 e5                	mov    %esp,%ebp
f0108bdb:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108bde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108be5:	83 ec 0c             	sub    $0xc,%esp
f0108be8:	68 30 d2 6b f0       	push   $0xf06bd230
f0108bed:	e8 53 6a 00 00       	call   f010f645 <acquire_spinlock>
f0108bf2:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bf5:	a1 20 d2 6b f0       	mov    0xf06bd220,%eax
f0108bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108bfd:	eb 41                	jmp    f0108c40 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108bff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c02:	8b 40 04             	mov    0x4(%eax),%eax
f0108c05:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c08:	75 2e                	jne    f0108c38 <get_share+0x60>
f0108c0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c0d:	83 c0 08             	add    $0x8,%eax
f0108c10:	83 ec 08             	sub    $0x8,%esp
f0108c13:	ff 75 0c             	pushl  0xc(%ebp)
f0108c16:	50                   	push   %eax
f0108c17:	e8 f6 6a 01 00       	call   f011f712 <strcmp>
f0108c1c:	83 c4 10             	add    $0x10,%esp
f0108c1f:	85 c0                	test   %eax,%eax
f0108c21:	75 15                	jne    f0108c38 <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c23:	83 ec 0c             	sub    $0xc,%esp
f0108c26:	68 30 d2 6b f0       	push   $0xf06bd230
f0108c2b:	e8 9c 6a 00 00       	call   f010f6cc <release_spinlock>
f0108c30:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c36:	eb 44                	jmp    f0108c7c <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c38:	a1 28 d2 6b f0       	mov    0xf06bd228,%eax
f0108c3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c44:	74 08                	je     f0108c4e <get_share+0x76>
f0108c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c49:	8b 40 58             	mov    0x58(%eax),%eax
f0108c4c:	eb 05                	jmp    f0108c53 <get_share+0x7b>
f0108c4e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c53:	a3 28 d2 6b f0       	mov    %eax,0xf06bd228
f0108c58:	a1 28 d2 6b f0       	mov    0xf06bd228,%eax
f0108c5d:	85 c0                	test   %eax,%eax
f0108c5f:	75 9e                	jne    f0108bff <get_share+0x27>
f0108c61:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c65:	75 98                	jne    f0108bff <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c67:	83 ec 0c             	sub    $0xc,%esp
f0108c6a:	68 30 d2 6b f0       	push   $0xf06bd230
f0108c6f:	e8 58 6a 00 00       	call   f010f6cc <release_spinlock>
f0108c74:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c77:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c7c:	c9                   	leave  
f0108c7d:	c3                   	ret    

f0108c7e <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c7e:	55                   	push   %ebp
f0108c7f:	89 e5                	mov    %esp,%ebp
f0108c81:	83 ec 48             	sub    $0x48,%esp
f0108c84:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c87:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c8a:	e8 14 27 00 00       	call   f010b3a3 <get_cpu_proc>
f0108c8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c92:	83 ec 08             	sub    $0x8,%esp
f0108c95:	ff 75 0c             	pushl  0xc(%ebp)
f0108c98:	ff 75 08             	pushl  0x8(%ebp)
f0108c9b:	e8 38 ff ff ff       	call   f0108bd8 <get_share>
f0108ca0:	83 c4 10             	add    $0x10,%esp
f0108ca3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108ca6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108caa:	74 0a                	je     f0108cb6 <createSharedObject+0x38>
f0108cac:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb1:	e9 7e 01 00 00       	jmp    f0108e34 <createSharedObject+0x1b6>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cb6:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cba:	50                   	push   %eax
f0108cbb:	ff 75 10             	pushl  0x10(%ebp)
f0108cbe:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc1:	ff 75 08             	pushl  0x8(%ebp)
f0108cc4:	e8 3e fe ff ff       	call   f0108b07 <create_share>
f0108cc9:	83 c4 10             	add    $0x10,%esp
f0108ccc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108ccf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cd3:	75 0a                	jne    f0108cdf <createSharedObject+0x61>
f0108cd5:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108cda:	e9 55 01 00 00       	jmp    f0108e34 <createSharedObject+0x1b6>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108cdf:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ce6:	8b 55 10             	mov    0x10(%ebp),%edx
f0108ce9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cec:	01 d0                	add    %edx,%eax
f0108cee:	48                   	dec    %eax
f0108cef:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cf5:	ba 00 00 00 00       	mov    $0x0,%edx
f0108cfa:	f7 75 e4             	divl   -0x1c(%ebp)
f0108cfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d00:	29 d0                	sub    %edx,%eax
f0108d02:	c1 e8 0c             	shr    $0xc,%eax
f0108d05:	89 45 dc             	mov    %eax,-0x24(%ebp)

	for (int k = 0; k < num_pages; k++)
f0108d08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d0f:	e9 8a 00 00 00       	jmp    f0108d9e <createSharedObject+0x120>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d14:	83 ec 0c             	sub    $0xc,%esp
f0108d17:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d1a:	50                   	push   %eax
f0108d1b:	e8 92 f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d20:	83 c4 10             	add    $0x10,%esp
f0108d23:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret != E_NO_MEM)
f0108d26:	83 7d d8 fc          	cmpl   $0xfffffffc,-0x28(%ebp)
f0108d2a:	74 5b                	je     f0108d87 <createSharedObject+0x109>
		{
			cprintf("VA: %x\n",(uint32)(virtual_address + (k * PAGE_SIZE)));
f0108d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d2f:	c1 e0 0c             	shl    $0xc,%eax
f0108d32:	89 c2                	mov    %eax,%edx
f0108d34:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d37:	01 d0                	add    %edx,%eax
f0108d39:	83 ec 08             	sub    $0x8,%esp
f0108d3c:	50                   	push   %eax
f0108d3d:	68 28 55 12 f0       	push   $0xf0125528
f0108d42:	e8 44 82 ff ff       	call   f0100f8b <cprintf>
f0108d47:	83 c4 10             	add    $0x10,%esp
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_WRITEABLE);
f0108d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d4d:	c1 e0 0c             	shl    $0xc,%eax
f0108d50:	89 c2                	mov    %eax,%edx
f0108d52:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d55:	01 d0                	add    %edx,%eax
f0108d57:	89 c1                	mov    %eax,%ecx
f0108d59:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d5f:	8b 40 64             	mov    0x64(%eax),%eax
f0108d62:	6a 02                	push   $0x2
f0108d64:	51                   	push   %ecx
f0108d65:	52                   	push   %edx
f0108d66:	50                   	push   %eax
f0108d67:	e8 13 f9 ff ff       	call   f010867f <map_frame>
f0108d6c:	83 c4 10             	add    $0x10,%esp
			//pt_set_page_permissions(myenv->env_page_directory, (uint32)(virtual_address + (k * PAGE_SIZE)), 0, PERM_PRESENT);
			created_share->framesStorage[k] = ptr_frame_info;
f0108d6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d72:	8b 40 54             	mov    0x54(%eax),%eax
f0108d75:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d78:	c1 e2 02             	shl    $0x2,%edx
f0108d7b:	01 c2                	add    %eax,%edx
f0108d7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d80:	89 02                	mov    %eax,(%edx)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d82:	ff 45 f4             	incl   -0xc(%ebp)
f0108d85:	eb 17                	jmp    f0108d9e <createSharedObject+0x120>
			//pt_set_page_permissions(myenv->env_page_directory, (uint32)(virtual_address + (k * PAGE_SIZE)), 0, PERM_PRESENT);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0108d87:	83 ec 04             	sub    $0x4,%esp
f0108d8a:	68 30 55 12 f0       	push   $0xf0125530
f0108d8f:	68 b1 00 00 00       	push   $0xb1
f0108d94:	68 3c 55 12 f0       	push   $0xf012553c
f0108d99:	e8 9b 75 ff ff       	call   f0100339 <_panic>
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108da1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108da4:	0f 82 6a ff ff ff    	jb     f0108d14 <createSharedObject+0x96>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108daa:	83 ec 0c             	sub    $0xc,%esp
f0108dad:	68 30 d2 6b f0       	push   $0xf06bd230
f0108db2:	e8 8e 68 00 00       	call   f010f645 <acquire_spinlock>
f0108db7:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108dba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108dbe:	75 17                	jne    f0108dd7 <createSharedObject+0x159>
f0108dc0:	83 ec 04             	sub    $0x4,%esp
f0108dc3:	68 60 55 12 f0       	push   $0xf0125560
f0108dc8:	68 b6 00 00 00       	push   $0xb6
f0108dcd:	68 3c 55 12 f0       	push   $0xf012553c
f0108dd2:	e8 62 75 ff ff       	call   f0100339 <_panic>
f0108dd7:	8b 15 24 d2 6b f0    	mov    0xf06bd224,%edx
f0108ddd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de0:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108de3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de6:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108de9:	85 c0                	test   %eax,%eax
f0108deb:	74 0d                	je     f0108dfa <createSharedObject+0x17c>
f0108ded:	a1 24 d2 6b f0       	mov    0xf06bd224,%eax
f0108df2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108df5:	89 50 58             	mov    %edx,0x58(%eax)
f0108df8:	eb 08                	jmp    f0108e02 <createSharedObject+0x184>
f0108dfa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dfd:	a3 20 d2 6b f0       	mov    %eax,0xf06bd220
f0108e02:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e05:	a3 24 d2 6b f0       	mov    %eax,0xf06bd224
f0108e0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e0d:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108e14:	a1 2c d2 6b f0       	mov    0xf06bd22c,%eax
f0108e19:	40                   	inc    %eax
f0108e1a:	a3 2c d2 6b f0       	mov    %eax,0xf06bd22c
	release_spinlock(&AllShares.shareslock);
f0108e1f:	83 ec 0c             	sub    $0xc,%esp
f0108e22:	68 30 d2 6b f0       	push   $0xf06bd230
f0108e27:	e8 a0 68 00 00       	call   f010f6cc <release_spinlock>
f0108e2c:	83 c4 10             	add    $0x10,%esp

	return created_share->ID;
f0108e2f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e32:	8b 00                	mov    (%eax),%eax
}
f0108e34:	c9                   	leave  
f0108e35:	c3                   	ret    

f0108e36 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e36:	55                   	push   %ebp
f0108e37:	89 e5                	mov    %esp,%ebp
f0108e39:	53                   	push   %ebx
f0108e3a:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e3d:	e8 61 25 00 00       	call   f010b3a3 <get_cpu_proc>
f0108e42:	89 45 f0             	mov    %eax,-0x10(%ebp)

	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e45:	83 ec 08             	sub    $0x8,%esp
f0108e48:	ff 75 0c             	pushl  0xc(%ebp)
f0108e4b:	ff 75 08             	pushl  0x8(%ebp)
f0108e4e:	e8 85 fd ff ff       	call   f0108bd8 <get_share>
f0108e53:	83 c4 10             	add    $0x10,%esp
f0108e56:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e59:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e5d:	75 0a                	jne    f0108e69 <getSharedObject+0x33>
f0108e5f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e64:	e9 9d 00 00 00       	jmp    f0108f06 <getSharedObject+0xd0>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e69:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e73:	8b 40 48             	mov    0x48(%eax),%eax
f0108e76:	89 c2                	mov    %eax,%edx
f0108e78:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e7b:	01 d0                	add    %edx,%eax
f0108e7d:	48                   	dec    %eax
f0108e7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e84:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e89:	f7 75 e8             	divl   -0x18(%ebp)
f0108e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e8f:	29 d0                	sub    %edx,%eax
f0108e91:	85 c0                	test   %eax,%eax
f0108e93:	79 05                	jns    f0108e9a <getSharedObject+0x64>
f0108e95:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e9a:	c1 f8 0c             	sar    $0xc,%eax
f0108e9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ea0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108ea7:	eb 41                	jmp    f0108eea <getSharedObject+0xb4>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),shared_obj->isWritable * PERM_WRITEABLE);
f0108ea9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eac:	8a 40 50             	mov    0x50(%eax),%al
f0108eaf:	0f b6 c0             	movzbl %al,%eax
f0108eb2:	01 c0                	add    %eax,%eax
f0108eb4:	89 c3                	mov    %eax,%ebx
f0108eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108eb9:	c1 e0 0c             	shl    $0xc,%eax
f0108ebc:	89 c2                	mov    %eax,%edx
f0108ebe:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ec1:	01 d0                	add    %edx,%eax
f0108ec3:	89 c1                	mov    %eax,%ecx
f0108ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ec8:	8b 40 54             	mov    0x54(%eax),%eax
f0108ecb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ece:	c1 e2 02             	shl    $0x2,%edx
f0108ed1:	01 d0                	add    %edx,%eax
f0108ed3:	8b 10                	mov    (%eax),%edx
f0108ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ed8:	8b 40 64             	mov    0x64(%eax),%eax
f0108edb:	53                   	push   %ebx
f0108edc:	51                   	push   %ecx
f0108edd:	52                   	push   %edx
f0108ede:	50                   	push   %eax
f0108edf:	e8 9b f7 ff ff       	call   f010867f <map_frame>
f0108ee4:	83 c4 10             	add    $0x10,%esp
	struct Env* myenv = get_cpu_proc(); //The calling environment

	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ee7:	ff 45 f4             	incl   -0xc(%ebp)
f0108eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108eed:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108ef0:	72 b7                	jb     f0108ea9 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),shared_obj->isWritable * PERM_WRITEABLE);
	}

	shared_obj->references++;
f0108ef2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ef5:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108ef8:	8d 50 01             	lea    0x1(%eax),%edx
f0108efb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108efe:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0108f01:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f04:	8b 00                	mov    (%eax),%eax
}
f0108f06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108f09:	c9                   	leave  
f0108f0a:	c3                   	ret    

f0108f0b <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108f0b:	55                   	push   %ebp
f0108f0c:	89 e5                	mov    %esp,%ebp
f0108f0e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108f11:	83 ec 04             	sub    $0x4,%esp
f0108f14:	68 84 55 12 f0       	push   $0xf0125584
f0108f19:	68 e2 00 00 00       	push   $0xe2
f0108f1e:	68 3c 55 12 f0       	push   $0xf012553c
f0108f23:	e8 11 74 ff ff       	call   f0100339 <_panic>

f0108f28 <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108f28:	55                   	push   %ebp
f0108f29:	89 e5                	mov    %esp,%ebp
f0108f2b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108f2e:	83 ec 04             	sub    $0x4,%esp
f0108f31:	68 a8 55 12 f0       	push   $0xf01255a8
f0108f36:	68 ed 00 00 00       	push   $0xed
f0108f3b:	68 3c 55 12 f0       	push   $0xf012553c
f0108f40:	e8 f4 73 ff ff       	call   f0100339 <_panic>

f0108f45 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0108f45:	55                   	push   %ebp
f0108f46:	89 e5                	mov    %esp,%ebp
f0108f48:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0108f4d:	83 f8 01             	cmp    $0x1,%eax
f0108f50:	75 04                	jne    f0108f56 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0108f52:	b0 01                	mov    $0x1,%al
f0108f54:	eb 02                	jmp    f0108f58 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0108f56:	b0 00                	mov    $0x0,%al
f0108f58:	5d                   	pop    %ebp
f0108f59:	c3                   	ret    

f0108f5a <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0108f5a:	55                   	push   %ebp
f0108f5b:	89 e5                	mov    %esp,%ebp
f0108f5d:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0108f62:	83 f8 02             	cmp    $0x2,%eax
f0108f65:	75 04                	jne    f0108f6b <isKHeapPlacementStrategyBESTFIT+0x11>
f0108f67:	b0 01                	mov    $0x1,%al
f0108f69:	eb 02                	jmp    f0108f6d <isKHeapPlacementStrategyBESTFIT+0x13>
f0108f6b:	b0 00                	mov    $0x0,%al
f0108f6d:	5d                   	pop    %ebp
f0108f6e:	c3                   	ret    

f0108f6f <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108f6f:	55                   	push   %ebp
f0108f70:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f75:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0108f7b:	29 d0                	sub    %edx,%eax
f0108f7d:	c1 f8 03             	sar    $0x3,%eax
f0108f80:	89 c2                	mov    %eax,%edx
f0108f82:	89 d0                	mov    %edx,%eax
f0108f84:	c1 e0 02             	shl    $0x2,%eax
f0108f87:	01 d0                	add    %edx,%eax
f0108f89:	c1 e0 02             	shl    $0x2,%eax
f0108f8c:	01 d0                	add    %edx,%eax
f0108f8e:	c1 e0 02             	shl    $0x2,%eax
f0108f91:	01 d0                	add    %edx,%eax
f0108f93:	89 c1                	mov    %eax,%ecx
f0108f95:	c1 e1 08             	shl    $0x8,%ecx
f0108f98:	01 c8                	add    %ecx,%eax
f0108f9a:	89 c1                	mov    %eax,%ecx
f0108f9c:	c1 e1 10             	shl    $0x10,%ecx
f0108f9f:	01 c8                	add    %ecx,%eax
f0108fa1:	01 c0                	add    %eax,%eax
f0108fa3:	01 d0                	add    %edx,%eax
}
f0108fa5:	5d                   	pop    %ebp
f0108fa6:	c3                   	ret    

f0108fa7 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108fa7:	55                   	push   %ebp
f0108fa8:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108faa:	ff 75 08             	pushl  0x8(%ebp)
f0108fad:	e8 bd ff ff ff       	call   f0108f6f <to_frame_number>
f0108fb2:	83 c4 04             	add    $0x4,%esp
f0108fb5:	c1 e0 0c             	shl    $0xc,%eax
}
f0108fb8:	c9                   	leave  
f0108fb9:	c3                   	ret    

f0108fba <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108fba:	55                   	push   %ebp
f0108fbb:	89 e5                	mov    %esp,%ebp
f0108fbd:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0108fc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fc3:	a3 08 da 6b f0       	mov    %eax,0xf06bda08
	hard_limit = daLimit;
f0108fc8:	8b 45 10             	mov    0x10(%ebp),%eax
f0108fcb:	a3 54 d8 6b f0       	mov    %eax,0xf06bd854
	brk = daStart + initSizeToAllocate;
f0108fd0:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108fd6:	01 d0                	add    %edx,%eax
f0108fd8:	a3 00 da 6b f0       	mov    %eax,0xf06bda00

	if(brk > daLimit) panic("exceeds Limit");
f0108fdd:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f0108fe2:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108fe5:	76 14                	jbe    f0108ffb <initialize_kheap_dynamic_allocator+0x41>
f0108fe7:	83 ec 04             	sub    $0x4,%esp
f0108fea:	68 d0 55 12 f0       	push   $0xf01255d0
f0108fef:	6a 1a                	push   $0x1a
f0108ff1:	68 de 55 12 f0       	push   $0xf01255de
f0108ff6:	e8 3e 73 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0108ffb:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0109002:	8b 45 10             	mov    0x10(%ebp),%eax
f0109005:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f0109008:	8b 45 0c             	mov    0xc(%ebp),%eax
f010900b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f010900e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109011:	c1 e8 0c             	shr    $0xc,%eax
f0109014:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f0109017:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010901e:	e9 8a 00 00 00       	jmp    f01090ad <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0109023:	83 ec 0c             	sub    $0xc,%esp
f0109026:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0109029:	50                   	push   %eax
f010902a:	e8 83 f1 ff ff       	call   f01081b2 <allocate_frame>
f010902f:	83 c4 10             	add    $0x10,%esp
f0109032:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f0109035:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0109039:	74 5e                	je     f0109099 <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f010903b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010903e:	c1 e0 0c             	shl    $0xc,%eax
f0109041:	89 c2                	mov    %eax,%edx
f0109043:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109046:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109049:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010904c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109051:	6a 02                	push   $0x2
f0109053:	51                   	push   %ecx
f0109054:	52                   	push   %edx
f0109055:	50                   	push   %eax
f0109056:	e8 24 f6 ff ff       	call   f010867f <map_frame>
f010905b:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f010905e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109061:	c1 e0 0c             	shl    $0xc,%eax
f0109064:	89 c2                	mov    %eax,%edx
f0109066:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109069:	01 d0                	add    %edx,%eax
f010906b:	83 ec 0c             	sub    $0xc,%esp
f010906e:	50                   	push   %eax
f010906f:	e8 d6 04 00 00       	call   f010954a <kheap_physical_address>
f0109074:	83 c4 10             	add    $0x10,%esp
f0109077:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f010907a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010907d:	c1 e8 0c             	shr    $0xc,%eax
f0109080:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109083:	c1 e2 0c             	shl    $0xc,%edx
f0109086:	89 d1                	mov    %edx,%ecx
f0109088:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010908b:	01 ca                	add    %ecx,%edx
f010908d:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109094:	ff 45 f4             	incl   -0xc(%ebp)
f0109097:	eb 14                	jmp    f01090ad <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0109099:	83 ec 04             	sub    $0x4,%esp
f010909c:	68 ef 55 12 f0       	push   $0xf01255ef
f01090a1:	6a 2f                	push   $0x2f
f01090a3:	68 de 55 12 f0       	push   $0xf01255de
f01090a8:	e8 8c 72 ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f01090ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090b0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01090b3:	0f 82 6a ff ff ff    	jb     f0109023 <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f01090b9:	83 ec 08             	sub    $0x8,%esp
f01090bc:	ff 75 0c             	pushl  0xc(%ebp)
f01090bf:	ff 75 08             	pushl  0x8(%ebp)
f01090c2:	e8 0e 71 01 00       	call   f01201d5 <initialize_dynamic_allocator>
f01090c7:	83 c4 10             	add    $0x10,%esp

	return 0;
f01090ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01090cf:	c9                   	leave  
f01090d0:	c3                   	ret    

f01090d1 <sbrk>:

void* sbrk(int numOfPages)
{
f01090d1:	55                   	push   %ebp
f01090d2:	89 e5                	mov    %esp,%ebp
f01090d4:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01090d7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01090db:	0f 8e d6 00 00 00    	jle    f01091b7 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f01090e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e4:	c1 e0 0c             	shl    $0xc,%eax
f01090e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01090ea:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f01090ef:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01090f2:	8b 15 00 da 6b f0    	mov    0xf06bda00,%edx
f01090f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090fb:	01 c2                	add    %eax,%edx
f01090fd:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f0109102:	39 c2                	cmp    %eax,%edx
f0109104:	76 0a                	jbe    f0109110 <sbrk+0x3f>
f0109106:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010910b:	e9 b9 00 00 00       	jmp    f01091c9 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f0109110:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109117:	eb 7d                	jmp    f0109196 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f0109119:	83 ec 0c             	sub    $0xc,%esp
f010911c:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010911f:	50                   	push   %eax
f0109120:	e8 8d f0 ff ff       	call   f01081b2 <allocate_frame>
f0109125:	83 c4 10             	add    $0x10,%esp
f0109128:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f010912b:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f010912f:	74 5e                	je     f010918f <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f0109131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109134:	c1 e0 0c             	shl    $0xc,%eax
f0109137:	89 c2                	mov    %eax,%edx
f0109139:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010913c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010913f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109142:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109147:	6a 02                	push   $0x2
f0109149:	51                   	push   %ecx
f010914a:	52                   	push   %edx
f010914b:	50                   	push   %eax
f010914c:	e8 2e f5 ff ff       	call   f010867f <map_frame>
f0109151:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f0109154:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109157:	c1 e0 0c             	shl    $0xc,%eax
f010915a:	89 c2                	mov    %eax,%edx
f010915c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010915f:	01 d0                	add    %edx,%eax
f0109161:	83 ec 0c             	sub    $0xc,%esp
f0109164:	50                   	push   %eax
f0109165:	e8 e0 03 00 00       	call   f010954a <kheap_physical_address>
f010916a:	83 c4 10             	add    $0x10,%esp
f010916d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f0109170:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109173:	c1 e8 0c             	shr    $0xc,%eax
f0109176:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109179:	c1 e2 0c             	shl    $0xc,%edx
f010917c:	89 d1                	mov    %edx,%ecx
f010917e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109181:	01 ca                	add    %ecx,%edx
f0109183:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f010918a:	ff 45 f4             	incl   -0xc(%ebp)
f010918d:	eb 07                	jmp    f0109196 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f010918f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109194:	eb 33                	jmp    f01091c9 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109196:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109199:	3b 45 08             	cmp    0x8(%ebp),%eax
f010919c:	0f 8c 77 ff ff ff    	jl     f0109119 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f01091a2:	8b 15 00 da 6b f0    	mov    0xf06bda00,%edx
f01091a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091ab:	01 d0                	add    %edx,%eax
f01091ad:	a3 00 da 6b f0       	mov    %eax,0xf06bda00
		return (void *)prev_brk;
f01091b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091b5:	eb 12                	jmp    f01091c9 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f01091b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01091bb:	75 07                	jne    f01091c4 <sbrk+0xf3>
	{
		return (void *) brk;
f01091bd:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f01091c2:	eb 05                	jmp    f01091c9 <sbrk+0xf8>
	}

	return (void *)-1;
f01091c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f01091c9:	c9                   	leave  
f01091ca:	c3                   	ret    

f01091cb <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f01091cb:	55                   	push   %ebp
f01091cc:	89 e5                	mov    %esp,%ebp
f01091ce:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f01091d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01091d8:	83 ec 04             	sub    $0x4,%esp
f01091db:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01091de:	50                   	push   %eax
f01091df:	ff 75 0c             	pushl  0xc(%ebp)
f01091e2:	ff 75 08             	pushl  0x8(%ebp)
f01091e5:	e8 7f f5 ff ff       	call   f0108769 <get_frame_info>
f01091ea:	83 c4 10             	add    $0x10,%esp
f01091ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01091f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01091f4:	75 07                	jne    f01091fd <isPageAllocated+0x32>
f01091f6:	b8 00 00 00 00       	mov    $0x0,%eax
f01091fb:	eb 05                	jmp    f0109202 <isPageAllocated+0x37>
	return 1;
f01091fd:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0109202:	c9                   	leave  
f0109203:	c3                   	ret    

f0109204 <kmalloc>:

void *kmalloc(unsigned int size)
{
f0109204:	55                   	push   %ebp
f0109205:	89 e5                	mov    %esp,%ebp
f0109207:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f010920a:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0109211:	8b 55 08             	mov    0x8(%ebp),%edx
f0109214:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109217:	01 d0                	add    %edx,%eax
f0109219:	48                   	dec    %eax
f010921a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010921d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109220:	ba 00 00 00 00       	mov    $0x0,%edx
f0109225:	f7 75 d8             	divl   -0x28(%ebp)
f0109228:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010922b:	29 d0                	sub    %edx,%eax
f010922d:	c1 e8 0c             	shr    $0xc,%eax
f0109230:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f0109233:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f010923a:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f010923f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109242:	29 c2                	sub    %eax,%edx
f0109244:	89 d0                	mov    %edx,%eax
f0109246:	48                   	dec    %eax
f0109247:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010924a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010924d:	ba 00 00 00 00       	mov    $0x0,%edx
f0109252:	f7 75 cc             	divl   -0x34(%ebp)
f0109255:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109258:	29 d0                	sub    %edx,%eax
f010925a:	c1 e8 0c             	shr    $0xc,%eax
f010925d:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f0109260:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109267:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f010926e:	77 42                	ja     f01092b2 <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0109270:	e8 d0 fc ff ff       	call   f0108f45 <isKHeapPlacementStrategyFIRSTFIT>
f0109275:	84 c0                	test   %al,%al
f0109277:	74 16                	je     f010928f <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f0109279:	83 ec 0c             	sub    $0xc,%esp
f010927c:	ff 75 08             	pushl  0x8(%ebp)
f010927f:	e8 6d 71 01 00       	call   f01203f1 <alloc_block_FF>
f0109284:	83 c4 10             	add    $0x10,%esp
f0109287:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010928a:	e9 d0 01 00 00       	jmp    f010945f <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f010928f:	e8 c6 fc ff ff       	call   f0108f5a <isKHeapPlacementStrategyBESTFIT>
f0109294:	84 c0                	test   %al,%al
f0109296:	0f 84 c3 01 00 00    	je     f010945f <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f010929c:	83 ec 0c             	sub    $0xc,%esp
f010929f:	ff 75 08             	pushl  0x8(%ebp)
f01092a2:	e8 06 76 01 00       	call   f01208ad <alloc_block_BF>
f01092a7:	83 c4 10             	add    $0x10,%esp
f01092aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01092ad:	e9 ad 01 00 00       	jmp    f010945f <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f01092b2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01092b5:	48                   	dec    %eax
f01092b6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01092b9:	0f 86 99 01 00 00    	jbe    f0109458 <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f01092bf:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01092c4:	05 00 10 00 00       	add    $0x1000,%eax
f01092c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01092cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01092d3:	e9 86 00 00 00       	jmp    f010935e <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01092d8:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01092dd:	83 ec 08             	sub    $0x8,%esp
f01092e0:	ff 75 f0             	pushl  -0x10(%ebp)
f01092e3:	50                   	push   %eax
f01092e4:	e8 e2 fe ff ff       	call   f01091cb <isPageAllocated>
f01092e9:	83 c4 10             	add    $0x10,%esp
f01092ec:	85 c0                	test   %eax,%eax
f01092ee:	75 61                	jne    f0109351 <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01092f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092f3:	05 00 10 00 00       	add    $0x1000,%eax
f01092f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01092fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f0109302:	eb 3d                	jmp    f0109341 <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f0109304:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f010930b:	76 0a                	jbe    f0109317 <kmalloc+0x113>
f010930d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109312:	e9 4b 01 00 00       	jmp    f0109462 <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f0109317:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010931c:	83 ec 08             	sub    $0x8,%esp
f010931f:	ff 75 e8             	pushl  -0x18(%ebp)
f0109322:	50                   	push   %eax
f0109323:	e8 a3 fe ff ff       	call   f01091cb <isPageAllocated>
f0109328:	83 c4 10             	add    $0x10,%esp
f010932b:	85 c0                	test   %eax,%eax
f010932d:	74 08                	je     f0109337 <kmalloc+0x133>
					{

						i = j;
f010932f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109332:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f0109335:	eb 1a                	jmp    f0109351 <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f0109337:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f010933e:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f0109341:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109344:	48                   	dec    %eax
f0109345:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109348:	77 ba                	ja     f0109304 <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f010934a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0109351:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109355:	75 16                	jne    f010936d <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f0109357:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f010935e:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f0109365:	0f 86 6d ff ff ff    	jbe    f01092d8 <kmalloc+0xd4>
f010936b:	eb 01                	jmp    f010936e <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f010936d:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f010936e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109372:	75 0a                	jne    f010937e <kmalloc+0x17a>
f0109374:	b8 00 00 00 00       	mov    $0x0,%eax
f0109379:	e9 e4 00 00 00       	jmp    f0109462 <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f010937e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109385:	eb 57                	jmp    f01093de <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109387:	83 ec 0c             	sub    $0xc,%esp
f010938a:	8d 45 b8             	lea    -0x48(%ebp),%eax
f010938d:	50                   	push   %eax
f010938e:	e8 1f ee ff ff       	call   f01081b2 <allocate_frame>
f0109393:	83 c4 10             	add    $0x10,%esp
f0109396:	89 45 c0             	mov    %eax,-0x40(%ebp)
			//map_frame(ptr_page_directory, ptr_frame_info, i + k * 1024, PERM_USER|PERM_WRITEABLE); REPLACED BY
			if (ret != E_NO_MEM)
f0109399:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f010939d:	74 28                	je     f01093c7 <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
f010939f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093a2:	c1 e0 0c             	shl    $0xc,%eax
f01093a5:	89 c2                	mov    %eax,%edx
f01093a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01093ad:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01093b0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01093b5:	6a 02                	push   $0x2
f01093b7:	51                   	push   %ecx
f01093b8:	52                   	push   %edx
f01093b9:	50                   	push   %eax
f01093ba:	e8 c0 f2 ff ff       	call   f010867f <map_frame>
f01093bf:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01093c2:	ff 45 e0             	incl   -0x20(%ebp)
f01093c5:	eb 17                	jmp    f01093de <kmalloc+0x1da>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
			}
			else
			{
				panic("No Memory");
f01093c7:	83 ec 04             	sub    $0x4,%esp
f01093ca:	68 ef 55 12 f0       	push   $0xf01255ef
f01093cf:	68 b6 00 00 00       	push   $0xb6
f01093d4:	68 de 55 12 f0       	push   $0xf01255de
f01093d9:	e8 5b 6f ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01093de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093e1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01093e4:	72 a1                	jb     f0109387 <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f01093e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093e9:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01093ec:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01093f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01093f4:	29 c2                	sub    %eax,%edx
f01093f6:	89 d0                	mov    %edx,%eax
f01093f8:	2d 00 10 00 00       	sub    $0x1000,%eax
f01093fd:	c1 e8 0c             	shr    $0xc,%eax
f0109400:	89 c2                	mov    %eax,%edx
f0109402:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109405:	89 04 95 a0 bf 6d f0 	mov    %eax,-0xf924060(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f010940c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109413:	eb 39                	jmp    f010944e <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f0109415:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109418:	c1 e0 0c             	shl    $0xc,%eax
f010941b:	89 c2                	mov    %eax,%edx
f010941d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109420:	01 d0                	add    %edx,%eax
f0109422:	83 ec 0c             	sub    $0xc,%esp
f0109425:	50                   	push   %eax
f0109426:	e8 1f 01 00 00       	call   f010954a <kheap_physical_address>
f010942b:	83 c4 10             	add    $0x10,%esp
f010942e:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109431:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109434:	c1 e8 0c             	shr    $0xc,%eax
f0109437:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010943a:	c1 e2 0c             	shl    $0xc,%edx
f010943d:	89 d1                	mov    %edx,%ecx
f010943f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109442:	01 ca                	add    %ecx,%edx
f0109444:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f010944b:	ff 45 dc             	incl   -0x24(%ebp)
f010944e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109451:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109454:	72 bf                	jb     f0109415 <kmalloc+0x211>
f0109456:	eb 07                	jmp    f010945f <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f0109458:	b8 00 00 00 00       	mov    $0x0,%eax
f010945d:	eb 03                	jmp    f0109462 <kmalloc+0x25e>
	}
	return ptr;
f010945f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109462:	c9                   	leave  
f0109463:	c3                   	ret    

f0109464 <kfree>:

void kfree(void *va)
{
f0109464:	55                   	push   %ebp
f0109465:	89 e5                	mov    %esp,%ebp
f0109467:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f010946a:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f010946f:	05 00 10 00 00       	add    $0x1000,%eax
f0109474:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109477:	8b 55 08             	mov    0x8(%ebp),%edx
f010947a:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f010947f:	39 c2                	cmp    %eax,%edx
f0109481:	73 13                	jae    f0109496 <kfree+0x32>
        free_block(va);
f0109483:	83 ec 0c             	sub    $0xc,%esp
f0109486:	ff 75 08             	pushl  0x8(%ebp)
f0109489:	e8 27 7e 01 00       	call   f01212b5 <free_block>
f010948e:	83 c4 10             	add    $0x10,%esp
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f0109491:	e9 b1 00 00 00       	jmp    f0109547 <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109496:	8b 45 08             	mov    0x8(%ebp),%eax
f0109499:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010949c:	0f 82 8e 00 00 00    	jb     f0109530 <kfree+0xcc>
f01094a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01094a5:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01094aa:	0f 87 80 00 00 00    	ja     f0109530 <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f01094b0:	8b 55 08             	mov    0x8(%ebp),%edx
f01094b3:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01094b8:	29 c2                	sub    %eax,%edx
f01094ba:	89 d0                	mov    %edx,%eax
f01094bc:	2d 00 10 00 00       	sub    $0x1000,%eax
f01094c1:	c1 e8 0c             	shr    $0xc,%eax
f01094c4:	8b 04 85 a0 bf 6d f0 	mov    -0xf924060(,%eax,4),%eax
f01094cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f01094ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01094d5:	eb 4f                	jmp    f0109526 <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f01094d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094da:	c1 e0 0c             	shl    $0xc,%eax
f01094dd:	89 c2                	mov    %eax,%edx
f01094df:	8b 45 08             	mov    0x8(%ebp),%eax
f01094e2:	01 d0                	add    %edx,%eax
f01094e4:	83 ec 0c             	sub    $0xc,%esp
f01094e7:	50                   	push   %eax
f01094e8:	e8 5d 00 00 00       	call   f010954a <kheap_physical_address>
f01094ed:	83 c4 10             	add    $0x10,%esp
f01094f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f01094f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01094f6:	c1 e8 0c             	shr    $0xc,%eax
f01094f9:	c7 04 85 a0 3f 70 f0 	movl   $0x0,-0xf8fc060(,%eax,4)
f0109500:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f0109504:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109507:	c1 e0 0c             	shl    $0xc,%eax
f010950a:	89 c2                	mov    %eax,%edx
f010950c:	8b 45 08             	mov    0x8(%ebp),%eax
f010950f:	01 c2                	add    %eax,%edx
f0109511:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109516:	83 ec 08             	sub    $0x8,%esp
f0109519:	52                   	push   %edx
f010951a:	50                   	push   %eax
f010951b:	e8 bf f2 ff ff       	call   f01087df <unmap_frame>
f0109520:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109523:	ff 45 f4             	incl   -0xc(%ebp)
f0109526:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109529:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010952c:	72 a9                	jb     f01094d7 <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f010952e:	eb 17                	jmp    f0109547 <kfree+0xe3>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109530:	83 ec 04             	sub    $0x4,%esp
f0109533:	68 fc 55 12 f0       	push   $0xf01255fc
f0109538:	68 dd 00 00 00       	push   $0xdd
f010953d:	68 de 55 12 f0       	push   $0xf01255de
f0109542:	e8 f2 6d ff ff       	call   f0100339 <_panic>
    }
}
f0109547:	90                   	nop
f0109548:	c9                   	leave  
f0109549:	c3                   	ret    

f010954a <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f010954a:	55                   	push   %ebp
f010954b:	89 e5                	mov    %esp,%ebp
f010954d:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109550:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f0109557:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010955c:	83 ec 04             	sub    $0x4,%esp
f010955f:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109562:	52                   	push   %edx
f0109563:	ff 75 08             	pushl  0x8(%ebp)
f0109566:	50                   	push   %eax
f0109567:	e8 fd f1 ff ff       	call   f0108769 <get_frame_info>
f010956c:	83 c4 10             	add    $0x10,%esp
f010956f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109572:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109576:	75 07                	jne    f010957f <kheap_physical_address+0x35>
		return 0;
f0109578:	b8 00 00 00 00       	mov    $0x0,%eax
f010957d:	eb 26                	jmp    f01095a5 <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f010957f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109582:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109587:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f010958a:	83 ec 0c             	sub    $0xc,%esp
f010958d:	ff 75 f4             	pushl  -0xc(%ebp)
f0109590:	e8 12 fa ff ff       	call   f0108fa7 <to_physical_address>
f0109595:	83 c4 10             	add    $0x10,%esp
f0109598:	89 c2                	mov    %eax,%edx
f010959a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010959d:	01 d0                	add    %edx,%eax
f010959f:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f01095a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01095a5:	c9                   	leave  
f01095a6:	c3                   	ret    

f01095a7 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f01095a7:	55                   	push   %ebp
f01095a8:	89 e5                	mov    %esp,%ebp
f01095aa:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f01095ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01095b0:	25 ff 0f 00 00       	and    $0xfff,%eax
f01095b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f01095b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01095bb:	c1 e8 0c             	shr    $0xc,%eax
f01095be:	8b 04 85 a0 3f 70 f0 	mov    -0xf8fc060(,%eax,4),%eax
f01095c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f01095c8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01095cc:	74 06                	je     f01095d4 <kheap_virtual_address+0x2d>
f01095ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01095d1:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f01095d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01095d7:	c9                   	leave  
f01095d8:	c3                   	ret    

f01095d9 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f01095d9:	55                   	push   %ebp
f01095da:	89 e5                	mov    %esp,%ebp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	return NULL;
f01095dc:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f01095e1:	5d                   	pop    %ebp
f01095e2:	c3                   	ret    

f01095e3 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f01095e3:	55                   	push   %ebp
f01095e4:	89 e5                	mov    %esp,%ebp
f01095e6:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01095e9:	83 ec 04             	sub    $0x4,%esp
f01095ec:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01095ef:	50                   	push   %eax
f01095f0:	ff 75 0c             	pushl  0xc(%ebp)
f01095f3:	ff 75 08             	pushl  0x8(%ebp)
f01095f6:	e8 f4 ed ff ff       	call   f01083ef <get_page_table>
f01095fb:	83 c4 10             	add    $0x10,%esp
f01095fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109601:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109604:	85 c0                	test   %eax,%eax
f0109606:	74 64                	je     f010966c <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109608:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010960b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010960e:	c1 ea 0c             	shr    $0xc,%edx
f0109611:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109617:	c1 e2 02             	shl    $0x2,%edx
f010961a:	01 c2                	add    %eax,%edx
f010961c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010961f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109622:	c1 e9 0c             	shr    $0xc,%ecx
f0109625:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010962b:	c1 e1 02             	shl    $0x2,%ecx
f010962e:	01 c8                	add    %ecx,%eax
f0109630:	8b 00                	mov    (%eax),%eax
f0109632:	0b 45 10             	or     0x10(%ebp),%eax
f0109635:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109637:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010963a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010963d:	c1 ea 0c             	shr    $0xc,%edx
f0109640:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109646:	c1 e2 02             	shl    $0x2,%edx
f0109649:	01 d0                	add    %edx,%eax
f010964b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010964e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109651:	c1 e9 0c             	shr    $0xc,%ecx
f0109654:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010965a:	c1 e1 02             	shl    $0x2,%ecx
f010965d:	01 ca                	add    %ecx,%edx
f010965f:	8b 12                	mov    (%edx),%edx
f0109661:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109664:	f7 d1                	not    %ecx
f0109666:	21 ca                	and    %ecx,%edx
f0109668:	89 10                	mov    %edx,(%eax)
f010966a:	eb 27                	jmp    f0109693 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f010966c:	83 ec 08             	sub    $0x8,%esp
f010966f:	ff 75 0c             	pushl  0xc(%ebp)
f0109672:	68 24 56 12 f0       	push   $0xf0125624
f0109677:	e8 0f 79 ff ff       	call   f0100f8b <cprintf>
f010967c:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010967f:	83 ec 04             	sub    $0x4,%esp
f0109682:	68 4c 56 12 f0       	push   $0xf012564c
f0109687:	6a 1c                	push   $0x1c
f0109689:	68 c0 56 12 f0       	push   $0xf01256c0
f010968e:	e8 a6 6c ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109693:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109696:	83 ec 08             	sub    $0x8,%esp
f0109699:	50                   	push   %eax
f010969a:	6a 00                	push   $0x0
f010969c:	e8 18 e7 ff ff       	call   f0107db9 <tlb_invalidate>
f01096a1:	83 c4 10             	add    $0x10,%esp
}
f01096a4:	90                   	nop
f01096a5:	c9                   	leave  
f01096a6:	c3                   	ret    

f01096a7 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f01096a7:	55                   	push   %ebp
f01096a8:	89 e5                	mov    %esp,%ebp
f01096aa:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01096ad:	83 ec 04             	sub    $0x4,%esp
f01096b0:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01096b3:	50                   	push   %eax
f01096b4:	ff 75 0c             	pushl  0xc(%ebp)
f01096b7:	ff 75 08             	pushl  0x8(%ebp)
f01096ba:	e8 30 ed ff ff       	call   f01083ef <get_page_table>
f01096bf:	83 c4 10             	add    $0x10,%esp
f01096c2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f01096c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096c8:	85 c0                	test   %eax,%eax
f01096ca:	74 1d                	je     f01096e9 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f01096cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096cf:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096d2:	c1 ea 0c             	shr    $0xc,%edx
f01096d5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096db:	c1 e2 02             	shl    $0x2,%edx
f01096de:	01 d0                	add    %edx,%eax
f01096e0:	8b 00                	mov    (%eax),%eax
f01096e2:	25 ff 0f 00 00       	and    $0xfff,%eax
f01096e7:	eb 05                	jmp    f01096ee <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f01096e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f01096ee:	c9                   	leave  
f01096ef:	c3                   	ret    

f01096f0 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f01096f0:	55                   	push   %ebp
f01096f1:	89 e5                	mov    %esp,%ebp
f01096f3:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01096f6:	83 ec 04             	sub    $0x4,%esp
f01096f9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01096fc:	50                   	push   %eax
f01096fd:	ff 75 0c             	pushl  0xc(%ebp)
f0109700:	ff 75 08             	pushl  0x8(%ebp)
f0109703:	e8 e7 ec ff ff       	call   f01083ef <get_page_table>
f0109708:	83 c4 10             	add    $0x10,%esp
f010970b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010970e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109711:	85 c0                	test   %eax,%eax
f0109713:	74 46                	je     f010975b <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109715:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109718:	8b 55 0c             	mov    0xc(%ebp),%edx
f010971b:	c1 ea 0c             	shr    $0xc,%edx
f010971e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109724:	c1 e2 02             	shl    $0x2,%edx
f0109727:	01 d0                	add    %edx,%eax
f0109729:	8b 00                	mov    (%eax),%eax
f010972b:	83 ec 04             	sub    $0x4,%esp
f010972e:	50                   	push   %eax
f010972f:	ff 75 0c             	pushl  0xc(%ebp)
f0109732:	68 dc 56 12 f0       	push   $0xf01256dc
f0109737:	e8 4f 78 ff ff       	call   f0100f8b <cprintf>
f010973c:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010973f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109742:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109745:	c1 ea 0c             	shr    $0xc,%edx
f0109748:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010974e:	c1 e2 02             	shl    $0x2,%edx
f0109751:	01 d0                	add    %edx,%eax
f0109753:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109759:	eb 14                	jmp    f010976f <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010975b:	83 ec 04             	sub    $0x4,%esp
f010975e:	68 04 57 12 f0       	push   $0xf0125704
f0109763:	6a 47                	push   $0x47
f0109765:	68 c0 56 12 f0       	push   $0xf01256c0
f010976a:	e8 ca 6b ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010976f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109772:	83 ec 08             	sub    $0x8,%esp
f0109775:	50                   	push   %eax
f0109776:	6a 00                	push   $0x0
f0109778:	e8 3c e6 ff ff       	call   f0107db9 <tlb_invalidate>
f010977d:	83 c4 10             	add    $0x10,%esp
}
f0109780:	90                   	nop
f0109781:	c9                   	leave  
f0109782:	c3                   	ret    

f0109783 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109783:	55                   	push   %ebp
f0109784:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109786:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109789:	c1 e8 16             	shr    $0x16,%eax
f010978c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109793:	8b 45 08             	mov    0x8(%ebp),%eax
f0109796:	01 d0                	add    %edx,%eax
f0109798:	8b 00                	mov    (%eax),%eax
f010979a:	83 e0 20             	and    $0x20,%eax
f010979d:	85 c0                	test   %eax,%eax
f010979f:	0f 95 c0             	setne  %al
f01097a2:	0f b6 c0             	movzbl %al,%eax
}
f01097a5:	5d                   	pop    %ebp
f01097a6:	c3                   	ret    

f01097a7 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f01097a7:	55                   	push   %ebp
f01097a8:	89 e5                	mov    %esp,%ebp
f01097aa:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f01097ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097b0:	c1 e8 16             	shr    $0x16,%eax
f01097b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01097ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01097bd:	01 d0                	add    %edx,%eax
f01097bf:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097c2:	c1 ea 16             	shr    $0x16,%edx
f01097c5:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01097cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01097cf:	01 ca                	add    %ecx,%edx
f01097d1:	8b 12                	mov    (%edx),%edx
f01097d3:	83 e2 df             	and    $0xffffffdf,%edx
f01097d6:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01097d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097db:	83 ec 08             	sub    $0x8,%esp
f01097de:	50                   	push   %eax
f01097df:	6a 00                	push   $0x0
f01097e1:	e8 d3 e5 ff ff       	call   f0107db9 <tlb_invalidate>
f01097e6:	83 c4 10             	add    $0x10,%esp
}
f01097e9:	90                   	nop
f01097ea:	c9                   	leave  
f01097eb:	c3                   	ret    

f01097ec <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f01097ec:	55                   	push   %ebp
f01097ed:	89 e5                	mov    %esp,%ebp
f01097ef:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f01097f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097f5:	c1 e8 16             	shr    $0x16,%eax
f01097f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01097ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0109802:	01 d0                	add    %edx,%eax
f0109804:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010980a:	0f 20 d8             	mov    %cr3,%eax
f010980d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109810:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109813:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109816:	90                   	nop
f0109817:	c9                   	leave  
f0109818:	c3                   	ret    

f0109819 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109819:	55                   	push   %ebp
f010981a:	89 e5                	mov    %esp,%ebp
f010981c:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f010981f:	83 ec 0c             	sub    $0xc,%esp
f0109822:	6a 18                	push   $0x18
f0109824:	e8 db f9 ff ff       	call   f0109204 <kmalloc>
f0109829:	83 c4 10             	add    $0x10,%esp
f010982c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f010982f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109833:	75 14                	jne    f0109849 <env_page_ws_list_create_element+0x30>
f0109835:	83 ec 04             	sub    $0x4,%esp
f0109838:	68 7c 57 12 f0       	push   $0xf012577c
f010983d:	6a 19                	push   $0x19
f010983f:	68 ac 57 12 f0       	push   $0xf01257ac
f0109844:	e8 f0 6a ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109849:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010984c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f010984f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109852:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109858:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010985d:	89 c2                	mov    %eax,%edx
f010985f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109862:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109864:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109867:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f010986b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010986e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f0109875:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109878:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f010987f:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109882:	c9                   	leave  
f0109883:	c3                   	ret    

f0109884 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109884:	55                   	push   %ebp
f0109885:	89 e5                	mov    %esp,%ebp
f0109887:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010988a:	83 ec 0c             	sub    $0xc,%esp
f010988d:	6a 02                	push   $0x2
f010988f:	e8 4b 57 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0109894:	83 c4 10             	add    $0x10,%esp
f0109897:	85 c0                	test   %eax,%eax
f0109899:	0f 84 e5 03 00 00    	je     f0109c84 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010989f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f01098a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f01098ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01098b0:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01098b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01098b9:	e9 3b 02 00 00       	jmp    f0109af9 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01098be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098c1:	8b 00                	mov    (%eax),%eax
f01098c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01098c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01098c9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01098ce:	89 c2                	mov    %eax,%edx
f01098d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01098d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01098d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01098d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01098de:	39 c2                	cmp    %eax,%edx
f01098e0:	0f 85 07 02 00 00    	jne    f0109aed <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f01098e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01098e9:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01098ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01098f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098f5:	8b 10                	mov    (%eax),%edx
f01098f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01098fa:	8b 40 64             	mov    0x64(%eax),%eax
f01098fd:	83 ec 08             	sub    $0x8,%esp
f0109900:	52                   	push   %edx
f0109901:	50                   	push   %eax
f0109902:	e8 d8 ee ff ff       	call   f01087df <unmap_frame>
f0109907:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010990a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010990e:	75 14                	jne    f0109924 <env_page_ws_invalidate+0xa0>
f0109910:	83 ec 04             	sub    $0x4,%esp
f0109913:	68 cb 57 12 f0       	push   $0xf01257cb
f0109918:	6a 2f                	push   $0x2f
f010991a:	68 ac 57 12 f0       	push   $0xf01257ac
f010991f:	e8 15 6a ff ff       	call   f0100339 <_panic>
f0109924:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109927:	8b 40 10             	mov    0x10(%eax),%eax
f010992a:	85 c0                	test   %eax,%eax
f010992c:	74 11                	je     f010993f <env_page_ws_invalidate+0xbb>
f010992e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109931:	8b 40 10             	mov    0x10(%eax),%eax
f0109934:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109937:	8b 52 14             	mov    0x14(%edx),%edx
f010993a:	89 50 14             	mov    %edx,0x14(%eax)
f010993d:	eb 0f                	jmp    f010994e <env_page_ws_invalidate+0xca>
f010993f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109942:	8b 50 14             	mov    0x14(%eax),%edx
f0109945:	8b 45 08             	mov    0x8(%ebp),%eax
f0109948:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010994e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109951:	8b 40 14             	mov    0x14(%eax),%eax
f0109954:	85 c0                	test   %eax,%eax
f0109956:	74 11                	je     f0109969 <env_page_ws_invalidate+0xe5>
f0109958:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010995b:	8b 40 14             	mov    0x14(%eax),%eax
f010995e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109961:	8b 52 10             	mov    0x10(%edx),%edx
f0109964:	89 50 10             	mov    %edx,0x10(%eax)
f0109967:	eb 0f                	jmp    f0109978 <env_page_ws_invalidate+0xf4>
f0109969:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010996c:	8b 50 10             	mov    0x10(%eax),%edx
f010996f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109972:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109978:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010997b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109982:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109985:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010998c:	8b 45 08             	mov    0x8(%ebp),%eax
f010998f:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109995:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109998:	8b 45 08             	mov    0x8(%ebp),%eax
f010999b:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f01099a1:	83 ec 0c             	sub    $0xc,%esp
f01099a4:	ff 75 f0             	pushl  -0x10(%ebp)
f01099a7:	e8 b8 fa ff ff       	call   f0109464 <kfree>
f01099ac:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f01099af:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01099b3:	0f 84 2b 01 00 00    	je     f0109ae4 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f01099b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01099bd:	75 14                	jne    f01099d3 <env_page_ws_invalidate+0x14f>
f01099bf:	83 ec 04             	sub    $0x4,%esp
f01099c2:	68 cb 57 12 f0       	push   $0xf01257cb
f01099c7:	6a 35                	push   $0x35
f01099c9:	68 ac 57 12 f0       	push   $0xf01257ac
f01099ce:	e8 66 69 ff ff       	call   f0100339 <_panic>
f01099d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099d6:	8b 40 10             	mov    0x10(%eax),%eax
f01099d9:	85 c0                	test   %eax,%eax
f01099db:	74 11                	je     f01099ee <env_page_ws_invalidate+0x16a>
f01099dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099e0:	8b 40 10             	mov    0x10(%eax),%eax
f01099e3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01099e6:	8b 52 14             	mov    0x14(%edx),%edx
f01099e9:	89 50 14             	mov    %edx,0x14(%eax)
f01099ec:	eb 0f                	jmp    f01099fd <env_page_ws_invalidate+0x179>
f01099ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099f1:	8b 50 14             	mov    0x14(%eax),%edx
f01099f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01099f7:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f01099fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a00:	8b 40 14             	mov    0x14(%eax),%eax
f0109a03:	85 c0                	test   %eax,%eax
f0109a05:	74 11                	je     f0109a18 <env_page_ws_invalidate+0x194>
f0109a07:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a0a:	8b 40 14             	mov    0x14(%eax),%eax
f0109a0d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a10:	8b 52 10             	mov    0x10(%edx),%edx
f0109a13:	89 50 10             	mov    %edx,0x10(%eax)
f0109a16:	eb 0f                	jmp    f0109a27 <env_page_ws_invalidate+0x1a3>
f0109a18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a1b:	8b 50 10             	mov    0x10(%eax),%edx
f0109a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a21:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f0109a27:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a2a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109a31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a34:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109a3b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a3e:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0109a44:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109a47:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a4a:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f0109a50:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109a54:	75 14                	jne    f0109a6a <env_page_ws_invalidate+0x1e6>
f0109a56:	83 ec 04             	sub    $0x4,%esp
f0109a59:	68 ec 57 12 f0       	push   $0xf01257ec
f0109a5e:	6a 36                	push   $0x36
f0109a60:	68 ac 57 12 f0       	push   $0xf01257ac
f0109a65:	e8 cf 68 ff ff       	call   f0100339 <_panic>
f0109a6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a6d:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f0109a73:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a76:	89 50 14             	mov    %edx,0x14(%eax)
f0109a79:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a7c:	8b 40 14             	mov    0x14(%eax),%eax
f0109a7f:	85 c0                	test   %eax,%eax
f0109a81:	74 11                	je     f0109a94 <env_page_ws_invalidate+0x210>
f0109a83:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a86:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109a8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a8f:	89 50 10             	mov    %edx,0x10(%eax)
f0109a92:	eb 0c                	jmp    f0109aa0 <env_page_ws_invalidate+0x21c>
f0109a94:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a97:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a9a:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109aa0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109aa3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109aa6:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109aac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109aaf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109ab6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ab9:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109abf:	8d 50 01             	lea    0x1(%eax),%edx
f0109ac2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ac5:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f0109acb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ace:	8b 10                	mov    (%eax),%edx
f0109ad0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ad3:	8b 40 64             	mov    0x64(%eax),%eax
f0109ad6:	6a 00                	push   $0x0
f0109ad8:	6a 01                	push   $0x1
f0109ada:	52                   	push   %edx
f0109adb:	50                   	push   %eax
f0109adc:	e8 02 fb ff ff       	call   f01095e3 <pt_set_page_permissions>
f0109ae1:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f0109ae4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0109aeb:	eb 43                	jmp    f0109b30 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109aed:	8b 45 08             	mov    0x8(%ebp),%eax
f0109af0:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109af6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109af9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109afd:	74 08                	je     f0109b07 <env_page_ws_invalidate+0x283>
f0109aff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b02:	8b 40 10             	mov    0x10(%eax),%eax
f0109b05:	eb 05                	jmp    f0109b0c <env_page_ws_invalidate+0x288>
f0109b07:	b8 00 00 00 00       	mov    $0x0,%eax
f0109b0c:	8b 55 08             	mov    0x8(%ebp),%edx
f0109b0f:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0109b15:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b18:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109b1e:	85 c0                	test   %eax,%eax
f0109b20:	0f 85 98 fd ff ff    	jne    f01098be <env_page_ws_invalidate+0x3a>
f0109b26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b2a:	0f 85 8e fd ff ff    	jne    f01098be <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f0109b30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109b34:	0f 85 a4 02 00 00    	jne    f0109dde <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f0109b3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109b41:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b44:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109b4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109b4d:	e9 f6 00 00 00       	jmp    f0109c48 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109b52:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b55:	8b 00                	mov    (%eax),%eax
f0109b57:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109b5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109b5d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b62:	89 c2                	mov    %eax,%edx
f0109b64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b67:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109b6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109b6d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b72:	39 c2                	cmp    %eax,%edx
f0109b74:	0f 85 c2 00 00 00    	jne    f0109c3c <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109b7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b7d:	8b 10                	mov    (%eax),%edx
f0109b7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b82:	8b 40 64             	mov    0x64(%eax),%eax
f0109b85:	83 ec 08             	sub    $0x8,%esp
f0109b88:	52                   	push   %edx
f0109b89:	50                   	push   %eax
f0109b8a:	e8 50 ec ff ff       	call   f01087df <unmap_frame>
f0109b8f:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f0109b92:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b96:	75 14                	jne    f0109bac <env_page_ws_invalidate+0x328>
f0109b98:	83 ec 04             	sub    $0x4,%esp
f0109b9b:	68 cb 57 12 f0       	push   $0xf01257cb
f0109ba0:	6a 46                	push   $0x46
f0109ba2:	68 ac 57 12 f0       	push   $0xf01257ac
f0109ba7:	e8 8d 67 ff ff       	call   f0100339 <_panic>
f0109bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109baf:	8b 40 10             	mov    0x10(%eax),%eax
f0109bb2:	85 c0                	test   %eax,%eax
f0109bb4:	74 11                	je     f0109bc7 <env_page_ws_invalidate+0x343>
f0109bb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bb9:	8b 40 10             	mov    0x10(%eax),%eax
f0109bbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109bbf:	8b 52 14             	mov    0x14(%edx),%edx
f0109bc2:	89 50 14             	mov    %edx,0x14(%eax)
f0109bc5:	eb 0f                	jmp    f0109bd6 <env_page_ws_invalidate+0x352>
f0109bc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bca:	8b 50 14             	mov    0x14(%eax),%edx
f0109bcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bd0:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f0109bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bd9:	8b 40 14             	mov    0x14(%eax),%eax
f0109bdc:	85 c0                	test   %eax,%eax
f0109bde:	74 11                	je     f0109bf1 <env_page_ws_invalidate+0x36d>
f0109be0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109be3:	8b 40 14             	mov    0x14(%eax),%eax
f0109be6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109be9:	8b 52 10             	mov    0x10(%edx),%edx
f0109bec:	89 50 10             	mov    %edx,0x10(%eax)
f0109bef:	eb 0f                	jmp    f0109c00 <env_page_ws_invalidate+0x37c>
f0109bf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bf4:	8b 50 10             	mov    0x10(%eax),%edx
f0109bf7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bfa:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f0109c00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c03:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109c0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c0d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109c14:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c17:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0109c1d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109c20:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c23:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f0109c29:	83 ec 0c             	sub    $0xc,%esp
f0109c2c:	ff 75 f0             	pushl  -0x10(%ebp)
f0109c2f:	e8 30 f8 ff ff       	call   f0109464 <kfree>
f0109c34:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f0109c37:	e9 a2 01 00 00       	jmp    f0109dde <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109c3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c3f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109c45:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109c48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109c4c:	74 08                	je     f0109c56 <env_page_ws_invalidate+0x3d2>
f0109c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c51:	8b 40 10             	mov    0x10(%eax),%eax
f0109c54:	eb 05                	jmp    f0109c5b <env_page_ws_invalidate+0x3d7>
f0109c56:	b8 00 00 00 00       	mov    $0x0,%eax
f0109c5b:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c5e:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109c64:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c67:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109c6d:	85 c0                	test   %eax,%eax
f0109c6f:	0f 85 dd fe ff ff    	jne    f0109b52 <env_page_ws_invalidate+0x2ce>
f0109c75:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109c79:	0f 85 d3 fe ff ff    	jne    f0109b52 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f0109c7f:	e9 5a 01 00 00       	jmp    f0109dde <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109c84:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c87:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109c8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109c90:	e9 10 01 00 00       	jmp    f0109da5 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109c95:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c98:	8b 00                	mov    (%eax),%eax
f0109c9a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109c9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109ca0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109ca5:	89 c2                	mov    %eax,%edx
f0109ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109caa:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109cad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109cb0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109cb5:	39 c2                	cmp    %eax,%edx
f0109cb7:	0f 85 dc 00 00 00    	jne    f0109d99 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109cbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cc0:	8b 10                	mov    (%eax),%edx
f0109cc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cc5:	8b 40 64             	mov    0x64(%eax),%eax
f0109cc8:	83 ec 08             	sub    $0x8,%esp
f0109ccb:	52                   	push   %edx
f0109ccc:	50                   	push   %eax
f0109ccd:	e8 0d eb ff ff       	call   f01087df <unmap_frame>
f0109cd2:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f0109cd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cd8:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109ce1:	75 0f                	jne    f0109cf2 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f0109ce3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ce6:	8b 50 10             	mov    0x10(%eax),%edx
f0109ce9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cec:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f0109cf2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109cf6:	75 14                	jne    f0109d0c <env_page_ws_invalidate+0x488>
f0109cf8:	83 ec 04             	sub    $0x4,%esp
f0109cfb:	68 cb 57 12 f0       	push   $0xf01257cb
f0109d00:	6a 5c                	push   $0x5c
f0109d02:	68 ac 57 12 f0       	push   $0xf01257ac
f0109d07:	e8 2d 66 ff ff       	call   f0100339 <_panic>
f0109d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d0f:	8b 40 10             	mov    0x10(%eax),%eax
f0109d12:	85 c0                	test   %eax,%eax
f0109d14:	74 11                	je     f0109d27 <env_page_ws_invalidate+0x4a3>
f0109d16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d19:	8b 40 10             	mov    0x10(%eax),%eax
f0109d1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109d1f:	8b 52 14             	mov    0x14(%edx),%edx
f0109d22:	89 50 14             	mov    %edx,0x14(%eax)
f0109d25:	eb 0f                	jmp    f0109d36 <env_page_ws_invalidate+0x4b2>
f0109d27:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d2a:	8b 50 14             	mov    0x14(%eax),%edx
f0109d2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d30:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f0109d36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d39:	8b 40 14             	mov    0x14(%eax),%eax
f0109d3c:	85 c0                	test   %eax,%eax
f0109d3e:	74 11                	je     f0109d51 <env_page_ws_invalidate+0x4cd>
f0109d40:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d43:	8b 40 14             	mov    0x14(%eax),%eax
f0109d46:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109d49:	8b 52 10             	mov    0x10(%edx),%edx
f0109d4c:	89 50 10             	mov    %edx,0x10(%eax)
f0109d4f:	eb 0f                	jmp    f0109d60 <env_page_ws_invalidate+0x4dc>
f0109d51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d54:	8b 50 10             	mov    0x10(%eax),%edx
f0109d57:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d5a:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0109d60:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d63:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109d6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d6d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109d74:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d77:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0109d7d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109d80:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d83:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f0109d89:	83 ec 0c             	sub    $0xc,%esp
f0109d8c:	ff 75 ec             	pushl  -0x14(%ebp)
f0109d8f:	e8 d0 f6 ff ff       	call   f0109464 <kfree>
f0109d94:	83 c4 10             	add    $0x10,%esp

				break;
f0109d97:	eb 45                	jmp    f0109dde <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109d99:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d9c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109da2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109da5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109da9:	74 08                	je     f0109db3 <env_page_ws_invalidate+0x52f>
f0109dab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109dae:	8b 40 10             	mov    0x10(%eax),%eax
f0109db1:	eb 05                	jmp    f0109db8 <env_page_ws_invalidate+0x534>
f0109db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0109db8:	8b 55 08             	mov    0x8(%ebp),%edx
f0109dbb:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0109dc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dc4:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109dca:	85 c0                	test   %eax,%eax
f0109dcc:	0f 85 c3 fe ff ff    	jne    f0109c95 <env_page_ws_invalidate+0x411>
f0109dd2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109dd6:	0f 85 b9 fe ff ff    	jne    f0109c95 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f0109ddc:	eb 00                	jmp    f0109dde <env_page_ws_invalidate+0x55a>
f0109dde:	90                   	nop
f0109ddf:	c9                   	leave  
f0109de0:	c3                   	ret    

f0109de1 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f0109de1:	55                   	push   %ebp
f0109de2:	89 e5                	mov    %esp,%ebp
f0109de4:	53                   	push   %ebx
f0109de5:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109de8:	83 ec 0c             	sub    $0xc,%esp
f0109deb:	6a 02                	push   $0x2
f0109ded:	e8 ed 51 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f0109df2:	83 c4 10             	add    $0x10,%esp
f0109df5:	85 c0                	test   %eax,%eax
f0109df7:	0f 84 fe 00 00 00    	je     f0109efb <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109dfd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109e04:	83 ec 0c             	sub    $0xc,%esp
f0109e07:	68 0f 58 12 f0       	push   $0xf012580f
f0109e0c:	e8 7a 71 ff ff       	call   f0100f8b <cprintf>
f0109e11:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109e14:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e17:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109e1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e20:	eb 2c                	jmp    f0109e4e <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e25:	8b 10                	mov    (%eax),%edx
f0109e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e2a:	8d 48 01             	lea    0x1(%eax),%ecx
f0109e2d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109e30:	83 ec 04             	sub    $0x4,%esp
f0109e33:	52                   	push   %edx
f0109e34:	50                   	push   %eax
f0109e35:	68 29 58 12 f0       	push   $0xf0125829
f0109e3a:	e8 4c 71 ff ff       	call   f0100f8b <cprintf>
f0109e3f:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109e42:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e45:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109e4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e4e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109e52:	74 08                	je     f0109e5c <env_page_ws_print+0x7b>
f0109e54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e57:	8b 40 10             	mov    0x10(%eax),%eax
f0109e5a:	eb 05                	jmp    f0109e61 <env_page_ws_print+0x80>
f0109e5c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109e61:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e64:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0109e6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e6d:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109e73:	85 c0                	test   %eax,%eax
f0109e75:	75 ab                	jne    f0109e22 <env_page_ws_print+0x41>
f0109e77:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109e7b:	75 a5                	jne    f0109e22 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0109e7d:	83 ec 0c             	sub    $0xc,%esp
f0109e80:	68 31 58 12 f0       	push   $0xf0125831
f0109e85:	e8 01 71 ff ff       	call   f0100f8b <cprintf>
f0109e8a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109e8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e90:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109e96:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e99:	eb 2c                	jmp    f0109ec7 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109e9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e9e:	8b 10                	mov    (%eax),%edx
f0109ea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ea3:	8d 48 01             	lea    0x1(%eax),%ecx
f0109ea6:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109ea9:	83 ec 04             	sub    $0x4,%esp
f0109eac:	52                   	push   %edx
f0109ead:	50                   	push   %eax
f0109eae:	68 29 58 12 f0       	push   $0xf0125829
f0109eb3:	e8 d3 70 ff ff       	call   f0100f8b <cprintf>
f0109eb8:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109ebb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ebe:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109ec4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109ec7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ecb:	74 08                	je     f0109ed5 <env_page_ws_print+0xf4>
f0109ecd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ed0:	8b 40 10             	mov    0x10(%eax),%eax
f0109ed3:	eb 05                	jmp    f0109eda <env_page_ws_print+0xf9>
f0109ed5:	b8 00 00 00 00       	mov    $0x0,%eax
f0109eda:	8b 55 08             	mov    0x8(%ebp),%edx
f0109edd:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109ee3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ee6:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109eec:	85 c0                	test   %eax,%eax
f0109eee:	75 ab                	jne    f0109e9b <env_page_ws_print+0xba>
f0109ef0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ef4:	75 a5                	jne    f0109e9b <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109ef6:	e9 5a 01 00 00       	jmp    f010a055 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f0109efb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f0109f02:	83 ec 0c             	sub    $0xc,%esp
f0109f05:	68 4c 58 12 f0       	push   $0xf012584c
f0109f0a:	e8 7c 70 ff ff       	call   f0100f8b <cprintf>
f0109f0f:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f0109f12:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109f19:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f1c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109f22:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109f25:	e9 d1 00 00 00       	jmp    f0109ffb <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f0109f2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f2d:	8b 00                	mov    (%eax),%eax
f0109f2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f0109f32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f35:	8b 40 08             	mov    0x8(%eax),%eax
f0109f38:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0109f3b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f3e:	8b 40 64             	mov    0x64(%eax),%eax
f0109f41:	83 ec 08             	sub    $0x8,%esp
f0109f44:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109f47:	50                   	push   %eax
f0109f48:	e8 5a f7 ff ff       	call   f01096a7 <pt_get_page_permissions>
f0109f4d:	83 c4 10             	add    $0x10,%esp
f0109f50:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0109f53:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f56:	83 e0 40             	and    $0x40,%eax
f0109f59:	85 c0                	test   %eax,%eax
f0109f5b:	0f 95 c0             	setne  %al
f0109f5e:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0109f61:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f64:	83 e0 20             	and    $0x20,%eax
f0109f67:	85 c0                	test   %eax,%eax
f0109f69:	0f 95 c0             	setne  %al
f0109f6c:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0109f6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f72:	25 00 02 00 00       	and    $0x200,%eax
f0109f77:	85 c0                	test   %eax,%eax
f0109f79:	0f 95 c0             	setne  %al
f0109f7c:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f0109f7f:	83 ec 04             	sub    $0x4,%esp
f0109f82:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109f85:	ff 75 ec             	pushl  -0x14(%ebp)
f0109f88:	68 56 58 12 f0       	push   $0xf0125856
f0109f8d:	e8 f9 6f ff ff       	call   f0100f8b <cprintf>
f0109f92:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f0109f95:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f98:	8b 58 0c             	mov    0xc(%eax),%ebx
f0109f9b:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f0109f9f:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0109fa3:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f0109fa7:	83 ec 08             	sub    $0x8,%esp
f0109faa:	53                   	push   %ebx
f0109fab:	ff 75 e0             	pushl  -0x20(%ebp)
f0109fae:	51                   	push   %ecx
f0109faf:	52                   	push   %edx
f0109fb0:	50                   	push   %eax
f0109fb1:	68 60 58 12 f0       	push   $0xf0125860
f0109fb6:	e8 d0 6f ff ff       	call   f0100f8b <cprintf>
f0109fbb:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109fbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fc1:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109fc7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109fca:	75 10                	jne    f0109fdc <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f0109fcc:	83 ec 0c             	sub    $0xc,%esp
f0109fcf:	68 a7 58 12 f0       	push   $0xf01258a7
f0109fd4:	e8 b2 6f ff ff       	call   f0100f8b <cprintf>
f0109fd9:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109fdc:	83 ec 0c             	sub    $0xc,%esp
f0109fdf:	68 ac 58 12 f0       	push   $0xf01258ac
f0109fe4:	e8 a2 6f ff ff       	call   f0100f8b <cprintf>
f0109fe9:	83 c4 10             	add    $0x10,%esp
			i++;
f0109fec:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109fef:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ff2:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109ff8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109ffb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109fff:	74 08                	je     f010a009 <env_page_ws_print+0x228>
f010a001:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a004:	8b 40 10             	mov    0x10(%eax),%eax
f010a007:	eb 05                	jmp    f010a00e <env_page_ws_print+0x22d>
f010a009:	b8 00 00 00 00       	mov    $0x0,%eax
f010a00e:	8b 55 08             	mov    0x8(%ebp),%edx
f010a011:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a017:	8b 45 08             	mov    0x8(%ebp),%eax
f010a01a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a020:	85 c0                	test   %eax,%eax
f010a022:	0f 85 02 ff ff ff    	jne    f0109f2a <env_page_ws_print+0x149>
f010a028:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a02c:	0f 85 f8 fe ff ff    	jne    f0109f2a <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a032:	eb 13                	jmp    f010a047 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a034:	83 ec 0c             	sub    $0xc,%esp
f010a037:	68 ae 58 12 f0       	push   $0xf01258ae
f010a03c:	e8 4a 6f ff ff       	call   f0100f8b <cprintf>
f010a041:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a044:	ff 45 ec             	incl   -0x14(%ebp)
f010a047:	8b 45 08             	mov    0x8(%ebp),%eax
f010a04a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a050:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a053:	77 df                	ja     f010a034 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a055:	90                   	nop
f010a056:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a059:	c9                   	leave  
f010a05a:	c3                   	ret    

f010a05b <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a05b:	55                   	push   %ebp
f010a05c:	89 e5                	mov    %esp,%ebp
f010a05e:	53                   	push   %ebx
f010a05f:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a062:	83 ec 0c             	sub    $0xc,%esp
f010a065:	68 c0 58 12 f0       	push   $0xf01258c0
f010a06a:	e8 1c 6f ff ff       	call   f0100f8b <cprintf>
f010a06f:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a072:	83 ec 0c             	sub    $0xc,%esp
f010a075:	68 f5 58 12 f0       	push   $0xf01258f5
f010a07a:	e8 0c 6f ff ff       	call   f0100f8b <cprintf>
f010a07f:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a082:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a089:	e9 16 01 00 00       	jmp    f010a1a4 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a08e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a091:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a094:	89 d0                	mov    %edx,%eax
f010a096:	01 c0                	add    %eax,%eax
f010a098:	01 d0                	add    %edx,%eax
f010a09a:	c1 e0 03             	shl    $0x3,%eax
f010a09d:	01 c8                	add    %ecx,%eax
f010a09f:	05 b0 00 00 00       	add    $0xb0,%eax
f010a0a4:	8a 00                	mov    (%eax),%al
f010a0a6:	84 c0                	test   %al,%al
f010a0a8:	74 43                	je     f010a0ed <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a0aa:	83 ec 0c             	sub    $0xc,%esp
f010a0ad:	68 00 59 12 f0       	push   $0xf0125900
f010a0b2:	e8 d4 6e ff ff       	call   f0100f8b <cprintf>
f010a0b7:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a0ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0bd:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a0c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a0c6:	75 10                	jne    f010a0d8 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a0c8:	83 ec 0c             	sub    $0xc,%esp
f010a0cb:	68 0f 59 12 f0       	push   $0xf012590f
f010a0d0:	e8 b6 6e ff ff       	call   f0100f8b <cprintf>
f010a0d5:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a0d8:	83 ec 0c             	sub    $0xc,%esp
f010a0db:	68 ac 58 12 f0       	push   $0xf01258ac
f010a0e0:	e8 a6 6e ff ff       	call   f0100f8b <cprintf>
f010a0e5:	83 c4 10             	add    $0x10,%esp
			continue;
f010a0e8:	e9 b4 00 00 00       	jmp    f010a1a1 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a0ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a0f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0f3:	89 d0                	mov    %edx,%eax
f010a0f5:	01 c0                	add    %eax,%eax
f010a0f7:	01 d0                	add    %edx,%eax
f010a0f9:	c1 e0 03             	shl    $0x3,%eax
f010a0fc:	01 c8                	add    %ecx,%eax
f010a0fe:	05 ac 00 00 00       	add    $0xac,%eax
f010a103:	8b 00                	mov    (%eax),%eax
f010a105:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a108:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a10b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a10e:	89 d0                	mov    %edx,%eax
f010a110:	01 c0                	add    %eax,%eax
f010a112:	01 d0                	add    %edx,%eax
f010a114:	c1 e0 03             	shl    $0x3,%eax
f010a117:	01 c8                	add    %ecx,%eax
f010a119:	05 ac 00 00 00       	add    $0xac,%eax
f010a11e:	8b 00                	mov    (%eax),%eax
f010a120:	83 ec 04             	sub    $0x4,%esp
f010a123:	50                   	push   %eax
f010a124:	ff 75 f4             	pushl  -0xc(%ebp)
f010a127:	68 15 59 12 f0       	push   $0xf0125915
f010a12c:	e8 5a 6e ff ff       	call   f0100f8b <cprintf>
f010a131:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a134:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a137:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a13a:	89 d0                	mov    %edx,%eax
f010a13c:	01 c0                	add    %eax,%eax
f010a13e:	01 d0                	add    %edx,%eax
f010a140:	c1 e0 03             	shl    $0x3,%eax
f010a143:	01 c8                	add    %ecx,%eax
f010a145:	05 b4 00 00 00       	add    $0xb4,%eax
f010a14a:	8b 18                	mov    (%eax),%ebx
f010a14c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a14f:	8b 40 64             	mov    0x64(%eax),%eax
f010a152:	83 ec 08             	sub    $0x8,%esp
f010a155:	ff 75 f0             	pushl  -0x10(%ebp)
f010a158:	50                   	push   %eax
f010a159:	e8 25 f6 ff ff       	call   f0109783 <pd_is_table_used>
f010a15e:	83 c4 10             	add    $0x10,%esp
f010a161:	83 ec 04             	sub    $0x4,%esp
f010a164:	53                   	push   %ebx
f010a165:	50                   	push   %eax
f010a166:	68 2c 59 12 f0       	push   $0xf012592c
f010a16b:	e8 1b 6e ff ff       	call   f0100f8b <cprintf>
f010a170:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a173:	8b 45 08             	mov    0x8(%ebp),%eax
f010a176:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a17c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a17f:	75 10                	jne    f010a191 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a181:	83 ec 0c             	sub    $0xc,%esp
f010a184:	68 a7 58 12 f0       	push   $0xf01258a7
f010a189:	e8 fd 6d ff ff       	call   f0100f8b <cprintf>
f010a18e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a191:	83 ec 0c             	sub    $0xc,%esp
f010a194:	68 ac 58 12 f0       	push   $0xf01258ac
f010a199:	e8 ed 6d ff ff       	call   f0100f8b <cprintf>
f010a19e:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a1a1:	ff 45 f4             	incl   -0xc(%ebp)
f010a1a4:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a1a8:	0f 86 e0 fe ff ff    	jbe    f010a08e <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a1ae:	90                   	nop
f010a1af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a1b2:	c9                   	leave  
f010a1b3:	c3                   	ret    

f010a1b4 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a1b4:	55                   	push   %ebp
f010a1b5:	89 e5                	mov    %esp,%ebp
f010a1b7:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a1ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a1c1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a1c8:	eb 22                	jmp    f010a1ec <env_table_ws_get_size+0x38>
f010a1ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a1cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a1d0:	89 d0                	mov    %edx,%eax
f010a1d2:	01 c0                	add    %eax,%eax
f010a1d4:	01 d0                	add    %edx,%eax
f010a1d6:	c1 e0 03             	shl    $0x3,%eax
f010a1d9:	01 c8                	add    %ecx,%eax
f010a1db:	05 b0 00 00 00       	add    $0xb0,%eax
f010a1e0:	8a 00                	mov    (%eax),%al
f010a1e2:	84 c0                	test   %al,%al
f010a1e4:	75 03                	jne    f010a1e9 <env_table_ws_get_size+0x35>
f010a1e6:	ff 45 f8             	incl   -0x8(%ebp)
f010a1e9:	ff 45 fc             	incl   -0x4(%ebp)
f010a1ec:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a1f0:	7e d8                	jle    f010a1ca <env_table_ws_get_size+0x16>
	return counter;
f010a1f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a1f5:	c9                   	leave  
f010a1f6:	c3                   	ret    

f010a1f7 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a1f7:	55                   	push   %ebp
f010a1f8:	89 e5                	mov    %esp,%ebp
f010a1fa:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a1fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a204:	eb 4e                	jmp    f010a254 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a206:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a209:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a20c:	89 d0                	mov    %edx,%eax
f010a20e:	01 c0                	add    %eax,%eax
f010a210:	01 d0                	add    %edx,%eax
f010a212:	c1 e0 03             	shl    $0x3,%eax
f010a215:	01 c8                	add    %ecx,%eax
f010a217:	05 ac 00 00 00       	add    $0xac,%eax
f010a21c:	8b 00                	mov    (%eax),%eax
f010a21e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a221:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a224:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a229:	89 c2                	mov    %eax,%edx
f010a22b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a22e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a231:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a234:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a239:	39 c2                	cmp    %eax,%edx
f010a23b:	75 14                	jne    f010a251 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a23d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a240:	83 ec 08             	sub    $0x8,%esp
f010a243:	50                   	push   %eax
f010a244:	ff 75 08             	pushl  0x8(%ebp)
f010a247:	e8 bc 00 00 00       	call   f010a308 <env_table_ws_clear_entry>
f010a24c:	83 c4 10             	add    $0x10,%esp
			break;
f010a24f:	eb 09                	jmp    f010a25a <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a251:	ff 45 f4             	incl   -0xc(%ebp)
f010a254:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a258:	7e ac                	jle    f010a206 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a25a:	90                   	nop
f010a25b:	c9                   	leave  
f010a25c:	c3                   	ret    

f010a25d <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a25d:	55                   	push   %ebp
f010a25e:	89 e5                	mov    %esp,%ebp
f010a260:	53                   	push   %ebx
f010a261:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a264:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a268:	76 19                	jbe    f010a283 <env_table_ws_set_entry+0x26>
f010a26a:	68 50 59 12 f0       	push   $0xf0125950
f010a26f:	68 81 59 12 f0       	push   $0xf0125981
f010a274:	68 3f 01 00 00       	push   $0x13f
f010a279:	68 ac 57 12 f0       	push   $0xf01257ac
f010a27e:	e8 b6 60 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a283:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a28a:	76 19                	jbe    f010a2a5 <env_table_ws_set_entry+0x48>
f010a28c:	68 98 59 12 f0       	push   $0xf0125998
f010a291:	68 81 59 12 f0       	push   $0xf0125981
f010a296:	68 40 01 00 00       	push   $0x140
f010a29b:	68 ac 57 12 f0       	push   $0xf01257ac
f010a2a0:	e8 94 60 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a2a5:	8b 45 10             	mov    0x10(%ebp),%eax
f010a2a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a2ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a2ae:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a2b3:	89 c1                	mov    %eax,%ecx
f010a2b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a2b8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2bb:	89 d0                	mov    %edx,%eax
f010a2bd:	01 c0                	add    %eax,%eax
f010a2bf:	01 d0                	add    %edx,%eax
f010a2c1:	c1 e0 03             	shl    $0x3,%eax
f010a2c4:	01 d8                	add    %ebx,%eax
f010a2c6:	05 ac 00 00 00       	add    $0xac,%eax
f010a2cb:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a2cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2d0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2d3:	89 d0                	mov    %edx,%eax
f010a2d5:	01 c0                	add    %eax,%eax
f010a2d7:	01 d0                	add    %edx,%eax
f010a2d9:	c1 e0 03             	shl    $0x3,%eax
f010a2dc:	01 c8                	add    %ecx,%eax
f010a2de:	05 b0 00 00 00       	add    $0xb0,%eax
f010a2e3:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a2e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2e9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2ec:	89 d0                	mov    %edx,%eax
f010a2ee:	01 c0                	add    %eax,%eax
f010a2f0:	01 d0                	add    %edx,%eax
f010a2f2:	c1 e0 03             	shl    $0x3,%eax
f010a2f5:	01 c8                	add    %ecx,%eax
f010a2f7:	05 b4 00 00 00       	add    $0xb4,%eax
f010a2fc:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a302:	90                   	nop
}
f010a303:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a306:	c9                   	leave  
f010a307:	c3                   	ret    

f010a308 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a308:	55                   	push   %ebp
f010a309:	89 e5                	mov    %esp,%ebp
f010a30b:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a30e:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a312:	76 19                	jbe    f010a32d <env_table_ws_clear_entry+0x25>
f010a314:	68 50 59 12 f0       	push   $0xf0125950
f010a319:	68 81 59 12 f0       	push   $0xf0125981
f010a31e:	68 4b 01 00 00       	push   $0x14b
f010a323:	68 ac 57 12 f0       	push   $0xf01257ac
f010a328:	e8 0c 60 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a32d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a330:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a333:	89 d0                	mov    %edx,%eax
f010a335:	01 c0                	add    %eax,%eax
f010a337:	01 d0                	add    %edx,%eax
f010a339:	c1 e0 03             	shl    $0x3,%eax
f010a33c:	01 c8                	add    %ecx,%eax
f010a33e:	05 ac 00 00 00       	add    $0xac,%eax
f010a343:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a349:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a34c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a34f:	89 d0                	mov    %edx,%eax
f010a351:	01 c0                	add    %eax,%eax
f010a353:	01 d0                	add    %edx,%eax
f010a355:	c1 e0 03             	shl    $0x3,%eax
f010a358:	01 c8                	add    %ecx,%eax
f010a35a:	05 b0 00 00 00       	add    $0xb0,%eax
f010a35f:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010a362:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a365:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a368:	89 d0                	mov    %edx,%eax
f010a36a:	01 c0                	add    %eax,%eax
f010a36c:	01 d0                	add    %edx,%eax
f010a36e:	c1 e0 03             	shl    $0x3,%eax
f010a371:	01 c8                	add    %ecx,%eax
f010a373:	05 b4 00 00 00       	add    $0xb4,%eax
f010a378:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010a37e:	90                   	nop
f010a37f:	c9                   	leave  
f010a380:	c3                   	ret    

f010a381 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010a381:	55                   	push   %ebp
f010a382:	89 e5                	mov    %esp,%ebp
f010a384:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a387:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a38b:	76 19                	jbe    f010a3a6 <env_table_ws_get_virtual_address+0x25>
f010a38d:	68 50 59 12 f0       	push   $0xf0125950
f010a392:	68 81 59 12 f0       	push   $0xf0125981
f010a397:	68 53 01 00 00       	push   $0x153
f010a39c:	68 ac 57 12 f0       	push   $0xf01257ac
f010a3a1:	e8 93 5f ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010a3a6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a3a9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a3ac:	89 d0                	mov    %edx,%eax
f010a3ae:	01 c0                	add    %eax,%eax
f010a3b0:	01 d0                	add    %edx,%eax
f010a3b2:	c1 e0 03             	shl    $0x3,%eax
f010a3b5:	01 c8                	add    %ecx,%eax
f010a3b7:	05 ac 00 00 00       	add    $0xac,%eax
f010a3bc:	8b 00                	mov    (%eax),%eax
f010a3be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a3c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a3c4:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010a3c9:	c9                   	leave  
f010a3ca:	c3                   	ret    

f010a3cb <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010a3cb:	55                   	push   %ebp
f010a3cc:	89 e5                	mov    %esp,%ebp
f010a3ce:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a3d1:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a3d5:	76 19                	jbe    f010a3f0 <env_table_ws_get_time_stamp+0x25>
f010a3d7:	68 50 59 12 f0       	push   $0xf0125950
f010a3dc:	68 81 59 12 f0       	push   $0xf0125981
f010a3e1:	68 5a 01 00 00       	push   $0x15a
f010a3e6:	68 ac 57 12 f0       	push   $0xf01257ac
f010a3eb:	e8 49 5f ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010a3f0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a3f3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a3f6:	89 d0                	mov    %edx,%eax
f010a3f8:	01 c0                	add    %eax,%eax
f010a3fa:	01 d0                	add    %edx,%eax
f010a3fc:	c1 e0 03             	shl    $0x3,%eax
f010a3ff:	01 c8                	add    %ecx,%eax
f010a401:	05 b4 00 00 00       	add    $0xb4,%eax
f010a406:	8b 00                	mov    (%eax),%eax
}
f010a408:	c9                   	leave  
f010a409:	c3                   	ret    

f010a40a <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010a40a:	55                   	push   %ebp
f010a40b:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010a40d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a410:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a413:	89 d0                	mov    %edx,%eax
f010a415:	01 c0                	add    %eax,%eax
f010a417:	01 d0                	add    %edx,%eax
f010a419:	c1 e0 03             	shl    $0x3,%eax
f010a41c:	01 c8                	add    %ecx,%eax
f010a41e:	05 b0 00 00 00       	add    $0xb0,%eax
f010a423:	8a 00                	mov    (%eax),%al
f010a425:	0f b6 c0             	movzbl %al,%eax
}
f010a428:	5d                   	pop    %ebp
f010a429:	c3                   	ret    

f010a42a <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010a42a:	55                   	push   %ebp
f010a42b:	89 e5                	mov    %esp,%ebp
f010a42d:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a430:	83 ec 04             	sub    $0x4,%esp
f010a433:	68 cb 59 12 f0       	push   $0xf01259cb
f010a438:	68 6a 01 00 00       	push   $0x16a
f010a43d:	68 ac 57 12 f0       	push   $0xf01257ac
f010a442:	e8 f2 5e ff ff       	call   f0100339 <_panic>

f010a447 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010a447:	55                   	push   %ebp
f010a448:	89 e5                	mov    %esp,%ebp
f010a44a:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a44d:	83 ec 04             	sub    $0x4,%esp
f010a450:	68 cb 59 12 f0       	push   $0xf01259cb
f010a455:	68 6f 01 00 00       	push   $0x16f
f010a45a:	68 ac 57 12 f0       	push   $0xf01257ac
f010a45f:	e8 d5 5e ff ff       	call   f0100339 <_panic>

f010a464 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010a464:	55                   	push   %ebp
f010a465:	89 e5                	mov    %esp,%ebp
f010a467:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010a46a:	83 ec 04             	sub    $0x4,%esp
f010a46d:	68 dc 59 12 f0       	push   $0xf01259dc
f010a472:	6a 22                	push   $0x22
f010a474:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a479:	e8 bb 5e ff ff       	call   f0100339 <_panic>

f010a47e <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010a47e:	55                   	push   %ebp
f010a47f:	89 e5                	mov    %esp,%ebp
f010a481:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010a484:	83 ec 04             	sub    $0x4,%esp
f010a487:	68 28 5a 12 f0       	push   $0xf0125a28
f010a48c:	6a 35                	push   $0x35
f010a48e:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a493:	e8 a1 5e ff ff       	call   f0100339 <_panic>

f010a498 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010a498:	55                   	push   %ebp
f010a499:	89 e5                	mov    %esp,%ebp
f010a49b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010a49e:	83 ec 04             	sub    $0x4,%esp
f010a4a1:	68 58 5a 12 f0       	push   $0xf0125a58
f010a4a6:	6a 45                	push   $0x45
f010a4a8:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a4ad:	e8 87 5e ff ff       	call   f0100339 <_panic>

f010a4b2 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010a4b2:	55                   	push   %ebp
f010a4b3:	89 e5                	mov    %esp,%ebp
f010a4b5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010a4b8:	83 ec 04             	sub    $0x4,%esp
f010a4bb:	68 84 5a 12 f0       	push   $0xf0125a84
f010a4c0:	6a 53                	push   $0x53
f010a4c2:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a4c7:	e8 6d 5e ff ff       	call   f0100339 <_panic>

f010a4cc <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010a4cc:	55                   	push   %ebp
f010a4cd:	89 e5                	mov    %esp,%ebp
f010a4cf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010a4d2:	83 ec 04             	sub    $0x4,%esp
f010a4d5:	68 b4 5a 12 f0       	push   $0xf0125ab4
f010a4da:	6a 5d                	push   $0x5d
f010a4dc:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a4e1:	e8 53 5e ff ff       	call   f0100339 <_panic>

f010a4e6 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010a4e6:	55                   	push   %ebp
f010a4e7:	89 e5                	mov    %esp,%ebp
f010a4e9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010a4ec:	83 ec 04             	sub    $0x4,%esp
f010a4ef:	68 ec 5a 12 f0       	push   $0xf0125aec
f010a4f4:	6a 6a                	push   $0x6a
f010a4f6:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a4fb:	e8 39 5e ff ff       	call   f0100339 <_panic>

f010a500 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010a500:	55                   	push   %ebp
f010a501:	89 e5                	mov    %esp,%ebp
f010a503:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010a506:	e8 98 0e 00 00       	call   f010b3a3 <get_cpu_proc>
f010a50b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010a50e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a512:	7e 61                	jle    f010a575 <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010a514:	8b 45 08             	mov    0x8(%ebp),%eax
f010a517:	c1 e0 0c             	shl    $0xc,%eax
f010a51a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010a51d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a520:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a523:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010a526:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a529:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a52c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a52f:	01 c2                	add    %eax,%edx
f010a531:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a534:	8b 40 78             	mov    0x78(%eax),%eax
f010a537:	39 c2                	cmp    %eax,%edx
f010a539:	77 09                	ja     f010a544 <sys_sbrk+0x44>
f010a53b:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f010a540:	85 c0                	test   %eax,%eax
f010a542:	75 07                	jne    f010a54b <sys_sbrk+0x4b>
f010a544:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a549:	eb 3d                	jmp    f010a588 <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010a54b:	83 ec 04             	sub    $0x4,%esp
f010a54e:	ff 75 f0             	pushl  -0x10(%ebp)
f010a551:	ff 75 ec             	pushl  -0x14(%ebp)
f010a554:	ff 75 f4             	pushl  -0xc(%ebp)
f010a557:	e8 2e 00 00 00       	call   f010a58a <allocate_user_mem>
f010a55c:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010a55f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a562:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a565:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a568:	01 c2                	add    %eax,%edx
f010a56a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a56d:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010a570:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a573:	eb 13                	jmp    f010a588 <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010a575:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a579:	75 08                	jne    f010a583 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010a57b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a57e:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a581:	eb 05                	jmp    f010a588 <sys_sbrk+0x88>
	}

	return (void *)-1;
f010a583:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010a588:	c9                   	leave  
f010a589:	c3                   	ret    

f010a58a <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a58a:	55                   	push   %ebp
f010a58b:	89 e5                	mov    %esp,%ebp
f010a58d:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a590:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a597:	8b 55 10             	mov    0x10(%ebp),%edx
f010a59a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a59d:	01 d0                	add    %edx,%eax
f010a59f:	48                   	dec    %eax
f010a5a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a5a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5a6:	ba 00 00 00 00       	mov    $0x0,%edx
f010a5ab:	f7 75 f0             	divl   -0x10(%ebp)
f010a5ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5b1:	29 d0                	sub    %edx,%eax
f010a5b3:	c1 e8 0c             	shr    $0xc,%eax
f010a5b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010a5b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a5c0:	eb 78                	jmp    f010a63a <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010a5c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5c5:	c1 e0 0c             	shl    $0xc,%eax
f010a5c8:	89 c2                	mov    %eax,%edx
f010a5ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5cd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010a5d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5d3:	8b 40 64             	mov    0x64(%eax),%eax
f010a5d6:	83 ec 04             	sub    $0x4,%esp
f010a5d9:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010a5dc:	52                   	push   %edx
f010a5dd:	51                   	push   %ecx
f010a5de:	50                   	push   %eax
f010a5df:	e8 0b de ff ff       	call   f01083ef <get_page_table>
f010a5e4:	83 c4 10             	add    $0x10,%esp
f010a5e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010a5ea:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010a5ee:	75 23                	jne    f010a613 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010a5f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5f3:	c1 e0 0c             	shl    $0xc,%eax
f010a5f6:	89 c2                	mov    %eax,%edx
f010a5f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5fb:	01 c2                	add    %eax,%edx
f010a5fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a600:	8b 40 64             	mov    0x64(%eax),%eax
f010a603:	83 ec 08             	sub    $0x8,%esp
f010a606:	52                   	push   %edx
f010a607:	50                   	push   %eax
f010a608:	e8 38 df ff ff       	call   f0108545 <create_page_table>
f010a60d:	83 c4 10             	add    $0x10,%esp
f010a610:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010a613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a616:	c1 e0 0c             	shl    $0xc,%eax
f010a619:	89 c2                	mov    %eax,%edx
f010a61b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a61e:	01 c2                	add    %eax,%edx
f010a620:	8b 45 08             	mov    0x8(%ebp),%eax
f010a623:	8b 40 64             	mov    0x64(%eax),%eax
f010a626:	6a 00                	push   $0x0
f010a628:	68 00 02 00 00       	push   $0x200
f010a62d:	52                   	push   %edx
f010a62e:	50                   	push   %eax
f010a62f:	e8 af ef ff ff       	call   f01095e3 <pt_set_page_permissions>
f010a634:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010a637:	ff 45 f4             	incl   -0xc(%ebp)
f010a63a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a63d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a640:	72 80                	jb     f010a5c2 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010a642:	90                   	nop
f010a643:	c9                   	leave  
f010a644:	c3                   	ret    

f010a645 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a645:	55                   	push   %ebp
f010a646:	89 e5                	mov    %esp,%ebp
f010a648:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a64b:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a652:	8b 55 10             	mov    0x10(%ebp),%edx
f010a655:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a658:	01 d0                	add    %edx,%eax
f010a65a:	48                   	dec    %eax
f010a65b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a65e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a661:	ba 00 00 00 00       	mov    $0x0,%edx
f010a666:	f7 75 f0             	divl   -0x10(%ebp)
f010a669:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a66c:	29 d0                	sub    %edx,%eax
f010a66e:	c1 e8 0c             	shr    $0xc,%eax
f010a671:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010a674:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a67b:	e9 86 00 00 00       	jmp    f010a706 <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010a680:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a683:	c1 e0 0c             	shl    $0xc,%eax
f010a686:	89 c2                	mov    %eax,%edx
f010a688:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a68b:	01 c2                	add    %eax,%edx
f010a68d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a690:	8b 40 64             	mov    0x64(%eax),%eax
f010a693:	68 00 02 00 00       	push   $0x200
f010a698:	6a 00                	push   $0x0
f010a69a:	52                   	push   %edx
f010a69b:	50                   	push   %eax
f010a69c:	e8 42 ef ff ff       	call   f01095e3 <pt_set_page_permissions>
f010a6a1:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010a6a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6a7:	c1 e0 0c             	shl    $0xc,%eax
f010a6aa:	89 c2                	mov    %eax,%edx
f010a6ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a6af:	01 d0                	add    %edx,%eax
f010a6b1:	83 ec 08             	sub    $0x8,%esp
f010a6b4:	50                   	push   %eax
f010a6b5:	ff 75 08             	pushl  0x8(%ebp)
f010a6b8:	e8 24 9e ff ff       	call   f01044e1 <pf_read_env_page>
f010a6bd:	83 c4 10             	add    $0x10,%esp
f010a6c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010a6c3:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010a6c7:	75 1e                	jne    f010a6e7 <free_user_mem+0xa2>
f010a6c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6cc:	c1 e0 0c             	shl    $0xc,%eax
f010a6cf:	89 c2                	mov    %eax,%edx
f010a6d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a6d4:	01 d0                	add    %edx,%eax
f010a6d6:	83 ec 08             	sub    $0x8,%esp
f010a6d9:	50                   	push   %eax
f010a6da:	ff 75 08             	pushl  0x8(%ebp)
f010a6dd:	e8 a2 f1 ff ff       	call   f0109884 <env_page_ws_invalidate>
f010a6e2:	83 c4 10             	add    $0x10,%esp
f010a6e5:	eb 1c                	jmp    f010a703 <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010a6e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6ea:	c1 e0 0c             	shl    $0xc,%eax
f010a6ed:	89 c2                	mov    %eax,%edx
f010a6ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a6f2:	01 d0                	add    %edx,%eax
f010a6f4:	83 ec 08             	sub    $0x8,%esp
f010a6f7:	50                   	push   %eax
f010a6f8:	ff 75 08             	pushl  0x8(%ebp)
f010a6fb:	e8 a4 9e ff ff       	call   f01045a4 <pf_remove_env_page>
f010a700:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010a703:	ff 45 f4             	incl   -0xc(%ebp)
f010a706:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a709:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a70c:	0f 82 6e ff ff ff    	jb     f010a680 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010a712:	90                   	nop
f010a713:	c9                   	leave  
f010a714:	c3                   	ret    

f010a715 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a715:	55                   	push   %ebp
f010a716:	89 e5                	mov    %esp,%ebp
f010a718:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010a71b:	83 ec 04             	sub    $0x4,%esp
f010a71e:	68 24 5b 12 f0       	push   $0xf0125b24
f010a723:	68 e0 00 00 00       	push   $0xe0
f010a728:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a72d:	e8 07 5c ff ff       	call   f0100339 <_panic>

f010a732 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010a732:	55                   	push   %ebp
f010a733:	89 e5                	mov    %esp,%ebp
f010a735:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010a738:	83 ec 04             	sub    $0x4,%esp
f010a73b:	68 64 5b 12 f0       	push   $0xf0125b64
f010a740:	68 ea 00 00 00       	push   $0xea
f010a745:	68 0a 5a 12 f0       	push   $0xf0125a0a
f010a74a:	e8 ea 5b ff ff       	call   f0100339 <_panic>

f010a74f <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010a74f:	55                   	push   %ebp
f010a750:	89 e5                	mov    %esp,%ebp
f010a752:	56                   	push   %esi
f010a753:	53                   	push   %ebx
f010a754:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010a757:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010a75e:	e9 b0 01 00 00       	jmp    f010a913 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010a763:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a769:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a76c:	89 d0                	mov    %edx,%eax
f010a76e:	c1 e0 03             	shl    $0x3,%eax
f010a771:	01 d0                	add    %edx,%eax
f010a773:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a77a:	01 d8                	add    %ebx,%eax
f010a77c:	01 c0                	add    %eax,%eax
f010a77e:	01 d0                	add    %edx,%eax
f010a780:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a787:	01 d8                	add    %ebx,%eax
f010a789:	01 d0                	add    %edx,%eax
f010a78b:	01 c8                	add    %ecx,%eax
f010a78d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010a794:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a79a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a79d:	89 d0                	mov    %edx,%eax
f010a79f:	c1 e0 03             	shl    $0x3,%eax
f010a7a2:	01 d0                	add    %edx,%eax
f010a7a4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7ab:	01 d8                	add    %ebx,%eax
f010a7ad:	01 c0                	add    %eax,%eax
f010a7af:	01 d0                	add    %edx,%eax
f010a7b1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7b8:	01 d8                	add    %ebx,%eax
f010a7ba:	01 d0                	add    %edx,%eax
f010a7bc:	01 c8                	add    %ecx,%eax
f010a7be:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010a7c5:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a7cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7ce:	89 d0                	mov    %edx,%eax
f010a7d0:	c1 e0 03             	shl    $0x3,%eax
f010a7d3:	01 d0                	add    %edx,%eax
f010a7d5:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7dc:	01 d8                	add    %ebx,%eax
f010a7de:	01 c0                	add    %eax,%eax
f010a7e0:	01 d0                	add    %edx,%eax
f010a7e2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7e9:	01 d8                	add    %ebx,%eax
f010a7eb:	01 d0                	add    %edx,%eax
f010a7ed:	01 c8                	add    %ecx,%eax
f010a7ef:	85 c0                	test   %eax,%eax
f010a7f1:	75 14                	jne    f010a807 <env_init+0xb8>
f010a7f3:	83 ec 04             	sub    $0x4,%esp
f010a7f6:	68 90 5b 12 f0       	push   $0xf0125b90
f010a7fb:	6a 65                	push   $0x65
f010a7fd:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010a802:	e8 32 5b ff ff       	call   f0100339 <_panic>
f010a807:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a80d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a810:	89 d0                	mov    %edx,%eax
f010a812:	c1 e0 03             	shl    $0x3,%eax
f010a815:	01 d0                	add    %edx,%eax
f010a817:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a81e:	01 d8                	add    %ebx,%eax
f010a820:	01 c0                	add    %eax,%eax
f010a822:	01 d0                	add    %edx,%eax
f010a824:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a82b:	01 d8                	add    %ebx,%eax
f010a82d:	01 d0                	add    %edx,%eax
f010a82f:	01 c8                	add    %ecx,%eax
f010a831:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010a837:	89 50 08             	mov    %edx,0x8(%eax)
f010a83a:	8b 40 08             	mov    0x8(%eax),%eax
f010a83d:	85 c0                	test   %eax,%eax
f010a83f:	74 35                	je     f010a876 <env_init+0x127>
f010a841:	8b 0d d4 47 69 f0    	mov    0xf06947d4,%ecx
f010a847:	8b 1d d0 47 69 f0    	mov    0xf06947d0,%ebx
f010a84d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a850:	89 d0                	mov    %edx,%eax
f010a852:	c1 e0 03             	shl    $0x3,%eax
f010a855:	01 d0                	add    %edx,%eax
f010a857:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a85e:	01 f0                	add    %esi,%eax
f010a860:	01 c0                	add    %eax,%eax
f010a862:	01 d0                	add    %edx,%eax
f010a864:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a86b:	01 f0                	add    %esi,%eax
f010a86d:	01 d0                	add    %edx,%eax
f010a86f:	01 d8                	add    %ebx,%eax
f010a871:	89 41 0c             	mov    %eax,0xc(%ecx)
f010a874:	eb 2f                	jmp    f010a8a5 <env_init+0x156>
f010a876:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a87c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a87f:	89 d0                	mov    %edx,%eax
f010a881:	c1 e0 03             	shl    $0x3,%eax
f010a884:	01 d0                	add    %edx,%eax
f010a886:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a88d:	01 d8                	add    %ebx,%eax
f010a88f:	01 c0                	add    %eax,%eax
f010a891:	01 d0                	add    %edx,%eax
f010a893:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a89a:	01 d8                	add    %ebx,%eax
f010a89c:	01 d0                	add    %edx,%eax
f010a89e:	01 c8                	add    %ecx,%eax
f010a8a0:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010a8a5:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a8ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a8ae:	89 d0                	mov    %edx,%eax
f010a8b0:	c1 e0 03             	shl    $0x3,%eax
f010a8b3:	01 d0                	add    %edx,%eax
f010a8b5:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8bc:	01 d8                	add    %ebx,%eax
f010a8be:	01 c0                	add    %eax,%eax
f010a8c0:	01 d0                	add    %edx,%eax
f010a8c2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8c9:	01 d8                	add    %ebx,%eax
f010a8cb:	01 d0                	add    %edx,%eax
f010a8cd:	01 c8                	add    %ecx,%eax
f010a8cf:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010a8d4:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a8da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a8dd:	89 d0                	mov    %edx,%eax
f010a8df:	c1 e0 03             	shl    $0x3,%eax
f010a8e2:	01 d0                	add    %edx,%eax
f010a8e4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8eb:	01 d8                	add    %ebx,%eax
f010a8ed:	01 c0                	add    %eax,%eax
f010a8ef:	01 d0                	add    %edx,%eax
f010a8f1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8f8:	01 d8                	add    %ebx,%eax
f010a8fa:	01 d0                	add    %edx,%eax
f010a8fc:	01 c8                	add    %ecx,%eax
f010a8fe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a905:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010a90a:	40                   	inc    %eax
f010a90b:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010a910:	ff 4d f4             	decl   -0xc(%ebp)
f010a913:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a917:	0f 89 46 fe ff ff    	jns    f010a763 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010a91d:	90                   	nop
f010a91e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a921:	5b                   	pop    %ebx
f010a922:	5e                   	pop    %esi
f010a923:	5d                   	pop    %ebp
f010a924:	c3                   	ret    

f010a925 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010a925:	55                   	push   %ebp
f010a926:	89 e5                	mov    %esp,%ebp
f010a928:	57                   	push   %edi
f010a929:	56                   	push   %esi
f010a92a:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010a930:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010a937:	83 ec 0c             	sub    $0xc,%esp
f010a93a:	ff 75 08             	pushl  0x8(%ebp)
f010a93d:	e8 b8 1e 00 00       	call   f010c7fa <get_user_program_info>
f010a942:	83 c4 10             	add    $0x10,%esp
f010a945:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010a948:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a94c:	75 0a                	jne    f010a958 <env_create+0x33>
	{
		return NULL;
f010a94e:	b8 00 00 00 00       	mov    $0x0,%eax
f010a953:	e9 aa 09 00 00       	jmp    f010b302 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010a958:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a95b:	8b 40 08             	mov    0x8(%eax),%eax
f010a95e:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010a961:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010a968:	00 00 00 
	if(allocate_environment(&e) < 0)
f010a96b:	83 ec 0c             	sub    $0xc,%esp
f010a96e:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010a974:	50                   	push   %eax
f010a975:	e8 96 0e 00 00       	call   f010b810 <allocate_environment>
f010a97a:	83 c4 10             	add    $0x10,%esp
f010a97d:	85 c0                	test   %eax,%eax
f010a97f:	79 0a                	jns    f010a98b <env_create+0x66>
	{
		return NULL;
f010a981:	b8 00 00 00 00       	mov    $0x0,%eax
f010a986:	e9 77 09 00 00       	jmp    f010b302 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010a98b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a98e:	8b 00                	mov    (%eax),%eax
f010a990:	83 ec 0c             	sub    $0xc,%esp
f010a993:	50                   	push   %eax
f010a994:	e8 6d 4c 01 00       	call   f011f606 <strlen>
f010a999:	83 c4 10             	add    $0x10,%esp
f010a99c:	83 f8 3f             	cmp    $0x3f,%eax
f010a99f:	7f 1d                	jg     f010a9be <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010a9a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a9a4:	8b 00                	mov    (%eax),%eax
f010a9a6:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a9ac:	83 c2 20             	add    $0x20,%edx
f010a9af:	83 ec 08             	sub    $0x8,%esp
f010a9b2:	50                   	push   %eax
f010a9b3:	52                   	push   %edx
f010a9b4:	e8 9c 4c 01 00       	call   f011f655 <strcpy>
f010a9b9:	83 c4 10             	add    $0x10,%esp
f010a9bc:	eb 1d                	jmp    f010a9db <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010a9be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a9c1:	8b 00                	mov    (%eax),%eax
f010a9c3:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a9c9:	83 c2 20             	add    $0x20,%edx
f010a9cc:	83 ec 04             	sub    $0x4,%esp
f010a9cf:	6a 3f                	push   $0x3f
f010a9d1:	50                   	push   %eax
f010a9d2:	52                   	push   %edx
f010a9d3:	e8 ab 4c 01 00       	call   f011f683 <strncpy>
f010a9d8:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010a9db:	e8 fc 13 00 00       	call   f010bddc <create_user_directory>
f010a9e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010a9e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a9e6:	83 ec 0c             	sub    $0xc,%esp
f010a9e9:	50                   	push   %eax
f010a9ea:	e8 5b eb ff ff       	call   f010954a <kheap_physical_address>
f010a9ef:	83 c4 10             	add    $0x10,%esp
f010a9f2:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010a9f5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9fe:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010aa04:	83 ec 0c             	sub    $0xc,%esp
f010aa07:	6a 02                	push   $0x2
f010aa09:	e8 d1 45 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010aa0e:	83 c4 10             	add    $0x10,%esp
f010aa11:	85 c0                	test   %eax,%eax
f010aa13:	74 21                	je     f010aa36 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010aa15:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa1b:	8b 55 10             	mov    0x10(%ebp),%edx
f010aa1e:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010aa24:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa2a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa2d:	2b 55 10             	sub    0x10(%ebp),%edx
f010aa30:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010aa36:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010aa3a:	75 12                	jne    f010aa4e <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010aa3c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa42:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010aa49:	00 00 00 
f010aa4c:	eb 0f                	jmp    f010aa5d <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010aa4e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa54:	8b 55 14             	mov    0x14(%ebp),%edx
f010aa57:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010aa5d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa63:	83 ec 04             	sub    $0x4,%esp
f010aa66:	ff 75 bc             	pushl  -0x44(%ebp)
f010aa69:	ff 75 c0             	pushl  -0x40(%ebp)
f010aa6c:	50                   	push   %eax
f010aa6d:	e8 c8 14 00 00       	call   f010bf3a <initialize_environment>
f010aa72:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010aa75:	e8 55 c7 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010aa7a:	0f 20 d8             	mov    %cr3,%eax
f010aa7d:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010aa80:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010aa83:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010aa86:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa8c:	8b 40 68             	mov    0x68(%eax),%eax
f010aa8f:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010aa95:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010aa9b:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010aa9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010aaa5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010aaac:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aab2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010aab8:	48                   	dec    %eax
f010aab9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010aabc:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010aac3:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010aac6:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010aacc:	83 ec 08             	sub    $0x8,%esp
f010aacf:	ff 75 c8             	pushl  -0x38(%ebp)
f010aad2:	50                   	push   %eax
f010aad3:	e8 34 1a 00 00       	call   f010c50c <PROGRAM_SEGMENT_FIRST>
f010aad8:	83 c4 0c             	add    $0xc,%esp
f010aadb:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aae1:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010aae7:	b9 05 00 00 00       	mov    $0x5,%ecx
f010aaec:	89 c7                	mov    %eax,%edi
f010aaee:	89 d6                	mov    %edx,%esi
f010aaf0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010aaf2:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aaf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010aafb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aafe:	8b 40 10             	mov    0x10(%eax),%eax
f010ab01:	83 f8 ff             	cmp    $0xffffffff,%eax
f010ab04:	75 07                	jne    f010ab0d <env_create+0x1e8>
f010ab06:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010ab0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ab10:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ab13:	e9 fa 02 00 00       	jmp    f010ae12 <env_create+0x4ed>
		{
			segment_counter++;
f010ab18:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010ab1b:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010ab22:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010ab25:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab2b:	83 ec 0c             	sub    $0xc,%esp
f010ab2e:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010ab34:	52                   	push   %edx
f010ab35:	ff 75 ec             	pushl  -0x14(%ebp)
f010ab38:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010ab3e:	52                   	push   %edx
f010ab3f:	ff 75 f4             	pushl  -0xc(%ebp)
f010ab42:	50                   	push   %eax
f010ab43:	e8 86 0d 00 00       	call   f010b8ce <program_segment_alloc_map_copy_workingset>
f010ab48:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010ab4b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010ab51:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010ab54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab57:	8b 00                	mov    (%eax),%eax
f010ab59:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010ab5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab5f:	8b 40 0c             	mov    0xc(%eax),%eax
f010ab62:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010ab65:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab68:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010ab6b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010ab6e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ab73:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010ab76:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010ab7d:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010ab80:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010ab83:	01 d0                	add    %edx,%eax
f010ab85:	48                   	dec    %eax
f010ab86:	89 45 98             	mov    %eax,-0x68(%ebp)
f010ab89:	8b 45 98             	mov    -0x68(%ebp),%eax
f010ab8c:	ba 00 00 00 00       	mov    $0x0,%edx
f010ab91:	f7 75 9c             	divl   -0x64(%ebp)
f010ab94:	8b 45 98             	mov    -0x68(%ebp),%eax
f010ab97:	29 d0                	sub    %edx,%eax
f010ab99:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010ab9c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab9f:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010aba2:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010aba5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aba8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010abab:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010abb1:	8b 45 90             	mov    -0x70(%ebp),%eax
f010abb4:	01 d0                	add    %edx,%eax
f010abb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010abb9:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010abbd:	74 73                	je     f010ac32 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010abbf:	a1 0c da 6b f0       	mov    0xf06bda0c,%eax
f010abc4:	83 ec 04             	sub    $0x4,%esp
f010abc7:	68 00 10 00 00       	push   $0x1000
f010abcc:	6a 00                	push   $0x0
f010abce:	50                   	push   %eax
f010abcf:	e8 20 4c 01 00       	call   f011f7f4 <memset>
f010abd4:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010abd7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010abda:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010abdd:	eb 13                	jmp    f010abf2 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010abdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010abe2:	8a 10                	mov    (%eax),%dl
f010abe4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abe7:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010abe9:	ff 45 dc             	incl   -0x24(%ebp)
f010abec:	ff 45 e4             	incl   -0x1c(%ebp)
f010abef:	ff 45 e0             	incl   -0x20(%ebp)
f010abf2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010abf5:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010abf8:	72 e5                	jb     f010abdf <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010abfa:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010ac00:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ac06:	83 ec 04             	sub    $0x4,%esp
f010ac09:	52                   	push   %edx
f010ac0a:	ff 75 a0             	pushl  -0x60(%ebp)
f010ac0d:	50                   	push   %eax
f010ac0e:	e8 1e 96 ff ff       	call   f0104231 <pf_add_env_page>
f010ac13:	83 c4 10             	add    $0x10,%esp
f010ac16:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ac19:	75 17                	jne    f010ac32 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ac1b:	83 ec 04             	sub    $0x4,%esp
f010ac1e:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010ac23:	68 f5 00 00 00       	push   $0xf5
f010ac28:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010ac2d:	e8 07 57 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010ac32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac35:	8b 50 04             	mov    0x4(%eax),%edx
f010ac38:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac3b:	01 d0                	add    %edx,%eax
f010ac3d:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010ac40:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010ac43:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ac48:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010ac4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac4e:	8b 50 04             	mov    0x4(%eax),%edx
f010ac51:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac54:	01 d0                	add    %edx,%eax
f010ac56:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ac59:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010ac5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ac5f:	eb 43                	jmp    f010aca4 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010ac61:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ac64:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ac6a:	83 ec 04             	sub    $0x4,%esp
f010ac6d:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ac70:	52                   	push   %edx
f010ac71:	50                   	push   %eax
f010ac72:	e8 ba 95 ff ff       	call   f0104231 <pf_add_env_page>
f010ac77:	83 c4 10             	add    $0x10,%esp
f010ac7a:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ac7d:	75 17                	jne    f010ac96 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ac7f:	83 ec 04             	sub    $0x4,%esp
f010ac82:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010ac87:	68 02 01 00 00       	push   $0x102
f010ac8c:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010ac91:	e8 a3 56 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ac96:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010ac9d:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010aca4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aca7:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010acaa:	72 b5                	jb     f010ac61 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010acac:	a1 0c da 6b f0       	mov    0xf06bda0c,%eax
f010acb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010acb4:	83 ec 04             	sub    $0x4,%esp
f010acb7:	68 00 10 00 00       	push   $0x1000
f010acbc:	6a 00                	push   $0x0
f010acbe:	ff 75 e0             	pushl  -0x20(%ebp)
f010acc1:	e8 2e 4b 01 00       	call   f011f7f4 <memset>
f010acc6:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010acc9:	8b 45 88             	mov    -0x78(%ebp),%eax
f010accc:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010accf:	eb 13                	jmp    f010ace4 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010acd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010acd4:	8a 10                	mov    (%eax),%dl
f010acd6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010acd9:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010acdb:	ff 45 dc             	incl   -0x24(%ebp)
f010acde:	ff 45 e4             	incl   -0x1c(%ebp)
f010ace1:	ff 45 e0             	incl   -0x20(%ebp)
f010ace4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ace7:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010acea:	72 e5                	jb     f010acd1 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010acec:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010acf2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010acf8:	83 ec 04             	sub    $0x4,%esp
f010acfb:	52                   	push   %edx
f010acfc:	ff 75 88             	pushl  -0x78(%ebp)
f010acff:	50                   	push   %eax
f010ad00:	e8 2c 95 ff ff       	call   f0104231 <pf_add_env_page>
f010ad05:	83 c4 10             	add    $0x10,%esp
f010ad08:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ad0b:	75 17                	jne    f010ad24 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ad0d:	83 ec 04             	sub    $0x4,%esp
f010ad10:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010ad15:	68 11 01 00 00       	push   $0x111
f010ad1a:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010ad1f:	e8 15 56 ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010ad24:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010ad2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad2e:	8b 50 04             	mov    0x4(%eax),%edx
f010ad31:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ad34:	01 c2                	add    %eax,%edx
f010ad36:	8b 45 80             	mov    -0x80(%ebp),%eax
f010ad39:	01 d0                	add    %edx,%eax
f010ad3b:	48                   	dec    %eax
f010ad3c:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010ad42:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ad48:	ba 00 00 00 00       	mov    $0x0,%edx
f010ad4d:	f7 75 80             	divl   -0x80(%ebp)
f010ad50:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ad56:	29 d0                	sub    %edx,%eax
f010ad58:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010ad5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad5e:	8b 50 08             	mov    0x8(%eax),%edx
f010ad61:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ad64:	01 d0                	add    %edx,%eax
f010ad66:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010ad69:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010ad6f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010ad76:	eb 41                	jmp    f010adb9 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010ad78:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad7e:	83 ec 04             	sub    $0x4,%esp
f010ad81:	6a 01                	push   $0x1
f010ad83:	ff 75 d8             	pushl  -0x28(%ebp)
f010ad86:	50                   	push   %eax
f010ad87:	e8 74 93 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010ad8c:	83 c4 10             	add    $0x10,%esp
f010ad8f:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ad92:	75 17                	jne    f010adab <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ad94:	83 ec 04             	sub    $0x4,%esp
f010ad97:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010ad9c:	68 1e 01 00 00       	push   $0x11e
f010ada1:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010ada6:	e8 8e 55 ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010adab:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010adb2:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010adb9:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010adc0:	10 00 00 
f010adc3:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010adc9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010adcf:	01 d0                	add    %edx,%eax
f010add1:	48                   	dec    %eax
f010add2:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010add8:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010adde:	ba 00 00 00 00       	mov    $0x0,%edx
f010ade3:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010ade9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010adef:	29 d0                	sub    %edx,%eax
f010adf1:	89 c2                	mov    %eax,%edx
f010adf3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010adf6:	39 c2                	cmp    %eax,%edx
f010adf8:	0f 87 7a ff ff ff    	ja     f010ad78 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010adfe:	83 ec 08             	sub    $0x8,%esp
f010ae01:	ff 75 c8             	pushl  -0x38(%ebp)
f010ae04:	ff 75 f4             	pushl  -0xc(%ebp)
f010ae07:	e8 f5 15 00 00       	call   f010c401 <PROGRAM_SEGMENT_NEXT>
f010ae0c:	83 c4 10             	add    $0x10,%esp
f010ae0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ae12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ae16:	0f 85 fc fc ff ff    	jne    f010ab18 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ae1c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae22:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010ae28:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ae2b:	eb 77                	jmp    f010aea4 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010ae2d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ae30:	8b 00                	mov    (%eax),%eax
f010ae32:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010ae38:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae3e:	8b 40 64             	mov    0x64(%eax),%eax
f010ae41:	83 ec 04             	sub    $0x4,%esp
f010ae44:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010ae4a:	52                   	push   %edx
f010ae4b:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010ae51:	50                   	push   %eax
f010ae52:	e8 98 d5 ff ff       	call   f01083ef <get_page_table>
f010ae57:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010ae5a:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010ae60:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010ae66:	c1 ea 0c             	shr    $0xc,%edx
f010ae69:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010ae6f:	c1 e2 02             	shl    $0x2,%edx
f010ae72:	01 d0                	add    %edx,%eax
f010ae74:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010ae7a:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010ae80:	c1 e9 0c             	shr    $0xc,%ecx
f010ae83:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010ae89:	c1 e1 02             	shl    $0x2,%ecx
f010ae8c:	01 ca                	add    %ecx,%edx
f010ae8e:	8b 12                	mov    (%edx),%edx
f010ae90:	83 e2 bf             	and    $0xffffffbf,%edx
f010ae93:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ae95:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae9b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010aea1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010aea4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aeaa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010aeae:	74 08                	je     f010aeb8 <env_create+0x593>
f010aeb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aeb3:	8b 52 10             	mov    0x10(%edx),%edx
f010aeb6:	eb 05                	jmp    f010aebd <env_create+0x598>
f010aeb8:	ba 00 00 00 00       	mov    $0x0,%edx
f010aebd:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010aec3:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010aec9:	85 c0                	test   %eax,%eax
f010aecb:	0f 85 5c ff ff ff    	jne    f010ae2d <env_create+0x508>
f010aed1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010aed5:	0f 85 52 ff ff ff    	jne    f010ae2d <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010aedb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010aede:	8b 50 08             	mov    0x8(%eax),%edx
f010aee1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aee7:	83 ec 08             	sub    $0x8,%esp
f010aeea:	52                   	push   %edx
f010aeeb:	50                   	push   %eax
f010aeec:	e8 d0 14 00 00       	call   f010c3c1 <set_environment_entry_point>
f010aef1:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010aef4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aefa:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010af01:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010af08:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010af0b:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010af12:	e9 42 03 00 00       	jmp    f010b259 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010af17:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010af1e:	00 00 00 
			allocate_frame(&pp);
f010af21:	83 ec 0c             	sub    $0xc,%esp
f010af24:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010af2a:	50                   	push   %eax
f010af2b:	e8 82 d2 ff ff       	call   f01081b2 <allocate_frame>
f010af30:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010af33:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010af39:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af3f:	8b 40 64             	mov    0x64(%eax),%eax
f010af42:	6a 06                	push   $0x6
f010af44:	ff 75 d0             	pushl  -0x30(%ebp)
f010af47:	52                   	push   %edx
f010af48:	50                   	push   %eax
f010af49:	e8 35 d9 ff ff       	call   f0108883 <loadtime_map_frame>
f010af4e:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010af51:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010af54:	83 ec 04             	sub    $0x4,%esp
f010af57:	68 00 10 00 00       	push   $0x1000
f010af5c:	6a 00                	push   $0x0
f010af5e:	50                   	push   %eax
f010af5f:	e8 90 48 01 00       	call   f011f7f4 <memset>
f010af64:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010af67:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af6d:	83 ec 08             	sub    $0x8,%esp
f010af70:	ff 75 d0             	pushl  -0x30(%ebp)
f010af73:	50                   	push   %eax
f010af74:	e8 a0 e8 ff ff       	call   f0109819 <env_page_ws_list_create_element>
f010af79:	83 c4 10             	add    $0x10,%esp
f010af7c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010af7f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010af83:	75 17                	jne    f010af9c <env_create+0x677>
f010af85:	83 ec 04             	sub    $0x4,%esp
f010af88:	68 18 5c 12 f0       	push   $0xf0125c18
f010af8d:	68 5d 01 00 00       	push   $0x15d
f010af92:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010af97:	e8 9d 53 ff ff       	call   f0100339 <_panic>
f010af9c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afa2:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010afa8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afab:	89 50 14             	mov    %edx,0x14(%eax)
f010afae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afb1:	8b 40 14             	mov    0x14(%eax),%eax
f010afb4:	85 c0                	test   %eax,%eax
f010afb6:	74 14                	je     f010afcc <env_create+0x6a7>
f010afb8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afbe:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010afc4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afc7:	89 50 10             	mov    %edx,0x10(%eax)
f010afca:	eb 0f                	jmp    f010afdb <env_create+0x6b6>
f010afcc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afd2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afd5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010afdb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afe1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afe4:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010afea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afed:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010aff4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010affa:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b000:	42                   	inc    %edx
f010b001:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b007:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b00d:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b013:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b019:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b01f:	39 c2                	cmp    %eax,%edx
f010b021:	75 1a                	jne    f010b03d <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b023:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b029:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b02f:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b035:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b03b:	eb 10                	jmp    f010b04d <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b03d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b043:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b04a:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b04d:	83 ec 0c             	sub    $0xc,%esp
f010b050:	6a 02                	push   $0x2
f010b052:	e8 88 3f 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010b057:	83 c4 10             	add    $0x10,%esp
f010b05a:	85 c0                	test   %eax,%eax
f010b05c:	0f 84 d3 01 00 00    	je     f010b235 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b062:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b066:	75 17                	jne    f010b07f <env_create+0x75a>
f010b068:	83 ec 04             	sub    $0x4,%esp
f010b06b:	68 3b 5c 12 f0       	push   $0xf0125c3b
f010b070:	68 6a 01 00 00       	push   $0x16a
f010b075:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b07a:	e8 ba 52 ff ff       	call   f0100339 <_panic>
f010b07f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b082:	8b 40 10             	mov    0x10(%eax),%eax
f010b085:	85 c0                	test   %eax,%eax
f010b087:	74 11                	je     f010b09a <env_create+0x775>
f010b089:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b08c:	8b 40 10             	mov    0x10(%eax),%eax
f010b08f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b092:	8b 52 14             	mov    0x14(%edx),%edx
f010b095:	89 50 14             	mov    %edx,0x14(%eax)
f010b098:	eb 12                	jmp    f010b0ac <env_create+0x787>
f010b09a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0a0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0a3:	8b 52 14             	mov    0x14(%edx),%edx
f010b0a6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b0ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0af:	8b 40 14             	mov    0x14(%eax),%eax
f010b0b2:	85 c0                	test   %eax,%eax
f010b0b4:	74 11                	je     f010b0c7 <env_create+0x7a2>
f010b0b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0b9:	8b 40 14             	mov    0x14(%eax),%eax
f010b0bc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0bf:	8b 52 10             	mov    0x10(%edx),%edx
f010b0c2:	89 50 10             	mov    %edx,0x10(%eax)
f010b0c5:	eb 12                	jmp    f010b0d9 <env_create+0x7b4>
f010b0c7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0d0:	8b 52 10             	mov    0x10(%edx),%edx
f010b0d3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b0d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0dc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b0e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0e6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b0ed:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0f3:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b0f9:	4a                   	dec    %edx
f010b0fa:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b100:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b106:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b10c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b112:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b118:	39 c2                	cmp    %eax,%edx
f010b11a:	0f 83 8d 00 00 00    	jae    f010b1ad <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b120:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b124:	75 17                	jne    f010b13d <env_create+0x818>
f010b126:	83 ec 04             	sub    $0x4,%esp
f010b129:	68 90 5b 12 f0       	push   $0xf0125b90
f010b12e:	68 6f 01 00 00       	push   $0x16f
f010b133:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b138:	e8 fc 51 ff ff       	call   f0100339 <_panic>
f010b13d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b143:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b149:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b14c:	89 50 10             	mov    %edx,0x10(%eax)
f010b14f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b152:	8b 40 10             	mov    0x10(%eax),%eax
f010b155:	85 c0                	test   %eax,%eax
f010b157:	74 14                	je     f010b16d <env_create+0x848>
f010b159:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b15f:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b165:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b168:	89 50 14             	mov    %edx,0x14(%eax)
f010b16b:	eb 0f                	jmp    f010b17c <env_create+0x857>
f010b16d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b173:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b176:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b17c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b182:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b185:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b18b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b18e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b195:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b19b:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b1a1:	42                   	inc    %edx
f010b1a2:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b1a8:	e9 88 00 00 00       	jmp    f010b235 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b1ad:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b1b1:	75 17                	jne    f010b1ca <env_create+0x8a5>
f010b1b3:	83 ec 04             	sub    $0x4,%esp
f010b1b6:	68 90 5b 12 f0       	push   $0xf0125b90
f010b1bb:	68 73 01 00 00       	push   $0x173
f010b1c0:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b1c5:	e8 6f 51 ff ff       	call   f0100339 <_panic>
f010b1ca:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1d0:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b1d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b1d9:	89 50 10             	mov    %edx,0x10(%eax)
f010b1dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b1df:	8b 40 10             	mov    0x10(%eax),%eax
f010b1e2:	85 c0                	test   %eax,%eax
f010b1e4:	74 14                	je     f010b1fa <env_create+0x8d5>
f010b1e6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1ec:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b1f2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b1f5:	89 50 14             	mov    %edx,0x14(%eax)
f010b1f8:	eb 0f                	jmp    f010b209 <env_create+0x8e4>
f010b1fa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b200:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b203:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b209:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b20f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b212:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b218:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b21b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b222:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b228:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b22e:	42                   	inc    %edx
f010b22f:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b235:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b23b:	83 ec 04             	sub    $0x4,%esp
f010b23e:	6a 01                	push   $0x1
f010b240:	ff 75 d0             	pushl  -0x30(%ebp)
f010b243:	50                   	push   %eax
f010b244:	e8 b7 8e ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b249:	83 c4 10             	add    $0x10,%esp
f010b24c:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b252:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b259:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b25c:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b262:	0f 83 af fc ff ff    	jae    f010af17 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b268:	83 ec 0c             	sub    $0xc,%esp
f010b26b:	6a 02                	push   $0x2
f010b26d:	e8 6d 3d 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010b272:	83 c4 10             	add    $0x10,%esp
f010b275:	85 c0                	test   %eax,%eax
f010b277:	74 72                	je     f010b2eb <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b279:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b280:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b286:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b28c:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b28f:	eb 2b                	jmp    f010b2bc <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b291:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b294:	8b 10                	mov    (%eax),%edx
f010b296:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b29c:	8b 40 64             	mov    0x64(%eax),%eax
f010b29f:	6a 01                	push   $0x1
f010b2a1:	6a 00                	push   $0x0
f010b2a3:	52                   	push   %edx
f010b2a4:	50                   	push   %eax
f010b2a5:	e8 39 e3 ff ff       	call   f01095e3 <pt_set_page_permissions>
f010b2aa:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b2ad:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2b3:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b2b9:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b2bc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2c2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b2c6:	74 08                	je     f010b2d0 <env_create+0x9ab>
f010b2c8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2cb:	8b 52 10             	mov    0x10(%edx),%edx
f010b2ce:	eb 05                	jmp    f010b2d5 <env_create+0x9b0>
f010b2d0:	ba 00 00 00 00       	mov    $0x0,%edx
f010b2d5:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b2db:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b2e1:	85 c0                	test   %eax,%eax
f010b2e3:	75 ac                	jne    f010b291 <env_create+0x96c>
f010b2e5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b2e9:	75 a6                	jne    f010b291 <env_create+0x96c>
f010b2eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b2ee:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b2f1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b2f4:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b2f7:	e8 25 bf ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b2fc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b302:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b305:	5e                   	pop    %esi
f010b306:	5f                   	pop    %edi
f010b307:	5d                   	pop    %ebp
f010b308:	c3                   	ret    

f010b309 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b309:	55                   	push   %ebp
f010b30a:	89 e5                	mov    %esp,%ebp
f010b30c:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b30f:	83 ec 0c             	sub    $0xc,%esp
f010b312:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b317:	e8 b0 43 00 00       	call   f010f6cc <release_spinlock>
f010b31c:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b31f:	a1 60 e9 17 f0       	mov    0xf017e960,%eax
f010b324:	85 c0                	test   %eax,%eax
f010b326:	74 30                	je     f010b358 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b328:	e8 76 00 00 00       	call   f010b3a3 <get_cpu_proc>
f010b32d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b330:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b333:	8b 40 10             	mov    0x10(%eax),%eax
f010b336:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b339:	83 c2 20             	add    $0x20,%edx
f010b33c:	83 ec 04             	sub    $0x4,%esp
f010b33f:	50                   	push   %eax
f010b340:	52                   	push   %edx
f010b341:	68 59 5c 12 f0       	push   $0xf0125c59
f010b346:	e8 40 5c ff ff       	call   f0100f8b <cprintf>
f010b34b:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b34e:	c7 05 60 e9 17 f0 00 	movl   $0x0,0xf017e960
f010b355:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b358:	90                   	nop
f010b359:	c9                   	leave  
f010b35a:	c3                   	ret    

f010b35b <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b35b:	55                   	push   %ebp
f010b35c:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010b35e:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010b35f:	5d                   	pop    %ebp
f010b360:	c3                   	ret    

f010b361 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b361:	55                   	push   %ebp
f010b362:	89 e5                	mov    %esp,%ebp
f010b364:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b367:	e8 37 00 00 00       	call   f010b3a3 <get_cpu_proc>
f010b36c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b36f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b373:	75 19                	jne    f010b38e <env_exit+0x2d>
f010b375:	68 6f 5c 12 f0       	push   $0xf0125c6f
f010b37a:	68 7f 5c 12 f0       	push   $0xf0125c7f
f010b37f:	68 ed 01 00 00       	push   $0x1ed
f010b384:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b389:	e8 ab 4f ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010b38e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b391:	8b 40 10             	mov    0x10(%eax),%eax
f010b394:	83 ec 0c             	sub    $0xc,%esp
f010b397:	50                   	push   %eax
f010b398:	e8 8c a4 ff ff       	call   f0105829 <sched_exit_env>
f010b39d:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010b3a0:	90                   	nop
f010b3a1:	c9                   	leave  
f010b3a2:	c3                   	ret    

f010b3a3 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010b3a3:	55                   	push   %ebp
f010b3a4:	89 e5                	mov    %esp,%ebp
f010b3a6:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010b3a9:	e8 21 be ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b3ae:	e8 59 bd ff ff       	call   f010710c <mycpu>
f010b3b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010b3b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3b9:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b3bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010b3c2:	e8 5a be ff ff       	call   f0107221 <popcli>
	return p;
f010b3c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010b3ca:	c9                   	leave  
f010b3cb:	c3                   	ret    

f010b3cc <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010b3cc:	55                   	push   %ebp
f010b3cd:	89 e5                	mov    %esp,%ebp
f010b3cf:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010b3d2:	e8 f8 bd ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b3d7:	e8 30 bd ff ff       	call   f010710c <mycpu>
f010b3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010b3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3e2:	8b 55 08             	mov    0x8(%ebp),%edx
f010b3e5:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010b3eb:	e8 31 be ff ff       	call   f0107221 <popcli>
}
f010b3f0:	90                   	nop
f010b3f1:	c9                   	leave  
f010b3f2:	c3                   	ret    

f010b3f3 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010b3f3:	55                   	push   %ebp
f010b3f4:	89 e5                	mov    %esp,%ebp
f010b3f6:	53                   	push   %ebx
f010b3f7:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010b3fa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b3fe:	75 16                	jne    f010b416 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010b400:	e8 9e ff ff ff       	call   f010b3a3 <get_cpu_proc>
f010b405:	89 c2                	mov    %eax,%edx
f010b407:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b40a:	89 10                	mov    %edx,(%eax)
		return 0;
f010b40c:	b8 00 00 00 00       	mov    $0x0,%eax
f010b411:	e9 aa 00 00 00       	jmp    f010b4c0 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010b416:	8b 1d d0 47 69 f0    	mov    0xf06947d0,%ebx
f010b41c:	83 ec 0c             	sub    $0xc,%esp
f010b41f:	68 ca 02 00 00       	push   $0x2ca
f010b424:	e8 3b 27 01 00       	call   f011db64 <nearest_pow2_ceil>
f010b429:	83 c4 10             	add    $0x10,%esp
f010b42c:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b42f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b432:	21 c2                	and    %eax,%edx
f010b434:	89 d0                	mov    %edx,%eax
f010b436:	c1 e0 03             	shl    $0x3,%eax
f010b439:	01 d0                	add    %edx,%eax
f010b43b:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b442:	01 c8                	add    %ecx,%eax
f010b444:	01 c0                	add    %eax,%eax
f010b446:	01 d0                	add    %edx,%eax
f010b448:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b44f:	01 c8                	add    %ecx,%eax
f010b451:	01 d0                	add    %edx,%eax
f010b453:	01 d8                	add    %ebx,%eax
f010b455:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010b458:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b45b:	8b 40 18             	mov    0x18(%eax),%eax
f010b45e:	85 c0                	test   %eax,%eax
f010b460:	74 0b                	je     f010b46d <envid2env+0x7a>
f010b462:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b465:	8b 40 10             	mov    0x10(%eax),%eax
f010b468:	3b 45 08             	cmp    0x8(%ebp),%eax
f010b46b:	74 10                	je     f010b47d <envid2env+0x8a>
		*env_store = 0;
f010b46d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b470:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b476:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b47b:	eb 43                	jmp    f010b4c0 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010b47d:	e8 21 ff ff ff       	call   f010b3a3 <get_cpu_proc>
f010b482:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010b485:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010b489:	74 28                	je     f010b4b3 <envid2env+0xc0>
f010b48b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b48e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010b491:	74 20                	je     f010b4b3 <envid2env+0xc0>
f010b493:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b496:	8b 50 14             	mov    0x14(%eax),%edx
f010b499:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b49c:	8b 40 10             	mov    0x10(%eax),%eax
f010b49f:	39 c2                	cmp    %eax,%edx
f010b4a1:	74 10                	je     f010b4b3 <envid2env+0xc0>
		*env_store = 0;
f010b4a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b4a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b4ac:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b4b1:	eb 0d                	jmp    f010b4c0 <envid2env+0xcd>
	}

	*env_store = e;
f010b4b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b4b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4b9:	89 10                	mov    %edx,(%eax)
	return 0;
f010b4bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b4c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b4c3:	c9                   	leave  
f010b4c4:	c3                   	ret    

f010b4c5 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010b4c5:	55                   	push   %ebp
f010b4c6:	89 e5                	mov    %esp,%ebp
f010b4c8:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010b4cb:	83 ec 0c             	sub    $0xc,%esp
f010b4ce:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b4d3:	e8 6d 41 00 00       	call   f010f645 <acquire_spinlock>
f010b4d8:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010b4db:	e8 c3 fe ff ff       	call   f010b3a3 <get_cpu_proc>
f010b4e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010b4e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b4e7:	75 19                	jne    f010b502 <yield+0x3d>
f010b4e9:	68 94 5c 12 f0       	push   $0xf0125c94
f010b4ee:	68 7f 5c 12 f0       	push   $0xf0125c7f
f010b4f3:	68 4c 02 00 00       	push   $0x24c
f010b4f8:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b4fd:	e8 37 4e ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010b502:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b505:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010b50c:	e8 13 00 00 00       	call   f010b524 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010b511:	83 ec 0c             	sub    $0xc,%esp
f010b514:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b519:	e8 ae 41 00 00       	call   f010f6cc <release_spinlock>
f010b51e:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010b521:	90                   	nop
f010b522:	c9                   	leave  
f010b523:	c3                   	ret    

f010b524 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010b524:	55                   	push   %ebp
f010b525:	89 e5                	mov    %esp,%ebp
f010b527:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010b52a:	e8 74 fe ff ff       	call   f010b3a3 <get_cpu_proc>
f010b52f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010b532:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b536:	75 19                	jne    f010b551 <sched+0x2d>
f010b538:	68 94 5c 12 f0       	push   $0xf0125c94
f010b53d:	68 7f 5c 12 f0       	push   $0xf0125c7f
f010b542:	68 60 02 00 00       	push   $0x260
f010b547:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b54c:	e8 e8 4d ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010b551:	83 ec 0c             	sub    $0xc,%esp
f010b554:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b559:	e8 00 43 00 00       	call   f010f85e <holding_spinlock>
f010b55e:	83 c4 10             	add    $0x10,%esp
f010b561:	85 c0                	test   %eax,%eax
f010b563:	75 17                	jne    f010b57c <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010b565:	83 ec 04             	sub    $0x4,%esp
f010b568:	68 a0 5c 12 f0       	push   $0xf0125ca0
f010b56d:	68 64 02 00 00       	push   $0x264
f010b572:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b577:	e8 bd 4d ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010b57c:	e8 8b bb ff ff       	call   f010710c <mycpu>
f010b581:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b587:	83 f8 01             	cmp    $0x1,%eax
f010b58a:	74 20                	je     f010b5ac <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010b58c:	e8 7b bb ff ff       	call   f010710c <mycpu>
f010b591:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b597:	50                   	push   %eax
f010b598:	68 e2 5c 12 f0       	push   $0xf0125ce2
f010b59d:	68 67 02 00 00       	push   $0x267
f010b5a2:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b5a7:	e8 8d 4d ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010b5ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5af:	8b 40 18             	mov    0x18(%eax),%eax
f010b5b2:	83 f8 02             	cmp    $0x2,%eax
f010b5b5:	75 17                	jne    f010b5ce <sched+0xaa>
		panic("sched a running process");
f010b5b7:	83 ec 04             	sub    $0x4,%esp
f010b5ba:	68 f9 5c 12 f0       	push   $0xf0125cf9
f010b5bf:	68 6a 02 00 00       	push   $0x26a
f010b5c4:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b5c9:	e8 6b 4d ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010b5ce:	9c                   	pushf  
f010b5cf:	58                   	pop    %eax
f010b5d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010b5d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010b5d6:	25 00 02 00 00       	and    $0x200,%eax
f010b5db:	85 c0                	test   %eax,%eax
f010b5dd:	74 17                	je     f010b5f6 <sched+0xd2>
		panic("sched is interruptible!");
f010b5df:	83 ec 04             	sub    $0x4,%esp
f010b5e2:	68 11 5d 12 f0       	push   $0xf0125d11
f010b5e7:	68 6c 02 00 00       	push   $0x26c
f010b5ec:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b5f1:	e8 43 4d ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010b5f6:	e8 11 bb ff ff       	call   f010710c <mycpu>
f010b5fb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010b601:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010b604:	e8 03 bb ff ff       	call   f010710c <mycpu>
f010b609:	8b 40 04             	mov    0x4(%eax),%eax
f010b60c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b60f:	83 c2 04             	add    $0x4,%edx
f010b612:	83 ec 08             	sub    $0x8,%esp
f010b615:	50                   	push   %eax
f010b616:	52                   	push   %edx
f010b617:	e8 55 95 ff ff       	call   f0104b71 <context_switch>
f010b61c:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010b61f:	e8 e8 ba ff ff       	call   f010710c <mycpu>
f010b624:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b627:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010b62d:	90                   	nop
f010b62e:	c9                   	leave  
f010b62f:	c3                   	ret    

f010b630 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010b630:	55                   	push   %ebp
f010b631:	89 e5                	mov    %esp,%ebp
f010b633:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010b636:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f010b63b:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b63e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010b641:	0f 22 d8             	mov    %eax,%cr3
}
f010b644:	90                   	nop
f010b645:	c9                   	leave  
f010b646:	c3                   	ret    

f010b647 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010b647:	55                   	push   %ebp
f010b648:	89 e5                	mov    %esp,%ebp
f010b64a:	53                   	push   %ebx
f010b64b:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010b64e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b652:	75 17                	jne    f010b66b <switchuvm+0x24>
		panic("switchuvm: no process");
f010b654:	83 ec 04             	sub    $0x4,%esp
f010b657:	68 29 5d 12 f0       	push   $0xf0125d29
f010b65c:	68 81 02 00 00       	push   $0x281
f010b661:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b666:	e8 ce 4c ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010b66b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b66e:	8b 40 70             	mov    0x70(%eax),%eax
f010b671:	85 c0                	test   %eax,%eax
f010b673:	75 17                	jne    f010b68c <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010b675:	83 ec 04             	sub    $0x4,%esp
f010b678:	68 3f 5d 12 f0       	push   $0xf0125d3f
f010b67d:	68 83 02 00 00       	push   $0x283
f010b682:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b687:	e8 ad 4c ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010b68c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b68f:	8b 40 64             	mov    0x64(%eax),%eax
f010b692:	85 c0                	test   %eax,%eax
f010b694:	75 17                	jne    f010b6ad <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010b696:	83 ec 04             	sub    $0x4,%esp
f010b699:	68 54 5d 12 f0       	push   $0xf0125d54
f010b69e:	68 85 02 00 00       	push   $0x285
f010b6a3:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b6a8:	e8 8c 4c ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010b6ad:	e8 1d bb ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010b6b2:	e8 55 ba ff ff       	call   f010710c <mycpu>
f010b6b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010b6ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6bd:	8b 55 08             	mov    0x8(%ebp),%edx
f010b6c0:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010b6c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6c9:	83 c0 0c             	add    $0xc,%eax
f010b6cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6cf:	83 c2 0c             	add    $0xc,%edx
f010b6d2:	c1 ea 10             	shr    $0x10,%edx
f010b6d5:	88 d3                	mov    %dl,%bl
f010b6d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6da:	83 c2 0c             	add    $0xc,%edx
f010b6dd:	c1 ea 18             	shr    $0x18,%edx
f010b6e0:	88 d1                	mov    %dl,%cl
f010b6e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6e5:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010b6ec:	68 00 
f010b6ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6f1:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010b6f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6fb:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010b701:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b704:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b70a:	83 e2 f0             	and    $0xfffffff0,%edx
f010b70d:	83 ca 09             	or     $0x9,%edx
f010b710:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b716:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b719:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b71f:	83 ca 10             	or     $0x10,%edx
f010b722:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b728:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b72b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b731:	83 e2 9f             	and    $0xffffff9f,%edx
f010b734:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b73a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b73d:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b743:	83 ca 80             	or     $0xffffff80,%edx
f010b746:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b74c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b74f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b755:	83 e2 f0             	and    $0xfffffff0,%edx
f010b758:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b75e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b761:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b767:	83 e2 ef             	and    $0xffffffef,%edx
f010b76a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b770:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b773:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b779:	83 e2 df             	and    $0xffffffdf,%edx
f010b77c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b782:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b785:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b78b:	83 ca 40             	or     $0x40,%edx
f010b78e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b794:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b797:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b79d:	83 e2 7f             	and    $0x7f,%edx
f010b7a0:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7a9:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010b7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7b2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b7b8:	83 e2 ef             	and    $0xffffffef,%edx
f010b7bb:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010b7c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7c4:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b7ca:	8b 40 70             	mov    0x70(%eax),%eax
f010b7cd:	05 00 80 00 00       	add    $0x8000,%eax
f010b7d2:	89 c2                	mov    %eax,%edx
f010b7d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7d7:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010b7da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7dd:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010b7e3:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010b7e9:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010b7ed:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010b7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7f3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b7f9:	8b 40 68             	mov    0x68(%eax),%eax
f010b7fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b7ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b802:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010b805:	e8 17 ba ff ff       	call   f0107221 <popcli>
}
f010b80a:	90                   	nop
f010b80b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b80e:	c9                   	leave  
f010b80f:	c3                   	ret    

f010b810 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010b810:	55                   	push   %ebp
f010b811:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010b813:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010b819:	8b 45 08             	mov    0x8(%ebp),%eax
f010b81c:	89 10                	mov    %edx,(%eax)
f010b81e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b821:	8b 00                	mov    (%eax),%eax
f010b823:	85 c0                	test   %eax,%eax
f010b825:	75 07                	jne    f010b82e <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010b827:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010b82c:	eb 11                	jmp    f010b83f <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010b82e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b831:	8b 00                	mov    (%eax),%eax
f010b833:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010b83a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b83f:	5d                   	pop    %ebp
f010b840:	c3                   	ret    

f010b841 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010b841:	55                   	push   %ebp
f010b842:	89 e5                	mov    %esp,%ebp
f010b844:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010b847:	83 ec 04             	sub    $0x4,%esp
f010b84a:	68 bc 05 00 00       	push   $0x5bc
f010b84f:	6a 00                	push   $0x0
f010b851:	ff 75 08             	pushl  0x8(%ebp)
f010b854:	e8 9b 3f 01 00       	call   f011f7f4 <memset>
f010b859:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010b85c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b85f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010b866:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b86a:	75 17                	jne    f010b883 <free_environment+0x42>
f010b86c:	83 ec 04             	sub    $0x4,%esp
f010b86f:	68 90 5b 12 f0       	push   $0xf0125b90
f010b874:	68 c0 02 00 00       	push   $0x2c0
f010b879:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b87e:	e8 b6 4a ff ff       	call   f0100339 <_panic>
f010b883:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010b889:	8b 45 08             	mov    0x8(%ebp),%eax
f010b88c:	89 50 08             	mov    %edx,0x8(%eax)
f010b88f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b892:	8b 40 08             	mov    0x8(%eax),%eax
f010b895:	85 c0                	test   %eax,%eax
f010b897:	74 0d                	je     f010b8a6 <free_environment+0x65>
f010b899:	a1 d4 47 69 f0       	mov    0xf06947d4,%eax
f010b89e:	8b 55 08             	mov    0x8(%ebp),%edx
f010b8a1:	89 50 0c             	mov    %edx,0xc(%eax)
f010b8a4:	eb 08                	jmp    f010b8ae <free_environment+0x6d>
f010b8a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8a9:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010b8ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8b1:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010b8b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8b9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b8c0:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010b8c5:	40                   	inc    %eax
f010b8c6:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
}
f010b8cb:	90                   	nop
f010b8cc:	c9                   	leave  
f010b8cd:	c3                   	ret    

f010b8ce <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010b8ce:	55                   	push   %ebp
f010b8cf:	89 e5                	mov    %esp,%ebp
f010b8d1:	53                   	push   %ebx
f010b8d2:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010b8d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8d8:	8b 40 0c             	mov    0xc(%eax),%eax
f010b8db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010b8de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8e1:	8b 40 08             	mov    0x8(%eax),%eax
f010b8e4:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010b8e7:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010b8ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010b8f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b8f4:	01 c2                	add    %eax,%edx
f010b8f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b8f9:	01 d0                	add    %edx,%eax
f010b8fb:	48                   	dec    %eax
f010b8fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b8ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b902:	ba 00 00 00 00       	mov    $0x0,%edx
f010b907:	f7 75 dc             	divl   -0x24(%ebp)
f010b90a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b90d:	29 d0                	sub    %edx,%eax
f010b90f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010b912:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b915:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010b918:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b91b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b920:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010b923:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010b92a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010b931:	8b 45 10             	mov    0x10(%ebp),%eax
f010b934:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010b93a:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010b941:	0f 85 f5 03 00 00    	jne    f010bd3c <program_segment_alloc_map_copy_workingset+0x46e>
f010b947:	8b 45 08             	mov    0x8(%ebp),%eax
f010b94a:	83 c0 20             	add    $0x20,%eax
f010b94d:	83 ec 08             	sub    $0x8,%esp
f010b950:	68 68 5d 12 f0       	push   $0xf0125d68
f010b955:	50                   	push   %eax
f010b956:	e8 b7 3d 01 00       	call   f011f712 <strcmp>
f010b95b:	83 c4 10             	add    $0x10,%esp
f010b95e:	85 c0                	test   %eax,%eax
f010b960:	0f 84 d6 03 00 00    	je     f010bd3c <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010b966:	8b 45 14             	mov    0x14(%ebp),%eax
f010b969:	83 f8 06             	cmp    $0x6,%eax
f010b96c:	76 05                	jbe    f010b973 <program_segment_alloc_map_copy_workingset+0xa5>
f010b96e:	b8 06 00 00 00       	mov    $0x6,%eax
f010b973:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b976:	e9 c1 03 00 00       	jmp    f010bd3c <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010b97b:	83 ec 0c             	sub    $0xc,%esp
f010b97e:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010b981:	50                   	push   %eax
f010b982:	e8 2b c8 ff ff       	call   f01081b2 <allocate_frame>
f010b987:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010b98a:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b98d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b990:	8b 40 64             	mov    0x64(%eax),%eax
f010b993:	6a 06                	push   $0x6
f010b995:	ff 75 f4             	pushl  -0xc(%ebp)
f010b998:	52                   	push   %edx
f010b999:	50                   	push   %eax
f010b99a:	e8 e4 ce ff ff       	call   f0108883 <loadtime_map_frame>
f010b99f:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010b9a2:	83 ec 08             	sub    $0x8,%esp
f010b9a5:	ff 75 f4             	pushl  -0xc(%ebp)
f010b9a8:	ff 75 08             	pushl  0x8(%ebp)
f010b9ab:	e8 69 de ff ff       	call   f0109819 <env_page_ws_list_create_element>
f010b9b0:	83 c4 10             	add    $0x10,%esp
f010b9b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010b9b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9b9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b9c0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b9c4:	75 17                	jne    f010b9dd <program_segment_alloc_map_copy_workingset+0x10f>
f010b9c6:	83 ec 04             	sub    $0x4,%esp
f010b9c9:	68 18 5c 12 f0       	push   $0xf0125c18
f010b9ce:	68 ea 02 00 00       	push   $0x2ea
f010b9d3:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010b9d8:	e8 5c 49 ff ff       	call   f0100339 <_panic>
f010b9dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9e0:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b9e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9e9:	89 50 14             	mov    %edx,0x14(%eax)
f010b9ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9ef:	8b 40 14             	mov    0x14(%eax),%eax
f010b9f2:	85 c0                	test   %eax,%eax
f010b9f4:	74 11                	je     f010ba07 <program_segment_alloc_map_copy_workingset+0x139>
f010b9f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9f9:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b9ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba02:	89 50 10             	mov    %edx,0x10(%eax)
f010ba05:	eb 0c                	jmp    f010ba13 <program_segment_alloc_map_copy_workingset+0x145>
f010ba07:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba0a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba0d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010ba13:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba16:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba19:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba22:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ba29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba2c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010ba32:	8d 50 01             	lea    0x1(%eax),%edx
f010ba35:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba38:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010ba3e:	83 ec 0c             	sub    $0xc,%esp
f010ba41:	6a 02                	push   $0x2
f010ba43:	e8 97 35 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010ba48:	83 c4 10             	add    $0x10,%esp
f010ba4b:	85 c0                	test   %eax,%eax
f010ba4d:	0f 84 b3 01 00 00    	je     f010bc06 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010ba53:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ba57:	75 17                	jne    f010ba70 <program_segment_alloc_map_copy_workingset+0x1a2>
f010ba59:	83 ec 04             	sub    $0x4,%esp
f010ba5c:	68 3b 5c 12 f0       	push   $0xf0125c3b
f010ba61:	68 f6 02 00 00       	push   $0x2f6
f010ba66:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010ba6b:	e8 c9 48 ff ff       	call   f0100339 <_panic>
f010ba70:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba73:	8b 40 10             	mov    0x10(%eax),%eax
f010ba76:	85 c0                	test   %eax,%eax
f010ba78:	74 11                	je     f010ba8b <program_segment_alloc_map_copy_workingset+0x1bd>
f010ba7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba7d:	8b 40 10             	mov    0x10(%eax),%eax
f010ba80:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba83:	8b 52 14             	mov    0x14(%edx),%edx
f010ba86:	89 50 14             	mov    %edx,0x14(%eax)
f010ba89:	eb 0f                	jmp    f010ba9a <program_segment_alloc_map_copy_workingset+0x1cc>
f010ba8b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba8e:	8b 50 14             	mov    0x14(%eax),%edx
f010ba91:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba94:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba9a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba9d:	8b 40 14             	mov    0x14(%eax),%eax
f010baa0:	85 c0                	test   %eax,%eax
f010baa2:	74 11                	je     f010bab5 <program_segment_alloc_map_copy_workingset+0x1e7>
f010baa4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010baa7:	8b 40 14             	mov    0x14(%eax),%eax
f010baaa:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010baad:	8b 52 10             	mov    0x10(%edx),%edx
f010bab0:	89 50 10             	mov    %edx,0x10(%eax)
f010bab3:	eb 0f                	jmp    f010bac4 <program_segment_alloc_map_copy_workingset+0x1f6>
f010bab5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bab8:	8b 50 10             	mov    0x10(%eax),%edx
f010babb:	8b 45 08             	mov    0x8(%ebp),%eax
f010babe:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010bac4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bac7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bace:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bad1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bad8:	8b 45 08             	mov    0x8(%ebp),%eax
f010badb:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010bae1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bae4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bae7:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010baed:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf0:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010baf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf9:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010baff:	48                   	dec    %eax
f010bb00:	39 c2                	cmp    %eax,%edx
f010bb02:	0f 83 80 00 00 00    	jae    f010bb88 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010bb08:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bb0c:	75 17                	jne    f010bb25 <program_segment_alloc_map_copy_workingset+0x257>
f010bb0e:	83 ec 04             	sub    $0x4,%esp
f010bb11:	68 90 5b 12 f0       	push   $0xf0125b90
f010bb16:	68 fa 02 00 00       	push   $0x2fa
f010bb1b:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010bb20:	e8 14 48 ff ff       	call   f0100339 <_panic>
f010bb25:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb28:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010bb2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb31:	89 50 10             	mov    %edx,0x10(%eax)
f010bb34:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb37:	8b 40 10             	mov    0x10(%eax),%eax
f010bb3a:	85 c0                	test   %eax,%eax
f010bb3c:	74 11                	je     f010bb4f <program_segment_alloc_map_copy_workingset+0x281>
f010bb3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb41:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010bb47:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb4a:	89 50 14             	mov    %edx,0x14(%eax)
f010bb4d:	eb 0c                	jmp    f010bb5b <program_segment_alloc_map_copy_workingset+0x28d>
f010bb4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb52:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb55:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010bb5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb5e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb61:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010bb67:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb6a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bb71:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb74:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010bb7a:	8d 50 01             	lea    0x1(%eax),%edx
f010bb7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb80:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010bb86:	eb 7e                	jmp    f010bc06 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010bb88:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bb8c:	75 17                	jne    f010bba5 <program_segment_alloc_map_copy_workingset+0x2d7>
f010bb8e:	83 ec 04             	sub    $0x4,%esp
f010bb91:	68 90 5b 12 f0       	push   $0xf0125b90
f010bb96:	68 ff 02 00 00       	push   $0x2ff
f010bb9b:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010bba0:	e8 94 47 ff ff       	call   f0100339 <_panic>
f010bba5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bba8:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bbae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bbb1:	89 50 10             	mov    %edx,0x10(%eax)
f010bbb4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bbb7:	8b 40 10             	mov    0x10(%eax),%eax
f010bbba:	85 c0                	test   %eax,%eax
f010bbbc:	74 11                	je     f010bbcf <program_segment_alloc_map_copy_workingset+0x301>
f010bbbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbc1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bbc7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbca:	89 50 14             	mov    %edx,0x14(%eax)
f010bbcd:	eb 0c                	jmp    f010bbdb <program_segment_alloc_map_copy_workingset+0x30d>
f010bbcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbd2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbd5:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bbdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbde:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbe1:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bbe7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bbea:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bbf1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbf4:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010bbfa:	8d 50 01             	lea    0x1(%eax),%edx
f010bbfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc00:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010bc06:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc09:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010bc0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc12:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010bc18:	39 c2                	cmp    %eax,%edx
f010bc1a:	75 14                	jne    f010bc30 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010bc1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc1f:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010bc25:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc28:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010bc2e:	eb 0d                	jmp    f010bc3d <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010bc30:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc33:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010bc3a:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010bc3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc40:	c1 e8 16             	shr    $0x16,%eax
f010bc43:	89 c2                	mov    %eax,%edx
f010bc45:	8b 45 18             	mov    0x18(%ebp),%eax
f010bc48:	8b 00                	mov    (%eax),%eax
f010bc4a:	39 c2                	cmp    %eax,%edx
f010bc4c:	0f 84 d3 00 00 00    	je     f010bd25 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010bc52:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc55:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bc5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010bc61:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010bc64:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010bc69:	89 c1                	mov    %eax,%ecx
f010bc6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010bc6e:	89 d0                	mov    %edx,%eax
f010bc70:	01 c0                	add    %eax,%eax
f010bc72:	01 d0                	add    %edx,%eax
f010bc74:	c1 e0 03             	shl    $0x3,%eax
f010bc77:	01 d8                	add    %ebx,%eax
f010bc79:	05 ac 00 00 00       	add    $0xac,%eax
f010bc7e:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010bc80:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc83:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bc89:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bc8c:	89 d0                	mov    %edx,%eax
f010bc8e:	01 c0                	add    %eax,%eax
f010bc90:	01 d0                	add    %edx,%eax
f010bc92:	c1 e0 03             	shl    $0x3,%eax
f010bc95:	01 c8                	add    %ecx,%eax
f010bc97:	05 b0 00 00 00       	add    $0xb0,%eax
f010bc9c:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010bc9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bca2:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bca8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bcab:	89 d0                	mov    %edx,%eax
f010bcad:	01 c0                	add    %eax,%eax
f010bcaf:	01 d0                	add    %edx,%eax
f010bcb1:	c1 e0 03             	shl    $0x3,%eax
f010bcb4:	01 c8                	add    %ecx,%eax
f010bcb6:	05 b4 00 00 00       	add    $0xb4,%eax
f010bcbb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010bcc1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcc4:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bcca:	8d 50 01             	lea    0x1(%eax),%edx
f010bccd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcd0:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010bcd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcd9:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bcdf:	b9 32 00 00 00       	mov    $0x32,%ecx
f010bce4:	ba 00 00 00 00       	mov    $0x0,%edx
f010bce9:	f7 f1                	div    %ecx
f010bceb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcee:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010bcf4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcf7:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bcfd:	85 c0                	test   %eax,%eax
f010bcff:	75 17                	jne    f010bd18 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010bd01:	83 ec 04             	sub    $0x4,%esp
f010bd04:	68 6c 5d 12 f0       	push   $0xf0125d6c
f010bd09:	68 27 03 00 00       	push   $0x327
f010bd0e:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010bd13:	e8 21 46 ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010bd18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd1b:	c1 e8 16             	shr    $0x16,%eax
f010bd1e:	89 c2                	mov    %eax,%edx
f010bd20:	8b 45 18             	mov    0x18(%ebp),%eax
f010bd23:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010bd25:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd28:	8b 00                	mov    (%eax),%eax
f010bd2a:	8d 50 01             	lea    0x1(%eax),%edx
f010bd2d:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd30:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bd32:	ff 45 f0             	incl   -0x10(%ebp)
f010bd35:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010bd3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd3f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010bd42:	73 0c                	jae    f010bd50 <program_segment_alloc_map_copy_workingset+0x482>
f010bd44:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bd47:	3b 45 14             	cmp    0x14(%ebp),%eax
f010bd4a:	0f 82 2b fc ff ff    	jb     f010b97b <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010bd50:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd53:	8b 00                	mov    (%eax),%eax
f010bd55:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010bd58:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd5b:	8b 40 0c             	mov    0xc(%eax),%eax
f010bd5e:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bd61:	eb 10                	jmp    f010bd73 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010bd63:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd66:	8a 10                	mov    (%eax),%dl
f010bd68:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd6b:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010bd6d:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010bd70:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bd73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd76:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010bd79:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010bd7c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bd81:	89 c2                	mov    %eax,%edx
f010bd83:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd86:	8b 00                	mov    (%eax),%eax
f010bd88:	c1 e0 0c             	shl    $0xc,%eax
f010bd8b:	01 c2                	add    %eax,%edx
f010bd8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd90:	39 c2                	cmp    %eax,%edx
f010bd92:	76 1d                	jbe    f010bdb1 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010bd94:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd97:	8b 50 04             	mov    0x4(%eax),%edx
f010bd9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd9d:	01 c2                	add    %eax,%edx
f010bd9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bda2:	39 c2                	cmp    %eax,%edx
f010bda4:	77 bd                	ja     f010bd63 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bda6:	eb 09                	jmp    f010bdb1 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010bda8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bdab:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010bdae:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bdb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bdb4:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010bdb7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010bdba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bdbf:	89 c2                	mov    %eax,%edx
f010bdc1:	8b 45 10             	mov    0x10(%ebp),%eax
f010bdc4:	8b 00                	mov    (%eax),%eax
f010bdc6:	c1 e0 0c             	shl    $0xc,%eax
f010bdc9:	01 c2                	add    %eax,%edx
f010bdcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bdce:	39 c2                	cmp    %eax,%edx
f010bdd0:	77 d6                	ja     f010bda8 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010bdd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bdd7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bdda:	c9                   	leave  
f010bddb:	c3                   	ret    

f010bddc <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010bddc:	55                   	push   %ebp
f010bddd:	89 e5                	mov    %esp,%ebp
f010bddf:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010bde2:	83 ec 0c             	sub    $0xc,%esp
f010bde5:	68 00 10 00 00       	push   $0x1000
f010bdea:	e8 15 d4 ff ff       	call   f0109204 <kmalloc>
f010bdef:	83 c4 10             	add    $0x10,%esp
f010bdf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010bdf5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdf9:	75 17                	jne    f010be12 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010bdfb:	83 ec 04             	sub    $0x4,%esp
f010bdfe:	68 0f 5e 12 f0       	push   $0xf0125e0f
f010be03:	68 57 03 00 00       	push   $0x357
f010be08:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010be0d:	e8 27 45 ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010be12:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010be15:	c9                   	leave  
f010be16:	c3                   	ret    

f010be17 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010be17:	55                   	push   %ebp
f010be18:	89 e5                	mov    %esp,%ebp
f010be1a:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010be1d:	83 ec 0c             	sub    $0xc,%esp
f010be20:	68 00 80 00 00       	push   $0x8000
f010be25:	e8 da d3 ff ff       	call   f0109204 <kmalloc>
f010be2a:	83 c4 10             	add    $0x10,%esp
f010be2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010be30:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010be37:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be3a:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010be3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010be42:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010be45:	ba 00 00 00 00       	mov    $0x0,%edx
f010be4a:	f7 75 ec             	divl   -0x14(%ebp)
f010be4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010be50:	29 d0                	sub    %edx,%eax
f010be52:	85 c0                	test   %eax,%eax
f010be54:	79 05                	jns    f010be5b <create_user_kern_stack+0x44>
f010be56:	05 ff 0f 00 00       	add    $0xfff,%eax
f010be5b:	c1 f8 0c             	sar    $0xc,%eax
f010be5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010be61:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010be68:	eb 72                	jmp    f010bedc <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010be6a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010be71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be74:	c1 e0 0c             	shl    $0xc,%eax
f010be77:	89 c2                	mov    %eax,%edx
f010be79:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010be7c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010be7f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010be84:	83 ec 04             	sub    $0x4,%esp
f010be87:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010be8a:	52                   	push   %edx
f010be8b:	51                   	push   %ecx
f010be8c:	50                   	push   %eax
f010be8d:	e8 d7 c8 ff ff       	call   f0108769 <get_frame_info>
f010be92:	83 c4 10             	add    $0x10,%esp
f010be95:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010be98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be9b:	c1 e0 0c             	shl    $0xc,%eax
f010be9e:	89 c2                	mov    %eax,%edx
f010bea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bea3:	01 d0                	add    %edx,%eax
f010bea5:	6a 01                	push   $0x1
f010bea7:	50                   	push   %eax
f010bea8:	ff 75 e0             	pushl  -0x20(%ebp)
f010beab:	ff 75 08             	pushl  0x8(%ebp)
f010beae:	e8 cc c7 ff ff       	call   f010867f <map_frame>
f010beb3:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010beb6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010beba:	75 1d                	jne    f010bed9 <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010bebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bebf:	c1 e0 0c             	shl    $0xc,%eax
f010bec2:	89 c2                	mov    %eax,%edx
f010bec4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bec7:	01 d0                	add    %edx,%eax
f010bec9:	6a 01                	push   $0x1
f010becb:	6a 00                	push   $0x0
f010becd:	50                   	push   %eax
f010bece:	ff 75 08             	pushl  0x8(%ebp)
f010bed1:	e8 0d d7 ff ff       	call   f01095e3 <pt_set_page_permissions>
f010bed6:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010bed9:	ff 45 f4             	incl   -0xc(%ebp)
f010bedc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bedf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010bee2:	72 86                	jb     f010be6a <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010bee4:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010bee7:	c9                   	leave  
f010bee8:	c3                   	ret    

f010bee9 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010bee9:	55                   	push   %ebp
f010beea:	89 e5                	mov    %esp,%ebp
f010beec:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010beef:	83 ec 04             	sub    $0x4,%esp
f010bef2:	68 2c 5e 12 f0       	push   $0xf0125e2c
f010bef7:	68 8e 03 00 00       	push   $0x38e
f010befc:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010bf01:	e8 33 44 ff ff       	call   f0100339 <_panic>

f010bf06 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010bf06:	55                   	push   %ebp
f010bf07:	89 e5                	mov    %esp,%ebp
f010bf09:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010bf0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf0f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bf12:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010bf15:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf18:	8b 55 10             	mov    0x10(%ebp),%edx
f010bf1b:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010bf1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf21:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bf24:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010bf27:	83 ec 08             	sub    $0x8,%esp
f010bf2a:	6a 00                	push   $0x0
f010bf2c:	ff 75 0c             	pushl  0xc(%ebp)
f010bf2f:	e8 a1 42 01 00       	call   f01201d5 <initialize_dynamic_allocator>
f010bf34:	83 c4 10             	add    $0x10,%esp
}
f010bf37:	90                   	nop
f010bf38:	c9                   	leave  
f010bf39:	c3                   	ret    

f010bf3a <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010bf3a:	55                   	push   %ebp
f010bf3b:	89 e5                	mov    %esp,%ebp
f010bf3d:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010bf40:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf43:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bf46:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010bf49:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf4c:	8b 55 10             	mov    0x10(%ebp),%edx
f010bf4f:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010bf52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf59:	eb 17                	jmp    f010bf72 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010bf5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf5e:	8b 40 64             	mov    0x64(%eax),%eax
f010bf61:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf64:	c1 e2 02             	shl    $0x2,%edx
f010bf67:	01 d0                	add    %edx,%eax
f010bf69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010bf6f:	ff 45 f4             	incl   -0xc(%ebp)
f010bf72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf75:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010bf7a:	76 df                	jbe    f010bf5b <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010bf7c:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010bf83:	eb 22                	jmp    f010bfa7 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010bf85:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf88:	8b 40 64             	mov    0x64(%eax),%eax
f010bf8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf8e:	c1 e2 02             	shl    $0x2,%edx
f010bf91:	01 c2                	add    %eax,%edx
f010bf93:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010bf98:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010bf9b:	c1 e1 02             	shl    $0x2,%ecx
f010bf9e:	01 c8                	add    %ecx,%eax
f010bfa0:	8b 00                	mov    (%eax),%eax
f010bfa2:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010bfa4:	ff 45 f4             	incl   -0xc(%ebp)
f010bfa7:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010bfae:	7e d5                	jle    f010bf85 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010bfb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfb3:	8b 40 64             	mov    0x64(%eax),%eax
f010bfb6:	83 ec 0c             	sub    $0xc,%esp
f010bfb9:	50                   	push   %eax
f010bfba:	e8 58 fe ff ff       	call   f010be17 <create_user_kern_stack>
f010bfbf:	83 c4 10             	add    $0x10,%esp
f010bfc2:	89 c2                	mov    %eax,%edx
f010bfc4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfc7:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010bfca:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfcd:	8b 40 70             	mov    0x70(%eax),%eax
f010bfd0:	05 00 80 00 00       	add    $0x8000,%eax
f010bfd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010bfd8:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010bfdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfdf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bfe2:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010bfe4:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010bfe8:	ba 28 e0 10 f0       	mov    $0xf010e028,%edx
f010bfed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bff0:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010bff2:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010bff6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bff9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bffc:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010bfff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c002:	8b 40 04             	mov    0x4(%eax),%eax
f010c005:	83 ec 04             	sub    $0x4,%esp
f010c008:	6a 20                	push   $0x20
f010c00a:	6a 00                	push   $0x0
f010c00c:	50                   	push   %eax
f010c00d:	e8 e2 37 01 00       	call   f011f7f4 <memset>
f010c012:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c015:	8b 45 08             	mov    0x8(%ebp),%eax
f010c018:	8b 40 04             	mov    0x4(%eax),%eax
f010c01b:	ba 09 b3 10 f0       	mov    $0xf010b309,%edx
f010c020:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c023:	8b 45 08             	mov    0x8(%ebp),%eax
f010c026:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c02d:	00 00 00 
f010c030:	8b 45 08             	mov    0x8(%ebp),%eax
f010c033:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c03a:	00 00 00 
f010c03d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c040:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c047:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c04a:	83 ec 0c             	sub    $0xc,%esp
f010c04d:	6a 02                	push   $0x2
f010c04f:	e8 8b 2f 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010c054:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c057:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c05e:	eb 54                	jmp    f010c0b4 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c060:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c063:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c066:	89 d0                	mov    %edx,%eax
f010c068:	01 c0                	add    %eax,%eax
f010c06a:	01 d0                	add    %edx,%eax
f010c06c:	c1 e0 03             	shl    $0x3,%eax
f010c06f:	01 c8                	add    %ecx,%eax
f010c071:	05 ac 00 00 00       	add    $0xac,%eax
f010c076:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c07c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c07f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c082:	89 d0                	mov    %edx,%eax
f010c084:	01 c0                	add    %eax,%eax
f010c086:	01 d0                	add    %edx,%eax
f010c088:	c1 e0 03             	shl    $0x3,%eax
f010c08b:	01 c8                	add    %ecx,%eax
f010c08d:	05 b0 00 00 00       	add    $0xb0,%eax
f010c092:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c095:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c098:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c09b:	89 d0                	mov    %edx,%eax
f010c09d:	01 c0                	add    %eax,%eax
f010c09f:	01 d0                	add    %edx,%eax
f010c0a1:	c1 e0 03             	shl    $0x3,%eax
f010c0a4:	01 c8                	add    %ecx,%eax
f010c0a6:	05 b4 00 00 00       	add    $0xb4,%eax
f010c0ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c0b1:	ff 45 f4             	incl   -0xc(%ebp)
f010c0b4:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c0b8:	7e a6                	jle    f010c060 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c0ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0bd:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c0c4:	00 00 00 

	e->pageFaultsCounter=0;
f010c0c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0ca:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c0d1:	00 00 00 
	e->tableFaultsCounter=0;
f010c0d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0d7:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c0de:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c0e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0e4:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c0eb:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c0ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0f1:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c0f8:	00 00 00 

	e->nModifiedPages=0;
f010c0fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0fe:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c105:	00 00 00 
	e->nNotModifiedPages=0;
f010c108:	8b 45 08             	mov    0x8(%ebp),%eax
f010c10b:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c112:	00 00 00 
	e->nClocks = 0;
f010c115:	8b 45 08             	mov    0x8(%ebp),%eax
f010c118:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c11f:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c122:	8b 45 08             	mov    0x8(%ebp),%eax
f010c125:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c12c:	00 00 00 
	e->nPageOut = 0;
f010c12f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c132:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c139:	00 00 00 
	e->nNewPageAdded = 0;
f010c13c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c13f:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c146:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c149:	83 ec 04             	sub    $0x4,%esp
f010c14c:	68 00 00 00 82       	push   $0x82000000
f010c151:	68 00 00 00 80       	push   $0x80000000
f010c156:	ff 75 08             	pushl  0x8(%ebp)
f010c159:	e8 a8 fd ff ff       	call   f010bf06 <initialize_uheap_dynamic_allocator>
f010c15e:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c161:	83 ec 0c             	sub    $0xc,%esp
f010c164:	ff 75 08             	pushl  0x8(%ebp)
f010c167:	e8 06 00 00 00       	call   f010c172 <complete_environment_initialization>
f010c16c:	83 c4 10             	add    $0x10,%esp
}
f010c16f:	90                   	nop
f010c170:	c9                   	leave  
f010c171:	c3                   	ret    

f010c172 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c172:	55                   	push   %ebp
f010c173:	89 e5                	mov    %esp,%ebp
f010c175:	53                   	push   %ebx
f010c176:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c179:	8b 45 08             	mov    0x8(%ebp),%eax
f010c17c:	8b 40 64             	mov    0x64(%eax),%eax
f010c17f:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c185:	8b 45 08             	mov    0x8(%ebp),%eax
f010c188:	8b 40 68             	mov    0x68(%eax),%eax
f010c18b:	83 c8 03             	or     $0x3,%eax
f010c18e:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c190:	8b 45 08             	mov    0x8(%ebp),%eax
f010c193:	8b 40 64             	mov    0x64(%eax),%eax
f010c196:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c19c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19f:	8b 40 68             	mov    0x68(%eax),%eax
f010c1a2:	83 c8 05             	or     $0x5,%eax
f010c1a5:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c1a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1aa:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c1b1:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c1b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b7:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c1be:	00 00 00 
	e->disk_env_tabledir = 0;
f010c1c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1c4:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c1cb:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c1ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1d1:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c1d8:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c1db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1de:	8b 58 10             	mov    0x10(%eax),%ebx
f010c1e1:	83 ec 0c             	sub    $0xc,%esp
f010c1e4:	68 ca 02 00 00       	push   $0x2ca
f010c1e9:	e8 ab 19 01 00       	call   f011db99 <log2_ceil>
f010c1ee:	83 c4 10             	add    $0x10,%esp
f010c1f1:	ba 01 00 00 00       	mov    $0x1,%edx
f010c1f6:	88 c1                	mov    %al,%cl
f010c1f8:	d3 e2                	shl    %cl,%edx
f010c1fa:	89 d0                	mov    %edx,%eax
f010c1fc:	01 d8                	add    %ebx,%eax
f010c1fe:	89 c3                	mov    %eax,%ebx
f010c200:	83 ec 0c             	sub    $0xc,%esp
f010c203:	68 ca 02 00 00       	push   $0x2ca
f010c208:	e8 57 19 01 00       	call   f011db64 <nearest_pow2_ceil>
f010c20d:	83 c4 10             	add    $0x10,%esp
f010c210:	f7 d8                	neg    %eax
f010c212:	21 d8                	and    %ebx,%eax
f010c214:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c21b:	7f 1e                	jg     f010c23b <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c21d:	83 ec 0c             	sub    $0xc,%esp
f010c220:	68 ca 02 00 00       	push   $0x2ca
f010c225:	e8 6f 19 01 00       	call   f011db99 <log2_ceil>
f010c22a:	83 c4 10             	add    $0x10,%esp
f010c22d:	ba 01 00 00 00       	mov    $0x1,%edx
f010c232:	88 c1                	mov    %al,%cl
f010c234:	d3 e2                	shl    %cl,%edx
f010c236:	89 d0                	mov    %edx,%eax
f010c238:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23e:	8b 15 d0 47 69 f0    	mov    0xf06947d0,%edx
f010c244:	29 d0                	sub    %edx,%eax
f010c246:	c1 f8 02             	sar    $0x2,%eax
f010c249:	89 c2                	mov    %eax,%edx
f010c24b:	89 d0                	mov    %edx,%eax
f010c24d:	c1 e0 03             	shl    $0x3,%eax
f010c250:	01 d0                	add    %edx,%eax
f010c252:	c1 e0 03             	shl    $0x3,%eax
f010c255:	01 d0                	add    %edx,%eax
f010c257:	c1 e0 02             	shl    $0x2,%eax
f010c25a:	01 d0                	add    %edx,%eax
f010c25c:	01 c0                	add    %eax,%eax
f010c25e:	01 d0                	add    %edx,%eax
f010c260:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c267:	01 c8                	add    %ecx,%eax
f010c269:	c1 e0 02             	shl    $0x2,%eax
f010c26c:	01 d0                	add    %edx,%eax
f010c26e:	c1 e0 03             	shl    $0x3,%eax
f010c271:	01 d0                	add    %edx,%eax
f010c273:	c1 e0 05             	shl    $0x5,%eax
f010c276:	29 d0                	sub    %edx,%eax
f010c278:	c1 e0 02             	shl    $0x2,%eax
f010c27b:	01 d0                	add    %edx,%eax
f010c27d:	01 c0                	add    %eax,%eax
f010c27f:	01 d0                	add    %edx,%eax
f010c281:	c1 e0 03             	shl    $0x3,%eax
f010c284:	01 d0                	add    %edx,%eax
f010c286:	c1 e0 04             	shl    $0x4,%eax
f010c289:	29 d0                	sub    %edx,%eax
f010c28b:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c28e:	89 c2                	mov    %eax,%edx
f010c290:	8b 45 08             	mov    0x8(%ebp),%eax
f010c293:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c296:	e8 08 f1 ff ff       	call   f010b3a3 <get_cpu_proc>
f010c29b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c29e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c2a2:	75 0c                	jne    f010c2b0 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c2a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2a7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c2ae:	eb 0c                	jmp    f010c2bc <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c2b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c2b3:	8b 50 10             	mov    0x10(%eax),%edx
f010c2b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2b9:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c2bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2bf:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c2c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c9:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c2d0:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d6:	8b 00                	mov    (%eax),%eax
f010c2d8:	83 ec 04             	sub    $0x4,%esp
f010c2db:	6a 44                	push   $0x44
f010c2dd:	6a 00                	push   $0x0
f010c2df:	50                   	push   %eax
f010c2e0:	e8 0f 35 01 00       	call   f011f7f4 <memset>
f010c2e5:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c2e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2eb:	8b 00                	mov    (%eax),%eax
f010c2ed:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c2f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f6:	8b 00                	mov    (%eax),%eax
f010c2f8:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c2fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c301:	8b 00                	mov    (%eax),%eax
f010c303:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c309:	8b 45 08             	mov    0x8(%ebp),%eax
f010c30c:	8b 00                	mov    (%eax),%eax
f010c30e:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c315:	8b 45 08             	mov    0x8(%ebp),%eax
f010c318:	8b 00                	mov    (%eax),%eax
f010c31a:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c320:	8b 45 08             	mov    0x8(%ebp),%eax
f010c323:	8b 00                	mov    (%eax),%eax
f010c325:	8b 55 08             	mov    0x8(%ebp),%edx
f010c328:	8b 12                	mov    (%edx),%edx
f010c32a:	8b 52 38             	mov    0x38(%edx),%edx
f010c32d:	80 ce 02             	or     $0x2,%dh
f010c330:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c333:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c337:	75 17                	jne    f010c350 <complete_environment_initialization+0x1de>
f010c339:	83 ec 04             	sub    $0x4,%esp
f010c33c:	68 3b 5c 12 f0       	push   $0xf0125c3b
f010c341:	68 67 04 00 00       	push   $0x467
f010c346:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010c34b:	e8 e9 3f ff ff       	call   f0100339 <_panic>
f010c350:	8b 45 08             	mov    0x8(%ebp),%eax
f010c353:	8b 40 08             	mov    0x8(%eax),%eax
f010c356:	85 c0                	test   %eax,%eax
f010c358:	74 11                	je     f010c36b <complete_environment_initialization+0x1f9>
f010c35a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c35d:	8b 40 08             	mov    0x8(%eax),%eax
f010c360:	8b 55 08             	mov    0x8(%ebp),%edx
f010c363:	8b 52 0c             	mov    0xc(%edx),%edx
f010c366:	89 50 0c             	mov    %edx,0xc(%eax)
f010c369:	eb 0b                	jmp    f010c376 <complete_environment_initialization+0x204>
f010c36b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c36e:	8b 40 0c             	mov    0xc(%eax),%eax
f010c371:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010c376:	8b 45 08             	mov    0x8(%ebp),%eax
f010c379:	8b 40 0c             	mov    0xc(%eax),%eax
f010c37c:	85 c0                	test   %eax,%eax
f010c37e:	74 11                	je     f010c391 <complete_environment_initialization+0x21f>
f010c380:	8b 45 08             	mov    0x8(%ebp),%eax
f010c383:	8b 40 0c             	mov    0xc(%eax),%eax
f010c386:	8b 55 08             	mov    0x8(%ebp),%edx
f010c389:	8b 52 08             	mov    0x8(%edx),%edx
f010c38c:	89 50 08             	mov    %edx,0x8(%eax)
f010c38f:	eb 0b                	jmp    f010c39c <complete_environment_initialization+0x22a>
f010c391:	8b 45 08             	mov    0x8(%ebp),%eax
f010c394:	8b 40 08             	mov    0x8(%eax),%eax
f010c397:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010c39c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c39f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c3a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3a9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c3b0:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010c3b5:	48                   	dec    %eax
f010c3b6:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
	return ;
f010c3bb:	90                   	nop
}
f010c3bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c3bf:	c9                   	leave  
f010c3c0:	c3                   	ret    

f010c3c1 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c3c1:	55                   	push   %ebp
f010c3c2:	89 e5                	mov    %esp,%ebp
f010c3c4:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c3c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c3cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3d0:	8b 00                	mov    (%eax),%eax
f010c3d2:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c3d7:	74 17                	je     f010c3f0 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c3d9:	83 ec 04             	sub    $0x4,%esp
f010c3dc:	68 61 5e 12 f0       	push   $0xf0125e61
f010c3e1:	68 73 04 00 00       	push   $0x473
f010c3e6:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010c3eb:	e8 49 3f ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c3f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3f3:	8b 00                	mov    (%eax),%eax
f010c3f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c3f8:	8b 52 18             	mov    0x18(%edx),%edx
f010c3fb:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c3fe:	90                   	nop
f010c3ff:	c9                   	leave  
f010c400:	c3                   	ret    

f010c401 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c401:	55                   	push   %ebp
f010c402:	89 e5                	mov    %esp,%ebp
f010c404:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c407:	8b 45 08             	mov    0x8(%ebp),%eax
f010c40a:	8b 40 10             	mov    0x10(%eax),%eax
f010c40d:	8d 48 01             	lea    0x1(%eax),%ecx
f010c410:	8b 55 08             	mov    0x8(%ebp),%edx
f010c413:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c416:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c419:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c41c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c41f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c422:	8b 00                	mov    (%eax),%eax
f010c424:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c429:	74 17                	je     f010c442 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010c42b:	83 ec 04             	sub    $0x4,%esp
f010c42e:	68 61 5e 12 f0       	push   $0xf0125e61
f010c433:	68 81 04 00 00       	push   $0x481
f010c438:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010c43d:	e8 f7 3e ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c442:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c445:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c448:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c44b:	01 d0                	add    %edx,%eax
f010c44d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010c450:	eb 0f                	jmp    f010c461 <PROGRAM_SEGMENT_NEXT+0x60>
f010c452:	8b 45 08             	mov    0x8(%ebp),%eax
f010c455:	8b 40 10             	mov    0x10(%eax),%eax
f010c458:	8d 50 01             	lea    0x1(%eax),%edx
f010c45b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c45e:	89 50 10             	mov    %edx,0x10(%eax)
f010c461:	8b 45 08             	mov    0x8(%ebp),%eax
f010c464:	8b 40 10             	mov    0x10(%eax),%eax
f010c467:	c1 e0 05             	shl    $0x5,%eax
f010c46a:	89 c2                	mov    %eax,%edx
f010c46c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c46f:	01 d0                	add    %edx,%eax
f010c471:	8b 00                	mov    (%eax),%eax
f010c473:	83 f8 01             	cmp    $0x1,%eax
f010c476:	74 13                	je     f010c48b <PROGRAM_SEGMENT_NEXT+0x8a>
f010c478:	8b 45 08             	mov    0x8(%ebp),%eax
f010c47b:	8b 50 10             	mov    0x10(%eax),%edx
f010c47e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c481:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c484:	0f b7 c0             	movzwl %ax,%eax
f010c487:	39 c2                	cmp    %eax,%edx
f010c489:	72 c7                	jb     f010c452 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010c48b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c48e:	8b 40 10             	mov    0x10(%eax),%eax
f010c491:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010c494:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c497:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c49a:	0f b7 c0             	movzwl %ax,%eax
f010c49d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c4a0:	7e 63                	jle    f010c505 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c4a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4a5:	c1 e0 05             	shl    $0x5,%eax
f010c4a8:	89 c2                	mov    %eax,%edx
f010c4aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4ad:	01 d0                	add    %edx,%eax
f010c4af:	8b 50 04             	mov    0x4(%eax),%edx
f010c4b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c4b5:	01 c2                	add    %eax,%edx
f010c4b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4ba:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010c4bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4bf:	c1 e0 05             	shl    $0x5,%eax
f010c4c2:	89 c2                	mov    %eax,%edx
f010c4c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4c7:	01 d0                	add    %edx,%eax
f010c4c9:	8b 50 14             	mov    0x14(%eax),%edx
f010c4cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4cf:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010c4d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4d5:	c1 e0 05             	shl    $0x5,%eax
f010c4d8:	89 c2                	mov    %eax,%edx
f010c4da:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4dd:	01 d0                	add    %edx,%eax
f010c4df:	8b 50 10             	mov    0x10(%eax),%edx
f010c4e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e5:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010c4e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4eb:	c1 e0 05             	shl    $0x5,%eax
f010c4ee:	89 c2                	mov    %eax,%edx
f010c4f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4f3:	01 d0                	add    %edx,%eax
f010c4f5:	8b 40 08             	mov    0x8(%eax),%eax
f010c4f8:	89 c2                	mov    %eax,%edx
f010c4fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4fd:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010c500:	8b 45 08             	mov    0x8(%ebp),%eax
f010c503:	eb 05                	jmp    f010c50a <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010c505:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c50a:	c9                   	leave  
f010c50b:	c3                   	ret    

f010c50c <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010c50c:	55                   	push   %ebp
f010c50d:	89 e5                	mov    %esp,%ebp
f010c50f:	57                   	push   %edi
f010c510:	56                   	push   %esi
f010c511:	53                   	push   %ebx
f010c512:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010c515:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c51c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c51f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c522:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c525:	8b 00                	mov    (%eax),%eax
f010c527:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c52c:	74 17                	je     f010c545 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010c52e:	83 ec 04             	sub    $0x4,%esp
f010c531:	68 61 5e 12 f0       	push   $0xf0125e61
f010c536:	68 9d 04 00 00       	push   $0x49d
f010c53b:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010c540:	e8 f4 3d ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c545:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c548:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c54b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c54e:	01 d0                	add    %edx,%eax
f010c550:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010c553:	eb 07                	jmp    f010c55c <PROGRAM_SEGMENT_FIRST+0x50>
f010c555:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c558:	40                   	inc    %eax
f010c559:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c55c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c55f:	c1 e0 05             	shl    $0x5,%eax
f010c562:	89 c2                	mov    %eax,%edx
f010c564:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c567:	01 d0                	add    %edx,%eax
f010c569:	8b 00                	mov    (%eax),%eax
f010c56b:	83 f8 01             	cmp    $0x1,%eax
f010c56e:	74 10                	je     f010c580 <PROGRAM_SEGMENT_FIRST+0x74>
f010c570:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010c573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c576:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c579:	0f b7 c0             	movzwl %ax,%eax
f010c57c:	39 c2                	cmp    %eax,%edx
f010c57e:	72 d5                	jb     f010c555 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010c580:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c583:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010c586:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c589:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c58c:	0f b7 c0             	movzwl %ax,%eax
f010c58f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010c592:	7e 68                	jle    f010c5fc <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c594:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c597:	c1 e0 05             	shl    $0x5,%eax
f010c59a:	89 c2                	mov    %eax,%edx
f010c59c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c59f:	01 d0                	add    %edx,%eax
f010c5a1:	8b 50 04             	mov    0x4(%eax),%edx
f010c5a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c5a7:	01 d0                	add    %edx,%eax
f010c5a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010c5ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c5af:	c1 e0 05             	shl    $0x5,%eax
f010c5b2:	89 c2                	mov    %eax,%edx
f010c5b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c5b7:	01 d0                	add    %edx,%eax
f010c5b9:	8b 40 14             	mov    0x14(%eax),%eax
f010c5bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010c5bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c5c2:	c1 e0 05             	shl    $0x5,%eax
f010c5c5:	89 c2                	mov    %eax,%edx
f010c5c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c5ca:	01 d0                	add    %edx,%eax
f010c5cc:	8b 40 10             	mov    0x10(%eax),%eax
f010c5cf:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010c5d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c5d5:	c1 e0 05             	shl    $0x5,%eax
f010c5d8:	89 c2                	mov    %eax,%edx
f010c5da:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c5dd:	01 d0                	add    %edx,%eax
f010c5df:	8b 40 08             	mov    0x8(%eax),%eax
f010c5e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010c5e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5e8:	89 c3                	mov    %eax,%ebx
f010c5ea:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c5ed:	ba 05 00 00 00       	mov    $0x5,%edx
f010c5f2:	89 df                	mov    %ebx,%edi
f010c5f4:	89 c6                	mov    %eax,%esi
f010c5f6:	89 d1                	mov    %edx,%ecx
f010c5f8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010c5fa:	eb 1c                	jmp    f010c618 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010c5fc:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010c603:	8b 45 08             	mov    0x8(%ebp),%eax
f010c606:	89 c3                	mov    %eax,%ebx
f010c608:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c60b:	ba 05 00 00 00       	mov    $0x5,%edx
f010c610:	89 df                	mov    %ebx,%edi
f010c612:	89 c6                	mov    %eax,%esi
f010c614:	89 d1                	mov    %edx,%ecx
f010c616:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010c618:	8b 45 08             	mov    0x8(%ebp),%eax
f010c61b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010c61e:	5b                   	pop    %ebx
f010c61f:	5e                   	pop    %esi
f010c620:	5f                   	pop    %edi
f010c621:	5d                   	pop    %ebp
f010c622:	c2 04 00             	ret    $0x4

f010c625 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010c625:	55                   	push   %ebp
f010c626:	89 e5                	mov    %esp,%ebp
f010c628:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010c62b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010c632:	83 ec 0c             	sub    $0xc,%esp
f010c635:	68 80 d3 6b f0       	push   $0xf06bd380
f010c63a:	e8 06 30 00 00       	call   f010f645 <acquire_spinlock>
f010c63f:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c642:	a1 70 d3 6b f0       	mov    0xf06bd370,%eax
f010c647:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c64a:	e9 c3 00 00 00       	jmp    f010c712 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010c64f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c652:	8b 40 0c             	mov    0xc(%eax),%eax
f010c655:	3b 45 08             	cmp    0x8(%ebp),%eax
f010c658:	0f 85 ac 00 00 00    	jne    f010c70a <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010c65e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c661:	8b 50 10             	mov    0x10(%eax),%edx
f010c664:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c667:	8b 40 0c             	mov    0xc(%eax),%eax
f010c66a:	8b 40 64             	mov    0x64(%eax),%eax
f010c66d:	83 ec 08             	sub    $0x8,%esp
f010c670:	52                   	push   %edx
f010c671:	50                   	push   %eax
f010c672:	e8 79 d0 ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f010c677:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010c67a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c67e:	75 17                	jne    f010c697 <cleanup_buffers+0x72>
f010c680:	83 ec 04             	sub    $0x4,%esp
f010c683:	68 3b 5c 12 f0       	push   $0xf0125c3b
f010c688:	68 c6 04 00 00       	push   $0x4c6
f010c68d:	68 b3 5b 12 f0       	push   $0xf0125bb3
f010c692:	e8 a2 3c ff ff       	call   f0100339 <_panic>
f010c697:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c69a:	8b 00                	mov    (%eax),%eax
f010c69c:	85 c0                	test   %eax,%eax
f010c69e:	74 10                	je     f010c6b0 <cleanup_buffers+0x8b>
f010c6a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6a3:	8b 00                	mov    (%eax),%eax
f010c6a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6a8:	8b 52 04             	mov    0x4(%edx),%edx
f010c6ab:	89 50 04             	mov    %edx,0x4(%eax)
f010c6ae:	eb 0b                	jmp    f010c6bb <cleanup_buffers+0x96>
f010c6b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6b3:	8b 40 04             	mov    0x4(%eax),%eax
f010c6b6:	a3 74 d3 6b f0       	mov    %eax,0xf06bd374
f010c6bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6be:	8b 40 04             	mov    0x4(%eax),%eax
f010c6c1:	85 c0                	test   %eax,%eax
f010c6c3:	74 0f                	je     f010c6d4 <cleanup_buffers+0xaf>
f010c6c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6c8:	8b 40 04             	mov    0x4(%eax),%eax
f010c6cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6ce:	8b 12                	mov    (%edx),%edx
f010c6d0:	89 10                	mov    %edx,(%eax)
f010c6d2:	eb 0a                	jmp    f010c6de <cleanup_buffers+0xb9>
f010c6d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6d7:	8b 00                	mov    (%eax),%eax
f010c6d9:	a3 70 d3 6b f0       	mov    %eax,0xf06bd370
f010c6de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6e1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010c6e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6ea:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010c6f1:	a1 7c d3 6b f0       	mov    0xf06bd37c,%eax
f010c6f6:	48                   	dec    %eax
f010c6f7:	a3 7c d3 6b f0       	mov    %eax,0xf06bd37c

				free_frame(ptr_fi);
f010c6fc:	83 ec 0c             	sub    $0xc,%esp
f010c6ff:	ff 75 f4             	pushl  -0xc(%ebp)
f010c702:	e8 ff bb ff ff       	call   f0108306 <free_frame>
f010c707:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c70a:	a1 78 d3 6b f0       	mov    0xf06bd378,%eax
f010c70f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c712:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c716:	74 07                	je     f010c71f <cleanup_buffers+0xfa>
f010c718:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c71b:	8b 00                	mov    (%eax),%eax
f010c71d:	eb 05                	jmp    f010c724 <cleanup_buffers+0xff>
f010c71f:	b8 00 00 00 00       	mov    $0x0,%eax
f010c724:	a3 78 d3 6b f0       	mov    %eax,0xf06bd378
f010c729:	a1 78 d3 6b f0       	mov    0xf06bd378,%eax
f010c72e:	85 c0                	test   %eax,%eax
f010c730:	0f 85 19 ff ff ff    	jne    f010c64f <cleanup_buffers+0x2a>
f010c736:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c73a:	0f 85 0f ff ff ff    	jne    f010c64f <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010c740:	83 ec 0c             	sub    $0xc,%esp
f010c743:	68 80 d3 6b f0       	push   $0xf06bd380
f010c748:	e8 7f 2f 00 00       	call   f010f6cc <release_spinlock>
f010c74d:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010c750:	90                   	nop
f010c751:	c9                   	leave  
f010c752:	c3                   	ret    

f010c753 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010c753:	55                   	push   %ebp
f010c754:	89 e5                	mov    %esp,%ebp
f010c756:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010c759:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010c75d:	7e 06                	jle    f010c765 <set_program_priority+0x12>
f010c75f:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c763:	7e 14                	jle    f010c779 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010c765:	83 ec 04             	sub    $0x4,%esp
f010c768:	68 78 5e 12 f0       	push   $0xf0125e78
f010c76d:	6a 10                	push   $0x10
f010c76f:	68 9c 5e 12 f0       	push   $0xf0125e9c
f010c774:	e8 c0 3b ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010c779:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c77d:	74 78                	je     f010c7f7 <set_program_priority+0xa4>
		return;
	switch(priority)
f010c77f:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c783:	77 56                	ja     f010c7db <set_program_priority+0x88>
f010c785:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c788:	c1 e0 02             	shl    $0x2,%eax
f010c78b:	05 d8 5e 12 f0       	add    $0xf0125ed8,%eax
f010c790:	8b 00                	mov    (%eax),%eax
f010c792:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010c794:	83 ec 08             	sub    $0x8,%esp
f010c797:	6a 01                	push   $0x1
f010c799:	ff 75 08             	pushl  0x8(%ebp)
f010c79c:	e8 a6 dc ff ff       	call   f010a447 <half_WS_Size>
f010c7a1:	83 c4 10             	add    $0x10,%esp
			break;
f010c7a4:	eb 35                	jmp    f010c7db <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010c7a6:	83 ec 08             	sub    $0x8,%esp
f010c7a9:	6a 00                	push   $0x0
f010c7ab:	ff 75 08             	pushl  0x8(%ebp)
f010c7ae:	e8 94 dc ff ff       	call   f010a447 <half_WS_Size>
f010c7b3:	83 c4 10             	add    $0x10,%esp
			break;
f010c7b6:	eb 23                	jmp    f010c7db <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010c7b8:	83 ec 08             	sub    $0x8,%esp
f010c7bb:	6a 01                	push   $0x1
f010c7bd:	ff 75 08             	pushl  0x8(%ebp)
f010c7c0:	e8 65 dc ff ff       	call   f010a42a <double_WS_Size>
f010c7c5:	83 c4 10             	add    $0x10,%esp
			break;
f010c7c8:	eb 11                	jmp    f010c7db <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010c7ca:	83 ec 08             	sub    $0x8,%esp
f010c7cd:	6a 00                	push   $0x0
f010c7cf:	ff 75 08             	pushl  0x8(%ebp)
f010c7d2:	e8 53 dc ff ff       	call   f010a42a <double_WS_Size>
f010c7d7:	83 c4 10             	add    $0x10,%esp
			break;
f010c7da:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010c7db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7de:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c7e4:	83 ec 08             	sub    $0x8,%esp
f010c7e7:	50                   	push   %eax
f010c7e8:	68 b9 5e 12 f0       	push   $0xf0125eb9
f010c7ed:	e8 99 47 ff ff       	call   f0100f8b <cprintf>
f010c7f2:	83 c4 10             	add    $0x10,%esp
f010c7f5:	eb 01                	jmp    f010c7f8 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010c7f7:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010c7f8:	c9                   	leave  
f010c7f9:	c3                   	ret    

f010c7fa <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010c7fa:	55                   	push   %ebp
f010c7fb:	89 e5                	mov    %esp,%ebp
f010c7fd:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c800:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c807:	eb 29                	jmp    f010c832 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010c809:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c80c:	89 d0                	mov    %edx,%eax
f010c80e:	01 c0                	add    %eax,%eax
f010c810:	01 d0                	add    %edx,%eax
f010c812:	c1 e0 02             	shl    $0x2,%eax
f010c815:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c81a:	8b 00                	mov    (%eax),%eax
f010c81c:	83 ec 08             	sub    $0x8,%esp
f010c81f:	50                   	push   %eax
f010c820:	ff 75 08             	pushl  0x8(%ebp)
f010c823:	e8 ea 2e 01 00       	call   f011f712 <strcmp>
f010c828:	83 c4 10             	add    $0x10,%esp
f010c82b:	85 c0                	test   %eax,%eax
f010c82d:	74 0f                	je     f010c83e <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c82f:	ff 45 f4             	incl   -0xc(%ebp)
f010c832:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c837:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c83a:	7c cd                	jl     f010c809 <get_user_program_info+0xf>
f010c83c:	eb 01                	jmp    f010c83f <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010c83e:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c83f:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c844:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c847:	75 1a                	jne    f010c863 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010c849:	83 ec 08             	sub    $0x8,%esp
f010c84c:	ff 75 08             	pushl  0x8(%ebp)
f010c84f:	68 3d 6c 12 f0       	push   $0xf0126c3d
f010c854:	e8 32 47 ff ff       	call   f0100f8b <cprintf>
f010c859:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c85c:	b8 00 00 00 00       	mov    $0x0,%eax
f010c861:	eb 11                	jmp    f010c874 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010c863:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c866:	89 d0                	mov    %edx,%eax
f010c868:	01 c0                	add    %eax,%eax
f010c86a:	01 d0                	add    %edx,%eax
f010c86c:	c1 e0 02             	shl    $0x2,%eax
f010c86f:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c874:	c9                   	leave  
f010c875:	c3                   	ret    

f010c876 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010c876:	55                   	push   %ebp
f010c877:	89 e5                	mov    %esp,%ebp
f010c879:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c87c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c883:	eb 2d                	jmp    f010c8b2 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010c885:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c888:	89 d0                	mov    %edx,%eax
f010c88a:	01 c0                	add    %eax,%eax
f010c88c:	01 d0                	add    %edx,%eax
f010c88e:	c1 e0 02             	shl    $0x2,%eax
f010c891:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c896:	8b 00                	mov    (%eax),%eax
f010c898:	8b 55 08             	mov    0x8(%ebp),%edx
f010c89b:	83 c2 20             	add    $0x20,%edx
f010c89e:	83 ec 08             	sub    $0x8,%esp
f010c8a1:	50                   	push   %eax
f010c8a2:	52                   	push   %edx
f010c8a3:	e8 6a 2e 01 00       	call   f011f712 <strcmp>
f010c8a8:	83 c4 10             	add    $0x10,%esp
f010c8ab:	85 c0                	test   %eax,%eax
f010c8ad:	74 0f                	je     f010c8be <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c8af:	ff 45 f4             	incl   -0xc(%ebp)
f010c8b2:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c8b7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c8ba:	7c c9                	jl     f010c885 <get_user_program_info_by_env+0xf>
f010c8bc:	eb 01                	jmp    f010c8bf <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c8be:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c8bf:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c8c4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c8c7:	75 17                	jne    f010c8e0 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c8c9:	83 ec 0c             	sub    $0xc,%esp
f010c8cc:	68 58 6c 12 f0       	push   $0xf0126c58
f010c8d1:	e8 b5 46 ff ff       	call   f0100f8b <cprintf>
f010c8d6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c8d9:	b8 00 00 00 00       	mov    $0x0,%eax
f010c8de:	eb 11                	jmp    f010c8f1 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c8e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c8e3:	89 d0                	mov    %edx,%eax
f010c8e5:	01 c0                	add    %eax,%eax
f010c8e7:	01 d0                	add    %edx,%eax
f010c8e9:	c1 e0 02             	shl    $0x2,%eax
f010c8ec:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c8f1:	c9                   	leave  
f010c8f2:	c3                   	ret    

f010c8f3 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c8f3:	55                   	push   %ebp
f010c8f4:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c8f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8f9:	83 f8 13             	cmp    $0x13,%eax
f010c8fc:	77 0c                	ja     f010c90a <trapname+0x17>
		return excnames[trapno];
f010c8fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c901:	8b 04 85 40 70 12 f0 	mov    -0xfed8fc0(,%eax,4),%eax
f010c908:	eb 2c                	jmp    f010c936 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c90a:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c90e:	75 07                	jne    f010c917 <trapname+0x24>
		return "System call";
f010c910:	b8 80 6c 12 f0       	mov    $0xf0126c80,%eax
f010c915:	eb 1f                	jmp    f010c936 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c917:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c91b:	75 07                	jne    f010c924 <trapname+0x31>
		return "Clock Interrupt";
f010c91d:	b8 8c 6c 12 f0       	mov    $0xf0126c8c,%eax
f010c922:	eb 12                	jmp    f010c936 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c924:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c928:	75 07                	jne    f010c931 <trapname+0x3e>
		return "Keyboard Interrupt";
f010c92a:	b8 9c 6c 12 f0       	mov    $0xf0126c9c,%eax
f010c92f:	eb 05                	jmp    f010c936 <trapname+0x43>
	return "(unknown trap)";
f010c931:	b8 af 6c 12 f0       	mov    $0xf0126caf,%eax
}
f010c936:	5d                   	pop    %ebp
f010c937:	c3                   	ret    

f010c938 <ts_init>:


void ts_init(void)
{
f010c938:	55                   	push   %ebp
f010c939:	89 e5                	mov    %esp,%ebp
f010c93b:	53                   	push   %ebx
f010c93c:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c93f:	e8 8b a8 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010c944:	e8 c3 a7 ff ff       	call   f010710c <mycpu>
f010c949:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c94c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c94f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c956:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c959:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c95f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c962:	83 c0 0c             	add    $0xc,%eax
f010c965:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c968:	83 c2 0c             	add    $0xc,%edx
f010c96b:	c1 ea 10             	shr    $0x10,%edx
f010c96e:	88 d3                	mov    %dl,%bl
f010c970:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c973:	83 c2 0c             	add    $0xc,%edx
f010c976:	c1 ea 18             	shr    $0x18,%edx
f010c979:	88 d1                	mov    %dl,%cl
f010c97b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c97e:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c985:	68 00 
f010c987:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c98a:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c991:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c994:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c99a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c99d:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9a3:	83 e2 f0             	and    $0xfffffff0,%edx
f010c9a6:	83 ca 09             	or     $0x9,%edx
f010c9a9:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9b2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9b8:	83 ca 10             	or     $0x10,%edx
f010c9bb:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9c4:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9ca:	83 e2 9f             	and    $0xffffff9f,%edx
f010c9cd:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9d6:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9dc:	83 ca 80             	or     $0xffffff80,%edx
f010c9df:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9e8:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c9ee:	83 e2 f0             	and    $0xfffffff0,%edx
f010c9f1:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c9f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9fa:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca00:	83 e2 ef             	and    $0xffffffef,%edx
f010ca03:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca0c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca12:	83 e2 df             	and    $0xffffffdf,%edx
f010ca15:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca1e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca24:	83 ca 40             	or     $0x40,%edx
f010ca27:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca30:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca36:	83 e2 7f             	and    $0x7f,%edx
f010ca39:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca42:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ca48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca4b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ca51:	83 e2 ef             	and    $0xffffffef,%edx
f010ca54:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010ca5a:	e8 c2 a7 ff ff       	call   f0107221 <popcli>
f010ca5f:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010ca65:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010ca69:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010ca6c:	90                   	nop
f010ca6d:	83 c4 14             	add    $0x14,%esp
f010ca70:	5b                   	pop    %ebx
f010ca71:	5d                   	pop    %ebp
f010ca72:	c3                   	ret    

f010ca73 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010ca73:	55                   	push   %ebp
f010ca74:	89 e5                	mov    %esp,%ebp
f010ca76:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010ca79:	b8 22 df 10 f0       	mov    $0xf010df22,%eax
f010ca7e:	66 a3 40 48 69 f0    	mov    %ax,0xf0694840
f010ca84:	66 c7 05 42 48 69 f0 	movw   $0x8,0xf0694842
f010ca8b:	08 00 
f010ca8d:	a0 44 48 69 f0       	mov    0xf0694844,%al
f010ca92:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca95:	a2 44 48 69 f0       	mov    %al,0xf0694844
f010ca9a:	a0 44 48 69 f0       	mov    0xf0694844,%al
f010ca9f:	83 e0 1f             	and    $0x1f,%eax
f010caa2:	a2 44 48 69 f0       	mov    %al,0xf0694844
f010caa7:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010caac:	83 e0 f0             	and    $0xfffffff0,%eax
f010caaf:	83 c8 0e             	or     $0xe,%eax
f010cab2:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cab7:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010cabc:	83 e0 ef             	and    $0xffffffef,%eax
f010cabf:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cac4:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010cac9:	83 e0 9f             	and    $0xffffff9f,%eax
f010cacc:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cad1:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010cad6:	83 c8 80             	or     $0xffffff80,%eax
f010cad9:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cade:	b8 22 df 10 f0       	mov    $0xf010df22,%eax
f010cae3:	c1 e8 10             	shr    $0x10,%eax
f010cae6:	66 a3 46 48 69 f0    	mov    %ax,0xf0694846
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010caec:	b8 2a df 10 f0       	mov    $0xf010df2a,%eax
f010caf1:	66 a3 70 48 69 f0    	mov    %ax,0xf0694870
f010caf7:	66 c7 05 72 48 69 f0 	movw   $0x8,0xf0694872
f010cafe:	08 00 
f010cb00:	a0 74 48 69 f0       	mov    0xf0694874,%al
f010cb05:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb08:	a2 74 48 69 f0       	mov    %al,0xf0694874
f010cb0d:	a0 74 48 69 f0       	mov    0xf0694874,%al
f010cb12:	83 e0 1f             	and    $0x1f,%eax
f010cb15:	a2 74 48 69 f0       	mov    %al,0xf0694874
f010cb1a:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb1f:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb22:	83 c8 0e             	or     $0xe,%eax
f010cb25:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb2a:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb2f:	83 e0 ef             	and    $0xffffffef,%eax
f010cb32:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb37:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb3c:	83 e0 9f             	and    $0xffffff9f,%eax
f010cb3f:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb44:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb49:	83 c8 80             	or     $0xffffff80,%eax
f010cb4c:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb51:	b8 2a df 10 f0       	mov    $0xf010df2a,%eax
f010cb56:	c1 e8 10             	shr    $0x10,%eax
f010cb59:	66 a3 76 48 69 f0    	mov    %ax,0xf0694876
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010cb5f:	b8 32 df 10 f0       	mov    $0xf010df32,%eax
f010cb64:	66 a3 00 49 69 f0    	mov    %ax,0xf0694900
f010cb6a:	66 c7 05 02 49 69 f0 	movw   $0x8,0xf0694902
f010cb71:	08 00 
f010cb73:	a0 04 49 69 f0       	mov    0xf0694904,%al
f010cb78:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb7b:	a2 04 49 69 f0       	mov    %al,0xf0694904
f010cb80:	a0 04 49 69 f0       	mov    0xf0694904,%al
f010cb85:	83 e0 1f             	and    $0x1f,%eax
f010cb88:	a2 04 49 69 f0       	mov    %al,0xf0694904
f010cb8d:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cb92:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb95:	83 c8 0e             	or     $0xe,%eax
f010cb98:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cb9d:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cba2:	83 e0 ef             	and    $0xffffffef,%eax
f010cba5:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cbaa:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cbaf:	83 c8 60             	or     $0x60,%eax
f010cbb2:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cbb7:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cbbc:	83 c8 80             	or     $0xffffff80,%eax
f010cbbf:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cbc4:	b8 32 df 10 f0       	mov    $0xf010df32,%eax
f010cbc9:	c1 e8 10             	shr    $0x10,%eax
f010cbcc:	66 a3 06 49 69 f0    	mov    %ax,0xf0694906
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010cbd2:	b8 3c df 10 f0       	mov    $0xf010df3c,%eax
f010cbd7:	66 a3 08 49 69 f0    	mov    %ax,0xf0694908
f010cbdd:	66 c7 05 0a 49 69 f0 	movw   $0x8,0xf069490a
f010cbe4:	08 00 
f010cbe6:	a0 0c 49 69 f0       	mov    0xf069490c,%al
f010cbeb:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbee:	a2 0c 49 69 f0       	mov    %al,0xf069490c
f010cbf3:	a0 0c 49 69 f0       	mov    0xf069490c,%al
f010cbf8:	83 e0 1f             	and    $0x1f,%eax
f010cbfb:	a2 0c 49 69 f0       	mov    %al,0xf069490c
f010cc00:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc05:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc08:	83 c8 0e             	or     $0xe,%eax
f010cc0b:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc10:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc15:	83 e0 ef             	and    $0xffffffef,%eax
f010cc18:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc1d:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc22:	83 c8 60             	or     $0x60,%eax
f010cc25:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc2a:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc2f:	83 c8 80             	or     $0xffffff80,%eax
f010cc32:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc37:	b8 3c df 10 f0       	mov    $0xf010df3c,%eax
f010cc3c:	c1 e8 10             	shr    $0x10,%eax
f010cc3f:	66 a3 0e 49 69 f0    	mov    %ax,0xf069490e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010cc45:	b8 46 df 10 f0       	mov    $0xf010df46,%eax
f010cc4a:	66 a3 80 49 69 f0    	mov    %ax,0xf0694980
f010cc50:	66 c7 05 82 49 69 f0 	movw   $0x8,0xf0694982
f010cc57:	08 00 
f010cc59:	a0 84 49 69 f0       	mov    0xf0694984,%al
f010cc5e:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc61:	a2 84 49 69 f0       	mov    %al,0xf0694984
f010cc66:	a0 84 49 69 f0       	mov    0xf0694984,%al
f010cc6b:	83 e0 1f             	and    $0x1f,%eax
f010cc6e:	a2 84 49 69 f0       	mov    %al,0xf0694984
f010cc73:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc78:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc7b:	83 c8 0e             	or     $0xe,%eax
f010cc7e:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc83:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc88:	83 e0 ef             	and    $0xffffffef,%eax
f010cc8b:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc90:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc95:	83 c8 60             	or     $0x60,%eax
f010cc98:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc9d:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cca2:	83 c8 80             	or     $0xffffff80,%eax
f010cca5:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010ccaa:	b8 46 df 10 f0       	mov    $0xf010df46,%eax
f010ccaf:	c1 e8 10             	shr    $0x10,%eax
f010ccb2:	66 a3 86 49 69 f0    	mov    %ax,0xf0694986

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010ccb8:	b8 50 df 10 f0       	mov    $0xf010df50,%eax
f010ccbd:	66 a3 00 48 69 f0    	mov    %ax,0xf0694800
f010ccc3:	66 c7 05 02 48 69 f0 	movw   $0x8,0xf0694802
f010ccca:	08 00 
f010cccc:	a0 04 48 69 f0       	mov    0xf0694804,%al
f010ccd1:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccd4:	a2 04 48 69 f0       	mov    %al,0xf0694804
f010ccd9:	a0 04 48 69 f0       	mov    0xf0694804,%al
f010ccde:	83 e0 1f             	and    $0x1f,%eax
f010cce1:	a2 04 48 69 f0       	mov    %al,0xf0694804
f010cce6:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010cceb:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccee:	83 c8 0e             	or     $0xe,%eax
f010ccf1:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010ccf6:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010ccfb:	83 e0 ef             	and    $0xffffffef,%eax
f010ccfe:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010cd03:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010cd08:	83 c8 60             	or     $0x60,%eax
f010cd0b:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010cd10:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010cd15:	83 c8 80             	or     $0xffffff80,%eax
f010cd18:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010cd1d:	b8 50 df 10 f0       	mov    $0xf010df50,%eax
f010cd22:	c1 e8 10             	shr    $0x10,%eax
f010cd25:	66 a3 06 48 69 f0    	mov    %ax,0xf0694806
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010cd2b:	b8 5a df 10 f0       	mov    $0xf010df5a,%eax
f010cd30:	66 a3 08 48 69 f0    	mov    %ax,0xf0694808
f010cd36:	66 c7 05 0a 48 69 f0 	movw   $0x8,0xf069480a
f010cd3d:	08 00 
f010cd3f:	a0 0c 48 69 f0       	mov    0xf069480c,%al
f010cd44:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd47:	a2 0c 48 69 f0       	mov    %al,0xf069480c
f010cd4c:	a0 0c 48 69 f0       	mov    0xf069480c,%al
f010cd51:	83 e0 1f             	and    $0x1f,%eax
f010cd54:	a2 0c 48 69 f0       	mov    %al,0xf069480c
f010cd59:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd5e:	83 c8 0f             	or     $0xf,%eax
f010cd61:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd66:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd6b:	83 e0 ef             	and    $0xffffffef,%eax
f010cd6e:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd73:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd78:	83 c8 60             	or     $0x60,%eax
f010cd7b:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd80:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd85:	83 c8 80             	or     $0xffffff80,%eax
f010cd88:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd8d:	b8 5a df 10 f0       	mov    $0xf010df5a,%eax
f010cd92:	c1 e8 10             	shr    $0x10,%eax
f010cd95:	66 a3 0e 48 69 f0    	mov    %ax,0xf069480e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010cd9b:	b8 64 df 10 f0       	mov    $0xf010df64,%eax
f010cda0:	66 a3 10 48 69 f0    	mov    %ax,0xf0694810
f010cda6:	66 c7 05 12 48 69 f0 	movw   $0x8,0xf0694812
f010cdad:	08 00 
f010cdaf:	a0 14 48 69 f0       	mov    0xf0694814,%al
f010cdb4:	83 e0 e0             	and    $0xffffffe0,%eax
f010cdb7:	a2 14 48 69 f0       	mov    %al,0xf0694814
f010cdbc:	a0 14 48 69 f0       	mov    0xf0694814,%al
f010cdc1:	83 e0 1f             	and    $0x1f,%eax
f010cdc4:	a2 14 48 69 f0       	mov    %al,0xf0694814
f010cdc9:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdce:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdd1:	83 c8 0e             	or     $0xe,%eax
f010cdd4:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cdd9:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdde:	83 e0 ef             	and    $0xffffffef,%eax
f010cde1:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cde6:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdeb:	83 c8 60             	or     $0x60,%eax
f010cdee:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cdf3:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdf8:	83 c8 80             	or     $0xffffff80,%eax
f010cdfb:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010ce00:	b8 64 df 10 f0       	mov    $0xf010df64,%eax
f010ce05:	c1 e8 10             	shr    $0x10,%eax
f010ce08:	66 a3 16 48 69 f0    	mov    %ax,0xf0694816
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010ce0e:	b8 6e df 10 f0       	mov    $0xf010df6e,%eax
f010ce13:	66 a3 18 48 69 f0    	mov    %ax,0xf0694818
f010ce19:	66 c7 05 1a 48 69 f0 	movw   $0x8,0xf069481a
f010ce20:	08 00 
f010ce22:	a0 1c 48 69 f0       	mov    0xf069481c,%al
f010ce27:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce2a:	a2 1c 48 69 f0       	mov    %al,0xf069481c
f010ce2f:	a0 1c 48 69 f0       	mov    0xf069481c,%al
f010ce34:	83 e0 1f             	and    $0x1f,%eax
f010ce37:	a2 1c 48 69 f0       	mov    %al,0xf069481c
f010ce3c:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce41:	83 c8 0f             	or     $0xf,%eax
f010ce44:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce49:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce4e:	83 e0 ef             	and    $0xffffffef,%eax
f010ce51:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce56:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce5b:	83 c8 60             	or     $0x60,%eax
f010ce5e:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce63:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce68:	83 c8 80             	or     $0xffffff80,%eax
f010ce6b:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce70:	b8 6e df 10 f0       	mov    $0xf010df6e,%eax
f010ce75:	c1 e8 10             	shr    $0x10,%eax
f010ce78:	66 a3 1e 48 69 f0    	mov    %ax,0xf069481e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010ce7e:	b8 78 df 10 f0       	mov    $0xf010df78,%eax
f010ce83:	66 a3 20 48 69 f0    	mov    %ax,0xf0694820
f010ce89:	66 c7 05 22 48 69 f0 	movw   $0x8,0xf0694822
f010ce90:	08 00 
f010ce92:	a0 24 48 69 f0       	mov    0xf0694824,%al
f010ce97:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce9a:	a2 24 48 69 f0       	mov    %al,0xf0694824
f010ce9f:	a0 24 48 69 f0       	mov    0xf0694824,%al
f010cea4:	83 e0 1f             	and    $0x1f,%eax
f010cea7:	a2 24 48 69 f0       	mov    %al,0xf0694824
f010ceac:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010ceb1:	83 c8 0f             	or     $0xf,%eax
f010ceb4:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010ceb9:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010cebe:	83 e0 ef             	and    $0xffffffef,%eax
f010cec1:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010cec6:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010cecb:	83 c8 60             	or     $0x60,%eax
f010cece:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010ced3:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010ced8:	83 c8 80             	or     $0xffffff80,%eax
f010cedb:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010cee0:	b8 78 df 10 f0       	mov    $0xf010df78,%eax
f010cee5:	c1 e8 10             	shr    $0x10,%eax
f010cee8:	66 a3 26 48 69 f0    	mov    %ax,0xf0694826
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010ceee:	b8 82 df 10 f0       	mov    $0xf010df82,%eax
f010cef3:	66 a3 28 48 69 f0    	mov    %ax,0xf0694828
f010cef9:	66 c7 05 2a 48 69 f0 	movw   $0x8,0xf069482a
f010cf00:	08 00 
f010cf02:	a0 2c 48 69 f0       	mov    0xf069482c,%al
f010cf07:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf0a:	a2 2c 48 69 f0       	mov    %al,0xf069482c
f010cf0f:	a0 2c 48 69 f0       	mov    0xf069482c,%al
f010cf14:	83 e0 1f             	and    $0x1f,%eax
f010cf17:	a2 2c 48 69 f0       	mov    %al,0xf069482c
f010cf1c:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf21:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf24:	83 c8 0e             	or     $0xe,%eax
f010cf27:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf2c:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf31:	83 e0 ef             	and    $0xffffffef,%eax
f010cf34:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf39:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf3e:	83 c8 60             	or     $0x60,%eax
f010cf41:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf46:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf4b:	83 c8 80             	or     $0xffffff80,%eax
f010cf4e:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf53:	b8 82 df 10 f0       	mov    $0xf010df82,%eax
f010cf58:	c1 e8 10             	shr    $0x10,%eax
f010cf5b:	66 a3 2e 48 69 f0    	mov    %ax,0xf069482e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010cf61:	b8 8c df 10 f0       	mov    $0xf010df8c,%eax
f010cf66:	66 a3 30 48 69 f0    	mov    %ax,0xf0694830
f010cf6c:	66 c7 05 32 48 69 f0 	movw   $0x8,0xf0694832
f010cf73:	08 00 
f010cf75:	a0 34 48 69 f0       	mov    0xf0694834,%al
f010cf7a:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf7d:	a2 34 48 69 f0       	mov    %al,0xf0694834
f010cf82:	a0 34 48 69 f0       	mov    0xf0694834,%al
f010cf87:	83 e0 1f             	and    $0x1f,%eax
f010cf8a:	a2 34 48 69 f0       	mov    %al,0xf0694834
f010cf8f:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cf94:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf97:	83 c8 0e             	or     $0xe,%eax
f010cf9a:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cf9f:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cfa4:	83 e0 ef             	and    $0xffffffef,%eax
f010cfa7:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cfac:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cfb1:	83 c8 60             	or     $0x60,%eax
f010cfb4:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cfb9:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cfbe:	83 c8 80             	or     $0xffffff80,%eax
f010cfc1:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cfc6:	b8 8c df 10 f0       	mov    $0xf010df8c,%eax
f010cfcb:	c1 e8 10             	shr    $0x10,%eax
f010cfce:	66 a3 36 48 69 f0    	mov    %ax,0xf0694836
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010cfd4:	b8 96 df 10 f0       	mov    $0xf010df96,%eax
f010cfd9:	66 a3 38 48 69 f0    	mov    %ax,0xf0694838
f010cfdf:	66 c7 05 3a 48 69 f0 	movw   $0x8,0xf069483a
f010cfe6:	08 00 
f010cfe8:	a0 3c 48 69 f0       	mov    0xf069483c,%al
f010cfed:	83 e0 e0             	and    $0xffffffe0,%eax
f010cff0:	a2 3c 48 69 f0       	mov    %al,0xf069483c
f010cff5:	a0 3c 48 69 f0       	mov    0xf069483c,%al
f010cffa:	83 e0 1f             	and    $0x1f,%eax
f010cffd:	a2 3c 48 69 f0       	mov    %al,0xf069483c
f010d002:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d007:	83 e0 f0             	and    $0xfffffff0,%eax
f010d00a:	83 c8 0e             	or     $0xe,%eax
f010d00d:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d012:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d017:	83 e0 ef             	and    $0xffffffef,%eax
f010d01a:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d01f:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d024:	83 c8 60             	or     $0x60,%eax
f010d027:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d02c:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d031:	83 c8 80             	or     $0xffffff80,%eax
f010d034:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d039:	b8 96 df 10 f0       	mov    $0xf010df96,%eax
f010d03e:	c1 e8 10             	shr    $0x10,%eax
f010d041:	66 a3 3e 48 69 f0    	mov    %ax,0xf069483e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d047:	b8 9c df 10 f0       	mov    $0xf010df9c,%eax
f010d04c:	66 a3 50 48 69 f0    	mov    %ax,0xf0694850
f010d052:	66 c7 05 52 48 69 f0 	movw   $0x8,0xf0694852
f010d059:	08 00 
f010d05b:	a0 54 48 69 f0       	mov    0xf0694854,%al
f010d060:	83 e0 e0             	and    $0xffffffe0,%eax
f010d063:	a2 54 48 69 f0       	mov    %al,0xf0694854
f010d068:	a0 54 48 69 f0       	mov    0xf0694854,%al
f010d06d:	83 e0 1f             	and    $0x1f,%eax
f010d070:	a2 54 48 69 f0       	mov    %al,0xf0694854
f010d075:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d07a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d07d:	83 c8 0e             	or     $0xe,%eax
f010d080:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d085:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d08a:	83 e0 ef             	and    $0xffffffef,%eax
f010d08d:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d092:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d097:	83 c8 60             	or     $0x60,%eax
f010d09a:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d09f:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d0a4:	83 c8 80             	or     $0xffffff80,%eax
f010d0a7:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d0ac:	b8 9c df 10 f0       	mov    $0xf010df9c,%eax
f010d0b1:	c1 e8 10             	shr    $0x10,%eax
f010d0b4:	66 a3 56 48 69 f0    	mov    %ax,0xf0694856
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d0ba:	b8 a0 df 10 f0       	mov    $0xf010dfa0,%eax
f010d0bf:	66 a3 58 48 69 f0    	mov    %ax,0xf0694858
f010d0c5:	66 c7 05 5a 48 69 f0 	movw   $0x8,0xf069485a
f010d0cc:	08 00 
f010d0ce:	a0 5c 48 69 f0       	mov    0xf069485c,%al
f010d0d3:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0d6:	a2 5c 48 69 f0       	mov    %al,0xf069485c
f010d0db:	a0 5c 48 69 f0       	mov    0xf069485c,%al
f010d0e0:	83 e0 1f             	and    $0x1f,%eax
f010d0e3:	a2 5c 48 69 f0       	mov    %al,0xf069485c
f010d0e8:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0ed:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0f0:	83 c8 0e             	or     $0xe,%eax
f010d0f3:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d0f8:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0fd:	83 e0 ef             	and    $0xffffffef,%eax
f010d100:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d105:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d10a:	83 c8 60             	or     $0x60,%eax
f010d10d:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d112:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d117:	83 c8 80             	or     $0xffffff80,%eax
f010d11a:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d11f:	b8 a0 df 10 f0       	mov    $0xf010dfa0,%eax
f010d124:	c1 e8 10             	shr    $0x10,%eax
f010d127:	66 a3 5e 48 69 f0    	mov    %ax,0xf069485e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d12d:	b8 a4 df 10 f0       	mov    $0xf010dfa4,%eax
f010d132:	66 a3 60 48 69 f0    	mov    %ax,0xf0694860
f010d138:	66 c7 05 62 48 69 f0 	movw   $0x8,0xf0694862
f010d13f:	08 00 
f010d141:	a0 64 48 69 f0       	mov    0xf0694864,%al
f010d146:	83 e0 e0             	and    $0xffffffe0,%eax
f010d149:	a2 64 48 69 f0       	mov    %al,0xf0694864
f010d14e:	a0 64 48 69 f0       	mov    0xf0694864,%al
f010d153:	83 e0 1f             	and    $0x1f,%eax
f010d156:	a2 64 48 69 f0       	mov    %al,0xf0694864
f010d15b:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d160:	83 e0 f0             	and    $0xfffffff0,%eax
f010d163:	83 c8 0e             	or     $0xe,%eax
f010d166:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d16b:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d170:	83 e0 ef             	and    $0xffffffef,%eax
f010d173:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d178:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d17d:	83 c8 60             	or     $0x60,%eax
f010d180:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d185:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d18a:	83 c8 80             	or     $0xffffff80,%eax
f010d18d:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d192:	b8 a4 df 10 f0       	mov    $0xf010dfa4,%eax
f010d197:	c1 e8 10             	shr    $0x10,%eax
f010d19a:	66 a3 66 48 69 f0    	mov    %ax,0xf0694866
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d1a0:	b8 a8 df 10 f0       	mov    $0xf010dfa8,%eax
f010d1a5:	66 a3 68 48 69 f0    	mov    %ax,0xf0694868
f010d1ab:	66 c7 05 6a 48 69 f0 	movw   $0x8,0xf069486a
f010d1b2:	08 00 
f010d1b4:	a0 6c 48 69 f0       	mov    0xf069486c,%al
f010d1b9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1bc:	a2 6c 48 69 f0       	mov    %al,0xf069486c
f010d1c1:	a0 6c 48 69 f0       	mov    0xf069486c,%al
f010d1c6:	83 e0 1f             	and    $0x1f,%eax
f010d1c9:	a2 6c 48 69 f0       	mov    %al,0xf069486c
f010d1ce:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1d3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1d6:	83 c8 0e             	or     $0xe,%eax
f010d1d9:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1de:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1e3:	83 e0 ef             	and    $0xffffffef,%eax
f010d1e6:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1eb:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1f0:	83 c8 60             	or     $0x60,%eax
f010d1f3:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1f8:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1fd:	83 c8 80             	or     $0xffffff80,%eax
f010d200:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d205:	b8 a8 df 10 f0       	mov    $0xf010dfa8,%eax
f010d20a:	c1 e8 10             	shr    $0x10,%eax
f010d20d:	66 a3 6e 48 69 f0    	mov    %ax,0xf069486e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d213:	b8 ac df 10 f0       	mov    $0xf010dfac,%eax
f010d218:	66 a3 80 48 69 f0    	mov    %ax,0xf0694880
f010d21e:	66 c7 05 82 48 69 f0 	movw   $0x8,0xf0694882
f010d225:	08 00 
f010d227:	a0 84 48 69 f0       	mov    0xf0694884,%al
f010d22c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d22f:	a2 84 48 69 f0       	mov    %al,0xf0694884
f010d234:	a0 84 48 69 f0       	mov    0xf0694884,%al
f010d239:	83 e0 1f             	and    $0x1f,%eax
f010d23c:	a2 84 48 69 f0       	mov    %al,0xf0694884
f010d241:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d246:	83 e0 f0             	and    $0xfffffff0,%eax
f010d249:	83 c8 0e             	or     $0xe,%eax
f010d24c:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d251:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d256:	83 e0 ef             	and    $0xffffffef,%eax
f010d259:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d25e:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d263:	83 c8 60             	or     $0x60,%eax
f010d266:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d26b:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d270:	83 c8 80             	or     $0xffffff80,%eax
f010d273:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d278:	b8 ac df 10 f0       	mov    $0xf010dfac,%eax
f010d27d:	c1 e8 10             	shr    $0x10,%eax
f010d280:	66 a3 86 48 69 f0    	mov    %ax,0xf0694886
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d286:	b8 b2 df 10 f0       	mov    $0xf010dfb2,%eax
f010d28b:	66 a3 88 48 69 f0    	mov    %ax,0xf0694888
f010d291:	66 c7 05 8a 48 69 f0 	movw   $0x8,0xf069488a
f010d298:	08 00 
f010d29a:	a0 8c 48 69 f0       	mov    0xf069488c,%al
f010d29f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2a2:	a2 8c 48 69 f0       	mov    %al,0xf069488c
f010d2a7:	a0 8c 48 69 f0       	mov    0xf069488c,%al
f010d2ac:	83 e0 1f             	and    $0x1f,%eax
f010d2af:	a2 8c 48 69 f0       	mov    %al,0xf069488c
f010d2b4:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2b9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2bc:	83 c8 0e             	or     $0xe,%eax
f010d2bf:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2c4:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2c9:	83 e0 ef             	and    $0xffffffef,%eax
f010d2cc:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2d1:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2d6:	83 c8 60             	or     $0x60,%eax
f010d2d9:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2de:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2e3:	83 c8 80             	or     $0xffffff80,%eax
f010d2e6:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2eb:	b8 b2 df 10 f0       	mov    $0xf010dfb2,%eax
f010d2f0:	c1 e8 10             	shr    $0x10,%eax
f010d2f3:	66 a3 8e 48 69 f0    	mov    %ax,0xf069488e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d2f9:	b8 b6 df 10 f0       	mov    $0xf010dfb6,%eax
f010d2fe:	66 a3 90 48 69 f0    	mov    %ax,0xf0694890
f010d304:	66 c7 05 92 48 69 f0 	movw   $0x8,0xf0694892
f010d30b:	08 00 
f010d30d:	a0 94 48 69 f0       	mov    0xf0694894,%al
f010d312:	83 e0 e0             	and    $0xffffffe0,%eax
f010d315:	a2 94 48 69 f0       	mov    %al,0xf0694894
f010d31a:	a0 94 48 69 f0       	mov    0xf0694894,%al
f010d31f:	83 e0 1f             	and    $0x1f,%eax
f010d322:	a2 94 48 69 f0       	mov    %al,0xf0694894
f010d327:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d32c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d32f:	83 c8 0e             	or     $0xe,%eax
f010d332:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d337:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d33c:	83 e0 ef             	and    $0xffffffef,%eax
f010d33f:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d344:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d349:	83 c8 60             	or     $0x60,%eax
f010d34c:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d351:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d356:	83 c8 80             	or     $0xffffff80,%eax
f010d359:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d35e:	b8 b6 df 10 f0       	mov    $0xf010dfb6,%eax
f010d363:	c1 e8 10             	shr    $0x10,%eax
f010d366:	66 a3 96 48 69 f0    	mov    %ax,0xf0694896
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d36c:	b8 bc df 10 f0       	mov    $0xf010dfbc,%eax
f010d371:	66 a3 98 48 69 f0    	mov    %ax,0xf0694898
f010d377:	66 c7 05 9a 48 69 f0 	movw   $0x8,0xf069489a
f010d37e:	08 00 
f010d380:	a0 9c 48 69 f0       	mov    0xf069489c,%al
f010d385:	83 e0 e0             	and    $0xffffffe0,%eax
f010d388:	a2 9c 48 69 f0       	mov    %al,0xf069489c
f010d38d:	a0 9c 48 69 f0       	mov    0xf069489c,%al
f010d392:	83 e0 1f             	and    $0x1f,%eax
f010d395:	a2 9c 48 69 f0       	mov    %al,0xf069489c
f010d39a:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d39f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3a2:	83 c8 0e             	or     $0xe,%eax
f010d3a5:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3aa:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d3af:	83 e0 ef             	and    $0xffffffef,%eax
f010d3b2:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3b7:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d3bc:	83 c8 60             	or     $0x60,%eax
f010d3bf:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3c4:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d3c9:	83 c8 80             	or     $0xffffff80,%eax
f010d3cc:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3d1:	b8 bc df 10 f0       	mov    $0xf010dfbc,%eax
f010d3d6:	c1 e8 10             	shr    $0x10,%eax
f010d3d9:	66 a3 9e 48 69 f0    	mov    %ax,0xf069489e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d3df:	b8 c2 df 10 f0       	mov    $0xf010dfc2,%eax
f010d3e4:	66 a3 10 49 69 f0    	mov    %ax,0xf0694910
f010d3ea:	66 c7 05 12 49 69 f0 	movw   $0x8,0xf0694912
f010d3f1:	08 00 
f010d3f3:	a0 14 49 69 f0       	mov    0xf0694914,%al
f010d3f8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3fb:	a2 14 49 69 f0       	mov    %al,0xf0694914
f010d400:	a0 14 49 69 f0       	mov    0xf0694914,%al
f010d405:	83 e0 1f             	and    $0x1f,%eax
f010d408:	a2 14 49 69 f0       	mov    %al,0xf0694914
f010d40d:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d412:	83 e0 f0             	and    $0xfffffff0,%eax
f010d415:	83 c8 0e             	or     $0xe,%eax
f010d418:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d41d:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d422:	83 e0 ef             	and    $0xffffffef,%eax
f010d425:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d42a:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d42f:	83 c8 60             	or     $0x60,%eax
f010d432:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d437:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d43c:	83 c8 80             	or     $0xffffff80,%eax
f010d43f:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d444:	b8 c2 df 10 f0       	mov    $0xf010dfc2,%eax
f010d449:	c1 e8 10             	shr    $0x10,%eax
f010d44c:	66 a3 16 49 69 f0    	mov    %ax,0xf0694916
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010d452:	b8 c8 df 10 f0       	mov    $0xf010dfc8,%eax
f010d457:	66 a3 18 49 69 f0    	mov    %ax,0xf0694918
f010d45d:	66 c7 05 1a 49 69 f0 	movw   $0x8,0xf069491a
f010d464:	08 00 
f010d466:	a0 1c 49 69 f0       	mov    0xf069491c,%al
f010d46b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d46e:	a2 1c 49 69 f0       	mov    %al,0xf069491c
f010d473:	a0 1c 49 69 f0       	mov    0xf069491c,%al
f010d478:	83 e0 1f             	and    $0x1f,%eax
f010d47b:	a2 1c 49 69 f0       	mov    %al,0xf069491c
f010d480:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d485:	83 e0 f0             	and    $0xfffffff0,%eax
f010d488:	83 c8 0e             	or     $0xe,%eax
f010d48b:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d490:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d495:	83 e0 ef             	and    $0xffffffef,%eax
f010d498:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d49d:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d4a2:	83 c8 60             	or     $0x60,%eax
f010d4a5:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d4aa:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d4af:	83 c8 80             	or     $0xffffff80,%eax
f010d4b2:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d4b7:	b8 c8 df 10 f0       	mov    $0xf010dfc8,%eax
f010d4bc:	c1 e8 10             	shr    $0x10,%eax
f010d4bf:	66 a3 1e 49 69 f0    	mov    %ax,0xf069491e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010d4c5:	b8 ce df 10 f0       	mov    $0xf010dfce,%eax
f010d4ca:	66 a3 20 49 69 f0    	mov    %ax,0xf0694920
f010d4d0:	66 c7 05 22 49 69 f0 	movw   $0x8,0xf0694922
f010d4d7:	08 00 
f010d4d9:	a0 24 49 69 f0       	mov    0xf0694924,%al
f010d4de:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4e1:	a2 24 49 69 f0       	mov    %al,0xf0694924
f010d4e6:	a0 24 49 69 f0       	mov    0xf0694924,%al
f010d4eb:	83 e0 1f             	and    $0x1f,%eax
f010d4ee:	a2 24 49 69 f0       	mov    %al,0xf0694924
f010d4f3:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d4f8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4fb:	83 c8 0e             	or     $0xe,%eax
f010d4fe:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d503:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d508:	83 e0 ef             	and    $0xffffffef,%eax
f010d50b:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d510:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d515:	83 c8 60             	or     $0x60,%eax
f010d518:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d51d:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d522:	83 c8 80             	or     $0xffffff80,%eax
f010d525:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d52a:	b8 ce df 10 f0       	mov    $0xf010dfce,%eax
f010d52f:	c1 e8 10             	shr    $0x10,%eax
f010d532:	66 a3 26 49 69 f0    	mov    %ax,0xf0694926
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010d538:	b8 d4 df 10 f0       	mov    $0xf010dfd4,%eax
f010d53d:	66 a3 28 49 69 f0    	mov    %ax,0xf0694928
f010d543:	66 c7 05 2a 49 69 f0 	movw   $0x8,0xf069492a
f010d54a:	08 00 
f010d54c:	a0 2c 49 69 f0       	mov    0xf069492c,%al
f010d551:	83 e0 e0             	and    $0xffffffe0,%eax
f010d554:	a2 2c 49 69 f0       	mov    %al,0xf069492c
f010d559:	a0 2c 49 69 f0       	mov    0xf069492c,%al
f010d55e:	83 e0 1f             	and    $0x1f,%eax
f010d561:	a2 2c 49 69 f0       	mov    %al,0xf069492c
f010d566:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d56b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d56e:	83 c8 0e             	or     $0xe,%eax
f010d571:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d576:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d57b:	83 e0 ef             	and    $0xffffffef,%eax
f010d57e:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d583:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d588:	83 c8 60             	or     $0x60,%eax
f010d58b:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d590:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d595:	83 c8 80             	or     $0xffffff80,%eax
f010d598:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d59d:	b8 d4 df 10 f0       	mov    $0xf010dfd4,%eax
f010d5a2:	c1 e8 10             	shr    $0x10,%eax
f010d5a5:	66 a3 2e 49 69 f0    	mov    %ax,0xf069492e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010d5ab:	b8 da df 10 f0       	mov    $0xf010dfda,%eax
f010d5b0:	66 a3 30 49 69 f0    	mov    %ax,0xf0694930
f010d5b6:	66 c7 05 32 49 69 f0 	movw   $0x8,0xf0694932
f010d5bd:	08 00 
f010d5bf:	a0 34 49 69 f0       	mov    0xf0694934,%al
f010d5c4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5c7:	a2 34 49 69 f0       	mov    %al,0xf0694934
f010d5cc:	a0 34 49 69 f0       	mov    0xf0694934,%al
f010d5d1:	83 e0 1f             	and    $0x1f,%eax
f010d5d4:	a2 34 49 69 f0       	mov    %al,0xf0694934
f010d5d9:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5de:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5e1:	83 c8 0e             	or     $0xe,%eax
f010d5e4:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5e9:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5ee:	83 e0 ef             	and    $0xffffffef,%eax
f010d5f1:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5f6:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5fb:	83 c8 60             	or     $0x60,%eax
f010d5fe:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d603:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d608:	83 c8 80             	or     $0xffffff80,%eax
f010d60b:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d610:	b8 da df 10 f0       	mov    $0xf010dfda,%eax
f010d615:	c1 e8 10             	shr    $0x10,%eax
f010d618:	66 a3 36 49 69 f0    	mov    %ax,0xf0694936
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010d61e:	b8 e0 df 10 f0       	mov    $0xf010dfe0,%eax
f010d623:	66 a3 38 49 69 f0    	mov    %ax,0xf0694938
f010d629:	66 c7 05 3a 49 69 f0 	movw   $0x8,0xf069493a
f010d630:	08 00 
f010d632:	a0 3c 49 69 f0       	mov    0xf069493c,%al
f010d637:	83 e0 e0             	and    $0xffffffe0,%eax
f010d63a:	a2 3c 49 69 f0       	mov    %al,0xf069493c
f010d63f:	a0 3c 49 69 f0       	mov    0xf069493c,%al
f010d644:	83 e0 1f             	and    $0x1f,%eax
f010d647:	a2 3c 49 69 f0       	mov    %al,0xf069493c
f010d64c:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d651:	83 e0 f0             	and    $0xfffffff0,%eax
f010d654:	83 c8 0e             	or     $0xe,%eax
f010d657:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d65c:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d661:	83 e0 ef             	and    $0xffffffef,%eax
f010d664:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d669:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d66e:	83 c8 60             	or     $0x60,%eax
f010d671:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d676:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d67b:	83 c8 80             	or     $0xffffff80,%eax
f010d67e:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d683:	b8 e0 df 10 f0       	mov    $0xf010dfe0,%eax
f010d688:	c1 e8 10             	shr    $0x10,%eax
f010d68b:	66 a3 3e 49 69 f0    	mov    %ax,0xf069493e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010d691:	b8 e6 df 10 f0       	mov    $0xf010dfe6,%eax
f010d696:	66 a3 40 49 69 f0    	mov    %ax,0xf0694940
f010d69c:	66 c7 05 42 49 69 f0 	movw   $0x8,0xf0694942
f010d6a3:	08 00 
f010d6a5:	a0 44 49 69 f0       	mov    0xf0694944,%al
f010d6aa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6ad:	a2 44 49 69 f0       	mov    %al,0xf0694944
f010d6b2:	a0 44 49 69 f0       	mov    0xf0694944,%al
f010d6b7:	83 e0 1f             	and    $0x1f,%eax
f010d6ba:	a2 44 49 69 f0       	mov    %al,0xf0694944
f010d6bf:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6c4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6c7:	83 c8 0e             	or     $0xe,%eax
f010d6ca:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6cf:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6d4:	83 e0 ef             	and    $0xffffffef,%eax
f010d6d7:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6dc:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6e1:	83 c8 60             	or     $0x60,%eax
f010d6e4:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6e9:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6ee:	83 c8 80             	or     $0xffffff80,%eax
f010d6f1:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6f6:	b8 e6 df 10 f0       	mov    $0xf010dfe6,%eax
f010d6fb:	c1 e8 10             	shr    $0x10,%eax
f010d6fe:	66 a3 46 49 69 f0    	mov    %ax,0xf0694946
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010d704:	b8 ec df 10 f0       	mov    $0xf010dfec,%eax
f010d709:	66 a3 48 49 69 f0    	mov    %ax,0xf0694948
f010d70f:	66 c7 05 4a 49 69 f0 	movw   $0x8,0xf069494a
f010d716:	08 00 
f010d718:	a0 4c 49 69 f0       	mov    0xf069494c,%al
f010d71d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d720:	a2 4c 49 69 f0       	mov    %al,0xf069494c
f010d725:	a0 4c 49 69 f0       	mov    0xf069494c,%al
f010d72a:	83 e0 1f             	and    $0x1f,%eax
f010d72d:	a2 4c 49 69 f0       	mov    %al,0xf069494c
f010d732:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d737:	83 e0 f0             	and    $0xfffffff0,%eax
f010d73a:	83 c8 0e             	or     $0xe,%eax
f010d73d:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d742:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d747:	83 e0 ef             	and    $0xffffffef,%eax
f010d74a:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d74f:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d754:	83 c8 60             	or     $0x60,%eax
f010d757:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d75c:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d761:	83 c8 80             	or     $0xffffff80,%eax
f010d764:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d769:	b8 ec df 10 f0       	mov    $0xf010dfec,%eax
f010d76e:	c1 e8 10             	shr    $0x10,%eax
f010d771:	66 a3 4e 49 69 f0    	mov    %ax,0xf069494e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010d777:	b8 f2 df 10 f0       	mov    $0xf010dff2,%eax
f010d77c:	66 a3 50 49 69 f0    	mov    %ax,0xf0694950
f010d782:	66 c7 05 52 49 69 f0 	movw   $0x8,0xf0694952
f010d789:	08 00 
f010d78b:	a0 54 49 69 f0       	mov    0xf0694954,%al
f010d790:	83 e0 e0             	and    $0xffffffe0,%eax
f010d793:	a2 54 49 69 f0       	mov    %al,0xf0694954
f010d798:	a0 54 49 69 f0       	mov    0xf0694954,%al
f010d79d:	83 e0 1f             	and    $0x1f,%eax
f010d7a0:	a2 54 49 69 f0       	mov    %al,0xf0694954
f010d7a5:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7aa:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7ad:	83 c8 0e             	or     $0xe,%eax
f010d7b0:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7b5:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7ba:	83 e0 ef             	and    $0xffffffef,%eax
f010d7bd:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7c2:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7c7:	83 c8 60             	or     $0x60,%eax
f010d7ca:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7cf:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7d4:	83 c8 80             	or     $0xffffff80,%eax
f010d7d7:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7dc:	b8 f2 df 10 f0       	mov    $0xf010dff2,%eax
f010d7e1:	c1 e8 10             	shr    $0x10,%eax
f010d7e4:	66 a3 56 49 69 f0    	mov    %ax,0xf0694956
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010d7ea:	b8 f8 df 10 f0       	mov    $0xf010dff8,%eax
f010d7ef:	66 a3 58 49 69 f0    	mov    %ax,0xf0694958
f010d7f5:	66 c7 05 5a 49 69 f0 	movw   $0x8,0xf069495a
f010d7fc:	08 00 
f010d7fe:	a0 5c 49 69 f0       	mov    0xf069495c,%al
f010d803:	83 e0 e0             	and    $0xffffffe0,%eax
f010d806:	a2 5c 49 69 f0       	mov    %al,0xf069495c
f010d80b:	a0 5c 49 69 f0       	mov    0xf069495c,%al
f010d810:	83 e0 1f             	and    $0x1f,%eax
f010d813:	a2 5c 49 69 f0       	mov    %al,0xf069495c
f010d818:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d81d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d820:	83 c8 0e             	or     $0xe,%eax
f010d823:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d828:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d82d:	83 e0 ef             	and    $0xffffffef,%eax
f010d830:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d835:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d83a:	83 c8 60             	or     $0x60,%eax
f010d83d:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d842:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d847:	83 c8 80             	or     $0xffffff80,%eax
f010d84a:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d84f:	b8 f8 df 10 f0       	mov    $0xf010dff8,%eax
f010d854:	c1 e8 10             	shr    $0x10,%eax
f010d857:	66 a3 5e 49 69 f0    	mov    %ax,0xf069495e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010d85d:	b8 fe df 10 f0       	mov    $0xf010dffe,%eax
f010d862:	66 a3 60 49 69 f0    	mov    %ax,0xf0694960
f010d868:	66 c7 05 62 49 69 f0 	movw   $0x8,0xf0694962
f010d86f:	08 00 
f010d871:	a0 64 49 69 f0       	mov    0xf0694964,%al
f010d876:	83 e0 e0             	and    $0xffffffe0,%eax
f010d879:	a2 64 49 69 f0       	mov    %al,0xf0694964
f010d87e:	a0 64 49 69 f0       	mov    0xf0694964,%al
f010d883:	83 e0 1f             	and    $0x1f,%eax
f010d886:	a2 64 49 69 f0       	mov    %al,0xf0694964
f010d88b:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d890:	83 e0 f0             	and    $0xfffffff0,%eax
f010d893:	83 c8 0e             	or     $0xe,%eax
f010d896:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d89b:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d8a0:	83 e0 ef             	and    $0xffffffef,%eax
f010d8a3:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d8a8:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d8ad:	83 c8 60             	or     $0x60,%eax
f010d8b0:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d8b5:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d8ba:	83 c8 80             	or     $0xffffff80,%eax
f010d8bd:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d8c2:	b8 fe df 10 f0       	mov    $0xf010dffe,%eax
f010d8c7:	c1 e8 10             	shr    $0x10,%eax
f010d8ca:	66 a3 66 49 69 f0    	mov    %ax,0xf0694966
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d8d0:	b8 04 e0 10 f0       	mov    $0xf010e004,%eax
f010d8d5:	66 a3 68 49 69 f0    	mov    %ax,0xf0694968
f010d8db:	66 c7 05 6a 49 69 f0 	movw   $0x8,0xf069496a
f010d8e2:	08 00 
f010d8e4:	a0 6c 49 69 f0       	mov    0xf069496c,%al
f010d8e9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8ec:	a2 6c 49 69 f0       	mov    %al,0xf069496c
f010d8f1:	a0 6c 49 69 f0       	mov    0xf069496c,%al
f010d8f6:	83 e0 1f             	and    $0x1f,%eax
f010d8f9:	a2 6c 49 69 f0       	mov    %al,0xf069496c
f010d8fe:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d903:	83 e0 f0             	and    $0xfffffff0,%eax
f010d906:	83 c8 0e             	or     $0xe,%eax
f010d909:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d90e:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d913:	83 e0 ef             	and    $0xffffffef,%eax
f010d916:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d91b:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d920:	83 c8 60             	or     $0x60,%eax
f010d923:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d928:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d92d:	83 c8 80             	or     $0xffffff80,%eax
f010d930:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d935:	b8 04 e0 10 f0       	mov    $0xf010e004,%eax
f010d93a:	c1 e8 10             	shr    $0x10,%eax
f010d93d:	66 a3 6e 49 69 f0    	mov    %ax,0xf069496e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d943:	b8 0a e0 10 f0       	mov    $0xf010e00a,%eax
f010d948:	66 a3 70 49 69 f0    	mov    %ax,0xf0694970
f010d94e:	66 c7 05 72 49 69 f0 	movw   $0x8,0xf0694972
f010d955:	08 00 
f010d957:	a0 74 49 69 f0       	mov    0xf0694974,%al
f010d95c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d95f:	a2 74 49 69 f0       	mov    %al,0xf0694974
f010d964:	a0 74 49 69 f0       	mov    0xf0694974,%al
f010d969:	83 e0 1f             	and    $0x1f,%eax
f010d96c:	a2 74 49 69 f0       	mov    %al,0xf0694974
f010d971:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d976:	83 e0 f0             	and    $0xfffffff0,%eax
f010d979:	83 c8 0e             	or     $0xe,%eax
f010d97c:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d981:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d986:	83 e0 ef             	and    $0xffffffef,%eax
f010d989:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d98e:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d993:	83 c8 60             	or     $0x60,%eax
f010d996:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d99b:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d9a0:	83 c8 80             	or     $0xffffff80,%eax
f010d9a3:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d9a8:	b8 0a e0 10 f0       	mov    $0xf010e00a,%eax
f010d9ad:	c1 e8 10             	shr    $0x10,%eax
f010d9b0:	66 a3 76 49 69 f0    	mov    %ax,0xf0694976
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d9b6:	b8 10 e0 10 f0       	mov    $0xf010e010,%eax
f010d9bb:	66 a3 78 49 69 f0    	mov    %ax,0xf0694978
f010d9c1:	66 c7 05 7a 49 69 f0 	movw   $0x8,0xf069497a
f010d9c8:	08 00 
f010d9ca:	a0 7c 49 69 f0       	mov    0xf069497c,%al
f010d9cf:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9d2:	a2 7c 49 69 f0       	mov    %al,0xf069497c
f010d9d7:	a0 7c 49 69 f0       	mov    0xf069497c,%al
f010d9dc:	83 e0 1f             	and    $0x1f,%eax
f010d9df:	a2 7c 49 69 f0       	mov    %al,0xf069497c
f010d9e4:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9e9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9ec:	83 c8 0e             	or     $0xe,%eax
f010d9ef:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010d9f4:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9f9:	83 e0 ef             	and    $0xffffffef,%eax
f010d9fc:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010da01:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010da06:	83 c8 60             	or     $0x60,%eax
f010da09:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010da0e:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010da13:	83 c8 80             	or     $0xffffff80,%eax
f010da16:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010da1b:	b8 10 e0 10 f0       	mov    $0xf010e010,%eax
f010da20:	c1 e8 10             	shr    $0x10,%eax
f010da23:	66 a3 7e 49 69 f0    	mov    %ax,0xf069497e
f010da29:	c7 45 fc 00 48 69 f0 	movl   $0xf0694800,-0x4(%ebp)
f010da30:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010da37:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010da3a:	48                   	dec    %eax
f010da3b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010da3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010da42:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010da46:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010da49:	c1 e8 10             	shr    $0x10,%eax
f010da4c:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010da50:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010da53:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010da56:	90                   	nop
f010da57:	c9                   	leave  
f010da58:	c3                   	ret    

f010da59 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010da59:	55                   	push   %ebp
f010da5a:	89 e5                	mov    %esp,%ebp
f010da5c:	53                   	push   %ebx
f010da5d:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010da60:	83 ec 08             	sub    $0x8,%esp
f010da63:	ff 75 08             	pushl  0x8(%ebp)
f010da66:	68 be 6c 12 f0       	push   $0xf0126cbe
f010da6b:	e8 1b 35 ff ff       	call   f0100f8b <cprintf>
f010da70:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010da73:	8b 45 08             	mov    0x8(%ebp),%eax
f010da76:	83 ec 0c             	sub    $0xc,%esp
f010da79:	50                   	push   %eax
f010da7a:	e8 fd 00 00 00       	call   f010db7c <print_regs>
f010da7f:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010da82:	8b 45 08             	mov    0x8(%ebp),%eax
f010da85:	8b 40 20             	mov    0x20(%eax),%eax
f010da88:	0f b7 c0             	movzwl %ax,%eax
f010da8b:	83 ec 08             	sub    $0x8,%esp
f010da8e:	50                   	push   %eax
f010da8f:	68 d0 6c 12 f0       	push   $0xf0126cd0
f010da94:	e8 f2 34 ff ff       	call   f0100f8b <cprintf>
f010da99:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010da9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010da9f:	8b 40 24             	mov    0x24(%eax),%eax
f010daa2:	0f b7 c0             	movzwl %ax,%eax
f010daa5:	83 ec 08             	sub    $0x8,%esp
f010daa8:	50                   	push   %eax
f010daa9:	68 e3 6c 12 f0       	push   $0xf0126ce3
f010daae:	e8 d8 34 ff ff       	call   f0100f8b <cprintf>
f010dab3:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010dab6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dab9:	8b 58 28             	mov    0x28(%eax),%ebx
f010dabc:	8b 45 08             	mov    0x8(%ebp),%eax
f010dabf:	8b 40 28             	mov    0x28(%eax),%eax
f010dac2:	83 ec 0c             	sub    $0xc,%esp
f010dac5:	50                   	push   %eax
f010dac6:	e8 28 ee ff ff       	call   f010c8f3 <trapname>
f010dacb:	83 c4 10             	add    $0x10,%esp
f010dace:	89 c2                	mov    %eax,%edx
f010dad0:	8b 45 08             	mov    0x8(%ebp),%eax
f010dad3:	8b 40 28             	mov    0x28(%eax),%eax
f010dad6:	53                   	push   %ebx
f010dad7:	52                   	push   %edx
f010dad8:	50                   	push   %eax
f010dad9:	68 f6 6c 12 f0       	push   $0xf0126cf6
f010dade:	e8 a8 34 ff ff       	call   f0100f8b <cprintf>
f010dae3:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010dae6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dae9:	8b 40 2c             	mov    0x2c(%eax),%eax
f010daec:	83 ec 08             	sub    $0x8,%esp
f010daef:	50                   	push   %eax
f010daf0:	68 0d 6d 12 f0       	push   $0xf0126d0d
f010daf5:	e8 91 34 ff ff       	call   f0100f8b <cprintf>
f010dafa:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010dafd:	8b 45 08             	mov    0x8(%ebp),%eax
f010db00:	8b 40 30             	mov    0x30(%eax),%eax
f010db03:	83 ec 08             	sub    $0x8,%esp
f010db06:	50                   	push   %eax
f010db07:	68 1c 6d 12 f0       	push   $0xf0126d1c
f010db0c:	e8 7a 34 ff ff       	call   f0100f8b <cprintf>
f010db11:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010db14:	8b 45 08             	mov    0x8(%ebp),%eax
f010db17:	8b 40 34             	mov    0x34(%eax),%eax
f010db1a:	0f b7 c0             	movzwl %ax,%eax
f010db1d:	83 ec 08             	sub    $0x8,%esp
f010db20:	50                   	push   %eax
f010db21:	68 2b 6d 12 f0       	push   $0xf0126d2b
f010db26:	e8 60 34 ff ff       	call   f0100f8b <cprintf>
f010db2b:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010db2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010db31:	8b 40 38             	mov    0x38(%eax),%eax
f010db34:	83 ec 08             	sub    $0x8,%esp
f010db37:	50                   	push   %eax
f010db38:	68 3e 6d 12 f0       	push   $0xf0126d3e
f010db3d:	e8 49 34 ff ff       	call   f0100f8b <cprintf>
f010db42:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010db45:	8b 45 08             	mov    0x8(%ebp),%eax
f010db48:	8b 40 3c             	mov    0x3c(%eax),%eax
f010db4b:	83 ec 08             	sub    $0x8,%esp
f010db4e:	50                   	push   %eax
f010db4f:	68 4d 6d 12 f0       	push   $0xf0126d4d
f010db54:	e8 32 34 ff ff       	call   f0100f8b <cprintf>
f010db59:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010db5c:	8b 45 08             	mov    0x8(%ebp),%eax
f010db5f:	8b 40 40             	mov    0x40(%eax),%eax
f010db62:	0f b7 c0             	movzwl %ax,%eax
f010db65:	83 ec 08             	sub    $0x8,%esp
f010db68:	50                   	push   %eax
f010db69:	68 5c 6d 12 f0       	push   $0xf0126d5c
f010db6e:	e8 18 34 ff ff       	call   f0100f8b <cprintf>
f010db73:	83 c4 10             	add    $0x10,%esp
}
f010db76:	90                   	nop
f010db77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010db7a:	c9                   	leave  
f010db7b:	c3                   	ret    

f010db7c <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010db7c:	55                   	push   %ebp
f010db7d:	89 e5                	mov    %esp,%ebp
f010db7f:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010db82:	8b 45 08             	mov    0x8(%ebp),%eax
f010db85:	8b 00                	mov    (%eax),%eax
f010db87:	83 ec 08             	sub    $0x8,%esp
f010db8a:	50                   	push   %eax
f010db8b:	68 6f 6d 12 f0       	push   $0xf0126d6f
f010db90:	e8 f6 33 ff ff       	call   f0100f8b <cprintf>
f010db95:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010db98:	8b 45 08             	mov    0x8(%ebp),%eax
f010db9b:	8b 40 04             	mov    0x4(%eax),%eax
f010db9e:	83 ec 08             	sub    $0x8,%esp
f010dba1:	50                   	push   %eax
f010dba2:	68 7e 6d 12 f0       	push   $0xf0126d7e
f010dba7:	e8 df 33 ff ff       	call   f0100f8b <cprintf>
f010dbac:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010dbaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbb2:	8b 40 08             	mov    0x8(%eax),%eax
f010dbb5:	83 ec 08             	sub    $0x8,%esp
f010dbb8:	50                   	push   %eax
f010dbb9:	68 8d 6d 12 f0       	push   $0xf0126d8d
f010dbbe:	e8 c8 33 ff ff       	call   f0100f8b <cprintf>
f010dbc3:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010dbc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbc9:	8b 40 0c             	mov    0xc(%eax),%eax
f010dbcc:	83 ec 08             	sub    $0x8,%esp
f010dbcf:	50                   	push   %eax
f010dbd0:	68 9c 6d 12 f0       	push   $0xf0126d9c
f010dbd5:	e8 b1 33 ff ff       	call   f0100f8b <cprintf>
f010dbda:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010dbdd:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbe0:	8b 40 10             	mov    0x10(%eax),%eax
f010dbe3:	83 ec 08             	sub    $0x8,%esp
f010dbe6:	50                   	push   %eax
f010dbe7:	68 ab 6d 12 f0       	push   $0xf0126dab
f010dbec:	e8 9a 33 ff ff       	call   f0100f8b <cprintf>
f010dbf1:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010dbf4:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbf7:	8b 40 14             	mov    0x14(%eax),%eax
f010dbfa:	83 ec 08             	sub    $0x8,%esp
f010dbfd:	50                   	push   %eax
f010dbfe:	68 ba 6d 12 f0       	push   $0xf0126dba
f010dc03:	e8 83 33 ff ff       	call   f0100f8b <cprintf>
f010dc08:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010dc0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc0e:	8b 40 18             	mov    0x18(%eax),%eax
f010dc11:	83 ec 08             	sub    $0x8,%esp
f010dc14:	50                   	push   %eax
f010dc15:	68 c9 6d 12 f0       	push   $0xf0126dc9
f010dc1a:	e8 6c 33 ff ff       	call   f0100f8b <cprintf>
f010dc1f:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010dc22:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc25:	8b 40 1c             	mov    0x1c(%eax),%eax
f010dc28:	83 ec 08             	sub    $0x8,%esp
f010dc2b:	50                   	push   %eax
f010dc2c:	68 d8 6d 12 f0       	push   $0xf0126dd8
f010dc31:	e8 55 33 ff ff       	call   f0100f8b <cprintf>
f010dc36:	83 c4 10             	add    $0x10,%esp
}
f010dc39:	90                   	nop
f010dc3a:	c9                   	leave  
f010dc3b:	c3                   	ret    

f010dc3c <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010dc3c:	55                   	push   %ebp
f010dc3d:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010dc3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc42:	8b 55 0c             	mov    0xc(%ebp),%edx
f010dc45:	89 14 85 00 50 69 f0 	mov    %edx,-0xf96b000(,%eax,4)
}
f010dc4c:	90                   	nop
f010dc4d:	5d                   	pop    %ebp
f010dc4e:	c3                   	ret    

f010dc4f <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010dc4f:	55                   	push   %ebp
f010dc50:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010dc52:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc55:	c7 04 85 00 50 69 f0 	movl   $0x0,-0xf96b000(,%eax,4)
f010dc5c:	00 00 00 00 
}
f010dc60:	90                   	nop
f010dc61:	5d                   	pop    %ebp
f010dc62:	c3                   	ret    

f010dc63 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010dc63:	55                   	push   %ebp
f010dc64:	89 e5                	mov    %esp,%ebp
f010dc66:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010dc69:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc6c:	8b 40 28             	mov    0x28(%eax),%eax
f010dc6f:	83 e8 20             	sub    $0x20,%eax
f010dc72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010dc75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dc78:	8b 04 85 00 50 69 f0 	mov    -0xf96b000(,%eax,4),%eax
f010dc7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010dc82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010dc86:	74 0e                	je     f010dc96 <irq_dispatch+0x33>
	{
		handler(tf);
f010dc88:	83 ec 0c             	sub    $0xc,%esp
f010dc8b:	ff 75 08             	pushl  0x8(%ebp)
f010dc8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dc91:	ff d0                	call   *%eax
f010dc93:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010dc96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dc99:	0f b6 c0             	movzbl %al,%eax
f010dc9c:	83 ec 0c             	sub    $0xc,%esp
f010dc9f:	50                   	push   %eax
f010dca0:	e8 2e 94 ff ff       	call   f01070d3 <pic_sendEOI>
f010dca5:	83 c4 10             	add    $0x10,%esp
}
f010dca8:	90                   	nop
f010dca9:	c9                   	leave  
f010dcaa:	c3                   	ret    

f010dcab <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010dcab:	55                   	push   %ebp
f010dcac:	89 e5                	mov    %esp,%ebp
f010dcae:	57                   	push   %edi
f010dcaf:	56                   	push   %esi
f010dcb0:	53                   	push   %ebx
f010dcb1:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010dcb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcb7:	8b 40 28             	mov    0x28(%eax),%eax
f010dcba:	83 f8 0e             	cmp    $0xe,%eax
f010dcbd:	75 51                	jne    f010dd10 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010dcbf:	a0 40 50 69 f0       	mov    0xf0695040,%al
f010dcc4:	84 c0                	test   %al,%al
f010dcc6:	74 1f                	je     f010dce7 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010dcc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010dccb:	8b 40 30             	mov    0x30(%eax),%eax
f010dcce:	89 c2                	mov    %eax,%edx
f010dcd0:	a0 40 50 69 f0       	mov    0xf0695040,%al
f010dcd5:	0f b6 c0             	movzbl %al,%eax
f010dcd8:	01 d0                	add    %edx,%eax
f010dcda:	89 c2                	mov    %eax,%edx
f010dcdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcdf:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010dce2:	e9 0c 01 00 00       	jmp    f010ddf3 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010dce7:	83 ec 0c             	sub    $0xc,%esp
f010dcea:	6a 01                	push   $0x1
f010dcec:	e8 ee 12 00 00       	call   f010efdf <isPageReplacmentAlgorithmLRU>
f010dcf1:	83 c4 10             	add    $0x10,%esp
f010dcf4:	85 c0                	test   %eax,%eax
f010dcf6:	74 05                	je     f010dcfd <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010dcf8:	e8 45 8f ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010dcfd:	83 ec 0c             	sub    $0xc,%esp
f010dd00:	ff 75 08             	pushl  0x8(%ebp)
f010dd03:	e8 bc 13 00 00       	call   f010f0c4 <fault_handler>
f010dd08:	83 c4 10             	add    $0x10,%esp
f010dd0b:	e9 e3 00 00 00       	jmp    f010ddf3 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010dd10:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd13:	8b 40 28             	mov    0x28(%eax),%eax
f010dd16:	83 f8 30             	cmp    $0x30,%eax
f010dd19:	75 6e                	jne    f010dd89 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010dd1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd1e:	8b 40 38             	mov    0x38(%eax),%eax
f010dd21:	25 00 02 00 00       	and    $0x200,%eax
f010dd26:	85 c0                	test   %eax,%eax
f010dd28:	74 06                	je     f010dd30 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010dd2a:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010dd2b:	e8 b2 6f ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010dd30:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd33:	8b 78 04             	mov    0x4(%eax),%edi
f010dd36:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd39:	8b 30                	mov    (%eax),%esi
f010dd3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd3e:	8b 58 10             	mov    0x10(%eax),%ebx
f010dd41:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd44:	8b 48 18             	mov    0x18(%eax),%ecx
f010dd47:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd4a:	8b 50 14             	mov    0x14(%eax),%edx
f010dd4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd50:	8b 40 1c             	mov    0x1c(%eax),%eax
f010dd53:	83 ec 08             	sub    $0x8,%esp
f010dd56:	57                   	push   %edi
f010dd57:	56                   	push   %esi
f010dd58:	53                   	push   %ebx
f010dd59:	51                   	push   %ecx
f010dd5a:	52                   	push   %edx
f010dd5b:	50                   	push   %eax
f010dd5c:	e8 a5 09 00 00       	call   f010e706 <syscall>
f010dd61:	83 c4 20             	add    $0x20,%esp
f010dd64:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010dd67:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd6a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010dd6d:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010dd70:	9c                   	pushf  
f010dd71:	58                   	pop    %eax
f010dd72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010dd75:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010dd78:	25 00 02 00 00       	and    $0x200,%eax
f010dd7d:	85 c0                	test   %eax,%eax
f010dd7f:	74 72                	je     f010ddf3 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010dd81:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010dd82:	e8 33 6f ff ff       	call   f0104cba <kclock_stop>
f010dd87:	eb 6a                	jmp    f010ddf3 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010dd89:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd8c:	8b 40 28             	mov    0x28(%eax),%eax
f010dd8f:	83 f8 08             	cmp    $0x8,%eax
f010dd92:	75 17                	jne    f010ddab <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010dd94:	83 ec 04             	sub    $0x4,%esp
f010dd97:	68 e7 6d 12 f0       	push   $0xf0126de7
f010dd9c:	68 22 01 00 00       	push   $0x122
f010dda1:	68 f6 6d 12 f0       	push   $0xf0126df6
f010dda6:	e8 8e 25 ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010ddab:	83 ec 0c             	sub    $0xc,%esp
f010ddae:	ff 75 08             	pushl  0x8(%ebp)
f010ddb1:	e8 a3 fc ff ff       	call   f010da59 <print_trapframe>
f010ddb6:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010ddb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddbc:	8b 40 34             	mov    0x34(%eax),%eax
f010ddbf:	66 83 f8 08          	cmp    $0x8,%ax
f010ddc3:	75 17                	jne    f010dddc <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010ddc5:	83 ec 04             	sub    $0x4,%esp
f010ddc8:	68 07 6e 12 f0       	push   $0xf0126e07
f010ddcd:	68 2a 01 00 00       	push   $0x12a
f010ddd2:	68 f6 6d 12 f0       	push   $0xf0126df6
f010ddd7:	e8 5d 25 ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010dddc:	83 ec 04             	sub    $0x4,%esp
f010dddf:	68 20 6e 12 f0       	push   $0xf0126e20
f010dde4:	68 2f 01 00 00       	push   $0x12f
f010dde9:	68 f6 6d 12 f0       	push   $0xf0126df6
f010ddee:	e8 46 25 ff ff       	call   f0100339 <_panic>
		}
	}
}
f010ddf3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ddf6:	5b                   	pop    %ebx
f010ddf7:	5e                   	pop    %esi
f010ddf8:	5f                   	pop    %edi
f010ddf9:	5d                   	pop    %ebp
f010ddfa:	c3                   	ret    

f010ddfb <trap>:

void trap(struct Trapframe *tf)
{
f010ddfb:	55                   	push   %ebp
f010ddfc:	89 e5                	mov    %esp,%ebp
f010ddfe:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010de01:	e8 b4 6e ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010de06:	9c                   	pushf  
f010de07:	58                   	pop    %eax
f010de08:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010de0b:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010de0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010de11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010de14:	25 00 02 00 00       	and    $0x200,%eax
f010de19:	85 c0                	test   %eax,%eax
f010de1b:	74 25                	je     f010de42 <trap+0x47>
	{
		print_trapframe(tf);
f010de1d:	83 ec 0c             	sub    $0xc,%esp
f010de20:	ff 75 08             	pushl  0x8(%ebp)
f010de23:	e8 31 fc ff ff       	call   f010da59 <print_trapframe>
f010de28:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010de2b:	83 ec 04             	sub    $0x4,%esp
f010de2e:	68 40 6e 12 f0       	push   $0xf0126e40
f010de33:	68 45 01 00 00       	push   $0x145
f010de38:	68 f6 6d 12 f0       	push   $0xf0126df6
f010de3d:	e8 f7 24 ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010de42:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010de49:	e8 55 d5 ff ff       	call   f010b3a3 <get_cpu_proc>
f010de4e:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010de51:	8b 45 08             	mov    0x8(%ebp),%eax
f010de54:	8b 40 34             	mov    0x34(%eax),%eax
f010de57:	0f b7 c0             	movzwl %ax,%eax
f010de5a:	83 e0 03             	and    $0x3,%eax
f010de5d:	83 f8 03             	cmp    $0x3,%eax
f010de60:	75 54                	jne    f010deb6 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010de62:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010de66:	74 0b                	je     f010de73 <trap+0x78>
f010de68:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010de6b:	8b 40 18             	mov    0x18(%eax),%eax
f010de6e:	83 f8 02             	cmp    $0x2,%eax
f010de71:	74 19                	je     f010de8c <trap+0x91>
f010de73:	68 84 6e 12 f0       	push   $0xf0126e84
f010de78:	68 b2 6e 12 f0       	push   $0xf0126eb2
f010de7d:	68 4d 01 00 00       	push   $0x14d
f010de82:	68 f6 6d 12 f0       	push   $0xf0126df6
f010de87:	e8 ad 24 ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010de8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010de8f:	8b 00                	mov    (%eax),%eax
f010de91:	3b 45 08             	cmp    0x8(%ebp),%eax
f010de94:	74 19                	je     f010deaf <trap+0xb4>
f010de96:	68 c7 6e 12 f0       	push   $0xf0126ec7
f010de9b:	68 b2 6e 12 f0       	push   $0xf0126eb2
f010dea0:	68 4f 01 00 00       	push   $0x14f
f010dea5:	68 f6 6d 12 f0       	push   $0xf0126df6
f010deaa:	e8 8a 24 ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010deaf:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010deb6:	8b 45 08             	mov    0x8(%ebp),%eax
f010deb9:	8b 40 28             	mov    0x28(%eax),%eax
f010debc:	83 f8 1f             	cmp    $0x1f,%eax
f010debf:	76 1b                	jbe    f010dedc <trap+0xe1>
f010dec1:	8b 45 08             	mov    0x8(%ebp),%eax
f010dec4:	8b 40 28             	mov    0x28(%eax),%eax
f010dec7:	83 f8 2f             	cmp    $0x2f,%eax
f010deca:	77 10                	ja     f010dedc <trap+0xe1>
	{
		irq_dispatch(tf);
f010decc:	83 ec 0c             	sub    $0xc,%esp
f010decf:	ff 75 08             	pushl  0x8(%ebp)
f010ded2:	e8 8c fd ff ff       	call   f010dc63 <irq_dispatch>
f010ded7:	83 c4 10             	add    $0x10,%esp
f010deda:	eb 0e                	jmp    f010deea <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010dedc:	83 ec 0c             	sub    $0xc,%esp
f010dedf:	ff 75 08             	pushl  0x8(%ebp)
f010dee2:	e8 c4 fd ff ff       	call   f010dcab <trap_dispatch>
f010dee7:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010deea:	9c                   	pushf  
f010deeb:	58                   	pop    %eax
f010deec:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010deef:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010def2:	25 00 02 00 00       	and    $0x200,%eax
f010def7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010defa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010defe:	74 19                	je     f010df19 <trap+0x11e>
f010df00:	68 dd 6e 12 f0       	push   $0xf0126edd
f010df05:	68 b2 6e 12 f0       	push   $0xf0126eb2
f010df0a:	68 66 01 00 00       	push   $0x166
f010df0f:	68 f6 6d 12 f0       	push   $0xf0126df6
f010df14:	e8 20 24 ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010df19:	e8 c4 6d ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010df1e:	90                   	nop
f010df1f:	c9                   	leave  
f010df20:	c3                   	ret    
f010df21:	90                   	nop

f010df22 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010df22:	6a 08                	push   $0x8
f010df24:	e9 ed 00 00 00       	jmp    f010e016 <_alltraps>
f010df29:	90                   	nop

f010df2a <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010df2a:	6a 0e                	push   $0xe
f010df2c:	e9 e5 00 00 00       	jmp    f010e016 <_alltraps>
f010df31:	90                   	nop

f010df32 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010df32:	6a 00                	push   $0x0
f010df34:	6a 20                	push   $0x20
f010df36:	e9 db 00 00 00       	jmp    f010e016 <_alltraps>
f010df3b:	90                   	nop

f010df3c <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010df3c:	6a 00                	push   $0x0
f010df3e:	6a 21                	push   $0x21
f010df40:	e9 d1 00 00 00       	jmp    f010e016 <_alltraps>
f010df45:	90                   	nop

f010df46 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010df46:	6a 00                	push   $0x0
f010df48:	6a 30                	push   $0x30
f010df4a:	e9 c7 00 00 00       	jmp    f010e016 <_alltraps>
f010df4f:	90                   	nop

f010df50 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010df50:	6a 00                	push   $0x0
f010df52:	6a 00                	push   $0x0
f010df54:	e9 bd 00 00 00       	jmp    f010e016 <_alltraps>
f010df59:	90                   	nop

f010df5a <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010df5a:	6a 00                	push   $0x0
f010df5c:	6a 01                	push   $0x1
f010df5e:	e9 b3 00 00 00       	jmp    f010e016 <_alltraps>
f010df63:	90                   	nop

f010df64 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010df64:	6a 00                	push   $0x0
f010df66:	6a 02                	push   $0x2
f010df68:	e9 a9 00 00 00       	jmp    f010e016 <_alltraps>
f010df6d:	90                   	nop

f010df6e <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010df6e:	6a 00                	push   $0x0
f010df70:	6a 03                	push   $0x3
f010df72:	e9 9f 00 00 00       	jmp    f010e016 <_alltraps>
f010df77:	90                   	nop

f010df78 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010df78:	6a 00                	push   $0x0
f010df7a:	6a 04                	push   $0x4
f010df7c:	e9 95 00 00 00       	jmp    f010e016 <_alltraps>
f010df81:	90                   	nop

f010df82 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010df82:	6a 00                	push   $0x0
f010df84:	6a 05                	push   $0x5
f010df86:	e9 8b 00 00 00       	jmp    f010e016 <_alltraps>
f010df8b:	90                   	nop

f010df8c <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010df8c:	6a 00                	push   $0x0
f010df8e:	6a 06                	push   $0x6
f010df90:	e9 81 00 00 00       	jmp    f010e016 <_alltraps>
f010df95:	90                   	nop

f010df96 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010df96:	6a 00                	push   $0x0
f010df98:	6a 07                	push   $0x7
f010df9a:	eb 7a                	jmp    f010e016 <_alltraps>

f010df9c <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010df9c:	6a 0a                	push   $0xa
f010df9e:	eb 76                	jmp    f010e016 <_alltraps>

f010dfa0 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010dfa0:	6a 0b                	push   $0xb
f010dfa2:	eb 72                	jmp    f010e016 <_alltraps>

f010dfa4 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010dfa4:	6a 0c                	push   $0xc
f010dfa6:	eb 6e                	jmp    f010e016 <_alltraps>

f010dfa8 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010dfa8:	6a 0d                	push   $0xd
f010dfaa:	eb 6a                	jmp    f010e016 <_alltraps>

f010dfac <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010dfac:	6a 00                	push   $0x0
f010dfae:	6a 10                	push   $0x10
f010dfb0:	eb 64                	jmp    f010e016 <_alltraps>

f010dfb2 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010dfb2:	6a 11                	push   $0x11
f010dfb4:	eb 60                	jmp    f010e016 <_alltraps>

f010dfb6 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010dfb6:	6a 00                	push   $0x0
f010dfb8:	6a 12                	push   $0x12
f010dfba:	eb 5a                	jmp    f010e016 <_alltraps>

f010dfbc <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010dfbc:	6a 00                	push   $0x0
f010dfbe:	6a 13                	push   $0x13
f010dfc0:	eb 54                	jmp    f010e016 <_alltraps>

f010dfc2 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010dfc2:	6a 00                	push   $0x0
f010dfc4:	6a 22                	push   $0x22
f010dfc6:	eb 4e                	jmp    f010e016 <_alltraps>

f010dfc8 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010dfc8:	6a 00                	push   $0x0
f010dfca:	6a 23                	push   $0x23
f010dfcc:	eb 48                	jmp    f010e016 <_alltraps>

f010dfce <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010dfce:	6a 00                	push   $0x0
f010dfd0:	6a 24                	push   $0x24
f010dfd2:	eb 42                	jmp    f010e016 <_alltraps>

f010dfd4 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010dfd4:	6a 00                	push   $0x0
f010dfd6:	6a 25                	push   $0x25
f010dfd8:	eb 3c                	jmp    f010e016 <_alltraps>

f010dfda <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010dfda:	6a 00                	push   $0x0
f010dfdc:	6a 26                	push   $0x26
f010dfde:	eb 36                	jmp    f010e016 <_alltraps>

f010dfe0 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010dfe0:	6a 00                	push   $0x0
f010dfe2:	6a 27                	push   $0x27
f010dfe4:	eb 30                	jmp    f010e016 <_alltraps>

f010dfe6 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010dfe6:	6a 00                	push   $0x0
f010dfe8:	6a 28                	push   $0x28
f010dfea:	eb 2a                	jmp    f010e016 <_alltraps>

f010dfec <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010dfec:	6a 00                	push   $0x0
f010dfee:	6a 29                	push   $0x29
f010dff0:	eb 24                	jmp    f010e016 <_alltraps>

f010dff2 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010dff2:	6a 00                	push   $0x0
f010dff4:	6a 2a                	push   $0x2a
f010dff6:	eb 1e                	jmp    f010e016 <_alltraps>

f010dff8 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010dff8:	6a 00                	push   $0x0
f010dffa:	6a 2b                	push   $0x2b
f010dffc:	eb 18                	jmp    f010e016 <_alltraps>

f010dffe <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010dffe:	6a 00                	push   $0x0
f010e000:	6a 2c                	push   $0x2c
f010e002:	eb 12                	jmp    f010e016 <_alltraps>

f010e004 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e004:	6a 00                	push   $0x0
f010e006:	6a 2d                	push   $0x2d
f010e008:	eb 0c                	jmp    f010e016 <_alltraps>

f010e00a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e00a:	6a 00                	push   $0x0
f010e00c:	6a 2e                	push   $0x2e
f010e00e:	eb 06                	jmp    f010e016 <_alltraps>

f010e010 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e010:	6a 00                	push   $0x0
f010e012:	6a 2f                	push   $0x2f
f010e014:	eb 00                	jmp    f010e016 <_alltraps>

f010e016 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e016:	1e                   	push   %ds
push 	%es
f010e017:	06                   	push   %es
pushal
f010e018:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e019:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e01d:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e01f:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e021:	54                   	push   %esp
call 	trap
f010e022:	e8 d4 fd ff ff       	call   f010ddfb <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e027:	59                   	pop    %ecx

f010e028 <trapret>:
.globl trapret
trapret:
popal
f010e028:	61                   	popa   
pop 	%es
f010e029:	07                   	pop    %es
pop 	%ds
f010e02a:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e02b:	83 c4 08             	add    $0x8,%esp
iret
f010e02e:	cf                   	iret   

f010e02f <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e02f:	55                   	push   %ebp
f010e030:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e032:	8b 45 08             	mov    0x8(%ebp),%eax
f010e035:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f010e03b:	29 d0                	sub    %edx,%eax
f010e03d:	c1 f8 03             	sar    $0x3,%eax
f010e040:	89 c2                	mov    %eax,%edx
f010e042:	89 d0                	mov    %edx,%eax
f010e044:	c1 e0 02             	shl    $0x2,%eax
f010e047:	01 d0                	add    %edx,%eax
f010e049:	c1 e0 02             	shl    $0x2,%eax
f010e04c:	01 d0                	add    %edx,%eax
f010e04e:	c1 e0 02             	shl    $0x2,%eax
f010e051:	01 d0                	add    %edx,%eax
f010e053:	89 c1                	mov    %eax,%ecx
f010e055:	c1 e1 08             	shl    $0x8,%ecx
f010e058:	01 c8                	add    %ecx,%eax
f010e05a:	89 c1                	mov    %eax,%ecx
f010e05c:	c1 e1 10             	shl    $0x10,%ecx
f010e05f:	01 c8                	add    %ecx,%eax
f010e061:	01 c0                	add    %eax,%eax
f010e063:	01 d0                	add    %edx,%eax
}
f010e065:	5d                   	pop    %ebp
f010e066:	c3                   	ret    

f010e067 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e067:	55                   	push   %ebp
f010e068:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e06a:	ff 75 08             	pushl  0x8(%ebp)
f010e06d:	e8 bd ff ff ff       	call   f010e02f <to_frame_number>
f010e072:	83 c4 04             	add    $0x4,%esp
f010e075:	c1 e0 0c             	shl    $0xc,%eax
}
f010e078:	c9                   	leave  
f010e079:	c3                   	ret    

f010e07a <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e07a:	55                   	push   %ebp
f010e07b:	89 e5                	mov    %esp,%ebp
f010e07d:	83 ec 18             	sub    $0x18,%esp
f010e080:	8b 45 10             	mov    0x10(%ebp),%eax
f010e083:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e086:	e8 44 91 ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e08b:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e08f:	74 23                	je     f010e0b4 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e091:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e096:	8b 40 10             	mov    0x10(%eax),%eax
f010e099:	8b 15 a0 3f b0 f0    	mov    0xf0b03fa0,%edx
f010e09f:	83 c2 20             	add    $0x20,%edx
f010e0a2:	83 ec 04             	sub    $0x4,%esp
f010e0a5:	50                   	push   %eax
f010e0a6:	52                   	push   %edx
f010e0a7:	68 90 70 12 f0       	push   $0xf0127090
f010e0ac:	e8 da 2e ff ff       	call   f0100f8b <cprintf>
f010e0b1:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e0b4:	83 ec 04             	sub    $0x4,%esp
f010e0b7:	ff 75 08             	pushl  0x8(%ebp)
f010e0ba:	ff 75 0c             	pushl  0xc(%ebp)
f010e0bd:	68 99 70 12 f0       	push   $0xf0127099
f010e0c2:	e8 c4 2e ff ff       	call   f0100f8b <cprintf>
f010e0c7:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e0ca:	e8 52 91 ff ff       	call   f0107221 <popcli>
}
f010e0cf:	90                   	nop
f010e0d0:	c9                   	leave  
f010e0d1:	c3                   	ret    

f010e0d2 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e0d2:	55                   	push   %ebp
f010e0d3:	89 e5                	mov    %esp,%ebp
f010e0d5:	83 ec 18             	sub    $0x18,%esp
f010e0d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0db:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e0de:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e0e2:	83 ec 08             	sub    $0x8,%esp
f010e0e5:	50                   	push   %eax
f010e0e6:	68 9e 70 12 f0       	push   $0xf012709e
f010e0eb:	e8 9b 2e ff ff       	call   f0100f8b <cprintf>
f010e0f0:	83 c4 10             	add    $0x10,%esp
}
f010e0f3:	90                   	nop
f010e0f4:	c9                   	leave  
f010e0f5:	c3                   	ret    

f010e0f6 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e0f6:	55                   	push   %ebp
f010e0f7:	89 e5                	mov    %esp,%ebp
f010e0f9:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e0fc:	9c                   	pushf  
f010e0fd:	58                   	pop    %eax
f010e0fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e101:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e104:	25 00 02 00 00       	and    $0x200,%eax
f010e109:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e10c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e110:	74 10                	je     f010e122 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e112:	e8 ad 2c ff ff       	call   f0100dc4 <cons_getc2>
f010e117:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e11a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e11e:	74 f2                	je     f010e112 <sys_cgetc+0x1c>
f010e120:	eb 0e                	jmp    f010e130 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e122:	e8 42 2c ff ff       	call   f0100d69 <cons_getc>
f010e127:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e12a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e12e:	74 f2                	je     f010e122 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e130:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e133:	c9                   	leave  
f010e134:	c3                   	ret    

f010e135 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e135:	55                   	push   %ebp
f010e136:	89 e5                	mov    %esp,%ebp
f010e138:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e13b:	e8 70 2d ff ff       	call   f0100eb0 <cons_lock>
}
f010e140:	90                   	nop
f010e141:	c9                   	leave  
f010e142:	c3                   	ret    

f010e143 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e143:	55                   	push   %ebp
f010e144:	89 e5                	mov    %esp,%ebp
f010e146:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e149:	e8 a9 2d ff ff       	call   f0100ef7 <cons_unlock>
}
f010e14e:	90                   	nop
f010e14f:	c9                   	leave  
f010e150:	c3                   	ret    

f010e151 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e151:	55                   	push   %ebp
f010e152:	89 e5                	mov    %esp,%ebp
f010e154:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e157:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e15c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e15f:	83 ec 0c             	sub    $0xc,%esp
f010e162:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e165:	50                   	push   %eax
f010e166:	e8 47 a0 ff ff       	call   f01081b2 <allocate_frame>
f010e16b:	83 c4 10             	add    $0x10,%esp
f010e16e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e171:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e175:	75 08                	jne    f010e17f <__sys_allocate_page+0x2e>
		return r ;
f010e177:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e17a:	e9 e9 00 00 00       	jmp    f010e268 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e17f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e182:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e187:	77 0c                	ja     f010e195 <__sys_allocate_page+0x44>
f010e189:	8b 45 08             	mov    0x8(%ebp),%eax
f010e18c:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e191:	85 c0                	test   %eax,%eax
f010e193:	74 0a                	je     f010e19f <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e195:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e19a:	e9 c9 00 00 00       	jmp    f010e268 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e19f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1a2:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e1a7:	83 f8 04             	cmp    $0x4,%eax
f010e1aa:	74 0a                	je     f010e1b6 <__sys_allocate_page+0x65>
		return E_INVAL;
f010e1ac:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e1b1:	e9 b2 00 00 00       	jmp    f010e268 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e1b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e1b9:	83 ec 0c             	sub    $0xc,%esp
f010e1bc:	50                   	push   %eax
f010e1bd:	e8 a5 fe ff ff       	call   f010e067 <to_physical_address>
f010e1c2:	83 c4 10             	add    $0x10,%esp
f010e1c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e1c8:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e1cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1ce:	8b 40 64             	mov    0x64(%eax),%eax
f010e1d1:	6a 02                	push   $0x2
f010e1d3:	68 00 00 80 ef       	push   $0xef800000
f010e1d8:	52                   	push   %edx
f010e1d9:	50                   	push   %eax
f010e1da:	e8 a0 a4 ff ff       	call   f010867f <map_frame>
f010e1df:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e1e2:	83 ec 04             	sub    $0x4,%esp
f010e1e5:	68 00 10 00 00       	push   $0x1000
f010e1ea:	6a 00                	push   $0x0
f010e1ec:	68 00 00 80 ef       	push   $0xef800000
f010e1f1:	e8 fe 15 01 00       	call   f011f7f4 <memset>
f010e1f6:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e1f9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e1fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e1ff:	8b 40 08             	mov    0x8(%eax),%eax
f010e202:	40                   	inc    %eax
f010e203:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e20a:	8b 40 64             	mov    0x64(%eax),%eax
f010e20d:	83 ec 08             	sub    $0x8,%esp
f010e210:	68 00 00 80 ef       	push   $0xef800000
f010e215:	50                   	push   %eax
f010e216:	e8 c4 a5 ff ff       	call   f01087df <unmap_frame>
f010e21b:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e21e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e221:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e224:	8b 40 08             	mov    0x8(%eax),%eax
f010e227:	48                   	dec    %eax
f010e228:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e22c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e22f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e232:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e235:	8b 40 64             	mov    0x64(%eax),%eax
f010e238:	ff 75 0c             	pushl  0xc(%ebp)
f010e23b:	51                   	push   %ecx
f010e23c:	52                   	push   %edx
f010e23d:	50                   	push   %eax
f010e23e:	e8 3c a4 ff ff       	call   f010867f <map_frame>
f010e243:	83 c4 10             	add    $0x10,%esp
f010e246:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e249:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e24d:	75 14                	jne    f010e263 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e24f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e252:	83 ec 0c             	sub    $0xc,%esp
f010e255:	50                   	push   %eax
f010e256:	e8 64 a1 ff ff       	call   f01083bf <decrement_references>
f010e25b:	83 c4 10             	add    $0x10,%esp
		return r;
f010e25e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e261:	eb 05                	jmp    f010e268 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e268:	c9                   	leave  
f010e269:	c3                   	ret    

f010e26a <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e26a:	55                   	push   %ebp
f010e26b:	89 e5                	mov    %esp,%ebp
f010e26d:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e270:	83 ec 04             	sub    $0x4,%esp
f010e273:	68 a1 70 12 f0       	push   $0xf01270a1
f010e278:	68 dc 00 00 00       	push   $0xdc
f010e27d:	68 bf 70 12 f0       	push   $0xf01270bf
f010e282:	e8 b2 20 ff ff       	call   f0100339 <_panic>

f010e287 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e287:	55                   	push   %ebp
f010e288:	89 e5                	mov    %esp,%ebp
f010e28a:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e28d:	83 ec 04             	sub    $0x4,%esp
f010e290:	68 d4 70 12 f0       	push   $0xf01270d4
f010e295:	68 ed 00 00 00       	push   $0xed
f010e29a:	68 bf 70 12 f0       	push   $0xf01270bf
f010e29f:	e8 95 20 ff ff       	call   f0100339 <_panic>

f010e2a4 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e2a4:	55                   	push   %ebp
f010e2a5:	89 e5                	mov    %esp,%ebp
f010e2a7:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e2aa:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e2af:	8b 40 64             	mov    0x64(%eax),%eax
f010e2b2:	83 ec 04             	sub    $0x4,%esp
f010e2b5:	ff 75 0c             	pushl  0xc(%ebp)
f010e2b8:	ff 75 08             	pushl  0x8(%ebp)
f010e2bb:	50                   	push   %eax
f010e2bc:	e8 25 c2 ff ff       	call   f010a4e6 <calculate_required_frames>
f010e2c1:	83 c4 10             	add    $0x10,%esp
}
f010e2c4:	c9                   	leave  
f010e2c5:	c3                   	ret    

f010e2c6 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e2c6:	55                   	push   %ebp
f010e2c7:	89 e5                	mov    %esp,%ebp
f010e2c9:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e2cc:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e2cf:	83 ec 0c             	sub    $0xc,%esp
f010e2d2:	50                   	push   %eax
f010e2d3:	e8 89 a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e2d8:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e2db:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e2de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2e1:	01 d0                	add    %edx,%eax
}
f010e2e3:	c9                   	leave  
f010e2e4:	c3                   	ret    

f010e2e5 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e2e5:	55                   	push   %ebp
f010e2e6:	89 e5                	mov    %esp,%ebp
f010e2e8:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e2eb:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e2ee:	83 ec 0c             	sub    $0xc,%esp
f010e2f1:	50                   	push   %eax
f010e2f2:	e8 6a a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e2f7:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e2fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e2fd:	c9                   	leave  
f010e2fe:	c3                   	ret    

f010e2ff <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e2ff:	55                   	push   %ebp
f010e300:	89 e5                	mov    %esp,%ebp
f010e302:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e305:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e308:	83 ec 0c             	sub    $0xc,%esp
f010e30b:	50                   	push   %eax
f010e30c:	e8 50 a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e311:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e314:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e317:	c9                   	leave  
f010e318:	c3                   	ret    

f010e319 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e319:	55                   	push   %ebp
f010e31a:	89 e5                	mov    %esp,%ebp
f010e31c:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e31f:	83 ec 0c             	sub    $0xc,%esp
f010e322:	ff 75 08             	pushl  0x8(%ebp)
f010e325:	e8 73 00 01 00       	call   f011e39d <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e32a:	83 c4 10             	add    $0x10,%esp
}
f010e32d:	c9                   	leave  
f010e32e:	c3                   	ret    

f010e32f <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e32f:	55                   	push   %ebp
f010e330:	89 e5                	mov    %esp,%ebp
f010e332:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e335:	e8 8e ff 00 00       	call   f011e2c8 <scarce_memory>
}
f010e33a:	90                   	nop
f010e33b:	c9                   	leave  
f010e33c:	c3                   	ret    

f010e33d <sys_clearFFL>:

void sys_clearFFL()
{
f010e33d:	55                   	push   %ebp
f010e33e:	89 e5                	mov    %esp,%ebp
f010e340:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e343:	83 ec 0c             	sub    $0xc,%esp
f010e346:	68 80 d3 6b f0       	push   $0xf06bd380
f010e34b:	e8 f5 12 00 00       	call   f010f645 <acquire_spinlock>
f010e350:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e353:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f010e358:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e35b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e362:	eb 12                	jmp    f010e376 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e364:	83 ec 0c             	sub    $0xc,%esp
f010e367:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e36a:	50                   	push   %eax
f010e36b:	e8 42 9e ff ff       	call   f01081b2 <allocate_frame>
f010e370:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e373:	ff 45 f4             	incl   -0xc(%ebp)
f010e376:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e379:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e37c:	7c e6                	jl     f010e364 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010e37e:	83 ec 0c             	sub    $0xc,%esp
f010e381:	68 80 d3 6b f0       	push   $0xf06bd380
f010e386:	e8 41 13 00 00       	call   f010f6cc <release_spinlock>
f010e38b:	83 c4 10             	add    $0x10,%esp
}
f010e38e:	90                   	nop
f010e38f:	c9                   	leave  
f010e390:	c3                   	ret    

f010e391 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e391:	55                   	push   %ebp
f010e392:	89 e5                	mov    %esp,%ebp
f010e394:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010e397:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e39c:	83 ec 0c             	sub    $0xc,%esp
f010e39f:	50                   	push   %eax
f010e3a0:	e8 5a 64 ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010e3a5:	83 c4 10             	add    $0x10,%esp
}
f010e3a8:	c9                   	leave  
f010e3a9:	c3                   	ret    

f010e3aa <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e3aa:	55                   	push   %ebp
f010e3ab:	89 e5                	mov    %esp,%ebp
f010e3ad:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010e3b0:	e8 ed 0c 00 00       	call   f010f0a2 <isBufferingEnabled>
f010e3b5:	84 c0                	test   %al,%al
f010e3b7:	74 19                	je     f010e3d2 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010e3b9:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e3be:	83 ec 04             	sub    $0x4,%esp
f010e3c1:	ff 75 0c             	pushl  0xc(%ebp)
f010e3c4:	ff 75 08             	pushl  0x8(%ebp)
f010e3c7:	50                   	push   %eax
f010e3c8:	e8 48 c3 ff ff       	call   f010a715 <__free_user_mem_with_buffering>
f010e3cd:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010e3d0:	eb 18                	jmp    f010e3ea <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010e3d2:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e3d7:	83 ec 04             	sub    $0x4,%esp
f010e3da:	ff 75 0c             	pushl  0xc(%ebp)
f010e3dd:	ff 75 08             	pushl  0x8(%ebp)
f010e3e0:	50                   	push   %eax
f010e3e1:	e8 5f c2 ff ff       	call   f010a645 <free_user_mem>
f010e3e6:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010e3e9:	90                   	nop
}
f010e3ea:	c9                   	leave  
f010e3eb:	c3                   	ret    

f010e3ec <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010e3ec:	55                   	push   %ebp
f010e3ed:	89 e5                	mov    %esp,%ebp
f010e3ef:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010e3f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e3f6:	75 07                	jne    f010e3ff <check_Param+0x13>
	{
		env_exit();
f010e3f8:	e8 64 cf ff ff       	call   f010b361 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e3fd:	eb 25                	jmp    f010e424 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010e3ff:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010e406:	77 07                	ja     f010e40f <check_Param+0x23>
f010e408:	8b 45 08             	mov    0x8(%ebp),%eax
f010e40b:	85 c0                	test   %eax,%eax
f010e40d:	78 07                	js     f010e416 <check_Param+0x2a>
	{
		env_exit();
f010e40f:	e8 4d cf ff ff       	call   f010b361 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e414:	eb 0e                	jmp    f010e424 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010e416:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010e41d:	76 05                	jbe    f010e424 <check_Param+0x38>
	{
		env_exit();
f010e41f:	e8 3d cf ff ff       	call   f010b361 <env_exit>
	}
}
f010e424:	90                   	nop
f010e425:	c9                   	leave  
f010e426:	c3                   	ret    

f010e427 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010e427:	55                   	push   %ebp
f010e428:	89 e5                	mov    %esp,%ebp
f010e42a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e42d:	83 ec 0c             	sub    $0xc,%esp
f010e430:	ff 75 08             	pushl  0x8(%ebp)
f010e433:	e8 b4 ff ff ff       	call   f010e3ec <check_Param>
f010e438:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010e43b:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e440:	83 ec 04             	sub    $0x4,%esp
f010e443:	ff 75 0c             	pushl  0xc(%ebp)
f010e446:	ff 75 08             	pushl  0x8(%ebp)
f010e449:	50                   	push   %eax
f010e44a:	e8 3b c1 ff ff       	call   f010a58a <allocate_user_mem>
f010e44f:	83 c4 10             	add    $0x10,%esp
	return;
f010e452:	90                   	nop
}
f010e453:	c9                   	leave  
f010e454:	c3                   	ret    

f010e455 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010e455:	55                   	push   %ebp
f010e456:	89 e5                	mov    %esp,%ebp
f010e458:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e45b:	83 ec 0c             	sub    $0xc,%esp
f010e45e:	ff 75 08             	pushl  0x8(%ebp)
f010e461:	e8 86 ff ff ff       	call   f010e3ec <check_Param>
f010e466:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010e469:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e46e:	8b 40 64             	mov    0x64(%eax),%eax
f010e471:	ff 75 10             	pushl  0x10(%ebp)
f010e474:	ff 75 0c             	pushl  0xc(%ebp)
f010e477:	ff 75 08             	pushl  0x8(%ebp)
f010e47a:	50                   	push   %eax
f010e47b:	e8 32 c0 ff ff       	call   f010a4b2 <allocate_chunk>
f010e480:	83 c4 10             	add    $0x10,%esp
	return;
f010e483:	90                   	nop
}
f010e484:	c9                   	leave  
f010e485:	c3                   	ret    

f010e486 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010e486:	55                   	push   %ebp
f010e487:	89 e5                	mov    %esp,%ebp
f010e489:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010e48c:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e491:	ff 75 10             	pushl  0x10(%ebp)
f010e494:	ff 75 0c             	pushl  0xc(%ebp)
f010e497:	ff 75 08             	pushl  0x8(%ebp)
f010e49a:	50                   	push   %eax
f010e49b:	e8 92 c2 ff ff       	call   f010a732 <move_user_mem>
f010e4a0:	83 c4 10             	add    $0x10,%esp
	return;
f010e4a3:	90                   	nop
}
f010e4a4:	c9                   	leave  
f010e4a5:	c3                   	ret    

f010e4a6 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010e4a6:	55                   	push   %ebp
f010e4a7:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010e4a9:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
}
f010e4ae:	5d                   	pop    %ebp
f010e4af:	c3                   	ret    

f010e4b0 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010e4b0:	55                   	push   %ebp
f010e4b1:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010e4b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4b6:	a3 a4 d7 6b f0       	mov    %eax,0xf06bd7a4
}
f010e4bb:	90                   	nop
f010e4bc:	5d                   	pop    %ebp
f010e4bd:	c3                   	ret    

f010e4be <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010e4be:	55                   	push   %ebp
f010e4bf:	89 e5                	mov    %esp,%ebp
f010e4c1:	83 ec 18             	sub    $0x18,%esp
f010e4c4:	8b 45 10             	mov    0x10(%ebp),%eax
f010e4c7:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010e4ca:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010e4ce:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e4d3:	8b 40 10             	mov    0x10(%eax),%eax
f010e4d6:	83 ec 0c             	sub    $0xc,%esp
f010e4d9:	ff 75 14             	pushl  0x14(%ebp)
f010e4dc:	52                   	push   %edx
f010e4dd:	ff 75 0c             	pushl  0xc(%ebp)
f010e4e0:	ff 75 08             	pushl  0x8(%ebp)
f010e4e3:	50                   	push   %eax
f010e4e4:	e8 95 a7 ff ff       	call   f0108c7e <createSharedObject>
f010e4e9:	83 c4 20             	add    $0x20,%esp
}
f010e4ec:	c9                   	leave  
f010e4ed:	c3                   	ret    

f010e4ee <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010e4ee:	55                   	push   %ebp
f010e4ef:	89 e5                	mov    %esp,%ebp
f010e4f1:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010e4f4:	83 ec 08             	sub    $0x8,%esp
f010e4f7:	ff 75 0c             	pushl  0xc(%ebp)
f010e4fa:	ff 75 08             	pushl  0x8(%ebp)
f010e4fd:	e8 7e a5 ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010e502:	83 c4 10             	add    $0x10,%esp
}
f010e505:	c9                   	leave  
f010e506:	c3                   	ret    

f010e507 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010e507:	55                   	push   %ebp
f010e508:	89 e5                	mov    %esp,%ebp
f010e50a:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010e50d:	83 ec 04             	sub    $0x4,%esp
f010e510:	ff 75 10             	pushl  0x10(%ebp)
f010e513:	ff 75 0c             	pushl  0xc(%ebp)
f010e516:	ff 75 08             	pushl  0x8(%ebp)
f010e519:	e8 18 a9 ff ff       	call   f0108e36 <getSharedObject>
f010e51e:	83 c4 10             	add    $0x10,%esp
}
f010e521:	c9                   	leave  
f010e522:	c3                   	ret    

f010e523 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010e523:	55                   	push   %ebp
f010e524:	89 e5                	mov    %esp,%ebp
f010e526:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010e529:	83 ec 08             	sub    $0x8,%esp
f010e52c:	ff 75 0c             	pushl  0xc(%ebp)
f010e52f:	ff 75 08             	pushl  0x8(%ebp)
f010e532:	e8 f1 a9 ff ff       	call   f0108f28 <freeSharedObject>
f010e537:	83 c4 10             	add    $0x10,%esp
}
f010e53a:	c9                   	leave  
f010e53b:	c3                   	ret    

f010e53c <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010e53c:	55                   	push   %ebp
f010e53d:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010e53f:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e544:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e547:	5d                   	pop    %ebp
f010e548:	c3                   	ret    

f010e549 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010e549:	55                   	push   %ebp
f010e54a:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010e54c:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e551:	89 c2                	mov    %eax,%edx
f010e553:	a1 d0 47 69 f0       	mov    0xf06947d0,%eax
f010e558:	29 c2                	sub    %eax,%edx
f010e55a:	89 d0                	mov    %edx,%eax
f010e55c:	c1 f8 02             	sar    $0x2,%eax
f010e55f:	89 c2                	mov    %eax,%edx
f010e561:	89 d0                	mov    %edx,%eax
f010e563:	c1 e0 03             	shl    $0x3,%eax
f010e566:	01 d0                	add    %edx,%eax
f010e568:	c1 e0 03             	shl    $0x3,%eax
f010e56b:	01 d0                	add    %edx,%eax
f010e56d:	c1 e0 02             	shl    $0x2,%eax
f010e570:	01 d0                	add    %edx,%eax
f010e572:	01 c0                	add    %eax,%eax
f010e574:	01 d0                	add    %edx,%eax
f010e576:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010e57d:	01 c8                	add    %ecx,%eax
f010e57f:	c1 e0 02             	shl    $0x2,%eax
f010e582:	01 d0                	add    %edx,%eax
f010e584:	c1 e0 03             	shl    $0x3,%eax
f010e587:	01 d0                	add    %edx,%eax
f010e589:	c1 e0 05             	shl    $0x5,%eax
f010e58c:	29 d0                	sub    %edx,%eax
f010e58e:	c1 e0 02             	shl    $0x2,%eax
f010e591:	01 d0                	add    %edx,%eax
f010e593:	01 c0                	add    %eax,%eax
f010e595:	01 d0                	add    %edx,%eax
f010e597:	c1 e0 03             	shl    $0x3,%eax
f010e59a:	01 d0                	add    %edx,%eax
f010e59c:	c1 e0 04             	shl    $0x4,%eax
f010e59f:	29 d0                	sub    %edx,%eax
}
f010e5a1:	5d                   	pop    %ebp
f010e5a2:	c3                   	ret    

f010e5a3 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010e5a3:	55                   	push   %ebp
f010e5a4:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010e5a6:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5ab:	8b 40 14             	mov    0x14(%eax),%eax
}
f010e5ae:	5d                   	pop    %ebp
f010e5af:	c3                   	ret    

f010e5b0 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010e5b0:	55                   	push   %ebp
f010e5b1:	89 e5                	mov    %esp,%ebp
f010e5b3:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010e5b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e5ba:	75 0a                	jne    f010e5c6 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010e5bc:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e5c4:	eb 22                	jmp    f010e5e8 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010e5c6:	83 ec 04             	sub    $0x4,%esp
f010e5c9:	6a 00                	push   $0x0
f010e5cb:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010e5ce:	50                   	push   %eax
f010e5cf:	ff 75 08             	pushl  0x8(%ebp)
f010e5d2:	e8 1c ce ff ff       	call   f010b3f3 <envid2env>
f010e5d7:	83 c4 10             	add    $0x10,%esp
f010e5da:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e5dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e5e1:	79 05                	jns    f010e5e8 <sys_destroy_env+0x38>
	{
		return r;
f010e5e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5e6:	eb 5e                	jmp    f010e646 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010e5e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e5eb:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5f0:	39 c2                	cmp    %eax,%edx
f010e5f2:	75 1b                	jne    f010e60f <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010e5f4:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5f9:	8b 40 10             	mov    0x10(%eax),%eax
f010e5fc:	83 ec 08             	sub    $0x8,%esp
f010e5ff:	50                   	push   %eax
f010e600:	68 f3 70 12 f0       	push   $0xf01270f3
f010e605:	e8 81 29 ff ff       	call   f0100f8b <cprintf>
f010e60a:	83 c4 10             	add    $0x10,%esp
f010e60d:	eb 20                	jmp    f010e62f <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010e60f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e612:	8b 50 10             	mov    0x10(%eax),%edx
f010e615:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e61a:	8b 40 10             	mov    0x10(%eax),%eax
f010e61d:	83 ec 04             	sub    $0x4,%esp
f010e620:	52                   	push   %edx
f010e621:	50                   	push   %eax
f010e622:	68 0e 71 12 f0       	push   $0xf012710e
f010e627:	e8 5f 29 ff ff       	call   f0100f8b <cprintf>
f010e62c:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010e62f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e632:	8b 40 10             	mov    0x10(%eax),%eax
f010e635:	83 ec 0c             	sub    $0xc,%esp
f010e638:	50                   	push   %eax
f010e639:	e8 7a 74 ff ff       	call   f0105ab8 <sched_kill_env>
f010e63e:	83 c4 10             	add    $0x10,%esp

	return 0;
f010e641:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e646:	c9                   	leave  
f010e647:	c3                   	ret    

f010e648 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010e648:	55                   	push   %ebp
f010e649:	89 e5                	mov    %esp,%ebp
f010e64b:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010e64e:	e8 0e cd ff ff       	call   f010b361 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010e653:	90                   	nop
f010e654:	c9                   	leave  
f010e655:	c3                   	ret    

f010e656 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010e656:	55                   	push   %ebp
f010e657:	89 e5                	mov    %esp,%ebp
f010e659:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010e65c:	ff 75 14             	pushl  0x14(%ebp)
f010e65f:	ff 75 10             	pushl  0x10(%ebp)
f010e662:	ff 75 0c             	pushl  0xc(%ebp)
f010e665:	ff 75 08             	pushl  0x8(%ebp)
f010e668:	e8 b8 c2 ff ff       	call   f010a925 <env_create>
f010e66d:	83 c4 10             	add    $0x10,%esp
f010e670:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010e673:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e677:	75 07                	jne    f010e680 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010e679:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010e67e:	eb 14                	jmp    f010e694 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010e680:	83 ec 0c             	sub    $0xc,%esp
f010e683:	ff 75 f4             	pushl  -0xc(%ebp)
f010e686:	e8 91 70 ff ff       	call   f010571c <sched_new_env>
f010e68b:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010e68e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e691:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e694:	c9                   	leave  
f010e695:	c3                   	ret    

f010e696 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010e696:	55                   	push   %ebp
f010e697:	89 e5                	mov    %esp,%ebp
f010e699:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010e69c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e69f:	83 ec 0c             	sub    $0xc,%esp
f010e6a2:	50                   	push   %eax
f010e6a3:	e8 ca 70 ff ff       	call   f0105772 <sched_run_env>
f010e6a8:	83 c4 10             	add    $0x10,%esp
}
f010e6ab:	90                   	nop
f010e6ac:	c9                   	leave  
f010e6ad:	c3                   	ret    

f010e6ae <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010e6ae:	55                   	push   %ebp
f010e6af:	89 e5                	mov    %esp,%ebp
f010e6b1:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010e6b4:	0f 31                	rdtsc  
f010e6b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e6b9:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010e6bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e6bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e6c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e6c5:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010e6c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e6cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e6ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e6d1:	89 01                	mov    %eax,(%ecx)
f010e6d3:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010e6d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d9:	c9                   	leave  
f010e6da:	c2 04 00             	ret    $0x4

f010e6dd <sys_rcr2>:

uint32 sys_rcr2()
{
f010e6dd:	55                   	push   %ebp
f010e6de:	89 e5                	mov    %esp,%ebp
f010e6e0:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e6e3:	0f 20 d0             	mov    %cr2,%eax
f010e6e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010e6e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010e6ec:	90                   	nop
}
f010e6ed:	c9                   	leave  
f010e6ee:	c3                   	ret    

f010e6ef <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010e6ef:	55                   	push   %ebp
f010e6f0:	89 e5                	mov    %esp,%ebp
f010e6f2:	83 ec 04             	sub    $0x4,%esp
f010e6f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6f8:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010e6fb:	8a 45 fc             	mov    -0x4(%ebp),%al
f010e6fe:	a2 40 50 69 f0       	mov    %al,0xf0695040
}
f010e703:	90                   	nop
f010e704:	c9                   	leave  
f010e705:	c3                   	ret    

f010e706 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010e706:	55                   	push   %ebp
f010e707:	89 e5                	mov    %esp,%ebp
f010e709:	56                   	push   %esi
f010e70a:	53                   	push   %ebx
f010e70b:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010e70e:	e8 90 cc ff ff       	call   f010b3a3 <get_cpu_proc>
f010e713:	a3 a0 3f b0 f0       	mov    %eax,0xf0b03fa0
	assert(cur_env != NULL);
f010e718:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e71d:	85 c0                	test   %eax,%eax
f010e71f:	75 19                	jne    f010e73a <syscall+0x34>
f010e721:	68 26 71 12 f0       	push   $0xf0127126
f010e726:	68 36 71 12 f0       	push   $0xf0127136
f010e72b:	68 05 02 00 00       	push   $0x205
f010e730:	68 bf 70 12 f0       	push   $0xf01270bf
f010e735:	e8 ff 1b ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010e73a:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010e73e:	0f 87 06 04 00 00    	ja     f010eb4a <syscall+0x444>
f010e744:	8b 45 08             	mov    0x8(%ebp),%eax
f010e747:	c1 e0 02             	shl    $0x2,%eax
f010e74a:	05 4c 71 12 f0       	add    $0xf012714c,%eax
f010e74f:	8b 00                	mov    (%eax),%eax
f010e751:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010e753:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e756:	83 ec 0c             	sub    $0xc,%esp
f010e759:	50                   	push   %eax
f010e75a:	e8 a1 bd ff ff       	call   f010a500 <sys_sbrk>
f010e75f:	83 c4 10             	add    $0x10,%esp
f010e762:	e9 e8 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010e767:	83 ec 08             	sub    $0x8,%esp
f010e76a:	ff 75 10             	pushl  0x10(%ebp)
f010e76d:	ff 75 0c             	pushl  0xc(%ebp)
f010e770:	e8 35 fc ff ff       	call   f010e3aa <sys_free_user_mem>
f010e775:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e778:	b8 00 00 00 00       	mov    $0x0,%eax
f010e77d:	e9 cd 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010e782:	83 ec 08             	sub    $0x8,%esp
f010e785:	ff 75 10             	pushl  0x10(%ebp)
f010e788:	ff 75 0c             	pushl  0xc(%ebp)
f010e78b:	e8 97 fc ff ff       	call   f010e427 <sys_allocate_user_mem>
f010e790:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e793:	b8 00 00 00 00       	mov    $0x0,%eax
f010e798:	e9 b2 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010e79d:	8b 45 14             	mov    0x14(%ebp),%eax
f010e7a0:	0f b6 d0             	movzbl %al,%edx
f010e7a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7a6:	83 ec 04             	sub    $0x4,%esp
f010e7a9:	52                   	push   %edx
f010e7aa:	ff 75 10             	pushl  0x10(%ebp)
f010e7ad:	50                   	push   %eax
f010e7ae:	e8 c7 f8 ff ff       	call   f010e07a <sys_cputs>
f010e7b3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e7b6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7bb:	e9 8f 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010e7c0:	e8 31 f9 ff ff       	call   f010e0f6 <sys_cgetc>
f010e7c5:	e9 85 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010e7ca:	e8 66 f9 ff ff       	call   f010e135 <sys_lock_cons>
		return 0;
f010e7cf:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7d4:	e9 76 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010e7d9:	e8 65 f9 ff ff       	call   f010e143 <sys_unlock_cons>
		return 0;
f010e7de:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7e3:	e9 67 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010e7e8:	83 ec 08             	sub    $0x8,%esp
f010e7eb:	ff 75 10             	pushl  0x10(%ebp)
f010e7ee:	ff 75 0c             	pushl  0xc(%ebp)
f010e7f1:	e8 ae fa ff ff       	call   f010e2a4 <sys_calculate_required_frames>
f010e7f6:	83 c4 10             	add    $0x10,%esp
f010e7f9:	e9 51 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010e7fe:	e8 c3 fa ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f010e803:	e9 47 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010e808:	e8 d8 fa ff ff       	call   f010e2e5 <sys_calculate_modified_frames>
f010e80d:	e9 3d 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010e812:	e8 e8 fa ff ff       	call   f010e2ff <sys_calculate_notmod_frames>
f010e817:	e9 33 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010e81c:	e8 70 fb ff ff       	call   f010e391 <sys_pf_calculate_allocated_pages>
f010e821:	e9 29 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010e826:	83 ec 0c             	sub    $0xc,%esp
f010e829:	ff 75 0c             	pushl  0xc(%ebp)
f010e82c:	e8 e8 fa ff ff       	call   f010e319 <sys_calculate_pages_tobe_removed_ready_exit>
f010e831:	83 c4 10             	add    $0x10,%esp
f010e834:	e9 16 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010e839:	e8 f1 fa ff ff       	call   f010e32f <sys_scarce_memory>
		return 0;
f010e83e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e843:	e9 07 03 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010e848:	83 ec 04             	sub    $0x4,%esp
f010e84b:	ff 75 14             	pushl  0x14(%ebp)
f010e84e:	ff 75 10             	pushl  0x10(%ebp)
f010e851:	ff 75 0c             	pushl  0xc(%ebp)
f010e854:	e8 fc fb ff ff       	call   f010e455 <sys_allocate_chunk>
f010e859:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e85c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e861:	e9 e9 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010e866:	8b 55 10             	mov    0x10(%ebp),%edx
f010e869:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e86c:	83 ec 08             	sub    $0x8,%esp
f010e86f:	52                   	push   %edx
f010e870:	50                   	push   %eax
f010e871:	e8 db f8 ff ff       	call   f010e151 <__sys_allocate_page>
f010e876:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e879:	b8 00 00 00 00       	mov    $0x0,%eax
f010e87e:	e9 cc 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010e883:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010e886:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e889:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e88c:	8b 55 10             	mov    0x10(%ebp),%edx
f010e88f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e892:	83 ec 0c             	sub    $0xc,%esp
f010e895:	56                   	push   %esi
f010e896:	53                   	push   %ebx
f010e897:	51                   	push   %ecx
f010e898:	52                   	push   %edx
f010e899:	50                   	push   %eax
f010e89a:	e8 cb f9 ff ff       	call   f010e26a <__sys_map_frame>
f010e89f:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e8a2:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8a7:	e9 a3 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010e8ac:	8b 55 10             	mov    0x10(%ebp),%edx
f010e8af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8b2:	83 ec 08             	sub    $0x8,%esp
f010e8b5:	52                   	push   %edx
f010e8b6:	50                   	push   %eax
f010e8b7:	e8 cb f9 ff ff       	call   f010e287 <__sys_unmap_frame>
f010e8bc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8bf:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8c4:	e9 86 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010e8c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8cc:	0f be c0             	movsbl %al,%eax
f010e8cf:	83 ec 0c             	sub    $0xc,%esp
f010e8d2:	50                   	push   %eax
f010e8d3:	e8 fa f7 ff ff       	call   f010e0d2 <sys_cputc>
f010e8d8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8db:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8e0:	e9 6a 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e8e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8e8:	0f be c0             	movsbl %al,%eax
f010e8eb:	83 ec 0c             	sub    $0xc,%esp
f010e8ee:	50                   	push   %eax
f010e8ef:	e8 49 fa ff ff       	call   f010e33d <sys_clearFFL>
f010e8f4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8f7:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8fc:	e9 4e 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e901:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e904:	8b 45 14             	mov    0x14(%ebp),%eax
f010e907:	0f b6 d0             	movzbl %al,%edx
f010e90a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e90d:	51                   	push   %ecx
f010e90e:	52                   	push   %edx
f010e90f:	ff 75 10             	pushl  0x10(%ebp)
f010e912:	50                   	push   %eax
f010e913:	e8 a6 fb ff ff       	call   f010e4be <sys_createSharedObject>
f010e918:	83 c4 10             	add    $0x10,%esp
f010e91b:	e9 2f 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e920:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e923:	8b 55 10             	mov    0x10(%ebp),%edx
f010e926:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e929:	83 ec 04             	sub    $0x4,%esp
f010e92c:	51                   	push   %ecx
f010e92d:	52                   	push   %edx
f010e92e:	50                   	push   %eax
f010e92f:	e8 d3 fb ff ff       	call   f010e507 <sys_getSharedObject>
f010e934:	83 c4 10             	add    $0x10,%esp
f010e937:	e9 13 02 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e93c:	8b 55 10             	mov    0x10(%ebp),%edx
f010e93f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e942:	83 ec 08             	sub    $0x8,%esp
f010e945:	52                   	push   %edx
f010e946:	50                   	push   %eax
f010e947:	e8 d7 fb ff ff       	call   f010e523 <sys_freeSharedObject>
f010e94c:	83 c4 10             	add    $0x10,%esp
f010e94f:	e9 fb 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e954:	8b 55 10             	mov    0x10(%ebp),%edx
f010e957:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e95a:	83 ec 08             	sub    $0x8,%esp
f010e95d:	52                   	push   %edx
f010e95e:	50                   	push   %eax
f010e95f:	e8 8a fb ff ff       	call   f010e4ee <sys_getSizeOfSharedObject>
f010e964:	83 c4 10             	add    $0x10,%esp
f010e967:	e9 e3 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e96c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e96f:	ff 75 18             	pushl  0x18(%ebp)
f010e972:	ff 75 14             	pushl  0x14(%ebp)
f010e975:	ff 75 10             	pushl  0x10(%ebp)
f010e978:	50                   	push   %eax
f010e979:	e8 d8 fc ff ff       	call   f010e656 <sys_create_env>
f010e97e:	83 c4 10             	add    $0x10,%esp
f010e981:	e9 c9 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e986:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e989:	83 ec 0c             	sub    $0xc,%esp
f010e98c:	50                   	push   %eax
f010e98d:	e8 04 fd ff ff       	call   f010e696 <sys_run_env>
f010e992:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e995:	b8 00 00 00 00       	mov    $0x0,%eax
f010e99a:	e9 b0 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e99f:	e8 a5 fb ff ff       	call   f010e549 <sys_getenvindex>
f010e9a4:	e9 a6 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e9a9:	e8 8e fb ff ff       	call   f010e53c <sys_getenvid>
f010e9ae:	e9 9c 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e9b3:	e8 eb fb ff ff       	call   f010e5a3 <sys_getparentenvid>
f010e9b8:	e9 92 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e9bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9c0:	83 ec 0c             	sub    $0xc,%esp
f010e9c3:	50                   	push   %eax
f010e9c4:	e8 e7 fb ff ff       	call   f010e5b0 <sys_destroy_env>
f010e9c9:	83 c4 10             	add    $0x10,%esp
f010e9cc:	e9 7e 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e9d1:	e8 72 fc ff ff       	call   f010e648 <sys_exit_env>
		return 0;
f010e9d6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9db:	e9 6f 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e9e0:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e9e3:	83 ec 0c             	sub    $0xc,%esp
f010e9e6:	50                   	push   %eax
f010e9e7:	e8 c2 fc ff ff       	call   f010e6ae <sys_get_virtual_time>
f010e9ec:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e9ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e9f5:	8b 45 10             	mov    0x10(%ebp),%eax
f010e9f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e9fb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e9fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea01:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010ea03:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ea06:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ea09:	89 10                	mov    %edx,(%eax)
		return 0;
f010ea0b:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea10:	e9 3a 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010ea15:	83 ec 04             	sub    $0x4,%esp
f010ea18:	ff 75 14             	pushl  0x14(%ebp)
f010ea1b:	ff 75 10             	pushl  0x10(%ebp)
f010ea1e:	ff 75 0c             	pushl  0xc(%ebp)
f010ea21:	e8 60 fa ff ff       	call   f010e486 <sys_move_user_mem>
f010ea26:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea29:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea2e:	e9 1c 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010ea33:	e8 a5 fc ff ff       	call   f010e6dd <sys_rcr2>
f010ea38:	e9 12 01 00 00       	jmp    f010eb4f <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010ea3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea40:	0f b6 c0             	movzbl %al,%eax
f010ea43:	83 ec 0c             	sub    $0xc,%esp
f010ea46:	50                   	push   %eax
f010ea47:	e8 a3 fc ff ff       	call   f010e6ef <sys_bypassPageFault>
f010ea4c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea4f:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea54:	e9 f6 00 00 00       	jmp    f010eb4f <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010ea59:	e8 1e ef 00 00       	call   f011d97c <rsttst>
		return 0;
f010ea5e:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea63:	e9 e7 00 00 00       	jmp    f010eb4f <syscall+0x449>
	case SYS_inctst:
		inctst();
f010ea68:	e8 57 ef 00 00       	call   f011d9c4 <inctst>
		return 0;
f010ea6d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea72:	e9 d8 00 00 00       	jmp    f010eb4f <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010ea77:	83 ec 0c             	sub    $0xc,%esp
f010ea7a:	ff 75 0c             	pushl  0xc(%ebp)
f010ea7d:	e8 84 f0 00 00       	call   f011db06 <chktst>
f010ea82:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea85:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea8a:	e9 c0 00 00 00       	jmp    f010eb4f <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010ea8f:	e8 64 ef 00 00       	call   f011d9f8 <gettst>
f010ea94:	e9 b6 00 00 00       	jmp    f010eb4f <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010ea99:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010ea9c:	8b 45 18             	mov    0x18(%ebp),%eax
f010ea9f:	0f be c0             	movsbl %al,%eax
f010eaa2:	83 ec 0c             	sub    $0xc,%esp
f010eaa5:	52                   	push   %edx
f010eaa6:	50                   	push   %eax
f010eaa7:	ff 75 14             	pushl  0x14(%ebp)
f010eaaa:	ff 75 10             	pushl  0x10(%ebp)
f010eaad:	ff 75 0c             	pushl  0xc(%ebp)
f010eab0:	e8 4d ef 00 00       	call   f011da02 <tst>
f010eab5:	83 c4 20             	add    $0x20,%esp
		return 0;
f010eab8:	b8 00 00 00 00       	mov    $0x0,%eax
f010eabd:	e9 8d 00 00 00       	jmp    f010eb4f <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010eac2:	e8 df f9 ff ff       	call   f010e4a6 <sys_get_heap_strategy>
f010eac7:	e9 83 00 00 00       	jmp    f010eb4f <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010eacc:	83 ec 0c             	sub    $0xc,%esp
f010eacf:	ff 75 0c             	pushl  0xc(%ebp)
f010ead2:	e8 d9 f9 ff ff       	call   f010e4b0 <sys_set_uheap_strategy>
f010ead7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eada:	b8 00 00 00 00       	mov    $0x0,%eax
f010eadf:	eb 6e                	jmp    f010eb4f <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010eae1:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010eae4:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010eae7:	8b 55 10             	mov    0x10(%ebp),%edx
f010eaea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eaed:	53                   	push   %ebx
f010eaee:	51                   	push   %ecx
f010eaef:	52                   	push   %edx
f010eaf0:	50                   	push   %eax
f010eaf1:	e8 c6 1d 00 00       	call   f01108bc <sys_check_LRU_lists>
f010eaf6:	83 c4 10             	add    $0x10,%esp
f010eaf9:	eb 54                	jmp    f010eb4f <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010eafb:	8b 55 10             	mov    0x10(%ebp),%edx
f010eafe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb01:	83 ec 08             	sub    $0x8,%esp
f010eb04:	52                   	push   %edx
f010eb05:	50                   	push   %eax
f010eb06:	e8 73 1f 00 00       	call   f0110a7e <sys_check_LRU_lists_free>
f010eb0b:	83 c4 10             	add    $0x10,%esp
f010eb0e:	eb 3f                	jmp    f010eb4f <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010eb10:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010eb13:	8b 55 10             	mov    0x10(%ebp),%edx
f010eb16:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb19:	51                   	push   %ecx
f010eb1a:	ff 75 14             	pushl  0x14(%ebp)
f010eb1d:	52                   	push   %edx
f010eb1e:	50                   	push   %eax
f010eb1f:	e8 e7 20 00 00       	call   f0110c0b <sys_check_WS_list>
f010eb24:	83 c4 10             	add    $0x10,%esp
f010eb27:	eb 26                	jmp    f010eb4f <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010eb29:	8b 55 10             	mov    0x10(%ebp),%edx
f010eb2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb2f:	83 ec 08             	sub    $0x8,%esp
f010eb32:	52                   	push   %edx
f010eb33:	50                   	push   %eax
f010eb34:	e8 ce f1 00 00       	call   f011dd07 <sys_utilities>
f010eb39:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eb3c:	b8 00 00 00 00       	mov    $0x0,%eax
f010eb41:	eb 0c                	jmp    f010eb4f <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010eb43:	b8 03 00 00 00       	mov    $0x3,%eax
f010eb48:	eb 05                	jmp    f010eb4f <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010eb4a:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010eb4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010eb52:	5b                   	pop    %ebx
f010eb53:	5e                   	pop    %esi
f010eb54:	5d                   	pop    %ebp
f010eb55:	c3                   	ret    

f010eb56 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010eb56:	55                   	push   %ebp
f010eb57:	89 e5                	mov    %esp,%ebp
f010eb59:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010eb5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb5f:	8b 00                	mov    (%eax),%eax
f010eb61:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010eb64:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb67:	8b 00                	mov    (%eax),%eax
f010eb69:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010eb6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010eb73:	e9 ca 00 00 00       	jmp    f010ec42 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010eb78:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010eb7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010eb7e:	01 d0                	add    %edx,%eax
f010eb80:	89 c2                	mov    %eax,%edx
f010eb82:	c1 ea 1f             	shr    $0x1f,%edx
f010eb85:	01 d0                	add    %edx,%eax
f010eb87:	d1 f8                	sar    %eax
f010eb89:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010eb8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eb8f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010eb92:	eb 03                	jmp    f010eb97 <stab_binsearch+0x41>
			m--;
f010eb94:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010eb97:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb9a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010eb9d:	7c 1e                	jl     f010ebbd <stab_binsearch+0x67>
f010eb9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eba2:	89 d0                	mov    %edx,%eax
f010eba4:	01 c0                	add    %eax,%eax
f010eba6:	01 d0                	add    %edx,%eax
f010eba8:	c1 e0 02             	shl    $0x2,%eax
f010ebab:	89 c2                	mov    %eax,%edx
f010ebad:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebb0:	01 d0                	add    %edx,%eax
f010ebb2:	8a 40 04             	mov    0x4(%eax),%al
f010ebb5:	0f b6 c0             	movzbl %al,%eax
f010ebb8:	3b 45 14             	cmp    0x14(%ebp),%eax
f010ebbb:	75 d7                	jne    f010eb94 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010ebbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebc0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010ebc3:	7d 09                	jge    f010ebce <stab_binsearch+0x78>
			l = true_m + 1;
f010ebc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ebc8:	40                   	inc    %eax
f010ebc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010ebcc:	eb 74                	jmp    f010ec42 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010ebce:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010ebd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebd8:	89 d0                	mov    %edx,%eax
f010ebda:	01 c0                	add    %eax,%eax
f010ebdc:	01 d0                	add    %edx,%eax
f010ebde:	c1 e0 02             	shl    $0x2,%eax
f010ebe1:	89 c2                	mov    %eax,%edx
f010ebe3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebe6:	01 d0                	add    %edx,%eax
f010ebe8:	8b 40 08             	mov    0x8(%eax),%eax
f010ebeb:	3b 45 18             	cmp    0x18(%ebp),%eax
f010ebee:	73 11                	jae    f010ec01 <stab_binsearch+0xab>
			*region_left = m;
f010ebf0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebf3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebf6:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010ebf8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ebfb:	40                   	inc    %eax
f010ebfc:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010ebff:	eb 41                	jmp    f010ec42 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010ec01:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec04:	89 d0                	mov    %edx,%eax
f010ec06:	01 c0                	add    %eax,%eax
f010ec08:	01 d0                	add    %edx,%eax
f010ec0a:	c1 e0 02             	shl    $0x2,%eax
f010ec0d:	89 c2                	mov    %eax,%edx
f010ec0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec12:	01 d0                	add    %edx,%eax
f010ec14:	8b 40 08             	mov    0x8(%eax),%eax
f010ec17:	3b 45 18             	cmp    0x18(%ebp),%eax
f010ec1a:	76 14                	jbe    f010ec30 <stab_binsearch+0xda>
			*region_right = m - 1;
f010ec1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec1f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ec22:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec25:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010ec27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec2a:	48                   	dec    %eax
f010ec2b:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ec2e:	eb 12                	jmp    f010ec42 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010ec30:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec36:	89 10                	mov    %edx,(%eax)
			l = m;
f010ec38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec3b:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010ec3e:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010ec42:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ec45:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010ec48:	0f 8e 2a ff ff ff    	jle    f010eb78 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010ec4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec52:	75 0f                	jne    f010ec63 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010ec54:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec57:	8b 00                	mov    (%eax),%eax
f010ec59:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ec5c:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec5f:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010ec61:	eb 3d                	jmp    f010eca0 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010ec63:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec66:	8b 00                	mov    (%eax),%eax
f010ec68:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010ec6b:	eb 03                	jmp    f010ec70 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010ec6d:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010ec70:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec73:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010ec75:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010ec78:	7d 1e                	jge    f010ec98 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010ec7a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ec7d:	89 d0                	mov    %edx,%eax
f010ec7f:	01 c0                	add    %eax,%eax
f010ec81:	01 d0                	add    %edx,%eax
f010ec83:	c1 e0 02             	shl    $0x2,%eax
f010ec86:	89 c2                	mov    %eax,%edx
f010ec88:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec8b:	01 d0                	add    %edx,%eax
f010ec8d:	8a 40 04             	mov    0x4(%eax),%al
f010ec90:	0f b6 c0             	movzbl %al,%eax
f010ec93:	3b 45 14             	cmp    0x14(%ebp),%eax
f010ec96:	75 d5                	jne    f010ec6d <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010ec98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec9b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ec9e:	89 10                	mov    %edx,(%eax)
	}
}
f010eca0:	90                   	nop
f010eca1:	c9                   	leave  
f010eca2:	c3                   	ret    

f010eca3 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010eca3:	55                   	push   %ebp
f010eca4:	89 e5                	mov    %esp,%ebp
f010eca6:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010eca9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecac:	c7 00 08 72 12 f0    	movl   $0xf0127208,(%eax)
	info->eip_line = 0;
f010ecb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecb5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010ecbc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecbf:	c7 40 08 08 72 12 f0 	movl   $0xf0127208,0x8(%eax)
	info->eip_fn_namelen = 9;
f010ecc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecc9:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010ecd0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecd3:	8b 55 08             	mov    0x8(%ebp),%edx
f010ecd6:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010ecd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecdc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010ece3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ece6:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010eceb:	76 1e                	jbe    f010ed0b <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010eced:	c7 45 f4 9c 0f 13 f0 	movl   $0xf0130f9c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010ecf4:	c7 45 f0 18 3f 16 f0 	movl   $0xf0163f18,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010ecfb:	c7 45 ec 19 3f 16 f0 	movl   $0xf0163f19,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010ed02:	c7 45 e8 39 58 17 f0 	movl   $0xf0175839,-0x18(%ebp)
f010ed09:	eb 2a                	jmp    f010ed35 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010ed0b:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010ed12:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed15:	8b 00                	mov    (%eax),%eax
f010ed17:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010ed1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed1d:	8b 40 04             	mov    0x4(%eax),%eax
f010ed20:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010ed23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed26:	8b 40 08             	mov    0x8(%eax),%eax
f010ed29:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010ed2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed2f:	8b 40 0c             	mov    0xc(%eax),%eax
f010ed32:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010ed35:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed38:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ed3b:	76 0a                	jbe    f010ed47 <debuginfo_eip+0xa4>
f010ed3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed40:	48                   	dec    %eax
f010ed41:	8a 00                	mov    (%eax),%al
f010ed43:	84 c0                	test   %al,%al
f010ed45:	74 0a                	je     f010ed51 <debuginfo_eip+0xae>
		return -1;
f010ed47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ed4c:	e9 01 02 00 00       	jmp    f010ef52 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010ed51:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010ed58:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ed5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed5e:	29 c2                	sub    %eax,%edx
f010ed60:	89 d0                	mov    %edx,%eax
f010ed62:	c1 f8 02             	sar    $0x2,%eax
f010ed65:	89 c2                	mov    %eax,%edx
f010ed67:	89 d0                	mov    %edx,%eax
f010ed69:	c1 e0 02             	shl    $0x2,%eax
f010ed6c:	01 d0                	add    %edx,%eax
f010ed6e:	c1 e0 02             	shl    $0x2,%eax
f010ed71:	01 d0                	add    %edx,%eax
f010ed73:	c1 e0 02             	shl    $0x2,%eax
f010ed76:	01 d0                	add    %edx,%eax
f010ed78:	89 c1                	mov    %eax,%ecx
f010ed7a:	c1 e1 08             	shl    $0x8,%ecx
f010ed7d:	01 c8                	add    %ecx,%eax
f010ed7f:	89 c1                	mov    %eax,%ecx
f010ed81:	c1 e1 10             	shl    $0x10,%ecx
f010ed84:	01 c8                	add    %ecx,%eax
f010ed86:	01 c0                	add    %eax,%eax
f010ed88:	01 d0                	add    %edx,%eax
f010ed8a:	48                   	dec    %eax
f010ed8b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010ed8e:	ff 75 08             	pushl  0x8(%ebp)
f010ed91:	6a 64                	push   $0x64
f010ed93:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010ed96:	50                   	push   %eax
f010ed97:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010ed9a:	50                   	push   %eax
f010ed9b:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed9e:	e8 b3 fd ff ff       	call   f010eb56 <stab_binsearch>
f010eda3:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010eda6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010eda9:	85 c0                	test   %eax,%eax
f010edab:	75 0a                	jne    f010edb7 <debuginfo_eip+0x114>
		return -1;
f010edad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010edb2:	e9 9b 01 00 00       	jmp    f010ef52 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010edb7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010edba:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010edbd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010edc0:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010edc3:	ff 75 08             	pushl  0x8(%ebp)
f010edc6:	6a 24                	push   $0x24
f010edc8:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010edcb:	50                   	push   %eax
f010edcc:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010edcf:	50                   	push   %eax
f010edd0:	ff 75 f4             	pushl  -0xc(%ebp)
f010edd3:	e8 7e fd ff ff       	call   f010eb56 <stab_binsearch>
f010edd8:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010eddb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010edde:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ede1:	39 c2                	cmp    %eax,%edx
f010ede3:	0f 8f 86 00 00 00    	jg     f010ee6f <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010ede9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010edec:	89 c2                	mov    %eax,%edx
f010edee:	89 d0                	mov    %edx,%eax
f010edf0:	01 c0                	add    %eax,%eax
f010edf2:	01 d0                	add    %edx,%eax
f010edf4:	c1 e0 02             	shl    $0x2,%eax
f010edf7:	89 c2                	mov    %eax,%edx
f010edf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010edfc:	01 d0                	add    %edx,%eax
f010edfe:	8b 00                	mov    (%eax),%eax
f010ee00:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ee03:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ee06:	29 d1                	sub    %edx,%ecx
f010ee08:	89 ca                	mov    %ecx,%edx
f010ee0a:	39 d0                	cmp    %edx,%eax
f010ee0c:	73 22                	jae    f010ee30 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010ee0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ee11:	89 c2                	mov    %eax,%edx
f010ee13:	89 d0                	mov    %edx,%eax
f010ee15:	01 c0                	add    %eax,%eax
f010ee17:	01 d0                	add    %edx,%eax
f010ee19:	c1 e0 02             	shl    $0x2,%eax
f010ee1c:	89 c2                	mov    %eax,%edx
f010ee1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee21:	01 d0                	add    %edx,%eax
f010ee23:	8b 10                	mov    (%eax),%edx
f010ee25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee28:	01 c2                	add    %eax,%edx
f010ee2a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee2d:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010ee30:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ee33:	89 c2                	mov    %eax,%edx
f010ee35:	89 d0                	mov    %edx,%eax
f010ee37:	01 c0                	add    %eax,%eax
f010ee39:	01 d0                	add    %edx,%eax
f010ee3b:	c1 e0 02             	shl    $0x2,%eax
f010ee3e:	89 c2                	mov    %eax,%edx
f010ee40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee43:	01 d0                	add    %edx,%eax
f010ee45:	8b 50 08             	mov    0x8(%eax),%edx
f010ee48:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee4b:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010ee4e:	8b 55 08             	mov    0x8(%ebp),%edx
f010ee51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee54:	8b 40 10             	mov    0x10(%eax),%eax
f010ee57:	29 c2                	sub    %eax,%edx
f010ee59:	89 d0                	mov    %edx,%eax
f010ee5b:	c1 f8 02             	sar    $0x2,%eax
f010ee5e:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010ee61:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ee64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010ee67:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ee6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ee6d:	eb 15                	jmp    f010ee84 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010ee6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee72:	8b 55 08             	mov    0x8(%ebp),%edx
f010ee75:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010ee78:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ee7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010ee7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ee81:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010ee84:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee87:	8b 40 08             	mov    0x8(%eax),%eax
f010ee8a:	83 ec 08             	sub    $0x8,%esp
f010ee8d:	6a 3a                	push   $0x3a
f010ee8f:	50                   	push   %eax
f010ee90:	e8 33 09 01 00       	call   f011f7c8 <strfind>
f010ee95:	83 c4 10             	add    $0x10,%esp
f010ee98:	89 c2                	mov    %eax,%edx
f010ee9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee9d:	8b 40 08             	mov    0x8(%eax),%eax
f010eea0:	29 c2                	sub    %eax,%edx
f010eea2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eea5:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010eea8:	eb 03                	jmp    f010eead <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010eeaa:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010eead:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010eeb0:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010eeb3:	7c 4e                	jl     f010ef03 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010eeb5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eeb8:	89 d0                	mov    %edx,%eax
f010eeba:	01 c0                	add    %eax,%eax
f010eebc:	01 d0                	add    %edx,%eax
f010eebe:	c1 e0 02             	shl    $0x2,%eax
f010eec1:	89 c2                	mov    %eax,%edx
f010eec3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eec6:	01 d0                	add    %edx,%eax
f010eec8:	8a 40 04             	mov    0x4(%eax),%al
f010eecb:	3c 84                	cmp    $0x84,%al
f010eecd:	74 34                	je     f010ef03 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010eecf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eed2:	89 d0                	mov    %edx,%eax
f010eed4:	01 c0                	add    %eax,%eax
f010eed6:	01 d0                	add    %edx,%eax
f010eed8:	c1 e0 02             	shl    $0x2,%eax
f010eedb:	89 c2                	mov    %eax,%edx
f010eedd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eee0:	01 d0                	add    %edx,%eax
f010eee2:	8a 40 04             	mov    0x4(%eax),%al
f010eee5:	3c 64                	cmp    $0x64,%al
f010eee7:	75 c1                	jne    f010eeaa <debuginfo_eip+0x207>
f010eee9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eeec:	89 d0                	mov    %edx,%eax
f010eeee:	01 c0                	add    %eax,%eax
f010eef0:	01 d0                	add    %edx,%eax
f010eef2:	c1 e0 02             	shl    $0x2,%eax
f010eef5:	89 c2                	mov    %eax,%edx
f010eef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eefa:	01 d0                	add    %edx,%eax
f010eefc:	8b 40 08             	mov    0x8(%eax),%eax
f010eeff:	85 c0                	test   %eax,%eax
f010ef01:	74 a7                	je     f010eeaa <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010ef03:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ef06:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010ef09:	7c 42                	jl     f010ef4d <debuginfo_eip+0x2aa>
f010ef0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ef0e:	89 d0                	mov    %edx,%eax
f010ef10:	01 c0                	add    %eax,%eax
f010ef12:	01 d0                	add    %edx,%eax
f010ef14:	c1 e0 02             	shl    $0x2,%eax
f010ef17:	89 c2                	mov    %eax,%edx
f010ef19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef1c:	01 d0                	add    %edx,%eax
f010ef1e:	8b 00                	mov    (%eax),%eax
f010ef20:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ef23:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ef26:	29 d1                	sub    %edx,%ecx
f010ef28:	89 ca                	mov    %ecx,%edx
f010ef2a:	39 d0                	cmp    %edx,%eax
f010ef2c:	73 1f                	jae    f010ef4d <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010ef2e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ef31:	89 d0                	mov    %edx,%eax
f010ef33:	01 c0                	add    %eax,%eax
f010ef35:	01 d0                	add    %edx,%eax
f010ef37:	c1 e0 02             	shl    $0x2,%eax
f010ef3a:	89 c2                	mov    %eax,%edx
f010ef3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef3f:	01 d0                	add    %edx,%eax
f010ef41:	8b 10                	mov    (%eax),%edx
f010ef43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef46:	01 c2                	add    %eax,%edx
f010ef48:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef4b:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010ef4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef52:	c9                   	leave  
f010ef53:	c3                   	ret    

f010ef54 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010ef54:	55                   	push   %ebp
f010ef55:	89 e5                	mov    %esp,%ebp
f010ef57:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010ef5a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010ef5e:	74 1c                	je     f010ef7c <setPageReplacmentAlgorithmLRU+0x28>
f010ef60:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ef64:	74 16                	je     f010ef7c <setPageReplacmentAlgorithmLRU+0x28>
f010ef66:	68 14 72 12 f0       	push   $0xf0127214
f010ef6b:	68 5e 72 12 f0       	push   $0xf012725e
f010ef70:	6a 1a                	push   $0x1a
f010ef72:	68 73 72 12 f0       	push   $0xf0127273
f010ef77:	e8 bd 13 ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010ef7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef7f:	a3 10 da 6b f0       	mov    %eax,0xf06bda10
}
f010ef84:	90                   	nop
f010ef85:	c9                   	leave  
f010ef86:	c3                   	ret    

f010ef87 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010ef87:	55                   	push   %ebp
f010ef88:	89 e5                	mov    %esp,%ebp
f010ef8a:	c7 05 10 da 6b f0 03 	movl   $0x3,0xf06bda10
f010ef91:	00 00 00 
f010ef94:	90                   	nop
f010ef95:	5d                   	pop    %ebp
f010ef96:	c3                   	ret    

f010ef97 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010ef97:	55                   	push   %ebp
f010ef98:	89 e5                	mov    %esp,%ebp
f010ef9a:	c7 05 10 da 6b f0 04 	movl   $0x4,0xf06bda10
f010efa1:	00 00 00 
f010efa4:	90                   	nop
f010efa5:	5d                   	pop    %ebp
f010efa6:	c3                   	ret    

f010efa7 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010efa7:	55                   	push   %ebp
f010efa8:	89 e5                	mov    %esp,%ebp
f010efaa:	c7 05 10 da 6b f0 05 	movl   $0x5,0xf06bda10
f010efb1:	00 00 00 
f010efb4:	90                   	nop
f010efb5:	5d                   	pop    %ebp
f010efb6:	c3                   	ret    

f010efb7 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010efb7:	55                   	push   %ebp
f010efb8:	89 e5                	mov    %esp,%ebp
f010efba:	c7 05 10 da 6b f0 07 	movl   $0x7,0xf06bda10
f010efc1:	00 00 00 
f010efc4:	90                   	nop
f010efc5:	5d                   	pop    %ebp
f010efc6:	c3                   	ret    

f010efc7 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010efc7:	55                   	push   %ebp
f010efc8:	89 e5                	mov    %esp,%ebp
f010efca:	c7 05 10 da 6b f0 06 	movl   $0x6,0xf06bda10
f010efd1:	00 00 00 
f010efd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010efd7:	a3 54 d3 6b f0       	mov    %eax,0xf06bd354
f010efdc:	90                   	nop
f010efdd:	5d                   	pop    %ebp
f010efde:	c3                   	ret    

f010efdf <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010efdf:	55                   	push   %ebp
f010efe0:	89 e5                	mov    %esp,%ebp
f010efe2:	8b 15 10 da 6b f0    	mov    0xf06bda10,%edx
f010efe8:	8b 45 08             	mov    0x8(%ebp),%eax
f010efeb:	39 c2                	cmp    %eax,%edx
f010efed:	0f 94 c0             	sete   %al
f010eff0:	0f b6 c0             	movzbl %al,%eax
f010eff3:	5d                   	pop    %ebp
f010eff4:	c3                   	ret    

f010eff5 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010eff5:	55                   	push   %ebp
f010eff6:	89 e5                	mov    %esp,%ebp
f010eff8:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010effd:	83 f8 03             	cmp    $0x3,%eax
f010f000:	75 07                	jne    f010f009 <isPageReplacmentAlgorithmCLOCK+0x14>
f010f002:	b8 01 00 00 00       	mov    $0x1,%eax
f010f007:	eb 05                	jmp    f010f00e <isPageReplacmentAlgorithmCLOCK+0x19>
f010f009:	b8 00 00 00 00       	mov    $0x0,%eax
f010f00e:	5d                   	pop    %ebp
f010f00f:	c3                   	ret    

f010f010 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f010:	55                   	push   %ebp
f010f011:	89 e5                	mov    %esp,%ebp
f010f013:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f018:	83 f8 04             	cmp    $0x4,%eax
f010f01b:	75 07                	jne    f010f024 <isPageReplacmentAlgorithmFIFO+0x14>
f010f01d:	b8 01 00 00 00       	mov    $0x1,%eax
f010f022:	eb 05                	jmp    f010f029 <isPageReplacmentAlgorithmFIFO+0x19>
f010f024:	b8 00 00 00 00       	mov    $0x0,%eax
f010f029:	5d                   	pop    %ebp
f010f02a:	c3                   	ret    

f010f02b <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f02b:	55                   	push   %ebp
f010f02c:	89 e5                	mov    %esp,%ebp
f010f02e:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f033:	83 f8 05             	cmp    $0x5,%eax
f010f036:	75 07                	jne    f010f03f <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f038:	b8 01 00 00 00       	mov    $0x1,%eax
f010f03d:	eb 05                	jmp    f010f044 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f03f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f044:	5d                   	pop    %ebp
f010f045:	c3                   	ret    

f010f046 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f046:	55                   	push   %ebp
f010f047:	89 e5                	mov    %esp,%ebp
f010f049:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f04e:	83 f8 07             	cmp    $0x7,%eax
f010f051:	75 07                	jne    f010f05a <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f053:	b8 01 00 00 00       	mov    $0x1,%eax
f010f058:	eb 05                	jmp    f010f05f <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f05a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f05f:	5d                   	pop    %ebp
f010f060:	c3                   	ret    

f010f061 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f061:	55                   	push   %ebp
f010f062:	89 e5                	mov    %esp,%ebp
f010f064:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f069:	83 f8 06             	cmp    $0x6,%eax
f010f06c:	75 07                	jne    f010f075 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f06e:	b8 01 00 00 00       	mov    $0x1,%eax
f010f073:	eb 05                	jmp    f010f07a <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f075:	b8 00 00 00 00       	mov    $0x0,%eax
f010f07a:	5d                   	pop    %ebp
f010f07b:	c3                   	ret    

f010f07c <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f07c:	55                   	push   %ebp
f010f07d:	89 e5                	mov    %esp,%ebp
f010f07f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f082:	a3 b8 d7 6b f0       	mov    %eax,0xf06bd7b8
f010f087:	90                   	nop
f010f088:	5d                   	pop    %ebp
f010f089:	c3                   	ret    

f010f08a <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f08a:	55                   	push   %ebp
f010f08b:	89 e5                	mov    %esp,%ebp
f010f08d:	a1 b8 d7 6b f0       	mov    0xf06bd7b8,%eax
f010f092:	5d                   	pop    %ebp
f010f093:	c3                   	ret    

f010f094 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f094:	55                   	push   %ebp
f010f095:	89 e5                	mov    %esp,%ebp
f010f097:	8b 45 08             	mov    0x8(%ebp),%eax
f010f09a:	a3 94 da 6b f0       	mov    %eax,0xf06bda94
f010f09f:	90                   	nop
f010f0a0:	5d                   	pop    %ebp
f010f0a1:	c3                   	ret    

f010f0a2 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f0a2:	55                   	push   %ebp
f010f0a3:	89 e5                	mov    %esp,%ebp
f010f0a5:	a1 94 da 6b f0       	mov    0xf06bda94,%eax
f010f0aa:	5d                   	pop    %ebp
f010f0ab:	c3                   	ret    

f010f0ac <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f0ac:	55                   	push   %ebp
f010f0ad:	89 e5                	mov    %esp,%ebp
f010f0af:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0b2:	a3 30 db 6b f0       	mov    %eax,0xf06bdb30
f010f0b7:	90                   	nop
f010f0b8:	5d                   	pop    %ebp
f010f0b9:	c3                   	ret    

f010f0ba <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f0ba:	55                   	push   %ebp
f010f0bb:	89 e5                	mov    %esp,%ebp
f010f0bd:	a1 30 db 6b f0       	mov    0xf06bdb30,%eax
f010f0c2:	5d                   	pop    %ebp
f010f0c3:	c3                   	ret    

f010f0c4 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f0c4:	55                   	push   %ebp
f010f0c5:	89 e5                	mov    %esp,%ebp
f010f0c7:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f0ca:	0f 20 d0             	mov    %cr2,%eax
f010f0cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f0d0:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f0d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f0d6:	e8 c8 c2 ff ff       	call   f010b3a3 <get_cpu_proc>
f010f0db:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f0de:	a1 4c 50 69 f0       	mov    0xf069504c,%eax
f010f0e3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f0e6:	75 50                	jne    f010f138 <fault_handler+0x74>
f010f0e8:	a1 58 50 69 f0       	mov    0xf0695058,%eax
f010f0ed:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f0f0:	75 46                	jne    f010f138 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f0f2:	a0 54 50 69 f0       	mov    0xf0695054,%al
f010f0f7:	40                   	inc    %eax
f010f0f8:	a2 54 50 69 f0       	mov    %al,0xf0695054
		if (num_repeated_fault == 3)
f010f0fd:	a0 54 50 69 f0       	mov    0xf0695054,%al
f010f102:	3c 03                	cmp    $0x3,%al
f010f104:	75 4d                	jne    f010f153 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f106:	83 ec 0c             	sub    $0xc,%esp
f010f109:	ff 75 08             	pushl  0x8(%ebp)
f010f10c:	e8 48 e9 ff ff       	call   f010da59 <print_trapframe>
f010f111:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f114:	8b 15 48 50 69 f0    	mov    0xf0695048,%edx
f010f11a:	a1 50 50 69 f0       	mov    0xf0695050,%eax
f010f11f:	83 ec 08             	sub    $0x8,%esp
f010f122:	ff 75 ec             	pushl  -0x14(%ebp)
f010f125:	52                   	push   %edx
f010f126:	50                   	push   %eax
f010f127:	68 90 72 12 f0       	push   $0xf0127290
f010f12c:	6a 58                	push   $0x58
f010f12e:	68 73 72 12 f0       	push   $0xf0127273
f010f133:	e8 01 12 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f138:	a1 4c 50 69 f0       	mov    0xf069504c,%eax
f010f13d:	a3 50 50 69 f0       	mov    %eax,0xf0695050
		before_last_eip = last_eip;
f010f142:	a1 44 50 69 f0       	mov    0xf0695044,%eax
f010f147:	a3 48 50 69 f0       	mov    %eax,0xf0695048
		num_repeated_fault = 0;
f010f14c:	c6 05 54 50 69 f0 00 	movb   $0x0,0xf0695054
	}
	last_eip = (uint32)tf->tf_eip;
f010f153:	8b 45 08             	mov    0x8(%ebp),%eax
f010f156:	8b 40 30             	mov    0x30(%eax),%eax
f010f159:	a3 44 50 69 f0       	mov    %eax,0xf0695044
	last_fault_va = fault_va ;
f010f15e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f161:	a3 4c 50 69 f0       	mov    %eax,0xf069504c
	last_faulted_env = cur_env;
f010f166:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f169:	a3 58 50 69 f0       	mov    %eax,0xf0695058
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f16e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f175:	8b 45 08             	mov    0x8(%ebp),%eax
f010f178:	8b 40 34             	mov    0x34(%eax),%eax
f010f17b:	0f b7 c0             	movzwl %ax,%eax
f010f17e:	83 e0 03             	and    $0x3,%eax
f010f181:	83 f8 03             	cmp    $0x3,%eax
f010f184:	75 07                	jne    f010f18d <fault_handler+0xc9>
		userTrap = 1;
f010f186:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f18d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f191:	0f 85 c2 00 00 00    	jne    f010f259 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f197:	e8 70 7f ff ff       	call   f010710c <mycpu>
f010f19c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f19f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f1a3:	74 2f                	je     f010f1d4 <fault_handler+0x110>
f010f1a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f1a8:	8b 40 70             	mov    0x70(%eax),%eax
f010f1ab:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1ae:	77 24                	ja     f010f1d4 <fault_handler+0x110>
f010f1b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f1b3:	8b 40 70             	mov    0x70(%eax),%eax
f010f1b6:	05 00 10 00 00       	add    $0x1000,%eax
f010f1bb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1be:	76 14                	jbe    f010f1d4 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f1c0:	83 ec 04             	sub    $0x4,%esp
f010f1c3:	68 00 73 12 f0       	push   $0xf0127300
f010f1c8:	6a 6f                	push   $0x6f
f010f1ca:	68 73 72 12 f0       	push   $0xf0127273
f010f1cf:	e8 65 11 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f1d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1d7:	8b 40 08             	mov    0x8(%eax),%eax
f010f1da:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1dd:	77 5d                	ja     f010f23c <fault_handler+0x178>
f010f1df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1e2:	8b 40 08             	mov    0x8(%eax),%eax
f010f1e5:	05 00 10 00 00       	add    $0x1000,%eax
f010f1ea:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1ed:	76 4d                	jbe    f010f23c <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f1ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1f2:	ba a0 d4 6b f0       	mov    $0xf06bd4a0,%edx
f010f1f7:	29 d0                	sub    %edx,%eax
f010f1f9:	c1 f8 03             	sar    $0x3,%eax
f010f1fc:	89 c2                	mov    %eax,%edx
f010f1fe:	89 d0                	mov    %edx,%eax
f010f200:	c1 e0 02             	shl    $0x2,%eax
f010f203:	01 d0                	add    %edx,%eax
f010f205:	01 c0                	add    %eax,%eax
f010f207:	01 d0                	add    %edx,%eax
f010f209:	c1 e0 03             	shl    $0x3,%eax
f010f20c:	01 d0                	add    %edx,%eax
f010f20e:	89 c1                	mov    %eax,%ecx
f010f210:	c1 e1 0b             	shl    $0xb,%ecx
f010f213:	01 c8                	add    %ecx,%eax
f010f215:	c1 e0 05             	shl    $0x5,%eax
f010f218:	01 d0                	add    %edx,%eax
f010f21a:	c1 e0 02             	shl    $0x2,%eax
f010f21d:	01 d0                	add    %edx,%eax
f010f21f:	01 c0                	add    %eax,%eax
f010f221:	01 d0                	add    %edx,%eax
f010f223:	c1 e0 03             	shl    $0x3,%eax
f010f226:	01 d0                	add    %edx,%eax
f010f228:	f7 d8                	neg    %eax
f010f22a:	50                   	push   %eax
f010f22b:	68 28 73 12 f0       	push   $0xf0127328
f010f230:	6a 71                	push   $0x71
f010f232:	68 73 72 12 f0       	push   $0xf0127273
f010f237:	e8 fd 10 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f23c:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f243:	76 3a                	jbe    f010f27f <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f245:	83 ec 04             	sub    $0x4,%esp
f010f248:	68 5c 73 12 f0       	push   $0xf012735c
f010f24d:	6a 74                	push   $0x74
f010f24f:	68 73 72 12 f0       	push   $0xf0127273
f010f254:	e8 e0 10 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f259:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f260:	76 1d                	jbe    f010f27f <fault_handler+0x1bb>
f010f262:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f269:	77 14                	ja     f010f27f <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f26b:	83 ec 04             	sub    $0x4,%esp
f010f26e:	68 80 73 12 f0       	push   $0xf0127380
f010f273:	6a 7c                	push   $0x7c
f010f275:	68 73 72 12 f0       	push   $0xf0127273
f010f27a:	e8 ba 10 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f27f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f282:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f285:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f289:	75 25                	jne    f010f2b0 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f28b:	83 ec 0c             	sub    $0xc,%esp
f010f28e:	ff 75 08             	pushl  0x8(%ebp)
f010f291:	e8 c3 e7 ff ff       	call   f010da59 <print_trapframe>
f010f296:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f299:	83 ec 04             	sub    $0x4,%esp
f010f29c:	68 a1 73 12 f0       	push   $0xf01273a1
f010f2a1:	68 85 00 00 00       	push   $0x85
f010f2a6:	68 73 72 12 f0       	push   $0xf0127273
f010f2ab:	e8 89 10 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f2b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2b3:	8b 40 64             	mov    0x64(%eax),%eax
f010f2b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f2b9:	c1 ea 16             	shr    $0x16,%edx
f010f2bc:	c1 e2 02             	shl    $0x2,%edx
f010f2bf:	01 d0                	add    %edx,%eax
f010f2c1:	8b 00                	mov    (%eax),%eax
f010f2c3:	83 e0 01             	and    $0x1,%eax
f010f2c6:	85 c0                	test   %eax,%eax
f010f2c8:	75 2b                	jne    f010f2f5 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f2ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2cd:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f2d3:	8d 50 01             	lea    0x1(%eax),%edx
f010f2d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2d9:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f2df:	83 ec 08             	sub    $0x8,%esp
f010f2e2:	ff 75 ec             	pushl  -0x14(%ebp)
f010f2e5:	ff 75 e0             	pushl  -0x20(%ebp)
f010f2e8:	e8 31 01 00 00       	call   f010f41e <table_fault_handler>
f010f2ed:	83 c4 10             	add    $0x10,%esp
f010f2f0:	e9 1a 01 00 00       	jmp    f010f40f <fault_handler+0x34b>
	}
	else
	{
		if (userTrap)
f010f2f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f2f9:	0f 84 95 00 00 00    	je     f010f394 <fault_handler+0x2d0>
		{
			/*============================================================================================*/
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f2ff:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f306:	76 0a                	jbe    f010f312 <fault_handler+0x24e>
			{
				env_exit();
f010f308:	e8 54 c0 ff ff       	call   f010b361 <env_exit>
f010f30d:	e9 82 00 00 00       	jmp    f010f394 <fault_handler+0x2d0>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f312:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f315:	8b 40 64             	mov    0x64(%eax),%eax
f010f318:	83 ec 08             	sub    $0x8,%esp
f010f31b:	ff 75 ec             	pushl  -0x14(%ebp)
f010f31e:	50                   	push   %eax
f010f31f:	e8 83 a3 ff ff       	call   f01096a7 <pt_get_page_permissions>
f010f324:	83 c4 10             	add    $0x10,%esp
f010f327:	25 00 02 00 00       	and    $0x200,%eax
f010f32c:	85 c0                	test   %eax,%eax
f010f32e:	75 27                	jne    f010f357 <fault_handler+0x293>
f010f330:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f333:	85 c0                	test   %eax,%eax
f010f335:	79 20                	jns    f010f357 <fault_handler+0x293>
f010f337:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f33e:	77 17                	ja     f010f357 <fault_handler+0x293>
			{
				cprintf("exit2\n");
f010f340:	83 ec 0c             	sub    $0xc,%esp
f010f343:	68 b6 73 12 f0       	push   $0xf01273b6
f010f348:	e8 3e 1c ff ff       	call   f0100f8b <cprintf>
f010f34d:	83 c4 10             	add    $0x10,%esp
			env_exit();
f010f350:	e8 0c c0 ff ff       	call   f010b361 <env_exit>
f010f355:	eb 3d                	jmp    f010f394 <fault_handler+0x2d0>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE) != PERM_WRITEABLE)
f010f357:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f35a:	8b 40 64             	mov    0x64(%eax),%eax
f010f35d:	83 ec 08             	sub    $0x8,%esp
f010f360:	ff 75 ec             	pushl  -0x14(%ebp)
f010f363:	50                   	push   %eax
f010f364:	e8 3e a3 ff ff       	call   f01096a7 <pt_get_page_permissions>
f010f369:	83 c4 10             	add    $0x10,%esp
f010f36c:	83 e0 01             	and    $0x1,%eax
f010f36f:	85 c0                	test   %eax,%eax
f010f371:	74 21                	je     f010f394 <fault_handler+0x2d0>
f010f373:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f376:	8b 40 64             	mov    0x64(%eax),%eax
f010f379:	83 ec 08             	sub    $0x8,%esp
f010f37c:	ff 75 ec             	pushl  -0x14(%ebp)
f010f37f:	50                   	push   %eax
f010f380:	e8 22 a3 ff ff       	call   f01096a7 <pt_get_page_permissions>
f010f385:	83 c4 10             	add    $0x10,%esp
f010f388:	83 e0 02             	and    $0x2,%eax
f010f38b:	85 c0                	test   %eax,%eax
f010f38d:	75 05                	jne    f010f394 <fault_handler+0x2d0>
			{
				env_exit();
f010f38f:	e8 cd bf ff ff       	call   f010b361 <env_exit>
			}
			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010f394:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f397:	8b 40 64             	mov    0x64(%eax),%eax
f010f39a:	83 ec 08             	sub    $0x8,%esp
f010f39d:	ff 75 ec             	pushl  -0x14(%ebp)
f010f3a0:	50                   	push   %eax
f010f3a1:	e8 01 a3 ff ff       	call   f01096a7 <pt_get_page_permissions>
f010f3a6:	83 c4 10             	add    $0x10,%esp
f010f3a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010f3ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f3af:	83 e0 01             	and    $0x1,%eax
f010f3b2:	85 c0                	test   %eax,%eax
f010f3b4:	74 17                	je     f010f3cd <fault_handler+0x309>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010f3b6:	ff 75 ec             	pushl  -0x14(%ebp)
f010f3b9:	68 c0 73 12 f0       	push   $0xf01273c0
f010f3be:	68 ae 00 00 00       	push   $0xae
f010f3c3:	68 73 72 12 f0       	push   $0xf0127273
f010f3c8:	e8 6c 0f ff ff       	call   f0100339 <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010f3cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3d0:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010f3d6:	8d 50 01             	lea    0x1(%eax),%edx
f010f3d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3dc:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010f3e2:	e8 bb fc ff ff       	call   f010f0a2 <isBufferingEnabled>
f010f3e7:	84 c0                	test   %al,%al
f010f3e9:	74 13                	je     f010f3fe <fault_handler+0x33a>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010f3eb:	83 ec 08             	sub    $0x8,%esp
f010f3ee:	ff 75 ec             	pushl  -0x14(%ebp)
f010f3f1:	ff 75 e0             	pushl  -0x20(%ebp)
f010f3f4:	e8 fe 01 00 00       	call   f010f5f7 <__page_fault_handler_with_buffering>
f010f3f9:	83 c4 10             	add    $0x10,%esp
f010f3fc:	eb 11                	jmp    f010f40f <fault_handler+0x34b>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010f3fe:	83 ec 08             	sub    $0x8,%esp
f010f401:	ff 75 ec             	pushl  -0x14(%ebp)
f010f404:	ff 75 e0             	pushl  -0x20(%ebp)
f010f407:	e8 33 00 00 00       	call   f010f43f <page_fault_handler>
f010f40c:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010f40f:	0f 20 d8             	mov    %cr3,%eax
f010f412:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010f415:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f418:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010f41b:	90                   	nop
f010f41c:	c9                   	leave  
f010f41d:	c3                   	ret    

f010f41e <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010f41e:	55                   	push   %ebp
f010f41f:	89 e5                	mov    %esp,%ebp
f010f421:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010f424:	8b 45 08             	mov    0x8(%ebp),%eax
f010f427:	8b 40 64             	mov    0x64(%eax),%eax
f010f42a:	83 ec 08             	sub    $0x8,%esp
f010f42d:	ff 75 0c             	pushl  0xc(%ebp)
f010f430:	50                   	push   %eax
f010f431:	e8 0f 91 ff ff       	call   f0108545 <create_page_table>
f010f436:	83 c4 10             	add    $0x10,%esp
f010f439:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010f43c:	90                   	nop
f010f43d:	c9                   	leave  
f010f43e:	c3                   	ret    

f010f43f <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010f43f:	55                   	push   %ebp
f010f440:	89 e5                	mov    %esp,%ebp
f010f442:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010f445:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010f44c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f44f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f455:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010f458:	8b 45 08             	mov    0x8(%ebp),%eax
f010f45b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f461:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f464:	0f 86 74 01 00 00    	jbe    f010f5de <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010f46a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f46d:	83 ec 08             	sub    $0x8,%esp
f010f470:	50                   	push   %eax
f010f471:	ff 75 08             	pushl  0x8(%ebp)
f010f474:	e8 68 50 ff ff       	call   f01044e1 <pf_read_env_page>
f010f479:	83 c4 10             	add    $0x10,%esp
f010f47c:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010f47f:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010f483:	75 45                	jne    f010f4ca <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010f485:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f488:	85 c0                	test   %eax,%eax
f010f48a:	79 09                	jns    f010f495 <page_fault_handler+0x56>
f010f48c:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010f493:	76 35                	jbe    f010f4ca <page_fault_handler+0x8b>
f010f495:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010f49c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f49f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010f4a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010f4a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f4aa:	ba 00 00 00 00       	mov    $0x0,%edx
f010f4af:	f7 75 e8             	divl   -0x18(%ebp)
f010f4b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f4b5:	29 d0                	sub    %edx,%eax
f010f4b7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010f4ba:	77 09                	ja     f010f4c5 <page_fault_handler+0x86>
f010f4bc:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010f4c3:	76 05                	jbe    f010f4ca <page_fault_handler+0x8b>
			{
				env_exit();
f010f4c5:	e8 97 be ff ff       	call   f010b361 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010f4ca:	83 ec 0c             	sub    $0xc,%esp
f010f4cd:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f4d0:	50                   	push   %eax
f010f4d1:	e8 dc 8c ff ff       	call   f01081b2 <allocate_frame>
f010f4d6:	83 c4 10             	add    $0x10,%esp
f010f4d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010f4dc:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010f4e0:	74 34                	je     f010f516 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010f4e2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010f4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4e8:	8b 40 64             	mov    0x64(%eax),%eax
f010f4eb:	6a 06                	push   $0x6
f010f4ed:	ff 75 0c             	pushl  0xc(%ebp)
f010f4f0:	52                   	push   %edx
f010f4f1:	50                   	push   %eax
f010f4f2:	e8 88 91 ff ff       	call   f010867f <map_frame>
f010f4f7:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010f4fa:	83 ec 08             	sub    $0x8,%esp
f010f4fd:	ff 75 0c             	pushl  0xc(%ebp)
f010f500:	ff 75 08             	pushl  0x8(%ebp)
f010f503:	e8 11 a3 ff ff       	call   f0109819 <env_page_ws_list_create_element>
f010f508:	83 c4 10             	add    $0x10,%esp
f010f50b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f50e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010f512:	75 30                	jne    f010f544 <page_fault_handler+0x105>
f010f514:	eb 17                	jmp    f010f52d <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010f516:	83 ec 04             	sub    $0x4,%esp
f010f519:	68 04 74 12 f0       	push   $0xf0127404
f010f51e:	68 04 01 00 00       	push   $0x104
f010f523:	68 73 72 12 f0       	push   $0xf0127273
f010f528:	e8 0c 0e ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f52d:	83 ec 04             	sub    $0x4,%esp
f010f530:	68 1c 74 12 f0       	push   $0xf012741c
f010f535:	68 06 01 00 00       	push   $0x106
f010f53a:	68 73 72 12 f0       	push   $0xf0127273
f010f53f:	e8 f5 0d ff ff       	call   f0100339 <_panic>
f010f544:	8b 45 08             	mov    0x8(%ebp),%eax
f010f547:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010f54d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f550:	89 50 14             	mov    %edx,0x14(%eax)
f010f553:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f556:	8b 40 14             	mov    0x14(%eax),%eax
f010f559:	85 c0                	test   %eax,%eax
f010f55b:	74 11                	je     f010f56e <page_fault_handler+0x12f>
f010f55d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f560:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010f566:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f569:	89 50 10             	mov    %edx,0x10(%eax)
f010f56c:	eb 0c                	jmp    f010f57a <page_fault_handler+0x13b>
f010f56e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f571:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f574:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010f57a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f57d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f580:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010f586:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f589:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010f590:	8b 45 08             	mov    0x8(%ebp),%eax
f010f593:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f599:	8d 50 01             	lea    0x1(%eax),%edx
f010f59c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f59f:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010f5a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5a8:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010f5ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5b1:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f5b7:	39 c2                	cmp    %eax,%edx
f010f5b9:	75 14                	jne    f010f5cf <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010f5bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5be:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010f5c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5c7:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f5cd:	eb 26                	jmp    f010f5f5 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010f5cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5d2:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010f5d9:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f5dc:	eb 17                	jmp    f010f5f5 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010f5de:	83 ec 04             	sub    $0x4,%esp
f010f5e1:	68 40 74 12 f0       	push   $0xf0127440
f010f5e6:	68 16 01 00 00       	push   $0x116
f010f5eb:	68 73 72 12 f0       	push   $0xf0127273
f010f5f0:	e8 44 0d ff ff       	call   f0100339 <_panic>
	}
}
f010f5f5:	c9                   	leave  
f010f5f6:	c3                   	ret    

f010f5f7 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010f5f7:	55                   	push   %ebp
f010f5f8:	89 e5                	mov    %esp,%ebp
f010f5fa:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010f5fd:	83 ec 04             	sub    $0x4,%esp
f010f600:	68 80 74 12 f0       	push   $0xf0127480
f010f605:	68 1e 01 00 00       	push   $0x11e
f010f60a:	68 73 72 12 f0       	push   $0xf0127273
f010f60f:	e8 25 0d ff ff       	call   f0100339 <_panic>

f010f614 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010f614:	55                   	push   %ebp
f010f615:	89 e5                	mov    %esp,%ebp
f010f617:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010f61a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f61d:	83 c0 04             	add    $0x4,%eax
f010f620:	83 ec 08             	sub    $0x8,%esp
f010f623:	ff 75 0c             	pushl  0xc(%ebp)
f010f626:	50                   	push   %eax
f010f627:	e8 29 00 01 00       	call   f011f655 <strcpy>
f010f62c:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f62f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f632:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010f638:	8b 45 08             	mov    0x8(%ebp),%eax
f010f63b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010f642:	90                   	nop
f010f643:	c9                   	leave  
f010f644:	c3                   	ret    

f010f645 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010f645:	55                   	push   %ebp
f010f646:	89 e5                	mov    %esp,%ebp
f010f648:	53                   	push   %ebx
f010f649:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010f64c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f64f:	83 ec 0c             	sub    $0xc,%esp
f010f652:	50                   	push   %eax
f010f653:	e8 06 02 00 00       	call   f010f85e <holding_spinlock>
f010f658:	83 c4 10             	add    $0x10,%esp
f010f65b:	85 c0                	test   %eax,%eax
f010f65d:	74 18                	je     f010f677 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010f65f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f662:	83 c0 04             	add    $0x4,%eax
f010f665:	50                   	push   %eax
f010f666:	68 c4 74 12 f0       	push   $0xf01274c4
f010f66b:	6a 1f                	push   $0x1f
f010f66d:	68 01 75 12 f0       	push   $0xf0127501
f010f672:	e8 c2 0c ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010f677:	e8 53 7b ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010f67c:	90                   	nop
f010f67d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f680:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010f683:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010f68a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f68d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f690:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010f693:	f0 87 02             	lock xchg %eax,(%edx)
f010f696:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010f699:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f69c:	85 c0                	test   %eax,%eax
f010f69e:	75 dd                	jne    f010f67d <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010f6a0:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010f6a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010f6a8:	e8 5f 7a ff ff       	call   f010710c <mycpu>
f010f6ad:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010f6b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6b3:	83 c0 48             	add    $0x48,%eax
f010f6b6:	83 ec 08             	sub    $0x8,%esp
f010f6b9:	50                   	push   %eax
f010f6ba:	8d 45 08             	lea    0x8(%ebp),%eax
f010f6bd:	50                   	push   %eax
f010f6be:	e8 74 00 00 00       	call   f010f737 <getcallerpcs>
f010f6c3:	83 c4 10             	add    $0x10,%esp

}
f010f6c6:	90                   	nop
f010f6c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f6ca:	c9                   	leave  
f010f6cb:	c3                   	ret    

f010f6cc <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010f6cc:	55                   	push   %ebp
f010f6cd:	89 e5                	mov    %esp,%ebp
f010f6cf:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010f6d2:	83 ec 0c             	sub    $0xc,%esp
f010f6d5:	ff 75 08             	pushl  0x8(%ebp)
f010f6d8:	e8 81 01 00 00       	call   f010f85e <holding_spinlock>
f010f6dd:	83 c4 10             	add    $0x10,%esp
f010f6e0:	85 c0                	test   %eax,%eax
f010f6e2:	75 26                	jne    f010f70a <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010f6e4:	83 ec 0c             	sub    $0xc,%esp
f010f6e7:	ff 75 08             	pushl  0x8(%ebp)
f010f6ea:	e8 08 01 00 00       	call   f010f7f7 <printcallstack>
f010f6ef:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010f6f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6f5:	83 c0 04             	add    $0x4,%eax
f010f6f8:	50                   	push   %eax
f010f6f9:	68 18 75 12 f0       	push   $0xf0127518
f010f6fe:	6a 3c                	push   $0x3c
f010f700:	68 01 75 12 f0       	push   $0xf0127501
f010f705:	e8 2f 0c ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010f70a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f70d:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010f714:	8b 45 08             	mov    0x8(%ebp),%eax
f010f717:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010f71e:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010f723:	8b 45 08             	mov    0x8(%ebp),%eax
f010f726:	8b 55 08             	mov    0x8(%ebp),%edx
f010f729:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010f72f:	e8 ed 7a ff ff       	call   f0107221 <popcli>
}
f010f734:	90                   	nop
f010f735:	c9                   	leave  
f010f736:	c3                   	ret    

f010f737 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010f737:	55                   	push   %ebp
f010f738:	89 e5                	mov    %esp,%ebp
f010f73a:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010f73d:	e8 61 bc ff ff       	call   f010b3a3 <get_cpu_proc>
f010f742:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010f745:	e8 c2 79 ff ff       	call   f010710c <mycpu>
f010f74a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010f74d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f750:	83 e8 08             	sub    $0x8,%eax
f010f753:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010f756:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010f75d:	eb 67                	jmp    f010f7c6 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f75f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f763:	74 67                	je     f010f7cc <getcallerpcs+0x95>
f010f765:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010f76c:	76 5e                	jbe    f010f7cc <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f76e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f771:	8b 40 08             	mov    0x8(%eax),%eax
f010f774:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f779:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f77c:	77 10                	ja     f010f78e <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f77e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f781:	8b 40 08             	mov    0x8(%eax),%eax
f010f784:	05 00 90 00 00       	add    $0x9000,%eax
f010f789:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f78c:	77 3e                	ja     f010f7cc <getcallerpcs+0x95>
f010f78e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f792:	74 10                	je     f010f7a4 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010f794:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f797:	8b 40 70             	mov    0x70(%eax),%eax
f010f79a:	05 00 80 00 00       	add    $0x8000,%eax
f010f79f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f7a2:	76 28                	jbe    f010f7cc <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010f7a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f7a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f7ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7b1:	01 c2                	add    %eax,%edx
f010f7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7b6:	8b 40 04             	mov    0x4(%eax),%eax
f010f7b9:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010f7bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7be:	8b 00                	mov    (%eax),%eax
f010f7c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010f7c3:	ff 45 f0             	incl   -0x10(%ebp)
f010f7c6:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f7ca:	7e 93                	jle    f010f75f <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010f7cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f7cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010f7d2:	eb 18                	jmp    f010f7ec <getcallerpcs+0xb5>
		pcs[i] = 0;
f010f7d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f7d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f7de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7e1:	01 d0                	add    %edx,%eax
f010f7e3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010f7e9:	ff 45 f0             	incl   -0x10(%ebp)
f010f7ec:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f7f0:	7e e2                	jle    f010f7d4 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010f7f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010f7f5:	c9                   	leave  
f010f7f6:	c3                   	ret    

f010f7f7 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010f7f7:	55                   	push   %ebp
f010f7f8:	89 e5                	mov    %esp,%ebp
f010f7fa:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010f7fd:	83 ec 0c             	sub    $0xc,%esp
f010f800:	68 56 75 12 f0       	push   $0xf0127556
f010f805:	e8 81 17 ff ff       	call   f0100f8b <cprintf>
f010f80a:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010f80d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f810:	83 c0 48             	add    $0x48,%eax
f010f813:	83 ec 08             	sub    $0x8,%esp
f010f816:	50                   	push   %eax
f010f817:	8d 45 08             	lea    0x8(%ebp),%eax
f010f81a:	50                   	push   %eax
f010f81b:	e8 17 ff ff ff       	call   f010f737 <getcallerpcs>
f010f820:	83 c4 10             	add    $0x10,%esp
f010f823:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010f826:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f82d:	eb 24                	jmp    f010f853 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010f82f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f832:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f835:	83 c2 10             	add    $0x10,%edx
f010f838:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010f83c:	83 ec 04             	sub    $0x4,%esp
f010f83f:	50                   	push   %eax
f010f840:	ff 75 f4             	pushl  -0xc(%ebp)
f010f843:	68 66 75 12 f0       	push   $0xf0127566
f010f848:	e8 3e 17 ff ff       	call   f0100f8b <cprintf>
f010f84d:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010f850:	ff 45 f4             	incl   -0xc(%ebp)
f010f853:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f856:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f859:	7c d4                	jl     f010f82f <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010f85b:	90                   	nop
f010f85c:	c9                   	leave  
f010f85d:	c3                   	ret    

f010f85e <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010f85e:	55                   	push   %ebp
f010f85f:	89 e5                	mov    %esp,%ebp
f010f861:	53                   	push   %ebx
f010f862:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010f865:	e8 65 79 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010f86a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f86d:	8b 00                	mov    (%eax),%eax
f010f86f:	85 c0                	test   %eax,%eax
f010f871:	74 16                	je     f010f889 <holding_spinlock+0x2b>
f010f873:	8b 45 08             	mov    0x8(%ebp),%eax
f010f876:	8b 58 44             	mov    0x44(%eax),%ebx
f010f879:	e8 8e 78 ff ff       	call   f010710c <mycpu>
f010f87e:	39 c3                	cmp    %eax,%ebx
f010f880:	75 07                	jne    f010f889 <holding_spinlock+0x2b>
f010f882:	b8 01 00 00 00       	mov    $0x1,%eax
f010f887:	eb 05                	jmp    f010f88e <holding_spinlock+0x30>
f010f889:	b8 00 00 00 00       	mov    $0x0,%eax
f010f88e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010f891:	e8 8b 79 ff ff       	call   f0107221 <popcli>
	return r;
f010f896:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f899:	83 c4 14             	add    $0x14,%esp
f010f89c:	5b                   	pop    %ebx
f010f89d:	5d                   	pop    %ebp
f010f89e:	c3                   	ret    

f010f89f <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010f89f:	55                   	push   %ebp
f010f8a0:	89 e5                	mov    %esp,%ebp
f010f8a2:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010f8a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8a8:	83 c0 74             	add    $0x74,%eax
f010f8ab:	83 ec 08             	sub    $0x8,%esp
f010f8ae:	68 75 75 12 f0       	push   $0xf0127575
f010f8b3:	50                   	push   %eax
f010f8b4:	e8 4c 01 00 00       	call   f010fa05 <init_channel>
f010f8b9:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010f8bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8bf:	83 c0 04             	add    $0x4,%eax
f010f8c2:	83 ec 08             	sub    $0x8,%esp
f010f8c5:	68 88 75 12 f0       	push   $0xf0127588
f010f8ca:	50                   	push   %eax
f010f8cb:	e8 44 fd ff ff       	call   f010f614 <init_spinlock>
f010f8d0:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010f8d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8d6:	05 c4 00 00 00       	add    $0xc4,%eax
f010f8db:	83 ec 08             	sub    $0x8,%esp
f010f8de:	ff 75 0c             	pushl  0xc(%ebp)
f010f8e1:	50                   	push   %eax
f010f8e2:	e8 6e fd 00 00       	call   f011f655 <strcpy>
f010f8e7:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f8ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010f8f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8f6:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010f8fd:	00 00 00 
}
f010f900:	90                   	nop
f010f901:	c9                   	leave  
f010f902:	c3                   	ret    

f010f903 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010f903:	55                   	push   %ebp
f010f904:	89 e5                	mov    %esp,%ebp
f010f906:	53                   	push   %ebx
f010f907:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010f90a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f90d:	83 c0 04             	add    $0x4,%eax
f010f910:	83 ec 0c             	sub    $0xc,%esp
f010f913:	50                   	push   %eax
f010f914:	e8 2c fd ff ff       	call   f010f645 <acquire_spinlock>
f010f919:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010f91c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f91f:	8b 00                	mov    (%eax),%eax
f010f921:	85 c0                	test   %eax,%eax
f010f923:	74 1c                	je     f010f941 <holding_sleeplock+0x3e>
f010f925:	8b 45 08             	mov    0x8(%ebp),%eax
f010f928:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010f92e:	e8 70 ba ff ff       	call   f010b3a3 <get_cpu_proc>
f010f933:	8b 40 10             	mov    0x10(%eax),%eax
f010f936:	39 c3                	cmp    %eax,%ebx
f010f938:	75 07                	jne    f010f941 <holding_sleeplock+0x3e>
f010f93a:	b8 01 00 00 00       	mov    $0x1,%eax
f010f93f:	eb 05                	jmp    f010f946 <holding_sleeplock+0x43>
f010f941:	b8 00 00 00 00       	mov    $0x0,%eax
f010f946:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010f949:	8b 45 08             	mov    0x8(%ebp),%eax
f010f94c:	83 c0 04             	add    $0x4,%eax
f010f94f:	83 ec 0c             	sub    $0xc,%esp
f010f952:	50                   	push   %eax
f010f953:	e8 74 fd ff ff       	call   f010f6cc <release_spinlock>
f010f958:	83 c4 10             	add    $0x10,%esp
	return r;
f010f95b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f95e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f961:	c9                   	leave  
f010f962:	c3                   	ret    

f010f963 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010f963:	55                   	push   %ebp
f010f964:	89 e5                	mov    %esp,%ebp
f010f966:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f969:	8b 45 08             	mov    0x8(%ebp),%eax
f010f96c:	83 c0 04             	add    $0x4,%eax
f010f96f:	83 ec 0c             	sub    $0xc,%esp
f010f972:	50                   	push   %eax
f010f973:	e8 cd fc ff ff       	call   f010f645 <acquire_spinlock>
f010f978:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010f97b:	eb 19                	jmp    f010f996 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010f97d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f980:	8d 50 04             	lea    0x4(%eax),%edx
f010f983:	8b 45 08             	mov    0x8(%ebp),%eax
f010f986:	83 c0 74             	add    $0x74,%eax
f010f989:	83 ec 08             	sub    $0x8,%esp
f010f98c:	52                   	push   %edx
f010f98d:	50                   	push   %eax
f010f98e:	e8 9f 00 00 00       	call   f010fa32 <sleep>
f010f993:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010f996:	8b 45 08             	mov    0x8(%ebp),%eax
f010f999:	8b 00                	mov    (%eax),%eax
f010f99b:	85 c0                	test   %eax,%eax
f010f99d:	75 de                	jne    f010f97d <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010f99f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9a2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010f9a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9ab:	83 c0 04             	add    $0x4,%eax
f010f9ae:	83 ec 0c             	sub    $0xc,%esp
f010f9b1:	50                   	push   %eax
f010f9b2:	e8 15 fd ff ff       	call   f010f6cc <release_spinlock>
f010f9b7:	83 c4 10             	add    $0x10,%esp

}
f010f9ba:	90                   	nop
f010f9bb:	c9                   	leave  
f010f9bc:	c3                   	ret    

f010f9bd <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010f9bd:	55                   	push   %ebp
f010f9be:	89 e5                	mov    %esp,%ebp
f010f9c0:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f9c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9c6:	83 c0 04             	add    $0x4,%eax
f010f9c9:	83 ec 0c             	sub    $0xc,%esp
f010f9cc:	50                   	push   %eax
f010f9cd:	e8 73 fc ff ff       	call   f010f645 <acquire_spinlock>
f010f9d2:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010f9d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9d8:	83 c0 74             	add    $0x74,%eax
f010f9db:	83 ec 0c             	sub    $0xc,%esp
f010f9de:	50                   	push   %eax
f010f9df:	e8 3f 01 00 00       	call   f010fb23 <wakeup_all>
f010f9e4:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010f9e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010f9f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9f3:	83 c0 04             	add    $0x4,%eax
f010f9f6:	83 ec 0c             	sub    $0xc,%esp
f010f9f9:	50                   	push   %eax
f010f9fa:	e8 cd fc ff ff       	call   f010f6cc <release_spinlock>
f010f9ff:	83 c4 10             	add    $0x10,%esp
}
f010fa02:	90                   	nop
f010fa03:	c9                   	leave  
f010fa04:	c3                   	ret    

f010fa05 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010fa05:	55                   	push   %ebp
f010fa06:	89 e5                	mov    %esp,%ebp
f010fa08:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010fa0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa0e:	83 c0 10             	add    $0x10,%eax
f010fa11:	83 ec 08             	sub    $0x8,%esp
f010fa14:	ff 75 0c             	pushl  0xc(%ebp)
f010fa17:	50                   	push   %eax
f010fa18:	e8 38 fc 00 00       	call   f011f655 <strcpy>
f010fa1d:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010fa20:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa23:	83 ec 0c             	sub    $0xc,%esp
f010fa26:	50                   	push   %eax
f010fa27:	e8 3d 55 ff ff       	call   f0104f69 <init_queue>
f010fa2c:	83 c4 10             	add    $0x10,%esp
}
f010fa2f:	90                   	nop
f010fa30:	c9                   	leave  
f010fa31:	c3                   	ret    

f010fa32 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010fa32:	55                   	push   %ebp
f010fa33:	89 e5                	mov    %esp,%ebp
f010fa35:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f010fa38:	83 ec 0c             	sub    $0xc,%esp
f010fa3b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fa40:	e8 00 fc ff ff       	call   f010f645 <acquire_spinlock>
f010fa45:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010fa48:	e8 56 b9 ff ff       	call   f010b3a3 <get_cpu_proc>
f010fa4d:	89 c2                	mov    %eax,%edx
f010fa4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa52:	83 ec 08             	sub    $0x8,%esp
f010fa55:	52                   	push   %edx
f010fa56:	50                   	push   %eax
f010fa57:	e8 4e 55 ff ff       	call   f0104faa <enqueue>
f010fa5c:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010fa5f:	e8 3f b9 ff ff       	call   f010b3a3 <get_cpu_proc>
f010fa64:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010fa6b:	83 ec 0c             	sub    $0xc,%esp
f010fa6e:	ff 75 0c             	pushl  0xc(%ebp)
f010fa71:	e8 56 fc ff ff       	call   f010f6cc <release_spinlock>
f010fa76:	83 c4 10             	add    $0x10,%esp
	sched();
f010fa79:	e8 a6 ba ff ff       	call   f010b524 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010fa7e:	83 ec 0c             	sub    $0xc,%esp
f010fa81:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fa86:	e8 41 fc ff ff       	call   f010f6cc <release_spinlock>
f010fa8b:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010fa8e:	83 ec 0c             	sub    $0xc,%esp
f010fa91:	ff 75 0c             	pushl  0xc(%ebp)
f010fa94:	e8 ac fb ff ff       	call   f010f645 <acquire_spinlock>
f010fa99:	83 c4 10             	add    $0x10,%esp
}
f010fa9c:	90                   	nop
f010fa9d:	c9                   	leave  
f010fa9e:	c3                   	ret    

f010fa9f <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010fa9f:	55                   	push   %ebp
f010faa0:	89 e5                	mov    %esp,%ebp
f010faa2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f010faa5:	8b 45 08             	mov    0x8(%ebp),%eax
f010faa8:	83 ec 0c             	sub    $0xc,%esp
f010faab:	50                   	push   %eax
f010faac:	e8 e1 54 ff ff       	call   f0104f92 <queue_size>
f010fab1:	83 c4 10             	add    $0x10,%esp
f010fab4:	85 c0                	test   %eax,%eax
f010fab6:	74 68                	je     f010fb20 <wakeup_one+0x81>
		bool locked_by_me = 0;
f010fab8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010fabf:	83 ec 0c             	sub    $0xc,%esp
f010fac2:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fac7:	e8 92 fd ff ff       	call   f010f85e <holding_spinlock>
f010facc:	83 c4 10             	add    $0x10,%esp
f010facf:	85 c0                	test   %eax,%eax
f010fad1:	75 17                	jne    f010faea <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010fad3:	83 ec 0c             	sub    $0xc,%esp
f010fad6:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fadb:	e8 65 fb ff ff       	call   f010f645 <acquire_spinlock>
f010fae0:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010fae3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010faea:	8b 45 08             	mov    0x8(%ebp),%eax
f010faed:	83 ec 0c             	sub    $0xc,%esp
f010faf0:	50                   	push   %eax
f010faf1:	e8 45 55 ff ff       	call   f010503b <dequeue>
f010faf6:	83 c4 10             	add    $0x10,%esp
f010faf9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010fafc:	83 ec 0c             	sub    $0xc,%esp
f010faff:	ff 75 f0             	pushl  -0x10(%ebp)
f010fb02:	e8 6f 57 ff ff       	call   f0105276 <sched_insert_ready0>
f010fb07:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010fb0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fb0e:	74 10                	je     f010fb20 <wakeup_one+0x81>
f010fb10:	83 ec 0c             	sub    $0xc,%esp
f010fb13:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fb18:	e8 af fb ff ff       	call   f010f6cc <release_spinlock>
f010fb1d:	83 c4 10             	add    $0x10,%esp
	}
}
f010fb20:	90                   	nop
f010fb21:	c9                   	leave  
f010fb22:	c3                   	ret    

f010fb23 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010fb23:	55                   	push   %ebp
f010fb24:	89 e5                	mov    %esp,%ebp
f010fb26:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010fb29:	83 ec 0c             	sub    $0xc,%esp
f010fb2c:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fb31:	e8 0f fb ff ff       	call   f010f645 <acquire_spinlock>
f010fb36:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010fb39:	eb 0e                	jmp    f010fb49 <wakeup_all+0x26>
		wakeup_one(chan);
f010fb3b:	83 ec 0c             	sub    $0xc,%esp
f010fb3e:	ff 75 08             	pushl  0x8(%ebp)
f010fb41:	e8 59 ff ff ff       	call   f010fa9f <wakeup_one>
f010fb46:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010fb49:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb4c:	83 ec 0c             	sub    $0xc,%esp
f010fb4f:	50                   	push   %eax
f010fb50:	e8 3d 54 ff ff       	call   f0104f92 <queue_size>
f010fb55:	83 c4 10             	add    $0x10,%esp
f010fb58:	85 c0                	test   %eax,%eax
f010fb5a:	75 df                	jne    f010fb3b <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010fb5c:	83 ec 0c             	sub    $0xc,%esp
f010fb5f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fb64:	e8 63 fb ff ff       	call   f010f6cc <release_spinlock>
f010fb69:	83 c4 10             	add    $0x10,%esp
}
f010fb6c:	90                   	nop
f010fb6d:	c9                   	leave  
f010fb6e:	c3                   	ret    

f010fb6f <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010fb6f:	55                   	push   %ebp
f010fb70:	89 e5                	mov    %esp,%ebp
f010fb72:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010fb75:	83 ec 04             	sub    $0x4,%esp
f010fb78:	68 9c 75 12 f0       	push   $0xf012759c
f010fb7d:	6a 13                	push   $0x13
f010fb7f:	68 c3 75 12 f0       	push   $0xf01275c3
f010fb84:	e8 b0 07 ff ff       	call   f0100339 <_panic>

f010fb89 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010fb89:	55                   	push   %ebp
f010fb8a:	89 e5                	mov    %esp,%ebp
f010fb8c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010fb8f:	83 ec 04             	sub    $0x4,%esp
f010fb92:	68 dc 75 12 f0       	push   $0xf01275dc
f010fb97:	6a 1b                	push   $0x1b
f010fb99:	68 c3 75 12 f0       	push   $0xf01275c3
f010fb9e:	e8 96 07 ff ff       	call   f0100339 <_panic>

f010fba3 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010fba3:	55                   	push   %ebp
f010fba4:	89 e5                	mov    %esp,%ebp
f010fba6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010fba9:	83 ec 04             	sub    $0x4,%esp
f010fbac:	68 04 76 12 f0       	push   $0xf0127604
f010fbb1:	6a 24                	push   $0x24
f010fbb3:	68 c3 75 12 f0       	push   $0xf01275c3
f010fbb8:	e8 7c 07 ff ff       	call   f0100339 <_panic>

f010fbbd <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010fbbd:	55                   	push   %ebp
f010fbbe:	89 e5                	mov    %esp,%ebp
f010fbc0:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f010fbc7:	00 00 00 
f010fbca:	90                   	nop
f010fbcb:	5d                   	pop    %ebp
f010fbcc:	c3                   	ret    

f010fbcd <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010fbcd:	55                   	push   %ebp
f010fbce:	89 e5                	mov    %esp,%ebp
f010fbd0:	c7 05 58 d8 6b f0 02 	movl   $0x2,0xf06bd858
f010fbd7:	00 00 00 
f010fbda:	90                   	nop
f010fbdb:	5d                   	pop    %ebp
f010fbdc:	c3                   	ret    

f010fbdd <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010fbdd:	55                   	push   %ebp
f010fbde:	89 e5                	mov    %esp,%ebp
f010fbe0:	c7 05 58 d8 6b f0 03 	movl   $0x3,0xf06bd858
f010fbe7:	00 00 00 
f010fbea:	90                   	nop
f010fbeb:	5d                   	pop    %ebp
f010fbec:	c3                   	ret    

f010fbed <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010fbed:	55                   	push   %ebp
f010fbee:	89 e5                	mov    %esp,%ebp
f010fbf0:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fbf5:	83 f8 01             	cmp    $0x1,%eax
f010fbf8:	75 04                	jne    f010fbfe <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010fbfa:	b0 01                	mov    $0x1,%al
f010fbfc:	eb 02                	jmp    f010fc00 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010fbfe:	b0 00                	mov    $0x0,%al
f010fc00:	5d                   	pop    %ebp
f010fc01:	c3                   	ret    

f010fc02 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010fc02:	55                   	push   %ebp
f010fc03:	89 e5                	mov    %esp,%ebp
f010fc05:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fc0a:	83 f8 02             	cmp    $0x2,%eax
f010fc0d:	75 04                	jne    f010fc13 <isKHeapPlacementStrategyBESTFIT+0x11>
f010fc0f:	b0 01                	mov    $0x1,%al
f010fc11:	eb 02                	jmp    f010fc15 <isKHeapPlacementStrategyBESTFIT+0x13>
f010fc13:	b0 00                	mov    $0x0,%al
f010fc15:	5d                   	pop    %ebp
f010fc16:	c3                   	ret    

f010fc17 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010fc17:	55                   	push   %ebp
f010fc18:	89 e5                	mov    %esp,%ebp
f010fc1a:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fc1f:	83 f8 03             	cmp    $0x3,%eax
f010fc22:	75 04                	jne    f010fc28 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010fc24:	b0 01                	mov    $0x1,%al
f010fc26:	eb 02                	jmp    f010fc2a <isKHeapPlacementStrategyNEXTFIT+0x13>
f010fc28:	b0 00                	mov    $0x0,%al
f010fc2a:	5d                   	pop    %ebp
f010fc2b:	c3                   	ret    

f010fc2c <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010fc2c:	55                   	push   %ebp
f010fc2d:	89 e5                	mov    %esp,%ebp
f010fc2f:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fc32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fc39:	eb 26                	jmp    f010fc61 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010fc3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fc45:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc48:	01 c2                	add    %eax,%edx
f010fc4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc4d:	40                   	inc    %eax
f010fc4e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fc55:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc58:	01 c8                	add    %ecx,%eax
f010fc5a:	8b 00                	mov    (%eax),%eax
f010fc5c:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fc5e:	ff 45 f4             	incl   -0xc(%ebp)
f010fc61:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc64:	48                   	dec    %eax
f010fc65:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fc68:	7f d1                	jg     f010fc3b <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010fc6a:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010fc6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fc74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010fc7b:	eb 35                	jmp    f010fcb2 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010fc7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc80:	89 d0                	mov    %edx,%eax
f010fc82:	01 c0                	add    %eax,%eax
f010fc84:	01 d0                	add    %edx,%eax
f010fc86:	c1 e0 02             	shl    $0x2,%eax
f010fc89:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010fc8e:	8b 10                	mov    (%eax),%edx
f010fc90:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc93:	8b 00                	mov    (%eax),%eax
f010fc95:	83 ec 08             	sub    $0x8,%esp
f010fc98:	52                   	push   %edx
f010fc99:	50                   	push   %eax
f010fc9a:	e8 73 fa 00 00       	call   f011f712 <strcmp>
f010fc9f:	83 c4 10             	add    $0x10,%esp
f010fca2:	85 c0                	test   %eax,%eax
f010fca4:	75 09                	jne    f010fcaf <tst_handler+0x83>
		{
			test_found = 1;
f010fca6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010fcad:	eb 0f                	jmp    f010fcbe <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fcaf:	ff 45 ec             	incl   -0x14(%ebp)
f010fcb2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fcb5:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f010fcba:	39 c2                	cmp    %eax,%edx
f010fcbc:	72 bf                	jb     f010fc7d <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010fcbe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fcc2:	74 29                	je     f010fced <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010fcc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fcc7:	89 d0                	mov    %edx,%eax
f010fcc9:	01 c0                	add    %eax,%eax
f010fccb:	01 d0                	add    %edx,%eax
f010fccd:	c1 e0 02             	shl    $0x2,%eax
f010fcd0:	05 08 ed 17 f0       	add    $0xf017ed08,%eax
f010fcd5:	8b 00                	mov    (%eax),%eax
f010fcd7:	83 ec 08             	sub    $0x8,%esp
f010fcda:	ff 75 0c             	pushl  0xc(%ebp)
f010fcdd:	ff 75 08             	pushl  0x8(%ebp)
f010fce0:	ff d0                	call   *%eax
f010fce2:	83 c4 10             	add    $0x10,%esp
f010fce5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010fce8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fceb:	eb 1b                	jmp    f010fd08 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010fced:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fcf0:	8b 00                	mov    (%eax),%eax
f010fcf2:	83 ec 08             	sub    $0x8,%esp
f010fcf5:	50                   	push   %eax
f010fcf6:	68 44 79 12 f0       	push   $0xf0127944
f010fcfb:	e8 8b 12 ff ff       	call   f0100f8b <cprintf>
f010fd00:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fd03:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010fd08:	c9                   	leave  
f010fd09:	c3                   	ret    

f010fd0a <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010fd0a:	55                   	push   %ebp
f010fd0b:	89 e5                	mov    %esp,%ebp
f010fd0d:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010fd10:	e8 7c d0 00 00       	call   f011cd91 <test_three_creation_functions>
	return 0;
f010fd15:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd1a:	c9                   	leave  
f010fd1b:	c3                   	ret    

f010fd1c <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010fd1c:	55                   	push   %ebp
f010fd1d:	89 e5                	mov    %esp,%ebp
f010fd1f:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010fd22:	e8 03 69 00 00       	call   f011662a <test_priority_normal_and_higher>
	return 0;
f010fd27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd2c:	c9                   	leave  
f010fd2d:	c3                   	ret    

f010fd2e <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010fd2e:	55                   	push   %ebp
f010fd2f:	89 e5                	mov    %esp,%ebp
f010fd31:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010fd34:	e8 0b 69 00 00       	call   f0116644 <test_priority_normal_and_lower>
	return 0;
f010fd39:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd3e:	c9                   	leave  
f010fd3f:	c3                   	ret    

f010fd40 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010fd40:	55                   	push   %ebp
f010fd41:	89 e5                	mov    %esp,%ebp
f010fd43:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010fd46:	e8 f9 d1 00 00       	call   f011cf44 <test_kfreeall>
	return 0;
f010fd4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd50:	c9                   	leave  
f010fd51:	c3                   	ret    

f010fd52 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010fd52:	55                   	push   %ebp
f010fd53:	89 e5                	mov    %esp,%ebp
f010fd55:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010fd58:	e8 04 d2 00 00       	call   f011cf61 <test_kexpand>
	return 0;
f010fd5d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd62:	c9                   	leave  
f010fd63:	c3                   	ret    

f010fd64 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010fd64:	55                   	push   %ebp
f010fd65:	89 e5                	mov    %esp,%ebp
f010fd67:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010fd6a:	e8 0f d2 00 00       	call   f011cf7e <test_kshrink>
	return 0;
f010fd6f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd74:	c9                   	leave  
f010fd75:	c3                   	ret    

f010fd76 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010fd76:	55                   	push   %ebp
f010fd77:	89 e5                	mov    %esp,%ebp
f010fd79:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010fd7c:	e8 1a d2 00 00       	call   f011cf9b <test_kfreelast>
	return 0;
f010fd81:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd86:	c9                   	leave  
f010fd87:	c3                   	ret    

f010fd88 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010fd88:	55                   	push   %ebp
f010fd89:	89 e5                	mov    %esp,%ebp
f010fd8b:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010fd8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd91:	83 c0 04             	add    $0x4,%eax
f010fd94:	8b 00                	mov    (%eax),%eax
f010fd96:	83 ec 04             	sub    $0x4,%esp
f010fd99:	6a 0a                	push   $0xa
f010fd9b:	6a 00                	push   $0x0
f010fd9d:	50                   	push   %eax
f010fd9e:	e8 c3 fb 00 00       	call   f011f966 <strtol>
f010fda3:	83 c4 10             	add    $0x10,%esp
f010fda6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010fda9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010fdb0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010fdb7:	83 ec 0c             	sub    $0xc,%esp
f010fdba:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fdbf:	e8 81 f8 ff ff       	call   f010f645 <acquire_spinlock>
f010fdc4:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fdc7:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f010fdcc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fdcf:	eb 3b                	jmp    f010fe0c <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010fdd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fdd4:	83 c0 20             	add    $0x20,%eax
f010fdd7:	83 ec 08             	sub    $0x8,%esp
f010fdda:	68 57 79 12 f0       	push   $0xf0127957
f010fddf:	50                   	push   %eax
f010fde0:	e8 2d f9 00 00       	call   f011f712 <strcmp>
f010fde5:	83 c4 10             	add    $0x10,%esp
f010fde8:	85 c0                	test   %eax,%eax
f010fdea:	75 12                	jne    f010fdfe <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010fdec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdf0:	74 07                	je     f010fdf9 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010fdf2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010fdf9:	ff 45 f4             	incl   -0xc(%ebp)
f010fdfc:	eb 06                	jmp    f010fe04 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010fdfe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fe02:	74 31                	je     f010fe35 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fe04:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010fe09:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fe0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fe10:	74 08                	je     f010fe1a <tst_sc_MLFQ+0x92>
f010fe12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fe15:	8b 40 08             	mov    0x8(%eax),%eax
f010fe18:	eb 05                	jmp    f010fe1f <tst_sc_MLFQ+0x97>
f010fe1a:	b8 00 00 00 00       	mov    $0x0,%eax
f010fe1f:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f010fe24:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010fe29:	85 c0                	test   %eax,%eax
f010fe2b:	75 a4                	jne    f010fdd1 <tst_sc_MLFQ+0x49>
f010fe2d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fe31:	75 9e                	jne    f010fdd1 <tst_sc_MLFQ+0x49>
f010fe33:	eb 01                	jmp    f010fe36 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010fe35:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010fe36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe39:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fe3c:	75 12                	jne    f010fe50 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010fe3e:	83 ec 0c             	sub    $0xc,%esp
f010fe41:	68 60 79 12 f0       	push   $0xf0127960
f010fe46:	e8 40 11 ff ff       	call   f0100f8b <cprintf>
f010fe4b:	83 c4 10             	add    $0x10,%esp
f010fe4e:	eb 17                	jmp    f010fe67 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010fe50:	83 ec 04             	sub    $0x4,%esp
f010fe53:	68 99 79 12 f0       	push   $0xf0127999
f010fe58:	68 9b 00 00 00       	push   $0x9b
f010fe5d:	68 af 79 12 f0       	push   $0xf01279af
f010fe62:	e8 d2 04 ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010fe67:	83 ec 0c             	sub    $0xc,%esp
f010fe6a:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fe6f:	e8 58 f8 ff ff       	call   f010f6cc <release_spinlock>
f010fe74:	83 c4 10             	add    $0x10,%esp
	return 0;
f010fe77:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fe7c:	c9                   	leave  
f010fe7d:	c3                   	ret    

f010fe7e <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010fe7e:	55                   	push   %ebp
f010fe7f:	89 e5                	mov    %esp,%ebp
f010fe81:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010fe84:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010fe88:	74 17                	je     f010fea1 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010fe8a:	83 ec 0c             	sub    $0xc,%esp
f010fe8d:	68 c8 79 12 f0       	push   $0xf01279c8
f010fe92:	e8 f4 10 ff ff       	call   f0100f8b <cprintf>
f010fe97:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fe9a:	b8 00 00 00 00       	mov    $0x0,%eax
f010fe9f:	eb 45                	jmp    f010fee6 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010fea1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fea4:	83 c0 04             	add    $0x4,%eax
f010fea7:	8b 00                	mov    (%eax),%eax
f010fea9:	83 ec 04             	sub    $0x4,%esp
f010feac:	6a 0a                	push   $0xa
f010feae:	6a 00                	push   $0x0
f010feb0:	50                   	push   %eax
f010feb1:	e8 b0 fa 00 00       	call   f011f966 <strtol>
f010feb6:	83 c4 10             	add    $0x10,%esp
f010feb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010febc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010febf:	83 f8 01             	cmp    $0x1,%eax
f010fec2:	74 10                	je     f010fed4 <tst_bsd_nice+0x56>
f010fec4:	83 f8 02             	cmp    $0x2,%eax
f010fec7:	74 12                	je     f010fedb <tst_bsd_nice+0x5d>
f010fec9:	85 c0                	test   %eax,%eax
f010fecb:	75 14                	jne    f010fee1 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010fecd:	e8 cc d2 00 00       	call   f011d19e <test_bsd_nice_0>
		break;
f010fed2:	eb 0d                	jmp    f010fee1 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010fed4:	e8 4f d5 00 00       	call   f011d428 <test_bsd_nice_1>
		break;
f010fed9:	eb 06                	jmp    f010fee1 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010fedb:	e8 5c d7 00 00       	call   f011d63c <test_bsd_nice_2>
		break;
f010fee0:	90                   	nop
	}
	return 0;
f010fee1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fee6:	c9                   	leave  
f010fee7:	c3                   	ret    

f010fee8 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010fee8:	55                   	push   %ebp
f010fee9:	89 e5                	mov    %esp,%ebp
f010feeb:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010feee:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010fef2:	74 17                	je     f010ff0b <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010fef4:	83 ec 0c             	sub    $0xc,%esp
f010fef7:	68 08 7a 12 f0       	push   $0xf0127a08
f010fefc:	e8 8a 10 ff ff       	call   f0100f8b <cprintf>
f010ff01:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ff04:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff09:	eb 0a                	jmp    f010ff15 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010ff0b:	e8 3f 15 00 00       	call   f011144f <test_str2lower_function>
	return 0;
f010ff10:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ff15:	c9                   	leave  
f010ff16:	c3                   	ret    

f010ff17 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010ff17:	55                   	push   %ebp
f010ff18:	89 e5                	mov    %esp,%ebp
f010ff1a:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010ff1d:	e8 63 11 00 00       	call   f0111085 <TestAutoCompleteCommand>
f010ff22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010ff25:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ff2a:	c9                   	leave  
f010ff2b:	c3                   	ret    

f010ff2c <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010ff2c:	55                   	push   %ebp
f010ff2d:	89 e5                	mov    %esp,%ebp
f010ff2f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010ff32:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ff36:	74 1a                	je     f010ff52 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010ff38:	83 ec 0c             	sub    $0xc,%esp
f010ff3b:	68 3c 7a 12 f0       	push   $0xf0127a3c
f010ff40:	e8 46 10 ff ff       	call   f0100f8b <cprintf>
f010ff45:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ff48:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff4d:	e9 2f 01 00 00       	jmp    f0110081 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010ff52:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff55:	83 c0 04             	add    $0x4,%eax
f010ff58:	8b 00                	mov    (%eax),%eax
f010ff5a:	83 ec 08             	sub    $0x8,%esp
f010ff5d:	68 79 7a 12 f0       	push   $0xf0127a79
f010ff62:	50                   	push   %eax
f010ff63:	e8 aa f7 00 00       	call   f011f712 <strcmp>
f010ff68:	83 c4 10             	add    $0x10,%esp
f010ff6b:	85 c0                	test   %eax,%eax
f010ff6d:	75 0a                	jne    f010ff79 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010ff6f:	e8 40 08 00 00       	call   f01107b4 <test_initialize_dynamic_allocator>
f010ff74:	e9 03 01 00 00       	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010ff79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff7c:	83 c0 04             	add    $0x4,%eax
f010ff7f:	8b 00                	mov    (%eax),%eax
f010ff81:	83 ec 08             	sub    $0x8,%esp
f010ff84:	68 7e 7a 12 f0       	push   $0xf0127a7e
f010ff89:	50                   	push   %eax
f010ff8a:	e8 83 f7 00 00       	call   f011f712 <strcmp>
f010ff8f:	83 c4 10             	add    $0x10,%esp
f010ff92:	85 c0                	test   %eax,%eax
f010ff94:	75 0a                	jne    f010ffa0 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010ff96:	e8 4d 08 00 00       	call   f01107e8 <test_alloc_block_FF>
f010ff9b:	e9 dc 00 00 00       	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010ffa0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffa3:	83 c0 04             	add    $0x4,%eax
f010ffa6:	8b 00                	mov    (%eax),%eax
f010ffa8:	83 ec 08             	sub    $0x8,%esp
f010ffab:	68 86 7a 12 f0       	push   $0xf0127a86
f010ffb0:	50                   	push   %eax
f010ffb1:	e8 5c f7 00 00       	call   f011f712 <strcmp>
f010ffb6:	83 c4 10             	add    $0x10,%esp
f010ffb9:	85 c0                	test   %eax,%eax
f010ffbb:	75 0a                	jne    f010ffc7 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010ffbd:	e8 43 08 00 00       	call   f0110805 <test_alloc_block_BF>
f010ffc2:	e9 b5 00 00 00       	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010ffc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffca:	83 c0 04             	add    $0x4,%eax
f010ffcd:	8b 00                	mov    (%eax),%eax
f010ffcf:	83 ec 08             	sub    $0x8,%esp
f010ffd2:	68 8e 7a 12 f0       	push   $0xf0127a8e
f010ffd7:	50                   	push   %eax
f010ffd8:	e8 35 f7 00 00       	call   f011f712 <strcmp>
f010ffdd:	83 c4 10             	add    $0x10,%esp
f010ffe0:	85 c0                	test   %eax,%eax
f010ffe2:	75 0a                	jne    f010ffee <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010ffe4:	e8 3c 08 00 00       	call   f0110825 <test_alloc_block_NF>
f010ffe9:	e9 8e 00 00 00       	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010ffee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fff1:	83 c0 04             	add    $0x4,%eax
f010fff4:	8b 00                	mov    (%eax),%eax
f010fff6:	83 ec 08             	sub    $0x8,%esp
f010fff9:	68 96 7a 12 f0       	push   $0xf0127a96
f010fffe:	50                   	push   %eax
f010ffff:	e8 0e f7 00 00       	call   f011f712 <strcmp>
f0110004:	83 c4 10             	add    $0x10,%esp
f0110007:	85 c0                	test   %eax,%eax
f0110009:	75 07                	jne    f0110012 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f011000b:	e8 1b 08 00 00       	call   f011082b <test_free_block_FF>
f0110010:	eb 6a                	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f0110012:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110015:	83 c0 04             	add    $0x4,%eax
f0110018:	8b 00                	mov    (%eax),%eax
f011001a:	83 ec 08             	sub    $0x8,%esp
f011001d:	68 9d 7a 12 f0       	push   $0xf0127a9d
f0110022:	50                   	push   %eax
f0110023:	e8 ea f6 00 00       	call   f011f712 <strcmp>
f0110028:	83 c4 10             	add    $0x10,%esp
f011002b:	85 c0                	test   %eax,%eax
f011002d:	75 07                	jne    f0110036 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f011002f:	e8 14 08 00 00       	call   f0110848 <test_free_block_BF>
f0110034:	eb 46                	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f0110036:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110039:	83 c0 04             	add    $0x4,%eax
f011003c:	8b 00                	mov    (%eax),%eax
f011003e:	83 ec 08             	sub    $0x8,%esp
f0110041:	68 a4 7a 12 f0       	push   $0xf0127aa4
f0110046:	50                   	push   %eax
f0110047:	e8 c6 f6 00 00       	call   f011f712 <strcmp>
f011004c:	83 c4 10             	add    $0x10,%esp
f011004f:	85 c0                	test   %eax,%eax
f0110051:	75 07                	jne    f011005a <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0110053:	e8 0d 08 00 00       	call   f0110865 <test_free_block_NF>
f0110058:	eb 22                	jmp    f011007c <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f011005a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011005d:	83 c0 04             	add    $0x4,%eax
f0110060:	8b 00                	mov    (%eax),%eax
f0110062:	83 ec 08             	sub    $0x8,%esp
f0110065:	68 ab 7a 12 f0       	push   $0xf0127aab
f011006a:	50                   	push   %eax
f011006b:	e8 a2 f6 00 00       	call   f011f712 <strcmp>
f0110070:	83 c4 10             	add    $0x10,%esp
f0110073:	85 c0                	test   %eax,%eax
f0110075:	75 05                	jne    f011007c <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0110077:	e8 06 08 00 00       	call   f0110882 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f011007c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110081:	c9                   	leave  
f0110082:	c3                   	ret    

f0110083 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110083:	55                   	push   %ebp
f0110084:	89 e5                	mov    %esp,%ebp
f0110086:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110089:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011008d:	74 1a                	je     f01100a9 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f011008f:	83 ec 0c             	sub    $0xc,%esp
f0110092:	68 b8 7a 12 f0       	push   $0xf0127ab8
f0110097:	e8 ef 0e ff ff       	call   f0100f8b <cprintf>
f011009c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011009f:	b8 00 00 00 00       	mov    $0x0,%eax
f01100a4:	e9 e1 00 00 00       	jmp    f011018a <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f01100a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100ac:	83 c0 04             	add    $0x4,%eax
f01100af:	8b 00                	mov    (%eax),%eax
f01100b1:	83 ec 08             	sub    $0x8,%esp
f01100b4:	68 f1 7a 12 f0       	push   $0xf0127af1
f01100b9:	50                   	push   %eax
f01100ba:	e8 53 f6 00 00       	call   f011f712 <strcmp>
f01100bf:	83 c4 10             	add    $0x10,%esp
f01100c2:	85 c0                	test   %eax,%eax
f01100c4:	75 0a                	jne    f01100d0 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01100c6:	e8 97 1c 00 00       	call   f0111d62 <test_cut_paste_pages>
f01100cb:	e9 b5 00 00 00       	jmp    f0110185 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01100d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100d3:	83 c0 04             	add    $0x4,%eax
f01100d6:	8b 00                	mov    (%eax),%eax
f01100d8:	83 ec 08             	sub    $0x8,%esp
f01100db:	68 fa 7a 12 f0       	push   $0xf0127afa
f01100e0:	50                   	push   %eax
f01100e1:	e8 2c f6 00 00       	call   f011f712 <strcmp>
f01100e6:	83 c4 10             	add    $0x10,%esp
f01100e9:	85 c0                	test   %eax,%eax
f01100eb:	75 0a                	jne    f01100f7 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01100ed:	e8 bb 26 00 00       	call   f01127ad <test_copy_paste_chunk>
f01100f2:	e9 8e 00 00 00       	jmp    f0110185 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01100f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100fa:	83 c0 04             	add    $0x4,%eax
f01100fd:	8b 00                	mov    (%eax),%eax
f01100ff:	83 ec 08             	sub    $0x8,%esp
f0110102:	68 04 7b 12 f0       	push   $0xf0127b04
f0110107:	50                   	push   %eax
f0110108:	e8 05 f6 00 00       	call   f011f712 <strcmp>
f011010d:	83 c4 10             	add    $0x10,%esp
f0110110:	85 c0                	test   %eax,%eax
f0110112:	75 07                	jne    f011011b <tst_chunks+0x98>
	{
		test_share_chunk();
f0110114:	e8 92 37 00 00       	call   f01138ab <test_share_chunk>
f0110119:	eb 6a                	jmp    f0110185 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f011011b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011011e:	83 c0 04             	add    $0x4,%eax
f0110121:	8b 00                	mov    (%eax),%eax
f0110123:	83 ec 08             	sub    $0x8,%esp
f0110126:	68 0a 7b 12 f0       	push   $0xf0127b0a
f011012b:	50                   	push   %eax
f011012c:	e8 e1 f5 00 00       	call   f011f712 <strcmp>
f0110131:	83 c4 10             	add    $0x10,%esp
f0110134:	85 c0                	test   %eax,%eax
f0110136:	75 07                	jne    f011013f <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110138:	e8 96 41 00 00       	call   f01142d3 <test_allocate_chunk>
f011013d:	eb 46                	jmp    f0110185 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f011013f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110142:	83 c0 04             	add    $0x4,%eax
f0110145:	8b 00                	mov    (%eax),%eax
f0110147:	83 ec 08             	sub    $0x8,%esp
f011014a:	68 13 7b 12 f0       	push   $0xf0127b13
f011014f:	50                   	push   %eax
f0110150:	e8 bd f5 00 00       	call   f011f712 <strcmp>
f0110155:	83 c4 10             	add    $0x10,%esp
f0110158:	85 c0                	test   %eax,%eax
f011015a:	75 07                	jne    f0110163 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f011015c:	e8 79 4a 00 00       	call   f0114bda <test_calculate_required_frames>
f0110161:	eb 22                	jmp    f0110185 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110163:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110166:	83 c0 04             	add    $0x4,%eax
f0110169:	8b 00                	mov    (%eax),%eax
f011016b:	83 ec 08             	sub    $0x8,%esp
f011016e:	68 22 7b 12 f0       	push   $0xf0127b22
f0110173:	50                   	push   %eax
f0110174:	e8 99 f5 00 00       	call   f011f712 <strcmp>
f0110179:	83 c4 10             	add    $0x10,%esp
f011017c:	85 c0                	test   %eax,%eax
f011017e:	75 05                	jne    f0110185 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110180:	e8 c9 52 00 00       	call   f011544e <test_calculate_allocated_space>
	}
	return 0;
f0110185:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011018a:	c9                   	leave  
f011018b:	c3                   	ret    

f011018c <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011018c:	55                   	push   %ebp
f011018d:	89 e5                	mov    %esp,%ebp
f011018f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110192:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110196:	74 1a                	je     f01101b2 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110198:	83 ec 0c             	sub    $0xc,%esp
f011019b:	68 34 7b 12 f0       	push   $0xf0127b34
f01101a0:	e8 e6 0d ff ff       	call   f0100f8b <cprintf>
f01101a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01101a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01101ad:	e9 ba 00 00 00       	jmp    f011026c <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f01101b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101b5:	83 c0 04             	add    $0x4,%eax
f01101b8:	8b 00                	mov    (%eax),%eax
f01101ba:	83 ec 08             	sub    $0x8,%esp
f01101bd:	68 6a 7b 12 f0       	push   $0xf0127b6a
f01101c2:	50                   	push   %eax
f01101c3:	e8 4a f5 00 00       	call   f011f712 <strcmp>
f01101c8:	83 c4 10             	add    $0x10,%esp
f01101cb:	85 c0                	test   %eax,%eax
f01101cd:	75 0a                	jne    f01101d9 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01101cf:	e8 01 16 00 00       	call   f01117d5 <test_pt_set_page_permissions>
f01101d4:	e9 8e 00 00 00       	jmp    f0110267 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01101d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101dc:	83 c0 04             	add    $0x4,%eax
f01101df:	8b 00                	mov    (%eax),%eax
f01101e1:	83 ec 08             	sub    $0x8,%esp
f01101e4:	68 72 7b 12 f0       	push   $0xf0127b72
f01101e9:	50                   	push   %eax
f01101ea:	e8 23 f5 00 00       	call   f011f712 <strcmp>
f01101ef:	83 c4 10             	add    $0x10,%esp
f01101f2:	85 c0                	test   %eax,%eax
f01101f4:	75 07                	jne    f01101fd <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01101f6:	e8 49 18 00 00       	call   f0111a44 <test_pt_set_page_permissions_invalid_va>
f01101fb:	eb 6a                	jmp    f0110267 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01101fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110200:	83 c0 04             	add    $0x4,%eax
f0110203:	8b 00                	mov    (%eax),%eax
f0110205:	83 ec 08             	sub    $0x8,%esp
f0110208:	68 7a 7b 12 f0       	push   $0xf0127b7a
f011020d:	50                   	push   %eax
f011020e:	e8 ff f4 00 00       	call   f011f712 <strcmp>
f0110213:	83 c4 10             	add    $0x10,%esp
f0110216:	85 c0                	test   %eax,%eax
f0110218:	75 07                	jne    f0110221 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f011021a:	e8 6e 18 00 00       	call   f0111a8d <test_pt_get_page_permissions>
f011021f:	eb 46                	jmp    f0110267 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f0110221:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110224:	83 c0 04             	add    $0x4,%eax
f0110227:	8b 00                	mov    (%eax),%eax
f0110229:	83 ec 08             	sub    $0x8,%esp
f011022c:	68 82 7b 12 f0       	push   $0xf0127b82
f0110231:	50                   	push   %eax
f0110232:	e8 db f4 00 00       	call   f011f712 <strcmp>
f0110237:	83 c4 10             	add    $0x10,%esp
f011023a:	85 c0                	test   %eax,%eax
f011023c:	75 07                	jne    f0110245 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f011023e:	e8 8e 19 00 00       	call   f0111bd1 <test_pt_clear_page_table_entry>
f0110243:	eb 22                	jmp    f0110267 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110245:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110248:	83 c0 04             	add    $0x4,%eax
f011024b:	8b 00                	mov    (%eax),%eax
f011024d:	83 ec 08             	sub    $0x8,%esp
f0110250:	68 89 7b 12 f0       	push   $0xf0127b89
f0110255:	50                   	push   %eax
f0110256:	e8 b7 f4 00 00       	call   f011f712 <strcmp>
f011025b:	83 c4 10             	add    $0x10,%esp
f011025e:	85 c0                	test   %eax,%eax
f0110260:	75 05                	jne    f0110267 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110262:	e8 c3 1a 00 00       	call   f0111d2a <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110267:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011026c:	c9                   	leave  
f011026d:	c3                   	ret    

f011026e <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011026e:	55                   	push   %ebp
f011026f:	89 e5                	mov    %esp,%ebp
f0110271:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110274:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110277:	83 c0 08             	add    $0x8,%eax
f011027a:	8b 00                	mov    (%eax),%eax
f011027c:	83 ec 08             	sub    $0x8,%esp
f011027f:	68 90 7b 12 f0       	push   $0xf0127b90
f0110284:	50                   	push   %eax
f0110285:	e8 88 f4 00 00       	call   f011f712 <strcmp>
f011028a:	83 c4 10             	add    $0x10,%esp
f011028d:	85 c0                	test   %eax,%eax
f011028f:	75 20                	jne    f01102b1 <tst_kheap+0x43>
f0110291:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110295:	74 1a                	je     f01102b1 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110297:	83 ec 0c             	sub    $0xc,%esp
f011029a:	68 98 7b 12 f0       	push   $0xf0127b98
f011029f:	e8 e7 0c ff ff       	call   f0100f8b <cprintf>
f01102a4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01102a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01102ac:	e9 42 04 00 00       	jmp    f01106f3 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f01102b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102b4:	83 c0 08             	add    $0x8,%eax
f01102b7:	8b 00                	mov    (%eax),%eax
f01102b9:	83 ec 08             	sub    $0x8,%esp
f01102bc:	68 90 7b 12 f0       	push   $0xf0127b90
f01102c1:	50                   	push   %eax
f01102c2:	e8 4b f4 00 00       	call   f011f712 <strcmp>
f01102c7:	83 c4 10             	add    $0x10,%esp
f01102ca:	85 c0                	test   %eax,%eax
f01102cc:	74 43                	je     f0110311 <tst_kheap+0xa3>
f01102ce:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01102d2:	74 3d                	je     f0110311 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01102d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102d7:	83 c0 08             	add    $0x8,%eax
f01102da:	8b 00                	mov    (%eax),%eax
f01102dc:	83 ec 08             	sub    $0x8,%esp
f01102df:	68 e8 7b 12 f0       	push   $0xf0127be8
f01102e4:	50                   	push   %eax
f01102e5:	e8 28 f4 00 00       	call   f011f712 <strcmp>
f01102ea:	83 c4 10             	add    $0x10,%esp
f01102ed:	85 c0                	test   %eax,%eax
f01102ef:	74 20                	je     f0110311 <tst_kheap+0xa3>
f01102f1:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01102f5:	74 1a                	je     f0110311 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01102f7:	83 ec 0c             	sub    $0xc,%esp
f01102fa:	68 f4 7b 12 f0       	push   $0xf0127bf4
f01102ff:	e8 87 0c ff ff       	call   f0100f8b <cprintf>
f0110304:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110307:	b8 00 00 00 00       	mov    $0x0,%eax
f011030c:	e9 e2 03 00 00       	jmp    f01106f3 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110311:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110314:	83 c0 04             	add    $0x4,%eax
f0110317:	8b 00                	mov    (%eax),%eax
f0110319:	83 ec 08             	sub    $0x8,%esp
f011031c:	68 39 7c 12 f0       	push   $0xf0127c39
f0110321:	50                   	push   %eax
f0110322:	e8 eb f3 00 00       	call   f011f712 <strcmp>
f0110327:	83 c4 10             	add    $0x10,%esp
f011032a:	85 c0                	test   %eax,%eax
f011032c:	74 1d                	je     f011034b <tst_kheap+0xdd>
f011032e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110331:	83 c0 04             	add    $0x4,%eax
f0110334:	8b 00                	mov    (%eax),%eax
f0110336:	83 ec 08             	sub    $0x8,%esp
f0110339:	68 3c 7c 12 f0       	push   $0xf0127c3c
f011033e:	50                   	push   %eax
f011033f:	e8 ce f3 00 00       	call   f011f712 <strcmp>
f0110344:	83 c4 10             	add    $0x10,%esp
f0110347:	85 c0                	test   %eax,%eax
f0110349:	75 1a                	jne    f0110365 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f011034b:	e8 6d f8 ff ff       	call   f010fbbd <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110350:	83 ec 0c             	sub    $0xc,%esp
f0110353:	68 40 7c 12 f0       	push   $0xf0127c40
f0110358:	e8 2e 0c ff ff       	call   f0100f8b <cprintf>
f011035d:	83 c4 10             	add    $0x10,%esp
f0110360:	e9 a0 00 00 00       	jmp    f0110405 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110365:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110368:	83 c0 04             	add    $0x4,%eax
f011036b:	8b 00                	mov    (%eax),%eax
f011036d:	83 ec 08             	sub    $0x8,%esp
f0110370:	68 6d 7c 12 f0       	push   $0xf0127c6d
f0110375:	50                   	push   %eax
f0110376:	e8 97 f3 00 00       	call   f011f712 <strcmp>
f011037b:	83 c4 10             	add    $0x10,%esp
f011037e:	85 c0                	test   %eax,%eax
f0110380:	74 1d                	je     f011039f <tst_kheap+0x131>
f0110382:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110385:	83 c0 04             	add    $0x4,%eax
f0110388:	8b 00                	mov    (%eax),%eax
f011038a:	83 ec 08             	sub    $0x8,%esp
f011038d:	68 70 7c 12 f0       	push   $0xf0127c70
f0110392:	50                   	push   %eax
f0110393:	e8 7a f3 00 00       	call   f011f712 <strcmp>
f0110398:	83 c4 10             	add    $0x10,%esp
f011039b:	85 c0                	test   %eax,%eax
f011039d:	75 17                	jne    f01103b6 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f011039f:	e8 29 f8 ff ff       	call   f010fbcd <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01103a4:	83 ec 0c             	sub    $0xc,%esp
f01103a7:	68 74 7c 12 f0       	push   $0xf0127c74
f01103ac:	e8 da 0b ff ff       	call   f0100f8b <cprintf>
f01103b1:	83 c4 10             	add    $0x10,%esp
f01103b4:	eb 4f                	jmp    f0110405 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f01103b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103b9:	83 c0 04             	add    $0x4,%eax
f01103bc:	8b 00                	mov    (%eax),%eax
f01103be:	83 ec 08             	sub    $0x8,%esp
f01103c1:	68 a0 7c 12 f0       	push   $0xf0127ca0
f01103c6:	50                   	push   %eax
f01103c7:	e8 46 f3 00 00       	call   f011f712 <strcmp>
f01103cc:	83 c4 10             	add    $0x10,%esp
f01103cf:	85 c0                	test   %eax,%eax
f01103d1:	74 1d                	je     f01103f0 <tst_kheap+0x182>
f01103d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103d6:	83 c0 04             	add    $0x4,%eax
f01103d9:	8b 00                	mov    (%eax),%eax
f01103db:	83 ec 08             	sub    $0x8,%esp
f01103de:	68 a3 7c 12 f0       	push   $0xf0127ca3
f01103e3:	50                   	push   %eax
f01103e4:	e8 29 f3 00 00       	call   f011f712 <strcmp>
f01103e9:	83 c4 10             	add    $0x10,%esp
f01103ec:	85 c0                	test   %eax,%eax
f01103ee:	75 15                	jne    f0110405 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f01103f0:	e8 e8 f7 ff ff       	call   f010fbdd <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01103f5:	83 ec 0c             	sub    $0xc,%esp
f01103f8:	68 a8 7c 12 f0       	push   $0xf0127ca8
f01103fd:	e8 89 0b ff ff       	call   f0100f8b <cprintf>
f0110402:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110405:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110408:	83 c0 08             	add    $0x8,%eax
f011040b:	8b 00                	mov    (%eax),%eax
f011040d:	83 ec 08             	sub    $0x8,%esp
f0110410:	68 90 7b 12 f0       	push   $0xf0127b90
f0110415:	50                   	push   %eax
f0110416:	e8 f7 f2 00 00       	call   f011f712 <strcmp>
f011041b:	83 c4 10             	add    $0x10,%esp
f011041e:	85 c0                	test   %eax,%eax
f0110420:	0f 85 13 01 00 00    	jne    f0110539 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110426:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110429:	83 c0 0c             	add    $0xc,%eax
f011042c:	8b 00                	mov    (%eax),%eax
f011042e:	83 ec 04             	sub    $0x4,%esp
f0110431:	6a 0a                	push   $0xa
f0110433:	6a 00                	push   $0x0
f0110435:	50                   	push   %eax
f0110436:	e8 2b f5 00 00       	call   f011f966 <strtol>
f011043b:	83 c4 10             	add    $0x10,%esp
f011043e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110441:	e8 a7 f7 ff ff       	call   f010fbed <isKHeapPlacementStrategyFIRSTFIT>
f0110446:	84 c0                	test   %al,%al
f0110448:	74 54                	je     f011049e <tst_kheap+0x230>
		{
			if (testNum == 0)
f011044a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011044e:	75 1a                	jne    f011046a <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110450:	83 ec 0c             	sub    $0xc,%esp
f0110453:	68 d4 7c 12 f0       	push   $0xf0127cd4
f0110458:	e8 2e 0b ff ff       	call   f0100f8b <cprintf>
f011045d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110460:	b8 00 00 00 00       	mov    $0x0,%eax
f0110465:	e9 89 02 00 00       	jmp    f01106f3 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f011046a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011046e:	75 0a                	jne    f011047a <tst_kheap+0x20c>
				test_kmalloc();
f0110470:	e8 ec 61 00 00       	call   f0116661 <test_kmalloc>
f0110475:	e9 b5 00 00 00       	jmp    f011052f <tst_kheap+0x2c1>
			else if (testNum == 2)
f011047a:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011047e:	75 0a                	jne    f011048a <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110480:	e8 7b 6d 00 00       	call   f0117200 <test_kmalloc_firstfit1>
f0110485:	e9 a5 00 00 00       	jmp    f011052f <tst_kheap+0x2c1>
			else if (testNum == 3)
f011048a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011048e:	0f 85 9b 00 00 00    	jne    f011052f <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110494:	e8 4b 78 00 00       	call   f0117ce4 <test_kmalloc_firstfit2>
f0110499:	e9 91 00 00 00       	jmp    f011052f <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f011049e:	e8 5f f7 ff ff       	call   f010fc02 <isKHeapPlacementStrategyBESTFIT>
f01104a3:	84 c0                	test   %al,%al
f01104a5:	74 47                	je     f01104ee <tst_kheap+0x280>
		{
			if (testNum == 0)
f01104a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01104ab:	75 1a                	jne    f01104c7 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f01104ad:	83 ec 0c             	sub    $0xc,%esp
f01104b0:	68 24 7d 12 f0       	push   $0xf0127d24
f01104b5:	e8 d1 0a ff ff       	call   f0100f8b <cprintf>
f01104ba:	83 c4 10             	add    $0x10,%esp
				return 0;
f01104bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01104c2:	e9 2c 02 00 00       	jmp    f01106f3 <tst_kheap+0x485>
			}
			if (testNum == 1)
f01104c7:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01104cb:	75 07                	jne    f01104d4 <tst_kheap+0x266>
				test_kmalloc();
f01104cd:	e8 8f 61 00 00       	call   f0116661 <test_kmalloc>
f01104d2:	eb 5b                	jmp    f011052f <tst_kheap+0x2c1>
			else if (testNum == 2)
f01104d4:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01104d8:	75 07                	jne    f01104e1 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f01104da:	e8 3e c8 00 00       	call   f011cd1d <test_kmalloc_bestfit1>
f01104df:	eb 4e                	jmp    f011052f <tst_kheap+0x2c1>
			else if (testNum == 3)
f01104e1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f01104e5:	75 48                	jne    f011052f <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f01104e7:	e8 4e c8 00 00       	call   f011cd3a <test_kmalloc_bestfit2>
f01104ec:	eb 41                	jmp    f011052f <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f01104ee:	e8 24 f7 ff ff       	call   f010fc17 <isKHeapPlacementStrategyNEXTFIT>
f01104f3:	84 c0                	test   %al,%al
f01104f5:	74 38                	je     f011052f <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f01104f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01104fb:	75 1a                	jne    f0110517 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f01104fd:	83 ec 0c             	sub    $0xc,%esp
f0110500:	68 74 7d 12 f0       	push   $0xf0127d74
f0110505:	e8 81 0a ff ff       	call   f0100f8b <cprintf>
f011050a:	83 c4 10             	add    $0x10,%esp
				return 0;
f011050d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110512:	e9 dc 01 00 00       	jmp    f01106f3 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110517:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011051b:	75 07                	jne    f0110524 <tst_kheap+0x2b6>
				test_kmalloc();
f011051d:	e8 3f 61 00 00       	call   f0116661 <test_kmalloc>
f0110522:	eb 0b                	jmp    f011052f <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110524:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110528:	75 05                	jne    f011052f <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f011052a:	e8 d1 c7 00 00       	call   f011cd00 <test_kmalloc_nextfit>
		}
		return 0;
f011052f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110534:	e9 ba 01 00 00       	jmp    f01106f3 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110539:	8b 45 0c             	mov    0xc(%ebp),%eax
f011053c:	83 c0 08             	add    $0x8,%eax
f011053f:	8b 00                	mov    (%eax),%eax
f0110541:	83 ec 08             	sub    $0x8,%esp
f0110544:	68 c2 7d 12 f0       	push   $0xf0127dc2
f0110549:	50                   	push   %eax
f011054a:	e8 c3 f1 00 00       	call   f011f712 <strcmp>
f011054f:	83 c4 10             	add    $0x10,%esp
f0110552:	85 c0                	test   %eax,%eax
f0110554:	75 2f                	jne    f0110585 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110556:	e8 92 f6 ff ff       	call   f010fbed <isKHeapPlacementStrategyFIRSTFIT>
f011055b:	84 c0                	test   %al,%al
f011055d:	74 0f                	je     f011056e <tst_kheap+0x300>
		{
			test_fastfirstfit();
f011055f:	e8 87 82 00 00       	call   f01187eb <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110564:	b8 00 00 00 00       	mov    $0x0,%eax
f0110569:	e9 85 01 00 00       	jmp    f01106f3 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f011056e:	83 ec 04             	sub    $0x4,%esp
f0110571:	68 c8 7d 12 f0       	push   $0xf0127dc8
f0110576:	68 ac 01 00 00       	push   $0x1ac
f011057b:	68 af 79 12 f0       	push   $0xf01279af
f0110580:	e8 b4 fd fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110585:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110588:	83 c0 08             	add    $0x8,%eax
f011058b:	8b 00                	mov    (%eax),%eax
f011058d:	83 ec 08             	sub    $0x8,%esp
f0110590:	68 09 7e 12 f0       	push   $0xf0127e09
f0110595:	50                   	push   %eax
f0110596:	e8 77 f1 00 00       	call   f011f712 <strcmp>
f011059b:	83 c4 10             	add    $0x10,%esp
f011059e:	85 c0                	test   %eax,%eax
f01105a0:	75 28                	jne    f01105ca <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f01105a2:	e8 5b f6 ff ff       	call   f010fc02 <isKHeapPlacementStrategyBESTFIT>
f01105a7:	84 c0                	test   %al,%al
f01105a9:	75 09                	jne    f01105b4 <tst_kheap+0x346>
f01105ab:	e8 3d f6 ff ff       	call   f010fbed <isKHeapPlacementStrategyFIRSTFIT>
f01105b0:	84 c0                	test   %al,%al
f01105b2:	74 07                	je     f01105bb <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f01105b4:	e8 01 8b 00 00       	call   f01190ba <test_kfree_bestfirstfit>
f01105b9:	eb 05                	jmp    f01105c0 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f01105bb:	e8 b4 c7 00 00       	call   f011cd74 <test_kfree>
		}
		return 0;
f01105c0:	b8 00 00 00 00       	mov    $0x0,%eax
f01105c5:	e9 29 01 00 00       	jmp    f01106f3 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f01105ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105cd:	83 c0 08             	add    $0x8,%eax
f01105d0:	8b 00                	mov    (%eax),%eax
f01105d2:	83 ec 08             	sub    $0x8,%esp
f01105d5:	68 0f 7e 12 f0       	push   $0xf0127e0f
f01105da:	50                   	push   %eax
f01105db:	e8 32 f1 00 00       	call   f011f712 <strcmp>
f01105e0:	83 c4 10             	add    $0x10,%esp
f01105e3:	85 c0                	test   %eax,%eax
f01105e5:	75 0f                	jne    f01105f6 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f01105e7:	e8 2a a1 00 00       	call   f011a716 <test_kheap_phys_addr>
		return 0;
f01105ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01105f1:	e9 fd 00 00 00       	jmp    f01106f3 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f01105f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105f9:	83 c0 08             	add    $0x8,%eax
f01105fc:	8b 00                	mov    (%eax),%eax
f01105fe:	83 ec 08             	sub    $0x8,%esp
f0110601:	68 19 7e 12 f0       	push   $0xf0127e19
f0110606:	50                   	push   %eax
f0110607:	e8 06 f1 00 00       	call   f011f712 <strcmp>
f011060c:	83 c4 10             	add    $0x10,%esp
f011060f:	85 c0                	test   %eax,%eax
f0110611:	75 0f                	jne    f0110622 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110613:	e8 e1 ae 00 00       	call   f011b4f9 <test_kheap_virt_addr>
		return 0;
f0110618:	b8 00 00 00 00       	mov    $0x0,%eax
f011061d:	e9 d1 00 00 00       	jmp    f01106f3 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110622:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110625:	83 c0 08             	add    $0x8,%eax
f0110628:	8b 00                	mov    (%eax),%eax
f011062a:	83 ec 08             	sub    $0x8,%esp
f011062d:	68 e8 7b 12 f0       	push   $0xf0127be8
f0110632:	50                   	push   %eax
f0110633:	e8 da f0 00 00       	call   f011f712 <strcmp>
f0110638:	83 c4 10             	add    $0x10,%esp
f011063b:	85 c0                	test   %eax,%eax
f011063d:	0f 85 89 00 00 00    	jne    f01106cc <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110643:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110646:	83 c0 0c             	add    $0xc,%eax
f0110649:	8b 00                	mov    (%eax),%eax
f011064b:	83 ec 04             	sub    $0x4,%esp
f011064e:	6a 0a                	push   $0xa
f0110650:	6a 00                	push   $0x0
f0110652:	50                   	push   %eax
f0110653:	e8 0e f3 00 00       	call   f011f966 <strtol>
f0110658:	83 c4 10             	add    $0x10,%esp
f011065b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f011065e:	e8 8a f5 ff ff       	call   f010fbed <isKHeapPlacementStrategyFIRSTFIT>
f0110663:	84 c0                	test   %al,%al
f0110665:	74 42                	je     f01106a9 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110667:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011066b:	75 17                	jne    f0110684 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f011066d:	83 ec 0c             	sub    $0xc,%esp
f0110670:	68 d4 7c 12 f0       	push   $0xf0127cd4
f0110675:	e8 11 09 ff ff       	call   f0100f8b <cprintf>
f011067a:	83 c4 10             	add    $0x10,%esp
				return 0;
f011067d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110682:	eb 6f                	jmp    f01106f3 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110684:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110688:	75 07                	jne    f0110691 <tst_kheap+0x423>
				test_krealloc_FF1();
f011068a:	e8 63 c9 00 00       	call   f011cff2 <test_krealloc_FF1>
f011068f:	eb 18                	jmp    f01106a9 <tst_kheap+0x43b>
			else if (testNum==2)
f0110691:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110695:	75 07                	jne    f011069e <tst_kheap+0x430>
				test_krealloc_FF2();
f0110697:	e8 73 c9 00 00       	call   f011d00f <test_krealloc_FF2>
f011069c:	eb 0b                	jmp    f01106a9 <tst_kheap+0x43b>
			else if (testNum==3)
f011069e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01106a2:	75 05                	jne    f01106a9 <tst_kheap+0x43b>
				test_krealloc_FF3();
f01106a4:	e8 83 c9 00 00       	call   f011d02c <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f01106a9:	e8 69 f5 ff ff       	call   f010fc17 <isKHeapPlacementStrategyNEXTFIT>
f01106ae:	84 c0                	test   %al,%al
f01106b0:	74 05                	je     f01106b7 <tst_kheap+0x449>
		{
			test_krealloc();
f01106b2:	e8 01 c9 00 00       	call   f011cfb8 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f01106b7:	e8 46 f5 ff ff       	call   f010fc02 <isKHeapPlacementStrategyBESTFIT>
f01106bc:	84 c0                	test   %al,%al
f01106be:	74 05                	je     f01106c5 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f01106c0:	e8 10 c9 00 00       	call   f011cfd5 <test_krealloc_BF>
		}
		return 0;
f01106c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01106ca:	eb 27                	jmp    f01106f3 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f01106cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106cf:	83 c0 08             	add    $0x8,%eax
f01106d2:	8b 00                	mov    (%eax),%eax
f01106d4:	83 ec 08             	sub    $0x8,%esp
f01106d7:	68 23 7e 12 f0       	push   $0xf0127e23
f01106dc:	50                   	push   %eax
f01106dd:	e8 30 f0 00 00       	call   f011f712 <strcmp>
f01106e2:	83 c4 10             	add    $0x10,%esp
f01106e5:	85 c0                	test   %eax,%eax
f01106e7:	75 05                	jne    f01106ee <tst_kheap+0x480>
	{
		test_ksbrk();
f01106e9:	e8 30 bb 00 00       	call   f011c21e <test_ksbrk>
	}
	return 0;
f01106ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106f3:	c9                   	leave  
f01106f4:	c3                   	ret    

f01106f5 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f01106f5:	55                   	push   %ebp
f01106f6:	89 e5                	mov    %esp,%ebp
f01106f8:	83 ec 28             	sub    $0x28,%esp
f01106fb:	8b 45 14             	mov    0x14(%ebp),%eax
f01106fe:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110701:	8b 45 08             	mov    0x8(%ebp),%eax
f0110704:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110707:	74 1d                	je     f0110726 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110709:	83 ec 04             	sub    $0x4,%esp
f011070c:	ff 75 08             	pushl  0x8(%ebp)
f011070f:	ff 75 0c             	pushl  0xc(%ebp)
f0110712:	68 28 7e 12 f0       	push   $0xf0127e28
f0110717:	e8 6f 08 ff ff       	call   f0100f8b <cprintf>
f011071c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011071f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110724:	eb 55                	jmp    f011077b <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110726:	8b 45 08             	mov    0x8(%ebp),%eax
f0110729:	8b 40 fc             	mov    -0x4(%eax),%eax
f011072c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f011072f:	8b 45 10             	mov    0x10(%ebp),%eax
f0110732:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110735:	8b 45 08             	mov    0x8(%ebp),%eax
f0110738:	01 d0                	add    %edx,%eax
f011073a:	8b 00                	mov    (%eax),%eax
f011073c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f011073f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110743:	0b 45 10             	or     0x10(%ebp),%eax
f0110746:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0110749:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011074c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011074f:	75 08                	jne    f0110759 <check_block+0x64>
f0110751:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110754:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110757:	74 1d                	je     f0110776 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0110759:	ff 75 f0             	pushl  -0x10(%ebp)
f011075c:	ff 75 f4             	pushl  -0xc(%ebp)
f011075f:	ff 75 ec             	pushl  -0x14(%ebp)
f0110762:	68 58 7e 12 f0       	push   $0xf0127e58
f0110767:	e8 1f 08 ff ff       	call   f0100f8b <cprintf>
f011076c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011076f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110774:	eb 05                	jmp    f011077b <check_block+0x86>
	}
	return 1;
f0110776:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011077b:	c9                   	leave  
f011077c:	c3                   	ret    

f011077d <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f011077d:	55                   	push   %ebp
f011077e:	89 e5                	mov    %esp,%ebp
f0110780:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110783:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0110788:	3b 45 08             	cmp    0x8(%ebp),%eax
f011078b:	74 20                	je     f01107ad <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f011078d:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0110792:	83 ec 04             	sub    $0x4,%esp
f0110795:	50                   	push   %eax
f0110796:	ff 75 08             	pushl  0x8(%ebp)
f0110799:	68 94 7e 12 f0       	push   $0xf0127e94
f011079e:	e8 e8 07 ff ff       	call   f0100f8b <cprintf>
f01107a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01107ab:	eb 05                	jmp    f01107b2 <check_list_size+0x35>
	}
	return 1;
f01107ad:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01107b2:	c9                   	leave  
f01107b3:	c3                   	ret    

f01107b4 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f01107b4:	55                   	push   %ebp
f01107b5:	89 e5                	mov    %esp,%ebp
f01107b7:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f01107ba:	83 ec 04             	sub    $0x4,%esp
f01107bd:	68 c8 7e 12 f0       	push   $0xf0127ec8
f01107c2:	6a 3f                	push   $0x3f
f01107c4:	68 28 7f 12 f0       	push   $0xf0127f28
f01107c9:	e8 6b fb fe ff       	call   f0100339 <_panic>

f01107ce <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f01107ce:	55                   	push   %ebp
f01107cf:	89 e5                	mov    %esp,%ebp
f01107d1:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01107d4:	83 ec 04             	sub    $0x4,%esp
f01107d7:	68 4c 7f 12 f0       	push   $0xf0127f4c
f01107dc:	6a 61                	push   $0x61
f01107de:	68 28 7f 12 f0       	push   $0xf0127f28
f01107e3:	e8 51 fb fe ff       	call   f0100339 <_panic>

f01107e8 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f01107e8:	55                   	push   %ebp
f01107e9:	89 e5                	mov    %esp,%ebp
f01107eb:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01107ee:	83 ec 04             	sub    $0x4,%esp
f01107f1:	68 9c 7f 12 f0       	push   $0xf0127f9c
f01107f6:	68 e7 00 00 00       	push   $0xe7
f01107fb:	68 28 7f 12 f0       	push   $0xf0127f28
f0110800:	e8 34 fb fe ff       	call   f0100339 <_panic>

f0110805 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0110805:	55                   	push   %ebp
f0110806:	89 e5                	mov    %esp,%ebp
f0110808:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011080e:	83 ec 04             	sub    $0x4,%esp
f0110811:	68 f0 7f 12 f0       	push   $0xf0127ff0
f0110816:	68 88 01 00 00       	push   $0x188
f011081b:	68 28 7f 12 f0       	push   $0xf0127f28
f0110820:	e8 14 fb fe ff       	call   f0100339 <_panic>

f0110825 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0110825:	55                   	push   %ebp
f0110826:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110828:	90                   	nop
f0110829:	5d                   	pop    %ebp
f011082a:	c3                   	ret    

f011082b <test_free_block_FF>:

void test_free_block_FF()
{
f011082b:	55                   	push   %ebp
f011082c:	89 e5                	mov    %esp,%ebp
f011082e:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110831:	83 ec 04             	sub    $0x4,%esp
f0110834:	68 44 80 12 f0       	push   $0xf0128044
f0110839:	68 4e 02 00 00       	push   $0x24e
f011083e:	68 28 7f 12 f0       	push   $0xf0127f28
f0110843:	e8 f1 fa fe ff       	call   f0100339 <_panic>

f0110848 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110848:	55                   	push   %ebp
f0110849:	89 e5                	mov    %esp,%ebp
f011084b:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011084e:	83 ec 04             	sub    $0x4,%esp
f0110851:	68 44 80 12 f0       	push   $0xf0128044
f0110856:	68 9a 03 00 00       	push   $0x39a
f011085b:	68 28 7f 12 f0       	push   $0xf0127f28
f0110860:	e8 d4 fa fe ff       	call   f0100339 <_panic>

f0110865 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110865:	55                   	push   %ebp
f0110866:	89 e5                	mov    %esp,%ebp
f0110868:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011086b:	83 ec 04             	sub    $0x4,%esp
f011086e:	68 91 80 12 f0       	push   $0xf0128091
f0110873:	68 ba 04 00 00       	push   $0x4ba
f0110878:	68 28 7f 12 f0       	push   $0xf0127f28
f011087d:	e8 b7 fa fe ff       	call   f0100339 <_panic>

f0110882 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110882:	55                   	push   %ebp
f0110883:	89 e5                	mov    %esp,%ebp
f0110885:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110888:	83 ec 04             	sub    $0x4,%esp
f011088b:	68 44 80 12 f0       	push   $0xf0128044
f0110890:	68 c0 04 00 00       	push   $0x4c0
f0110895:	68 28 7f 12 f0       	push   $0xf0127f28
f011089a:	e8 9a fa fe ff       	call   f0100339 <_panic>

f011089f <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f011089f:	55                   	push   %ebp
f01108a0:	89 e5                	mov    %esp,%ebp
f01108a2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01108a5:	83 ec 04             	sub    $0x4,%esp
f01108a8:	68 44 80 12 f0       	push   $0xf0128044
f01108ad:	68 e7 05 00 00       	push   $0x5e7
f01108b2:	68 28 7f 12 f0       	push   $0xf0127f28
f01108b7:	e8 7d fa fe ff       	call   f0100339 <_panic>

f01108bc <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f01108bc:	55                   	push   %ebp
f01108bd:	89 e5                	mov    %esp,%ebp
f01108bf:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01108c2:	e8 dc aa ff ff       	call   f010b3a3 <get_cpu_proc>
f01108c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f01108ca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01108ce:	75 16                	jne    f01108e6 <sys_check_LRU_lists+0x2a>
f01108d0:	68 a4 80 12 f0       	push   $0xf01280a4
f01108d5:	68 b4 80 12 f0       	push   $0xf01280b4
f01108da:	6a 10                	push   $0x10
f01108dc:	68 c9 80 12 f0       	push   $0xf01280c9
f01108e1:	e8 53 fa fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01108e6:	83 ec 0c             	sub    $0xc,%esp
f01108e9:	68 e8 80 12 f0       	push   $0xf01280e8
f01108ee:	e8 98 06 ff ff       	call   f0100f8b <cprintf>
f01108f3:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01108f6:	83 ec 0c             	sub    $0xc,%esp
f01108f9:	ff 75 e0             	pushl  -0x20(%ebp)
f01108fc:	e8 e0 94 ff ff       	call   f0109de1 <env_page_ws_print>
f0110901:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0110904:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110907:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f011090a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0110911:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0110918:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011091c:	0f 84 a5 00 00 00    	je     f01109c7 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0110922:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110929:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011092c:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110932:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110935:	eb 4a                	jmp    f0110981 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0110937:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011093a:	8b 00                	mov    (%eax),%eax
f011093c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011093f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110942:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110947:	89 c2                	mov    %eax,%edx
f0110949:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011094c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110953:	8b 45 08             	mov    0x8(%ebp),%eax
f0110956:	01 c8                	add    %ecx,%eax
f0110958:	8b 00                	mov    (%eax),%eax
f011095a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011095d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110960:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110965:	39 c2                	cmp    %eax,%edx
f0110967:	74 09                	je     f0110972 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0110969:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110970:	eb 3e                	jmp    f01109b0 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0110972:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110975:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110978:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011097e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110981:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110985:	74 08                	je     f011098f <sys_check_LRU_lists+0xd3>
f0110987:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011098a:	8b 40 10             	mov    0x10(%eax),%eax
f011098d:	eb 05                	jmp    f0110994 <sys_check_LRU_lists+0xd8>
f011098f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110994:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110997:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011099d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01109a0:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01109a6:	85 c0                	test   %eax,%eax
f01109a8:	75 8d                	jne    f0110937 <sys_check_LRU_lists+0x7b>
f01109aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01109ae:	75 87                	jne    f0110937 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f01109b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01109b3:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f01109b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01109bc:	39 c2                	cmp    %eax,%edx
f01109be:	74 07                	je     f01109c7 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f01109c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f01109c7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01109cb:	0f 84 a5 00 00 00    	je     f0110a76 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f01109d1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01109d8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01109db:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01109e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01109e4:	eb 4a                	jmp    f0110a30 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01109e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01109e9:	8b 00                	mov    (%eax),%eax
f01109eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01109ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01109f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01109f6:	89 c2                	mov    %eax,%edx
f01109f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01109fb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110a02:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a05:	01 c8                	add    %ecx,%eax
f0110a07:	8b 00                	mov    (%eax),%eax
f0110a09:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0110a0c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110a0f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110a14:	39 c2                	cmp    %eax,%edx
f0110a16:	74 09                	je     f0110a21 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0110a18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0110a1f:	eb 3e                	jmp    f0110a5f <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0110a21:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110a24:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a27:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110a2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110a30:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110a34:	74 08                	je     f0110a3e <sys_check_LRU_lists+0x182>
f0110a36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110a39:	8b 40 10             	mov    0x10(%eax),%eax
f0110a3c:	eb 05                	jmp    f0110a43 <sys_check_LRU_lists+0x187>
f0110a3e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a43:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110a46:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0110a4c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a4f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110a55:	85 c0                	test   %eax,%eax
f0110a57:	75 8d                	jne    f01109e6 <sys_check_LRU_lists+0x12a>
f0110a59:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110a5d:	75 87                	jne    f01109e6 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0110a5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a62:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f0110a68:	8b 45 14             	mov    0x14(%ebp),%eax
f0110a6b:	39 c2                	cmp    %eax,%edx
f0110a6d:	74 07                	je     f0110a76 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0110a6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0110a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110a79:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0110a7c:	c9                   	leave  
f0110a7d:	c3                   	ret    

f0110a7e <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0110a7e:	55                   	push   %ebp
f0110a7f:	89 e5                	mov    %esp,%ebp
f0110a81:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110a84:	e8 1a a9 ff ff       	call   f010b3a3 <get_cpu_proc>
f0110a89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0110a8c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0110a90:	75 16                	jne    f0110aa8 <sys_check_LRU_lists_free+0x2a>
f0110a92:	68 a4 80 12 f0       	push   $0xf01280a4
f0110a97:	68 b4 80 12 f0       	push   $0xf01280b4
f0110a9c:	6a 45                	push   $0x45
f0110a9e:	68 c9 80 12 f0       	push   $0xf01280c9
f0110aa3:	e8 91 f8 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0110aa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110aab:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0110aae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110ab5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110ab8:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110abe:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110ac1:	eb 65                	jmp    f0110b28 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0110ac3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110aca:	eb 3a                	jmp    f0110b06 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110acc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110acf:	8b 00                	mov    (%eax),%eax
f0110ad1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110ad4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110ad7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110adc:	89 c2                	mov    %eax,%edx
f0110ade:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110ae1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110ae8:	8b 45 08             	mov    0x8(%ebp),%eax
f0110aeb:	01 c8                	add    %ecx,%eax
f0110aed:	8b 00                	mov    (%eax),%eax
f0110aef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0110af2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110af5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110afa:	39 c2                	cmp    %eax,%edx
f0110afc:	75 05                	jne    f0110b03 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0110afe:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110b01:	eb 0b                	jmp    f0110b0e <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0110b03:	ff 45 ec             	incl   -0x14(%ebp)
f0110b06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110b09:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110b0c:	7c be                	jl     f0110acc <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110b0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b12:	7e 08                	jle    f0110b1c <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0110b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b17:	e9 ed 00 00 00       	jmp    f0110c09 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110b1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b1f:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110b25:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110b28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b2c:	74 08                	je     f0110b36 <sys_check_LRU_lists_free+0xb8>
f0110b2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110b31:	8b 40 10             	mov    0x10(%eax),%eax
f0110b34:	eb 05                	jmp    f0110b3b <sys_check_LRU_lists_free+0xbd>
f0110b36:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b3b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110b3e:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110b44:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b47:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110b4d:	85 c0                	test   %eax,%eax
f0110b4f:	0f 85 6e ff ff ff    	jne    f0110ac3 <sys_check_LRU_lists_free+0x45>
f0110b55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b59:	0f 85 64 ff ff ff    	jne    f0110ac3 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110b5f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b62:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0110b68:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110b6b:	eb 62                	jmp    f0110bcf <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0110b6d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110b74:	eb 3a                	jmp    f0110bb0 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110b76:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110b79:	8b 00                	mov    (%eax),%eax
f0110b7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0110b7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110b81:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110b86:	89 c2                	mov    %eax,%edx
f0110b88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110b8b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b95:	01 c8                	add    %ecx,%eax
f0110b97:	8b 00                	mov    (%eax),%eax
f0110b99:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110b9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110b9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110ba4:	39 c2                	cmp    %eax,%edx
f0110ba6:	75 05                	jne    f0110bad <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0110ba8:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110bab:	eb 0b                	jmp    f0110bb8 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0110bad:	ff 45 e8             	incl   -0x18(%ebp)
f0110bb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110bb3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110bb6:	7c be                	jl     f0110b76 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110bb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110bbc:	7e 05                	jle    f0110bc3 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0110bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110bc1:	eb 46                	jmp    f0110c09 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110bc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110bc6:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110bcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110bcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110bd3:	74 08                	je     f0110bdd <sys_check_LRU_lists_free+0x15f>
f0110bd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110bd8:	8b 40 10             	mov    0x10(%eax),%eax
f0110bdb:	eb 05                	jmp    f0110be2 <sys_check_LRU_lists_free+0x164>
f0110bdd:	b8 00 00 00 00       	mov    $0x0,%eax
f0110be2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110be5:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0110beb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110bee:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110bf4:	85 c0                	test   %eax,%eax
f0110bf6:	0f 85 71 ff ff ff    	jne    f0110b6d <sys_check_LRU_lists_free+0xef>
f0110bfc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110c00:	0f 85 67 ff ff ff    	jne    f0110b6d <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0110c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110c09:	c9                   	leave  
f0110c0a:	c3                   	ret    

f0110c0b <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0110c0b:	55                   	push   %ebp
f0110c0c:	89 e5                	mov    %esp,%ebp
f0110c0e:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0110c11:	e8 8d a7 ff ff       	call   f010b3a3 <get_cpu_proc>
f0110c16:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0110c19:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0110c1d:	75 16                	jne    f0110c35 <sys_check_WS_list+0x2a>
f0110c1f:	68 a4 80 12 f0       	push   $0xf01280a4
f0110c24:	68 b4 80 12 f0       	push   $0xf01280b4
f0110c29:	6a 79                	push   $0x79
f0110c2b:	68 c9 80 12 f0       	push   $0xf01280c9
f0110c30:	e8 04 f7 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0110c35:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110c38:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0110c3b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0110c42:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110c46:	74 06                	je     f0110c4e <sys_check_WS_list+0x43>
f0110c48:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110c4c:	75 1f                	jne    f0110c6d <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0110c4e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c51:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0110c57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c5a:	39 c2                	cmp    %eax,%edx
f0110c5c:	74 0f                	je     f0110c6d <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0110c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110c65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c68:	e9 15 03 00 00       	jmp    f0110f82 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0110c6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110c71:	74 39                	je     f0110cac <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110c73:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c76:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110c7c:	8b 00                	mov    (%eax),%eax
f0110c7e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0110c81:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110c84:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c89:	89 c2                	mov    %eax,%edx
f0110c8b:	8b 45 10             	mov    0x10(%ebp),%eax
f0110c8e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0110c91:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110c94:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c99:	39 c2                	cmp    %eax,%edx
f0110c9b:	74 0f                	je     f0110cac <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0110c9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ca7:	e9 d6 02 00 00       	jmp    f0110f82 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0110cac:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110cb0:	0f 85 3c 01 00 00    	jne    f0110df2 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0110cb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0110cbd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110cc1:	74 4c                	je     f0110d0f <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110cc3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110cca:	eb 3b                	jmp    f0110d07 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110ccc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110ccf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110cd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0110cd9:	01 d0                	add    %edx,%eax
f0110cdb:	8b 00                	mov    (%eax),%eax
f0110cdd:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0110ce0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110ce3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110ce8:	89 c2                	mov    %eax,%edx
f0110cea:	8b 45 10             	mov    0x10(%ebp),%eax
f0110ced:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0110cf0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110cf3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110cf8:	39 c2                	cmp    %eax,%edx
f0110cfa:	75 08                	jne    f0110d04 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0110cfc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110cff:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0110d02:	eb 0b                	jmp    f0110d0f <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110d04:	ff 45 e8             	incl   -0x18(%ebp)
f0110d07:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110d0a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110d0d:	7c bd                	jl     f0110ccc <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0110d0f:	83 ec 08             	sub    $0x8,%esp
f0110d12:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d15:	68 10 81 12 f0       	push   $0xf0128110
f0110d1a:	e8 6c 02 ff ff       	call   f0100f8b <cprintf>
f0110d1f:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0110d22:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d25:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110d2b:	85 c0                	test   %eax,%eax
f0110d2d:	74 0e                	je     f0110d3d <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0110d2f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d32:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110d38:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110d3b:	eb 0c                	jmp    f0110d49 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110d3d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d40:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110d46:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0110d49:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d4c:	8b 00                	mov    (%eax),%eax
f0110d4e:	83 ec 08             	sub    $0x8,%esp
f0110d51:	50                   	push   %eax
f0110d52:	68 2f 81 12 f0       	push   $0xf012812f
f0110d57:	e8 2f 02 ff ff       	call   f0100f8b <cprintf>
f0110d5c:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110d5f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0110d66:	eb 79                	jmp    f0110de1 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0110d68:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d6b:	8b 00                	mov    (%eax),%eax
f0110d6d:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0110d70:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0110d73:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d78:	89 c2                	mov    %eax,%edx
f0110d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d7d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110d84:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d87:	01 c8                	add    %ecx,%eax
f0110d89:	8b 00                	mov    (%eax),%eax
f0110d8b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0110d8e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110d91:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d96:	39 c2                	cmp    %eax,%edx
f0110d98:	74 0c                	je     f0110da6 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0110d9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110da1:	e9 d9 01 00 00       	jmp    f0110f7f <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0110da6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110da9:	40                   	inc    %eax
f0110daa:	89 c2                	mov    %eax,%edx
f0110dac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110daf:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0110db5:	89 d0                	mov    %edx,%eax
f0110db7:	ba 00 00 00 00       	mov    $0x0,%edx
f0110dbc:	f7 f1                	div    %ecx
f0110dbe:	89 d0                	mov    %edx,%eax
f0110dc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0110dc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110dc6:	8b 40 10             	mov    0x10(%eax),%eax
f0110dc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0110dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110dd0:	75 0c                	jne    f0110dde <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110dd2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110dd5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110ddb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110dde:	ff 45 e4             	incl   -0x1c(%ebp)
f0110de1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110de4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110de7:	0f 8c 7b ff ff ff    	jl     f0110d68 <sys_check_WS_list+0x15d>
f0110ded:	e9 8d 01 00 00       	jmp    f0110f7f <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0110df2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110df6:	74 0a                	je     f0110e02 <sys_check_WS_list+0x1f7>
f0110df8:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110dfc:	0f 85 be 00 00 00    	jne    f0110ec0 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110e02:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0110e09:	e9 a1 00 00 00       	jmp    f0110eaf <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0110e0e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110e15:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e18:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110e1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110e21:	eb 47                	jmp    f0110e6a <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110e23:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e26:	8b 00                	mov    (%eax),%eax
f0110e28:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0110e2b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110e2e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110e33:	89 c2                	mov    %eax,%edx
f0110e35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110e38:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110e3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e42:	01 c8                	add    %ecx,%eax
f0110e44:	8b 00                	mov    (%eax),%eax
f0110e46:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110e49:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110e4c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110e51:	39 c2                	cmp    %eax,%edx
f0110e53:	75 09                	jne    f0110e5e <sys_check_WS_list+0x253>
				{
					found = 1;
f0110e55:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0110e5c:	eb 3b                	jmp    f0110e99 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110e5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e61:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e67:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110e6a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e6e:	74 08                	je     f0110e78 <sys_check_WS_list+0x26d>
f0110e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e73:	8b 40 10             	mov    0x10(%eax),%eax
f0110e76:	eb 05                	jmp    f0110e7d <sys_check_WS_list+0x272>
f0110e78:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e7d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110e80:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110e86:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e89:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e8f:	85 c0                	test   %eax,%eax
f0110e91:	75 90                	jne    f0110e23 <sys_check_WS_list+0x218>
f0110e93:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e97:	75 8a                	jne    f0110e23 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0110e99:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0110e9d:	75 0d                	jne    f0110eac <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0110e9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110ea6:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110ea7:	e9 d3 00 00 00       	jmp    f0110f7f <sys_check_WS_list+0x374>
f0110eac:	ff 45 e0             	incl   -0x20(%ebp)
f0110eaf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110eb2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110eb5:	0f 8c 53 ff ff ff    	jl     f0110e0e <sys_check_WS_list+0x203>
f0110ebb:	e9 bf 00 00 00       	jmp    f0110f7f <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0110ec0:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0110ec4:	0f 85 b5 00 00 00    	jne    f0110f7f <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110eca:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110ed1:	e9 9d 00 00 00       	jmp    f0110f73 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0110ed6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110edd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110ee0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110ee6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110ee9:	eb 47                	jmp    f0110f32 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110eeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110eee:	8b 00                	mov    (%eax),%eax
f0110ef0:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0110ef3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110ef6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110efb:	89 c2                	mov    %eax,%edx
f0110efd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110f00:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110f07:	8b 45 08             	mov    0x8(%ebp),%eax
f0110f0a:	01 c8                	add    %ecx,%eax
f0110f0c:	8b 00                	mov    (%eax),%eax
f0110f0e:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0110f11:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0110f14:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110f19:	39 c2                	cmp    %eax,%edx
f0110f1b:	75 09                	jne    f0110f26 <sys_check_WS_list+0x31b>
				{
					found = 1;
f0110f1d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0110f24:	eb 3b                	jmp    f0110f61 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110f26:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110f29:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110f2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110f32:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f36:	74 08                	je     f0110f40 <sys_check_WS_list+0x335>
f0110f38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110f3b:	8b 40 10             	mov    0x10(%eax),%eax
f0110f3e:	eb 05                	jmp    f0110f45 <sys_check_WS_list+0x33a>
f0110f40:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f45:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110f48:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110f4e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110f51:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110f57:	85 c0                	test   %eax,%eax
f0110f59:	75 90                	jne    f0110eeb <sys_check_WS_list+0x2e0>
f0110f5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f5f:	75 8a                	jne    f0110eeb <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0110f61:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0110f65:	74 09                	je     f0110f70 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0110f67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110f6e:	eb 0f                	jmp    f0110f7f <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110f70:	ff 45 d8             	incl   -0x28(%ebp)
f0110f73:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110f76:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110f79:	0f 8c 57 ff ff ff    	jl     f0110ed6 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0110f7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0110f82:	c9                   	leave  
f0110f83:	c3                   	ret    

f0110f84 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0110f84:	55                   	push   %ebp
f0110f85:	89 e5                	mov    %esp,%ebp
f0110f87:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0110f8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0110f91:	8b 15 24 da 6b f0    	mov    0xf06bda24,%edx
f0110f97:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f9a:	39 c2                	cmp    %eax,%edx
f0110f9c:	74 0a                	je     f0110fa8 <hasExpectedCommands+0x24>
		return 0;
f0110f9e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fa3:	e9 8b 00 00 00       	jmp    f0111033 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0110fa8:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0110fad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110fb0:	eb 55                	jmp    f0111007 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110fb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110fb9:	eb 2a                	jmp    f0110fe5 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0110fbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110fbe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110fc5:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fc8:	01 d0                	add    %edx,%eax
f0110fca:	8b 10                	mov    (%eax),%edx
f0110fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fcf:	8b 00                	mov    (%eax),%eax
f0110fd1:	83 ec 08             	sub    $0x8,%esp
f0110fd4:	52                   	push   %edx
f0110fd5:	50                   	push   %eax
f0110fd6:	e8 37 e7 00 00       	call   f011f712 <strcmp>
f0110fdb:	83 c4 10             	add    $0x10,%esp
f0110fde:	85 c0                	test   %eax,%eax
f0110fe0:	74 0d                	je     f0110fef <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110fe2:	ff 45 f0             	incl   -0x10(%ebp)
f0110fe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110fe8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110feb:	7c ce                	jl     f0110fbb <hasExpectedCommands+0x37>
f0110fed:	eb 01                	jmp    f0110ff0 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0110fef:	90                   	nop
		if (i == commandsCount)
f0110ff0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ff3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110ff6:	75 07                	jne    f0110fff <hasExpectedCommands+0x7b>
			return 0;
f0110ff8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ffd:	eb 34                	jmp    f0111033 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0110fff:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0111004:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111007:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011100b:	74 08                	je     f0111015 <hasExpectedCommands+0x91>
f011100d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111010:	8b 40 10             	mov    0x10(%eax),%eax
f0111013:	eb 05                	jmp    f011101a <hasExpectedCommands+0x96>
f0111015:	b8 00 00 00 00       	mov    $0x0,%eax
f011101a:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f011101f:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0111024:	85 c0                	test   %eax,%eax
f0111026:	75 8a                	jne    f0110fb2 <hasExpectedCommands+0x2e>
f0111028:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011102c:	75 84                	jne    f0110fb2 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011102e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111033:	c9                   	leave  
f0111034:	c3                   	ret    

f0111035 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111035:	55                   	push   %ebp
f0111036:	89 e5                	mov    %esp,%ebp
f0111038:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011103b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111042:	eb 2e                	jmp    f0111072 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111044:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111047:	89 d0                	mov    %edx,%eax
f0111049:	01 c0                	add    %eax,%eax
f011104b:	01 d0                	add    %edx,%eax
f011104d:	c1 e0 03             	shl    $0x3,%eax
f0111050:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0111055:	8b 00                	mov    (%eax),%eax
f0111057:	83 ec 08             	sub    $0x8,%esp
f011105a:	ff 75 08             	pushl  0x8(%ebp)
f011105d:	50                   	push   %eax
f011105e:	e8 af e6 00 00       	call   f011f712 <strcmp>
f0111063:	83 c4 10             	add    $0x10,%esp
f0111066:	85 c0                	test   %eax,%eax
f0111068:	75 05                	jne    f011106f <getIndexOfCommand+0x3a>
			return i;
f011106a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011106d:	eb 14                	jmp    f0111083 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011106f:	ff 45 f4             	incl   -0xc(%ebp)
f0111072:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111075:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f011107a:	39 c2                	cmp    %eax,%edx
f011107c:	72 c6                	jb     f0111044 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011107e:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111083:	c9                   	leave  
f0111084:	c3                   	ret    

f0111085 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111085:	55                   	push   %ebp
f0111086:	89 e5                	mov    %esp,%ebp
f0111088:	57                   	push   %edi
f0111089:	56                   	push   %esi
f011108a:	53                   	push   %ebx
f011108b:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111091:	83 ec 0c             	sub    $0xc,%esp
f0111094:	68 60 81 12 f0       	push   $0xf0128160
f0111099:	e8 ed fe fe ff       	call   f0100f8b <cprintf>
f011109e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01110a1:	83 ec 0c             	sub    $0xc,%esp
f01110a4:	68 84 81 12 f0       	push   $0xf0128184
f01110a9:	e8 dd fe fe ff       	call   f0100f8b <cprintf>
f01110ae:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01110b1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01110b8:	c7 45 8c 9f 81 12 f0 	movl   $0xf012819f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01110bf:	83 ec 08             	sub    $0x8,%esp
f01110c2:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01110c5:	50                   	push   %eax
f01110c6:	6a 01                	push   $0x1
f01110c8:	e8 03 11 ff ff       	call   f01021d0 <process_command>
f01110cd:	83 c4 10             	add    $0x10,%esp
f01110d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01110d3:	83 ec 0c             	sub    $0xc,%esp
f01110d6:	68 ac 81 12 f0       	push   $0xf01281ac
f01110db:	e8 ab fe fe ff       	call   f0100f8b <cprintf>
f01110e0:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01110e3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01110e6:	83 ec 0c             	sub    $0xc,%esp
f01110e9:	50                   	push   %eax
f01110ea:	e8 46 ff ff ff       	call   f0111035 <getIndexOfCommand>
f01110ef:	83 c4 10             	add    $0x10,%esp
f01110f2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01110f5:	75 0f                	jne    f0111106 <TestAutoCompleteCommand+0x81>
f01110f7:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01110fc:	85 c0                	test   %eax,%eax
f01110fe:	75 06                	jne    f0111106 <TestAutoCompleteCommand+0x81>
		eval += 15;
f0111100:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111104:	eb 10                	jmp    f0111116 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111106:	83 ec 0c             	sub    $0xc,%esp
f0111109:	68 dc 81 12 f0       	push   $0xf01281dc
f011110e:	e8 78 fe fe ff       	call   f0100f8b <cprintf>
f0111113:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0111116:	83 ec 0c             	sub    $0xc,%esp
f0111119:	68 2c 82 12 f0       	push   $0xf012822c
f011111e:	e8 68 fe fe ff       	call   f0100f8b <cprintf>
f0111123:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111126:	c7 45 88 52 82 12 f0 	movl   $0xf0128252,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f011112d:	83 ec 08             	sub    $0x8,%esp
f0111130:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111133:	50                   	push   %eax
f0111134:	6a 01                	push   $0x1
f0111136:	e8 95 10 ff ff       	call   f01021d0 <process_command>
f011113b:	83 c4 10             	add    $0x10,%esp
f011113e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111141:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111145:	75 30                	jne    f0111177 <TestAutoCompleteCommand+0xf2>
f0111147:	8d 45 90             	lea    -0x70(%ebp),%eax
f011114a:	bb 30 86 12 f0       	mov    $0xf0128630,%ebx
f011114f:	ba 03 00 00 00       	mov    $0x3,%edx
f0111154:	89 c7                	mov    %eax,%edi
f0111156:	89 de                	mov    %ebx,%esi
f0111158:	89 d1                	mov    %edx,%ecx
f011115a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011115c:	83 ec 08             	sub    $0x8,%esp
f011115f:	6a 03                	push   $0x3
f0111161:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111164:	50                   	push   %eax
f0111165:	e8 1a fe ff ff       	call   f0110f84 <hasExpectedCommands>
f011116a:	83 c4 10             	add    $0x10,%esp
f011116d:	85 c0                	test   %eax,%eax
f011116f:	74 06                	je     f0111177 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111171:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111175:	eb 10                	jmp    f0111187 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111177:	83 ec 0c             	sub    $0xc,%esp
f011117a:	68 58 82 12 f0       	push   $0xf0128258
f011117f:	e8 07 fe fe ff       	call   f0100f8b <cprintf>
f0111184:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111187:	83 ec 0c             	sub    $0xc,%esp
f011118a:	68 a8 82 12 f0       	push   $0xf01282a8
f011118f:	e8 f7 fd fe ff       	call   f0100f8b <cprintf>
f0111194:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111197:	c7 45 84 cd 82 12 f0 	movl   $0xf01282cd,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011119e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01111a1:	83 ec 04             	sub    $0x4,%esp
f01111a4:	50                   	push   %eax
f01111a5:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01111a8:	50                   	push   %eax
f01111a9:	68 d0 82 12 f0       	push   $0xf01282d0
f01111ae:	e8 d8 fd fe ff       	call   f0100f8b <cprintf>
f01111b3:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01111b6:	83 ec 08             	sub    $0x8,%esp
f01111b9:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01111bc:	50                   	push   %eax
f01111bd:	6a 01                	push   $0x1
f01111bf:	e8 0c 10 ff ff       	call   f01021d0 <process_command>
f01111c4:	83 c4 10             	add    $0x10,%esp
f01111c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01111ca:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01111ce:	75 1b                	jne    f01111eb <TestAutoCompleteCommand+0x166>
f01111d0:	83 ec 08             	sub    $0x8,%esp
f01111d3:	6a 01                	push   $0x1
f01111d5:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01111d8:	50                   	push   %eax
f01111d9:	e8 a6 fd ff ff       	call   f0110f84 <hasExpectedCommands>
f01111de:	83 c4 10             	add    $0x10,%esp
f01111e1:	85 c0                	test   %eax,%eax
f01111e3:	74 06                	je     f01111eb <TestAutoCompleteCommand+0x166>
		eval += 15;
f01111e5:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01111e9:	eb 10                	jmp    f01111fb <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01111eb:	83 ec 0c             	sub    $0xc,%esp
f01111ee:	68 f0 82 12 f0       	push   $0xf01282f0
f01111f3:	e8 93 fd fe ff       	call   f0100f8b <cprintf>
f01111f8:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01111fb:	83 ec 0c             	sub    $0xc,%esp
f01111fe:	68 48 83 12 f0       	push   $0xf0128348
f0111203:	e8 83 fd fe ff       	call   f0100f8b <cprintf>
f0111208:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f011120b:	c7 45 80 6e 83 12 f0 	movl   $0xf012836e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111212:	83 ec 08             	sub    $0x8,%esp
f0111215:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111218:	50                   	push   %eax
f0111219:	6a 01                	push   $0x1
f011121b:	e8 b0 0f ff ff       	call   f01021d0 <process_command>
f0111220:	83 c4 10             	add    $0x10,%esp
f0111223:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111226:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f011122a:	75 0f                	jne    f011123b <TestAutoCompleteCommand+0x1b6>
f011122c:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0111231:	85 c0                	test   %eax,%eax
f0111233:	75 06                	jne    f011123b <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111235:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111239:	eb 10                	jmp    f011124b <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011123b:	83 ec 0c             	sub    $0xc,%esp
f011123e:	68 74 83 12 f0       	push   $0xf0128374
f0111243:	e8 43 fd fe ff       	call   f0100f8b <cprintf>
f0111248:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011124b:	83 ec 0c             	sub    $0xc,%esp
f011124e:	68 c4 83 12 f0       	push   $0xf01283c4
f0111253:	e8 33 fd fe ff       	call   f0100f8b <cprintf>
f0111258:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011125b:	c7 85 7c ff ff ff e9 	movl   $0xf01283e9,-0x84(%ebp)
f0111262:	83 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111265:	83 ec 08             	sub    $0x8,%esp
f0111268:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011126e:	50                   	push   %eax
f011126f:	6a 01                	push   $0x1
f0111271:	e8 5a 0f ff ff       	call   f01021d0 <process_command>
f0111276:	83 c4 10             	add    $0x10,%esp
f0111279:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011127c:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111280:	75 30                	jne    f01112b2 <TestAutoCompleteCommand+0x22d>
f0111282:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111285:	bb c0 86 12 f0       	mov    $0xf01286c0,%ebx
f011128a:	ba 0c 00 00 00       	mov    $0xc,%edx
f011128f:	89 c7                	mov    %eax,%edi
f0111291:	89 de                	mov    %ebx,%esi
f0111293:	89 d1                	mov    %edx,%ecx
f0111295:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111297:	83 ec 08             	sub    $0x8,%esp
f011129a:	6a 0c                	push   $0xc
f011129c:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011129f:	50                   	push   %eax
f01112a0:	e8 df fc ff ff       	call   f0110f84 <hasExpectedCommands>
f01112a5:	83 c4 10             	add    $0x10,%esp
f01112a8:	85 c0                	test   %eax,%eax
f01112aa:	74 06                	je     f01112b2 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01112ac:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01112b0:	eb 10                	jmp    f01112c2 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01112b2:	83 ec 0c             	sub    $0xc,%esp
f01112b5:	68 ec 83 12 f0       	push   $0xf01283ec
f01112ba:	e8 cc fc fe ff       	call   f0100f8b <cprintf>
f01112bf:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01112c2:	83 ec 0c             	sub    $0xc,%esp
f01112c5:	68 44 84 12 f0       	push   $0xf0128444
f01112ca:	e8 bc fc fe ff       	call   f0100f8b <cprintf>
f01112cf:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01112d2:	c7 85 78 ff ff ff 69 	movl   $0xf0128469,-0x88(%ebp)
f01112d9:	84 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01112dc:	83 ec 08             	sub    $0x8,%esp
f01112df:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01112e5:	50                   	push   %eax
f01112e6:	6a 01                	push   $0x1
f01112e8:	e8 e3 0e ff ff       	call   f01021d0 <process_command>
f01112ed:	83 c4 10             	add    $0x10,%esp
f01112f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01112f3:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01112f7:	75 30                	jne    f0111329 <TestAutoCompleteCommand+0x2a4>
f01112f9:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01112fc:	bb 08 87 12 f0       	mov    $0xf0128708,%ebx
f0111301:	ba 05 00 00 00       	mov    $0x5,%edx
f0111306:	89 c7                	mov    %eax,%edi
f0111308:	89 de                	mov    %ebx,%esi
f011130a:	89 d1                	mov    %edx,%ecx
f011130c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011130e:	83 ec 08             	sub    $0x8,%esp
f0111311:	6a 05                	push   $0x5
f0111313:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111316:	50                   	push   %eax
f0111317:	e8 68 fc ff ff       	call   f0110f84 <hasExpectedCommands>
f011131c:	83 c4 10             	add    $0x10,%esp
f011131f:	85 c0                	test   %eax,%eax
f0111321:	74 06                	je     f0111329 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111323:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111327:	eb 10                	jmp    f0111339 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111329:	83 ec 0c             	sub    $0xc,%esp
f011132c:	68 6c 84 12 f0       	push   $0xf012846c
f0111331:	e8 55 fc fe ff       	call   f0100f8b <cprintf>
f0111336:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111339:	83 ec 0c             	sub    $0xc,%esp
f011133c:	68 c4 84 12 f0       	push   $0xf01284c4
f0111341:	e8 45 fc fe ff       	call   f0100f8b <cprintf>
f0111346:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111349:	c7 85 70 ff ff ff f0 	movl   $0xf01284f0,-0x90(%ebp)
f0111350:	84 12 f0 
f0111353:	c7 85 74 ff ff ff f5 	movl   $0xf01284f5,-0x8c(%ebp)
f011135a:	84 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011135d:	83 ec 08             	sub    $0x8,%esp
f0111360:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111366:	50                   	push   %eax
f0111367:	6a 02                	push   $0x2
f0111369:	e8 62 0e ff ff       	call   f01021d0 <process_command>
f011136e:	83 c4 10             	add    $0x10,%esp
f0111371:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111374:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011137a:	83 ec 0c             	sub    $0xc,%esp
f011137d:	50                   	push   %eax
f011137e:	e8 b2 fc ff ff       	call   f0111035 <getIndexOfCommand>
f0111383:	83 c4 10             	add    $0x10,%esp
f0111386:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111389:	75 0f                	jne    f011139a <TestAutoCompleteCommand+0x315>
f011138b:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0111390:	85 c0                	test   %eax,%eax
f0111392:	75 06                	jne    f011139a <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111394:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111398:	eb 10                	jmp    f01113aa <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011139a:	83 ec 0c             	sub    $0xc,%esp
f011139d:	68 fc 84 12 f0       	push   $0xf01284fc
f01113a2:	e8 e4 fb fe ff       	call   f0100f8b <cprintf>
f01113a7:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01113aa:	83 ec 0c             	sub    $0xc,%esp
f01113ad:	68 4c 85 12 f0       	push   $0xf012854c
f01113b2:	e8 d4 fb fe ff       	call   f0100f8b <cprintf>
f01113b7:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f01113ba:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01113c0:	bb 30 87 12 f0       	mov    $0xf0128730,%ebx
f01113c5:	ba 03 00 00 00       	mov    $0x3,%edx
f01113ca:	89 c7                	mov    %eax,%edi
f01113cc:	89 de                	mov    %ebx,%esi
f01113ce:	89 d1                	mov    %edx,%ecx
f01113d0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01113d2:	83 ec 08             	sub    $0x8,%esp
f01113d5:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01113db:	50                   	push   %eax
f01113dc:	6a 03                	push   $0x3
f01113de:	e8 ed 0d ff ff       	call   f01021d0 <process_command>
f01113e3:	83 c4 10             	add    $0x10,%esp
f01113e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01113e9:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01113ef:	83 ec 0c             	sub    $0xc,%esp
f01113f2:	50                   	push   %eax
f01113f3:	e8 3d fc ff ff       	call   f0111035 <getIndexOfCommand>
f01113f8:	83 c4 10             	add    $0x10,%esp
f01113fb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01113fe:	75 0f                	jne    f011140f <TestAutoCompleteCommand+0x38a>
f0111400:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0111405:	85 c0                	test   %eax,%eax
f0111407:	75 06                	jne    f011140f <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111409:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011140d:	eb 10                	jmp    f011141f <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011140f:	83 ec 0c             	sub    $0xc,%esp
f0111412:	68 80 85 12 f0       	push   $0xf0128580
f0111417:	e8 6f fb fe ff       	call   f0100f8b <cprintf>
f011141c:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f011141f:	83 ec 08             	sub    $0x8,%esp
f0111422:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111425:	68 d0 85 12 f0       	push   $0xf01285d0
f011142a:	e8 5c fb fe ff       	call   f0100f8b <cprintf>
f011142f:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111432:	83 ec 0c             	sub    $0xc,%esp
f0111435:	68 00 86 12 f0       	push   $0xf0128600
f011143a:	e8 4c fb fe ff       	call   f0100f8b <cprintf>
f011143f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111442:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111447:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011144a:	5b                   	pop    %ebx
f011144b:	5e                   	pop    %esi
f011144c:	5f                   	pop    %edi
f011144d:	5d                   	pop    %ebp
f011144e:	c3                   	ret    

f011144f <test_str2lower_function>:

int test_str2lower_function()
{
f011144f:	55                   	push   %ebp
f0111450:	89 e5                	mov    %esp,%ebp
f0111452:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111458:	83 ec 0c             	sub    $0xc,%esp
f011145b:	68 3c 87 12 f0       	push   $0xf012873c
f0111460:	e8 26 fb fe ff       	call   f0100f8b <cprintf>
f0111465:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111468:	83 ec 0c             	sub    $0xc,%esp
f011146b:	68 5d 87 12 f0       	push   $0xf012875d
f0111470:	e8 16 fb fe ff       	call   f0100f8b <cprintf>
f0111475:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111478:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f011147f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111486:	c7 45 ec 77 87 12 f0 	movl   $0xf0128777,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011148d:	83 ec 08             	sub    $0x8,%esp
f0111490:	ff 75 ec             	pushl  -0x14(%ebp)
f0111493:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111499:	50                   	push   %eax
f011149a:	e8 50 e8 00 00       	call   f011fcef <str2lower>
f011149f:	83 c4 10             	add    $0x10,%esp
f01114a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f01114a5:	83 ec 0c             	sub    $0xc,%esp
f01114a8:	ff 75 e8             	pushl  -0x18(%ebp)
f01114ab:	e8 56 e1 00 00       	call   f011f606 <strlen>
f01114b0:	83 c4 10             	add    $0x10,%esp
f01114b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f01114b6:	83 ec 08             	sub    $0x8,%esp
f01114b9:	68 82 87 12 f0       	push   $0xf0128782
f01114be:	ff 75 e8             	pushl  -0x18(%ebp)
f01114c1:	e8 4c e2 00 00       	call   f011f712 <strcmp>
f01114c6:	83 c4 10             	add    $0x10,%esp
f01114c9:	85 c0                	test   %eax,%eax
f01114cb:	75 13                	jne    f01114e0 <test_str2lower_function+0x91>
f01114cd:	83 ec 0c             	sub    $0xc,%esp
f01114d0:	ff 75 ec             	pushl  -0x14(%ebp)
f01114d3:	e8 2e e1 00 00       	call   f011f606 <strlen>
f01114d8:	83 c4 10             	add    $0x10,%esp
f01114db:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01114de:	74 15                	je     f01114f5 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01114e0:	83 ec 08             	sub    $0x8,%esp
f01114e3:	ff 75 e8             	pushl  -0x18(%ebp)
f01114e6:	68 90 87 12 f0       	push   $0xf0128790
f01114eb:	e8 9b fa fe ff       	call   f0100f8b <cprintf>
f01114f0:	83 c4 10             	add    $0x10,%esp
f01114f3:	eb 04                	jmp    f01114f9 <test_str2lower_function+0xaa>
	else
		eval += 10;
f01114f5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01114f9:	c7 45 e0 f2 87 12 f0 	movl   $0xf01287f2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111500:	83 ec 08             	sub    $0x8,%esp
f0111503:	ff 75 e0             	pushl  -0x20(%ebp)
f0111506:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011150c:	50                   	push   %eax
f011150d:	e8 dd e7 00 00       	call   f011fcef <str2lower>
f0111512:	83 c4 10             	add    $0x10,%esp
f0111515:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111518:	83 ec 0c             	sub    $0xc,%esp
f011151b:	ff 75 e8             	pushl  -0x18(%ebp)
f011151e:	e8 e3 e0 00 00       	call   f011f606 <strlen>
f0111523:	83 c4 10             	add    $0x10,%esp
f0111526:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111529:	83 ec 08             	sub    $0x8,%esp
f011152c:	68 f2 87 12 f0       	push   $0xf01287f2
f0111531:	ff 75 e8             	pushl  -0x18(%ebp)
f0111534:	e8 d9 e1 00 00       	call   f011f712 <strcmp>
f0111539:	83 c4 10             	add    $0x10,%esp
f011153c:	85 c0                	test   %eax,%eax
f011153e:	75 13                	jne    f0111553 <test_str2lower_function+0x104>
f0111540:	83 ec 0c             	sub    $0xc,%esp
f0111543:	ff 75 e0             	pushl  -0x20(%ebp)
f0111546:	e8 bb e0 00 00       	call   f011f606 <strlen>
f011154b:	83 c4 10             	add    $0x10,%esp
f011154e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111551:	74 15                	je     f0111568 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111553:	83 ec 08             	sub    $0x8,%esp
f0111556:	ff 75 e8             	pushl  -0x18(%ebp)
f0111559:	68 f4 87 12 f0       	push   $0xf01287f4
f011155e:	e8 28 fa fe ff       	call   f0100f8b <cprintf>
f0111563:	83 c4 10             	add    $0x10,%esp
f0111566:	eb 04                	jmp    f011156c <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111568:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011156c:	c7 45 dc 4c 88 12 f0 	movl   $0xf012884c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111573:	83 ec 08             	sub    $0x8,%esp
f0111576:	ff 75 dc             	pushl  -0x24(%ebp)
f0111579:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f011157f:	50                   	push   %eax
f0111580:	e8 6a e7 00 00       	call   f011fcef <str2lower>
f0111585:	83 c4 10             	add    $0x10,%esp
f0111588:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011158b:	83 ec 0c             	sub    $0xc,%esp
f011158e:	ff 75 e8             	pushl  -0x18(%ebp)
f0111591:	e8 70 e0 00 00       	call   f011f606 <strlen>
f0111596:	83 c4 10             	add    $0x10,%esp
f0111599:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011159c:	83 ec 08             	sub    $0x8,%esp
f011159f:	68 4c 88 12 f0       	push   $0xf012884c
f01115a4:	ff 75 e8             	pushl  -0x18(%ebp)
f01115a7:	e8 66 e1 00 00       	call   f011f712 <strcmp>
f01115ac:	83 c4 10             	add    $0x10,%esp
f01115af:	85 c0                	test   %eax,%eax
f01115b1:	75 13                	jne    f01115c6 <test_str2lower_function+0x177>
f01115b3:	83 ec 0c             	sub    $0xc,%esp
f01115b6:	ff 75 dc             	pushl  -0x24(%ebp)
f01115b9:	e8 48 e0 00 00       	call   f011f606 <strlen>
f01115be:	83 c4 10             	add    $0x10,%esp
f01115c1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01115c4:	74 15                	je     f01115db <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f01115c6:	83 ec 08             	sub    $0x8,%esp
f01115c9:	ff 75 e8             	pushl  -0x18(%ebp)
f01115cc:	68 58 88 12 f0       	push   $0xf0128858
f01115d1:	e8 b5 f9 fe ff       	call   f0100f8b <cprintf>
f01115d6:	83 c4 10             	add    $0x10,%esp
f01115d9:	eb 04                	jmp    f01115df <test_str2lower_function+0x190>
	else
		eval += 15;
f01115db:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01115df:	c7 45 d8 bb 88 12 f0 	movl   $0xf01288bb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f01115e6:	83 ec 08             	sub    $0x8,%esp
f01115e9:	ff 75 d8             	pushl  -0x28(%ebp)
f01115ec:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01115f2:	50                   	push   %eax
f01115f3:	e8 f7 e6 00 00       	call   f011fcef <str2lower>
f01115f8:	83 c4 10             	add    $0x10,%esp
f01115fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01115fe:	83 ec 0c             	sub    $0xc,%esp
f0111601:	ff 75 e8             	pushl  -0x18(%ebp)
f0111604:	e8 fd df 00 00       	call   f011f606 <strlen>
f0111609:	83 c4 10             	add    $0x10,%esp
f011160c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f011160f:	83 ec 08             	sub    $0x8,%esp
f0111612:	68 bb 88 12 f0       	push   $0xf01288bb
f0111617:	ff 75 e8             	pushl  -0x18(%ebp)
f011161a:	e8 f3 e0 00 00       	call   f011f712 <strcmp>
f011161f:	83 c4 10             	add    $0x10,%esp
f0111622:	85 c0                	test   %eax,%eax
f0111624:	75 13                	jne    f0111639 <test_str2lower_function+0x1ea>
f0111626:	83 ec 0c             	sub    $0xc,%esp
f0111629:	ff 75 d8             	pushl  -0x28(%ebp)
f011162c:	e8 d5 df 00 00       	call   f011f606 <strlen>
f0111631:	83 c4 10             	add    $0x10,%esp
f0111634:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111637:	74 15                	je     f011164e <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111639:	83 ec 08             	sub    $0x8,%esp
f011163c:	ff 75 e8             	pushl  -0x18(%ebp)
f011163f:	68 c8 88 12 f0       	push   $0xf01288c8
f0111644:	e8 42 f9 fe ff       	call   f0100f8b <cprintf>
f0111649:	83 c4 10             	add    $0x10,%esp
f011164c:	eb 04                	jmp    f0111652 <test_str2lower_function+0x203>
	else
		eval += 15;
f011164e:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111652:	c7 45 d4 2a 89 12 f0 	movl   $0xf012892a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111659:	83 ec 08             	sub    $0x8,%esp
f011165c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011165f:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111665:	50                   	push   %eax
f0111666:	e8 84 e6 00 00       	call   f011fcef <str2lower>
f011166b:	83 c4 10             	add    $0x10,%esp
f011166e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111671:	83 ec 0c             	sub    $0xc,%esp
f0111674:	ff 75 e8             	pushl  -0x18(%ebp)
f0111677:	e8 8a df 00 00       	call   f011f606 <strlen>
f011167c:	83 c4 10             	add    $0x10,%esp
f011167f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111682:	83 ec 08             	sub    $0x8,%esp
f0111685:	68 40 89 12 f0       	push   $0xf0128940
f011168a:	ff 75 e8             	pushl  -0x18(%ebp)
f011168d:	e8 80 e0 00 00       	call   f011f712 <strcmp>
f0111692:	83 c4 10             	add    $0x10,%esp
f0111695:	85 c0                	test   %eax,%eax
f0111697:	75 13                	jne    f01116ac <test_str2lower_function+0x25d>
f0111699:	83 ec 0c             	sub    $0xc,%esp
f011169c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011169f:	e8 62 df 00 00       	call   f011f606 <strlen>
f01116a4:	83 c4 10             	add    $0x10,%esp
f01116a7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01116aa:	74 15                	je     f01116c1 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f01116ac:	83 ec 08             	sub    $0x8,%esp
f01116af:	ff 75 e8             	pushl  -0x18(%ebp)
f01116b2:	68 58 89 12 f0       	push   $0xf0128958
f01116b7:	e8 cf f8 fe ff       	call   f0100f8b <cprintf>
f01116bc:	83 c4 10             	add    $0x10,%esp
f01116bf:	eb 04                	jmp    f01116c5 <test_str2lower_function+0x276>
	else
		eval += 15;
f01116c1:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f01116c5:	c7 45 d0 c5 89 12 f0 	movl   $0xf01289c5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f01116cc:	83 ec 08             	sub    $0x8,%esp
f01116cf:	ff 75 d0             	pushl  -0x30(%ebp)
f01116d2:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f01116d8:	50                   	push   %eax
f01116d9:	e8 11 e6 00 00       	call   f011fcef <str2lower>
f01116de:	83 c4 10             	add    $0x10,%esp
f01116e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01116e4:	83 ec 0c             	sub    $0xc,%esp
f01116e7:	ff 75 e8             	pushl  -0x18(%ebp)
f01116ea:	e8 17 df 00 00       	call   f011f606 <strlen>
f01116ef:	83 c4 10             	add    $0x10,%esp
f01116f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f01116f5:	83 ec 08             	sub    $0x8,%esp
f01116f8:	68 d1 89 12 f0       	push   $0xf01289d1
f01116fd:	ff 75 e8             	pushl  -0x18(%ebp)
f0111700:	e8 0d e0 00 00       	call   f011f712 <strcmp>
f0111705:	83 c4 10             	add    $0x10,%esp
f0111708:	85 c0                	test   %eax,%eax
f011170a:	75 13                	jne    f011171f <test_str2lower_function+0x2d0>
f011170c:	83 ec 0c             	sub    $0xc,%esp
f011170f:	ff 75 d0             	pushl  -0x30(%ebp)
f0111712:	e8 ef de 00 00       	call   f011f606 <strlen>
f0111717:	83 c4 10             	add    $0x10,%esp
f011171a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011171d:	74 15                	je     f0111734 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f011171f:	83 ec 08             	sub    $0x8,%esp
f0111722:	ff 75 e8             	pushl  -0x18(%ebp)
f0111725:	68 e0 89 12 f0       	push   $0xf01289e0
f011172a:	e8 5c f8 fe ff       	call   f0100f8b <cprintf>
f011172f:	83 c4 10             	add    $0x10,%esp
f0111732:	eb 04                	jmp    f0111738 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111734:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111738:	c7 45 cc 43 8a 12 f0 	movl   $0xf0128a43,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f011173f:	83 ec 08             	sub    $0x8,%esp
f0111742:	ff 75 cc             	pushl  -0x34(%ebp)
f0111745:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f011174b:	50                   	push   %eax
f011174c:	e8 9e e5 00 00       	call   f011fcef <str2lower>
f0111751:	83 c4 10             	add    $0x10,%esp
f0111754:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111757:	83 ec 0c             	sub    $0xc,%esp
f011175a:	ff 75 e8             	pushl  -0x18(%ebp)
f011175d:	e8 a4 de 00 00       	call   f011f606 <strlen>
f0111762:	83 c4 10             	add    $0x10,%esp
f0111765:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111768:	83 ec 08             	sub    $0x8,%esp
f011176b:	68 5e 8a 12 f0       	push   $0xf0128a5e
f0111770:	ff 75 e8             	pushl  -0x18(%ebp)
f0111773:	e8 9a df 00 00       	call   f011f712 <strcmp>
f0111778:	83 c4 10             	add    $0x10,%esp
f011177b:	85 c0                	test   %eax,%eax
f011177d:	75 13                	jne    f0111792 <test_str2lower_function+0x343>
f011177f:	83 ec 0c             	sub    $0xc,%esp
f0111782:	ff 75 cc             	pushl  -0x34(%ebp)
f0111785:	e8 7c de 00 00       	call   f011f606 <strlen>
f011178a:	83 c4 10             	add    $0x10,%esp
f011178d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111790:	74 15                	je     f01117a7 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111792:	83 ec 08             	sub    $0x8,%esp
f0111795:	ff 75 e8             	pushl  -0x18(%ebp)
f0111798:	68 7c 8a 12 f0       	push   $0xf0128a7c
f011179d:	e8 e9 f7 fe ff       	call   f0100f8b <cprintf>
f01117a2:	83 c4 10             	add    $0x10,%esp
f01117a5:	eb 04                	jmp    f01117ab <test_str2lower_function+0x35c>
	else
		eval += 20;
f01117a7:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f01117ab:	83 ec 08             	sub    $0x8,%esp
f01117ae:	ff 75 f4             	pushl  -0xc(%ebp)
f01117b1:	68 f0 8a 12 f0       	push   $0xf0128af0
f01117b6:	e8 d0 f7 fe ff       	call   f0100f8b <cprintf>
f01117bb:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01117be:	83 ec 0c             	sub    $0xc,%esp
f01117c1:	68 00 86 12 f0       	push   $0xf0128600
f01117c6:	e8 c0 f7 fe ff       	call   f0100f8b <cprintf>
f01117cb:	83 c4 10             	add    $0x10,%esp
	return 0;
f01117ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01117d3:	c9                   	leave  
f01117d4:	c3                   	ret    

f01117d5 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01117d5:	55                   	push   %ebp
f01117d6:	89 e5                	mov    %esp,%ebp
f01117d8:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f01117db:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01117e2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01117e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01117f0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01117f5:	ff 75 ec             	pushl  -0x14(%ebp)
f01117f8:	ff 75 f0             	pushl  -0x10(%ebp)
f01117fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01117fe:	50                   	push   %eax
f01117ff:	e8 df 7d ff ff       	call   f01095e3 <pt_set_page_permissions>
f0111804:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111807:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011180c:	ff 75 ec             	pushl  -0x14(%ebp)
f011180f:	ff 75 f0             	pushl  -0x10(%ebp)
f0111812:	ff 75 f4             	pushl  -0xc(%ebp)
f0111815:	50                   	push   %eax
f0111816:	e8 74 4b 00 00       	call   f011638f <CP>
f011181b:	83 c4 10             	add    $0x10,%esp
f011181e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111821:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111825:	74 17                	je     f011183e <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111827:	83 ec 04             	sub    $0x4,%esp
f011182a:	68 20 8b 12 f0       	push   $0xf0128b20
f011182f:	68 23 01 00 00       	push   $0x123
f0111834:	68 42 8b 12 f0       	push   $0xf0128b42
f0111839:	e8 fb ea fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f011183e:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111845:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f011184c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111853:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111858:	ff 75 ec             	pushl  -0x14(%ebp)
f011185b:	ff 75 f0             	pushl  -0x10(%ebp)
f011185e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111861:	50                   	push   %eax
f0111862:	e8 7c 7d ff ff       	call   f01095e3 <pt_set_page_permissions>
f0111867:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011186a:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011186f:	ff 75 ec             	pushl  -0x14(%ebp)
f0111872:	ff 75 f0             	pushl  -0x10(%ebp)
f0111875:	ff 75 f4             	pushl  -0xc(%ebp)
f0111878:	50                   	push   %eax
f0111879:	e8 11 4b 00 00       	call   f011638f <CP>
f011187e:	83 c4 10             	add    $0x10,%esp
f0111881:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111884:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111888:	74 17                	je     f01118a1 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011188a:	83 ec 04             	sub    $0x4,%esp
f011188d:	68 60 8b 12 f0       	push   $0xf0128b60
f0111892:	68 2f 01 00 00       	push   $0x12f
f0111897:	68 42 8b 12 f0       	push   $0xf0128b42
f011189c:	e8 98 ea fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f01118a1:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f01118a8:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f01118af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01118b6:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01118bb:	ff 75 ec             	pushl  -0x14(%ebp)
f01118be:	ff 75 f0             	pushl  -0x10(%ebp)
f01118c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01118c4:	50                   	push   %eax
f01118c5:	e8 19 7d ff ff       	call   f01095e3 <pt_set_page_permissions>
f01118ca:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01118cd:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01118d2:	ff 75 ec             	pushl  -0x14(%ebp)
f01118d5:	ff 75 f0             	pushl  -0x10(%ebp)
f01118d8:	ff 75 f4             	pushl  -0xc(%ebp)
f01118db:	50                   	push   %eax
f01118dc:	e8 ae 4a 00 00       	call   f011638f <CP>
f01118e1:	83 c4 10             	add    $0x10,%esp
f01118e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01118e7:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01118eb:	74 17                	je     f0111904 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01118ed:	83 ec 04             	sub    $0x4,%esp
f01118f0:	68 84 8b 12 f0       	push   $0xf0128b84
f01118f5:	68 3a 01 00 00       	push   $0x13a
f01118fa:	68 42 8b 12 f0       	push   $0xf0128b42
f01118ff:	e8 35 ea fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111904:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f011190b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111912:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111919:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011191e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111921:	ff 75 f0             	pushl  -0x10(%ebp)
f0111924:	ff 75 f4             	pushl  -0xc(%ebp)
f0111927:	50                   	push   %eax
f0111928:	e8 b6 7c ff ff       	call   f01095e3 <pt_set_page_permissions>
f011192d:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111930:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111935:	ff 75 ec             	pushl  -0x14(%ebp)
f0111938:	ff 75 f0             	pushl  -0x10(%ebp)
f011193b:	ff 75 f4             	pushl  -0xc(%ebp)
f011193e:	50                   	push   %eax
f011193f:	e8 4b 4a 00 00       	call   f011638f <CP>
f0111944:	83 c4 10             	add    $0x10,%esp
f0111947:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011194a:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011194e:	74 17                	je     f0111967 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111950:	83 ec 04             	sub    $0x4,%esp
f0111953:	68 a8 8b 12 f0       	push   $0xf0128ba8
f0111958:	68 46 01 00 00       	push   $0x146
f011195d:	68 42 8b 12 f0       	push   $0xf0128b42
f0111962:	e8 d2 e9 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111967:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f011196e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111975:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011197c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111981:	ff 75 ec             	pushl  -0x14(%ebp)
f0111984:	ff 75 f0             	pushl  -0x10(%ebp)
f0111987:	ff 75 f4             	pushl  -0xc(%ebp)
f011198a:	50                   	push   %eax
f011198b:	e8 53 7c ff ff       	call   f01095e3 <pt_set_page_permissions>
f0111990:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111993:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111998:	ff 75 ec             	pushl  -0x14(%ebp)
f011199b:	ff 75 f0             	pushl  -0x10(%ebp)
f011199e:	ff 75 f4             	pushl  -0xc(%ebp)
f01119a1:	50                   	push   %eax
f01119a2:	e8 e8 49 00 00       	call   f011638f <CP>
f01119a7:	83 c4 10             	add    $0x10,%esp
f01119aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01119ad:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01119b1:	74 17                	je     f01119ca <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f01119b3:	83 ec 04             	sub    $0x4,%esp
f01119b6:	68 cc 8b 12 f0       	push   $0xf0128bcc
f01119bb:	68 52 01 00 00       	push   $0x152
f01119c0:	68 42 8b 12 f0       	push   $0xf0128b42
f01119c5:	e8 6f e9 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01119ca:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01119d1:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01119d8:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01119df:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01119e4:	ff 75 ec             	pushl  -0x14(%ebp)
f01119e7:	ff 75 f0             	pushl  -0x10(%ebp)
f01119ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01119ed:	50                   	push   %eax
f01119ee:	e8 f0 7b ff ff       	call   f01095e3 <pt_set_page_permissions>
f01119f3:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01119f6:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01119fb:	ff 75 ec             	pushl  -0x14(%ebp)
f01119fe:	ff 75 f0             	pushl  -0x10(%ebp)
f0111a01:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a04:	50                   	push   %eax
f0111a05:	e8 85 49 00 00       	call   f011638f <CP>
f0111a0a:	83 c4 10             	add    $0x10,%esp
f0111a0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111a10:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111a14:	74 17                	je     f0111a2d <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0111a16:	83 ec 04             	sub    $0x4,%esp
f0111a19:	68 f0 8b 12 f0       	push   $0xf0128bf0
f0111a1e:	68 5e 01 00 00       	push   $0x15e
f0111a23:	68 42 8b 12 f0       	push   $0xf0128b42
f0111a28:	e8 0c e9 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0111a2d:	83 ec 0c             	sub    $0xc,%esp
f0111a30:	68 1c 8c 12 f0       	push   $0xf0128c1c
f0111a35:	e8 51 f5 fe ff       	call   f0100f8b <cprintf>
f0111a3a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111a3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111a42:	c9                   	leave  
f0111a43:	c3                   	ret    

f0111a44 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0111a44:	55                   	push   %ebp
f0111a45:	89 e5                	mov    %esp,%ebp
f0111a47:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0111a4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111a51:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111a58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111a5f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111a64:	ff 75 ec             	pushl  -0x14(%ebp)
f0111a67:	ff 75 f0             	pushl  -0x10(%ebp)
f0111a6a:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a6d:	50                   	push   %eax
f0111a6e:	e8 70 7b ff ff       	call   f01095e3 <pt_set_page_permissions>
f0111a73:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0111a76:	83 ec 04             	sub    $0x4,%esp
f0111a79:	68 6c 8c 12 f0       	push   $0xf0128c6c
f0111a7e:	68 6b 01 00 00       	push   $0x16b
f0111a83:	68 42 8b 12 f0       	push   $0xf0128b42
f0111a88:	e8 ac e8 fe ff       	call   f0100339 <_panic>

f0111a8d <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111a8d:	55                   	push   %ebp
f0111a8e:	89 e5                	mov    %esp,%ebp
f0111a90:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111a93:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0111a9a:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111a9f:	83 ec 08             	sub    $0x8,%esp
f0111aa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0111aa5:	50                   	push   %eax
f0111aa6:	e8 fc 7b ff ff       	call   f01096a7 <pt_get_page_permissions>
f0111aab:	83 c4 10             	add    $0x10,%esp
f0111aae:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111ab1:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0111ab5:	74 17                	je     f0111ace <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0111ab7:	83 ec 04             	sub    $0x4,%esp
f0111aba:	68 08 8d 12 f0       	push   $0xf0128d08
f0111abf:	68 79 01 00 00       	push   $0x179
f0111ac4:	68 42 8b 12 f0       	push   $0xf0128b42
f0111ac9:	e8 6b e8 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111ace:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111ad5:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111ada:	83 ec 08             	sub    $0x8,%esp
f0111add:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ae0:	50                   	push   %eax
f0111ae1:	e8 c1 7b ff ff       	call   f01096a7 <pt_get_page_permissions>
f0111ae6:	83 c4 10             	add    $0x10,%esp
f0111ae9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111aec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111af0:	74 17                	je     f0111b09 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111af2:	83 ec 04             	sub    $0x4,%esp
f0111af5:	68 2c 8d 12 f0       	push   $0xf0128d2c
f0111afa:	68 81 01 00 00       	push   $0x181
f0111aff:	68 42 8b 12 f0       	push   $0xf0128b42
f0111b04:	e8 30 e8 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0111b09:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111b10:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111b15:	83 ec 08             	sub    $0x8,%esp
f0111b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b1b:	50                   	push   %eax
f0111b1c:	e8 86 7b ff ff       	call   f01096a7 <pt_get_page_permissions>
f0111b21:	83 c4 10             	add    $0x10,%esp
f0111b24:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111b27:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111b2b:	74 17                	je     f0111b44 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111b2d:	83 ec 04             	sub    $0x4,%esp
f0111b30:	68 50 8d 12 f0       	push   $0xf0128d50
f0111b35:	68 89 01 00 00       	push   $0x189
f0111b3a:	68 42 8b 12 f0       	push   $0xf0128b42
f0111b3f:	e8 f5 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0111b44:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111b4b:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111b50:	83 ec 08             	sub    $0x8,%esp
f0111b53:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b56:	50                   	push   %eax
f0111b57:	e8 4b 7b ff ff       	call   f01096a7 <pt_get_page_permissions>
f0111b5c:	83 c4 10             	add    $0x10,%esp
f0111b5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111b62:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111b66:	74 17                	je     f0111b7f <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0111b68:	83 ec 04             	sub    $0x4,%esp
f0111b6b:	68 74 8d 12 f0       	push   $0xf0128d74
f0111b70:	68 90 01 00 00       	push   $0x190
f0111b75:	68 42 8b 12 f0       	push   $0xf0128b42
f0111b7a:	e8 ba e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111b7f:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111b86:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111b8b:	83 ec 08             	sub    $0x8,%esp
f0111b8e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b91:	50                   	push   %eax
f0111b92:	e8 10 7b ff ff       	call   f01096a7 <pt_get_page_permissions>
f0111b97:	83 c4 10             	add    $0x10,%esp
f0111b9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111b9d:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111ba1:	74 17                	je     f0111bba <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111ba3:	83 ec 04             	sub    $0x4,%esp
f0111ba6:	68 98 8d 12 f0       	push   $0xf0128d98
f0111bab:	68 97 01 00 00       	push   $0x197
f0111bb0:	68 42 8b 12 f0       	push   $0xf0128b42
f0111bb5:	e8 7f e7 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111bba:	83 ec 0c             	sub    $0xc,%esp
f0111bbd:	68 bc 8d 12 f0       	push   $0xf0128dbc
f0111bc2:	e8 c4 f3 fe ff       	call   f0100f8b <cprintf>
f0111bc7:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111bca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111bcf:	c9                   	leave  
f0111bd0:	c3                   	ret    

f0111bd1 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111bd1:	55                   	push   %ebp
f0111bd2:	89 e5                	mov    %esp,%ebp
f0111bd4:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0111bd7:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111bde:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111be3:	83 ec 08             	sub    $0x8,%esp
f0111be6:	ff 75 f4             	pushl  -0xc(%ebp)
f0111be9:	50                   	push   %eax
f0111bea:	e8 01 7b ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f0111bef:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111bf2:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111bf7:	83 ec 08             	sub    $0x8,%esp
f0111bfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bfd:	50                   	push   %eax
f0111bfe:	e8 e8 46 00 00       	call   f01162eb <CE>
f0111c03:	83 c4 10             	add    $0x10,%esp
f0111c06:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111c09:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111c0d:	74 17                	je     f0111c26 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111c0f:	83 ec 04             	sub    $0x4,%esp
f0111c12:	68 04 8e 12 f0       	push   $0xf0128e04
f0111c17:	68 a7 01 00 00       	push   $0x1a7
f0111c1c:	68 42 8b 12 f0       	push   $0xf0128b42
f0111c21:	e8 13 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111c26:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111c2d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c32:	83 ec 08             	sub    $0x8,%esp
f0111c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c38:	50                   	push   %eax
f0111c39:	e8 b2 7a ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f0111c3e:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111c41:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c46:	83 ec 08             	sub    $0x8,%esp
f0111c49:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c4c:	50                   	push   %eax
f0111c4d:	e8 99 46 00 00       	call   f01162eb <CE>
f0111c52:	83 c4 10             	add    $0x10,%esp
f0111c55:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111c58:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111c5c:	74 17                	je     f0111c75 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0111c5e:	83 ec 04             	sub    $0x4,%esp
f0111c61:	68 30 8e 12 f0       	push   $0xf0128e30
f0111c66:	68 af 01 00 00       	push   $0x1af
f0111c6b:	68 42 8b 12 f0       	push   $0xf0128b42
f0111c70:	e8 c4 e6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111c75:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111c7c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c81:	83 ec 08             	sub    $0x8,%esp
f0111c84:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c87:	50                   	push   %eax
f0111c88:	e8 63 7a ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f0111c8d:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111c90:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c95:	83 ec 08             	sub    $0x8,%esp
f0111c98:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c9b:	50                   	push   %eax
f0111c9c:	e8 4a 46 00 00       	call   f01162eb <CE>
f0111ca1:	83 c4 10             	add    $0x10,%esp
f0111ca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111ca7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111cab:	74 17                	je     f0111cc4 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0111cad:	83 ec 04             	sub    $0x4,%esp
f0111cb0:	68 5c 8e 12 f0       	push   $0xf0128e5c
f0111cb5:	68 b7 01 00 00       	push   $0x1b7
f0111cba:	68 42 8b 12 f0       	push   $0xf0128b42
f0111cbf:	e8 75 e6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0111cc4:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111ccb:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111cd0:	83 ec 08             	sub    $0x8,%esp
f0111cd3:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cd6:	50                   	push   %eax
f0111cd7:	e8 14 7a ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f0111cdc:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111cdf:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111ce4:	83 ec 08             	sub    $0x8,%esp
f0111ce7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cea:	50                   	push   %eax
f0111ceb:	e8 fb 45 00 00       	call   f01162eb <CE>
f0111cf0:	83 c4 10             	add    $0x10,%esp
f0111cf3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111cf6:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111cfa:	74 17                	je     f0111d13 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0111cfc:	83 ec 04             	sub    $0x4,%esp
f0111cff:	68 88 8e 12 f0       	push   $0xf0128e88
f0111d04:	68 bf 01 00 00       	push   $0x1bf
f0111d09:	68 42 8b 12 f0       	push   $0xf0128b42
f0111d0e:	e8 26 e6 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0111d13:	83 ec 0c             	sub    $0xc,%esp
f0111d16:	68 b4 8e 12 f0       	push   $0xf0128eb4
f0111d1b:	e8 6b f2 fe ff       	call   f0100f8b <cprintf>
f0111d20:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111d23:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111d28:	c9                   	leave  
f0111d29:	c3                   	ret    

f0111d2a <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0111d2a:	55                   	push   %ebp
f0111d2b:	89 e5                	mov    %esp,%ebp
f0111d2d:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0111d30:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111d37:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111d3c:	83 ec 08             	sub    $0x8,%esp
f0111d3f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d42:	50                   	push   %eax
f0111d43:	e8 a8 79 ff ff       	call   f01096f0 <pt_clear_page_table_entry>
f0111d48:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0111d4b:	83 ec 04             	sub    $0x4,%esp
f0111d4e:	68 00 8f 12 f0       	push   $0xf0128f00
f0111d53:	68 ca 01 00 00       	push   $0x1ca
f0111d58:	68 42 8b 12 f0       	push   $0xf0128b42
f0111d5d:	e8 d7 e5 fe ff       	call   f0100339 <_panic>

f0111d62 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0111d62:	55                   	push   %ebp
f0111d63:	89 e5                	mov    %esp,%ebp
f0111d65:	57                   	push   %edi
f0111d66:	56                   	push   %esi
f0111d67:	53                   	push   %ebx
f0111d68:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0111d6e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111d74:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f0111d79:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d7e:	89 c7                	mov    %eax,%edi
f0111d80:	89 de                	mov    %ebx,%esi
f0111d82:	89 d1                	mov    %edx,%ecx
f0111d84:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d86:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0111d8c:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111d91:	b0 00                	mov    $0x0,%al
f0111d93:	89 d7                	mov    %edx,%edi
f0111d95:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0111d97:	6a 00                	push   $0x0
f0111d99:	6a 0a                	push   $0xa
f0111d9b:	6a 14                	push   $0x14
f0111d9d:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111da3:	50                   	push   %eax
f0111da4:	e8 7c 8b ff ff       	call   f010a925 <env_create>
f0111da9:	83 c4 10             	add    $0x10,%esp
f0111dac:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111daf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111db2:	8b 40 64             	mov    0x64(%eax),%eax
f0111db5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111db8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111dbb:	8b 40 68             	mov    0x68(%eax),%eax
f0111dbe:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0111dc1:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111dc4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111dc7:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0111dce:	75 70 20 
f0111dd1:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0111dd8:	00 00 00 
f0111ddb:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0111de1:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111de6:	b8 00 00 00 00       	mov    $0x0,%eax
f0111deb:	89 d7                	mov    %edx,%edi
f0111ded:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111def:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111df2:	8b 40 10             	mov    0x10(%eax),%eax
f0111df5:	83 ec 08             	sub    $0x8,%esp
f0111df8:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111dfe:	52                   	push   %edx
f0111dff:	50                   	push   %eax
f0111e00:	e8 a7 dc 00 00       	call   f011faac <ltostr>
f0111e05:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111e08:	83 ec 04             	sub    $0x4,%esp
f0111e0b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e11:	50                   	push   %eax
f0111e12:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0111e18:	50                   	push   %eax
f0111e19:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0111e1f:	50                   	push   %eax
f0111e20:	e8 60 dd 00 00       	call   f011fb85 <strcconcat>
f0111e25:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0111e28:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0111e2f:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0111e36:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0111e3d:	83 ec 0c             	sub    $0xc,%esp
f0111e40:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e43:	e8 85 45 00 00       	call   f01163cd <ClearUserSpace>
f0111e48:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0111e4b:	83 ec 04             	sub    $0x4,%esp
f0111e4e:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111e54:	50                   	push   %eax
f0111e55:	68 96 8f 12 f0       	push   $0xf0128f96
f0111e5a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e60:	50                   	push   %eax
f0111e61:	e8 1f dd 00 00       	call   f011fb85 <strcconcat>
f0111e66:	83 c4 10             	add    $0x10,%esp
f0111e69:	83 ec 0c             	sub    $0xc,%esp
f0111e6c:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111e72:	50                   	push   %eax
f0111e73:	e8 83 00 ff ff       	call   f0101efb <execute_command>
f0111e78:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0111e7b:	83 ec 04             	sub    $0x4,%esp
f0111e7e:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111e84:	50                   	push   %eax
f0111e85:	68 a1 8f 12 f0       	push   $0xf0128fa1
f0111e8a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e90:	50                   	push   %eax
f0111e91:	e8 ef dc 00 00       	call   f011fb85 <strcconcat>
f0111e96:	83 c4 10             	add    $0x10,%esp
f0111e99:	83 ec 0c             	sub    $0xc,%esp
f0111e9c:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111ea2:	50                   	push   %eax
f0111ea3:	e8 53 00 ff ff       	call   f0101efb <execute_command>
f0111ea8:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0111eab:	83 ec 04             	sub    $0x4,%esp
f0111eae:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111eb4:	50                   	push   %eax
f0111eb5:	68 ac 8f 12 f0       	push   $0xf0128fac
f0111eba:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111ec0:	50                   	push   %eax
f0111ec1:	e8 bf dc 00 00       	call   f011fb85 <strcconcat>
f0111ec6:	83 c4 10             	add    $0x10,%esp
f0111ec9:	83 ec 0c             	sub    $0xc,%esp
f0111ecc:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111ed2:	50                   	push   %eax
f0111ed3:	e8 23 00 ff ff       	call   f0101efb <execute_command>
f0111ed8:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0111edb:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0111ee2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ee5:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0111ee8:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0111eef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ef2:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0111ef5:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111efc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111eff:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0111f02:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111f05:	83 ec 08             	sub    $0x8,%esp
f0111f08:	50                   	push   %eax
f0111f09:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f0c:	e8 9d 44 00 00       	call   f01163ae <GP>
f0111f11:	83 c4 10             	add    $0x10,%esp
f0111f14:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0111f17:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0111f1e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0111f25:	e8 9c c3 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0111f2a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0111f2d:	83 ec 0c             	sub    $0xc,%esp
f0111f30:	68 b8 8f 12 f0       	push   $0xf0128fb8
f0111f35:	e8 51 f0 fe ff       	call   f0100f8b <cprintf>
f0111f3a:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0111f3d:	6a 03                	push   $0x3
f0111f3f:	68 00 00 90 02       	push   $0x2900000
f0111f44:	68 00 00 80 02       	push   $0x2800000
f0111f49:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f4c:	e8 13 85 ff ff       	call   f010a464 <cut_paste_pages>
f0111f51:	83 c4 10             	add    $0x10,%esp
f0111f54:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0111f57:	e8 6a c3 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0111f5c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0111f5f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0111f66:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0111f6a:	75 08                	jne    f0111f74 <test_cut_paste_pages+0x212>
f0111f6c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f6f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111f72:	74 2b                	je     f0111f9f <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111f74:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f77:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111f7a:	83 ec 0c             	sub    $0xc,%esp
f0111f7d:	50                   	push   %eax
f0111f7e:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111f81:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0111f86:	68 04 02 00 00       	push   $0x204
f0111f8b:	68 42 8b 12 f0       	push   $0xf0128b42
f0111f90:	e8 41 e5 fe ff       	call   f01004d6 <_warn>
f0111f95:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111f98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0111f9f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111fa3:	74 04                	je     f0111fa9 <test_cut_paste_pages+0x247>
f0111fa5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111fa9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0111fb0:	83 ec 08             	sub    $0x8,%esp
f0111fb3:	6a 00                	push   $0x0
f0111fb5:	6a 01                	push   $0x1
f0111fb7:	6a 00                	push   $0x0
f0111fb9:	68 ff 0f 00 00       	push   $0xfff
f0111fbe:	ff 75 bc             	pushl  -0x44(%ebp)
f0111fc1:	6a 01                	push   $0x1
f0111fc3:	68 00 30 00 00       	push   $0x3000
f0111fc8:	68 00 00 90 02       	push   $0x2900000
f0111fcd:	68 00 00 80 02       	push   $0x2800000
f0111fd2:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111fd5:	e8 27 44 00 00       	call   f0116401 <CCP>
f0111fda:	83 c4 30             	add    $0x30,%esp
f0111fdd:	83 f8 01             	cmp    $0x1,%eax
f0111fe0:	74 21                	je     f0112003 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111fe2:	83 ec 04             	sub    $0x4,%esp
f0111fe5:	68 3c 90 12 f0       	push   $0xf012903c
f0111fea:	68 0c 02 00 00       	push   $0x20c
f0111fef:	68 42 8b 12 f0       	push   $0xf0128b42
f0111ff4:	e8 dd e4 fe ff       	call   f01004d6 <_warn>
f0111ff9:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111ffc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112003:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112007:	74 04                	je     f011200d <test_cut_paste_pages+0x2ab>
f0112009:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f011200d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112014:	83 ec 04             	sub    $0x4,%esp
f0112017:	6a 00                	push   $0x0
f0112019:	68 00 00 90 02       	push   $0x2900000
f011201e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112021:	e8 b7 41 00 00       	call   f01161dd <CB>
f0112026:	83 c4 10             	add    $0x10,%esp
f0112029:	85 c0                	test   %eax,%eax
f011202b:	0f 84 f6 00 00 00    	je     f0112127 <test_cut_paste_pages+0x3c5>
f0112031:	83 ec 04             	sub    $0x4,%esp
f0112034:	6a 00                	push   $0x0
f0112036:	68 00 10 90 02       	push   $0x2901000
f011203b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011203e:	e8 9a 41 00 00       	call   f01161dd <CB>
f0112043:	83 c4 10             	add    $0x10,%esp
f0112046:	85 c0                	test   %eax,%eax
f0112048:	0f 84 d9 00 00 00    	je     f0112127 <test_cut_paste_pages+0x3c5>
f011204e:	83 ec 04             	sub    $0x4,%esp
f0112051:	6a 00                	push   $0x0
f0112053:	68 00 20 90 02       	push   $0x2902000
f0112058:	ff 75 d4             	pushl  -0x2c(%ebp)
f011205b:	e8 7d 41 00 00       	call   f01161dd <CB>
f0112060:	83 c4 10             	add    $0x10,%esp
f0112063:	85 c0                	test   %eax,%eax
f0112065:	0f 84 bc 00 00 00    	je     f0112127 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011206b:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112072:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112079:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112080:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112083:	8a 00                	mov    (%eax),%al
f0112085:	3c 61                	cmp    $0x61,%al
f0112087:	75 12                	jne    f011209b <test_cut_paste_pages+0x339>
f0112089:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011208c:	8a 00                	mov    (%eax),%al
f011208e:	3c 62                	cmp    $0x62,%al
f0112090:	75 09                	jne    f011209b <test_cut_paste_pages+0x339>
f0112092:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112095:	8a 00                	mov    (%eax),%al
f0112097:	3c 63                	cmp    $0x63,%al
f0112099:	74 21                	je     f01120bc <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011209b:	83 ec 04             	sub    $0x4,%esp
f011209e:	68 88 90 12 f0       	push   $0xf0129088
f01120a3:	68 19 02 00 00       	push   $0x219
f01120a8:	68 42 8b 12 f0       	push   $0xf0128b42
f01120ad:	e8 24 e4 fe ff       	call   f01004d6 <_warn>
f01120b2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01120b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01120bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01120c0:	74 04                	je     f01120c6 <test_cut_paste_pages+0x364>
f01120c2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01120c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01120cd:	83 ec 04             	sub    $0x4,%esp
f01120d0:	6a 01                	push   $0x1
f01120d2:	68 00 10 90 02       	push   $0x2901000
f01120d7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01120da:	e8 fe 40 00 00       	call   f01161dd <CB>
f01120df:	83 c4 10             	add    $0x10,%esp
f01120e2:	85 c0                	test   %eax,%eax
f01120e4:	74 41                	je     f0112127 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01120e6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120e9:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01120ec:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120ef:	8a 00                	mov    (%eax),%al
f01120f1:	3c 79                	cmp    $0x79,%al
f01120f3:	74 21                	je     f0112116 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01120f5:	83 ec 04             	sub    $0x4,%esp
f01120f8:	68 88 90 12 f0       	push   $0xf0129088
f01120fd:	68 24 02 00 00       	push   $0x224
f0112102:	68 42 8b 12 f0       	push   $0xf0128b42
f0112107:	e8 ca e3 fe ff       	call   f01004d6 <_warn>
f011210c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011210f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112116:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011211a:	74 04                	je     f0112120 <test_cut_paste_pages+0x3be>
f011211c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112120:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112127:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011212a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f011212d:	6a 02                	push   $0x2
f011212f:	68 00 f0 bf 02       	push   $0x2bff000
f0112134:	68 00 10 90 02       	push   $0x2901000
f0112139:	ff 75 d4             	pushl  -0x2c(%ebp)
f011213c:	e8 23 83 ff ff       	call   f010a464 <cut_paste_pages>
f0112141:	83 c4 10             	add    $0x10,%esp
f0112144:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112147:	e8 7a c1 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011214c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f011214f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112153:	75 0b                	jne    f0112160 <test_cut_paste_pages+0x3fe>
f0112155:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112158:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011215b:	83 f8 01             	cmp    $0x1,%eax
f011215e:	74 2b                	je     f011218b <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112160:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112163:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112166:	83 ec 0c             	sub    $0xc,%esp
f0112169:	50                   	push   %eax
f011216a:	ff 75 b4             	pushl  -0x4c(%ebp)
f011216d:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0112172:	68 35 02 00 00       	push   $0x235
f0112177:	68 42 8b 12 f0       	push   $0xf0128b42
f011217c:	e8 55 e3 fe ff       	call   f01004d6 <_warn>
f0112181:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112184:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011218b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011218f:	74 04                	je     f0112195 <test_cut_paste_pages+0x433>
f0112191:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112195:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011219c:	83 ec 08             	sub    $0x8,%esp
f011219f:	6a 00                	push   $0x0
f01121a1:	6a 01                	push   $0x1
f01121a3:	6a 00                	push   $0x0
f01121a5:	68 ff 0f 00 00       	push   $0xfff
f01121aa:	ff 75 bc             	pushl  -0x44(%ebp)
f01121ad:	6a 01                	push   $0x1
f01121af:	68 00 20 00 00       	push   $0x2000
f01121b4:	68 00 f0 bf 02       	push   $0x2bff000
f01121b9:	68 00 10 90 02       	push   $0x2901000
f01121be:	ff 75 d4             	pushl  -0x2c(%ebp)
f01121c1:	e8 3b 42 00 00       	call   f0116401 <CCP>
f01121c6:	83 c4 30             	add    $0x30,%esp
f01121c9:	83 f8 01             	cmp    $0x1,%eax
f01121cc:	74 21                	je     f01121ef <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01121ce:	83 ec 04             	sub    $0x4,%esp
f01121d1:	68 3c 90 12 f0       	push   $0xf012903c
f01121d6:	68 3d 02 00 00       	push   $0x23d
f01121db:	68 42 8b 12 f0       	push   $0xf0128b42
f01121e0:	e8 f1 e2 fe ff       	call   f01004d6 <_warn>
f01121e5:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01121e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01121ef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01121f3:	74 04                	je     f01121f9 <test_cut_paste_pages+0x497>
f01121f5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01121f9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112200:	83 ec 04             	sub    $0x4,%esp
f0112203:	6a 00                	push   $0x0
f0112205:	68 ff f7 bf 02       	push   $0x2bff7ff
f011220a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011220d:	e8 cb 3f 00 00       	call   f01161dd <CB>
f0112212:	83 c4 10             	add    $0x10,%esp
f0112215:	85 c0                	test   %eax,%eax
f0112217:	74 6b                	je     f0112284 <test_cut_paste_pages+0x522>
f0112219:	83 ec 04             	sub    $0x4,%esp
f011221c:	6a 00                	push   $0x0
f011221e:	68 ff 0f c0 02       	push   $0x2c00fff
f0112223:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112226:	e8 b2 3f 00 00       	call   f01161dd <CB>
f011222b:	83 c4 10             	add    $0x10,%esp
f011222e:	85 c0                	test   %eax,%eax
f0112230:	74 52                	je     f0112284 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112232:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112239:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112240:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112243:	8a 00                	mov    (%eax),%al
f0112245:	3c 79                	cmp    $0x79,%al
f0112247:	75 09                	jne    f0112252 <test_cut_paste_pages+0x4f0>
f0112249:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011224c:	8a 00                	mov    (%eax),%al
f011224e:	3c 63                	cmp    $0x63,%al
f0112250:	74 21                	je     f0112273 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112252:	83 ec 04             	sub    $0x4,%esp
f0112255:	68 88 90 12 f0       	push   $0xf0129088
f011225a:	68 49 02 00 00       	push   $0x249
f011225f:	68 42 8b 12 f0       	push   $0xf0128b42
f0112264:	e8 6d e2 fe ff       	call   f01004d6 <_warn>
f0112269:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011226c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112273:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112277:	74 04                	je     f011227d <test_cut_paste_pages+0x51b>
f0112279:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011227d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112284:	83 ec 0c             	sub    $0xc,%esp
f0112287:	68 c1 90 12 f0       	push   $0xf01290c1
f011228c:	e8 fa ec fe ff       	call   f0100f8b <cprintf>
f0112291:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112294:	83 ec 0c             	sub    $0xc,%esp
f0112297:	68 d0 90 12 f0       	push   $0xf01290d0
f011229c:	e8 ea ec fe ff       	call   f0100f8b <cprintf>
f01122a1:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01122a4:	83 ec 04             	sub    $0x4,%esp
f01122a7:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01122ad:	50                   	push   %eax
f01122ae:	68 f9 90 12 f0       	push   $0xf01290f9
f01122b3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122b9:	50                   	push   %eax
f01122ba:	e8 c6 d8 00 00       	call   f011fb85 <strcconcat>
f01122bf:	83 c4 10             	add    $0x10,%esp
f01122c2:	83 ec 0c             	sub    $0xc,%esp
f01122c5:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01122cb:	50                   	push   %eax
f01122cc:	e8 2a fc fe ff       	call   f0101efb <execute_command>
f01122d1:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01122d4:	83 ec 04             	sub    $0x4,%esp
f01122d7:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01122dd:	50                   	push   %eax
f01122de:	68 04 91 12 f0       	push   $0xf0129104
f01122e3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122e9:	50                   	push   %eax
f01122ea:	e8 96 d8 00 00       	call   f011fb85 <strcconcat>
f01122ef:	83 c4 10             	add    $0x10,%esp
f01122f2:	83 ec 0c             	sub    $0xc,%esp
f01122f5:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01122fb:	50                   	push   %eax
f01122fc:	e8 fa fb fe ff       	call   f0101efb <execute_command>
f0112301:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112304:	83 ec 04             	sub    $0x4,%esp
f0112307:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011230d:	50                   	push   %eax
f011230e:	68 0f 91 12 f0       	push   $0xf012910f
f0112313:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112319:	50                   	push   %eax
f011231a:	e8 66 d8 00 00       	call   f011fb85 <strcconcat>
f011231f:	83 c4 10             	add    $0x10,%esp
f0112322:	83 ec 0c             	sub    $0xc,%esp
f0112325:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011232b:	50                   	push   %eax
f011232c:	e8 ca fb fe ff       	call   f0101efb <execute_command>
f0112331:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112334:	83 ec 04             	sub    $0x4,%esp
f0112337:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011233d:	50                   	push   %eax
f011233e:	68 1a 91 12 f0       	push   $0xf012911a
f0112343:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112349:	50                   	push   %eax
f011234a:	e8 36 d8 00 00       	call   f011fb85 <strcconcat>
f011234f:	83 c4 10             	add    $0x10,%esp
f0112352:	83 ec 0c             	sub    $0xc,%esp
f0112355:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011235b:	50                   	push   %eax
f011235c:	e8 9a fb fe ff       	call   f0101efb <execute_command>
f0112361:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112364:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011236b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011236e:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112371:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112378:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011237b:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011237e:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112385:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112388:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011238b:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112392:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112395:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112398:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f011239f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01123a2:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01123a5:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01123ac:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01123af:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01123b2:	83 ec 08             	sub    $0x8,%esp
f01123b5:	68 00 00 c0 01       	push   $0x1c00000
f01123ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123bd:	e8 ec 3f 00 00       	call   f01163ae <GP>
f01123c2:	83 c4 10             	add    $0x10,%esp
f01123c5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f01123c8:	83 ec 08             	sub    $0x8,%esp
f01123cb:	68 00 00 40 01       	push   $0x1400000
f01123d0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123d3:	e8 d6 3f 00 00       	call   f01163ae <GP>
f01123d8:	83 c4 10             	add    $0x10,%esp
f01123db:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01123de:	e8 e3 be ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01123e3:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01123e6:	6a 01                	push   $0x1
f01123e8:	68 00 00 40 01       	push   $0x1400000
f01123ed:	68 00 00 c0 01       	push   $0x1c00000
f01123f2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123f5:	e8 6a 80 ff ff       	call   f010a464 <cut_paste_pages>
f01123fa:	83 c4 10             	add    $0x10,%esp
f01123fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112400:	e8 c1 be ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0112405:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112408:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f011240c:	75 08                	jne    f0112416 <test_cut_paste_pages+0x6b4>
f011240e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112411:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112414:	74 2b                	je     f0112441 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112416:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112419:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011241c:	83 ec 0c             	sub    $0xc,%esp
f011241f:	50                   	push   %eax
f0112420:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112423:	68 28 91 12 f0       	push   $0xf0129128
f0112428:	68 6c 02 00 00       	push   $0x26c
f011242d:	68 42 8b 12 f0       	push   $0xf0128b42
f0112432:	e8 9f e0 fe ff       	call   f01004d6 <_warn>
f0112437:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011243a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112441:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112445:	74 04                	je     f011244b <test_cut_paste_pages+0x6e9>
f0112447:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011244b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112452:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112459:	83 ec 08             	sub    $0x8,%esp
f011245c:	6a 00                	push   $0x0
f011245e:	68 ff 0f 00 00       	push   $0xfff
f0112463:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112466:	68 ff 0f 00 00       	push   $0xfff
f011246b:	ff 75 a0             	pushl  -0x60(%ebp)
f011246e:	6a 01                	push   $0x1
f0112470:	68 00 10 00 00       	push   $0x1000
f0112475:	68 00 00 40 01       	push   $0x1400000
f011247a:	68 00 00 c0 01       	push   $0x1c00000
f011247f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112482:	e8 7a 3f 00 00       	call   f0116401 <CCP>
f0112487:	83 c4 30             	add    $0x30,%esp
f011248a:	83 f8 01             	cmp    $0x1,%eax
f011248d:	74 28                	je     f01124b7 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011248f:	83 ec 04             	sub    $0x4,%esp
f0112492:	68 3c 90 12 f0       	push   $0xf012903c
f0112497:	68 75 02 00 00       	push   $0x275
f011249c:	68 42 8b 12 f0       	push   $0xf0128b42
f01124a1:	e8 30 e0 fe ff       	call   f01004d6 <_warn>
f01124a6:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01124a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01124b0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01124b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01124bb:	74 04                	je     f01124c1 <test_cut_paste_pages+0x75f>
f01124bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01124c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01124c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01124cc:	0f 84 92 00 00 00    	je     f0112564 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01124d2:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01124d9:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01124e0:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01124e7:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01124ee:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01124f5:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01124fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124ff:	8a 00                	mov    (%eax),%al
f0112501:	3c 61                	cmp    $0x61,%al
f0112503:	75 2d                	jne    f0112532 <test_cut_paste_pages+0x7d0>
f0112505:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112508:	8a 00                	mov    (%eax),%al
f011250a:	3c 78                	cmp    $0x78,%al
f011250c:	75 24                	jne    f0112532 <test_cut_paste_pages+0x7d0>
f011250e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112511:	8a 00                	mov    (%eax),%al
f0112513:	3c 62                	cmp    $0x62,%al
f0112515:	75 1b                	jne    f0112532 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112517:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011251a:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011251c:	3c 79                	cmp    $0x79,%al
f011251e:	75 12                	jne    f0112532 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112520:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112523:	8a 00                	mov    (%eax),%al
f0112525:	3c 63                	cmp    $0x63,%al
f0112527:	75 09                	jne    f0112532 <test_cut_paste_pages+0x7d0>
f0112529:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011252c:	8a 00                	mov    (%eax),%al
f011252e:	3c 7a                	cmp    $0x7a,%al
f0112530:	74 21                	je     f0112553 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112532:	83 ec 04             	sub    $0x4,%esp
f0112535:	68 88 90 12 f0       	push   $0xf0129088
f011253a:	68 87 02 00 00       	push   $0x287
f011253f:	68 42 8b 12 f0       	push   $0xf0128b42
f0112544:	e8 8d df fe ff       	call   f01004d6 <_warn>
f0112549:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011254c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112553:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112557:	74 04                	je     f011255d <test_cut_paste_pages+0x7fb>
f0112559:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011255d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112564:	e8 5d bd ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0112569:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011256c:	6a 03                	push   $0x3
f011256e:	68 00 f0 bf 01       	push   $0x1bff000
f0112573:	68 00 00 40 01       	push   $0x1400000
f0112578:	ff 75 d4             	pushl  -0x2c(%ebp)
f011257b:	e8 e4 7e ff ff       	call   f010a464 <cut_paste_pages>
f0112580:	83 c4 10             	add    $0x10,%esp
f0112583:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112586:	e8 3b bd ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011258b:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011258e:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112592:	75 08                	jne    f011259c <test_cut_paste_pages+0x83a>
f0112594:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112597:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011259a:	74 2b                	je     f01125c7 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011259c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011259f:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01125a2:	83 ec 0c             	sub    $0xc,%esp
f01125a5:	50                   	push   %eax
f01125a6:	ff 75 b4             	pushl  -0x4c(%ebp)
f01125a9:	68 28 91 12 f0       	push   $0xf0129128
f01125ae:	68 96 02 00 00       	push   $0x296
f01125b3:	68 42 8b 12 f0       	push   $0xf0128b42
f01125b8:	e8 19 df fe ff       	call   f01004d6 <_warn>
f01125bd:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01125c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01125c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125cb:	74 04                	je     f01125d1 <test_cut_paste_pages+0x86f>
f01125cd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01125d1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01125d8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01125df:	83 ec 04             	sub    $0x4,%esp
f01125e2:	6a 00                	push   $0x0
f01125e4:	68 00 00 40 01       	push   $0x1400000
f01125e9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125ec:	e8 ec 3b 00 00       	call   f01161dd <CB>
f01125f1:	83 c4 10             	add    $0x10,%esp
f01125f4:	83 f8 01             	cmp    $0x1,%eax
f01125f7:	0f 85 80 00 00 00    	jne    f011267d <test_cut_paste_pages+0x91b>
f01125fd:	83 ec 04             	sub    $0x4,%esp
f0112600:	6a 00                	push   $0x0
f0112602:	68 00 10 40 01       	push   $0x1401000
f0112607:	ff 75 d4             	pushl  -0x2c(%ebp)
f011260a:	e8 ce 3b 00 00       	call   f01161dd <CB>
f011260f:	83 c4 10             	add    $0x10,%esp
f0112612:	83 f8 01             	cmp    $0x1,%eax
f0112615:	75 66                	jne    f011267d <test_cut_paste_pages+0x91b>
f0112617:	83 ec 04             	sub    $0x4,%esp
f011261a:	6a 00                	push   $0x0
f011261c:	68 00 20 40 01       	push   $0x1402000
f0112621:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112624:	e8 b4 3b 00 00       	call   f01161dd <CB>
f0112629:	83 c4 10             	add    $0x10,%esp
f011262c:	83 f8 01             	cmp    $0x1,%eax
f011262f:	75 4c                	jne    f011267d <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112631:	83 ec 04             	sub    $0x4,%esp
f0112634:	6a 00                	push   $0x0
f0112636:	68 00 f0 bf 01       	push   $0x1bff000
f011263b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011263e:	e8 9a 3b 00 00       	call   f01161dd <CB>
f0112643:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112646:	85 c0                	test   %eax,%eax
f0112648:	75 33                	jne    f011267d <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011264a:	83 ec 04             	sub    $0x4,%esp
f011264d:	6a 00                	push   $0x0
f011264f:	68 00 00 c0 01       	push   $0x1c00000
f0112654:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112657:	e8 81 3b 00 00       	call   f01161dd <CB>
f011265c:	83 c4 10             	add    $0x10,%esp
f011265f:	83 f8 01             	cmp    $0x1,%eax
f0112662:	75 19                	jne    f011267d <test_cut_paste_pages+0x91b>
f0112664:	83 ec 04             	sub    $0x4,%esp
f0112667:	6a 00                	push   $0x0
f0112669:	68 00 10 c0 01       	push   $0x1c01000
f011266e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112671:	e8 67 3b 00 00       	call   f01161dd <CB>
f0112676:	83 c4 10             	add    $0x10,%esp
f0112679:	85 c0                	test   %eax,%eax
f011267b:	74 28                	je     f01126a5 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f011267d:	83 ec 04             	sub    $0x4,%esp
f0112680:	68 88 91 12 f0       	push   $0xf0129188
f0112685:	68 9f 02 00 00       	push   $0x29f
f011268a:	68 42 8b 12 f0       	push   $0xf0128b42
f011268f:	e8 42 de fe ff       	call   f01004d6 <_warn>
f0112694:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112697:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011269e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01126a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126a9:	74 04                	je     f01126af <test_cut_paste_pages+0x94d>
f01126ab:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01126af:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01126b6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01126ba:	0f 84 99 00 00 00    	je     f0112759 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f01126c0:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01126c7:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01126ce:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01126d5:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01126dc:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01126e3:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01126ea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01126ed:	8a 00                	mov    (%eax),%al
f01126ef:	3c 61                	cmp    $0x61,%al
f01126f1:	75 2d                	jne    f0112720 <test_cut_paste_pages+0x9be>
f01126f3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01126f6:	8a 00                	mov    (%eax),%al
f01126f8:	3c 78                	cmp    $0x78,%al
f01126fa:	75 24                	jne    f0112720 <test_cut_paste_pages+0x9be>
f01126fc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01126ff:	8a 00                	mov    (%eax),%al
f0112701:	3c 62                	cmp    $0x62,%al
f0112703:	75 1b                	jne    f0112720 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112705:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112708:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011270a:	3c 79                	cmp    $0x79,%al
f011270c:	75 12                	jne    f0112720 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011270e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112711:	8a 00                	mov    (%eax),%al
f0112713:	3c 63                	cmp    $0x63,%al
f0112715:	75 09                	jne    f0112720 <test_cut_paste_pages+0x9be>
f0112717:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011271a:	8a 00                	mov    (%eax),%al
f011271c:	3c 7a                	cmp    $0x7a,%al
f011271e:	74 28                	je     f0112748 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112720:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112727:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011272e:	83 ec 04             	sub    $0x4,%esp
f0112731:	68 88 90 12 f0       	push   $0xf0129088
f0112736:	68 b3 02 00 00       	push   $0x2b3
f011273b:	68 42 8b 12 f0       	push   $0xf0128b42
f0112740:	e8 91 dd fe ff       	call   f01004d6 <_warn>
f0112745:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112748:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011274c:	74 04                	je     f0112752 <test_cut_paste_pages+0x9f0>
f011274e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112752:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112759:	83 ec 0c             	sub    $0xc,%esp
f011275c:	68 c1 91 12 f0       	push   $0xf01291c1
f0112761:	e8 25 e8 fe ff       	call   f0100f8b <cprintf>
f0112766:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112769:	83 ec 08             	sub    $0x8,%esp
f011276c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011276f:	68 d0 91 12 f0       	push   $0xf01291d0
f0112774:	e8 12 e8 fe ff       	call   f0100f8b <cprintf>
f0112779:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011277c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112780:	75 10                	jne    f0112792 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112782:	83 ec 0c             	sub    $0xc,%esp
f0112785:	68 04 92 12 f0       	push   $0xf0129204
f011278a:	e8 fc e7 fe ff       	call   f0100f8b <cprintf>
f011278f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112792:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0112797:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011279a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011279d:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01127a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01127a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01127a8:	5b                   	pop    %ebx
f01127a9:	5e                   	pop    %esi
f01127aa:	5f                   	pop    %edi
f01127ab:	5d                   	pop    %ebp
f01127ac:	c3                   	ret    

f01127ad <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f01127ad:	55                   	push   %ebp
f01127ae:	89 e5                	mov    %esp,%ebp
f01127b0:	57                   	push   %edi
f01127b1:	56                   	push   %esi
f01127b2:	53                   	push   %ebx
f01127b3:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01127b9:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01127bf:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f01127c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01127c9:	89 c7                	mov    %eax,%edi
f01127cb:	89 de                	mov    %ebx,%esi
f01127cd:	89 d1                	mov    %edx,%ecx
f01127cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01127d1:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f01127d7:	b9 23 00 00 00       	mov    $0x23,%ecx
f01127dc:	b0 00                	mov    $0x0,%al
f01127de:	89 d7                	mov    %edx,%edi
f01127e0:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01127e2:	6a 00                	push   $0x0
f01127e4:	6a 0a                	push   $0xa
f01127e6:	6a 14                	push   $0x14
f01127e8:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01127ee:	50                   	push   %eax
f01127ef:	e8 31 81 ff ff       	call   f010a925 <env_create>
f01127f4:	83 c4 10             	add    $0x10,%esp
f01127f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01127fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01127fd:	8b 40 64             	mov    0x64(%eax),%eax
f0112800:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112803:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112806:	8b 40 68             	mov    0x68(%eax),%eax
f0112809:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f011280f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112815:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112818:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f011281f:	75 70 20 
f0112822:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112829:	00 00 00 
f011282c:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112832:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112837:	b8 00 00 00 00       	mov    $0x0,%eax
f011283c:	89 d7                	mov    %edx,%edi
f011283e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112840:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112843:	8b 40 10             	mov    0x10(%eax),%eax
f0112846:	83 ec 08             	sub    $0x8,%esp
f0112849:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f011284f:	52                   	push   %edx
f0112850:	50                   	push   %eax
f0112851:	e8 56 d2 00 00       	call   f011faac <ltostr>
f0112856:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112859:	83 ec 04             	sub    $0x4,%esp
f011285c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112862:	50                   	push   %eax
f0112863:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112869:	50                   	push   %eax
f011286a:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112870:	50                   	push   %eax
f0112871:	e8 0f d3 00 00       	call   f011fb85 <strcconcat>
f0112876:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112879:	83 ec 0c             	sub    $0xc,%esp
f011287c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011287f:	e8 49 3b 00 00       	call   f01163cd <ClearUserSpace>
f0112884:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112887:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f011288e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112895:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011289c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f01128a3:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01128aa:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f01128b1:	83 ec 0c             	sub    $0xc,%esp
f01128b4:	68 78 92 12 f0       	push   $0xf0129278
f01128b9:	e8 cd e6 fe ff       	call   f0100f8b <cprintf>
f01128be:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01128c1:	83 ec 04             	sub    $0x4,%esp
f01128c4:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128ca:	50                   	push   %eax
f01128cb:	68 ae 92 12 f0       	push   $0xf01292ae
f01128d0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01128d6:	50                   	push   %eax
f01128d7:	e8 a9 d2 00 00       	call   f011fb85 <strcconcat>
f01128dc:	83 c4 10             	add    $0x10,%esp
f01128df:	83 ec 0c             	sub    $0xc,%esp
f01128e2:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128e8:	50                   	push   %eax
f01128e9:	e8 0d f6 fe ff       	call   f0101efb <execute_command>
f01128ee:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f01128f1:	83 ec 04             	sub    $0x4,%esp
f01128f4:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128fa:	50                   	push   %eax
f01128fb:	68 b3 92 12 f0       	push   $0xf01292b3
f0112900:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112906:	50                   	push   %eax
f0112907:	e8 79 d2 00 00       	call   f011fb85 <strcconcat>
f011290c:	83 c4 10             	add    $0x10,%esp
f011290f:	83 ec 0c             	sub    $0xc,%esp
f0112912:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112918:	50                   	push   %eax
f0112919:	e8 dd f5 fe ff       	call   f0101efb <execute_command>
f011291e:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112921:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112927:	bb b9 95 12 f0       	mov    $0xf01295b9,%ebx
f011292c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112931:	89 c7                	mov    %eax,%edi
f0112933:	89 de                	mov    %ebx,%esi
f0112935:	89 d1                	mov    %edx,%ecx
f0112937:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112939:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f011293f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112944:	b0 00                	mov    $0x0,%al
f0112946:	89 d7                	mov    %edx,%edi
f0112948:	f3 aa                	rep stos %al,%es:(%edi)
f011294a:	83 ec 0c             	sub    $0xc,%esp
f011294d:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112953:	50                   	push   %eax
f0112954:	e8 a2 f5 fe ff       	call   f0101efb <execute_command>
f0112959:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f011295c:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112962:	bb 1d 96 12 f0       	mov    $0xf012961d,%ebx
f0112967:	ba 0f 00 00 00       	mov    $0xf,%edx
f011296c:	89 c7                	mov    %eax,%edi
f011296e:	89 de                	mov    %ebx,%esi
f0112970:	89 d1                	mov    %edx,%ecx
f0112972:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112974:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011297a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011297f:	b0 00                	mov    $0x0,%al
f0112981:	89 d7                	mov    %edx,%edi
f0112983:	f3 aa                	rep stos %al,%es:(%edi)
f0112985:	83 ec 0c             	sub    $0xc,%esp
f0112988:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011298e:	50                   	push   %eax
f011298f:	e8 67 f5 fe ff       	call   f0101efb <execute_command>
f0112994:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112997:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011299d:	bb 81 96 12 f0       	mov    $0xf0129681,%ebx
f01129a2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129a7:	89 c7                	mov    %eax,%edi
f01129a9:	89 de                	mov    %ebx,%esi
f01129ab:	89 d1                	mov    %edx,%ecx
f01129ad:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129af:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01129b5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01129ba:	b0 00                	mov    $0x0,%al
f01129bc:	89 d7                	mov    %edx,%edi
f01129be:	f3 aa                	rep stos %al,%es:(%edi)
f01129c0:	83 ec 0c             	sub    $0xc,%esp
f01129c3:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01129c9:	50                   	push   %eax
f01129ca:	e8 2c f5 fe ff       	call   f0101efb <execute_command>
f01129cf:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f01129d2:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01129d8:	bb e5 96 12 f0       	mov    $0xf01296e5,%ebx
f01129dd:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129e2:	89 c7                	mov    %eax,%edi
f01129e4:	89 de                	mov    %ebx,%esi
f01129e6:	89 d1                	mov    %edx,%ecx
f01129e8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129ea:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01129f0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01129f5:	b0 00                	mov    $0x0,%al
f01129f7:	89 d7                	mov    %edx,%edi
f01129f9:	f3 aa                	rep stos %al,%es:(%edi)
f01129fb:	83 ec 0c             	sub    $0xc,%esp
f01129fe:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112a04:	50                   	push   %eax
f0112a05:	e8 f1 f4 fe ff       	call   f0101efb <execute_command>
f0112a0a:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0112a0d:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112a13:	bb 49 97 12 f0       	mov    $0xf0129749,%ebx
f0112a18:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a1d:	89 c7                	mov    %eax,%edi
f0112a1f:	89 de                	mov    %ebx,%esi
f0112a21:	89 d1                	mov    %edx,%ecx
f0112a23:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a25:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112a2b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a30:	b0 00                	mov    $0x0,%al
f0112a32:	89 d7                	mov    %edx,%edi
f0112a34:	f3 aa                	rep stos %al,%es:(%edi)
f0112a36:	83 ec 0c             	sub    $0xc,%esp
f0112a39:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112a3f:	50                   	push   %eax
f0112a40:	e8 b6 f4 fe ff       	call   f0101efb <execute_command>
f0112a45:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0112a48:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112a4e:	bb ad 97 12 f0       	mov    $0xf01297ad,%ebx
f0112a53:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a58:	89 c7                	mov    %eax,%edi
f0112a5a:	89 de                	mov    %ebx,%esi
f0112a5c:	89 d1                	mov    %edx,%ecx
f0112a5e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a60:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112a66:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a6b:	b0 00                	mov    $0x0,%al
f0112a6d:	89 d7                	mov    %edx,%edi
f0112a6f:	f3 aa                	rep stos %al,%es:(%edi)
f0112a71:	83 ec 0c             	sub    $0xc,%esp
f0112a74:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112a7a:	50                   	push   %eax
f0112a7b:	e8 7b f4 fe ff       	call   f0101efb <execute_command>
f0112a80:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0112a83:	83 ec 04             	sub    $0x4,%esp
f0112a86:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112a8c:	50                   	push   %eax
f0112a8d:	68 bb 92 12 f0       	push   $0xf01292bb
f0112a92:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112a98:	50                   	push   %eax
f0112a99:	e8 e7 d0 00 00       	call   f011fb85 <strcconcat>
f0112a9e:	83 c4 10             	add    $0x10,%esp
f0112aa1:	83 ec 0c             	sub    $0xc,%esp
f0112aa4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112aaa:	50                   	push   %eax
f0112aab:	e8 4b f4 fe ff       	call   f0101efb <execute_command>
f0112ab0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112ab3:	83 ec 04             	sub    $0x4,%esp
f0112ab6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112abc:	50                   	push   %eax
f0112abd:	68 c5 92 12 f0       	push   $0xf01292c5
f0112ac2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112ac8:	50                   	push   %eax
f0112ac9:	e8 b7 d0 00 00       	call   f011fb85 <strcconcat>
f0112ace:	83 c4 10             	add    $0x10,%esp
f0112ad1:	83 ec 0c             	sub    $0xc,%esp
f0112ad4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ada:	50                   	push   %eax
f0112adb:	e8 1b f4 fe ff       	call   f0101efb <execute_command>
f0112ae0:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0112ae3:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112ae9:	bb 11 98 12 f0       	mov    $0xf0129811,%ebx
f0112aee:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112af3:	89 c7                	mov    %eax,%edi
f0112af5:	89 de                	mov    %ebx,%esi
f0112af7:	89 d1                	mov    %edx,%ecx
f0112af9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112afb:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112b01:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112b06:	b0 00                	mov    $0x0,%al
f0112b08:	89 d7                	mov    %edx,%edi
f0112b0a:	f3 aa                	rep stos %al,%es:(%edi)
f0112b0c:	83 ec 0c             	sub    $0xc,%esp
f0112b0f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112b15:	50                   	push   %eax
f0112b16:	e8 e0 f3 fe ff       	call   f0101efb <execute_command>
f0112b1b:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112b1e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112b24:	bb 75 98 12 f0       	mov    $0xf0129875,%ebx
f0112b29:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112b2e:	89 c7                	mov    %eax,%edi
f0112b30:	89 de                	mov    %ebx,%esi
f0112b32:	89 d1                	mov    %edx,%ecx
f0112b34:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112b36:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112b3c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112b41:	b0 00                	mov    $0x0,%al
f0112b43:	89 d7                	mov    %edx,%edi
f0112b45:	f3 aa                	rep stos %al,%es:(%edi)
f0112b47:	83 ec 0c             	sub    $0xc,%esp
f0112b4a:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112b50:	50                   	push   %eax
f0112b51:	e8 a5 f3 fe ff       	call   f0101efb <execute_command>
f0112b56:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0112b59:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112b5f:	bb d9 98 12 f0       	mov    $0xf01298d9,%ebx
f0112b64:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112b69:	89 c7                	mov    %eax,%edi
f0112b6b:	89 de                	mov    %ebx,%esi
f0112b6d:	89 d1                	mov    %edx,%ecx
f0112b6f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112b71:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112b77:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112b7c:	b0 00                	mov    $0x0,%al
f0112b7e:	89 d7                	mov    %edx,%edi
f0112b80:	f3 aa                	rep stos %al,%es:(%edi)
f0112b82:	83 ec 0c             	sub    $0xc,%esp
f0112b85:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112b8b:	50                   	push   %eax
f0112b8c:	e8 6a f3 fe ff       	call   f0101efb <execute_command>
f0112b91:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112b94:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112b9b:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112ba2:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0112ba9:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112bb0:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0112bb7:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112bbe:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0112bc5:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112bcc:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112bd3:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112bda:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112be1:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0112be8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112beb:	8a 00                	mov    (%eax),%al
f0112bed:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112bf3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bf6:	8a 00                	mov    (%eax),%al
f0112bf8:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112bfe:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112c01:	8a 00                	mov    (%eax),%al
f0112c03:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112c09:	e8 b8 b6 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0112c0e:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112c11:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112c14:	89 d0                	mov    %edx,%eax
f0112c16:	01 c0                	add    %eax,%eax
f0112c18:	01 d0                	add    %edx,%eax
f0112c1a:	01 c0                	add    %eax,%eax
f0112c1c:	50                   	push   %eax
f0112c1d:	68 00 00 10 00       	push   $0x100000
f0112c22:	6a 00                	push   $0x0
f0112c24:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c27:	e8 52 78 ff ff       	call   f010a47e <copy_paste_chunk>
f0112c2c:	83 c4 10             	add    $0x10,%esp
f0112c2f:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112c32:	e8 8f b6 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0112c37:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112c3a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112c41:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0112c45:	75 08                	jne    f0112c4f <test_copy_paste_chunk+0x4a2>
f0112c47:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c4a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112c4d:	74 2b                	je     f0112c7a <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112c4f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c52:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112c55:	83 ec 0c             	sub    $0xc,%esp
f0112c58:	50                   	push   %eax
f0112c59:	ff 75 88             	pushl  -0x78(%ebp)
f0112c5c:	68 d4 92 12 f0       	push   $0xf01292d4
f0112c61:	68 06 03 00 00       	push   $0x306
f0112c66:	68 42 8b 12 f0       	push   $0xf0128b42
f0112c6b:	e8 66 d8 fe ff       	call   f01004d6 <_warn>
f0112c70:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112c73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112c7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c7e:	74 04                	je     f0112c84 <test_copy_paste_chunk+0x4d7>
f0112c80:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112c84:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0112c8b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112c8e:	8a 00                	mov    (%eax),%al
f0112c90:	3c 61                	cmp    $0x61,%al
f0112c92:	75 75                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112c94:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c97:	8a 00                	mov    (%eax),%al
f0112c99:	3c 78                	cmp    $0x78,%al
f0112c9b:	75 6c                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112c9d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112ca0:	8a 00                	mov    (%eax),%al
f0112ca2:	3c 62                	cmp    $0x62,%al
f0112ca4:	75 63                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112ca6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112ca9:	8a 00                	mov    (%eax),%al
f0112cab:	3c 79                	cmp    $0x79,%al
f0112cad:	75 5a                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112caf:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112cb2:	8a 00                	mov    (%eax),%al
f0112cb4:	3c 63                	cmp    $0x63,%al
f0112cb6:	75 51                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112cb8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112cbb:	8a 00                	mov    (%eax),%al
f0112cbd:	3c 7a                	cmp    $0x7a,%al
f0112cbf:	75 48                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0112cc1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112cc4:	8a 00                	mov    (%eax),%al
f0112cc6:	3c 64                	cmp    $0x64,%al
f0112cc8:	75 3f                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112cca:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112ccd:	8a 10                	mov    (%eax),%dl
f0112ccf:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0112cd5:	38 c2                	cmp    %al,%dl
f0112cd7:	75 30                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112cd9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112cdc:	8a 00                	mov    (%eax),%al
f0112cde:	3c 65                	cmp    $0x65,%al
f0112ce0:	75 27                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112ce2:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ce5:	8a 10                	mov    (%eax),%dl
f0112ce7:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0112ced:	38 c2                	cmp    %al,%dl
f0112cef:	75 18                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112cf1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112cf4:	8a 00                	mov    (%eax),%al
f0112cf6:	3c 66                	cmp    $0x66,%al
f0112cf8:	75 0f                	jne    f0112d09 <test_copy_paste_chunk+0x55c>
f0112cfa:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112cfd:	8a 10                	mov    (%eax),%dl
f0112cff:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0112d05:	38 c2                	cmp    %al,%dl
f0112d07:	74 21                	je     f0112d2a <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112d09:	83 ec 04             	sub    $0x4,%esp
f0112d0c:	68 38 93 12 f0       	push   $0xf0129338
f0112d11:	68 0f 03 00 00       	push   $0x30f
f0112d16:	68 42 8b 12 f0       	push   $0xf0128b42
f0112d1b:	e8 b6 d7 fe ff       	call   f01004d6 <_warn>
f0112d20:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112d23:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112d2a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d2e:	74 04                	je     f0112d34 <test_copy_paste_chunk+0x587>
f0112d30:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112d34:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0112d3b:	83 ec 0c             	sub    $0xc,%esp
f0112d3e:	68 72 93 12 f0       	push   $0xf0129372
f0112d43:	e8 43 e2 fe ff       	call   f0100f8b <cprintf>
f0112d48:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0112d4b:	83 ec 0c             	sub    $0xc,%esp
f0112d4e:	68 84 93 12 f0       	push   $0xf0129384
f0112d53:	e8 33 e2 fe ff       	call   f0100f8b <cprintf>
f0112d58:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0112d5b:	83 ec 04             	sub    $0x4,%esp
f0112d5e:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d64:	50                   	push   %eax
f0112d65:	68 ba 93 12 f0       	push   $0xf01293ba
f0112d6a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112d70:	50                   	push   %eax
f0112d71:	e8 0f ce 00 00       	call   f011fb85 <strcconcat>
f0112d76:	83 c4 10             	add    $0x10,%esp
f0112d79:	83 ec 0c             	sub    $0xc,%esp
f0112d7c:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d82:	50                   	push   %eax
f0112d83:	e8 73 f1 fe ff       	call   f0101efb <execute_command>
f0112d88:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0112d8b:	83 ec 04             	sub    $0x4,%esp
f0112d8e:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d94:	50                   	push   %eax
f0112d95:	68 c4 93 12 f0       	push   $0xf01293c4
f0112d9a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112da0:	50                   	push   %eax
f0112da1:	e8 df cd 00 00       	call   f011fb85 <strcconcat>
f0112da6:	83 c4 10             	add    $0x10,%esp
f0112da9:	83 ec 0c             	sub    $0xc,%esp
f0112dac:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112db2:	50                   	push   %eax
f0112db3:	e8 43 f1 fe ff       	call   f0101efb <execute_command>
f0112db8:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0112dbb:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112dc1:	bb 3d 99 12 f0       	mov    $0xf012993d,%ebx
f0112dc6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112dcb:	89 c7                	mov    %eax,%edi
f0112dcd:	89 de                	mov    %ebx,%esi
f0112dcf:	89 d1                	mov    %edx,%ecx
f0112dd1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112dd3:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112dd9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112dde:	b0 00                	mov    $0x0,%al
f0112de0:	89 d7                	mov    %edx,%edi
f0112de2:	f3 aa                	rep stos %al,%es:(%edi)
f0112de4:	83 ec 0c             	sub    $0xc,%esp
f0112de7:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112ded:	50                   	push   %eax
f0112dee:	e8 08 f1 fe ff       	call   f0101efb <execute_command>
f0112df3:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0112df6:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112dfc:	bb a1 99 12 f0       	mov    $0xf01299a1,%ebx
f0112e01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e06:	89 c7                	mov    %eax,%edi
f0112e08:	89 de                	mov    %ebx,%esi
f0112e0a:	89 d1                	mov    %edx,%ecx
f0112e0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e0e:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112e14:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e19:	b0 00                	mov    $0x0,%al
f0112e1b:	89 d7                	mov    %edx,%edi
f0112e1d:	f3 aa                	rep stos %al,%es:(%edi)
f0112e1f:	83 ec 0c             	sub    $0xc,%esp
f0112e22:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112e28:	50                   	push   %eax
f0112e29:	e8 cd f0 fe ff       	call   f0101efb <execute_command>
f0112e2e:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0112e31:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112e37:	bb 05 9a 12 f0       	mov    $0xf0129a05,%ebx
f0112e3c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e41:	89 c7                	mov    %eax,%edi
f0112e43:	89 de                	mov    %ebx,%esi
f0112e45:	89 d1                	mov    %edx,%ecx
f0112e47:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e49:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112e4f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e54:	b0 00                	mov    $0x0,%al
f0112e56:	89 d7                	mov    %edx,%edi
f0112e58:	f3 aa                	rep stos %al,%es:(%edi)
f0112e5a:	83 ec 0c             	sub    $0xc,%esp
f0112e5d:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112e63:	50                   	push   %eax
f0112e64:	e8 92 f0 fe ff       	call   f0101efb <execute_command>
f0112e69:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0112e6c:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112e72:	bb 69 9a 12 f0       	mov    $0xf0129a69,%ebx
f0112e77:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e7c:	89 c7                	mov    %eax,%edi
f0112e7e:	89 de                	mov    %ebx,%esi
f0112e80:	89 d1                	mov    %edx,%ecx
f0112e82:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e84:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112e8a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e8f:	b0 00                	mov    $0x0,%al
f0112e91:	89 d7                	mov    %edx,%edi
f0112e93:	f3 aa                	rep stos %al,%es:(%edi)
f0112e95:	83 ec 0c             	sub    $0xc,%esp
f0112e98:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112e9e:	50                   	push   %eax
f0112e9f:	e8 57 f0 fe ff       	call   f0101efb <execute_command>
f0112ea4:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0112ea7:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112ead:	bb cd 9a 12 f0       	mov    $0xf0129acd,%ebx
f0112eb2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112eb7:	89 c7                	mov    %eax,%edi
f0112eb9:	89 de                	mov    %ebx,%esi
f0112ebb:	89 d1                	mov    %edx,%ecx
f0112ebd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ebf:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112ec5:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112eca:	b0 00                	mov    $0x0,%al
f0112ecc:	89 d7                	mov    %edx,%edi
f0112ece:	f3 aa                	rep stos %al,%es:(%edi)
f0112ed0:	83 ec 0c             	sub    $0xc,%esp
f0112ed3:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112ed9:	50                   	push   %eax
f0112eda:	e8 1c f0 fe ff       	call   f0101efb <execute_command>
f0112edf:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0112ee2:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112ee8:	bb 31 9b 12 f0       	mov    $0xf0129b31,%ebx
f0112eed:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ef2:	89 c7                	mov    %eax,%edi
f0112ef4:	89 de                	mov    %ebx,%esi
f0112ef6:	89 d1                	mov    %edx,%ecx
f0112ef8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112efa:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112f00:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f05:	b0 00                	mov    $0x0,%al
f0112f07:	89 d7                	mov    %edx,%edi
f0112f09:	f3 aa                	rep stos %al,%es:(%edi)
f0112f0b:	83 ec 0c             	sub    $0xc,%esp
f0112f0e:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112f14:	50                   	push   %eax
f0112f15:	e8 e1 ef fe ff       	call   f0101efb <execute_command>
f0112f1a:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0112f1d:	83 ec 04             	sub    $0x4,%esp
f0112f20:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f26:	50                   	push   %eax
f0112f27:	68 ce 93 12 f0       	push   $0xf01293ce
f0112f2c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f32:	50                   	push   %eax
f0112f33:	e8 4d cc 00 00       	call   f011fb85 <strcconcat>
f0112f38:	83 c4 10             	add    $0x10,%esp
f0112f3b:	83 ec 0c             	sub    $0xc,%esp
f0112f3e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f44:	50                   	push   %eax
f0112f45:	e8 b1 ef fe ff       	call   f0101efb <execute_command>
f0112f4a:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0112f4d:	83 ec 04             	sub    $0x4,%esp
f0112f50:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f56:	50                   	push   %eax
f0112f57:	68 d8 93 12 f0       	push   $0xf01293d8
f0112f5c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f62:	50                   	push   %eax
f0112f63:	e8 1d cc 00 00       	call   f011fb85 <strcconcat>
f0112f68:	83 c4 10             	add    $0x10,%esp
f0112f6b:	83 ec 0c             	sub    $0xc,%esp
f0112f6e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f74:	50                   	push   %eax
f0112f75:	e8 81 ef fe ff       	call   f0101efb <execute_command>
f0112f7a:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0112f7d:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112f83:	bb 95 9b 12 f0       	mov    $0xf0129b95,%ebx
f0112f88:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f8d:	89 c7                	mov    %eax,%edi
f0112f8f:	89 de                	mov    %ebx,%esi
f0112f91:	89 d1                	mov    %edx,%ecx
f0112f93:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f95:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112f9b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fa0:	b0 00                	mov    $0x0,%al
f0112fa2:	89 d7                	mov    %edx,%edi
f0112fa4:	f3 aa                	rep stos %al,%es:(%edi)
f0112fa6:	83 ec 0c             	sub    $0xc,%esp
f0112fa9:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112faf:	50                   	push   %eax
f0112fb0:	e8 46 ef fe ff       	call   f0101efb <execute_command>
f0112fb5:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0112fb8:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112fbe:	bb f9 9b 12 f0       	mov    $0xf0129bf9,%ebx
f0112fc3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112fc8:	89 c7                	mov    %eax,%edi
f0112fca:	89 de                	mov    %ebx,%esi
f0112fcc:	89 d1                	mov    %edx,%ecx
f0112fce:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fd0:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112fd6:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fdb:	b0 00                	mov    $0x0,%al
f0112fdd:	89 d7                	mov    %edx,%edi
f0112fdf:	f3 aa                	rep stos %al,%es:(%edi)
f0112fe1:	83 ec 0c             	sub    $0xc,%esp
f0112fe4:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112fea:	50                   	push   %eax
f0112feb:	e8 0b ef fe ff       	call   f0101efb <execute_command>
f0112ff0:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0112ff3:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112ff9:	bb 5d 9c 12 f0       	mov    $0xf0129c5d,%ebx
f0112ffe:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113003:	89 c7                	mov    %eax,%edi
f0113005:	89 de                	mov    %ebx,%esi
f0113007:	89 d1                	mov    %edx,%ecx
f0113009:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011300b:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113011:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113016:	b0 00                	mov    $0x0,%al
f0113018:	89 d7                	mov    %edx,%edi
f011301a:	f3 aa                	rep stos %al,%es:(%edi)
f011301c:	83 ec 0c             	sub    $0xc,%esp
f011301f:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113025:	50                   	push   %eax
f0113026:	e8 d0 ee fe ff       	call   f0101efb <execute_command>
f011302b:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011302e:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113035:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f011303c:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113043:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011304a:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113051:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113058:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f011305f:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113066:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011306d:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113074:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011307b:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113082:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113085:	8a 00                	mov    (%eax),%al
f0113087:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011308d:	e8 34 b2 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113092:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113095:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113098:	89 d0                	mov    %edx,%eax
f011309a:	01 c0                	add    %eax,%eax
f011309c:	01 d0                	add    %edx,%eax
f011309e:	01 c0                	add    %eax,%eax
f01130a0:	50                   	push   %eax
f01130a1:	68 00 00 40 00       	push   $0x400000
f01130a6:	68 00 00 20 00       	push   $0x200000
f01130ab:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130ae:	e8 cb 73 ff ff       	call   f010a47e <copy_paste_chunk>
f01130b3:	83 c4 10             	add    $0x10,%esp
f01130b6:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01130b9:	e8 08 b2 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01130be:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01130c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01130c8:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01130cc:	75 08                	jne    f01130d6 <test_copy_paste_chunk+0x929>
f01130ce:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01130d1:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01130d4:	74 2b                	je     f0113101 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01130d6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01130d9:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01130dc:	83 ec 0c             	sub    $0xc,%esp
f01130df:	50                   	push   %eax
f01130e0:	ff 75 80             	pushl  -0x80(%ebp)
f01130e3:	68 e4 93 12 f0       	push   $0xf01293e4
f01130e8:	68 3f 03 00 00       	push   $0x33f
f01130ed:	68 42 8b 12 f0       	push   $0xf0128b42
f01130f2:	e8 df d3 fe ff       	call   f01004d6 <_warn>
f01130f7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01130fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113101:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113105:	74 04                	je     f011310b <test_copy_paste_chunk+0x95e>
f0113107:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011310b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113112:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113119:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011311c:	83 ec 08             	sub    $0x8,%esp
f011311f:	6a 01                	push   $0x1
f0113121:	6a 07                	push   $0x7
f0113123:	6a 07                	push   $0x7
f0113125:	6a 07                	push   $0x7
f0113127:	6a 07                	push   $0x7
f0113129:	6a 01                	push   $0x1
f011312b:	68 00 20 00 00       	push   $0x2000
f0113130:	68 00 00 40 00       	push   $0x400000
f0113135:	68 00 00 20 00       	push   $0x200000
f011313a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011313d:	e8 bf 32 00 00       	call   f0116401 <CCP>
f0113142:	83 c4 30             	add    $0x30,%esp
f0113145:	83 f8 01             	cmp    $0x1,%eax
f0113148:	74 2b                	je     f0113175 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011314a:	83 ec 04             	sub    $0x4,%esp
f011314d:	68 38 94 12 f0       	push   $0xf0129438
f0113152:	68 48 03 00 00       	push   $0x348
f0113157:	68 42 8b 12 f0       	push   $0xf0128b42
f011315c:	e8 75 d3 fe ff       	call   f01004d6 <_warn>
f0113161:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113164:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011316b:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113172:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113175:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113179:	74 04                	je     f011317f <test_copy_paste_chunk+0x9d2>
f011317b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011317f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113186:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113189:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011318c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011318f:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113192:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113195:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113198:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011319b:	8a 00                	mov    (%eax),%al
f011319d:	3c 61                	cmp    $0x61,%al
f011319f:	75 69                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01131a4:	8a 00                	mov    (%eax),%al
f01131a6:	3c 61                	cmp    $0x61,%al
f01131a8:	75 60                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131aa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01131ad:	8a 00                	mov    (%eax),%al
f01131af:	3c 79                	cmp    $0x79,%al
f01131b1:	75 57                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131b3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01131b6:	8a 00                	mov    (%eax),%al
f01131b8:	3c 62                	cmp    $0x62,%al
f01131ba:	75 4e                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131bc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01131bf:	8a 00                	mov    (%eax),%al
f01131c1:	3c 63                	cmp    $0x63,%al
f01131c3:	75 45                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131c5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01131c8:	8a 00                	mov    (%eax),%al
f01131ca:	3c 7a                	cmp    $0x7a,%al
f01131cc:	75 3c                	jne    f011320a <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01131ce:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01131d1:	8a 00                	mov    (%eax),%al
f01131d3:	3c 77                	cmp    $0x77,%al
f01131d5:	75 33                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131d7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01131da:	8a 00                	mov    (%eax),%al
f01131dc:	3c 64                	cmp    $0x64,%al
f01131de:	75 2a                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131e0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01131e3:	8a 00                	mov    (%eax),%al
f01131e5:	3c 65                	cmp    $0x65,%al
f01131e7:	75 21                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131e9:	8b 45 98             	mov    -0x68(%ebp),%eax
f01131ec:	8a 00                	mov    (%eax),%al
f01131ee:	3c 65                	cmp    $0x65,%al
f01131f0:	75 18                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131f2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01131f5:	8a 00                	mov    (%eax),%al
f01131f7:	3c 66                	cmp    $0x66,%al
f01131f9:	75 0f                	jne    f011320a <test_copy_paste_chunk+0xa5d>
f01131fb:	8b 45 90             	mov    -0x70(%ebp),%eax
f01131fe:	8a 10                	mov    (%eax),%dl
f0113200:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113206:	38 c2                	cmp    %al,%dl
f0113208:	74 21                	je     f011322b <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011320a:	83 ec 04             	sub    $0x4,%esp
f011320d:	68 38 93 12 f0       	push   $0xf0129338
f0113212:	68 56 03 00 00       	push   $0x356
f0113217:	68 42 8b 12 f0       	push   $0xf0128b42
f011321c:	e8 b5 d2 fe ff       	call   f01004d6 <_warn>
f0113221:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113224:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011322b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011322f:	74 04                	je     f0113235 <test_copy_paste_chunk+0xa88>
f0113231:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113235:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011323c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011323f:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113242:	e8 7f b0 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113247:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011324a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011324d:	89 c2                	mov    %eax,%edx
f011324f:	01 d2                	add    %edx,%edx
f0113251:	01 d0                	add    %edx,%eax
f0113253:	50                   	push   %eax
f0113254:	68 00 08 20 00       	push   $0x200800
f0113259:	68 00 08 40 00       	push   $0x400800
f011325e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113261:	e8 18 72 ff ff       	call   f010a47e <copy_paste_chunk>
f0113266:	83 c4 10             	add    $0x10,%esp
f0113269:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011326c:	e8 55 b0 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113271:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113274:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113278:	75 08                	jne    f0113282 <test_copy_paste_chunk+0xad5>
f011327a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011327d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113280:	74 2b                	je     f01132ad <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113282:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113285:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113288:	83 ec 0c             	sub    $0xc,%esp
f011328b:	50                   	push   %eax
f011328c:	ff 75 80             	pushl  -0x80(%ebp)
f011328f:	68 e4 93 12 f0       	push   $0xf01293e4
f0113294:	68 66 03 00 00       	push   $0x366
f0113299:	68 42 8b 12 f0       	push   $0xf0128b42
f011329e:	e8 33 d2 fe ff       	call   f01004d6 <_warn>
f01132a3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01132a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01132ad:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132b1:	74 04                	je     f01132b7 <test_copy_paste_chunk+0xb0a>
f01132b3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01132b7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01132be:	83 ec 08             	sub    $0x8,%esp
f01132c1:	6a 01                	push   $0x1
f01132c3:	6a 07                	push   $0x7
f01132c5:	6a 07                	push   $0x7
f01132c7:	6a 07                	push   $0x7
f01132c9:	6a 07                	push   $0x7
f01132cb:	6a 01                	push   $0x1
f01132cd:	68 00 20 00 00       	push   $0x2000
f01132d2:	68 00 00 20 00       	push   $0x200000
f01132d7:	68 00 00 40 00       	push   $0x400000
f01132dc:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132df:	e8 1d 31 00 00       	call   f0116401 <CCP>
f01132e4:	83 c4 30             	add    $0x30,%esp
f01132e7:	83 f8 01             	cmp    $0x1,%eax
f01132ea:	74 21                	je     f011330d <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01132ec:	83 ec 04             	sub    $0x4,%esp
f01132ef:	68 84 94 12 f0       	push   $0xf0129484
f01132f4:	68 6e 03 00 00       	push   $0x36e
f01132f9:	68 42 8b 12 f0       	push   $0xf0128b42
f01132fe:	e8 d3 d1 fe ff       	call   f01004d6 <_warn>
f0113303:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113306:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011330d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113311:	74 04                	je     f0113317 <test_copy_paste_chunk+0xb6a>
f0113313:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113317:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011331e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113321:	8a 00                	mov    (%eax),%al
f0113323:	3c 61                	cmp    $0x61,%al
f0113325:	75 69                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113327:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011332a:	8a 00                	mov    (%eax),%al
f011332c:	3c 61                	cmp    $0x61,%al
f011332e:	75 60                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113330:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113333:	8a 00                	mov    (%eax),%al
f0113335:	3c 79                	cmp    $0x79,%al
f0113337:	75 57                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113339:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011333c:	8a 00                	mov    (%eax),%al
f011333e:	3c 62                	cmp    $0x62,%al
f0113340:	75 4e                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113342:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113345:	8a 00                	mov    (%eax),%al
f0113347:	3c 7a                	cmp    $0x7a,%al
f0113349:	75 45                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f011334b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011334e:	8a 00                	mov    (%eax),%al
f0113350:	3c 7a                	cmp    $0x7a,%al
f0113352:	75 3c                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113354:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113357:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113359:	3c 64                	cmp    $0x64,%al
f011335b:	75 33                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011335d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113360:	8a 00                	mov    (%eax),%al
f0113362:	3c 64                	cmp    $0x64,%al
f0113364:	75 2a                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113366:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113369:	8a 00                	mov    (%eax),%al
f011336b:	3c 65                	cmp    $0x65,%al
f011336d:	75 21                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f011336f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113372:	8a 00                	mov    (%eax),%al
f0113374:	3c 78                	cmp    $0x78,%al
f0113376:	75 18                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113378:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011337b:	8a 00                	mov    (%eax),%al
f011337d:	3c 66                	cmp    $0x66,%al
f011337f:	75 0f                	jne    f0113390 <test_copy_paste_chunk+0xbe3>
f0113381:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113384:	8a 10                	mov    (%eax),%dl
f0113386:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011338c:	38 c2                	cmp    %al,%dl
f011338e:	74 21                	je     f01133b1 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113390:	83 ec 04             	sub    $0x4,%esp
f0113393:	68 38 93 12 f0       	push   $0xf0129338
f0113398:	68 77 03 00 00       	push   $0x377
f011339d:	68 42 8b 12 f0       	push   $0xf0128b42
f01133a2:	e8 2f d1 fe ff       	call   f01004d6 <_warn>
f01133a7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01133aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01133b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01133b5:	74 04                	je     f01133bb <test_copy_paste_chunk+0xc0e>
f01133b7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01133bb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01133c2:	83 ec 0c             	sub    $0xc,%esp
f01133c5:	68 cf 94 12 f0       	push   $0xf01294cf
f01133ca:	e8 bc db fe ff       	call   f0100f8b <cprintf>
f01133cf:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01133d2:	83 ec 0c             	sub    $0xc,%esp
f01133d5:	68 e0 94 12 f0       	push   $0xf01294e0
f01133da:	e8 ac db fe ff       	call   f0100f8b <cprintf>
f01133df:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01133e2:	83 ec 04             	sub    $0x4,%esp
f01133e5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01133eb:	50                   	push   %eax
f01133ec:	68 14 95 12 f0       	push   $0xf0129514
f01133f1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133f7:	50                   	push   %eax
f01133f8:	e8 88 c7 00 00       	call   f011fb85 <strcconcat>
f01133fd:	83 c4 10             	add    $0x10,%esp
f0113400:	83 ec 0c             	sub    $0xc,%esp
f0113403:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113409:	50                   	push   %eax
f011340a:	e8 ec ea fe ff       	call   f0101efb <execute_command>
f011340f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113412:	83 ec 04             	sub    $0x4,%esp
f0113415:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011341b:	50                   	push   %eax
f011341c:	68 1e 95 12 f0       	push   $0xf012951e
f0113421:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113427:	50                   	push   %eax
f0113428:	e8 58 c7 00 00       	call   f011fb85 <strcconcat>
f011342d:	83 c4 10             	add    $0x10,%esp
f0113430:	83 ec 0c             	sub    $0xc,%esp
f0113433:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113439:	50                   	push   %eax
f011343a:	e8 bc ea fe ff       	call   f0101efb <execute_command>
f011343f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113442:	83 ec 04             	sub    $0x4,%esp
f0113445:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011344b:	50                   	push   %eax
f011344c:	68 28 95 12 f0       	push   $0xf0129528
f0113451:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113457:	50                   	push   %eax
f0113458:	e8 28 c7 00 00       	call   f011fb85 <strcconcat>
f011345d:	83 c4 10             	add    $0x10,%esp
f0113460:	83 ec 0c             	sub    $0xc,%esp
f0113463:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113469:	50                   	push   %eax
f011346a:	e8 8c ea fe ff       	call   f0101efb <execute_command>
f011346f:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113472:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113478:	bb c1 9c 12 f0       	mov    $0xf0129cc1,%ebx
f011347d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113482:	89 c7                	mov    %eax,%edi
f0113484:	89 de                	mov    %ebx,%esi
f0113486:	89 d1                	mov    %edx,%ecx
f0113488:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011348a:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113490:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113495:	b0 00                	mov    $0x0,%al
f0113497:	89 d7                	mov    %edx,%edi
f0113499:	f3 aa                	rep stos %al,%es:(%edi)
f011349b:	83 ec 0c             	sub    $0xc,%esp
f011349e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01134a4:	50                   	push   %eax
f01134a5:	e8 51 ea fe ff       	call   f0101efb <execute_command>
f01134aa:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f01134ad:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01134b3:	bb 25 9d 12 f0       	mov    $0xf0129d25,%ebx
f01134b8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134bd:	89 c7                	mov    %eax,%edi
f01134bf:	89 de                	mov    %ebx,%esi
f01134c1:	89 d1                	mov    %edx,%ecx
f01134c3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134c5:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01134cb:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134d0:	b0 00                	mov    $0x0,%al
f01134d2:	89 d7                	mov    %edx,%edi
f01134d4:	f3 aa                	rep stos %al,%es:(%edi)
f01134d6:	83 ec 0c             	sub    $0xc,%esp
f01134d9:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01134df:	50                   	push   %eax
f01134e0:	e8 16 ea fe ff       	call   f0101efb <execute_command>
f01134e5:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f01134e8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01134ee:	bb 89 9d 12 f0       	mov    $0xf0129d89,%ebx
f01134f3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134f8:	89 c7                	mov    %eax,%edi
f01134fa:	89 de                	mov    %ebx,%esi
f01134fc:	89 d1                	mov    %edx,%ecx
f01134fe:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113500:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113506:	b9 55 00 00 00       	mov    $0x55,%ecx
f011350b:	b0 00                	mov    $0x0,%al
f011350d:	89 d7                	mov    %edx,%edi
f011350f:	f3 aa                	rep stos %al,%es:(%edi)
f0113511:	83 ec 0c             	sub    $0xc,%esp
f0113514:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011351a:	50                   	push   %eax
f011351b:	e8 db e9 fe ff       	call   f0101efb <execute_command>
f0113520:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113523:	e8 9e ad ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113528:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011352b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011352e:	89 d0                	mov    %edx,%eax
f0113530:	01 c0                	add    %eax,%eax
f0113532:	01 d0                	add    %edx,%eax
f0113534:	c1 e0 02             	shl    $0x2,%eax
f0113537:	50                   	push   %eax
f0113538:	68 00 00 90 00       	push   $0x900000
f011353d:	68 00 00 80 00       	push   $0x800000
f0113542:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113545:	e8 34 6f ff ff       	call   f010a47e <copy_paste_chunk>
f011354a:	83 c4 10             	add    $0x10,%esp
f011354d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113553:	e8 6e ad ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113558:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011355b:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113562:	75 0b                	jne    f011356f <test_copy_paste_chunk+0xdc2>
f0113564:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113567:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011356a:	83 f8 03             	cmp    $0x3,%eax
f011356d:	74 2e                	je     f011359d <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011356f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113572:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113575:	83 ec 0c             	sub    $0xc,%esp
f0113578:	50                   	push   %eax
f0113579:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f011357f:	68 e4 93 12 f0       	push   $0xf01293e4
f0113584:	68 95 03 00 00       	push   $0x395
f0113589:	68 42 8b 12 f0       	push   $0xf0128b42
f011358e:	e8 43 cf fe ff       	call   f01004d6 <_warn>
f0113593:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113596:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011359d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01135a1:	74 04                	je     f01135a7 <test_copy_paste_chunk+0xdfa>
f01135a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01135a7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f01135ae:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01135b5:	83 ec 08             	sub    $0x8,%esp
f01135b8:	6a 01                	push   $0x1
f01135ba:	6a 07                	push   $0x7
f01135bc:	6a 07                	push   $0x7
f01135be:	6a 07                	push   $0x7
f01135c0:	6a 07                	push   $0x7
f01135c2:	6a 01                	push   $0x1
f01135c4:	68 00 30 00 00       	push   $0x3000
f01135c9:	68 00 00 90 00       	push   $0x900000
f01135ce:	68 00 00 80 00       	push   $0x800000
f01135d3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135d6:	e8 26 2e 00 00       	call   f0116401 <CCP>
f01135db:	83 c4 30             	add    $0x30,%esp
f01135de:	83 f8 01             	cmp    $0x1,%eax
f01135e1:	74 28                	je     f011360b <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01135e3:	83 ec 04             	sub    $0x4,%esp
f01135e6:	68 84 94 12 f0       	push   $0xf0129484
f01135eb:	68 9e 03 00 00       	push   $0x39e
f01135f0:	68 42 8b 12 f0       	push   $0xf0128b42
f01135f5:	e8 dc ce fe ff       	call   f01004d6 <_warn>
f01135fa:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01135fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113604:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f011360b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011360f:	74 04                	je     f0113615 <test_copy_paste_chunk+0xe68>
f0113611:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113615:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011361c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113620:	0f 84 9e 00 00 00    	je     f01136c4 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113626:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f011362d:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113634:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f011363b:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113642:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113649:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113650:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113653:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113656:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113659:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f011365c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011365f:	8a 00                	mov    (%eax),%al
f0113661:	3c 61                	cmp    $0x61,%al
f0113663:	75 2d                	jne    f0113692 <test_copy_paste_chunk+0xee5>
f0113665:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113668:	8a 00                	mov    (%eax),%al
f011366a:	3c 61                	cmp    $0x61,%al
f011366c:	75 24                	jne    f0113692 <test_copy_paste_chunk+0xee5>
f011366e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113671:	8a 00                	mov    (%eax),%al
f0113673:	3c 79                	cmp    $0x79,%al
f0113675:	75 1b                	jne    f0113692 <test_copy_paste_chunk+0xee5>
f0113677:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011367a:	8a 00                	mov    (%eax),%al
f011367c:	3c 62                	cmp    $0x62,%al
f011367e:	75 12                	jne    f0113692 <test_copy_paste_chunk+0xee5>
f0113680:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113683:	8a 00                	mov    (%eax),%al
f0113685:	3c 63                	cmp    $0x63,%al
f0113687:	75 09                	jne    f0113692 <test_copy_paste_chunk+0xee5>
f0113689:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011368c:	8a 00                	mov    (%eax),%al
f011368e:	3c 7a                	cmp    $0x7a,%al
f0113690:	74 21                	je     f01136b3 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113692:	83 ec 04             	sub    $0x4,%esp
f0113695:	68 38 93 12 f0       	push   $0xf0129338
f011369a:	68 b0 03 00 00       	push   $0x3b0
f011369f:	68 42 8b 12 f0       	push   $0xf0128b42
f01136a4:	e8 2d ce fe ff       	call   f01004d6 <_warn>
f01136a9:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01136ac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f01136b3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136b7:	74 04                	je     f01136bd <test_copy_paste_chunk+0xf10>
f01136b9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f01136bd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01136c4:	e8 fd ab ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01136c9:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f01136cc:	6a 00                	push   $0x0
f01136ce:	6a 02                	push   $0x2
f01136d0:	68 00 10 90 00       	push   $0x901000
f01136d5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136d8:	e8 b1 2b 00 00       	call   f011628e <SB>
f01136dd:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f01136e0:	6a 00                	push   $0x0
f01136e2:	6a 02                	push   $0x2
f01136e4:	68 00 20 90 00       	push   $0x902000
f01136e9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136ec:	e8 9d 2b 00 00       	call   f011628e <SB>
f01136f1:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f01136f4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01136f7:	c1 e0 03             	shl    $0x3,%eax
f01136fa:	50                   	push   %eax
f01136fb:	68 00 f0 bf 00       	push   $0xbff000
f0113700:	68 00 10 90 00       	push   $0x901000
f0113705:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113708:	e8 71 6d ff ff       	call   f010a47e <copy_paste_chunk>
f011370d:	83 c4 10             	add    $0x10,%esp
f0113710:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113716:	e8 ab ab ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011371b:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011371e:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113725:	75 0b                	jne    f0113732 <test_copy_paste_chunk+0xf85>
f0113727:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011372a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011372d:	83 f8 03             	cmp    $0x3,%eax
f0113730:	74 2e                	je     f0113760 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113732:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113735:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113738:	83 ec 0c             	sub    $0xc,%esp
f011373b:	50                   	push   %eax
f011373c:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113742:	68 e4 93 12 f0       	push   $0xf01293e4
f0113747:	68 c0 03 00 00       	push   $0x3c0
f011374c:	68 42 8b 12 f0       	push   $0xf0128b42
f0113751:	e8 80 cd fe ff       	call   f01004d6 <_warn>
f0113756:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113759:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113760:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113764:	74 04                	je     f011376a <test_copy_paste_chunk+0xfbd>
f0113766:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011376a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113771:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113778:	83 ec 08             	sub    $0x8,%esp
f011377b:	6a 01                	push   $0x1
f011377d:	6a 07                	push   $0x7
f011377f:	6a 03                	push   $0x3
f0113781:	6a 07                	push   $0x7
f0113783:	6a 03                	push   $0x3
f0113785:	6a 01                	push   $0x1
f0113787:	68 00 20 00 00       	push   $0x2000
f011378c:	68 00 f0 bf 00       	push   $0xbff000
f0113791:	68 00 10 90 00       	push   $0x901000
f0113796:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113799:	e8 63 2c 00 00       	call   f0116401 <CCP>
f011379e:	83 c4 30             	add    $0x30,%esp
f01137a1:	83 f8 01             	cmp    $0x1,%eax
f01137a4:	74 28                	je     f01137ce <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01137a6:	83 ec 04             	sub    $0x4,%esp
f01137a9:	68 84 94 12 f0       	push   $0xf0129484
f01137ae:	68 c9 03 00 00       	push   $0x3c9
f01137b3:	68 42 8b 12 f0       	push   $0xf0128b42
f01137b8:	e8 19 cd fe ff       	call   f01004d6 <_warn>
f01137bd:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01137c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01137c7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f01137ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137d2:	74 04                	je     f01137d8 <test_copy_paste_chunk+0x102b>
f01137d4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01137d8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01137df:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01137e3:	74 72                	je     f0113857 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f01137e5:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f01137ec:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f01137f3:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f01137fa:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113801:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113804:	8a 00                	mov    (%eax),%al
f0113806:	3c 62                	cmp    $0x62,%al
f0113808:	75 1b                	jne    f0113825 <test_copy_paste_chunk+0x1078>
f011380a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011380d:	8a 00                	mov    (%eax),%al
f011380f:	3c 62                	cmp    $0x62,%al
f0113811:	75 12                	jne    f0113825 <test_copy_paste_chunk+0x1078>
f0113813:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113816:	8a 00                	mov    (%eax),%al
f0113818:	3c 7a                	cmp    $0x7a,%al
f011381a:	75 09                	jne    f0113825 <test_copy_paste_chunk+0x1078>
f011381c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011381f:	8a 00                	mov    (%eax),%al
f0113821:	3c 7a                	cmp    $0x7a,%al
f0113823:	74 21                	je     f0113846 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113825:	83 ec 04             	sub    $0x4,%esp
f0113828:	68 38 93 12 f0       	push   $0xf0129338
f011382d:	68 d5 03 00 00       	push   $0x3d5
f0113832:	68 42 8b 12 f0       	push   $0xf0128b42
f0113837:	e8 9a cc fe ff       	call   f01004d6 <_warn>
f011383c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011383f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113846:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011384a:	74 04                	je     f0113850 <test_copy_paste_chunk+0x10a3>
f011384c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113850:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113857:	83 ec 0c             	sub    $0xc,%esp
f011385a:	68 32 95 12 f0       	push   $0xf0129532
f011385f:	e8 27 d7 fe ff       	call   f0100f8b <cprintf>
f0113864:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113867:	83 ec 08             	sub    $0x8,%esp
f011386a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011386d:	68 44 95 12 f0       	push   $0xf0129544
f0113872:	e8 14 d7 fe ff       	call   f0100f8b <cprintf>
f0113877:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011387a:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011387e:	75 10                	jne    f0113890 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113880:	83 ec 0c             	sub    $0xc,%esp
f0113883:	68 78 95 12 f0       	push   $0xf0129578
f0113888:	e8 fe d6 fe ff       	call   f0100f8b <cprintf>
f011388d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113890:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0113895:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113898:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011389b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011389e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01138a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01138a6:	5b                   	pop    %ebx
f01138a7:	5e                   	pop    %esi
f01138a8:	5f                   	pop    %edi
f01138a9:	5d                   	pop    %ebp
f01138aa:	c3                   	ret    

f01138ab <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f01138ab:	55                   	push   %ebp
f01138ac:	89 e5                	mov    %esp,%ebp
f01138ae:	57                   	push   %edi
f01138af:	56                   	push   %esi
f01138b0:	53                   	push   %ebx
f01138b1:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01138b7:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01138bd:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f01138c2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138c7:	89 c7                	mov    %eax,%edi
f01138c9:	89 de                	mov    %ebx,%esi
f01138cb:	89 d1                	mov    %edx,%ecx
f01138cd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138cf:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f01138d5:	b9 23 00 00 00       	mov    $0x23,%ecx
f01138da:	b0 00                	mov    $0x0,%al
f01138dc:	89 d7                	mov    %edx,%edi
f01138de:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01138e0:	6a 00                	push   $0x0
f01138e2:	6a 0a                	push   $0xa
f01138e4:	6a 14                	push   $0x14
f01138e6:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01138ec:	50                   	push   %eax
f01138ed:	e8 33 70 ff ff       	call   f010a925 <env_create>
f01138f2:	83 c4 10             	add    $0x10,%esp
f01138f5:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01138f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01138fb:	8b 40 64             	mov    0x64(%eax),%eax
f01138fe:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113901:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113904:	8b 40 68             	mov    0x68(%eax),%eax
f0113907:	89 45 80             	mov    %eax,-0x80(%ebp)
f011390a:	8b 45 80             	mov    -0x80(%ebp),%eax
f011390d:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113910:	83 ec 0c             	sub    $0xc,%esp
f0113913:	ff 75 cc             	pushl  -0x34(%ebp)
f0113916:	e8 b2 2a 00 00       	call   f01163cd <ClearUserSpace>
f011391b:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011391e:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113925:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011392c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113933:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113937:	83 ec 0c             	sub    $0xc,%esp
f011393a:	68 f0 9d 12 f0       	push   $0xf0129df0
f011393f:	e8 47 d6 fe ff       	call   f0100f8b <cprintf>
f0113944:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113947:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f011394e:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113955:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113958:	8a 00                	mov    (%eax),%al
f011395a:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113960:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113963:	8a 00                	mov    (%eax),%al
f0113965:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011396b:	e8 56 a9 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113970:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113973:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113976:	89 d0                	mov    %edx,%eax
f0113978:	01 c0                	add    %eax,%eax
f011397a:	01 d0                	add    %edx,%eax
f011397c:	01 c0                	add    %eax,%eax
f011397e:	83 ec 0c             	sub    $0xc,%esp
f0113981:	6a 02                	push   $0x2
f0113983:	50                   	push   %eax
f0113984:	68 00 40 10 f0       	push   $0xf0104000
f0113989:	68 00 00 10 f0       	push   $0xf0100000
f011398e:	ff 75 cc             	pushl  -0x34(%ebp)
f0113991:	e8 02 6b ff ff       	call   f010a498 <share_chunk>
f0113996:	83 c4 20             	add    $0x20,%esp
f0113999:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011399c:	e8 25 a9 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01139a1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01139a4:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01139a8:	75 08                	jne    f01139b2 <test_share_chunk+0x107>
f01139aa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139ad:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01139b0:	74 28                	je     f01139da <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f01139b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139b5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01139b8:	83 ec 0c             	sub    $0xc,%esp
f01139bb:	50                   	push   %eax
f01139bc:	ff 75 b0             	pushl  -0x50(%ebp)
f01139bf:	68 1c 9e 12 f0       	push   $0xf0129e1c
f01139c4:	68 11 04 00 00       	push   $0x411
f01139c9:	68 42 8b 12 f0       	push   $0xf0128b42
f01139ce:	e8 03 cb fe ff       	call   f01004d6 <_warn>
f01139d3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01139d6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01139da:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01139de:	74 04                	je     f01139e4 <test_share_chunk+0x139>
f01139e0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139e4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f01139e8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01139eb:	c1 e0 03             	shl    $0x3,%eax
f01139ee:	83 ec 08             	sub    $0x8,%esp
f01139f1:	68 fd 00 00 00       	push   $0xfd
f01139f6:	6a 07                	push   $0x7
f01139f8:	6a 03                	push   $0x3
f01139fa:	6a 07                	push   $0x7
f01139fc:	6a 03                	push   $0x3
f01139fe:	6a 01                	push   $0x1
f0113a00:	50                   	push   %eax
f0113a01:	68 00 40 10 f0       	push   $0xf0104000
f0113a06:	68 00 00 10 f0       	push   $0xf0100000
f0113a0b:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a0e:	e8 ee 29 00 00       	call   f0116401 <CCP>
f0113a13:	83 c4 30             	add    $0x30,%esp
f0113a16:	85 c0                	test   %eax,%eax
f0113a18:	75 1e                	jne    f0113a38 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113a1a:	83 ec 04             	sub    $0x4,%esp
f0113a1d:	68 78 9e 12 f0       	push   $0xf0129e78
f0113a22:	68 19 04 00 00       	push   $0x419
f0113a27:	68 42 8b 12 f0       	push   $0xf0128b42
f0113a2c:	e8 a5 ca fe ff       	call   f01004d6 <_warn>
f0113a31:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a34:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113a38:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113a3c:	74 04                	je     f0113a42 <test_share_chunk+0x197>
f0113a3e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0113a42:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a45:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0113a48:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a4b:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0113a4e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a51:	8a 00                	mov    (%eax),%al
f0113a53:	3c 41                	cmp    $0x41,%al
f0113a55:	75 09                	jne    f0113a60 <test_share_chunk+0x1b5>
f0113a57:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a5a:	8a 00                	mov    (%eax),%al
f0113a5c:	3c 42                	cmp    $0x42,%al
f0113a5e:	74 1e                	je     f0113a7e <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113a60:	83 ec 04             	sub    $0x4,%esp
f0113a63:	68 c0 9e 12 f0       	push   $0xf0129ec0
f0113a68:	68 23 04 00 00       	push   $0x423
f0113a6d:	68 42 8b 12 f0       	push   $0xf0128b42
f0113a72:	e8 5f ca fe ff       	call   f01004d6 <_warn>
f0113a77:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a7a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113a7e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113a82:	74 04                	je     f0113a88 <test_share_chunk+0x1dd>
f0113a84:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113a88:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0113a8c:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113a92:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a95:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0113a97:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113a9d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113aa0:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113aa2:	83 ec 0c             	sub    $0xc,%esp
f0113aa5:	68 f5 9e 12 f0       	push   $0xf0129ef5
f0113aaa:	e8 dc d4 fe ff       	call   f0100f8b <cprintf>
f0113aaf:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113ab2:	83 ec 0c             	sub    $0xc,%esp
f0113ab5:	68 04 9f 12 f0       	push   $0xf0129f04
f0113aba:	e8 cc d4 fe ff       	call   f0100f8b <cprintf>
f0113abf:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ac2:	e8 ff a7 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113ac7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113aca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113acd:	c1 e0 05             	shl    $0x5,%eax
f0113ad0:	83 ec 0c             	sub    $0xc,%esp
f0113ad3:	68 02 0e 00 00       	push   $0xe02
f0113ad8:	50                   	push   %eax
f0113ad9:	68 00 00 00 40       	push   $0x40000000
f0113ade:	68 00 00 00 f0       	push   $0xf0000000
f0113ae3:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ae6:	e8 ad 69 ff ff       	call   f010a498 <share_chunk>
f0113aeb:	83 c4 20             	add    $0x20,%esp
f0113aee:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113af1:	e8 d0 a7 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113af6:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0113af9:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113afd:	75 1f                	jne    f0113b1e <test_share_chunk+0x273>
f0113aff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b02:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b05:	89 c1                	mov    %eax,%ecx
f0113b07:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b0a:	c1 e0 05             	shl    $0x5,%eax
f0113b0d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b10:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113b17:	99                   	cltd   
f0113b18:	f7 fb                	idiv   %ebx
f0113b1a:	39 c1                	cmp    %eax,%ecx
f0113b1c:	74 28                	je     f0113b46 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b1e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b21:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b24:	83 ec 0c             	sub    $0xc,%esp
f0113b27:	50                   	push   %eax
f0113b28:	ff 75 a8             	pushl  -0x58(%ebp)
f0113b2b:	68 40 9f 12 f0       	push   $0xf0129f40
f0113b30:	68 3b 04 00 00       	push   $0x43b
f0113b35:	68 42 8b 12 f0       	push   $0xf0128b42
f0113b3a:	e8 97 c9 fe ff       	call   f01004d6 <_warn>
f0113b3f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b42:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113b46:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113b4a:	74 04                	je     f0113b50 <test_share_chunk+0x2a5>
f0113b4c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b50:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113b54:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113b5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b5e:	c1 e0 05             	shl    $0x5,%eax
f0113b61:	83 ec 08             	sub    $0x8,%esp
f0113b64:	6a 02                	push   $0x2
f0113b66:	6a 07                	push   $0x7
f0113b68:	6a 03                	push   $0x3
f0113b6a:	68 07 0e 00 00       	push   $0xe07
f0113b6f:	68 03 0e 00 00       	push   $0xe03
f0113b74:	6a ff                	push   $0xffffffff
f0113b76:	50                   	push   %eax
f0113b77:	68 00 00 00 40       	push   $0x40000000
f0113b7c:	68 00 00 00 f0       	push   $0xf0000000
f0113b81:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b84:	e8 78 28 00 00       	call   f0116401 <CCP>
f0113b89:	83 c4 30             	add    $0x30,%esp
f0113b8c:	85 c0                	test   %eax,%eax
f0113b8e:	75 25                	jne    f0113bb5 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113b90:	83 ec 04             	sub    $0x4,%esp
f0113b93:	68 78 9e 12 f0       	push   $0xf0129e78
f0113b98:	68 44 04 00 00       	push   $0x444
f0113b9d:	68 42 8b 12 f0       	push   $0xf0128b42
f0113ba2:	e8 2f c9 fe ff       	call   f01004d6 <_warn>
f0113ba7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113baa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113bae:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113bb5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113bb8:	89 d0                	mov    %edx,%eax
f0113bba:	01 c0                	add    %eax,%eax
f0113bbc:	01 d0                	add    %edx,%eax
f0113bbe:	c1 e0 02             	shl    $0x2,%eax
f0113bc1:	83 ec 08             	sub    $0x8,%esp
f0113bc4:	6a 02                	push   $0x2
f0113bc6:	6a 07                	push   $0x7
f0113bc8:	6a 03                	push   $0x3
f0113bca:	68 07 0e 00 00       	push   $0xe07
f0113bcf:	68 03 0e 00 00       	push   $0xe03
f0113bd4:	6a 02                	push   $0x2
f0113bd6:	50                   	push   %eax
f0113bd7:	68 00 00 00 40       	push   $0x40000000
f0113bdc:	68 00 00 00 f0       	push   $0xf0000000
f0113be1:	ff 75 cc             	pushl  -0x34(%ebp)
f0113be4:	e8 18 28 00 00       	call   f0116401 <CCP>
f0113be9:	83 c4 30             	add    $0x30,%esp
f0113bec:	85 c0                	test   %eax,%eax
f0113bee:	75 1e                	jne    f0113c0e <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113bf0:	83 ec 04             	sub    $0x4,%esp
f0113bf3:	68 78 9e 12 f0       	push   $0xf0129e78
f0113bf8:	68 4b 04 00 00       	push   $0x44b
f0113bfd:	68 42 8b 12 f0       	push   $0xf0128b42
f0113c02:	e8 cf c8 fe ff       	call   f01004d6 <_warn>
f0113c07:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c0a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113c0e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113c12:	74 04                	je     f0113c18 <test_share_chunk+0x36d>
f0113c14:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c18:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113c1c:	b8 90 84 b0 f0       	mov    $0xf0b08490,%eax
f0113c21:	05 00 00 00 10       	add    $0x10000000,%eax
f0113c26:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113c29:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113c2c:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0113c31:	83 ec 08             	sub    $0x8,%esp
f0113c34:	6a 02                	push   $0x2
f0113c36:	6a 07                	push   $0x7
f0113c38:	6a 03                	push   $0x3
f0113c3a:	68 07 0e 00 00       	push   $0xe07
f0113c3f:	68 03 0e 00 00       	push   $0xe03
f0113c44:	6a 02                	push   $0x2
f0113c46:	50                   	push   %eax
f0113c47:	68 00 00 0a 40       	push   $0x400a0000
f0113c4c:	68 00 00 0a f0       	push   $0xf00a0000
f0113c51:	ff 75 cc             	pushl  -0x34(%ebp)
f0113c54:	e8 a8 27 00 00       	call   f0116401 <CCP>
f0113c59:	83 c4 30             	add    $0x30,%esp
f0113c5c:	85 c0                	test   %eax,%eax
f0113c5e:	75 1e                	jne    f0113c7e <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113c60:	83 ec 04             	sub    $0x4,%esp
f0113c63:	68 78 9e 12 f0       	push   $0xf0129e78
f0113c68:	68 55 04 00 00       	push   $0x455
f0113c6d:	68 42 8b 12 f0       	push   $0xf0128b42
f0113c72:	e8 5f c8 fe ff       	call   f01004d6 <_warn>
f0113c77:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c7a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113c7e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113c82:	74 04                	je     f0113c88 <test_share_chunk+0x3dd>
f0113c84:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c88:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113c8c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113c90:	0f 84 a4 00 00 00    	je     f0113d3a <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0113c96:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0113c9d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113ca0:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0113ca3:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0113caa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cad:	8a 00                	mov    (%eax),%al
f0113caf:	3c 41                	cmp    $0x41,%al
f0113cb1:	75 09                	jne    f0113cbc <test_share_chunk+0x411>
f0113cb3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113cb6:	8a 00                	mov    (%eax),%al
f0113cb8:	3c 41                	cmp    $0x41,%al
f0113cba:	74 1e                	je     f0113cda <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113cbc:	83 ec 04             	sub    $0x4,%esp
f0113cbf:	68 c0 9e 12 f0       	push   $0xf0129ec0
f0113cc4:	68 62 04 00 00       	push   $0x462
f0113cc9:	68 42 8b 12 f0       	push   $0xf0128b42
f0113cce:	e8 03 c8 fe ff       	call   f01004d6 <_warn>
f0113cd3:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113cd6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113cda:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113cde:	74 04                	je     f0113ce4 <test_share_chunk+0x439>
f0113ce0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113ce4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0113ce8:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0113cef:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cf2:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0113cf5:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0113cfc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cff:	8a 00                	mov    (%eax),%al
f0113d01:	3c 43                	cmp    $0x43,%al
f0113d03:	75 09                	jne    f0113d0e <test_share_chunk+0x463>
f0113d05:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d08:	8a 00                	mov    (%eax),%al
f0113d0a:	3c 43                	cmp    $0x43,%al
f0113d0c:	74 1e                	je     f0113d2c <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113d0e:	83 ec 04             	sub    $0x4,%esp
f0113d11:	68 c0 9e 12 f0       	push   $0xf0129ec0
f0113d16:	68 6d 04 00 00       	push   $0x46d
f0113d1b:	68 42 8b 12 f0       	push   $0xf0128b42
f0113d20:	e8 b1 c7 fe ff       	call   f01004d6 <_warn>
f0113d25:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113d28:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113d2c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113d30:	74 04                	je     f0113d36 <test_share_chunk+0x48b>
f0113d32:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113d36:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113d3a:	83 ec 0c             	sub    $0xc,%esp
f0113d3d:	68 cf 94 12 f0       	push   $0xf01294cf
f0113d42:	e8 44 d2 fe ff       	call   f0100f8b <cprintf>
f0113d47:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0113d4a:	83 ec 0c             	sub    $0xc,%esp
f0113d4d:	68 90 9f 12 f0       	push   $0xf0129f90
f0113d52:	e8 34 d2 fe ff       	call   f0100f8b <cprintf>
f0113d57:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113d5a:	e8 67 a5 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113d5f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0113d62:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d65:	89 d0                	mov    %edx,%eax
f0113d67:	c1 e0 03             	shl    $0x3,%eax
f0113d6a:	01 d0                	add    %edx,%eax
f0113d6c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0113d73:	01 d0                	add    %edx,%eax
f0113d75:	c1 e0 03             	shl    $0x3,%eax
f0113d78:	83 ec 0c             	sub    $0xc,%esp
f0113d7b:	6a 06                	push   $0x6
f0113d7d:	50                   	push   %eax
f0113d7e:	6a 00                	push   $0x0
f0113d80:	68 00 00 00 40       	push   $0x40000000
f0113d85:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d88:	e8 0b 67 ff ff       	call   f010a498 <share_chunk>
f0113d8d:	83 c4 20             	add    $0x20,%esp
f0113d90:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d93:	e8 2e a5 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0113d98:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113d9b:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0113d9f:	75 0b                	jne    f0113dac <test_share_chunk+0x501>
f0113da1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113da4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113da7:	83 f8 01             	cmp    $0x1,%eax
f0113daa:	74 28                	je     f0113dd4 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113dac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113daf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113db2:	83 ec 0c             	sub    $0xc,%esp
f0113db5:	50                   	push   %eax
f0113db6:	ff 75 a0             	pushl  -0x60(%ebp)
f0113db9:	68 40 9f 12 f0       	push   $0xf0129f40
f0113dbe:	68 83 04 00 00       	push   $0x483
f0113dc3:	68 42 8b 12 f0       	push   $0xf0128b42
f0113dc8:	e8 09 c7 fe ff       	call   f01004d6 <_warn>
f0113dcd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113dd0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113dd4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113dd8:	74 04                	je     f0113dde <test_share_chunk+0x533>
f0113dda:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113dde:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113de2:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113de9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dec:	05 00 80 02 00       	add    $0x28000,%eax
f0113df1:	c1 e0 02             	shl    $0x2,%eax
f0113df4:	83 ec 08             	sub    $0x8,%esp
f0113df7:	6a 02                	push   $0x2
f0113df9:	6a 07                	push   $0x7
f0113dfb:	6a 03                	push   $0x3
f0113dfd:	6a 07                	push   $0x7
f0113dff:	6a 07                	push   $0x7
f0113e01:	6a ff                	push   $0xffffffff
f0113e03:	50                   	push   %eax
f0113e04:	6a 00                	push   $0x0
f0113e06:	68 00 00 00 40       	push   $0x40000000
f0113e0b:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e0e:	e8 ee 25 00 00       	call   f0116401 <CCP>
f0113e13:	83 c4 30             	add    $0x30,%esp
f0113e16:	85 c0                	test   %eax,%eax
f0113e18:	75 25                	jne    f0113e3f <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113e1a:	83 ec 04             	sub    $0x4,%esp
f0113e1d:	68 78 9e 12 f0       	push   $0xf0129e78
f0113e22:	68 8c 04 00 00       	push   $0x48c
f0113e27:	68 42 8b 12 f0       	push   $0xf0128b42
f0113e2c:	e8 a5 c6 fe ff       	call   f01004d6 <_warn>
f0113e31:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e34:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113e38:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113e3f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e42:	89 d0                	mov    %edx,%eax
f0113e44:	01 c0                	add    %eax,%eax
f0113e46:	01 d0                	add    %edx,%eax
f0113e48:	c1 e0 02             	shl    $0x2,%eax
f0113e4b:	83 ec 08             	sub    $0x8,%esp
f0113e4e:	6a 02                	push   $0x2
f0113e50:	6a 07                	push   $0x7
f0113e52:	6a 03                	push   $0x3
f0113e54:	6a 07                	push   $0x7
f0113e56:	6a 07                	push   $0x7
f0113e58:	6a 03                	push   $0x3
f0113e5a:	50                   	push   %eax
f0113e5b:	6a 00                	push   $0x0
f0113e5d:	68 00 00 00 40       	push   $0x40000000
f0113e62:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e65:	e8 97 25 00 00       	call   f0116401 <CCP>
f0113e6a:	83 c4 30             	add    $0x30,%esp
f0113e6d:	85 c0                	test   %eax,%eax
f0113e6f:	75 1e                	jne    f0113e8f <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113e71:	83 ec 04             	sub    $0x4,%esp
f0113e74:	68 78 9e 12 f0       	push   $0xf0129e78
f0113e79:	68 93 04 00 00       	push   $0x493
f0113e7e:	68 42 8b 12 f0       	push   $0xf0128b42
f0113e83:	e8 4e c6 fe ff       	call   f01004d6 <_warn>
f0113e88:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e8b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113e8f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e93:	74 04                	je     f0113e99 <test_share_chunk+0x5ee>
f0113e95:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e99:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113e9d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113ea0:	89 d0                	mov    %edx,%eax
f0113ea2:	01 c0                	add    %eax,%eax
f0113ea4:	01 d0                	add    %edx,%eax
f0113ea6:	c1 e0 02             	shl    $0x2,%eax
f0113ea9:	f7 d8                	neg    %eax
f0113eab:	05 00 00 0a 00       	add    $0xa0000,%eax
f0113eb0:	83 ec 08             	sub    $0x8,%esp
f0113eb3:	6a 02                	push   $0x2
f0113eb5:	6a 07                	push   $0x7
f0113eb7:	6a 03                	push   $0x3
f0113eb9:	6a 07                	push   $0x7
f0113ebb:	6a 07                	push   $0x7
f0113ebd:	6a 02                	push   $0x2
f0113ebf:	50                   	push   %eax
f0113ec0:	68 00 30 00 00       	push   $0x3000
f0113ec5:	68 00 30 00 40       	push   $0x40003000
f0113eca:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ecd:	e8 2f 25 00 00       	call   f0116401 <CCP>
f0113ed2:	83 c4 30             	add    $0x30,%esp
f0113ed5:	85 c0                	test   %eax,%eax
f0113ed7:	75 1e                	jne    f0113ef7 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113ed9:	83 ec 04             	sub    $0x4,%esp
f0113edc:	68 78 9e 12 f0       	push   $0xf0129e78
f0113ee1:	68 9b 04 00 00       	push   $0x49b
f0113ee6:	68 42 8b 12 f0       	push   $0xf0128b42
f0113eeb:	e8 e6 c5 fe ff       	call   f01004d6 <_warn>
f0113ef0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ef3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113ef7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113efb:	74 04                	je     f0113f01 <test_share_chunk+0x656>
f0113efd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f01:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113f05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113f08:	c1 e0 02             	shl    $0x2,%eax
f0113f0b:	83 ec 08             	sub    $0x8,%esp
f0113f0e:	6a 02                	push   $0x2
f0113f10:	6a 07                	push   $0x7
f0113f12:	6a 03                	push   $0x3
f0113f14:	6a 07                	push   $0x7
f0113f16:	6a 07                	push   $0x7
f0113f18:	6a 03                	push   $0x3
f0113f1a:	50                   	push   %eax
f0113f1b:	68 00 00 0a 00       	push   $0xa0000
f0113f20:	68 00 00 0a 40       	push   $0x400a0000
f0113f25:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f28:	e8 d4 24 00 00       	call   f0116401 <CCP>
f0113f2d:	83 c4 30             	add    $0x30,%esp
f0113f30:	85 c0                	test   %eax,%eax
f0113f32:	75 1e                	jne    f0113f52 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113f34:	83 ec 04             	sub    $0x4,%esp
f0113f37:	68 78 9e 12 f0       	push   $0xf0129e78
f0113f3c:	68 a3 04 00 00       	push   $0x4a3
f0113f41:	68 42 8b 12 f0       	push   $0xf0128b42
f0113f46:	e8 8b c5 fe ff       	call   f01004d6 <_warn>
f0113f4b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f4e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f52:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f56:	74 04                	je     f0113f5c <test_share_chunk+0x6b1>
f0113f58:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f5c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113f60:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113f64:	0f 84 92 00 00 00    	je     f0113ffc <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0113f6a:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0113f71:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0113f78:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0113f7f:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0113f86:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113f89:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0113f8c:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0113f93:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113f9a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f9d:	8a 00                	mov    (%eax),%al
f0113f9f:	3c 41                	cmp    $0x41,%al
f0113fa1:	75 2d                	jne    f0113fd0 <test_share_chunk+0x725>
f0113fa3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113fa6:	8a 00                	mov    (%eax),%al
f0113fa8:	3c 41                	cmp    $0x41,%al
f0113faa:	75 24                	jne    f0113fd0 <test_share_chunk+0x725>
f0113fac:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113faf:	8a 00                	mov    (%eax),%al
f0113fb1:	3c 41                	cmp    $0x41,%al
f0113fb3:	75 1b                	jne    f0113fd0 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113fb5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113fb8:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113fba:	3c 44                	cmp    $0x44,%al
f0113fbc:	75 12                	jne    f0113fd0 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113fbe:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113fc1:	8a 00                	mov    (%eax),%al
f0113fc3:	3c 44                	cmp    $0x44,%al
f0113fc5:	75 09                	jne    f0113fd0 <test_share_chunk+0x725>
f0113fc7:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113fca:	8a 00                	mov    (%eax),%al
f0113fcc:	3c 44                	cmp    $0x44,%al
f0113fce:	74 1e                	je     f0113fee <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113fd0:	83 ec 04             	sub    $0x4,%esp
f0113fd3:	68 c0 9e 12 f0       	push   $0xf0129ec0
f0113fd8:	68 b5 04 00 00       	push   $0x4b5
f0113fdd:	68 42 8b 12 f0       	push   $0xf0128b42
f0113fe2:	e8 ef c4 fe ff       	call   f01004d6 <_warn>
f0113fe7:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113fea:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113fee:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ff2:	74 04                	je     f0113ff8 <test_share_chunk+0x74d>
f0113ff4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113ff8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113ffc:	83 ec 0c             	sub    $0xc,%esp
f0113fff:	68 32 95 12 f0       	push   $0xf0129532
f0114004:	e8 82 cf fe ff       	call   f0100f8b <cprintf>
f0114009:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f011400c:	83 ec 0c             	sub    $0xc,%esp
f011400f:	68 cc 9f 12 f0       	push   $0xf0129fcc
f0114014:	e8 72 cf fe ff       	call   f0100f8b <cprintf>
f0114019:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011401c:	e8 a5 a2 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114021:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114024:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114027:	89 d0                	mov    %edx,%eax
f0114029:	01 c0                	add    %eax,%eax
f011402b:	01 d0                	add    %edx,%eax
f011402d:	01 c0                	add    %eax,%eax
f011402f:	01 d0                	add    %edx,%eax
f0114031:	83 ec 0c             	sub    $0xc,%esp
f0114034:	6a 04                	push   $0x4
f0114036:	50                   	push   %eax
f0114037:	68 00 fc 3f 00       	push   $0x3ffc00
f011403c:	68 00 fc 09 00       	push   $0x9fc00
f0114041:	ff 75 cc             	pushl  -0x34(%ebp)
f0114044:	e8 4f 64 ff ff       	call   f010a498 <share_chunk>
f0114049:	83 c4 20             	add    $0x20,%esp
f011404c:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011404f:	e8 72 a2 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114054:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114057:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011405b:	75 0b                	jne    f0114068 <test_share_chunk+0x7bd>
f011405d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114060:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114063:	83 f8 01             	cmp    $0x1,%eax
f0114066:	74 28                	je     f0114090 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114068:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011406b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011406e:	83 ec 0c             	sub    $0xc,%esp
f0114071:	50                   	push   %eax
f0114072:	ff 75 8c             	pushl  -0x74(%ebp)
f0114075:	68 40 9f 12 f0       	push   $0xf0129f40
f011407a:	68 cb 04 00 00       	push   $0x4cb
f011407f:	68 42 8b 12 f0       	push   $0xf0128b42
f0114084:	e8 4d c4 fe ff       	call   f01004d6 <_warn>
f0114089:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011408c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114090:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114094:	74 04                	je     f011409a <test_share_chunk+0x7ef>
f0114096:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011409a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011409e:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01140a5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01140a8:	89 d0                	mov    %edx,%eax
f01140aa:	01 c0                	add    %eax,%eax
f01140ac:	01 d0                	add    %edx,%eax
f01140ae:	c1 e0 02             	shl    $0x2,%eax
f01140b1:	83 ec 08             	sub    $0x8,%esp
f01140b4:	6a 02                	push   $0x2
f01140b6:	6a 07                	push   $0x7
f01140b8:	6a 07                	push   $0x7
f01140ba:	6a 07                	push   $0x7
f01140bc:	6a 05                	push   $0x5
f01140be:	6a ff                	push   $0xffffffff
f01140c0:	50                   	push   %eax
f01140c1:	68 00 f0 3f 00       	push   $0x3ff000
f01140c6:	68 00 f0 09 00       	push   $0x9f000
f01140cb:	ff 75 cc             	pushl  -0x34(%ebp)
f01140ce:	e8 2e 23 00 00       	call   f0116401 <CCP>
f01140d3:	83 c4 30             	add    $0x30,%esp
f01140d6:	85 c0                	test   %eax,%eax
f01140d8:	75 25                	jne    f01140ff <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01140da:	83 ec 04             	sub    $0x4,%esp
f01140dd:	68 78 9e 12 f0       	push   $0xf0129e78
f01140e2:	68 d4 04 00 00       	push   $0x4d4
f01140e7:	68 42 8b 12 f0       	push   $0xf0128b42
f01140ec:	e8 e5 c3 fe ff       	call   f01004d6 <_warn>
f01140f1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140f4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01140f8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01140ff:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114103:	74 04                	je     f0114109 <test_share_chunk+0x85e>
f0114105:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114109:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011410d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114110:	c1 e0 02             	shl    $0x2,%eax
f0114113:	83 ec 08             	sub    $0x8,%esp
f0114116:	6a 02                	push   $0x2
f0114118:	6a 07                	push   $0x7
f011411a:	6a 07                	push   $0x7
f011411c:	6a 07                	push   $0x7
f011411e:	6a 05                	push   $0x5
f0114120:	6a 03                	push   $0x3
f0114122:	50                   	push   %eax
f0114123:	68 00 f0 3f 00       	push   $0x3ff000
f0114128:	68 00 f0 09 00       	push   $0x9f000
f011412d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114130:	e8 cc 22 00 00       	call   f0116401 <CCP>
f0114135:	83 c4 30             	add    $0x30,%esp
f0114138:	85 c0                	test   %eax,%eax
f011413a:	75 1e                	jne    f011415a <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011413c:	83 ec 04             	sub    $0x4,%esp
f011413f:	68 78 9e 12 f0       	push   $0xf0129e78
f0114144:	68 dd 04 00 00       	push   $0x4dd
f0114149:	68 42 8b 12 f0       	push   $0xf0128b42
f011414e:	e8 83 c3 fe ff       	call   f01004d6 <_warn>
f0114153:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114156:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011415a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011415e:	74 04                	je     f0114164 <test_share_chunk+0x8b9>
f0114160:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114164:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114168:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011416b:	c1 e0 03             	shl    $0x3,%eax
f011416e:	83 ec 08             	sub    $0x8,%esp
f0114171:	6a 02                	push   $0x2
f0114173:	6a 07                	push   $0x7
f0114175:	6a 07                	push   $0x7
f0114177:	6a 07                	push   $0x7
f0114179:	6a 05                	push   $0x5
f011417b:	6a 04                	push   $0x4
f011417d:	50                   	push   %eax
f011417e:	68 00 00 40 00       	push   $0x400000
f0114183:	68 00 00 0a 00       	push   $0xa0000
f0114188:	ff 75 cc             	pushl  -0x34(%ebp)
f011418b:	e8 71 22 00 00       	call   f0116401 <CCP>
f0114190:	83 c4 30             	add    $0x30,%esp
f0114193:	85 c0                	test   %eax,%eax
f0114195:	75 1e                	jne    f01141b5 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114197:	83 ec 04             	sub    $0x4,%esp
f011419a:	68 78 9e 12 f0       	push   $0xf0129e78
f011419f:	68 e5 04 00 00       	push   $0x4e5
f01141a4:	68 42 8b 12 f0       	push   $0xf0128b42
f01141a9:	e8 28 c3 fe ff       	call   f01004d6 <_warn>
f01141ae:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01141b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01141b5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141b9:	74 04                	je     f01141bf <test_share_chunk+0x914>
f01141bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01141bf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01141c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01141c7:	0f 84 b2 00 00 00    	je     f011427f <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01141cd:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01141d4:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01141db:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01141e2:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01141e9:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01141f0:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01141f7:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01141fe:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114205:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114208:	8a 00                	mov    (%eax),%al
f011420a:	3c 44                	cmp    $0x44,%al
f011420c:	75 45                	jne    f0114253 <test_share_chunk+0x9a8>
f011420e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114211:	8a 00                	mov    (%eax),%al
f0114213:	3c 44                	cmp    $0x44,%al
f0114215:	75 3c                	jne    f0114253 <test_share_chunk+0x9a8>
f0114217:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011421a:	8a 00                	mov    (%eax),%al
f011421c:	3c 44                	cmp    $0x44,%al
f011421e:	75 33                	jne    f0114253 <test_share_chunk+0x9a8>
f0114220:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114223:	8a 00                	mov    (%eax),%al
f0114225:	3c 44                	cmp    $0x44,%al
f0114227:	75 2a                	jne    f0114253 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114229:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011422c:	8a 10                	mov    (%eax),%dl
f011422e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114231:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114233:	38 c2                	cmp    %al,%dl
f0114235:	75 1c                	jne    f0114253 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114237:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011423a:	8a 10                	mov    (%eax),%dl
f011423c:	8b 45 88             	mov    -0x78(%ebp),%eax
f011423f:	8a 00                	mov    (%eax),%al
f0114241:	38 c2                	cmp    %al,%dl
f0114243:	75 0e                	jne    f0114253 <test_share_chunk+0x9a8>
f0114245:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114248:	8a 10                	mov    (%eax),%dl
f011424a:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011424d:	8a 00                	mov    (%eax),%al
f011424f:	38 c2                	cmp    %al,%dl
f0114251:	74 1e                	je     f0114271 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114253:	83 ec 04             	sub    $0x4,%esp
f0114256:	68 c0 9e 12 f0       	push   $0xf0129ec0
f011425b:	68 fa 04 00 00       	push   $0x4fa
f0114260:	68 42 8b 12 f0       	push   $0xf0128b42
f0114265:	e8 6c c2 fe ff       	call   f01004d6 <_warn>
f011426a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011426d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114271:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114275:	74 04                	je     f011427b <test_share_chunk+0x9d0>
f0114277:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011427b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f011427f:	83 ec 0c             	sub    $0xc,%esp
f0114282:	68 04 a0 12 f0       	push   $0xf012a004
f0114287:	e8 ff cc fe ff       	call   f0100f8b <cprintf>
f011428c:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f011428f:	83 ec 08             	sub    $0x8,%esp
f0114292:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114295:	68 14 a0 12 f0       	push   $0xf012a014
f011429a:	e8 ec cc fe ff       	call   f0100f8b <cprintf>
f011429f:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01142a2:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01142a6:	75 10                	jne    f01142b8 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01142a8:	83 ec 0c             	sub    $0xc,%esp
f01142ab:	68 44 a0 12 f0       	push   $0xf012a044
f01142b0:	e8 d6 cc fe ff       	call   f0100f8b <cprintf>
f01142b5:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01142b8:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f01142bd:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01142c0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01142c3:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01142c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01142cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01142ce:	5b                   	pop    %ebx
f01142cf:	5e                   	pop    %esi
f01142d0:	5f                   	pop    %edi
f01142d1:	5d                   	pop    %ebp
f01142d2:	c3                   	ret    

f01142d3 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01142d3:	55                   	push   %ebp
f01142d4:	89 e5                	mov    %esp,%ebp
f01142d6:	57                   	push   %edi
f01142d7:	56                   	push   %esi
f01142d8:	53                   	push   %ebx
f01142d9:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01142df:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01142e5:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f01142ea:	ba 0f 00 00 00       	mov    $0xf,%edx
f01142ef:	89 c7                	mov    %eax,%edi
f01142f1:	89 de                	mov    %ebx,%esi
f01142f3:	89 d1                	mov    %edx,%ecx
f01142f5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01142f7:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01142fd:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114302:	b0 00                	mov    $0x0,%al
f0114304:	89 d7                	mov    %edx,%edi
f0114306:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114308:	6a 00                	push   $0x0
f011430a:	6a 0a                	push   $0xa
f011430c:	6a 14                	push   $0x14
f011430e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114314:	50                   	push   %eax
f0114315:	e8 0b 66 ff ff       	call   f010a925 <env_create>
f011431a:	83 c4 10             	add    $0x10,%esp
f011431d:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114320:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114323:	8b 40 64             	mov    0x64(%eax),%eax
f0114326:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114329:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011432c:	8b 40 68             	mov    0x68(%eax),%eax
f011432f:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114332:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114335:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114338:	83 ec 0c             	sub    $0xc,%esp
f011433b:	ff 75 cc             	pushl  -0x34(%ebp)
f011433e:	e8 8a 20 00 00       	call   f01163cd <ClearUserSpace>
f0114343:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114346:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011434d:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114354:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011435b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f011435f:	83 ec 0c             	sub    $0xc,%esp
f0114362:	68 80 a0 12 f0       	push   $0xf012a080
f0114367:	e8 1f cc fe ff       	call   f0100f8b <cprintf>
f011436c:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f011436f:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114376:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011437d:	eb 03                	jmp    f0114382 <test_allocate_chunk+0xaf>
f011437f:	ff 4d e4             	decl   -0x1c(%ebp)
f0114382:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114389:	76 09                	jbe    f0114394 <test_allocate_chunk+0xc1>
f011438b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011438e:	8a 00                	mov    (%eax),%al
f0114390:	84 c0                	test   %al,%al
f0114392:	74 eb                	je     f011437f <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114394:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011439b:	75 06                	jne    f01143a3 <test_allocate_chunk+0xd0>
f011439d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01143a0:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01143a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01143a6:	8a 00                	mov    (%eax),%al
f01143a8:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01143ae:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143b1:	8a 00                	mov    (%eax),%al
f01143b3:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01143b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01143bc:	8a 00                	mov    (%eax),%al
f01143be:	0f be c0             	movsbl %al,%eax
f01143c1:	83 ec 08             	sub    $0x8,%esp
f01143c4:	50                   	push   %eax
f01143c5:	68 aa a0 12 f0       	push   $0xf012a0aa
f01143ca:	e8 bc cb fe ff       	call   f0100f8b <cprintf>
f01143cf:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01143d2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143d5:	8a 00                	mov    (%eax),%al
f01143d7:	0f be c0             	movsbl %al,%eax
f01143da:	83 ec 08             	sub    $0x8,%esp
f01143dd:	50                   	push   %eax
f01143de:	68 b6 a0 12 f0       	push   $0xf012a0b6
f01143e3:	e8 a3 cb fe ff       	call   f0100f8b <cprintf>
f01143e8:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01143eb:	83 ec 08             	sub    $0x8,%esp
f01143ee:	68 00 f0 bf ef       	push   $0xefbff000
f01143f3:	ff 75 cc             	pushl  -0x34(%ebp)
f01143f6:	e8 b3 1f 00 00       	call   f01163ae <GP>
f01143fb:	83 c4 10             	add    $0x10,%esp
f01143fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114401:	e8 c0 9e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114406:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114409:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011440c:	c1 e0 02             	shl    $0x2,%eax
f011440f:	6a 02                	push   $0x2
f0114411:	50                   	push   %eax
f0114412:	68 00 f0 bf ef       	push   $0xefbff000
f0114417:	ff 75 cc             	pushl  -0x34(%ebp)
f011441a:	e8 93 60 ff ff       	call   f010a4b2 <allocate_chunk>
f011441f:	83 c4 10             	add    $0x10,%esp
f0114422:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114425:	e8 9c 9e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011442a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011442d:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114431:	75 08                	jne    f011443b <test_allocate_chunk+0x168>
f0114433:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114436:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114439:	74 2a                	je     f0114465 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011443b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011443e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114441:	83 ec 08             	sub    $0x8,%esp
f0114444:	6a 00                	push   $0x0
f0114446:	50                   	push   %eax
f0114447:	ff 75 b0             	pushl  -0x50(%ebp)
f011444a:	68 c4 a0 12 f0       	push   $0xf012a0c4
f011444f:	68 3a 05 00 00       	push   $0x53a
f0114454:	68 42 8b 12 f0       	push   $0xf0128b42
f0114459:	e8 78 c0 fe ff       	call   f01004d6 <_warn>
f011445e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114461:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114465:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114469:	74 04                	je     f011446f <test_allocate_chunk+0x19c>
f011446b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011446f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114473:	e8 4e 9e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114478:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011447b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011447e:	01 c0                	add    %eax,%eax
f0114480:	89 c1                	mov    %eax,%ecx
f0114482:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114485:	89 d0                	mov    %edx,%eax
f0114487:	c1 e0 02             	shl    $0x2,%eax
f011448a:	01 d0                	add    %edx,%eax
f011448c:	f7 d8                	neg    %eax
f011448e:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114493:	6a 02                	push   $0x2
f0114495:	51                   	push   %ecx
f0114496:	50                   	push   %eax
f0114497:	ff 75 cc             	pushl  -0x34(%ebp)
f011449a:	e8 13 60 ff ff       	call   f010a4b2 <allocate_chunk>
f011449f:	83 c4 10             	add    $0x10,%esp
f01144a2:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01144a5:	e8 1c 9e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01144aa:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01144ad:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01144b1:	75 08                	jne    f01144bb <test_allocate_chunk+0x1e8>
f01144b3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01144b6:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01144b9:	74 2a                	je     f01144e5 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01144bb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01144be:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01144c1:	83 ec 08             	sub    $0x8,%esp
f01144c4:	6a 00                	push   $0x0
f01144c6:	50                   	push   %eax
f01144c7:	ff 75 b0             	pushl  -0x50(%ebp)
f01144ca:	68 c4 a0 12 f0       	push   $0xf012a0c4
f01144cf:	68 48 05 00 00       	push   $0x548
f01144d4:	68 42 8b 12 f0       	push   $0xf0128b42
f01144d9:	e8 f8 bf fe ff       	call   f01004d6 <_warn>
f01144de:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144e1:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01144e5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01144e9:	74 04                	je     f01144ef <test_allocate_chunk+0x21c>
f01144eb:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01144ef:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01144f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01144f6:	c1 e0 02             	shl    $0x2,%eax
f01144f9:	83 ec 08             	sub    $0x8,%esp
f01144fc:	6a 03                	push   $0x3
f01144fe:	6a 00                	push   $0x0
f0114500:	6a 00                	push   $0x0
f0114502:	68 ff 0f 00 00       	push   $0xfff
f0114507:	ff 75 b8             	pushl  -0x48(%ebp)
f011450a:	6a 01                	push   $0x1
f011450c:	50                   	push   %eax
f011450d:	68 00 f0 bf ef       	push   $0xefbff000
f0114512:	6a 00                	push   $0x0
f0114514:	ff 75 cc             	pushl  -0x34(%ebp)
f0114517:	e8 e5 1e 00 00       	call   f0116401 <CCP>
f011451c:	83 c4 30             	add    $0x30,%esp
f011451f:	85 c0                	test   %eax,%eax
f0114521:	75 1e                	jne    f0114541 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114523:	83 ec 04             	sub    $0x4,%esp
f0114526:	68 2c a1 12 f0       	push   $0xf012a12c
f011452b:	68 50 05 00 00       	push   $0x550
f0114530:	68 42 8b 12 f0       	push   $0xf0128b42
f0114535:	e8 9c bf fe ff       	call   f01004d6 <_warn>
f011453a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011453d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114541:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114545:	74 04                	je     f011454b <test_allocate_chunk+0x278>
f0114547:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011454b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f011454f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114552:	8a 10                	mov    (%eax),%dl
f0114554:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011455a:	38 c2                	cmp    %al,%dl
f011455c:	75 0f                	jne    f011456d <test_allocate_chunk+0x29a>
f011455e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114561:	8a 10                	mov    (%eax),%dl
f0114563:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114569:	38 c2                	cmp    %al,%dl
f011456b:	74 1e                	je     f011458b <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011456d:	83 ec 04             	sub    $0x4,%esp
f0114570:	68 78 a1 12 f0       	push   $0xf012a178
f0114575:	68 58 05 00 00       	push   $0x558
f011457a:	68 42 8b 12 f0       	push   $0xf0128b42
f011457f:	e8 52 bf fe ff       	call   f01004d6 <_warn>
f0114584:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114587:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011458b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011458f:	74 04                	je     f0114595 <test_allocate_chunk+0x2c2>
f0114591:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114595:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114599:	83 ec 0c             	sub    $0xc,%esp
f011459c:	68 f5 9e 12 f0       	push   $0xf0129ef5
f01145a1:	e8 e5 c9 fe ff       	call   f0100f8b <cprintf>
f01145a6:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f01145a9:	83 ec 0c             	sub    $0xc,%esp
f01145ac:	68 b0 a1 12 f0       	push   $0xf012a1b0
f01145b1:	e8 d5 c9 fe ff       	call   f0100f8b <cprintf>
f01145b6:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01145b9:	e8 08 9d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01145be:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01145c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145c4:	c1 e0 05             	shl    $0x5,%eax
f01145c7:	68 02 0e 00 00       	push   $0xe02
f01145cc:	50                   	push   %eax
f01145cd:	6a 00                	push   $0x0
f01145cf:	ff 75 cc             	pushl  -0x34(%ebp)
f01145d2:	e8 db 5e ff ff       	call   f010a4b2 <allocate_chunk>
f01145d7:	83 c4 10             	add    $0x10,%esp
f01145da:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01145dd:	e8 e4 9c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01145e2:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f01145e5:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01145e9:	75 36                	jne    f0114621 <test_allocate_chunk+0x34e>
f01145eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01145ee:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01145f1:	89 c1                	mov    %eax,%ecx
f01145f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145f6:	c1 e0 05             	shl    $0x5,%eax
f01145f9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01145fc:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114603:	99                   	cltd   
f0114604:	f7 fe                	idiv   %esi
f0114606:	89 c3                	mov    %eax,%ebx
f0114608:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011460b:	c1 e0 05             	shl    $0x5,%eax
f011460e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114611:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114618:	99                   	cltd   
f0114619:	f7 fe                	idiv   %esi
f011461b:	01 d8                	add    %ebx,%eax
f011461d:	39 c1                	cmp    %eax,%ecx
f011461f:	74 54                	je     f0114675 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114621:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114624:	c1 e0 05             	shl    $0x5,%eax
f0114627:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011462a:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114631:	99                   	cltd   
f0114632:	f7 ff                	idiv   %edi
f0114634:	89 c1                	mov    %eax,%ecx
f0114636:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114639:	c1 e0 05             	shl    $0x5,%eax
f011463c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011463f:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114646:	99                   	cltd   
f0114647:	f7 fe                	idiv   %esi
f0114649:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011464c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011464f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114652:	83 ec 08             	sub    $0x8,%esp
f0114655:	52                   	push   %edx
f0114656:	50                   	push   %eax
f0114657:	ff 75 a8             	pushl  -0x58(%ebp)
f011465a:	68 f0 a1 12 f0       	push   $0xf012a1f0
f011465f:	68 6d 05 00 00       	push   $0x56d
f0114664:	68 42 8b 12 f0       	push   $0xf0128b42
f0114669:	e8 68 be fe ff       	call   f01004d6 <_warn>
f011466e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114671:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114675:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114679:	74 04                	je     f011467f <test_allocate_chunk+0x3ac>
f011467b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011467f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114683:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011468a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011468d:	c1 e0 05             	shl    $0x5,%eax
f0114690:	83 ec 08             	sub    $0x8,%esp
f0114693:	6a 03                	push   $0x3
f0114695:	6a 00                	push   $0x0
f0114697:	6a 00                	push   $0x0
f0114699:	68 07 0e 00 00       	push   $0xe07
f011469e:	68 03 0e 00 00       	push   $0xe03
f01146a3:	6a 01                	push   $0x1
f01146a5:	50                   	push   %eax
f01146a6:	6a 00                	push   $0x0
f01146a8:	6a 00                	push   $0x0
f01146aa:	ff 75 cc             	pushl  -0x34(%ebp)
f01146ad:	e8 4f 1d 00 00       	call   f0116401 <CCP>
f01146b2:	83 c4 30             	add    $0x30,%esp
f01146b5:	85 c0                	test   %eax,%eax
f01146b7:	75 25                	jne    f01146de <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01146b9:	83 ec 04             	sub    $0x4,%esp
f01146bc:	68 2c a1 12 f0       	push   $0xf012a12c
f01146c1:	68 76 05 00 00       	push   $0x576
f01146c6:	68 42 8b 12 f0       	push   $0xf0128b42
f01146cb:	e8 06 be fe ff       	call   f01004d6 <_warn>
f01146d0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146d3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01146d7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f01146de:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01146e2:	74 04                	je     f01146e8 <test_allocate_chunk+0x415>
f01146e4:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01146e8:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01146ec:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01146f0:	74 5a                	je     f011474c <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f01146f2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01146f5:	01 c0                	add    %eax,%eax
f01146f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01146fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01146fd:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114700:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114703:	01 c0                	add    %eax,%eax
f0114705:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114708:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011470b:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011470e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114711:	8a 00                	mov    (%eax),%al
f0114713:	3c 4b                	cmp    $0x4b,%al
f0114715:	75 09                	jne    f0114720 <test_allocate_chunk+0x44d>
f0114717:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011471a:	8a 00                	mov    (%eax),%al
f011471c:	3c 4d                	cmp    $0x4d,%al
f011471e:	74 1e                	je     f011473e <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114720:	83 ec 04             	sub    $0x4,%esp
f0114723:	68 78 a1 12 f0       	push   $0xf012a178
f0114728:	68 84 05 00 00       	push   $0x584
f011472d:	68 42 8b 12 f0       	push   $0xf0128b42
f0114732:	e8 9f bd fe ff       	call   f01004d6 <_warn>
f0114737:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011473a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011473e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114742:	74 04                	je     f0114748 <test_allocate_chunk+0x475>
f0114744:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114748:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011474c:	83 ec 0c             	sub    $0xc,%esp
f011474f:	68 cf 94 12 f0       	push   $0xf01294cf
f0114754:	e8 32 c8 fe ff       	call   f0100f8b <cprintf>
f0114759:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f011475c:	83 ec 0c             	sub    $0xc,%esp
f011475f:	68 50 a2 12 f0       	push   $0xf012a250
f0114764:	e8 22 c8 fe ff       	call   f0100f8b <cprintf>
f0114769:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011476c:	e8 55 9b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114771:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114774:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114777:	c1 e0 06             	shl    $0x6,%eax
f011477a:	89 c2                	mov    %eax,%edx
f011477c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011477f:	c1 e0 05             	shl    $0x5,%eax
f0114782:	6a 00                	push   $0x0
f0114784:	52                   	push   %edx
f0114785:	50                   	push   %eax
f0114786:	ff 75 cc             	pushl  -0x34(%ebp)
f0114789:	e8 24 5d ff ff       	call   f010a4b2 <allocate_chunk>
f011478e:	83 c4 10             	add    $0x10,%esp
f0114791:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114794:	e8 2d 9b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114799:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011479c:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f01147a0:	75 36                	jne    f01147d8 <test_allocate_chunk+0x505>
f01147a2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01147a5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01147a8:	89 c1                	mov    %eax,%ecx
f01147aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147ad:	c1 e0 06             	shl    $0x6,%eax
f01147b0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01147b3:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01147ba:	99                   	cltd   
f01147bb:	f7 ff                	idiv   %edi
f01147bd:	89 c3                	mov    %eax,%ebx
f01147bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147c2:	c1 e0 06             	shl    $0x6,%eax
f01147c5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01147c8:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01147cf:	99                   	cltd   
f01147d0:	f7 fe                	idiv   %esi
f01147d2:	01 d8                	add    %ebx,%eax
f01147d4:	39 c1                	cmp    %eax,%ecx
f01147d6:	74 54                	je     f011482c <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f01147d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147db:	c1 e0 06             	shl    $0x6,%eax
f01147de:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01147e1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01147e8:	99                   	cltd   
f01147e9:	f7 fb                	idiv   %ebx
f01147eb:	89 c1                	mov    %eax,%ecx
f01147ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147f0:	c1 e0 06             	shl    $0x6,%eax
f01147f3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01147f6:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01147fd:	99                   	cltd   
f01147fe:	f7 ff                	idiv   %edi
f0114800:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114803:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114806:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114809:	83 ec 08             	sub    $0x8,%esp
f011480c:	52                   	push   %edx
f011480d:	50                   	push   %eax
f011480e:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114811:	68 f0 a1 12 f0       	push   $0xf012a1f0
f0114816:	68 9a 05 00 00       	push   $0x59a
f011481b:	68 42 8b 12 f0       	push   $0xf0128b42
f0114820:	e8 b1 bc fe ff       	call   f01004d6 <_warn>
f0114825:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114828:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011482c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114830:	74 04                	je     f0114836 <test_allocate_chunk+0x563>
f0114832:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114836:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011483a:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114841:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114844:	c1 e0 06             	shl    $0x6,%eax
f0114847:	89 c2                	mov    %eax,%edx
f0114849:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011484c:	c1 e0 05             	shl    $0x5,%eax
f011484f:	83 ec 08             	sub    $0x8,%esp
f0114852:	6a 03                	push   $0x3
f0114854:	6a 00                	push   $0x0
f0114856:	6a 00                	push   $0x0
f0114858:	68 07 0e 00 00       	push   $0xe07
f011485d:	6a 01                	push   $0x1
f011485f:	6a 01                	push   $0x1
f0114861:	52                   	push   %edx
f0114862:	50                   	push   %eax
f0114863:	6a 00                	push   $0x0
f0114865:	ff 75 cc             	pushl  -0x34(%ebp)
f0114868:	e8 94 1b 00 00       	call   f0116401 <CCP>
f011486d:	83 c4 30             	add    $0x30,%esp
f0114870:	85 c0                	test   %eax,%eax
f0114872:	75 25                	jne    f0114899 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114874:	83 ec 04             	sub    $0x4,%esp
f0114877:	68 2c a1 12 f0       	push   $0xf012a12c
f011487c:	68 a3 05 00 00       	push   $0x5a3
f0114881:	68 42 8b 12 f0       	push   $0xf0128b42
f0114886:	e8 4b bc fe ff       	call   f01004d6 <_warn>
f011488b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011488e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114892:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114899:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011489d:	74 04                	je     f01148a3 <test_allocate_chunk+0x5d0>
f011489f:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01148a3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f01148a7:	83 ec 0c             	sub    $0xc,%esp
f01148aa:	68 32 95 12 f0       	push   $0xf0129532
f01148af:	e8 d7 c6 fe ff       	call   f0100f8b <cprintf>
f01148b4:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f01148b7:	83 ec 0c             	sub    $0xc,%esp
f01148ba:	68 90 a2 12 f0       	push   $0xf012a290
f01148bf:	e8 c7 c6 fe ff       	call   f0100f8b <cprintf>
f01148c4:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01148c7:	e8 fa 99 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01148cc:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f01148cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01148d2:	c1 e0 06             	shl    $0x6,%eax
f01148d5:	68 06 0e 00 00       	push   $0xe06
f01148da:	50                   	push   %eax
f01148db:	68 00 00 00 80       	push   $0x80000000
f01148e0:	ff 75 cc             	pushl  -0x34(%ebp)
f01148e3:	e8 ca 5b ff ff       	call   f010a4b2 <allocate_chunk>
f01148e8:	83 c4 10             	add    $0x10,%esp
f01148eb:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01148ee:	e8 d3 99 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01148f3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f01148f6:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f01148fa:	75 36                	jne    f0114932 <test_allocate_chunk+0x65f>
f01148fc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01148ff:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114902:	89 c1                	mov    %eax,%ecx
f0114904:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114907:	c1 e0 06             	shl    $0x6,%eax
f011490a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011490d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114914:	99                   	cltd   
f0114915:	f7 fb                	idiv   %ebx
f0114917:	89 c3                	mov    %eax,%ebx
f0114919:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011491c:	c1 e0 06             	shl    $0x6,%eax
f011491f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114922:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114929:	99                   	cltd   
f011492a:	f7 fe                	idiv   %esi
f011492c:	01 d8                	add    %ebx,%eax
f011492e:	39 c1                	cmp    %eax,%ecx
f0114930:	74 54                	je     f0114986 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114932:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114935:	c1 e0 06             	shl    $0x6,%eax
f0114938:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011493b:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114942:	99                   	cltd   
f0114943:	f7 ff                	idiv   %edi
f0114945:	89 c1                	mov    %eax,%ecx
f0114947:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011494a:	c1 e0 06             	shl    $0x6,%eax
f011494d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114950:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114957:	99                   	cltd   
f0114958:	f7 fb                	idiv   %ebx
f011495a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011495d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114960:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114963:	83 ec 08             	sub    $0x8,%esp
f0114966:	52                   	push   %edx
f0114967:	50                   	push   %eax
f0114968:	ff 75 9c             	pushl  -0x64(%ebp)
f011496b:	68 f0 a1 12 f0       	push   $0xf012a1f0
f0114970:	68 b9 05 00 00       	push   $0x5b9
f0114975:	68 42 8b 12 f0       	push   $0xf0128b42
f011497a:	e8 57 bb fe ff       	call   f01004d6 <_warn>
f011497f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114982:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114986:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011498a:	74 04                	je     f0114990 <test_allocate_chunk+0x6bd>
f011498c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114990:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114994:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011499b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011499e:	c1 e0 06             	shl    $0x6,%eax
f01149a1:	83 ec 08             	sub    $0x8,%esp
f01149a4:	6a 03                	push   $0x3
f01149a6:	6a 00                	push   $0x0
f01149a8:	6a 00                	push   $0x0
f01149aa:	68 07 0e 00 00       	push   $0xe07
f01149af:	68 07 0e 00 00       	push   $0xe07
f01149b4:	6a 01                	push   $0x1
f01149b6:	50                   	push   %eax
f01149b7:	68 00 00 00 80       	push   $0x80000000
f01149bc:	6a 00                	push   $0x0
f01149be:	ff 75 cc             	pushl  -0x34(%ebp)
f01149c1:	e8 3b 1a 00 00       	call   f0116401 <CCP>
f01149c6:	83 c4 30             	add    $0x30,%esp
f01149c9:	85 c0                	test   %eax,%eax
f01149cb:	75 25                	jne    f01149f2 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01149cd:	83 ec 04             	sub    $0x4,%esp
f01149d0:	68 2c a1 12 f0       	push   $0xf012a12c
f01149d5:	68 c2 05 00 00       	push   $0x5c2
f01149da:	68 42 8b 12 f0       	push   $0xf0128b42
f01149df:	e8 f2 ba fe ff       	call   f01004d6 <_warn>
f01149e4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149e7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01149eb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f01149f2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01149f6:	74 04                	je     f01149fc <test_allocate_chunk+0x729>
f01149f8:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01149fc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114a00:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114a04:	74 6f                	je     f0114a75 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0114a06:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a09:	01 c0                	add    %eax,%eax
f0114a0b:	05 00 00 00 80       	add    $0x80000000,%eax
f0114a10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114a13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a16:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0114a19:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114a1c:	89 d0                	mov    %edx,%eax
f0114a1e:	c1 e0 02             	shl    $0x2,%eax
f0114a21:	01 d0                	add    %edx,%eax
f0114a23:	01 c0                	add    %eax,%eax
f0114a25:	01 d0                	add    %edx,%eax
f0114a27:	01 c0                	add    %eax,%eax
f0114a29:	05 00 00 00 80       	add    $0x80000000,%eax
f0114a2e:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114a31:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a34:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114a37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a3a:	8a 00                	mov    (%eax),%al
f0114a3c:	3c 4b                	cmp    $0x4b,%al
f0114a3e:	75 09                	jne    f0114a49 <test_allocate_chunk+0x776>
f0114a40:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a43:	8a 00                	mov    (%eax),%al
f0114a45:	3c 4d                	cmp    $0x4d,%al
f0114a47:	74 1e                	je     f0114a67 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114a49:	83 ec 04             	sub    $0x4,%esp
f0114a4c:	68 78 a1 12 f0       	push   $0xf012a178
f0114a51:	68 d0 05 00 00       	push   $0x5d0
f0114a56:	68 42 8b 12 f0       	push   $0xf0128b42
f0114a5b:	e8 76 ba fe ff       	call   f01004d6 <_warn>
f0114a60:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114a63:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114a67:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a6b:	74 04                	je     f0114a71 <test_allocate_chunk+0x79e>
f0114a6d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114a71:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114a75:	83 ec 0c             	sub    $0xc,%esp
f0114a78:	68 04 a0 12 f0       	push   $0xf012a004
f0114a7d:	e8 09 c5 fe ff       	call   f0100f8b <cprintf>
f0114a82:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0114a85:	83 ec 0c             	sub    $0xc,%esp
f0114a88:	68 cc a2 12 f0       	push   $0xf012a2cc
f0114a8d:	e8 f9 c4 fe ff       	call   f0100f8b <cprintf>
f0114a92:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a95:	e8 2c 98 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114a9a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114a9d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114aa0:	89 d0                	mov    %edx,%eax
f0114aa2:	01 c0                	add    %eax,%eax
f0114aa4:	01 d0                	add    %edx,%eax
f0114aa6:	01 c0                	add    %eax,%eax
f0114aa8:	01 d0                	add    %edx,%eax
f0114aaa:	68 04 0e 00 00       	push   $0xe04
f0114aaf:	50                   	push   %eax
f0114ab0:	68 00 fc 3f 40       	push   $0x403ffc00
f0114ab5:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ab8:	e8 f5 59 ff ff       	call   f010a4b2 <allocate_chunk>
f0114abd:	83 c4 10             	add    $0x10,%esp
f0114ac0:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ac3:	e8 fe 97 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0114ac8:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114acb:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114acf:	75 0b                	jne    f0114adc <test_allocate_chunk+0x809>
f0114ad1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ad4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ad7:	83 f8 05             	cmp    $0x5,%eax
f0114ada:	74 2a                	je     f0114b06 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114adc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114adf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ae2:	83 ec 08             	sub    $0x8,%esp
f0114ae5:	6a 05                	push   $0x5
f0114ae7:	50                   	push   %eax
f0114ae8:	ff 75 98             	pushl  -0x68(%ebp)
f0114aeb:	68 f0 a1 12 f0       	push   $0xf012a1f0
f0114af0:	68 e7 05 00 00       	push   $0x5e7
f0114af5:	68 42 8b 12 f0       	push   $0xf0128b42
f0114afa:	e8 d7 b9 fe ff       	call   f01004d6 <_warn>
f0114aff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b02:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114b06:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b0a:	74 04                	je     f0114b10 <test_allocate_chunk+0x83d>
f0114b0c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114b10:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114b14:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114b1b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b1e:	89 d0                	mov    %edx,%eax
f0114b20:	01 c0                	add    %eax,%eax
f0114b22:	01 d0                	add    %edx,%eax
f0114b24:	c1 e0 02             	shl    $0x2,%eax
f0114b27:	83 ec 08             	sub    $0x8,%esp
f0114b2a:	6a 03                	push   $0x3
f0114b2c:	6a 00                	push   $0x0
f0114b2e:	6a 00                	push   $0x0
f0114b30:	68 07 0e 00 00       	push   $0xe07
f0114b35:	68 05 0e 00 00       	push   $0xe05
f0114b3a:	6a 01                	push   $0x1
f0114b3c:	50                   	push   %eax
f0114b3d:	68 00 f0 3f 40       	push   $0x403ff000
f0114b42:	6a 00                	push   $0x0
f0114b44:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b47:	e8 b5 18 00 00       	call   f0116401 <CCP>
f0114b4c:	83 c4 30             	add    $0x30,%esp
f0114b4f:	85 c0                	test   %eax,%eax
f0114b51:	75 25                	jne    f0114b78 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114b53:	83 ec 04             	sub    $0x4,%esp
f0114b56:	68 2c a1 12 f0       	push   $0xf012a12c
f0114b5b:	68 f0 05 00 00       	push   $0x5f0
f0114b60:	68 42 8b 12 f0       	push   $0xf0128b42
f0114b65:	e8 6c b9 fe ff       	call   f01004d6 <_warn>
f0114b6a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b6d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114b71:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0114b78:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b7c:	74 04                	je     f0114b82 <test_allocate_chunk+0x8af>
f0114b7e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114b82:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0114b86:	83 ec 0c             	sub    $0xc,%esp
f0114b89:	68 03 a3 12 f0       	push   $0xf012a303
f0114b8e:	e8 f8 c3 fe ff       	call   f0100f8b <cprintf>
f0114b93:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0114b96:	83 ec 08             	sub    $0x8,%esp
f0114b99:	ff 75 e0             	pushl  -0x20(%ebp)
f0114b9c:	68 14 a3 12 f0       	push   $0xf012a314
f0114ba1:	e8 e5 c3 fe ff       	call   f0100f8b <cprintf>
f0114ba6:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114ba9:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114bad:	75 10                	jne    f0114bbf <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114baf:	83 ec 0c             	sub    $0xc,%esp
f0114bb2:	68 48 a3 12 f0       	push   $0xf012a348
f0114bb7:	e8 cf c3 fe ff       	call   f0100f8b <cprintf>
f0114bbc:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114bbf:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0114bc4:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114bc7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114bca:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114bcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114bd2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114bd5:	5b                   	pop    %ebx
f0114bd6:	5e                   	pop    %esi
f0114bd7:	5f                   	pop    %edi
f0114bd8:	5d                   	pop    %ebp
f0114bd9:	c3                   	ret    

f0114bda <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114bda:	55                   	push   %ebp
f0114bdb:	89 e5                	mov    %esp,%ebp
f0114bdd:	57                   	push   %edi
f0114bde:	56                   	push   %esi
f0114bdf:	53                   	push   %ebx
f0114be0:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114be6:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114be9:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f0114bee:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114bf3:	89 c7                	mov    %eax,%edi
f0114bf5:	89 de                	mov    %ebx,%esi
f0114bf7:	89 d1                	mov    %edx,%ecx
f0114bf9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114bfb:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114bfe:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114c03:	b0 00                	mov    $0x0,%al
f0114c05:	89 d7                	mov    %edx,%edi
f0114c07:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114c09:	6a 00                	push   $0x0
f0114c0b:	6a 0a                	push   $0xa
f0114c0d:	6a 14                	push   $0x14
f0114c0f:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114c12:	50                   	push   %eax
f0114c13:	e8 0d 5d ff ff       	call   f010a925 <env_create>
f0114c18:	83 c4 10             	add    $0x10,%esp
f0114c1b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114c1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114c21:	8b 40 64             	mov    0x64(%eax),%eax
f0114c24:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0114c27:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114c2a:	8b 40 68             	mov    0x68(%eax),%eax
f0114c2d:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114c30:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c33:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114c36:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0114c3d:	75 70 20 
f0114c40:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0114c47:	00 00 00 
f0114c4a:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114c4d:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114c52:	b8 00 00 00 00       	mov    $0x0,%eax
f0114c57:	89 d7                	mov    %edx,%edi
f0114c59:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114c5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114c5e:	8b 40 10             	mov    0x10(%eax),%eax
f0114c61:	83 ec 08             	sub    $0x8,%esp
f0114c64:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0114c6a:	52                   	push   %edx
f0114c6b:	50                   	push   %eax
f0114c6c:	e8 3b ae 00 00       	call   f011faac <ltostr>
f0114c71:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114c74:	83 ec 04             	sub    $0x4,%esp
f0114c77:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114c7d:	50                   	push   %eax
f0114c7e:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114c84:	50                   	push   %eax
f0114c85:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114c8b:	50                   	push   %eax
f0114c8c:	e8 f4 ae 00 00       	call   f011fb85 <strcconcat>
f0114c91:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114c94:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114c9b:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114ca2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0114ca9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0114cb0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0114cb4:	83 ec 0c             	sub    $0xc,%esp
f0114cb7:	ff 75 d8             	pushl  -0x28(%ebp)
f0114cba:	e8 0e 17 00 00       	call   f01163cd <ClearUserSpace>
f0114cbf:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114cc2:	83 ec 0c             	sub    $0xc,%esp
f0114cc5:	68 88 a3 12 f0       	push   $0xf012a388
f0114cca:	e8 bc c2 fe ff       	call   f0100f8b <cprintf>
f0114ccf:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114cd2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114cd5:	c1 e0 03             	shl    $0x3,%eax
f0114cd8:	83 ec 04             	sub    $0x4,%esp
f0114cdb:	50                   	push   %eax
f0114cdc:	6a 00                	push   $0x0
f0114cde:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ce1:	e8 00 58 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114ce6:	83 c4 10             	add    $0x10,%esp
f0114ce9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114cec:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114cf0:	74 23                	je     f0114d15 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114cf2:	83 ec 0c             	sub    $0xc,%esp
f0114cf5:	6a 03                	push   $0x3
f0114cf7:	ff 75 c8             	pushl  -0x38(%ebp)
f0114cfa:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114cff:	68 29 06 00 00       	push   $0x629
f0114d04:	68 42 8b 12 f0       	push   $0xf0128b42
f0114d09:	e8 c8 b7 fe ff       	call   f01004d6 <_warn>
f0114d0e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d11:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d15:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d19:	74 04                	je     f0114d1f <test_calculate_required_frames+0x145>
f0114d1b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d1f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0114d23:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d26:	c1 e0 02             	shl    $0x2,%eax
f0114d29:	83 ec 04             	sub    $0x4,%esp
f0114d2c:	50                   	push   %eax
f0114d2d:	6a 00                	push   $0x0
f0114d2f:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d32:	e8 af 57 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114d37:	83 c4 10             	add    $0x10,%esp
f0114d3a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0114d3d:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0114d44:	74 26                	je     f0114d6c <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0114d46:	83 ec 0c             	sub    $0xc,%esp
f0114d49:	68 01 04 00 00       	push   $0x401
f0114d4e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114d51:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114d56:	68 33 06 00 00       	push   $0x633
f0114d5b:	68 42 8b 12 f0       	push   $0xf0128b42
f0114d60:	e8 71 b7 fe ff       	call   f01004d6 <_warn>
f0114d65:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d68:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d6c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d70:	74 04                	je     f0114d76 <test_calculate_required_frames+0x19c>
f0114d72:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d76:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0114d7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d7d:	c1 e0 0a             	shl    $0xa,%eax
f0114d80:	83 ec 04             	sub    $0x4,%esp
f0114d83:	50                   	push   %eax
f0114d84:	6a 00                	push   $0x0
f0114d86:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d89:	e8 58 57 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114d8e:	83 c4 10             	add    $0x10,%esp
f0114d91:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0114d94:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d97:	c1 e0 0a             	shl    $0xa,%eax
f0114d9a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114d9d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114da4:	99                   	cltd   
f0114da5:	f7 fb                	idiv   %ebx
f0114da7:	89 c1                	mov    %eax,%ecx
f0114da9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114dac:	c1 e0 0a             	shl    $0xa,%eax
f0114daf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114db2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114db9:	99                   	cltd   
f0114dba:	f7 fe                	idiv   %esi
f0114dbc:	01 c8                	add    %ecx,%eax
f0114dbe:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114dc1:	74 4c                	je     f0114e0f <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0114dc3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114dc6:	c1 e0 0a             	shl    $0xa,%eax
f0114dc9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114dcc:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114dd3:	99                   	cltd   
f0114dd4:	f7 fb                	idiv   %ebx
f0114dd6:	89 c1                	mov    %eax,%ecx
f0114dd8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ddb:	c1 e0 0a             	shl    $0xa,%eax
f0114dde:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114de1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114de8:	99                   	cltd   
f0114de9:	f7 fe                	idiv   %esi
f0114deb:	01 c8                	add    %ecx,%eax
f0114ded:	83 ec 0c             	sub    $0xc,%esp
f0114df0:	50                   	push   %eax
f0114df1:	ff 75 c8             	pushl  -0x38(%ebp)
f0114df4:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114df9:	68 3d 06 00 00       	push   $0x63d
f0114dfe:	68 42 8b 12 f0       	push   $0xf0128b42
f0114e03:	e8 ce b6 fe ff       	call   f01004d6 <_warn>
f0114e08:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e0b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e0f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e13:	74 04                	je     f0114e19 <test_calculate_required_frames+0x23f>
f0114e15:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e19:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0114e1d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114e20:	89 d0                	mov    %edx,%eax
f0114e22:	01 c0                	add    %eax,%eax
f0114e24:	01 d0                	add    %edx,%eax
f0114e26:	01 c0                	add    %eax,%eax
f0114e28:	83 ec 04             	sub    $0x4,%esp
f0114e2b:	50                   	push   %eax
f0114e2c:	68 00 10 00 00       	push   $0x1000
f0114e31:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e34:	e8 ad 56 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114e39:	83 c4 10             	add    $0x10,%esp
f0114e3c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114e3f:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114e43:	74 23                	je     f0114e68 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114e45:	83 ec 0c             	sub    $0xc,%esp
f0114e48:	6a 03                	push   $0x3
f0114e4a:	ff 75 c8             	pushl  -0x38(%ebp)
f0114e4d:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114e52:	68 49 06 00 00       	push   $0x649
f0114e57:	68 42 8b 12 f0       	push   $0xf0128b42
f0114e5c:	e8 75 b6 fe ff       	call   f01004d6 <_warn>
f0114e61:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e68:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e6c:	74 04                	je     f0114e72 <test_calculate_required_frames+0x298>
f0114e6e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e72:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114e76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e79:	89 c2                	mov    %eax,%edx
f0114e7b:	01 d2                	add    %edx,%edx
f0114e7d:	01 d0                	add    %edx,%eax
f0114e7f:	83 ec 04             	sub    $0x4,%esp
f0114e82:	50                   	push   %eax
f0114e83:	68 00 18 00 00       	push   $0x1800
f0114e88:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e8b:	e8 56 56 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114e90:	83 c4 10             	add    $0x10,%esp
f0114e93:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114e96:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114e9a:	74 23                	je     f0114ebf <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114e9c:	83 ec 0c             	sub    $0xc,%esp
f0114e9f:	6a 03                	push   $0x3
f0114ea1:	ff 75 c8             	pushl  -0x38(%ebp)
f0114ea4:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114ea9:	68 53 06 00 00       	push   $0x653
f0114eae:	68 42 8b 12 f0       	push   $0xf0128b42
f0114eb3:	e8 1e b6 fe ff       	call   f01004d6 <_warn>
f0114eb8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ebb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ebf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ec3:	74 04                	je     f0114ec9 <test_calculate_required_frames+0x2ef>
f0114ec5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114ec9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0114ecd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114ed0:	89 d0                	mov    %edx,%eax
f0114ed2:	c1 e0 02             	shl    $0x2,%eax
f0114ed5:	01 d0                	add    %edx,%eax
f0114ed7:	01 c0                	add    %eax,%eax
f0114ed9:	83 ec 04             	sub    $0x4,%esp
f0114edc:	50                   	push   %eax
f0114edd:	68 00 00 40 00       	push   $0x400000
f0114ee2:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ee5:	e8 fc 55 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114eea:	83 c4 10             	add    $0x10,%esp
f0114eed:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0114ef0:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0114ef7:	74 26                	je     f0114f1f <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114ef9:	83 ec 0c             	sub    $0xc,%esp
f0114efc:	68 03 0a 00 00       	push   $0xa03
f0114f01:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f04:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114f09:	68 5d 06 00 00       	push   $0x65d
f0114f0e:	68 42 8b 12 f0       	push   $0xf0128b42
f0114f13:	e8 be b5 fe ff       	call   f01004d6 <_warn>
f0114f18:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f1b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114f1f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f23:	74 04                	je     f0114f29 <test_calculate_required_frames+0x34f>
f0114f25:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114f29:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0114f2d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114f30:	01 c0                	add    %eax,%eax
f0114f32:	83 ec 04             	sub    $0x4,%esp
f0114f35:	50                   	push   %eax
f0114f36:	68 00 00 70 00       	push   $0x700000
f0114f3b:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f3e:	e8 a3 55 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114f43:	83 c4 10             	add    $0x10,%esp
f0114f46:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0114f49:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0114f50:	74 26                	je     f0114f78 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0114f52:	83 ec 0c             	sub    $0xc,%esp
f0114f55:	68 02 02 00 00       	push   $0x202
f0114f5a:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f5d:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114f62:	68 69 06 00 00       	push   $0x669
f0114f67:	68 42 8b 12 f0       	push   $0xf0128b42
f0114f6c:	e8 65 b5 fe ff       	call   f01004d6 <_warn>
f0114f71:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f74:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114f78:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f7c:	74 04                	je     f0114f82 <test_calculate_required_frames+0x3a8>
f0114f7e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114f82:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0114f86:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114f89:	83 ec 04             	sub    $0x4,%esp
f0114f8c:	50                   	push   %eax
f0114f8d:	68 ff ff 3f 00       	push   $0x3fffff
f0114f92:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f95:	e8 4c 55 ff ff       	call   f010a4e6 <calculate_required_frames>
f0114f9a:	83 c4 10             	add    $0x10,%esp
f0114f9d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0114fa0:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0114fa4:	74 23                	je     f0114fc9 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0114fa6:	83 ec 0c             	sub    $0xc,%esp
f0114fa9:	6a 04                	push   $0x4
f0114fab:	ff 75 c8             	pushl  -0x38(%ebp)
f0114fae:	68 bc a3 12 f0       	push   $0xf012a3bc
f0114fb3:	68 73 06 00 00       	push   $0x673
f0114fb8:	68 42 8b 12 f0       	push   $0xf0128b42
f0114fbd:	e8 14 b5 fe ff       	call   f01004d6 <_warn>
f0114fc2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fc5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114fc9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114fcd:	74 04                	je     f0114fd3 <test_calculate_required_frames+0x3f9>
f0114fcf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114fd3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114fd7:	83 ec 0c             	sub    $0xc,%esp
f0114fda:	68 f5 9e 12 f0       	push   $0xf0129ef5
f0114fdf:	e8 a7 bf fe ff       	call   f0100f8b <cprintf>
f0114fe4:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0114fe7:	83 ec 0c             	sub    $0xc,%esp
f0114fea:	68 14 a4 12 f0       	push   $0xf012a414
f0114fef:	e8 97 bf fe ff       	call   f0100f8b <cprintf>
f0114ff4:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114ff7:	83 ec 04             	sub    $0x4,%esp
f0114ffa:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115000:	50                   	push   %eax
f0115001:	68 ae 92 12 f0       	push   $0xf01292ae
f0115006:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011500c:	50                   	push   %eax
f011500d:	e8 73 ab 00 00       	call   f011fb85 <strcconcat>
f0115012:	83 c4 10             	add    $0x10,%esp
f0115015:	83 ec 0c             	sub    $0xc,%esp
f0115018:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011501e:	50                   	push   %eax
f011501f:	e8 d7 ce fe ff       	call   f0101efb <execute_command>
f0115024:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115027:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011502a:	c1 e0 03             	shl    $0x3,%eax
f011502d:	83 ec 04             	sub    $0x4,%esp
f0115030:	50                   	push   %eax
f0115031:	6a 00                	push   $0x0
f0115033:	ff 75 d8             	pushl  -0x28(%ebp)
f0115036:	e8 ab 54 ff ff       	call   f010a4e6 <calculate_required_frames>
f011503b:	83 c4 10             	add    $0x10,%esp
f011503e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115041:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115048:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011504b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011504e:	74 24                	je     f0115074 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115050:	83 ec 0c             	sub    $0xc,%esp
f0115053:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115056:	ff 75 c8             	pushl  -0x38(%ebp)
f0115059:	68 bc a3 12 f0       	push   $0xf012a3bc
f011505e:	68 87 06 00 00       	push   $0x687
f0115063:	68 42 8b 12 f0       	push   $0xf0128b42
f0115068:	e8 69 b4 fe ff       	call   f01004d6 <_warn>
f011506d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115070:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115074:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115078:	74 04                	je     f011507e <test_calculate_required_frames+0x4a4>
f011507a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011507e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115082:	83 ec 04             	sub    $0x4,%esp
f0115085:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011508b:	50                   	push   %eax
f011508c:	68 bb 92 12 f0       	push   $0xf01292bb
f0115091:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115097:	50                   	push   %eax
f0115098:	e8 e8 aa 00 00       	call   f011fb85 <strcconcat>
f011509d:	83 c4 10             	add    $0x10,%esp
f01150a0:	83 ec 0c             	sub    $0xc,%esp
f01150a3:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01150a9:	50                   	push   %eax
f01150aa:	e8 4c ce fe ff       	call   f0101efb <execute_command>
f01150af:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01150b2:	83 ec 04             	sub    $0x4,%esp
f01150b5:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01150bb:	50                   	push   %eax
f01150bc:	68 48 a4 12 f0       	push   $0xf012a448
f01150c1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01150c7:	50                   	push   %eax
f01150c8:	e8 b8 aa 00 00       	call   f011fb85 <strcconcat>
f01150cd:	83 c4 10             	add    $0x10,%esp
f01150d0:	83 ec 0c             	sub    $0xc,%esp
f01150d3:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01150d9:	50                   	push   %eax
f01150da:	e8 1c ce fe ff       	call   f0101efb <execute_command>
f01150df:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01150e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01150e5:	c1 e0 03             	shl    $0x3,%eax
f01150e8:	83 ec 04             	sub    $0x4,%esp
f01150eb:	50                   	push   %eax
f01150ec:	6a 00                	push   $0x0
f01150ee:	ff 75 d8             	pushl  -0x28(%ebp)
f01150f1:	e8 f0 53 ff ff       	call   f010a4e6 <calculate_required_frames>
f01150f6:	83 c4 10             	add    $0x10,%esp
f01150f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01150fc:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115103:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115106:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115109:	74 24                	je     f011512f <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011510b:	83 ec 0c             	sub    $0xc,%esp
f011510e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115111:	ff 75 c8             	pushl  -0x38(%ebp)
f0115114:	68 bc a3 12 f0       	push   $0xf012a3bc
f0115119:	68 95 06 00 00       	push   $0x695
f011511e:	68 42 8b 12 f0       	push   $0xf0128b42
f0115123:	e8 ae b3 fe ff       	call   f01004d6 <_warn>
f0115128:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011512b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011512f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115133:	74 04                	je     f0115139 <test_calculate_required_frames+0x55f>
f0115135:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115139:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011513d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115140:	c1 e0 0a             	shl    $0xa,%eax
f0115143:	83 ec 04             	sub    $0x4,%esp
f0115146:	50                   	push   %eax
f0115147:	6a 00                	push   $0x0
f0115149:	ff 75 d8             	pushl  -0x28(%ebp)
f011514c:	e8 95 53 ff ff       	call   f010a4e6 <calculate_required_frames>
f0115151:	83 c4 10             	add    $0x10,%esp
f0115154:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115157:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011515a:	c1 e0 0a             	shl    $0xa,%eax
f011515d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115160:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115167:	99                   	cltd   
f0115168:	f7 fb                	idiv   %ebx
f011516a:	89 c1                	mov    %eax,%ecx
f011516c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011516f:	c1 e0 0a             	shl    $0xa,%eax
f0115172:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115175:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011517c:	99                   	cltd   
f011517d:	f7 fe                	idiv   %esi
f011517f:	01 c8                	add    %ecx,%eax
f0115181:	83 e8 05             	sub    $0x5,%eax
f0115184:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115187:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011518a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011518d:	74 24                	je     f01151b3 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011518f:	83 ec 0c             	sub    $0xc,%esp
f0115192:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115195:	ff 75 c8             	pushl  -0x38(%ebp)
f0115198:	68 bc a3 12 f0       	push   $0xf012a3bc
f011519d:	68 a0 06 00 00       	push   $0x6a0
f01151a2:	68 42 8b 12 f0       	push   $0xf0128b42
f01151a7:	e8 2a b3 fe ff       	call   f01004d6 <_warn>
f01151ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01151b3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01151b7:	74 04                	je     f01151bd <test_calculate_required_frames+0x5e3>
f01151b9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01151bd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01151c1:	83 ec 04             	sub    $0x4,%esp
f01151c4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01151ca:	50                   	push   %eax
f01151cb:	68 54 a4 12 f0       	push   $0xf012a454
f01151d0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01151d6:	50                   	push   %eax
f01151d7:	e8 a9 a9 00 00       	call   f011fb85 <strcconcat>
f01151dc:	83 c4 10             	add    $0x10,%esp
f01151df:	83 ec 0c             	sub    $0xc,%esp
f01151e2:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01151e8:	50                   	push   %eax
f01151e9:	e8 0d cd fe ff       	call   f0101efb <execute_command>
f01151ee:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01151f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01151f4:	89 c2                	mov    %eax,%edx
f01151f6:	01 d2                	add    %edx,%edx
f01151f8:	01 d0                	add    %edx,%eax
f01151fa:	83 ec 04             	sub    $0x4,%esp
f01151fd:	50                   	push   %eax
f01151fe:	68 00 18 00 00       	push   $0x1800
f0115203:	ff 75 d8             	pushl  -0x28(%ebp)
f0115206:	e8 db 52 ff ff       	call   f010a4e6 <calculate_required_frames>
f011520b:	83 c4 10             	add    $0x10,%esp
f011520e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115211:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115218:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011521b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011521e:	74 24                	je     f0115244 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115220:	83 ec 0c             	sub    $0xc,%esp
f0115223:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115226:	ff 75 c8             	pushl  -0x38(%ebp)
f0115229:	68 bc a3 12 f0       	push   $0xf012a3bc
f011522e:	68 af 06 00 00       	push   $0x6af
f0115233:	68 42 8b 12 f0       	push   $0xf0128b42
f0115238:	e8 99 b2 fe ff       	call   f01004d6 <_warn>
f011523d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115240:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115244:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115248:	74 04                	je     f011524e <test_calculate_required_frames+0x674>
f011524a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011524e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115252:	83 ec 04             	sub    $0x4,%esp
f0115255:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011525b:	50                   	push   %eax
f011525c:	68 14 95 12 f0       	push   $0xf0129514
f0115261:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115267:	50                   	push   %eax
f0115268:	e8 18 a9 00 00       	call   f011fb85 <strcconcat>
f011526d:	83 c4 10             	add    $0x10,%esp
f0115270:	83 ec 0c             	sub    $0xc,%esp
f0115273:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115279:	50                   	push   %eax
f011527a:	e8 7c cc fe ff       	call   f0101efb <execute_command>
f011527f:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115282:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115285:	89 d0                	mov    %edx,%eax
f0115287:	c1 e0 02             	shl    $0x2,%eax
f011528a:	01 d0                	add    %edx,%eax
f011528c:	01 c0                	add    %eax,%eax
f011528e:	83 ec 04             	sub    $0x4,%esp
f0115291:	50                   	push   %eax
f0115292:	68 00 00 40 00       	push   $0x400000
f0115297:	ff 75 d8             	pushl  -0x28(%ebp)
f011529a:	e8 47 52 ff ff       	call   f010a4e6 <calculate_required_frames>
f011529f:	83 c4 10             	add    $0x10,%esp
f01152a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01152a5:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01152ac:	74 26                	je     f01152d4 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01152ae:	83 ec 0c             	sub    $0xc,%esp
f01152b1:	68 03 0a 00 00       	push   $0xa03
f01152b6:	ff 75 c8             	pushl  -0x38(%ebp)
f01152b9:	68 bc a3 12 f0       	push   $0xf012a3bc
f01152be:	68 bb 06 00 00       	push   $0x6bb
f01152c3:	68 42 8b 12 f0       	push   $0xf0128b42
f01152c8:	e8 09 b2 fe ff       	call   f01004d6 <_warn>
f01152cd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152d0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01152d4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152d8:	74 04                	je     f01152de <test_calculate_required_frames+0x704>
f01152da:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152de:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01152e2:	83 ec 04             	sub    $0x4,%esp
f01152e5:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01152eb:	50                   	push   %eax
f01152ec:	68 1e 95 12 f0       	push   $0xf012951e
f01152f1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01152f7:	50                   	push   %eax
f01152f8:	e8 88 a8 00 00       	call   f011fb85 <strcconcat>
f01152fd:	83 c4 10             	add    $0x10,%esp
f0115300:	83 ec 0c             	sub    $0xc,%esp
f0115303:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115309:	50                   	push   %eax
f011530a:	e8 ec cb fe ff       	call   f0101efb <execute_command>
f011530f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115312:	83 ec 04             	sub    $0x4,%esp
f0115315:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011531b:	50                   	push   %eax
f011531c:	68 5c a4 12 f0       	push   $0xf012a45c
f0115321:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115327:	50                   	push   %eax
f0115328:	e8 58 a8 00 00       	call   f011fb85 <strcconcat>
f011532d:	83 c4 10             	add    $0x10,%esp
f0115330:	83 ec 0c             	sub    $0xc,%esp
f0115333:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115339:	50                   	push   %eax
f011533a:	e8 bc cb fe ff       	call   f0101efb <execute_command>
f011533f:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115342:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115345:	01 c0                	add    %eax,%eax
f0115347:	83 ec 04             	sub    $0x4,%esp
f011534a:	50                   	push   %eax
f011534b:	68 00 00 70 00       	push   $0x700000
f0115350:	ff 75 d8             	pushl  -0x28(%ebp)
f0115353:	e8 8e 51 ff ff       	call   f010a4e6 <calculate_required_frames>
f0115358:	83 c4 10             	add    $0x10,%esp
f011535b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011535e:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115365:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115368:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011536b:	74 24                	je     f0115391 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011536d:	83 ec 0c             	sub    $0xc,%esp
f0115370:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115373:	ff 75 c8             	pushl  -0x38(%ebp)
f0115376:	68 bc a3 12 f0       	push   $0xf012a3bc
f011537b:	68 cb 06 00 00       	push   $0x6cb
f0115380:	68 42 8b 12 f0       	push   $0xf0128b42
f0115385:	e8 4c b1 fe ff       	call   f01004d6 <_warn>
f011538a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011538d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115391:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115395:	74 04                	je     f011539b <test_calculate_required_frames+0x7c1>
f0115397:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011539b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f011539f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01153a2:	83 ec 04             	sub    $0x4,%esp
f01153a5:	50                   	push   %eax
f01153a6:	68 ff ff 3f 00       	push   $0x3fffff
f01153ab:	ff 75 d8             	pushl  -0x28(%ebp)
f01153ae:	e8 33 51 ff ff       	call   f010a4e6 <calculate_required_frames>
f01153b3:	83 c4 10             	add    $0x10,%esp
f01153b6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01153b9:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01153c0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01153c3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01153c6:	74 24                	je     f01153ec <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01153c8:	83 ec 0c             	sub    $0xc,%esp
f01153cb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01153ce:	ff 75 c8             	pushl  -0x38(%ebp)
f01153d1:	68 bc a3 12 f0       	push   $0xf012a3bc
f01153d6:	68 d6 06 00 00       	push   $0x6d6
f01153db:	68 42 8b 12 f0       	push   $0xf0128b42
f01153e0:	e8 f1 b0 fe ff       	call   f01004d6 <_warn>
f01153e5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153e8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01153ec:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153f0:	74 04                	je     f01153f6 <test_calculate_required_frames+0x81c>
f01153f2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153f6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01153fa:	83 ec 0c             	sub    $0xc,%esp
f01153fd:	68 cf 94 12 f0       	push   $0xf01294cf
f0115402:	e8 84 bb fe ff       	call   f0100f8b <cprintf>
f0115407:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f011540a:	83 ec 08             	sub    $0x8,%esp
f011540d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115410:	68 68 a4 12 f0       	push   $0xf012a468
f0115415:	e8 71 bb fe ff       	call   f0100f8b <cprintf>
f011541a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011541d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115421:	75 10                	jne    f0115433 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115423:	83 ec 0c             	sub    $0xc,%esp
f0115426:	68 a8 a4 12 f0       	push   $0xf012a4a8
f011542b:	e8 5b bb fe ff       	call   f0100f8b <cprintf>
f0115430:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115433:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0115438:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011543b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011543e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115441:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115446:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115449:	5b                   	pop    %ebx
f011544a:	5e                   	pop    %esi
f011544b:	5f                   	pop    %edi
f011544c:	5d                   	pop    %ebp
f011544d:	c3                   	ret    

f011544e <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f011544e:	55                   	push   %ebp
f011544f:	89 e5                	mov    %esp,%ebp
f0115451:	57                   	push   %edi
f0115452:	56                   	push   %esi
f0115453:	53                   	push   %ebx
f0115454:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011545a:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011545d:	bb 44 92 12 f0       	mov    $0xf0129244,%ebx
f0115462:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115467:	89 c7                	mov    %eax,%edi
f0115469:	89 de                	mov    %ebx,%esi
f011546b:	89 d1                	mov    %edx,%ecx
f011546d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011546f:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115472:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115477:	b0 00                	mov    $0x0,%al
f0115479:	89 d7                	mov    %edx,%edi
f011547b:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011547d:	6a 00                	push   $0x0
f011547f:	6a 0a                	push   $0xa
f0115481:	6a 14                	push   $0x14
f0115483:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115486:	50                   	push   %eax
f0115487:	e8 99 54 ff ff       	call   f010a925 <env_create>
f011548c:	83 c4 10             	add    $0x10,%esp
f011548f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115492:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115495:	8b 40 64             	mov    0x64(%eax),%eax
f0115498:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011549b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011549e:	8b 40 68             	mov    0x68(%eax),%eax
f01154a1:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01154a4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154a7:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01154aa:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01154b1:	75 70 20 
f01154b4:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01154bb:	00 00 00 
f01154be:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01154c1:	b9 03 00 00 00       	mov    $0x3,%ecx
f01154c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01154cb:	89 d7                	mov    %edx,%edi
f01154cd:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01154cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01154d2:	8b 40 10             	mov    0x10(%eax),%eax
f01154d5:	83 ec 08             	sub    $0x8,%esp
f01154d8:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01154de:	52                   	push   %edx
f01154df:	50                   	push   %eax
f01154e0:	e8 c7 a5 00 00       	call   f011faac <ltostr>
f01154e5:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01154e8:	83 ec 04             	sub    $0x4,%esp
f01154eb:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01154f1:	50                   	push   %eax
f01154f2:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01154f8:	50                   	push   %eax
f01154f9:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01154ff:	50                   	push   %eax
f0115500:	e8 80 a6 00 00       	call   f011fb85 <strcconcat>
f0115505:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115508:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011550f:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115516:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f011551d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115521:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115528:	00 00 00 
	uint32 num_tables = 0;
f011552b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115532:	00 00 00 
	ClearUserSpace(proc_directory);
f0115535:	83 ec 0c             	sub    $0xc,%esp
f0115538:	ff 75 d8             	pushl  -0x28(%ebp)
f011553b:	e8 8d 0e 00 00       	call   f01163cd <ClearUserSpace>
f0115540:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115543:	83 ec 0c             	sub    $0xc,%esp
f0115546:	68 88 a3 12 f0       	push   $0xf012a388
f011554b:	e8 3b ba fe ff       	call   f0100f8b <cprintf>
f0115550:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115553:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115556:	c1 e0 03             	shl    $0x3,%eax
f0115559:	89 c2                	mov    %eax,%edx
f011555b:	83 ec 0c             	sub    $0xc,%esp
f011555e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115564:	50                   	push   %eax
f0115565:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011556b:	50                   	push   %eax
f011556c:	52                   	push   %edx
f011556d:	6a 00                	push   $0x0
f011556f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115572:	e8 55 4f ff ff       	call   f010a4cc <calculate_allocated_space>
f0115577:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011557a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115580:	85 c0                	test   %eax,%eax
f0115582:	74 27                	je     f01155ab <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115584:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011558a:	83 ec 0c             	sub    $0xc,%esp
f011558d:	6a 00                	push   $0x0
f011558f:	50                   	push   %eax
f0115590:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115595:	68 0b 07 00 00       	push   $0x70b
f011559a:	68 42 8b 12 f0       	push   $0xf0128b42
f011559f:	e8 32 af fe ff       	call   f01004d6 <_warn>
f01155a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01155ab:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155b1:	85 c0                	test   %eax,%eax
f01155b3:	74 27                	je     f01155dc <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01155b5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155bb:	83 ec 0c             	sub    $0xc,%esp
f01155be:	6a 00                	push   $0x0
f01155c0:	50                   	push   %eax
f01155c1:	68 54 a5 12 f0       	push   $0xf012a554
f01155c6:	68 10 07 00 00       	push   $0x710
f01155cb:	68 42 8b 12 f0       	push   $0xf0128b42
f01155d0:	e8 01 af fe ff       	call   f01004d6 <_warn>
f01155d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01155dc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155e0:	74 04                	je     f01155e6 <test_calculate_allocated_space+0x198>
f01155e2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155e6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f01155ea:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01155f1:	00 00 00 
		num_pages = 0;
f01155f4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01155fb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01155fe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115601:	c1 e0 02             	shl    $0x2,%eax
f0115604:	89 c2                	mov    %eax,%edx
f0115606:	83 ec 0c             	sub    $0xc,%esp
f0115609:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011560f:	50                   	push   %eax
f0115610:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115616:	50                   	push   %eax
f0115617:	52                   	push   %edx
f0115618:	6a 00                	push   $0x0
f011561a:	ff 75 d8             	pushl  -0x28(%ebp)
f011561d:	e8 aa 4e ff ff       	call   f010a4cc <calculate_allocated_space>
f0115622:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115625:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011562b:	85 c0                	test   %eax,%eax
f011562d:	74 27                	je     f0115656 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011562f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115635:	83 ec 0c             	sub    $0xc,%esp
f0115638:	6a 00                	push   $0x0
f011563a:	50                   	push   %eax
f011563b:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115640:	68 1c 07 00 00       	push   $0x71c
f0115645:	68 42 8b 12 f0       	push   $0xf0128b42
f011564a:	e8 87 ae fe ff       	call   f01004d6 <_warn>
f011564f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115652:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115656:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011565c:	85 c0                	test   %eax,%eax
f011565e:	74 27                	je     f0115687 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115660:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115666:	83 ec 0c             	sub    $0xc,%esp
f0115669:	6a 00                	push   $0x0
f011566b:	50                   	push   %eax
f011566c:	68 54 a5 12 f0       	push   $0xf012a554
f0115671:	68 21 07 00 00       	push   $0x721
f0115676:	68 42 8b 12 f0       	push   $0xf0128b42
f011567b:	e8 56 ae fe ff       	call   f01004d6 <_warn>
f0115680:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115683:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115687:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011568b:	74 04                	je     f0115691 <test_calculate_allocated_space+0x243>
f011568d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115691:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115695:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011569c:	00 00 00 
		num_pages = 0;
f011569f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01156a6:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01156a9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01156ac:	c1 e0 0a             	shl    $0xa,%eax
f01156af:	89 c2                	mov    %eax,%edx
f01156b1:	83 ec 0c             	sub    $0xc,%esp
f01156b4:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01156ba:	50                   	push   %eax
f01156bb:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01156c1:	50                   	push   %eax
f01156c2:	52                   	push   %edx
f01156c3:	6a 00                	push   $0x0
f01156c5:	ff 75 d8             	pushl  -0x28(%ebp)
f01156c8:	e8 ff 4d ff ff       	call   f010a4cc <calculate_allocated_space>
f01156cd:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01156d0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01156d6:	85 c0                	test   %eax,%eax
f01156d8:	74 27                	je     f0115701 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01156da:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01156e0:	83 ec 0c             	sub    $0xc,%esp
f01156e3:	6a 00                	push   $0x0
f01156e5:	50                   	push   %eax
f01156e6:	68 f4 a4 12 f0       	push   $0xf012a4f4
f01156eb:	68 2d 07 00 00       	push   $0x72d
f01156f0:	68 42 8b 12 f0       	push   $0xf0128b42
f01156f5:	e8 dc ad fe ff       	call   f01004d6 <_warn>
f01156fa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156fd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115701:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115707:	85 c0                	test   %eax,%eax
f0115709:	74 27                	je     f0115732 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011570b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115711:	83 ec 0c             	sub    $0xc,%esp
f0115714:	6a 00                	push   $0x0
f0115716:	50                   	push   %eax
f0115717:	68 54 a5 12 f0       	push   $0xf012a554
f011571c:	68 32 07 00 00       	push   $0x732
f0115721:	68 42 8b 12 f0       	push   $0xf0128b42
f0115726:	e8 ab ad fe ff       	call   f01004d6 <_warn>
f011572b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011572e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115732:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115736:	74 04                	je     f011573c <test_calculate_allocated_space+0x2ee>
f0115738:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011573c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115740:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115747:	00 00 00 
		num_pages = 0;
f011574a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115751:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115754:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115757:	89 d0                	mov    %edx,%eax
f0115759:	01 c0                	add    %eax,%eax
f011575b:	01 d0                	add    %edx,%eax
f011575d:	01 c0                	add    %eax,%eax
f011575f:	05 00 10 00 00       	add    $0x1000,%eax
f0115764:	89 c2                	mov    %eax,%edx
f0115766:	83 ec 0c             	sub    $0xc,%esp
f0115769:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011576f:	50                   	push   %eax
f0115770:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115776:	50                   	push   %eax
f0115777:	52                   	push   %edx
f0115778:	68 00 10 00 00       	push   $0x1000
f011577d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115780:	e8 47 4d ff ff       	call   f010a4cc <calculate_allocated_space>
f0115785:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115788:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011578e:	85 c0                	test   %eax,%eax
f0115790:	74 27                	je     f01157b9 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115792:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115798:	83 ec 0c             	sub    $0xc,%esp
f011579b:	6a 00                	push   $0x0
f011579d:	50                   	push   %eax
f011579e:	68 f4 a4 12 f0       	push   $0xf012a4f4
f01157a3:	68 3f 07 00 00       	push   $0x73f
f01157a8:	68 42 8b 12 f0       	push   $0xf0128b42
f01157ad:	e8 24 ad fe ff       	call   f01004d6 <_warn>
f01157b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01157b9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01157bf:	85 c0                	test   %eax,%eax
f01157c1:	74 27                	je     f01157ea <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01157c3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01157c9:	83 ec 0c             	sub    $0xc,%esp
f01157cc:	6a 00                	push   $0x0
f01157ce:	50                   	push   %eax
f01157cf:	68 54 a5 12 f0       	push   $0xf012a554
f01157d4:	68 44 07 00 00       	push   $0x744
f01157d9:	68 42 8b 12 f0       	push   $0xf0128b42
f01157de:	e8 f3 ac fe ff       	call   f01004d6 <_warn>
f01157e3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157e6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01157ea:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157ee:	74 04                	je     f01157f4 <test_calculate_allocated_space+0x3a6>
f01157f0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01157f4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f01157f8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01157ff:	00 00 00 
		num_pages = 0;
f0115802:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115809:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011580c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011580f:	89 c2                	mov    %eax,%edx
f0115811:	01 d2                	add    %edx,%edx
f0115813:	01 d0                	add    %edx,%eax
f0115815:	05 00 18 00 00       	add    $0x1800,%eax
f011581a:	89 c2                	mov    %eax,%edx
f011581c:	83 ec 0c             	sub    $0xc,%esp
f011581f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115825:	50                   	push   %eax
f0115826:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011582c:	50                   	push   %eax
f011582d:	52                   	push   %edx
f011582e:	68 00 18 00 00       	push   $0x1800
f0115833:	ff 75 d8             	pushl  -0x28(%ebp)
f0115836:	e8 91 4c ff ff       	call   f010a4cc <calculate_allocated_space>
f011583b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011583e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115844:	85 c0                	test   %eax,%eax
f0115846:	74 27                	je     f011586f <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115848:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011584e:	83 ec 0c             	sub    $0xc,%esp
f0115851:	6a 00                	push   $0x0
f0115853:	50                   	push   %eax
f0115854:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115859:	68 50 07 00 00       	push   $0x750
f011585e:	68 42 8b 12 f0       	push   $0xf0128b42
f0115863:	e8 6e ac fe ff       	call   f01004d6 <_warn>
f0115868:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011586b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011586f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115875:	85 c0                	test   %eax,%eax
f0115877:	74 27                	je     f01158a0 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115879:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011587f:	83 ec 0c             	sub    $0xc,%esp
f0115882:	6a 00                	push   $0x0
f0115884:	50                   	push   %eax
f0115885:	68 54 a5 12 f0       	push   $0xf012a554
f011588a:	68 55 07 00 00       	push   $0x755
f011588f:	68 42 8b 12 f0       	push   $0xf0128b42
f0115894:	e8 3d ac fe ff       	call   f01004d6 <_warn>
f0115899:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011589c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158a0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158a4:	74 04                	je     f01158aa <test_calculate_allocated_space+0x45c>
f01158a6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158aa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f01158ae:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01158b5:	00 00 00 
		num_pages = 0;
f01158b8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01158bf:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01158c2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01158c5:	89 d0                	mov    %edx,%eax
f01158c7:	c1 e0 02             	shl    $0x2,%eax
f01158ca:	01 d0                	add    %edx,%eax
f01158cc:	01 c0                	add    %eax,%eax
f01158ce:	05 00 00 40 00       	add    $0x400000,%eax
f01158d3:	89 c2                	mov    %eax,%edx
f01158d5:	83 ec 0c             	sub    $0xc,%esp
f01158d8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01158de:	50                   	push   %eax
f01158df:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01158e5:	50                   	push   %eax
f01158e6:	52                   	push   %edx
f01158e7:	68 00 00 40 00       	push   $0x400000
f01158ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01158ef:	e8 d8 4b ff ff       	call   f010a4cc <calculate_allocated_space>
f01158f4:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01158f7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01158fd:	85 c0                	test   %eax,%eax
f01158ff:	74 27                	je     f0115928 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115901:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115907:	83 ec 0c             	sub    $0xc,%esp
f011590a:	6a 00                	push   $0x0
f011590c:	50                   	push   %eax
f011590d:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115912:	68 61 07 00 00       	push   $0x761
f0115917:	68 42 8b 12 f0       	push   $0xf0128b42
f011591c:	e8 b5 ab fe ff       	call   f01004d6 <_warn>
f0115921:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115924:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115928:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011592e:	85 c0                	test   %eax,%eax
f0115930:	74 27                	je     f0115959 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115932:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115938:	83 ec 0c             	sub    $0xc,%esp
f011593b:	6a 00                	push   $0x0
f011593d:	50                   	push   %eax
f011593e:	68 54 a5 12 f0       	push   $0xf012a554
f0115943:	68 66 07 00 00       	push   $0x766
f0115948:	68 42 8b 12 f0       	push   $0xf0128b42
f011594d:	e8 84 ab fe ff       	call   f01004d6 <_warn>
f0115952:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115955:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115959:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011595d:	74 04                	je     f0115963 <test_calculate_allocated_space+0x515>
f011595f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115963:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115967:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011596e:	00 00 00 
		num_pages = 0;
f0115971:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115978:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011597b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011597e:	05 00 00 38 00       	add    $0x380000,%eax
f0115983:	01 c0                	add    %eax,%eax
f0115985:	89 c2                	mov    %eax,%edx
f0115987:	83 ec 0c             	sub    $0xc,%esp
f011598a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115990:	50                   	push   %eax
f0115991:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115997:	50                   	push   %eax
f0115998:	52                   	push   %edx
f0115999:	68 00 00 70 00       	push   $0x700000
f011599e:	ff 75 d8             	pushl  -0x28(%ebp)
f01159a1:	e8 26 4b ff ff       	call   f010a4cc <calculate_allocated_space>
f01159a6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01159a9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01159af:	85 c0                	test   %eax,%eax
f01159b1:	74 27                	je     f01159da <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01159b3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01159b9:	83 ec 0c             	sub    $0xc,%esp
f01159bc:	6a 00                	push   $0x0
f01159be:	50                   	push   %eax
f01159bf:	68 f4 a4 12 f0       	push   $0xf012a4f4
f01159c4:	68 73 07 00 00       	push   $0x773
f01159c9:	68 42 8b 12 f0       	push   $0xf0128b42
f01159ce:	e8 03 ab fe ff       	call   f01004d6 <_warn>
f01159d3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01159da:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159e0:	85 c0                	test   %eax,%eax
f01159e2:	74 27                	je     f0115a0b <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01159e4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159ea:	83 ec 0c             	sub    $0xc,%esp
f01159ed:	6a 00                	push   $0x0
f01159ef:	50                   	push   %eax
f01159f0:	68 54 a5 12 f0       	push   $0xf012a554
f01159f5:	68 78 07 00 00       	push   $0x778
f01159fa:	68 42 8b 12 f0       	push   $0xf0128b42
f01159ff:	e8 d2 aa fe ff       	call   f01004d6 <_warn>
f0115a04:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a07:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a0b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a0f:	74 04                	je     f0115a15 <test_calculate_allocated_space+0x5c7>
f0115a11:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a15:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0115a19:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115a20:	00 00 00 
		num_pages = 0;
f0115a23:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115a2a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a30:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115a35:	89 c2                	mov    %eax,%edx
f0115a37:	83 ec 0c             	sub    $0xc,%esp
f0115a3a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115a40:	50                   	push   %eax
f0115a41:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115a47:	50                   	push   %eax
f0115a48:	52                   	push   %edx
f0115a49:	68 ff ff 3f 00       	push   $0x3fffff
f0115a4e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a51:	e8 76 4a ff ff       	call   f010a4cc <calculate_allocated_space>
f0115a56:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115a59:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a5f:	85 c0                	test   %eax,%eax
f0115a61:	74 27                	je     f0115a8a <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115a63:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a69:	83 ec 0c             	sub    $0xc,%esp
f0115a6c:	6a 00                	push   $0x0
f0115a6e:	50                   	push   %eax
f0115a6f:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115a74:	68 84 07 00 00       	push   $0x784
f0115a79:	68 42 8b 12 f0       	push   $0xf0128b42
f0115a7e:	e8 53 aa fe ff       	call   f01004d6 <_warn>
f0115a83:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a86:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115a8a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a90:	85 c0                	test   %eax,%eax
f0115a92:	74 27                	je     f0115abb <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115a94:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a9a:	83 ec 0c             	sub    $0xc,%esp
f0115a9d:	6a 00                	push   $0x0
f0115a9f:	50                   	push   %eax
f0115aa0:	68 54 a5 12 f0       	push   $0xf012a554
f0115aa5:	68 89 07 00 00       	push   $0x789
f0115aaa:	68 42 8b 12 f0       	push   $0xf0128b42
f0115aaf:	e8 22 aa fe ff       	call   f01004d6 <_warn>
f0115ab4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ab7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115abb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115abf:	74 04                	je     f0115ac5 <test_calculate_allocated_space+0x677>
f0115ac1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115ac5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115ac9:	83 ec 0c             	sub    $0xc,%esp
f0115acc:	68 f5 9e 12 f0       	push   $0xf0129ef5
f0115ad1:	e8 b5 b4 fe ff       	call   f0100f8b <cprintf>
f0115ad6:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115ad9:	83 ec 0c             	sub    $0xc,%esp
f0115adc:	68 14 a4 12 f0       	push   $0xf012a414
f0115ae1:	e8 a5 b4 fe ff       	call   f0100f8b <cprintf>
f0115ae6:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115ae9:	83 ec 04             	sub    $0x4,%esp
f0115aec:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115af2:	50                   	push   %eax
f0115af3:	68 ae 92 12 f0       	push   $0xf01292ae
f0115af8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115afe:	50                   	push   %eax
f0115aff:	e8 81 a0 00 00       	call   f011fb85 <strcconcat>
f0115b04:	83 c4 10             	add    $0x10,%esp
f0115b07:	83 ec 0c             	sub    $0xc,%esp
f0115b0a:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115b10:	50                   	push   %eax
f0115b11:	e8 e5 c3 fe ff       	call   f0101efb <execute_command>
f0115b16:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0115b19:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b20:	00 00 00 
		num_pages = 0;
f0115b23:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115b2a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115b2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b30:	c1 e0 03             	shl    $0x3,%eax
f0115b33:	89 c2                	mov    %eax,%edx
f0115b35:	83 ec 0c             	sub    $0xc,%esp
f0115b38:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b3e:	50                   	push   %eax
f0115b3f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b45:	50                   	push   %eax
f0115b46:	52                   	push   %edx
f0115b47:	6a 00                	push   $0x0
f0115b49:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b4c:	e8 7b 49 ff ff       	call   f010a4cc <calculate_allocated_space>
f0115b51:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115b54:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0115b5b:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115b62:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b68:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115b6b:	74 28                	je     f0115b95 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115b6d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b73:	83 ec 0c             	sub    $0xc,%esp
f0115b76:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b79:	50                   	push   %eax
f0115b7a:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115b7f:	68 a0 07 00 00       	push   $0x7a0
f0115b84:	68 42 8b 12 f0       	push   $0xf0128b42
f0115b89:	e8 48 a9 fe ff       	call   f01004d6 <_warn>
f0115b8e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b91:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115b95:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b9b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115b9e:	74 28                	je     f0115bc8 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115ba0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ba6:	83 ec 0c             	sub    $0xc,%esp
f0115ba9:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115bac:	50                   	push   %eax
f0115bad:	68 54 a5 12 f0       	push   $0xf012a554
f0115bb2:	68 a5 07 00 00       	push   $0x7a5
f0115bb7:	68 42 8b 12 f0       	push   $0xf0128b42
f0115bbc:	e8 15 a9 fe ff       	call   f01004d6 <_warn>
f0115bc1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bc4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bc8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bcc:	74 04                	je     f0115bd2 <test_calculate_allocated_space+0x784>
f0115bce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bd2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115bd6:	83 ec 04             	sub    $0x4,%esp
f0115bd9:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115bdf:	50                   	push   %eax
f0115be0:	68 bb 92 12 f0       	push   $0xf01292bb
f0115be5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115beb:	50                   	push   %eax
f0115bec:	e8 94 9f 00 00       	call   f011fb85 <strcconcat>
f0115bf1:	83 c4 10             	add    $0x10,%esp
f0115bf4:	83 ec 0c             	sub    $0xc,%esp
f0115bf7:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115bfd:	50                   	push   %eax
f0115bfe:	e8 f8 c2 fe ff       	call   f0101efb <execute_command>
f0115c03:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115c06:	83 ec 04             	sub    $0x4,%esp
f0115c09:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115c0f:	50                   	push   %eax
f0115c10:	68 48 a4 12 f0       	push   $0xf012a448
f0115c15:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c1b:	50                   	push   %eax
f0115c1c:	e8 64 9f 00 00       	call   f011fb85 <strcconcat>
f0115c21:	83 c4 10             	add    $0x10,%esp
f0115c24:	83 ec 0c             	sub    $0xc,%esp
f0115c27:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115c2d:	50                   	push   %eax
f0115c2e:	e8 c8 c2 fe ff       	call   f0101efb <execute_command>
f0115c33:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0115c36:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c3d:	00 00 00 
		num_pages = 0;
f0115c40:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c47:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0115c4a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c4d:	c1 e0 03             	shl    $0x3,%eax
f0115c50:	89 c2                	mov    %eax,%edx
f0115c52:	83 ec 0c             	sub    $0xc,%esp
f0115c55:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c5b:	50                   	push   %eax
f0115c5c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c62:	50                   	push   %eax
f0115c63:	52                   	push   %edx
f0115c64:	6a 00                	push   $0x0
f0115c66:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c69:	e8 5e 48 ff ff       	call   f010a4cc <calculate_allocated_space>
f0115c6e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115c71:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0115c78:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115c7f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c85:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115c88:	74 28                	je     f0115cb2 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115c8a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c90:	83 ec 0c             	sub    $0xc,%esp
f0115c93:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c96:	50                   	push   %eax
f0115c97:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115c9c:	68 b6 07 00 00       	push   $0x7b6
f0115ca1:	68 42 8b 12 f0       	push   $0xf0128b42
f0115ca6:	e8 2b a8 fe ff       	call   f01004d6 <_warn>
f0115cab:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115cb2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115cb8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115cbb:	74 28                	je     f0115ce5 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115cbd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115cc3:	83 ec 0c             	sub    $0xc,%esp
f0115cc6:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115cc9:	50                   	push   %eax
f0115cca:	68 54 a5 12 f0       	push   $0xf012a554
f0115ccf:	68 bb 07 00 00       	push   $0x7bb
f0115cd4:	68 42 8b 12 f0       	push   $0xf0128b42
f0115cd9:	e8 f8 a7 fe ff       	call   f01004d6 <_warn>
f0115cde:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ce1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ce5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ce9:	74 04                	je     f0115cef <test_calculate_allocated_space+0x8a1>
f0115ceb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cef:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115cf3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115cfa:	00 00 00 
		num_pages = 0;
f0115cfd:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d04:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115d07:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d0a:	c1 e0 0a             	shl    $0xa,%eax
f0115d0d:	89 c2                	mov    %eax,%edx
f0115d0f:	83 ec 0c             	sub    $0xc,%esp
f0115d12:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d18:	50                   	push   %eax
f0115d19:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d1f:	50                   	push   %eax
f0115d20:	52                   	push   %edx
f0115d21:	6a 00                	push   $0x0
f0115d23:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d26:	e8 a1 47 ff ff       	call   f010a4cc <calculate_allocated_space>
f0115d2b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0115d2e:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0115d35:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115d3c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d42:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115d45:	74 28                	je     f0115d6f <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115d47:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d4d:	83 ec 0c             	sub    $0xc,%esp
f0115d50:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d53:	50                   	push   %eax
f0115d54:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115d59:	68 c9 07 00 00       	push   $0x7c9
f0115d5e:	68 42 8b 12 f0       	push   $0xf0128b42
f0115d63:	e8 6e a7 fe ff       	call   f01004d6 <_warn>
f0115d68:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d6b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115d6f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d75:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d78:	74 28                	je     f0115da2 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115d7a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d80:	83 ec 0c             	sub    $0xc,%esp
f0115d83:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d86:	50                   	push   %eax
f0115d87:	68 54 a5 12 f0       	push   $0xf012a554
f0115d8c:	68 ce 07 00 00       	push   $0x7ce
f0115d91:	68 42 8b 12 f0       	push   $0xf0128b42
f0115d96:	e8 3b a7 fe ff       	call   f01004d6 <_warn>
f0115d9b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d9e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115da2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115da6:	74 04                	je     f0115dac <test_calculate_allocated_space+0x95e>
f0115da8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115dac:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115db0:	83 ec 04             	sub    $0x4,%esp
f0115db3:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115db9:	50                   	push   %eax
f0115dba:	68 54 a4 12 f0       	push   $0xf012a454
f0115dbf:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115dc5:	50                   	push   %eax
f0115dc6:	e8 ba 9d 00 00       	call   f011fb85 <strcconcat>
f0115dcb:	83 c4 10             	add    $0x10,%esp
f0115dce:	83 ec 0c             	sub    $0xc,%esp
f0115dd1:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115dd7:	50                   	push   %eax
f0115dd8:	e8 1e c1 fe ff       	call   f0101efb <execute_command>
f0115ddd:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0115de0:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115de7:	00 00 00 
		num_pages = 0;
f0115dea:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115df1:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115df4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115df7:	89 c2                	mov    %eax,%edx
f0115df9:	01 d2                	add    %edx,%edx
f0115dfb:	01 d0                	add    %edx,%eax
f0115dfd:	05 00 18 00 00       	add    $0x1800,%eax
f0115e02:	89 c2                	mov    %eax,%edx
f0115e04:	83 ec 0c             	sub    $0xc,%esp
f0115e07:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e0d:	50                   	push   %eax
f0115e0e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e14:	50                   	push   %eax
f0115e15:	52                   	push   %edx
f0115e16:	68 00 18 00 00       	push   $0x1800
f0115e1b:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e1e:	e8 a9 46 ff ff       	call   f010a4cc <calculate_allocated_space>
f0115e23:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115e26:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115e2d:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115e34:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e3a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115e3d:	74 28                	je     f0115e67 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115e3f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e45:	83 ec 0c             	sub    $0xc,%esp
f0115e48:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e4b:	50                   	push   %eax
f0115e4c:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115e51:	68 df 07 00 00       	push   $0x7df
f0115e56:	68 42 8b 12 f0       	push   $0xf0128b42
f0115e5b:	e8 76 a6 fe ff       	call   f01004d6 <_warn>
f0115e60:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e63:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115e67:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e6d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115e70:	74 28                	je     f0115e9a <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115e72:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e78:	83 ec 0c             	sub    $0xc,%esp
f0115e7b:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115e7e:	50                   	push   %eax
f0115e7f:	68 54 a5 12 f0       	push   $0xf012a554
f0115e84:	68 e4 07 00 00       	push   $0x7e4
f0115e89:	68 42 8b 12 f0       	push   $0xf0128b42
f0115e8e:	e8 43 a6 fe ff       	call   f01004d6 <_warn>
f0115e93:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e96:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e9a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e9e:	74 04                	je     f0115ea4 <test_calculate_allocated_space+0xa56>
f0115ea0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ea4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115ea8:	83 ec 04             	sub    $0x4,%esp
f0115eab:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115eb1:	50                   	push   %eax
f0115eb2:	68 14 95 12 f0       	push   $0xf0129514
f0115eb7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ebd:	50                   	push   %eax
f0115ebe:	e8 c2 9c 00 00       	call   f011fb85 <strcconcat>
f0115ec3:	83 c4 10             	add    $0x10,%esp
f0115ec6:	83 ec 0c             	sub    $0xc,%esp
f0115ec9:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ecf:	50                   	push   %eax
f0115ed0:	e8 26 c0 fe ff       	call   f0101efb <execute_command>
f0115ed5:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0115ed8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115edf:	00 00 00 
		num_pages = 0;
f0115ee2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115ee9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115eec:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115eef:	89 d0                	mov    %edx,%eax
f0115ef1:	c1 e0 02             	shl    $0x2,%eax
f0115ef4:	01 d0                	add    %edx,%eax
f0115ef6:	01 c0                	add    %eax,%eax
f0115ef8:	05 00 00 40 00       	add    $0x400000,%eax
f0115efd:	89 c2                	mov    %eax,%edx
f0115eff:	83 ec 0c             	sub    $0xc,%esp
f0115f02:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f08:	50                   	push   %eax
f0115f09:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f0f:	50                   	push   %eax
f0115f10:	52                   	push   %edx
f0115f11:	68 00 00 40 00       	push   $0x400000
f0115f16:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f19:	e8 ae 45 ff ff       	call   f010a4cc <calculate_allocated_space>
f0115f1e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115f21:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115f28:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115f2f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f35:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f38:	74 28                	je     f0115f62 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115f3a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f40:	83 ec 0c             	sub    $0xc,%esp
f0115f43:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f46:	50                   	push   %eax
f0115f47:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0115f4c:	68 f4 07 00 00       	push   $0x7f4
f0115f51:	68 42 8b 12 f0       	push   $0xf0128b42
f0115f56:	e8 7b a5 fe ff       	call   f01004d6 <_warn>
f0115f5b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f5e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115f62:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f68:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f6b:	74 28                	je     f0115f95 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115f6d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f73:	83 ec 0c             	sub    $0xc,%esp
f0115f76:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f79:	50                   	push   %eax
f0115f7a:	68 54 a5 12 f0       	push   $0xf012a554
f0115f7f:	68 f9 07 00 00       	push   $0x7f9
f0115f84:	68 42 8b 12 f0       	push   $0xf0128b42
f0115f89:	e8 48 a5 fe ff       	call   f01004d6 <_warn>
f0115f8e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f91:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f95:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f99:	74 04                	je     f0115f9f <test_calculate_allocated_space+0xb51>
f0115f9b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f9f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115fa3:	83 ec 04             	sub    $0x4,%esp
f0115fa6:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115fac:	50                   	push   %eax
f0115fad:	68 1e 95 12 f0       	push   $0xf012951e
f0115fb2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115fb8:	50                   	push   %eax
f0115fb9:	e8 c7 9b 00 00       	call   f011fb85 <strcconcat>
f0115fbe:	83 c4 10             	add    $0x10,%esp
f0115fc1:	83 ec 0c             	sub    $0xc,%esp
f0115fc4:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115fca:	50                   	push   %eax
f0115fcb:	e8 2b bf fe ff       	call   f0101efb <execute_command>
f0115fd0:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115fd3:	83 ec 04             	sub    $0x4,%esp
f0115fd6:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115fdc:	50                   	push   %eax
f0115fdd:	68 5c a4 12 f0       	push   $0xf012a45c
f0115fe2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115fe8:	50                   	push   %eax
f0115fe9:	e8 97 9b 00 00       	call   f011fb85 <strcconcat>
f0115fee:	83 c4 10             	add    $0x10,%esp
f0115ff1:	83 ec 0c             	sub    $0xc,%esp
f0115ff4:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ffa:	50                   	push   %eax
f0115ffb:	e8 fb be fe ff       	call   f0101efb <execute_command>
f0116000:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116003:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011600a:	00 00 00 
		num_pages = 0;
f011600d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116014:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116017:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011601a:	05 00 00 38 00       	add    $0x380000,%eax
f011601f:	01 c0                	add    %eax,%eax
f0116021:	89 c2                	mov    %eax,%edx
f0116023:	83 ec 0c             	sub    $0xc,%esp
f0116026:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011602c:	50                   	push   %eax
f011602d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116033:	50                   	push   %eax
f0116034:	52                   	push   %edx
f0116035:	68 00 00 70 00       	push   $0x700000
f011603a:	ff 75 d8             	pushl  -0x28(%ebp)
f011603d:	e8 8a 44 ff ff       	call   f010a4cc <calculate_allocated_space>
f0116042:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116045:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011604c:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116053:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116059:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011605c:	74 28                	je     f0116086 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011605e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116064:	83 ec 0c             	sub    $0xc,%esp
f0116067:	ff 75 c8             	pushl  -0x38(%ebp)
f011606a:	50                   	push   %eax
f011606b:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0116070:	68 0b 08 00 00       	push   $0x80b
f0116075:	68 42 8b 12 f0       	push   $0xf0128b42
f011607a:	e8 57 a4 fe ff       	call   f01004d6 <_warn>
f011607f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116082:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116086:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011608c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011608f:	74 28                	je     f01160b9 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116091:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116097:	83 ec 0c             	sub    $0xc,%esp
f011609a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011609d:	50                   	push   %eax
f011609e:	68 54 a5 12 f0       	push   $0xf012a554
f01160a3:	68 10 08 00 00       	push   $0x810
f01160a8:	68 42 8b 12 f0       	push   $0xf0128b42
f01160ad:	e8 24 a4 fe ff       	call   f01004d6 <_warn>
f01160b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01160b9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160bd:	74 04                	je     f01160c3 <test_calculate_allocated_space+0xc75>
f01160bf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01160c3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01160c7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160ce:	00 00 00 
		num_pages = 0;
f01160d1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160d8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01160db:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160de:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01160e3:	89 c2                	mov    %eax,%edx
f01160e5:	83 ec 0c             	sub    $0xc,%esp
f01160e8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160ee:	50                   	push   %eax
f01160ef:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160f5:	50                   	push   %eax
f01160f6:	52                   	push   %edx
f01160f7:	68 ff ff 3f 00       	push   $0x3fffff
f01160fc:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ff:	e8 c8 43 ff ff       	call   f010a4cc <calculate_allocated_space>
f0116104:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116107:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f011610e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116115:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011611b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011611e:	74 28                	je     f0116148 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116120:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116126:	83 ec 0c             	sub    $0xc,%esp
f0116129:	ff 75 c8             	pushl  -0x38(%ebp)
f011612c:	50                   	push   %eax
f011612d:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0116132:	68 1e 08 00 00       	push   $0x81e
f0116137:	68 42 8b 12 f0       	push   $0xf0128b42
f011613c:	e8 95 a3 fe ff       	call   f01004d6 <_warn>
f0116141:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116144:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116148:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011614e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116151:	74 28                	je     f011617b <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116153:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116159:	83 ec 0c             	sub    $0xc,%esp
f011615c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011615f:	50                   	push   %eax
f0116160:	68 54 a5 12 f0       	push   $0xf012a554
f0116165:	68 23 08 00 00       	push   $0x823
f011616a:	68 42 8b 12 f0       	push   $0xf0128b42
f011616f:	e8 62 a3 fe ff       	call   f01004d6 <_warn>
f0116174:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116177:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011617b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011617f:	74 04                	je     f0116185 <test_calculate_allocated_space+0xd37>
f0116181:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116185:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116189:	83 ec 0c             	sub    $0xc,%esp
f011618c:	68 cf 94 12 f0       	push   $0xf01294cf
f0116191:	e8 f5 ad fe ff       	call   f0100f8b <cprintf>
f0116196:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116199:	83 ec 08             	sub    $0x8,%esp
f011619c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011619f:	68 b0 a5 12 f0       	push   $0xf012a5b0
f01161a4:	e8 e2 ad fe ff       	call   f0100f8b <cprintf>
f01161a9:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01161ac:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01161b0:	75 10                	jne    f01161c2 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01161b2:	83 ec 0c             	sub    $0xc,%esp
f01161b5:	68 f0 a5 12 f0       	push   $0xf012a5f0
f01161ba:	e8 cc ad fe ff       	call   f0100f8b <cprintf>
f01161bf:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01161c2:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f01161c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01161ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01161cd:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01161d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01161d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01161d8:	5b                   	pop    %ebx
f01161d9:	5e                   	pop    %esi
f01161da:	5f                   	pop    %edi
f01161db:	5d                   	pop    %ebp
f01161dc:	c3                   	ret    

f01161dd <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01161dd:	55                   	push   %ebp
f01161de:	89 e5                	mov    %esp,%ebp
f01161e0:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01161e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01161e6:	ba 01 00 00 00       	mov    $0x1,%edx
f01161eb:	88 c1                	mov    %al,%cl
f01161ed:	d3 e2                	shl    %cl,%edx
f01161ef:	89 d0                	mov    %edx,%eax
f01161f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01161f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01161f7:	c1 e8 16             	shr    $0x16,%eax
f01161fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116201:	8b 45 08             	mov    0x8(%ebp),%eax
f0116204:	01 d0                	add    %edx,%eax
f0116206:	8b 00                	mov    (%eax),%eax
f0116208:	83 e0 01             	and    $0x1,%eax
f011620b:	85 c0                	test   %eax,%eax
f011620d:	75 07                	jne    f0116216 <CB+0x39>
f011620f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116214:	eb 76                	jmp    f011628c <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116216:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116219:	c1 e8 16             	shr    $0x16,%eax
f011621c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116223:	8b 45 08             	mov    0x8(%ebp),%eax
f0116226:	01 d0                	add    %edx,%eax
f0116228:	8b 00                	mov    (%eax),%eax
f011622a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011622f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116232:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116235:	c1 e8 0c             	shr    $0xc,%eax
f0116238:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011623b:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0116240:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116243:	72 17                	jb     f011625c <CB+0x7f>
f0116245:	ff 75 f0             	pushl  -0x10(%ebp)
f0116248:	68 3c a6 12 f0       	push   $0xf012a63c
f011624d:	68 3e 08 00 00       	push   $0x83e
f0116252:	68 42 8b 12 f0       	push   $0xf0128b42
f0116257:	e8 dd a0 fe ff       	call   f0100339 <_panic>
f011625c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011625f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116264:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116267:	8b 45 0c             	mov    0xc(%ebp),%eax
f011626a:	c1 e8 0c             	shr    $0xc,%eax
f011626d:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116272:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116279:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011627c:	01 d0                	add    %edx,%eax
f011627e:	8b 00                	mov    (%eax),%eax
f0116280:	23 45 f4             	and    -0xc(%ebp),%eax
f0116283:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116286:	0f 94 c0             	sete   %al
f0116289:	0f b6 c0             	movzbl %al,%eax
}
f011628c:	c9                   	leave  
f011628d:	c3                   	ret    

f011628e <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011628e:	55                   	push   %ebp
f011628f:	89 e5                	mov    %esp,%ebp
f0116291:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116294:	68 6b a6 12 f0       	push   $0xf012a66b
f0116299:	68 7a a6 12 f0       	push   $0xf012a67a
f011629e:	68 43 08 00 00       	push   $0x843
f01162a3:	68 42 8b 12 f0       	push   $0xf0128b42
f01162a8:	e8 8c a0 fe ff       	call   f0100339 <_panic>

f01162ad <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f01162ad:	55                   	push   %ebp
f01162ae:	89 e5                	mov    %esp,%ebp
f01162b0:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01162b3:	68 6b a6 12 f0       	push   $0xf012a66b
f01162b8:	68 7a a6 12 f0       	push   $0xf012a67a
f01162bd:	68 4d 08 00 00       	push   $0x84d
f01162c2:	68 42 8b 12 f0       	push   $0xf0128b42
f01162c7:	e8 6d a0 fe ff       	call   f0100339 <_panic>

f01162cc <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f01162cc:	55                   	push   %ebp
f01162cd:	89 e5                	mov    %esp,%ebp
f01162cf:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01162d2:	68 6b a6 12 f0       	push   $0xf012a66b
f01162d7:	68 7a a6 12 f0       	push   $0xf012a67a
f01162dc:	68 5c 08 00 00       	push   $0x85c
f01162e1:	68 42 8b 12 f0       	push   $0xf0128b42
f01162e6:	e8 4e a0 fe ff       	call   f0100339 <_panic>

f01162eb <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f01162eb:	55                   	push   %ebp
f01162ec:	89 e5                	mov    %esp,%ebp
f01162ee:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01162f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01162f4:	c1 e8 16             	shr    $0x16,%eax
f01162f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01162fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0116301:	01 d0                	add    %edx,%eax
f0116303:	8b 00                	mov    (%eax),%eax
f0116305:	83 e0 01             	and    $0x1,%eax
f0116308:	85 c0                	test   %eax,%eax
f011630a:	75 07                	jne    f0116313 <CE+0x28>
f011630c:	b8 00 00 00 00       	mov    $0x0,%eax
f0116311:	eb 7a                	jmp    f011638d <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116313:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116316:	c1 e8 16             	shr    $0x16,%eax
f0116319:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116320:	8b 45 08             	mov    0x8(%ebp),%eax
f0116323:	01 d0                	add    %edx,%eax
f0116325:	8b 00                	mov    (%eax),%eax
f0116327:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011632c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011632f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116332:	c1 e8 0c             	shr    $0xc,%eax
f0116335:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116338:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011633d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116340:	72 17                	jb     f0116359 <CE+0x6e>
f0116342:	ff 75 f4             	pushl  -0xc(%ebp)
f0116345:	68 3c a6 12 f0       	push   $0xf012a63c
f011634a:	68 65 08 00 00       	push   $0x865
f011634f:	68 42 8b 12 f0       	push   $0xf0128b42
f0116354:	e8 e0 9f fe ff       	call   f0100339 <_panic>
f0116359:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011635c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116361:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116364:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116367:	c1 e8 0c             	shr    $0xc,%eax
f011636a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011636f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116376:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116379:	01 d0                	add    %edx,%eax
f011637b:	8b 00                	mov    (%eax),%eax
f011637d:	85 c0                	test   %eax,%eax
f011637f:	74 07                	je     f0116388 <CE+0x9d>
f0116381:	b8 00 00 00 00       	mov    $0x0,%eax
f0116386:	eb 05                	jmp    f011638d <CE+0xa2>
	return 1;
f0116388:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011638d:	c9                   	leave  
f011638e:	c3                   	ret    

f011638f <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f011638f:	55                   	push   %ebp
f0116390:	89 e5                	mov    %esp,%ebp
f0116392:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116395:	68 6b a6 12 f0       	push   $0xf012a66b
f011639a:	68 7a a6 12 f0       	push   $0xf012a67a
f011639f:	68 6c 08 00 00       	push   $0x86c
f01163a4:	68 42 8b 12 f0       	push   $0xf0128b42
f01163a9:	e8 8b 9f fe ff       	call   f0100339 <_panic>

f01163ae <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01163ae:	55                   	push   %ebp
f01163af:	89 e5                	mov    %esp,%ebp
f01163b1:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01163b4:	68 6b a6 12 f0       	push   $0xf012a66b
f01163b9:	68 7a a6 12 f0       	push   $0xf012a67a
f01163be:	68 7c 08 00 00       	push   $0x87c
f01163c3:	68 42 8b 12 f0       	push   $0xf0128b42
f01163c8:	e8 6c 9f fe ff       	call   f0100339 <_panic>

f01163cd <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f01163cd:	55                   	push   %ebp
f01163ce:	89 e5                	mov    %esp,%ebp
f01163d0:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01163d3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01163da:	eb 18                	jmp    f01163f4 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01163dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01163df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01163e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01163e9:	01 d0                	add    %edx,%eax
f01163eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01163f1:	ff 45 fc             	incl   -0x4(%ebp)
f01163f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01163f7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01163fc:	76 de                	jbe    f01163dc <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01163fe:	90                   	nop
f01163ff:	c9                   	leave  
f0116400:	c3                   	ret    

f0116401 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116401:	55                   	push   %ebp
f0116402:	89 e5                	mov    %esp,%ebp
f0116404:	83 ec 38             	sub    $0x38,%esp
f0116407:	8b 45 2c             	mov    0x2c(%ebp),%eax
f011640a:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f011640d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116410:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116415:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116418:	8b 45 10             	mov    0x10(%ebp),%eax
f011641b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116420:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116423:	e9 ea 01 00 00       	jmp    f0116612 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116428:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011642c:	74 44                	je     f0116472 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f011642e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116431:	83 ec 04             	sub    $0x4,%esp
f0116434:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116437:	52                   	push   %edx
f0116438:	50                   	push   %eax
f0116439:	ff 75 08             	pushl  0x8(%ebp)
f011643c:	e8 28 23 ff ff       	call   f0108769 <get_frame_info>
f0116441:	83 c4 10             	add    $0x10,%esp
f0116444:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116447:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011644a:	85 c0                	test   %eax,%eax
f011644c:	75 24                	jne    f0116472 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f011644e:	83 ec 04             	sub    $0x4,%esp
f0116451:	68 90 a6 12 f0       	push   $0xf012a690
f0116456:	68 99 08 00 00       	push   $0x899
f011645b:	68 42 8b 12 f0       	push   $0xf0128b42
f0116460:	e8 71 a0 fe ff       	call   f01004d6 <_warn>
f0116465:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116468:	b8 00 00 00 00       	mov    $0x0,%eax
f011646d:	e9 b6 01 00 00       	jmp    f0116628 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116472:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116475:	83 ec 04             	sub    $0x4,%esp
f0116478:	8d 55 d8             	lea    -0x28(%ebp),%edx
f011647b:	52                   	push   %edx
f011647c:	50                   	push   %eax
f011647d:	ff 75 08             	pushl  0x8(%ebp)
f0116480:	e8 e4 22 ff ff       	call   f0108769 <get_frame_info>
f0116485:	83 c4 10             	add    $0x10,%esp
f0116488:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f011648b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011648e:	85 c0                	test   %eax,%eax
f0116490:	75 24                	jne    f01164b6 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116492:	83 ec 04             	sub    $0x4,%esp
f0116495:	68 bc a6 12 f0       	push   $0xf012a6bc
f011649a:	68 a0 08 00 00       	push   $0x8a0
f011649f:	68 42 8b 12 f0       	push   $0xf0128b42
f01164a4:	e8 2d a0 fe ff       	call   f01004d6 <_warn>
f01164a9:	83 c4 10             	add    $0x10,%esp
			return 0;
f01164ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01164b1:	e9 72 01 00 00       	jmp    f0116628 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f01164b6:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f01164ba:	75 70                	jne    f011652c <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f01164bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01164bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01164c2:	c1 ea 0c             	shr    $0xc,%edx
f01164c5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01164cb:	c1 e2 02             	shl    $0x2,%edx
f01164ce:	01 d0                	add    %edx,%eax
f01164d0:	8b 00                	mov    (%eax),%eax
f01164d2:	c1 e8 0c             	shr    $0xc,%eax
f01164d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f01164d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01164db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01164de:	c1 ea 0c             	shr    $0xc,%edx
f01164e1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01164e7:	c1 e2 02             	shl    $0x2,%edx
f01164ea:	01 d0                	add    %edx,%eax
f01164ec:	8b 00                	mov    (%eax),%eax
f01164ee:	c1 e8 0c             	shr    $0xc,%eax
f01164f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f01164f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01164f7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01164fa:	74 30                	je     f011652c <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f01164fc:	83 ec 04             	sub    $0x4,%esp
f01164ff:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116502:	ff 75 e8             	pushl  -0x18(%ebp)
f0116505:	ff 75 f0             	pushl  -0x10(%ebp)
f0116508:	ff 75 f4             	pushl  -0xc(%ebp)
f011650b:	68 e8 a6 12 f0       	push   $0xf012a6e8
f0116510:	68 aa 08 00 00       	push   $0x8aa
f0116515:	68 42 8b 12 f0       	push   $0xf0128b42
f011651a:	e8 b7 9f fe ff       	call   f01004d6 <_warn>
f011651f:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116522:	b8 00 00 00 00       	mov    $0x0,%eax
f0116527:	e9 fc 00 00 00       	jmp    f0116628 <CCP+0x227>
			}
		}
		if (ref != -1)
f011652c:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116530:	74 52                	je     f0116584 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116532:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116536:	74 0e                	je     f0116546 <CCP+0x145>
f0116538:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011653b:	8b 40 08             	mov    0x8(%eax),%eax
f011653e:	0f b7 c0             	movzwl %ax,%eax
f0116541:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116544:	74 3e                	je     f0116584 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116546:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011654a:	74 0b                	je     f0116557 <CCP+0x156>
f011654c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011654f:	8b 40 08             	mov    0x8(%eax),%eax
f0116552:	0f b7 c0             	movzwl %ax,%eax
f0116555:	eb 05                	jmp    f011655c <CCP+0x15b>
f0116557:	b8 00 00 00 00       	mov    $0x0,%eax
f011655c:	83 ec 0c             	sub    $0xc,%esp
f011655f:	50                   	push   %eax
f0116560:	ff 75 f0             	pushl  -0x10(%ebp)
f0116563:	68 44 a7 12 f0       	push   $0xf012a744
f0116568:	68 b2 08 00 00       	push   $0x8b2
f011656d:	68 42 8b 12 f0       	push   $0xf0128b42
f0116572:	e8 5f 9f fe ff       	call   f01004d6 <_warn>
f0116577:	83 c4 20             	add    $0x20,%esp
				return 0;
f011657a:	b8 00 00 00 00       	mov    $0x0,%eax
f011657f:	e9 a4 00 00 00       	jmp    f0116628 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116584:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116587:	ff 75 20             	pushl  0x20(%ebp)
f011658a:	ff 75 1c             	pushl  0x1c(%ebp)
f011658d:	50                   	push   %eax
f011658e:	ff 75 08             	pushl  0x8(%ebp)
f0116591:	e8 17 fd ff ff       	call   f01162ad <CPs>
f0116596:	83 c4 10             	add    $0x10,%esp
f0116599:	85 c0                	test   %eax,%eax
f011659b:	7f 21                	jg     f01165be <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011659d:	83 ec 04             	sub    $0x4,%esp
f01165a0:	68 b4 a7 12 f0       	push   $0xf012a7b4
f01165a5:	68 b8 08 00 00       	push   $0x8b8
f01165aa:	68 42 8b 12 f0       	push   $0xf0128b42
f01165af:	e8 22 9f fe ff       	call   f01004d6 <_warn>
f01165b4:	83 c4 10             	add    $0x10,%esp
			return 0;
f01165b7:	b8 00 00 00 00       	mov    $0x0,%eax
f01165bc:	eb 6a                	jmp    f0116628 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f01165be:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01165c2:	74 3a                	je     f01165fe <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f01165c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01165c7:	ff 75 28             	pushl  0x28(%ebp)
f01165ca:	ff 75 24             	pushl  0x24(%ebp)
f01165cd:	50                   	push   %eax
f01165ce:	ff 75 08             	pushl  0x8(%ebp)
f01165d1:	e8 d7 fc ff ff       	call   f01162ad <CPs>
f01165d6:	83 c4 10             	add    $0x10,%esp
f01165d9:	85 c0                	test   %eax,%eax
f01165db:	7f 21                	jg     f01165fe <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f01165dd:	83 ec 04             	sub    $0x4,%esp
f01165e0:	68 fc a7 12 f0       	push   $0xf012a7fc
f01165e5:	68 bf 08 00 00       	push   $0x8bf
f01165ea:	68 42 8b 12 f0       	push   $0xf0128b42
f01165ef:	e8 e2 9e fe ff       	call   f01004d6 <_warn>
f01165f4:	83 c4 10             	add    $0x10,%esp
				return 0;
f01165f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01165fc:	eb 2a                	jmp    f0116628 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f01165fe:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116602:	74 07                	je     f011660b <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116604:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011660b:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116612:	8b 55 10             	mov    0x10(%ebp),%edx
f0116615:	8b 45 14             	mov    0x14(%ebp),%eax
f0116618:	01 d0                	add    %edx,%eax
f011661a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011661d:	0f 87 05 fe ff ff    	ja     f0116428 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116623:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116628:	c9                   	leave  
f0116629:	c3                   	ret    

f011662a <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f011662a:	55                   	push   %ebp
f011662b:	89 e5                	mov    %esp,%ebp
f011662d:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116630:	83 ec 04             	sub    $0x4,%esp
f0116633:	68 3c a8 12 f0       	push   $0xf012a83c
f0116638:	6a 0e                	push   $0xe
f011663a:	68 4c a8 12 f0       	push   $0xf012a84c
f011663f:	e8 f5 9c fe ff       	call   f0100339 <_panic>

f0116644 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116644:	55                   	push   %ebp
f0116645:	89 e5                	mov    %esp,%ebp
f0116647:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011664a:	83 ec 04             	sub    $0x4,%esp
f011664d:	68 3c a8 12 f0       	push   $0xf012a83c
f0116652:	68 d7 00 00 00       	push   $0xd7
f0116657:	68 4c a8 12 f0       	push   $0xf012a84c
f011665c:	e8 d8 9c fe ff       	call   f0100339 <_panic>

f0116661 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116661:	55                   	push   %ebp
f0116662:	89 e5                	mov    %esp,%ebp
f0116664:	57                   	push   %edi
f0116665:	53                   	push   %ebx
f0116666:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011666c:	83 ec 0c             	sub    $0xc,%esp
f011666f:	68 68 a8 12 f0       	push   $0xf012a868
f0116674:	e8 12 a9 fe ff       	call   f0100f8b <cprintf>
f0116679:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011667c:	83 ec 0c             	sub    $0xc,%esp
f011667f:	68 98 a8 12 f0       	push   $0xf012a898
f0116684:	e8 02 a9 fe ff       	call   f0100f8b <cprintf>
f0116689:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011668c:	83 ec 0c             	sub    $0xc,%esp
f011668f:	68 68 a8 12 f0       	push   $0xf012a868
f0116694:	e8 f2 a8 fe ff       	call   f0100f8b <cprintf>
f0116699:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011669c:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f01166a0:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f01166a4:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f01166aa:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f01166b0:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f01166b7:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f01166be:	e8 03 7c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01166c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f01166c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01166cd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f01166d4:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01166da:	b9 14 00 00 00       	mov    $0x14,%ecx
f01166df:	b8 00 00 00 00       	mov    $0x0,%eax
f01166e4:	89 d7                	mov    %edx,%edi
f01166e6:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f01166e8:	83 ec 0c             	sub    $0xc,%esp
f01166eb:	68 f1 a8 12 f0       	push   $0xf012a8f1
f01166f0:	e8 96 a8 fe ff       	call   f0100f8b <cprintf>
f01166f5:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01166f8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f01166ff:	e8 c2 7b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116704:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116707:	e8 99 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011670c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f011670f:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116716:	83 ec 0c             	sub    $0xc,%esp
f0116719:	ff 75 cc             	pushl  -0x34(%ebp)
f011671c:	e8 e3 2a ff ff       	call   f0109204 <kmalloc>
f0116721:	83 c4 10             	add    $0x10,%esp
f0116724:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f011672a:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116730:	85 c0                	test   %eax,%eax
f0116732:	74 17                	je     f011674b <test_kmalloc+0xea>
f0116734:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011673b:	83 ec 0c             	sub    $0xc,%esp
f011673e:	68 10 a9 12 f0       	push   $0xf012a910
f0116743:	e8 43 a8 fe ff       	call   f0100f8b <cprintf>
f0116748:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011674b:	e8 55 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116750:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116753:	74 17                	je     f011676c <test_kmalloc+0x10b>
f0116755:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011675c:	83 ec 0c             	sub    $0xc,%esp
f011675f:	68 44 a9 12 f0       	push   $0xf012a944
f0116764:	e8 22 a8 fe ff       	call   f0100f8b <cprintf>
f0116769:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011676c:	e8 55 7b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116771:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116774:	74 17                	je     f011678d <test_kmalloc+0x12c>
f0116776:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011677d:	83 ec 0c             	sub    $0xc,%esp
f0116780:	68 b0 a9 12 f0       	push   $0xf012a9b0
f0116785:	e8 01 a8 fe ff       	call   f0100f8b <cprintf>
f011678a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011678d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116791:	74 04                	je     f0116797 <test_kmalloc+0x136>
f0116793:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116797:	83 ec 0c             	sub    $0xc,%esp
f011679a:	68 f4 a9 12 f0       	push   $0xf012a9f4
f011679f:	e8 e7 a7 fe ff       	call   f0100f8b <cprintf>
f01167a4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01167a7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01167ae:	e8 13 7b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01167b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01167b6:	e8 ea e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01167bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01167be:	83 ec 0c             	sub    $0xc,%esp
f01167c1:	68 00 fc 1f 00       	push   $0x1ffc00
f01167c6:	e8 39 2a ff ff       	call   f0109204 <kmalloc>
f01167cb:	83 c4 10             	add    $0x10,%esp
f01167ce:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01167d4:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01167da:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01167df:	74 17                	je     f01167f8 <test_kmalloc+0x197>
f01167e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01167e8:	83 ec 0c             	sub    $0xc,%esp
f01167eb:	68 38 aa 12 f0       	push   $0xf012aa38
f01167f0:	e8 96 a7 fe ff       	call   f0100f8b <cprintf>
f01167f5:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01167f8:	e8 a8 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01167fd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116800:	74 17                	je     f0116819 <test_kmalloc+0x1b8>
f0116802:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116809:	83 ec 0c             	sub    $0xc,%esp
f011680c:	68 8c aa 12 f0       	push   $0xf012aa8c
f0116811:	e8 75 a7 fe ff       	call   f0100f8b <cprintf>
f0116816:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116819:	e8 a8 7a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011681e:	89 c2                	mov    %eax,%edx
f0116820:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116823:	29 d0                	sub    %edx,%eax
f0116825:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011682a:	7f 17                	jg     f0116843 <test_kmalloc+0x1e2>
f011682c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116833:	83 ec 0c             	sub    $0xc,%esp
f0116836:	68 f8 aa 12 f0       	push   $0xf012aaf8
f011683b:	e8 4b a7 fe ff       	call   f0100f8b <cprintf>
f0116840:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116843:	e8 7e 7a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116848:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011684b:	e8 55 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116850:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116853:	83 ec 0c             	sub    $0xc,%esp
f0116856:	68 00 fc 1f 00       	push   $0x1ffc00
f011685b:	e8 a4 29 ff ff       	call   f0109204 <kmalloc>
f0116860:	83 c4 10             	add    $0x10,%esp
f0116863:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116869:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011686f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116874:	74 17                	je     f011688d <test_kmalloc+0x22c>
f0116876:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011687d:	83 ec 0c             	sub    $0xc,%esp
f0116880:	68 3c ab 12 f0       	push   $0xf012ab3c
f0116885:	e8 01 a7 fe ff       	call   f0100f8b <cprintf>
f011688a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011688d:	e8 13 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116892:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116895:	74 17                	je     f01168ae <test_kmalloc+0x24d>
f0116897:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011689e:	83 ec 0c             	sub    $0xc,%esp
f01168a1:	68 90 ab 12 f0       	push   $0xf012ab90
f01168a6:	e8 e0 a6 fe ff       	call   f0100f8b <cprintf>
f01168ab:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01168ae:	e8 13 7a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01168b3:	89 c2                	mov    %eax,%edx
f01168b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01168b8:	29 d0                	sub    %edx,%eax
f01168ba:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01168bf:	7f 17                	jg     f01168d8 <test_kmalloc+0x277>
f01168c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168c8:	83 ec 0c             	sub    $0xc,%esp
f01168cb:	68 fc ab 12 f0       	push   $0xf012abfc
f01168d0:	e8 b6 a6 fe ff       	call   f0100f8b <cprintf>
f01168d5:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f01168d8:	e8 e9 79 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01168dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01168e0:	e8 c0 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01168e5:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f01168e8:	83 ec 0c             	sub    $0xc,%esp
f01168eb:	68 ff 07 00 00       	push   $0x7ff
f01168f0:	e8 0f 29 ff ff       	call   f0109204 <kmalloc>
f01168f5:	83 c4 10             	add    $0x10,%esp
f01168f8:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01168fe:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116904:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116909:	76 28                	jbe    f0116933 <test_kmalloc+0x2d2>
f011690b:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0116911:	83 ec 0c             	sub    $0xc,%esp
f0116914:	6a 00                	push   $0x0
f0116916:	e8 b6 27 ff ff       	call   f01090d1 <sbrk>
f011691b:	83 c4 10             	add    $0x10,%esp
f011691e:	39 c3                	cmp    %eax,%ebx
f0116920:	73 11                	jae    f0116933 <test_kmalloc+0x2d2>
f0116922:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116928:	89 c2                	mov    %eax,%edx
f011692a:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011692f:	39 c2                	cmp    %eax,%edx
f0116931:	72 17                	jb     f011694a <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116933:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011693a:	83 ec 0c             	sub    $0xc,%esp
f011693d:	68 40 ac 12 f0       	push   $0xf012ac40
f0116942:	e8 44 a6 fe ff       	call   f0100f8b <cprintf>
f0116947:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011694a:	e8 56 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011694f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116952:	74 17                	je     f011696b <test_kmalloc+0x30a>
f0116954:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011695b:	83 ec 0c             	sub    $0xc,%esp
f011695e:	68 cc ac 12 f0       	push   $0xf012accc
f0116963:	e8 23 a6 fe ff       	call   f0100f8b <cprintf>
f0116968:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011696b:	e8 35 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116970:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0116973:	83 ec 0c             	sub    $0xc,%esp
f0116976:	68 ff 07 00 00       	push   $0x7ff
f011697b:	e8 84 28 ff ff       	call   f0109204 <kmalloc>
f0116980:	83 c4 10             	add    $0x10,%esp
f0116983:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0116989:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011698f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116994:	76 28                	jbe    f01169be <test_kmalloc+0x35d>
f0116996:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011699c:	83 ec 0c             	sub    $0xc,%esp
f011699f:	6a 00                	push   $0x0
f01169a1:	e8 2b 27 ff ff       	call   f01090d1 <sbrk>
f01169a6:	83 c4 10             	add    $0x10,%esp
f01169a9:	39 c3                	cmp    %eax,%ebx
f01169ab:	73 11                	jae    f01169be <test_kmalloc+0x35d>
f01169ad:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01169b3:	89 c2                	mov    %eax,%edx
f01169b5:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01169ba:	39 c2                	cmp    %eax,%edx
f01169bc:	72 17                	jb     f01169d5 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01169be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169c5:	83 ec 0c             	sub    $0xc,%esp
f01169c8:	68 38 ad 12 f0       	push   $0xf012ad38
f01169cd:	e8 b9 a5 fe ff       	call   f0100f8b <cprintf>
f01169d2:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169d5:	e8 cb de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01169da:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01169dd:	74 17                	je     f01169f6 <test_kmalloc+0x395>
f01169df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169e6:	83 ec 0c             	sub    $0xc,%esp
f01169e9:	68 c4 ad 12 f0       	push   $0xf012adc4
f01169ee:	e8 98 a5 fe ff       	call   f0100f8b <cprintf>
f01169f3:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f01169f6:	e8 cb 78 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01169fb:	89 c2                	mov    %eax,%edx
f01169fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116a00:	29 d0                	sub    %edx,%eax
f0116a02:	83 f8 01             	cmp    $0x1,%eax
f0116a05:	74 17                	je     f0116a1e <test_kmalloc+0x3bd>
f0116a07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a0e:	83 ec 0c             	sub    $0xc,%esp
f0116a11:	68 30 ae 12 f0       	push   $0xf012ae30
f0116a16:	e8 70 a5 fe ff       	call   f0100f8b <cprintf>
f0116a1b:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a1e:	e8 a3 78 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116a23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a26:	e8 7a de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a2b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0116a2e:	83 ec 0c             	sub    $0xc,%esp
f0116a31:	68 00 1c 00 00       	push   $0x1c00
f0116a36:	e8 c9 27 ff ff       	call   f0109204 <kmalloc>
f0116a3b:	83 c4 10             	add    $0x10,%esp
f0116a3e:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116a44:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0116a4a:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116a4f:	74 17                	je     f0116a68 <test_kmalloc+0x407>
f0116a51:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a58:	83 ec 0c             	sub    $0xc,%esp
f0116a5b:	68 50 ae 12 f0       	push   $0xf012ae50
f0116a60:	e8 26 a5 fe ff       	call   f0100f8b <cprintf>
f0116a65:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116a68:	e8 38 de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a6d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116a70:	74 17                	je     f0116a89 <test_kmalloc+0x428>
f0116a72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a79:	83 ec 0c             	sub    $0xc,%esp
f0116a7c:	68 a4 ae 12 f0       	push   $0xf012aea4
f0116a81:	e8 05 a5 fe ff       	call   f0100f8b <cprintf>
f0116a86:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116a89:	e8 38 78 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116a8e:	89 c2                	mov    %eax,%edx
f0116a90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116a93:	29 d0                	sub    %edx,%eax
f0116a95:	83 f8 01             	cmp    $0x1,%eax
f0116a98:	7f 17                	jg     f0116ab1 <test_kmalloc+0x450>
f0116a9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116aa1:	83 ec 0c             	sub    $0xc,%esp
f0116aa4:	68 10 af 12 f0       	push   $0xf012af10
f0116aa9:	e8 dd a4 fe ff       	call   f0100f8b <cprintf>
f0116aae:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ab1:	e8 10 78 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116ab6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ab9:	e8 e7 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116abe:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0116ac1:	83 ec 0c             	sub    $0xc,%esp
f0116ac4:	68 00 fc 2f 00       	push   $0x2ffc00
f0116ac9:	e8 36 27 ff ff       	call   f0109204 <kmalloc>
f0116ace:	83 c4 10             	add    $0x10,%esp
f0116ad1:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116ad7:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0116add:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0116ae2:	74 17                	je     f0116afb <test_kmalloc+0x49a>
f0116ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116aeb:	83 ec 0c             	sub    $0xc,%esp
f0116aee:	68 54 af 12 f0       	push   $0xf012af54
f0116af3:	e8 93 a4 fe ff       	call   f0100f8b <cprintf>
f0116af8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116afb:	e8 a5 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b00:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116b03:	74 17                	je     f0116b1c <test_kmalloc+0x4bb>
f0116b05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b0c:	83 ec 0c             	sub    $0xc,%esp
f0116b0f:	68 a8 af 12 f0       	push   $0xf012afa8
f0116b14:	e8 72 a4 fe ff       	call   f0100f8b <cprintf>
f0116b19:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116b1c:	e8 a5 77 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116b21:	89 c2                	mov    %eax,%edx
f0116b23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116b26:	29 d0                	sub    %edx,%eax
f0116b28:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116b2d:	7f 17                	jg     f0116b46 <test_kmalloc+0x4e5>
f0116b2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b36:	83 ec 0c             	sub    $0xc,%esp
f0116b39:	68 14 b0 12 f0       	push   $0xf012b014
f0116b3e:	e8 48 a4 fe ff       	call   f0100f8b <cprintf>
f0116b43:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b46:	e8 7b 77 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116b4b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b4e:	e8 52 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b53:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0116b56:	83 ec 0c             	sub    $0xc,%esp
f0116b59:	68 00 fc 5f 00       	push   $0x5ffc00
f0116b5e:	e8 a1 26 ff ff       	call   f0109204 <kmalloc>
f0116b63:	83 c4 10             	add    $0x10,%esp
f0116b66:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116b6c:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116b72:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0116b77:	74 17                	je     f0116b90 <test_kmalloc+0x52f>
f0116b79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b80:	83 ec 0c             	sub    $0xc,%esp
f0116b83:	68 58 b0 12 f0       	push   $0xf012b058
f0116b88:	e8 fe a3 fe ff       	call   f0100f8b <cprintf>
f0116b8d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116b90:	e8 10 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b95:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116b98:	74 17                	je     f0116bb1 <test_kmalloc+0x550>
f0116b9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ba1:	83 ec 0c             	sub    $0xc,%esp
f0116ba4:	68 ac b0 12 f0       	push   $0xf012b0ac
f0116ba9:	e8 dd a3 fe ff       	call   f0100f8b <cprintf>
f0116bae:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116bb1:	e8 10 77 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116bb6:	89 c2                	mov    %eax,%edx
f0116bb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116bbb:	29 d0                	sub    %edx,%eax
f0116bbd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0116bc2:	7f 17                	jg     f0116bdb <test_kmalloc+0x57a>
f0116bc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bcb:	83 ec 0c             	sub    $0xc,%esp
f0116bce:	68 18 b1 12 f0       	push   $0xf012b118
f0116bd3:	e8 b3 a3 fe ff       	call   f0100f8b <cprintf>
f0116bd8:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116bdb:	e8 e6 76 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116be0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116be3:	e8 bd dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116be8:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0116beb:	83 ec 0c             	sub    $0xc,%esp
f0116bee:	68 00 38 00 00       	push   $0x3800
f0116bf3:	e8 0c 26 ff ff       	call   f0109204 <kmalloc>
f0116bf8:	83 c4 10             	add    $0x10,%esp
f0116bfb:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116c01:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116c07:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0116c0c:	74 17                	je     f0116c25 <test_kmalloc+0x5c4>
f0116c0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c15:	83 ec 0c             	sub    $0xc,%esp
f0116c18:	68 5c b1 12 f0       	push   $0xf012b15c
f0116c1d:	e8 69 a3 fe ff       	call   f0100f8b <cprintf>
f0116c22:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116c25:	e8 7b dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116c2a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116c2d:	74 17                	je     f0116c46 <test_kmalloc+0x5e5>
f0116c2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c36:	83 ec 0c             	sub    $0xc,%esp
f0116c39:	68 b0 b1 12 f0       	push   $0xf012b1b0
f0116c3e:	e8 48 a3 fe ff       	call   f0100f8b <cprintf>
f0116c43:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116c46:	e8 7b 76 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116c4b:	89 c2                	mov    %eax,%edx
f0116c4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116c50:	29 d0                	sub    %edx,%eax
f0116c52:	83 f8 03             	cmp    $0x3,%eax
f0116c55:	7f 17                	jg     f0116c6e <test_kmalloc+0x60d>
f0116c57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c5e:	83 ec 0c             	sub    $0xc,%esp
f0116c61:	68 1c b2 12 f0       	push   $0xf012b21c
f0116c66:	e8 20 a3 fe ff       	call   f0100f8b <cprintf>
f0116c6b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0116c6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116c72:	74 04                	je     f0116c78 <test_kmalloc+0x617>
f0116c74:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0116c78:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0116c7f:	83 ec 0c             	sub    $0xc,%esp
f0116c82:	68 60 b2 12 f0       	push   $0xf012b260
f0116c87:	e8 ff a2 fe ff       	call   f0100f8b <cprintf>
f0116c8c:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c8f:	e8 32 76 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0116c94:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116c97:	e8 09 dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116c9c:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0116c9f:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0116ca6:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116cac:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0116caf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116cb2:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116cb5:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0116cb7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116cba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116cbd:	01 c2                	add    %eax,%edx
f0116cbf:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116cc2:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0116cc4:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116cca:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0116ccd:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0116cd4:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116cd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116cda:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0116cdd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116ce0:	01 c0                	add    %eax,%eax
f0116ce2:	89 c2                	mov    %eax,%edx
f0116ce4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ce7:	01 c2                	add    %eax,%edx
f0116ce9:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116ced:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0116cf0:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116cf6:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0116cf9:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0116d00:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116d03:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116d06:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0116d08:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116d0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d12:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116d15:	01 c2                	add    %eax,%edx
f0116d17:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116d1a:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0116d1c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116d22:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0116d25:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0116d2c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d2f:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116d32:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0116d34:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116d37:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d3a:	01 c2                	add    %eax,%edx
f0116d3c:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116d3f:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0116d41:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0116d47:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0116d4a:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0116d51:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d54:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116d57:	88 10                	mov    %dl,(%eax)
f0116d59:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0116d5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116d5f:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116d63:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d66:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116d69:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0116d6c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d6f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116d76:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d79:	01 c2                	add    %eax,%edx
f0116d7b:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116d7e:	88 02                	mov    %al,(%edx)
f0116d80:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d83:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116d8a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d8d:	01 c2                	add    %eax,%edx
f0116d8f:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116d93:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116d97:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d9a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116da1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116da4:	01 c2                	add    %eax,%edx
f0116da6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116da9:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0116dac:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0116db3:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116db9:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0116dbc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116dbf:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116dc2:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0116dc4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116dc7:	89 c2                	mov    %eax,%edx
f0116dc9:	c1 ea 1f             	shr    $0x1f,%edx
f0116dcc:	01 d0                	add    %edx,%eax
f0116dce:	d1 f8                	sar    %eax
f0116dd0:	89 c2                	mov    %eax,%edx
f0116dd2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116dd5:	01 c2                	add    %eax,%edx
f0116dd7:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116dda:	88 c1                	mov    %al,%cl
f0116ddc:	c0 e9 07             	shr    $0x7,%cl
f0116ddf:	01 c8                	add    %ecx,%eax
f0116de1:	d0 f8                	sar    %al
f0116de3:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0116de5:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116de8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116deb:	01 c2                	add    %eax,%edx
f0116ded:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116df0:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0116df2:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116df8:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116dfb:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0116e02:	8b 55 98             	mov    -0x68(%ebp),%edx
f0116e05:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116e08:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116e0b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116e0e:	01 c0                	add    %eax,%eax
f0116e10:	89 c2                	mov    %eax,%edx
f0116e12:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116e15:	01 c2                	add    %eax,%edx
f0116e17:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116e1b:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e1e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116e21:	8a 00                	mov    (%eax),%al
f0116e23:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116e26:	75 0f                	jne    f0116e37 <test_kmalloc+0x7d6>
f0116e28:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116e2b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116e2e:	01 d0                	add    %edx,%eax
f0116e30:	8a 00                	mov    (%eax),%al
f0116e32:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116e35:	74 17                	je     f0116e4e <test_kmalloc+0x7ed>
f0116e37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e3e:	83 ec 0c             	sub    $0xc,%esp
f0116e41:	68 98 b2 12 f0       	push   $0xf012b298
f0116e46:	e8 40 a1 fe ff       	call   f0100f8b <cprintf>
f0116e4b:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116e51:	66 8b 00             	mov    (%eax),%ax
f0116e54:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116e58:	75 15                	jne    f0116e6f <test_kmalloc+0x80e>
f0116e5a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116e5d:	01 c0                	add    %eax,%eax
f0116e5f:	89 c2                	mov    %eax,%edx
f0116e61:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116e64:	01 d0                	add    %edx,%eax
f0116e66:	66 8b 00             	mov    (%eax),%ax
f0116e69:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116e6d:	74 17                	je     f0116e86 <test_kmalloc+0x825>
f0116e6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e76:	83 ec 0c             	sub    $0xc,%esp
f0116e79:	68 d0 b2 12 f0       	push   $0xf012b2d0
f0116e7e:	e8 08 a1 fe ff       	call   f0100f8b <cprintf>
f0116e83:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e86:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116e89:	8b 00                	mov    (%eax),%eax
f0116e8b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116e8e:	75 16                	jne    f0116ea6 <test_kmalloc+0x845>
f0116e90:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116e93:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116e9d:	01 d0                	add    %edx,%eax
f0116e9f:	8b 00                	mov    (%eax),%eax
f0116ea1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116ea4:	74 17                	je     f0116ebd <test_kmalloc+0x85c>
f0116ea6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ead:	83 ec 0c             	sub    $0xc,%esp
f0116eb0:	68 0c b3 12 f0       	push   $0xf012b30c
f0116eb5:	e8 d1 a0 fe ff       	call   f0100f8b <cprintf>
f0116eba:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0116ebd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116ec0:	8a 00                	mov    (%eax),%al
f0116ec2:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116ec5:	75 0f                	jne    f0116ed6 <test_kmalloc+0x875>
f0116ec7:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116eca:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116ecd:	01 d0                	add    %edx,%eax
f0116ecf:	8a 00                	mov    (%eax),%al
f0116ed1:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116ed4:	74 17                	je     f0116eed <test_kmalloc+0x88c>
f0116ed6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116edd:	83 ec 0c             	sub    $0xc,%esp
f0116ee0:	68 48 b3 12 f0       	push   $0xf012b348
f0116ee5:	e8 a1 a0 fe ff       	call   f0100f8b <cprintf>
f0116eea:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0116eed:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ef0:	8a 00                	mov    (%eax),%al
f0116ef2:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116ef5:	75 16                	jne    f0116f0d <test_kmalloc+0x8ac>
f0116ef7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116efa:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116f01:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f04:	01 d0                	add    %edx,%eax
f0116f06:	8a 00                	mov    (%eax),%al
f0116f08:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116f0b:	74 17                	je     f0116f24 <test_kmalloc+0x8c3>
f0116f0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f14:	83 ec 0c             	sub    $0xc,%esp
f0116f17:	68 84 b3 12 f0       	push   $0xf012b384
f0116f1c:	e8 6a a0 fe ff       	call   f0100f8b <cprintf>
f0116f21:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0116f24:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f27:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116f2b:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116f2f:	75 19                	jne    f0116f4a <test_kmalloc+0x8e9>
f0116f31:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116f34:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116f3b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f3e:	01 d0                	add    %edx,%eax
f0116f40:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116f44:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116f48:	74 17                	je     f0116f61 <test_kmalloc+0x900>
f0116f4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f51:	83 ec 0c             	sub    $0xc,%esp
f0116f54:	68 c0 b3 12 f0       	push   $0xf012b3c0
f0116f59:	e8 2d a0 fe ff       	call   f0100f8b <cprintf>
f0116f5e:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0116f61:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f64:	8b 40 04             	mov    0x4(%eax),%eax
f0116f67:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116f6a:	75 17                	jne    f0116f83 <test_kmalloc+0x922>
f0116f6c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116f6f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116f76:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f79:	01 d0                	add    %edx,%eax
f0116f7b:	8b 40 04             	mov    0x4(%eax),%eax
f0116f7e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116f81:	74 17                	je     f0116f9a <test_kmalloc+0x939>
f0116f83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f8a:	83 ec 0c             	sub    $0xc,%esp
f0116f8d:	68 fc b3 12 f0       	push   $0xf012b3fc
f0116f92:	e8 f4 9f fe ff       	call   f0100f8b <cprintf>
f0116f97:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0116f9a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116f9d:	8a 00                	mov    (%eax),%al
f0116f9f:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116fa2:	75 34                	jne    f0116fd8 <test_kmalloc+0x977>
f0116fa4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116fa7:	89 c2                	mov    %eax,%edx
f0116fa9:	c1 ea 1f             	shr    $0x1f,%edx
f0116fac:	01 d0                	add    %edx,%eax
f0116fae:	d1 f8                	sar    %eax
f0116fb0:	89 c2                	mov    %eax,%edx
f0116fb2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116fb5:	01 d0                	add    %edx,%eax
f0116fb7:	8a 10                	mov    (%eax),%dl
f0116fb9:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116fbc:	88 c1                	mov    %al,%cl
f0116fbe:	c0 e9 07             	shr    $0x7,%cl
f0116fc1:	01 c8                	add    %ecx,%eax
f0116fc3:	d0 f8                	sar    %al
f0116fc5:	38 c2                	cmp    %al,%dl
f0116fc7:	75 0f                	jne    f0116fd8 <test_kmalloc+0x977>
f0116fc9:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116fcc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116fcf:	01 d0                	add    %edx,%eax
f0116fd1:	8a 00                	mov    (%eax),%al
f0116fd3:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116fd6:	74 17                	je     f0116fef <test_kmalloc+0x98e>
f0116fd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fdf:	83 ec 0c             	sub    $0xc,%esp
f0116fe2:	68 38 b4 12 f0       	push   $0xf012b438
f0116fe7:	e8 9f 9f fe ff       	call   f0100f8b <cprintf>
f0116fec:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0116fef:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116ff2:	66 8b 00             	mov    (%eax),%ax
f0116ff5:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116ff9:	75 15                	jne    f0117010 <test_kmalloc+0x9af>
f0116ffb:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116ffe:	01 c0                	add    %eax,%eax
f0117000:	89 c2                	mov    %eax,%edx
f0117002:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117005:	01 d0                	add    %edx,%eax
f0117007:	66 8b 00             	mov    (%eax),%ax
f011700a:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011700e:	74 17                	je     f0117027 <test_kmalloc+0x9c6>
f0117010:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117017:	83 ec 0c             	sub    $0xc,%esp
f011701a:	68 70 b4 12 f0       	push   $0xf012b470
f011701f:	e8 67 9f fe ff       	call   f0100f8b <cprintf>
f0117024:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117027:	e8 9a 72 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011702c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011702f:	74 17                	je     f0117048 <test_kmalloc+0x9e7>
f0117031:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117038:	83 ec 0c             	sub    $0xc,%esp
f011703b:	68 ac b4 12 f0       	push   $0xf012b4ac
f0117040:	e8 46 9f fe ff       	call   f0100f8b <cprintf>
f0117045:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117048:	e8 58 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011704d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117050:	74 17                	je     f0117069 <test_kmalloc+0xa08>
f0117052:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117059:	83 ec 0c             	sub    $0xc,%esp
f011705c:	68 f0 b4 12 f0       	push   $0xf012b4f0
f0117061:	e8 25 9f fe ff       	call   f0100f8b <cprintf>
f0117066:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0117069:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011706d:	74 04                	je     f0117073 <test_kmalloc+0xa12>
f011706f:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117073:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f011707a:	83 ec 0c             	sub    $0xc,%esp
f011707d:	68 5c b5 12 f0       	push   $0xf012b55c
f0117082:	e8 04 9f fe ff       	call   f0100f8b <cprintf>
f0117087:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011708a:	e8 37 72 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011708f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117092:	e8 0e d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117097:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f011709a:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		cprintf("restOfKheap : %x\n",restOfKHeap);
f01170a1:	83 ec 08             	sub    $0x8,%esp
f01170a4:	ff 75 90             	pushl  -0x70(%ebp)
f01170a7:	68 80 b5 12 f0       	push   $0xf012b580
f01170ac:	e8 da 9e fe ff       	call   f0100f8b <cprintf>
f01170b1:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f01170b4:	8b 45 90             	mov    -0x70(%ebp),%eax
f01170b7:	40                   	inc    %eax
f01170b8:	83 ec 0c             	sub    $0xc,%esp
f01170bb:	50                   	push   %eax
f01170bc:	e8 43 21 ff ff       	call   f0109204 <kmalloc>
f01170c1:	83 c4 10             	add    $0x10,%esp
f01170c4:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f01170ca:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f01170d0:	85 c0                	test   %eax,%eax
f01170d2:	74 17                	je     f01170eb <test_kmalloc+0xa8a>
f01170d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170db:	83 ec 0c             	sub    $0xc,%esp
f01170de:	68 94 b5 12 f0       	push   $0xf012b594
f01170e3:	e8 a3 9e fe ff       	call   f0100f8b <cprintf>
f01170e8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170eb:	e8 b5 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170f0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170f3:	74 17                	je     f011710c <test_kmalloc+0xaab>
f01170f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170fc:	83 ec 0c             	sub    $0xc,%esp
f01170ff:	68 cc b5 12 f0       	push   $0xf012b5cc
f0117104:	e8 82 9e fe ff       	call   f0100f8b <cprintf>
f0117109:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011710c:	e8 b5 71 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117111:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117114:	74 17                	je     f011712d <test_kmalloc+0xacc>
f0117116:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011711d:	83 ec 0c             	sub    $0xc,%esp
f0117120:	68 38 b6 12 f0       	push   $0xf012b638
f0117125:	e8 61 9e fe ff       	call   f0100f8b <cprintf>
f011712a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011712d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117131:	74 04                	je     f0117137 <test_kmalloc+0xad6>
f0117133:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117137:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f011713e:	83 ec 0c             	sub    $0xc,%esp
f0117141:	68 7c b6 12 f0       	push   $0xf012b67c
f0117146:	e8 40 9e fe ff       	call   f0100f8b <cprintf>
f011714b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f011714e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117154:	05 00 40 00 00       	add    $0x4000,%eax
f0117159:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011715c:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117163:	eb 6a                	jmp    f01171cf <test_kmalloc+0xb6e>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117165:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011716a:	83 ec 04             	sub    $0x4,%esp
f011716d:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117173:	52                   	push   %edx
f0117174:	ff 75 ec             	pushl  -0x14(%ebp)
f0117177:	50                   	push   %eax
f0117178:	e8 72 12 ff ff       	call   f01083ef <get_page_table>
f011717d:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117180:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117186:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117189:	c1 ea 0c             	shr    $0xc,%edx
f011718c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117192:	c1 e2 02             	shl    $0x2,%edx
f0117195:	01 d0                	add    %edx,%eax
f0117197:	8b 00                	mov    (%eax),%eax
f0117199:	25 ff 0f 00 00       	and    $0xfff,%eax
f011719e:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f01171a1:	8b 45 88             	mov    -0x78(%ebp),%eax
f01171a4:	83 e0 04             	and    $0x4,%eax
f01171a7:	85 c0                	test   %eax,%eax
f01171a9:	74 1d                	je     f01171c8 <test_kmalloc+0xb67>
			{
				if (correct)
f01171ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01171af:	74 17                	je     f01171c8 <test_kmalloc+0xb67>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f01171b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171b8:	83 ec 0c             	sub    $0xc,%esp
f01171bb:	68 c0 b6 12 f0       	push   $0xf012b6c0
f01171c0:	e8 c6 9d fe ff       	call   f0100f8b <cprintf>
f01171c5:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01171c8:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f01171cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01171d2:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01171d5:	72 8e                	jb     f0117165 <test_kmalloc+0xb04>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f01171d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01171db:	74 04                	je     f01171e1 <test_kmalloc+0xb80>
f01171dd:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01171e1:	83 ec 08             	sub    $0x8,%esp
f01171e4:	ff 75 f4             	pushl  -0xc(%ebp)
f01171e7:	68 10 b7 12 f0       	push   $0xf012b710
f01171ec:	e8 9a 9d fe ff       	call   f0100f8b <cprintf>
f01171f1:	83 c4 10             	add    $0x10,%esp

	return 1;
f01171f4:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01171f9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01171fc:	5b                   	pop    %ebx
f01171fd:	5f                   	pop    %edi
f01171fe:	5d                   	pop    %ebp
f01171ff:	c3                   	ret    

f0117200 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0117200:	55                   	push   %ebp
f0117201:	89 e5                	mov    %esp,%ebp
f0117203:	57                   	push   %edi
f0117204:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117207:	83 ec 0c             	sub    $0xc,%esp
f011720a:	68 68 a8 12 f0       	push   $0xf012a868
f011720f:	e8 77 9d fe ff       	call   f0100f8b <cprintf>
f0117214:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117217:	83 ec 0c             	sub    $0xc,%esp
f011721a:	68 98 a8 12 f0       	push   $0xf012a898
f011721f:	e8 67 9d fe ff       	call   f0100f8b <cprintf>
f0117224:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117227:	83 ec 0c             	sub    $0xc,%esp
f011722a:	68 68 a8 12 f0       	push   $0xf012a868
f011722f:	e8 57 9d fe ff       	call   f0100f8b <cprintf>
f0117234:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117237:	8d 55 98             	lea    -0x68(%ebp),%edx
f011723a:	b9 14 00 00 00       	mov    $0x14,%ecx
f011723f:	b8 00 00 00 00       	mov    $0x0,%eax
f0117244:	89 d7                	mov    %edx,%edi
f0117246:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117248:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011724f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117256:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f011725d:	83 ec 0c             	sub    $0xc,%esp
f0117260:	68 3c b7 12 f0       	push   $0xf012b73c
f0117265:	e8 21 9d fe ff       	call   f0100f8b <cprintf>
f011726a:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011726d:	e8 54 70 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117272:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117275:	e8 2b d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011727a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011727d:	83 ec 0c             	sub    $0xc,%esp
f0117280:	68 00 fc 0f 00       	push   $0xffc00
f0117285:	e8 7a 1f ff ff       	call   f0109204 <kmalloc>
f011728a:	83 c4 10             	add    $0x10,%esp
f011728d:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117290:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117293:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117298:	74 17                	je     f01172b1 <test_kmalloc_firstfit1+0xb1>
f011729a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172a1:	83 ec 0c             	sub    $0xc,%esp
f01172a4:	68 7c b7 12 f0       	push   $0xf012b77c
f01172a9:	e8 dd 9c fe ff       	call   f0100f8b <cprintf>
f01172ae:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172b1:	e8 ef d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172b6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01172b9:	74 17                	je     f01172d2 <test_kmalloc_firstfit1+0xd2>
f01172bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172c2:	83 ec 0c             	sub    $0xc,%esp
f01172c5:	68 8c aa 12 f0       	push   $0xf012aa8c
f01172ca:	e8 bc 9c fe ff       	call   f0100f8b <cprintf>
f01172cf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f01172d2:	e8 ef 6f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01172d7:	89 c2                	mov    %eax,%edx
f01172d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01172dc:	29 d0                	sub    %edx,%eax
f01172de:	3d ff 00 00 00       	cmp    $0xff,%eax
f01172e3:	7f 17                	jg     f01172fc <test_kmalloc_firstfit1+0xfc>
f01172e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ec:	83 ec 0c             	sub    $0xc,%esp
f01172ef:	68 af b7 12 f0       	push   $0xf012b7af
f01172f4:	e8 92 9c fe ff       	call   f0100f8b <cprintf>
f01172f9:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172fc:	e8 c5 6f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117301:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117304:	e8 9c d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117309:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f011730c:	83 ec 0c             	sub    $0xc,%esp
f011730f:	68 00 fc 0f 00       	push   $0xffc00
f0117314:	e8 eb 1e ff ff       	call   f0109204 <kmalloc>
f0117319:	83 c4 10             	add    $0x10,%esp
f011731c:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f011731f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117322:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117327:	74 17                	je     f0117340 <test_kmalloc_firstfit1+0x140>
f0117329:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117330:	83 ec 0c             	sub    $0xc,%esp
f0117333:	68 c8 b7 12 f0       	push   $0xf012b7c8
f0117338:	e8 4e 9c fe ff       	call   f0100f8b <cprintf>
f011733d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117340:	e8 60 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117345:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117348:	74 17                	je     f0117361 <test_kmalloc_firstfit1+0x161>
f011734a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117351:	83 ec 0c             	sub    $0xc,%esp
f0117354:	68 90 ab 12 f0       	push   $0xf012ab90
f0117359:	e8 2d 9c fe ff       	call   f0100f8b <cprintf>
f011735e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117361:	e8 60 6f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117366:	89 c2                	mov    %eax,%edx
f0117368:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011736b:	29 d0                	sub    %edx,%eax
f011736d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117372:	7f 17                	jg     f011738b <test_kmalloc_firstfit1+0x18b>
f0117374:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011737b:	83 ec 0c             	sub    $0xc,%esp
f011737e:	68 fb b7 12 f0       	push   $0xf012b7fb
f0117383:	e8 03 9c fe ff       	call   f0100f8b <cprintf>
f0117388:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011738b:	e8 36 6f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117390:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117393:	e8 0d d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117398:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f011739b:	83 ec 0c             	sub    $0xc,%esp
f011739e:	68 00 fc 0f 00       	push   $0xffc00
f01173a3:	e8 5c 1e ff ff       	call   f0109204 <kmalloc>
f01173a8:	83 c4 10             	add    $0x10,%esp
f01173ab:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01173ae:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01173b1:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01173b6:	74 17                	je     f01173cf <test_kmalloc_firstfit1+0x1cf>
f01173b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173bf:	83 ec 0c             	sub    $0xc,%esp
f01173c2:	68 14 b8 12 f0       	push   $0xf012b814
f01173c7:	e8 bf 9b fe ff       	call   f0100f8b <cprintf>
f01173cc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173cf:	e8 d1 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01173d4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01173d7:	74 17                	je     f01173f0 <test_kmalloc_firstfit1+0x1f0>
f01173d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173e0:	83 ec 0c             	sub    $0xc,%esp
f01173e3:	68 cc ac 12 f0       	push   $0xf012accc
f01173e8:	e8 9e 9b fe ff       	call   f0100f8b <cprintf>
f01173ed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01173f0:	e8 d1 6e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01173f5:	89 c2                	mov    %eax,%edx
f01173f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01173fa:	29 d0                	sub    %edx,%eax
f01173fc:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117401:	7f 17                	jg     f011741a <test_kmalloc_firstfit1+0x21a>
f0117403:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011740a:	83 ec 0c             	sub    $0xc,%esp
f011740d:	68 47 b8 12 f0       	push   $0xf012b847
f0117412:	e8 74 9b fe ff       	call   f0100f8b <cprintf>
f0117417:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011741a:	e8 a7 6e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011741f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117422:	e8 7e d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f011742a:	83 ec 0c             	sub    $0xc,%esp
f011742d:	68 00 fc 0f 00       	push   $0xffc00
f0117432:	e8 cd 1d ff ff       	call   f0109204 <kmalloc>
f0117437:	83 c4 10             	add    $0x10,%esp
f011743a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f011743d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117440:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117445:	74 17                	je     f011745e <test_kmalloc_firstfit1+0x25e>
f0117447:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011744e:	83 ec 0c             	sub    $0xc,%esp
f0117451:	68 60 b8 12 f0       	push   $0xf012b860
f0117456:	e8 30 9b fe ff       	call   f0100f8b <cprintf>
f011745b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011745e:	e8 42 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117463:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117466:	74 17                	je     f011747f <test_kmalloc_firstfit1+0x27f>
f0117468:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011746f:	83 ec 0c             	sub    $0xc,%esp
f0117472:	68 c4 ad 12 f0       	push   $0xf012adc4
f0117477:	e8 0f 9b fe ff       	call   f0100f8b <cprintf>
f011747c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011747f:	e8 42 6e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117484:	89 c2                	mov    %eax,%edx
f0117486:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117489:	29 d0                	sub    %edx,%eax
f011748b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117490:	7f 17                	jg     f01174a9 <test_kmalloc_firstfit1+0x2a9>
f0117492:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117499:	83 ec 0c             	sub    $0xc,%esp
f011749c:	68 93 b8 12 f0       	push   $0xf012b893
f01174a1:	e8 e5 9a fe ff       	call   f0100f8b <cprintf>
f01174a6:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01174a9:	e8 18 6e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01174ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174b1:	e8 ef d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01174b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f01174b9:	83 ec 0c             	sub    $0xc,%esp
f01174bc:	68 00 fc 1f 00       	push   $0x1ffc00
f01174c1:	e8 3e 1d ff ff       	call   f0109204 <kmalloc>
f01174c6:	83 c4 10             	add    $0x10,%esp
f01174c9:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f01174cc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174cf:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01174d4:	74 17                	je     f01174ed <test_kmalloc_firstfit1+0x2ed>
f01174d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174dd:	83 ec 0c             	sub    $0xc,%esp
f01174e0:	68 ac b8 12 f0       	push   $0xf012b8ac
f01174e5:	e8 a1 9a fe ff       	call   f0100f8b <cprintf>
f01174ea:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174ed:	e8 b3 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01174f2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01174f5:	74 17                	je     f011750e <test_kmalloc_firstfit1+0x30e>
f01174f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174fe:	83 ec 0c             	sub    $0xc,%esp
f0117501:	68 a4 ae 12 f0       	push   $0xf012aea4
f0117506:	e8 80 9a fe ff       	call   f0100f8b <cprintf>
f011750b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f011750e:	e8 b3 6d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117513:	89 c2                	mov    %eax,%edx
f0117515:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117518:	29 d0                	sub    %edx,%eax
f011751a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011751f:	7f 17                	jg     f0117538 <test_kmalloc_firstfit1+0x338>
f0117521:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117528:	83 ec 0c             	sub    $0xc,%esp
f011752b:	68 df b8 12 f0       	push   $0xf012b8df
f0117530:	e8 56 9a fe ff       	call   f0100f8b <cprintf>
f0117535:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117538:	e8 89 6d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011753d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117540:	e8 60 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117545:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117548:	83 ec 0c             	sub    $0xc,%esp
f011754b:	68 00 fc 1f 00       	push   $0x1ffc00
f0117550:	e8 af 1c ff ff       	call   f0109204 <kmalloc>
f0117555:	83 c4 10             	add    $0x10,%esp
f0117558:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f011755b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011755e:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117563:	74 17                	je     f011757c <test_kmalloc_firstfit1+0x37c>
f0117565:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011756c:	83 ec 0c             	sub    $0xc,%esp
f011756f:	68 f8 b8 12 f0       	push   $0xf012b8f8
f0117574:	e8 12 9a fe ff       	call   f0100f8b <cprintf>
f0117579:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011757c:	e8 24 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117581:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117584:	74 17                	je     f011759d <test_kmalloc_firstfit1+0x39d>
f0117586:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011758d:	83 ec 0c             	sub    $0xc,%esp
f0117590:	68 a8 af 12 f0       	push   $0xf012afa8
f0117595:	e8 f1 99 fe ff       	call   f0100f8b <cprintf>
f011759a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f011759d:	e8 24 6d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01175a2:	89 c2                	mov    %eax,%edx
f01175a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01175a7:	29 d0                	sub    %edx,%eax
f01175a9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01175ae:	7f 17                	jg     f01175c7 <test_kmalloc_firstfit1+0x3c7>
f01175b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175b7:	83 ec 0c             	sub    $0xc,%esp
f01175ba:	68 2b b9 12 f0       	push   $0xf012b92b
f01175bf:	e8 c7 99 fe ff       	call   f0100f8b <cprintf>
f01175c4:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01175c7:	e8 fa 6c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01175cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01175cf:	e8 d1 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01175d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01175d7:	83 ec 0c             	sub    $0xc,%esp
f01175da:	68 00 fc 2f 00       	push   $0x2ffc00
f01175df:	e8 20 1c ff ff       	call   f0109204 <kmalloc>
f01175e4:	83 c4 10             	add    $0x10,%esp
f01175e7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01175ea:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175ed:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01175f2:	74 17                	je     f011760b <test_kmalloc_firstfit1+0x40b>
f01175f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175fb:	83 ec 0c             	sub    $0xc,%esp
f01175fe:	68 44 b9 12 f0       	push   $0xf012b944
f0117603:	e8 83 99 fe ff       	call   f0100f8b <cprintf>
f0117608:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011760b:	e8 95 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117610:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117613:	74 17                	je     f011762c <test_kmalloc_firstfit1+0x42c>
f0117615:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011761c:	83 ec 0c             	sub    $0xc,%esp
f011761f:	68 ac b0 12 f0       	push   $0xf012b0ac
f0117624:	e8 62 99 fe ff       	call   f0100f8b <cprintf>
f0117629:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f011762c:	e8 95 6c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117631:	89 c2                	mov    %eax,%edx
f0117633:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117636:	29 d0                	sub    %edx,%eax
f0117638:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011763d:	7f 17                	jg     f0117656 <test_kmalloc_firstfit1+0x456>
f011763f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117646:	83 ec 0c             	sub    $0xc,%esp
f0117649:	68 77 b9 12 f0       	push   $0xf012b977
f011764e:	e8 38 99 fe ff       	call   f0100f8b <cprintf>
f0117653:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117656:	e8 6b 6c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011765b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011765e:	e8 42 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117663:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117666:	83 ec 0c             	sub    $0xc,%esp
f0117669:	68 00 fc 2f 00       	push   $0x2ffc00
f011766e:	e8 91 1b ff ff       	call   f0109204 <kmalloc>
f0117673:	83 c4 10             	add    $0x10,%esp
f0117676:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117679:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011767c:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117681:	74 17                	je     f011769a <test_kmalloc_firstfit1+0x49a>
f0117683:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011768a:	83 ec 0c             	sub    $0xc,%esp
f011768d:	68 90 b9 12 f0       	push   $0xf012b990
f0117692:	e8 f4 98 fe ff       	call   f0100f8b <cprintf>
f0117697:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011769a:	e8 06 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011769f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176a2:	74 17                	je     f01176bb <test_kmalloc_firstfit1+0x4bb>
f01176a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176ab:	83 ec 0c             	sub    $0xc,%esp
f01176ae:	68 b0 b1 12 f0       	push   $0xf012b1b0
f01176b3:	e8 d3 98 fe ff       	call   f0100f8b <cprintf>
f01176b8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f01176bb:	e8 06 6c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01176c0:	89 c2                	mov    %eax,%edx
f01176c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01176c5:	29 d0                	sub    %edx,%eax
f01176c7:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01176cc:	7f 17                	jg     f01176e5 <test_kmalloc_firstfit1+0x4e5>
f01176ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176d5:	83 ec 0c             	sub    $0xc,%esp
f01176d8:	68 c3 b9 12 f0       	push   $0xf012b9c3
f01176dd:	e8 a9 98 fe ff       	call   f0100f8b <cprintf>
f01176e2:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01176e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01176e9:	74 04                	je     f01176ef <test_kmalloc_firstfit1+0x4ef>
f01176eb:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01176ef:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f01176f6:	83 ec 0c             	sub    $0xc,%esp
f01176f9:	68 dc b9 12 f0       	push   $0xf012b9dc
f01176fe:	e8 88 98 fe ff       	call   f0100f8b <cprintf>
f0117703:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117706:	e8 bb 6b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011770b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011770e:	e8 92 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117713:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117716:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117719:	83 ec 0c             	sub    $0xc,%esp
f011771c:	50                   	push   %eax
f011771d:	e8 42 1d ff ff       	call   f0109464 <kfree>
f0117722:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117725:	e8 7b d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011772a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011772d:	74 17                	je     f0117746 <test_kmalloc_firstfit1+0x546>
f011772f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117736:	83 ec 0c             	sub    $0xc,%esp
f0117739:	68 04 ba 12 f0       	push   $0xf012ba04
f011773e:	e8 48 98 fe ff       	call   f0100f8b <cprintf>
f0117743:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117746:	e8 7b 6b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011774b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011774e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117753:	7f 17                	jg     f011776c <test_kmalloc_firstfit1+0x56c>
f0117755:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011775c:	83 ec 0c             	sub    $0xc,%esp
f011775f:	68 6f ba 12 f0       	push   $0xf012ba6f
f0117764:	e8 22 98 fe ff       	call   f0100f8b <cprintf>
f0117769:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011776c:	e8 55 6b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117771:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117774:	e8 2c d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117779:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011777c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011777f:	83 ec 0c             	sub    $0xc,%esp
f0117782:	50                   	push   %eax
f0117783:	e8 dc 1c ff ff       	call   f0109464 <kfree>
f0117788:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011778b:	e8 15 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117790:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117793:	74 17                	je     f01177ac <test_kmalloc_firstfit1+0x5ac>
f0117795:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011779c:	83 ec 0c             	sub    $0xc,%esp
f011779f:	68 80 ba 12 f0       	push   $0xf012ba80
f01177a4:	e8 e2 97 fe ff       	call   f0100f8b <cprintf>
f01177a9:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f01177ac:	e8 15 6b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01177b1:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01177b4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01177b9:	7f 17                	jg     f01177d2 <test_kmalloc_firstfit1+0x5d2>
f01177bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177c2:	83 ec 0c             	sub    $0xc,%esp
f01177c5:	68 ec ba 12 f0       	push   $0xf012baec
f01177ca:	e8 bc 97 fe ff       	call   f0100f8b <cprintf>
f01177cf:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01177d2:	e8 ef 6a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01177d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01177da:	e8 c6 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01177df:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01177e2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01177e5:	83 ec 0c             	sub    $0xc,%esp
f01177e8:	50                   	push   %eax
f01177e9:	e8 76 1c ff ff       	call   f0109464 <kfree>
f01177ee:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177f1:	e8 af d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01177f6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01177f9:	74 17                	je     f0117812 <test_kmalloc_firstfit1+0x612>
f01177fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117802:	83 ec 0c             	sub    $0xc,%esp
f0117805:	68 00 bb 12 f0       	push   $0xf012bb00
f011780a:	e8 7c 97 fe ff       	call   f0100f8b <cprintf>
f011780f:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117812:	e8 af 6a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117817:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011781a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011781f:	7f 17                	jg     f0117838 <test_kmalloc_firstfit1+0x638>
f0117821:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117828:	83 ec 0c             	sub    $0xc,%esp
f011782b:	68 6c bb 12 f0       	push   $0xf012bb6c
f0117830:	e8 56 97 fe ff       	call   f0100f8b <cprintf>
f0117835:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117838:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011783c:	74 04                	je     f0117842 <test_kmalloc_firstfit1+0x642>
f011783e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117842:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117849:	83 ec 0c             	sub    $0xc,%esp
f011784c:	68 80 bb 12 f0       	push   $0xf012bb80
f0117851:	e8 35 97 fe ff       	call   f0100f8b <cprintf>
f0117856:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117859:	e8 68 6a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011785e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117861:	e8 3f d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117866:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117869:	83 ec 0c             	sub    $0xc,%esp
f011786c:	68 00 fc 07 00       	push   $0x7fc00
f0117871:	e8 8e 19 ff ff       	call   f0109204 <kmalloc>
f0117876:	83 c4 10             	add    $0x10,%esp
f0117879:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f011787c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011787f:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117884:	74 17                	je     f011789d <test_kmalloc_firstfit1+0x69d>
f0117886:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011788d:	83 ec 0c             	sub    $0xc,%esp
f0117890:	68 ac bb 12 f0       	push   $0xf012bbac
f0117895:	e8 f1 96 fe ff       	call   f0100f8b <cprintf>
f011789a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011789d:	e8 03 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178a2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178a5:	74 17                	je     f01178be <test_kmalloc_firstfit1+0x6be>
f01178a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178ae:	83 ec 0c             	sub    $0xc,%esp
f01178b1:	68 e0 bb 12 f0       	push   $0xf012bbe0
f01178b6:	e8 d0 96 fe ff       	call   f0100f8b <cprintf>
f01178bb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f01178be:	e8 03 6a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01178c3:	89 c2                	mov    %eax,%edx
f01178c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01178c8:	29 d0                	sub    %edx,%eax
f01178ca:	83 f8 7f             	cmp    $0x7f,%eax
f01178cd:	7f 17                	jg     f01178e6 <test_kmalloc_firstfit1+0x6e6>
f01178cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178d6:	83 ec 0c             	sub    $0xc,%esp
f01178d9:	68 4c bc 12 f0       	push   $0xf012bc4c
f01178de:	e8 a8 96 fe ff       	call   f0100f8b <cprintf>
f01178e3:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01178e6:	e8 db 69 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01178eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178ee:	e8 b2 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f01178f6:	83 ec 0c             	sub    $0xc,%esp
f01178f9:	68 00 fc 0f 00       	push   $0xffc00
f01178fe:	e8 01 19 ff ff       	call   f0109204 <kmalloc>
f0117903:	83 c4 10             	add    $0x10,%esp
f0117906:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0117909:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011790c:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117911:	74 17                	je     f011792a <test_kmalloc_firstfit1+0x72a>
f0117913:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011791a:	83 ec 0c             	sub    $0xc,%esp
f011791d:	68 64 bc 12 f0       	push   $0xf012bc64
f0117922:	e8 64 96 fe ff       	call   f0100f8b <cprintf>
f0117927:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011792a:	e8 76 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011792f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117932:	74 17                	je     f011794b <test_kmalloc_firstfit1+0x74b>
f0117934:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011793b:	83 ec 0c             	sub    $0xc,%esp
f011793e:	68 98 bc 12 f0       	push   $0xf012bc98
f0117943:	e8 43 96 fe ff       	call   f0100f8b <cprintf>
f0117948:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f011794b:	e8 76 69 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117950:	89 c2                	mov    %eax,%edx
f0117952:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117955:	29 d0                	sub    %edx,%eax
f0117957:	3d ff 00 00 00       	cmp    $0xff,%eax
f011795c:	7f 17                	jg     f0117975 <test_kmalloc_firstfit1+0x775>
f011795e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117965:	83 ec 0c             	sub    $0xc,%esp
f0117968:	68 04 bd 12 f0       	push   $0xf012bd04
f011796d:	e8 19 96 fe ff       	call   f0100f8b <cprintf>
f0117972:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117975:	e8 4c 69 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011797a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011797d:	e8 23 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117982:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0117985:	83 ec 0c             	sub    $0xc,%esp
f0117988:	68 00 fc 03 00       	push   $0x3fc00
f011798d:	e8 72 18 ff ff       	call   f0109204 <kmalloc>
f0117992:	83 c4 10             	add    $0x10,%esp
f0117995:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0117998:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011799b:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f01179a0:	74 17                	je     f01179b9 <test_kmalloc_firstfit1+0x7b9>
f01179a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179a9:	83 ec 0c             	sub    $0xc,%esp
f01179ac:	68 1c bd 12 f0       	push   $0xf012bd1c
f01179b1:	e8 d5 95 fe ff       	call   f0100f8b <cprintf>
f01179b6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179b9:	e8 e7 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179be:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179c1:	74 17                	je     f01179da <test_kmalloc_firstfit1+0x7da>
f01179c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179ca:	83 ec 0c             	sub    $0xc,%esp
f01179cd:	68 50 bd 12 f0       	push   $0xf012bd50
f01179d2:	e8 b4 95 fe ff       	call   f0100f8b <cprintf>
f01179d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f01179da:	e8 e7 68 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01179df:	89 c2                	mov    %eax,%edx
f01179e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179e4:	29 d0                	sub    %edx,%eax
f01179e6:	83 f8 3f             	cmp    $0x3f,%eax
f01179e9:	7f 17                	jg     f0117a02 <test_kmalloc_firstfit1+0x802>
f01179eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179f2:	83 ec 0c             	sub    $0xc,%esp
f01179f5:	68 bc bd 12 f0       	push   $0xf012bdbc
f01179fa:	e8 8c 95 fe ff       	call   f0100f8b <cprintf>
f01179ff:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a02:	e8 bf 68 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117a07:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a0a:	e8 96 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0117a12:	83 ec 0c             	sub    $0xc,%esp
f0117a15:	68 00 00 20 00       	push   $0x200000
f0117a1a:	e8 e5 17 ff ff       	call   f0109204 <kmalloc>
f0117a1f:	83 c4 10             	add    $0x10,%esp
f0117a22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0117a25:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117a28:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117a2d:	74 17                	je     f0117a46 <test_kmalloc_firstfit1+0x846>
f0117a2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a36:	83 ec 0c             	sub    $0xc,%esp
f0117a39:	68 d4 bd 12 f0       	push   $0xf012bdd4
f0117a3e:	e8 48 95 fe ff       	call   f0100f8b <cprintf>
f0117a43:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0117a46:	e8 7b 68 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117a4b:	89 c2                	mov    %eax,%edx
f0117a4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a50:	29 d0                	sub    %edx,%eax
f0117a52:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117a57:	7f 17                	jg     f0117a70 <test_kmalloc_firstfit1+0x870>
f0117a59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a60:	83 ec 0c             	sub    $0xc,%esp
f0117a63:	68 08 be 12 f0       	push   $0xf012be08
f0117a68:	e8 1e 95 fe ff       	call   f0100f8b <cprintf>
f0117a6d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a70:	e8 30 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a75:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a78:	74 17                	je     f0117a91 <test_kmalloc_firstfit1+0x891>
f0117a7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a81:	83 ec 0c             	sub    $0xc,%esp
f0117a84:	68 20 be 12 f0       	push   $0xf012be20
f0117a89:	e8 fd 94 fe ff       	call   f0100f8b <cprintf>
f0117a8e:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a91:	e8 30 68 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117a96:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a99:	e8 07 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0117aa1:	83 ec 0c             	sub    $0xc,%esp
f0117aa4:	68 00 fc 3f 00       	push   $0x3ffc00
f0117aa9:	e8 56 17 ff ff       	call   f0109204 <kmalloc>
f0117aae:	83 c4 10             	add    $0x10,%esp
f0117ab1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0117ab4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117ab7:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0117abc:	74 17                	je     f0117ad5 <test_kmalloc_firstfit1+0x8d5>
f0117abe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ac5:	83 ec 0c             	sub    $0xc,%esp
f0117ac8:	68 8c be 12 f0       	push   $0xf012be8c
f0117acd:	e8 b9 94 fe ff       	call   f0100f8b <cprintf>
f0117ad2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ad5:	e8 cb cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ada:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117add:	74 17                	je     f0117af6 <test_kmalloc_firstfit1+0x8f6>
f0117adf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ae6:	83 ec 0c             	sub    $0xc,%esp
f0117ae9:	68 c0 be 12 f0       	push   $0xf012bec0
f0117aee:	e8 98 94 fe ff       	call   f0100f8b <cprintf>
f0117af3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0117af6:	e8 cb 67 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117afb:	89 c2                	mov    %eax,%edx
f0117afd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b00:	29 d0                	sub    %edx,%eax
f0117b02:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0117b07:	7f 17                	jg     f0117b20 <test_kmalloc_firstfit1+0x920>
f0117b09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b10:	83 ec 0c             	sub    $0xc,%esp
f0117b13:	68 2c bf 12 f0       	push   $0xf012bf2c
f0117b18:	e8 6e 94 fe ff       	call   f0100f8b <cprintf>
f0117b1d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117b20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b24:	74 04                	je     f0117b2a <test_kmalloc_firstfit1+0x92a>
f0117b26:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117b2a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0117b31:	83 ec 0c             	sub    $0xc,%esp
f0117b34:	68 44 bf 12 f0       	push   $0xf012bf44
f0117b39:	e8 4d 94 fe ff       	call   f0100f8b <cprintf>
f0117b3e:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b41:	e8 80 67 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117b46:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b49:	e8 57 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0117b51:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117b54:	83 ec 0c             	sub    $0xc,%esp
f0117b57:	50                   	push   %eax
f0117b58:	e8 07 19 ff ff       	call   f0109464 <kfree>
f0117b5d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b60:	e8 40 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b65:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b68:	74 17                	je     f0117b81 <test_kmalloc_firstfit1+0x981>
f0117b6a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b71:	83 ec 0c             	sub    $0xc,%esp
f0117b74:	68 f0 b4 12 f0       	push   $0xf012b4f0
f0117b79:	e8 0d 94 fe ff       	call   f0100f8b <cprintf>
f0117b7e:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0117b81:	e8 40 67 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117b86:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117b89:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b8e:	7f 17                	jg     f0117ba7 <test_kmalloc_firstfit1+0x9a7>
f0117b90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b97:	83 ec 0c             	sub    $0xc,%esp
f0117b9a:	68 78 bf 12 f0       	push   $0xf012bf78
f0117b9f:	e8 e7 93 fe ff       	call   f0100f8b <cprintf>
f0117ba4:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ba7:	e8 1a 67 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117bac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117baf:	e8 f1 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0117bb7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117bba:	83 ec 0c             	sub    $0xc,%esp
f0117bbd:	50                   	push   %eax
f0117bbe:	e8 a1 18 ff ff       	call   f0109464 <kfree>
f0117bc3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117bc6:	e8 da cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bcb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117bce:	74 17                	je     f0117be7 <test_kmalloc_firstfit1+0x9e7>
f0117bd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bd7:	83 ec 0c             	sub    $0xc,%esp
f0117bda:	68 cc b5 12 f0       	push   $0xf012b5cc
f0117bdf:	e8 a7 93 fe ff       	call   f0100f8b <cprintf>
f0117be4:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0117be7:	e8 da 66 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117bec:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117bef:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117bf4:	7f 17                	jg     f0117c0d <test_kmalloc_firstfit1+0xa0d>
f0117bf6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bfd:	83 ec 0c             	sub    $0xc,%esp
f0117c00:	68 89 bf 12 f0       	push   $0xf012bf89
f0117c05:	e8 81 93 fe ff       	call   f0100f8b <cprintf>
f0117c0a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117c0d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117c11:	74 04                	je     f0117c17 <test_kmalloc_firstfit1+0xa17>
f0117c13:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117c17:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0117c1e:	83 ec 0c             	sub    $0xc,%esp
f0117c21:	68 9c bf 12 f0       	push   $0xf012bf9c
f0117c26:	e8 60 93 fe ff       	call   f0100f8b <cprintf>
f0117c2b:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c2e:	e8 93 66 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c36:	e8 6a cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0117c3e:	83 ec 0c             	sub    $0xc,%esp
f0117c41:	68 00 00 10 00       	push   $0x100000
f0117c46:	e8 b9 15 ff ff       	call   f0109204 <kmalloc>
f0117c4b:	83 c4 10             	add    $0x10,%esp
f0117c4e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117c51:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117c54:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0117c59:	74 17                	je     f0117c72 <test_kmalloc_firstfit1+0xa72>
f0117c5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c62:	83 ec 0c             	sub    $0xc,%esp
f0117c65:	68 dc bf 12 f0       	push   $0xf012bfdc
f0117c6a:	e8 1c 93 fe ff       	call   f0100f8b <cprintf>
f0117c6f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c72:	e8 2e cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c77:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c7a:	74 17                	je     f0117c93 <test_kmalloc_firstfit1+0xa93>
f0117c7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c83:	83 ec 0c             	sub    $0xc,%esp
f0117c86:	68 10 c0 12 f0       	push   $0xf012c010
f0117c8b:	e8 fb 92 fe ff       	call   f0100f8b <cprintf>
f0117c90:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0117c93:	e8 2e 66 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117c98:	89 c2                	mov    %eax,%edx
f0117c9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c9d:	29 d0                	sub    %edx,%eax
f0117c9f:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ca4:	7f 17                	jg     f0117cbd <test_kmalloc_firstfit1+0xabd>
f0117ca6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cad:	83 ec 0c             	sub    $0xc,%esp
f0117cb0:	68 7c c0 12 f0       	push   $0xf012c07c
f0117cb5:	e8 d1 92 fe ff       	call   f0100f8b <cprintf>
f0117cba:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0117cbd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117cc1:	74 04                	je     f0117cc7 <test_kmalloc_firstfit1+0xac7>
f0117cc3:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0117cc7:	83 ec 08             	sub    $0x8,%esp
f0117cca:	ff 75 f4             	pushl  -0xc(%ebp)
f0117ccd:	68 94 c0 12 f0       	push   $0xf012c094
f0117cd2:	e8 b4 92 fe ff       	call   f0100f8b <cprintf>
f0117cd7:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117cda:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117cdf:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0117ce2:	c9                   	leave  
f0117ce3:	c3                   	ret    

f0117ce4 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0117ce4:	55                   	push   %ebp
f0117ce5:	89 e5                	mov    %esp,%ebp
f0117ce7:	57                   	push   %edi
f0117ce8:	53                   	push   %ebx
f0117ce9:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117cec:	83 ec 0c             	sub    $0xc,%esp
f0117cef:	68 68 a8 12 f0       	push   $0xf012a868
f0117cf4:	e8 92 92 fe ff       	call   f0100f8b <cprintf>
f0117cf9:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117cfc:	83 ec 0c             	sub    $0xc,%esp
f0117cff:	68 98 a8 12 f0       	push   $0xf012a898
f0117d04:	e8 82 92 fe ff       	call   f0100f8b <cprintf>
f0117d09:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117d0c:	83 ec 0c             	sub    $0xc,%esp
f0117d0f:	68 68 a8 12 f0       	push   $0xf012a868
f0117d14:	e8 72 92 fe ff       	call   f0100f8b <cprintf>
f0117d19:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117d1c:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117d1f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117d24:	b8 00 00 00 00       	mov    $0x0,%eax
f0117d29:	89 d7                	mov    %edx,%edi
f0117d2b:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117d2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117d34:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117d3b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0117d42:	83 ec 0c             	sub    $0xc,%esp
f0117d45:	68 cc c0 12 f0       	push   $0xf012c0cc
f0117d4a:	e8 3c 92 fe ff       	call   f0100f8b <cprintf>
f0117d4f:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0117d52:	83 ec 0c             	sub    $0xc,%esp
f0117d55:	68 01 e0 ff 07       	push   $0x7ffe001
f0117d5a:	e8 a5 14 ff ff       	call   f0109204 <kmalloc>
f0117d5f:	83 c4 10             	add    $0x10,%esp
f0117d62:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0117d65:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117d68:	85 c0                	test   %eax,%eax
f0117d6a:	74 17                	je     f0117d83 <test_kmalloc_firstfit2+0x9f>
f0117d6c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d73:	83 ec 0c             	sub    $0xc,%esp
f0117d76:	68 00 c1 12 f0       	push   $0xf012c100
f0117d7b:	e8 0b 92 fe ff       	call   f0100f8b <cprintf>
f0117d80:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117d83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117d87:	74 04                	je     f0117d8d <test_kmalloc_firstfit2+0xa9>
f0117d89:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117d8d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0117d94:	83 ec 0c             	sub    $0xc,%esp
f0117d97:	68 48 c1 12 f0       	push   $0xf012c148
f0117d9c:	e8 ea 91 fe ff       	call   f0100f8b <cprintf>
f0117da1:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117da4:	e8 1d 65 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117da9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117dac:	e8 f4 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117db1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0117db4:	83 ec 0c             	sub    $0xc,%esp
f0117db7:	68 00 fc 1f 00       	push   $0x1ffc00
f0117dbc:	e8 43 14 ff ff       	call   f0109204 <kmalloc>
f0117dc1:	83 c4 10             	add    $0x10,%esp
f0117dc4:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117dc7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117dca:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117dcf:	74 17                	je     f0117de8 <test_kmalloc_firstfit2+0x104>
f0117dd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dd8:	83 ec 0c             	sub    $0xc,%esp
f0117ddb:	68 c8 b7 12 f0       	push   $0xf012b7c8
f0117de0:	e8 a6 91 fe ff       	call   f0100f8b <cprintf>
f0117de5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117de8:	e8 b8 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ded:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117df0:	74 17                	je     f0117e09 <test_kmalloc_firstfit2+0x125>
f0117df2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117df9:	83 ec 0c             	sub    $0xc,%esp
f0117dfc:	68 90 ab 12 f0       	push   $0xf012ab90
f0117e01:	e8 85 91 fe ff       	call   f0100f8b <cprintf>
f0117e06:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117e09:	e8 b8 64 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117e0e:	89 c2                	mov    %eax,%edx
f0117e10:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e13:	29 d0                	sub    %edx,%eax
f0117e15:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e1a:	7f 17                	jg     f0117e33 <test_kmalloc_firstfit2+0x14f>
f0117e1c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e23:	83 ec 0c             	sub    $0xc,%esp
f0117e26:	68 fb b7 12 f0       	push   $0xf012b7fb
f0117e2b:	e8 5b 91 fe ff       	call   f0100f8b <cprintf>
f0117e30:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e33:	e8 8e 64 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117e38:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e3b:	e8 65 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e40:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0117e43:	83 ec 0c             	sub    $0xc,%esp
f0117e46:	68 00 fc 1f 00       	push   $0x1ffc00
f0117e4b:	e8 b4 13 ff ff       	call   f0109204 <kmalloc>
f0117e50:	83 c4 10             	add    $0x10,%esp
f0117e53:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117e56:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117e59:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117e5e:	74 17                	je     f0117e77 <test_kmalloc_firstfit2+0x193>
f0117e60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e67:	83 ec 0c             	sub    $0xc,%esp
f0117e6a:	68 14 b8 12 f0       	push   $0xf012b814
f0117e6f:	e8 17 91 fe ff       	call   f0100f8b <cprintf>
f0117e74:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e77:	e8 29 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e7c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e7f:	74 17                	je     f0117e98 <test_kmalloc_firstfit2+0x1b4>
f0117e81:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e88:	83 ec 0c             	sub    $0xc,%esp
f0117e8b:	68 cc ac 12 f0       	push   $0xf012accc
f0117e90:	e8 f6 90 fe ff       	call   f0100f8b <cprintf>
f0117e95:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117e98:	e8 29 64 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117e9d:	89 c2                	mov    %eax,%edx
f0117e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ea2:	29 d0                	sub    %edx,%eax
f0117ea4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117ea9:	7f 17                	jg     f0117ec2 <test_kmalloc_firstfit2+0x1de>
f0117eab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117eb2:	83 ec 0c             	sub    $0xc,%esp
f0117eb5:	68 47 b8 12 f0       	push   $0xf012b847
f0117eba:	e8 cc 90 fe ff       	call   f0100f8b <cprintf>
f0117ebf:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ec2:	e8 ff 63 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117eca:	e8 d6 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ecf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0117ed2:	83 ec 0c             	sub    $0xc,%esp
f0117ed5:	68 00 1c 00 00       	push   $0x1c00
f0117eda:	e8 25 13 ff ff       	call   f0109204 <kmalloc>
f0117edf:	83 c4 10             	add    $0x10,%esp
f0117ee2:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117ee5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117ee8:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117eed:	74 17                	je     f0117f06 <test_kmalloc_firstfit2+0x222>
f0117eef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ef6:	83 ec 0c             	sub    $0xc,%esp
f0117ef9:	68 60 b8 12 f0       	push   $0xf012b860
f0117efe:	e8 88 90 fe ff       	call   f0100f8b <cprintf>
f0117f03:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f06:	e8 9a c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f0b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f0e:	74 17                	je     f0117f27 <test_kmalloc_firstfit2+0x243>
f0117f10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f17:	83 ec 0c             	sub    $0xc,%esp
f0117f1a:	68 c4 ad 12 f0       	push   $0xf012adc4
f0117f1f:	e8 67 90 fe ff       	call   f0100f8b <cprintf>
f0117f24:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117f27:	e8 9a 63 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117f2c:	89 c2                	mov    %eax,%edx
f0117f2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f31:	29 d0                	sub    %edx,%eax
f0117f33:	83 f8 01             	cmp    $0x1,%eax
f0117f36:	7f 17                	jg     f0117f4f <test_kmalloc_firstfit2+0x26b>
f0117f38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f3f:	83 ec 0c             	sub    $0xc,%esp
f0117f42:	68 93 b8 12 f0       	push   $0xf012b893
f0117f47:	e8 3f 90 fe ff       	call   f0100f8b <cprintf>
f0117f4c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f4f:	e8 72 63 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117f54:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f57:	e8 49 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0117f5f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117f62:	83 ec 0c             	sub    $0xc,%esp
f0117f65:	50                   	push   %eax
f0117f66:	e8 f9 14 ff ff       	call   f0109464 <kfree>
f0117f6b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f6e:	e8 32 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f73:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f76:	74 17                	je     f0117f8f <test_kmalloc_firstfit2+0x2ab>
f0117f78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f7f:	83 ec 0c             	sub    $0xc,%esp
f0117f82:	68 a4 ae 12 f0       	push   $0xf012aea4
f0117f87:	e8 ff 8f fe ff       	call   f0100f8b <cprintf>
f0117f8c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0117f8f:	e8 32 63 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117f94:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117f97:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117f9c:	7f 17                	jg     f0117fb5 <test_kmalloc_firstfit2+0x2d1>
f0117f9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fa5:	83 ec 0c             	sub    $0xc,%esp
f0117fa8:	68 8e c1 12 f0       	push   $0xf012c18e
f0117fad:	e8 d9 8f fe ff       	call   f0100f8b <cprintf>
f0117fb2:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fb5:	e8 0c 63 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0117fba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fbd:	e8 e3 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117fc5:	83 ec 0c             	sub    $0xc,%esp
f0117fc8:	68 00 fc 2f 00       	push   $0x2ffc00
f0117fcd:	e8 32 12 ff ff       	call   f0109204 <kmalloc>
f0117fd2:	83 c4 10             	add    $0x10,%esp
f0117fd5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117fd8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117fdb:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117fe0:	74 17                	je     f0117ff9 <test_kmalloc_firstfit2+0x315>
f0117fe2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fe9:	83 ec 0c             	sub    $0xc,%esp
f0117fec:	68 f8 b8 12 f0       	push   $0xf012b8f8
f0117ff1:	e8 95 8f fe ff       	call   f0100f8b <cprintf>
f0117ff6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ff9:	e8 a7 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ffe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118001:	74 17                	je     f011801a <test_kmalloc_firstfit2+0x336>
f0118003:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011800a:	83 ec 0c             	sub    $0xc,%esp
f011800d:	68 a8 af 12 f0       	push   $0xf012afa8
f0118012:	e8 74 8f fe ff       	call   f0100f8b <cprintf>
f0118017:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f011801a:	e8 a7 62 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011801f:	89 c2                	mov    %eax,%edx
f0118021:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118024:	29 d0                	sub    %edx,%eax
f0118026:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011802b:	7f 17                	jg     f0118044 <test_kmalloc_firstfit2+0x360>
f011802d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118034:	83 ec 0c             	sub    $0xc,%esp
f0118037:	68 2b b9 12 f0       	push   $0xf012b92b
f011803c:	e8 4a 8f fe ff       	call   f0100f8b <cprintf>
f0118041:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118044:	e8 7d 62 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118049:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011804c:	e8 54 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118051:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0118054:	83 ec 0c             	sub    $0xc,%esp
f0118057:	68 00 18 20 00       	push   $0x201800
f011805c:	e8 a3 11 ff ff       	call   f0109204 <kmalloc>
f0118061:	83 c4 10             	add    $0x10,%esp
f0118064:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118067:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011806a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011806f:	74 17                	je     f0118088 <test_kmalloc_firstfit2+0x3a4>
f0118071:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118078:	83 ec 0c             	sub    $0xc,%esp
f011807b:	68 44 b9 12 f0       	push   $0xf012b944
f0118080:	e8 06 8f fe ff       	call   f0100f8b <cprintf>
f0118085:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118088:	e8 18 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011808d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118090:	74 17                	je     f01180a9 <test_kmalloc_firstfit2+0x3c5>
f0118092:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118099:	83 ec 0c             	sub    $0xc,%esp
f011809c:	68 ac b0 12 f0       	push   $0xf012b0ac
f01180a1:	e8 e5 8e fe ff       	call   f0100f8b <cprintf>
f01180a6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01180a9:	e8 18 62 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01180ae:	89 c2                	mov    %eax,%edx
f01180b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180b3:	29 d0                	sub    %edx,%eax
f01180b5:	3d 01 02 00 00       	cmp    $0x201,%eax
f01180ba:	7f 17                	jg     f01180d3 <test_kmalloc_firstfit2+0x3ef>
f01180bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c3:	83 ec 0c             	sub    $0xc,%esp
f01180c6:	68 77 b9 12 f0       	push   $0xf012b977
f01180cb:	e8 bb 8e fe ff       	call   f0100f8b <cprintf>
f01180d0:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01180d3:	e8 ee 61 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01180d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01180db:	e8 c5 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01180e3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01180e6:	83 ec 0c             	sub    $0xc,%esp
f01180e9:	50                   	push   %eax
f01180ea:	e8 75 13 ff ff       	call   f0109464 <kfree>
f01180ef:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180f2:	e8 ae c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180f7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180fa:	74 17                	je     f0118113 <test_kmalloc_firstfit2+0x42f>
f01180fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118103:	83 ec 0c             	sub    $0xc,%esp
f0118106:	68 b0 b1 12 f0       	push   $0xf012b1b0
f011810b:	e8 7b 8e fe ff       	call   f0100f8b <cprintf>
f0118110:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f0118113:	e8 ae 61 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118118:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011811b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118120:	7f 17                	jg     f0118139 <test_kmalloc_firstfit2+0x455>
f0118122:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118129:	83 ec 0c             	sub    $0xc,%esp
f011812c:	68 9e c1 12 f0       	push   $0xf012c19e
f0118131:	e8 55 8e fe ff       	call   f0100f8b <cprintf>
f0118136:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118139:	e8 88 61 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011813e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118141:	e8 5f c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118146:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118149:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011814c:	83 ec 0c             	sub    $0xc,%esp
f011814f:	50                   	push   %eax
f0118150:	e8 0f 13 ff ff       	call   f0109464 <kfree>
f0118155:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0118158:	e8 69 61 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011815d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118160:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118165:	7f 17                	jg     f011817e <test_kmalloc_firstfit2+0x49a>
f0118167:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011816e:	83 ec 0c             	sub    $0xc,%esp
f0118171:	68 6f ba 12 f0       	push   $0xf012ba6f
f0118176:	e8 10 8e fe ff       	call   f0100f8b <cprintf>
f011817b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011817e:	e8 22 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118183:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118186:	74 17                	je     f011819f <test_kmalloc_firstfit2+0x4bb>
f0118188:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011818f:	83 ec 0c             	sub    $0xc,%esp
f0118192:	68 04 ba 12 f0       	push   $0xf012ba04
f0118197:	e8 ef 8d fe ff       	call   f0100f8b <cprintf>
f011819c:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011819f:	e8 22 61 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01181a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181a7:	e8 f9 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f01181af:	83 ec 0c             	sub    $0xc,%esp
f01181b2:	68 00 fc 4f 00       	push   $0x4ffc00
f01181b7:	e8 48 10 ff ff       	call   f0109204 <kmalloc>
f01181bc:	83 c4 10             	add    $0x10,%esp
f01181bf:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f01181c2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01181c5:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f01181ca:	74 17                	je     f01181e3 <test_kmalloc_firstfit2+0x4ff>
f01181cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181d3:	83 ec 0c             	sub    $0xc,%esp
f01181d6:	68 b0 c1 12 f0       	push   $0xf012c1b0
f01181db:	e8 ab 8d fe ff       	call   f0100f8b <cprintf>
f01181e0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181e3:	e8 bd c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181eb:	74 17                	je     f0118204 <test_kmalloc_firstfit2+0x520>
f01181ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181f4:	83 ec 0c             	sub    $0xc,%esp
f01181f7:	68 80 ba 12 f0       	push   $0xf012ba80
f01181fc:	e8 8a 8d fe ff       	call   f0100f8b <cprintf>
f0118201:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f0118204:	e8 bd 60 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118209:	89 c2                	mov    %eax,%edx
f011820b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011820e:	29 d0                	sub    %edx,%eax
f0118210:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0118215:	7f 17                	jg     f011822e <test_kmalloc_firstfit2+0x54a>
f0118217:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011821e:	83 ec 0c             	sub    $0xc,%esp
f0118221:	68 e4 c1 12 f0       	push   $0xf012c1e4
f0118226:	e8 60 8d fe ff       	call   f0100f8b <cprintf>
f011822b:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011822e:	e8 93 60 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118233:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118236:	e8 6a c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011823b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f011823e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118241:	83 ec 0c             	sub    $0xc,%esp
f0118244:	50                   	push   %eax
f0118245:	e8 1a 12 ff ff       	call   f0109464 <kfree>
f011824a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011824d:	e8 53 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118252:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118255:	74 17                	je     f011826e <test_kmalloc_firstfit2+0x58a>
f0118257:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011825e:	83 ec 0c             	sub    $0xc,%esp
f0118261:	68 00 bb 12 f0       	push   $0xf012bb00
f0118266:	e8 20 8d fe ff       	call   f0100f8b <cprintf>
f011826b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f011826e:	e8 53 60 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118273:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118276:	83 f8 01             	cmp    $0x1,%eax
f0118279:	7f 17                	jg     f0118292 <test_kmalloc_firstfit2+0x5ae>
f011827b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118282:	83 ec 0c             	sub    $0xc,%esp
f0118285:	68 6c bb 12 f0       	push   $0xf012bb6c
f011828a:	e8 fc 8c fe ff       	call   f0100f8b <cprintf>
f011828f:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118292:	e8 2f 60 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118297:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011829a:	e8 06 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011829f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f01182a2:	83 ec 0c             	sub    $0xc,%esp
f01182a5:	68 00 04 00 00       	push   $0x400
f01182aa:	e8 55 0f ff ff       	call   f0109204 <kmalloc>
f01182af:	83 c4 10             	add    $0x10,%esp
f01182b2:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01182b5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01182b8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01182bd:	76 22                	jbe    f01182e1 <test_kmalloc_firstfit2+0x5fd>
f01182bf:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f01182c2:	83 ec 0c             	sub    $0xc,%esp
f01182c5:	6a 00                	push   $0x0
f01182c7:	e8 05 0e ff ff       	call   f01090d1 <sbrk>
f01182cc:	83 c4 10             	add    $0x10,%esp
f01182cf:	39 c3                	cmp    %eax,%ebx
f01182d1:	73 0e                	jae    f01182e1 <test_kmalloc_firstfit2+0x5fd>
f01182d3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01182d6:	89 c2                	mov    %eax,%edx
f01182d8:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01182dd:	39 c2                	cmp    %eax,%edx
f01182df:	72 17                	jb     f01182f8 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01182e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182e8:	83 ec 0c             	sub    $0xc,%esp
f01182eb:	68 fc c1 12 f0       	push   $0xf012c1fc
f01182f0:	e8 96 8c fe ff       	call   f0100f8b <cprintf>
f01182f5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182f8:	e8 a8 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118300:	74 17                	je     f0118319 <test_kmalloc_firstfit2+0x635>
f0118302:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118309:	83 ec 0c             	sub    $0xc,%esp
f011830c:	68 e0 bb 12 f0       	push   $0xf012bbe0
f0118311:	e8 75 8c fe ff       	call   f0100f8b <cprintf>
f0118316:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118319:	e8 87 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011831e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118321:	83 ec 0c             	sub    $0xc,%esp
f0118324:	68 00 08 00 00       	push   $0x800
f0118329:	e8 d6 0e ff ff       	call   f0109204 <kmalloc>
f011832e:	83 c4 10             	add    $0x10,%esp
f0118331:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118334:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118337:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011833c:	76 22                	jbe    f0118360 <test_kmalloc_firstfit2+0x67c>
f011833e:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118341:	83 ec 0c             	sub    $0xc,%esp
f0118344:	6a 00                	push   $0x0
f0118346:	e8 86 0d ff ff       	call   f01090d1 <sbrk>
f011834b:	83 c4 10             	add    $0x10,%esp
f011834e:	39 c3                	cmp    %eax,%ebx
f0118350:	73 0e                	jae    f0118360 <test_kmalloc_firstfit2+0x67c>
f0118352:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118355:	89 c2                	mov    %eax,%edx
f0118357:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011835c:	39 c2                	cmp    %eax,%edx
f011835e:	72 17                	jb     f0118377 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118360:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118367:	83 ec 0c             	sub    $0xc,%esp
f011836a:	68 88 c2 12 f0       	push   $0xf012c288
f011836f:	e8 17 8c fe ff       	call   f0100f8b <cprintf>
f0118374:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118377:	e8 29 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011837c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011837f:	74 17                	je     f0118398 <test_kmalloc_firstfit2+0x6b4>
f0118381:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118388:	83 ec 0c             	sub    $0xc,%esp
f011838b:	68 98 bc 12 f0       	push   $0xf012bc98
f0118390:	e8 f6 8b fe ff       	call   f0100f8b <cprintf>
f0118395:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118398:	e8 08 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011839d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f01183a0:	83 ec 0c             	sub    $0xc,%esp
f01183a3:	68 00 04 00 00       	push   $0x400
f01183a8:	e8 57 0e ff ff       	call   f0109204 <kmalloc>
f01183ad:	83 c4 10             	add    $0x10,%esp
f01183b0:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f01183b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01183b6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01183bb:	76 22                	jbe    f01183df <test_kmalloc_firstfit2+0x6fb>
f01183bd:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01183c0:	83 ec 0c             	sub    $0xc,%esp
f01183c3:	6a 00                	push   $0x0
f01183c5:	e8 07 0d ff ff       	call   f01090d1 <sbrk>
f01183ca:	83 c4 10             	add    $0x10,%esp
f01183cd:	39 c3                	cmp    %eax,%ebx
f01183cf:	73 0e                	jae    f01183df <test_kmalloc_firstfit2+0x6fb>
f01183d1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01183d4:	89 c2                	mov    %eax,%edx
f01183d6:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01183db:	39 c2                	cmp    %eax,%edx
f01183dd:	72 17                	jb     f01183f6 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01183df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183e6:	83 ec 0c             	sub    $0xc,%esp
f01183e9:	68 14 c3 12 f0       	push   $0xf012c314
f01183ee:	e8 98 8b fe ff       	call   f0100f8b <cprintf>
f01183f3:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183f6:	e8 aa c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01183fb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183fe:	74 17                	je     f0118417 <test_kmalloc_firstfit2+0x733>
f0118400:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118407:	83 ec 0c             	sub    $0xc,%esp
f011840a:	68 50 bd 12 f0       	push   $0xf012bd50
f011840f:	e8 77 8b fe ff       	call   f0100f8b <cprintf>
f0118414:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118417:	e8 aa 5e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011841c:	89 c2                	mov    %eax,%edx
f011841e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118421:	29 d0                	sub    %edx,%eax
f0118423:	83 f8 01             	cmp    $0x1,%eax
f0118426:	74 17                	je     f011843f <test_kmalloc_firstfit2+0x75b>
f0118428:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011842f:	83 ec 0c             	sub    $0xc,%esp
f0118432:	68 a0 c3 12 f0       	push   $0xf012c3a0
f0118437:	e8 4f 8b fe ff       	call   f0100f8b <cprintf>
f011843c:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f011843f:	e8 82 5e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118444:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118447:	e8 59 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011844c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f011844f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118452:	83 ec 0c             	sub    $0xc,%esp
f0118455:	50                   	push   %eax
f0118456:	e8 09 10 ff ff       	call   f0109464 <kfree>
f011845b:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011845e:	e8 42 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118463:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118466:	74 17                	je     f011847f <test_kmalloc_firstfit2+0x79b>
f0118468:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011846f:	83 ec 0c             	sub    $0xc,%esp
f0118472:	68 20 be 12 f0       	push   $0xf012be20
f0118477:	e8 0f 8b fe ff       	call   f0100f8b <cprintf>
f011847c:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011847f:	e8 42 5e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118484:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118487:	74 17                	je     f01184a0 <test_kmalloc_firstfit2+0x7bc>
f0118489:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118490:	83 ec 0c             	sub    $0xc,%esp
f0118493:	68 c4 c3 12 f0       	push   $0xf012c3c4
f0118498:	e8 ee 8a fe ff       	call   f0100f8b <cprintf>
f011849d:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f01184a0:	e8 21 5e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01184a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184a8:	e8 f8 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f01184b0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01184b3:	83 ec 0c             	sub    $0xc,%esp
f01184b6:	50                   	push   %eax
f01184b7:	e8 a8 0f ff ff       	call   f0109464 <kfree>
f01184bc:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184bf:	e8 e1 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184c4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184c7:	74 17                	je     f01184e0 <test_kmalloc_firstfit2+0x7fc>
f01184c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184d0:	83 ec 0c             	sub    $0xc,%esp
f01184d3:	68 c0 be 12 f0       	push   $0xf012bec0
f01184d8:	e8 ae 8a fe ff       	call   f0100f8b <cprintf>
f01184dd:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01184e0:	e8 e1 5d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01184e5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01184e8:	74 17                	je     f0118501 <test_kmalloc_firstfit2+0x81d>
f01184ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184f1:	83 ec 0c             	sub    $0xc,%esp
f01184f4:	68 24 c4 12 f0       	push   $0xf012c424
f01184f9:	e8 8d 8a fe ff       	call   f0100f8b <cprintf>
f01184fe:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118501:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118505:	74 04                	je     f011850b <test_kmalloc_firstfit2+0x827>
f0118507:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f011850b:	83 ec 0c             	sub    $0xc,%esp
f011850e:	68 84 c4 12 f0       	push   $0xf012c484
f0118513:	e8 73 8a fe ff       	call   f0100f8b <cprintf>
f0118518:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011851b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118522:	e8 9f 5d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118527:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011852a:	e8 76 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011852f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118532:	83 ec 0c             	sub    $0xc,%esp
f0118535:	68 00 08 00 00       	push   $0x800
f011853a:	e8 c5 0c ff ff       	call   f0109204 <kmalloc>
f011853f:	83 c4 10             	add    $0x10,%esp
f0118542:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118545:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118548:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011854b:	39 c2                	cmp    %eax,%edx
f011854d:	74 17                	je     f0118566 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f011854f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118556:	83 ec 0c             	sub    $0xc,%esp
f0118559:	68 bc c4 12 f0       	push   $0xf012c4bc
f011855e:	e8 28 8a fe ff       	call   f0100f8b <cprintf>
f0118563:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118566:	e8 3a c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011856b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011856e:	74 17                	je     f0118587 <test_kmalloc_firstfit2+0x8a3>
f0118570:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118577:	83 ec 0c             	sub    $0xc,%esp
f011857a:	68 f0 b4 12 f0       	push   $0xf012b4f0
f011857f:	e8 07 8a fe ff       	call   f0100f8b <cprintf>
f0118584:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118587:	e8 3a 5d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011858c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011858f:	74 17                	je     f01185a8 <test_kmalloc_firstfit2+0x8c4>
f0118591:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118598:	83 ec 0c             	sub    $0xc,%esp
f011859b:	68 f0 c4 12 f0       	push   $0xf012c4f0
f01185a0:	e8 e6 89 fe ff       	call   f0100f8b <cprintf>
f01185a5:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01185a8:	e8 19 5d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01185ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185b0:	e8 f0 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f01185b8:	83 ec 0c             	sub    $0xc,%esp
f01185bb:	68 00 04 00 00       	push   $0x400
f01185c0:	e8 3f 0c ff ff       	call   f0109204 <kmalloc>
f01185c5:	83 c4 10             	add    $0x10,%esp
f01185c8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f01185cb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01185ce:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01185d1:	81 c2 08 08 00 00    	add    $0x808,%edx
f01185d7:	39 d0                	cmp    %edx,%eax
f01185d9:	74 17                	je     f01185f2 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f01185db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185e2:	83 ec 0c             	sub    $0xc,%esp
f01185e5:	68 08 c5 12 f0       	push   $0xf012c508
f01185ea:	e8 9c 89 fe ff       	call   f0100f8b <cprintf>
f01185ef:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185f2:	e8 ae c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185f7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185fa:	74 17                	je     f0118613 <test_kmalloc_firstfit2+0x92f>
f01185fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118603:	83 ec 0c             	sub    $0xc,%esp
f0118606:	68 cc b5 12 f0       	push   $0xf012b5cc
f011860b:	e8 7b 89 fe ff       	call   f0100f8b <cprintf>
f0118610:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118613:	e8 ae 5c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118618:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011861b:	74 17                	je     f0118634 <test_kmalloc_firstfit2+0x950>
f011861d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118624:	83 ec 0c             	sub    $0xc,%esp
f0118627:	68 3c c5 12 f0       	push   $0xf012c53c
f011862c:	e8 5a 89 fe ff       	call   f0100f8b <cprintf>
f0118631:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118634:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118638:	74 04                	je     f011863e <test_kmalloc_firstfit2+0x95a>
f011863a:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f011863e:	83 ec 0c             	sub    $0xc,%esp
f0118641:	68 54 c5 12 f0       	push   $0xf012c554
f0118646:	e8 40 89 fe ff       	call   f0100f8b <cprintf>
f011864b:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011864e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118655:	e8 6c 5c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011865a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011865d:	e8 43 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118662:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118665:	83 ec 0c             	sub    $0xc,%esp
f0118668:	68 00 04 70 00       	push   $0x700400
f011866d:	e8 92 0b ff ff       	call   f0109204 <kmalloc>
f0118672:	83 c4 10             	add    $0x10,%esp
f0118675:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118678:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011867b:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118680:	74 17                	je     f0118699 <test_kmalloc_firstfit2+0x9b5>
f0118682:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118689:	83 ec 0c             	sub    $0xc,%esp
f011868c:	68 dc bf 12 f0       	push   $0xf012bfdc
f0118691:	e8 f5 88 fe ff       	call   f0100f8b <cprintf>
f0118696:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118699:	e8 07 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011869e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01186a1:	74 17                	je     f01186ba <test_kmalloc_firstfit2+0x9d6>
f01186a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186aa:	83 ec 0c             	sub    $0xc,%esp
f01186ad:	68 10 c0 12 f0       	push   $0xf012c010
f01186b2:	e8 d4 88 fe ff       	call   f0100f8b <cprintf>
f01186b7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01186ba:	e8 07 5c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01186bf:	89 c2                	mov    %eax,%edx
f01186c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186c4:	29 d0                	sub    %edx,%eax
f01186c6:	3d 00 07 00 00       	cmp    $0x700,%eax
f01186cb:	7f 17                	jg     f01186e4 <test_kmalloc_firstfit2+0xa00>
f01186cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186d4:	83 ec 0c             	sub    $0xc,%esp
f01186d7:	68 7c c0 12 f0       	push   $0xf012c07c
f01186dc:	e8 aa 88 fe ff       	call   f0100f8b <cprintf>
f01186e1:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186e4:	e8 dd 5b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01186e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186ec:	e8 b4 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f01186f4:	83 ec 0c             	sub    $0xc,%esp
f01186f7:	68 00 0c 00 00       	push   $0xc00
f01186fc:	e8 03 0b ff ff       	call   f0109204 <kmalloc>
f0118701:	83 c4 10             	add    $0x10,%esp
f0118704:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118707:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011870a:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011870f:	74 17                	je     f0118728 <test_kmalloc_firstfit2+0xa44>
f0118711:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118718:	83 ec 0c             	sub    $0xc,%esp
f011871b:	68 88 c5 12 f0       	push   $0xf012c588
f0118720:	e8 66 88 fe ff       	call   f0100f8b <cprintf>
f0118725:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118728:	e8 78 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011872d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118730:	74 17                	je     f0118749 <test_kmalloc_firstfit2+0xa65>
f0118732:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118739:	83 ec 0c             	sub    $0xc,%esp
f011873c:	68 bc c5 12 f0       	push   $0xf012c5bc
f0118741:	e8 45 88 fe ff       	call   f0100f8b <cprintf>
f0118746:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118749:	e8 78 5b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011874e:	89 c2                	mov    %eax,%edx
f0118750:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118753:	29 d0                	sub    %edx,%eax
f0118755:	85 c0                	test   %eax,%eax
f0118757:	7f 17                	jg     f0118770 <test_kmalloc_firstfit2+0xa8c>
f0118759:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118760:	83 ec 0c             	sub    $0xc,%esp
f0118763:	68 28 c6 12 f0       	push   $0xf012c628
f0118768:	e8 1e 88 fe ff       	call   f0100f8b <cprintf>
f011876d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118770:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118774:	74 04                	je     f011877a <test_kmalloc_firstfit2+0xa96>
f0118776:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f011877a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118781:	83 ec 0c             	sub    $0xc,%esp
f0118784:	68 40 c6 12 f0       	push   $0xf012c640
f0118789:	e8 fd 87 fe ff       	call   f0100f8b <cprintf>
f011878e:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118791:	83 ec 0c             	sub    $0xc,%esp
f0118794:	68 00 e0 1f 07       	push   $0x71fe000
f0118799:	e8 66 0a ff ff       	call   f0109204 <kmalloc>
f011879e:	83 c4 10             	add    $0x10,%esp
f01187a1:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f01187a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01187a7:	85 c0                	test   %eax,%eax
f01187a9:	74 17                	je     f01187c2 <test_kmalloc_firstfit2+0xade>
f01187ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187b2:	83 ec 0c             	sub    $0xc,%esp
f01187b5:	68 94 c6 12 f0       	push   $0xf012c694
f01187ba:	e8 cc 87 fe ff       	call   f0100f8b <cprintf>
f01187bf:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f01187c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01187c6:	74 04                	je     f01187cc <test_kmalloc_firstfit2+0xae8>
f01187c8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f01187cc:	83 ec 08             	sub    $0x8,%esp
f01187cf:	ff 75 f4             	pushl  -0xc(%ebp)
f01187d2:	68 fc c6 12 f0       	push   $0xf012c6fc
f01187d7:	e8 af 87 fe ff       	call   f0100f8b <cprintf>
f01187dc:	83 c4 10             	add    $0x10,%esp

	return 1;
f01187df:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01187e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01187e7:	5b                   	pop    %ebx
f01187e8:	5f                   	pop    %edi
f01187e9:	5d                   	pop    %ebp
f01187ea:	c3                   	ret    

f01187eb <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f01187eb:	55                   	push   %ebp
f01187ec:	89 e5                	mov    %esp,%ebp
f01187ee:	53                   	push   %ebx
f01187ef:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01187f2:	83 ec 0c             	sub    $0xc,%esp
f01187f5:	68 68 a8 12 f0       	push   $0xf012a868
f01187fa:	e8 8c 87 fe ff       	call   f0100f8b <cprintf>
f01187ff:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118802:	83 ec 0c             	sub    $0xc,%esp
f0118805:	68 98 a8 12 f0       	push   $0xf012a898
f011880a:	e8 7c 87 fe ff       	call   f0100f8b <cprintf>
f011880f:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118812:	83 ec 0c             	sub    $0xc,%esp
f0118815:	68 68 a8 12 f0       	push   $0xf012a868
f011881a:	e8 6c 87 fe ff       	call   f0100f8b <cprintf>
f011881f:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0118822:	e8 9f 5a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118827:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f011882a:	e8 76 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011882f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118832:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0118839:	83 ec 0c             	sub    $0xc,%esp
f011883c:	68 31 c7 12 f0       	push   $0xf012c731
f0118841:	e8 45 87 fe ff       	call   f0100f8b <cprintf>
f0118846:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118849:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011884e:	ba 00 00 00 00       	mov    $0x0,%edx
f0118853:	f7 75 e4             	divl   -0x1c(%ebp)
f0118856:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118859:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118860:	eb 1d                	jmp    f011887f <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118862:	83 ec 0c             	sub    $0xc,%esp
f0118865:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118868:	e8 97 09 ff ff       	call   f0109204 <kmalloc>
f011886d:	83 c4 10             	add    $0x10,%esp
f0118870:	89 c2                	mov    %eax,%edx
f0118872:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118875:	89 14 85 60 50 69 f0 	mov    %edx,-0xf96afa0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f011887c:	ff 45 f4             	incl   -0xc(%ebp)
f011887f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118882:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118885:	7c db                	jl     f0118862 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118887:	83 ec 0c             	sub    $0xc,%esp
f011888a:	68 35 c7 12 f0       	push   $0xf012c735
f011888f:	e8 f7 86 fe ff       	call   f0100f8b <cprintf>
f0118894:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118897:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011889c:	ba 00 00 00 00       	mov    $0x0,%edx
f01188a1:	f7 75 e4             	divl   -0x1c(%ebp)
f01188a4:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f01188a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01188ab:	74 1e                	je     f01188cb <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f01188ad:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f01188b0:	8d 43 01             	lea    0x1(%ebx),%eax
f01188b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01188b6:	83 ec 0c             	sub    $0xc,%esp
f01188b9:	ff 75 e0             	pushl  -0x20(%ebp)
f01188bc:	e8 43 09 ff ff       	call   f0109204 <kmalloc>
f01188c1:	83 c4 10             	add    $0x10,%esp
f01188c4:	89 04 9d 60 50 69 f0 	mov    %eax,-0xf96afa0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f01188cb:	83 ec 04             	sub    $0x4,%esp
f01188ce:	ff 75 f0             	pushl  -0x10(%ebp)
f01188d1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01188d4:	68 3c c7 12 f0       	push   $0xf012c73c
f01188d9:	e8 ad 86 fe ff       	call   f0100f8b <cprintf>
f01188de:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01188e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01188e8:	eb 36                	jmp    f0118920 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f01188ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188ed:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f01188f4:	89 c2                	mov    %eax,%edx
f01188f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188f9:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01188fd:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0118902:	39 c2                	cmp    %eax,%edx
f0118904:	74 17                	je     f011891d <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0118906:	83 ec 04             	sub    $0x4,%esp
f0118909:	68 84 c7 12 f0       	push   $0xf012c784
f011890e:	68 e4 02 00 00       	push   $0x2e4
f0118913:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118918:	e8 1c 7a fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f011891d:	ff 45 f4             	incl   -0xc(%ebp)
f0118920:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118923:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118926:	7c c2                	jl     f01188ea <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118928:	e8 78 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011892d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118930:	74 17                	je     f0118949 <test_fastfirstfit+0x15e>
f0118932:	83 ec 04             	sub    $0x4,%esp
f0118935:	68 e0 c7 12 f0       	push   $0xf012c7e0
f011893a:	68 e7 02 00 00       	push   $0x2e7
f011893f:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118944:	e8 f0 79 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0118949:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011894c:	e8 75 59 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118951:	29 c3                	sub    %eax,%ebx
f0118953:	89 d8                	mov    %ebx,%eax
f0118955:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f011895a:	77 17                	ja     f0118973 <test_fastfirstfit+0x188>
f011895c:	83 ec 04             	sub    $0x4,%esp
f011895f:	68 48 c8 12 f0       	push   $0xf012c848
f0118964:	68 e8 02 00 00       	push   $0x2e8
f0118969:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011896e:	e8 c6 79 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118973:	e8 2d bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118978:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f011897b:	e8 46 59 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118980:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118983:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0118987:	7f 17                	jg     f01189a0 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0118989:	83 ec 04             	sub    $0x4,%esp
f011898c:	68 5c c8 12 f0       	push   $0xf012c85c
f0118991:	68 ef 02 00 00       	push   $0x2ef
f0118996:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011899b:	e8 99 79 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f01189a0:	a1 60 50 69 f0       	mov    0xf0695060,%eax
f01189a5:	83 ec 0c             	sub    $0xc,%esp
f01189a8:	50                   	push   %eax
f01189a9:	e8 b6 0a ff ff       	call   f0109464 <kfree>
f01189ae:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f01189b1:	a1 68 50 69 f0       	mov    0xf0695068,%eax
f01189b6:	83 ec 0c             	sub    $0xc,%esp
f01189b9:	50                   	push   %eax
f01189ba:	e8 a5 0a ff ff       	call   f0109464 <kfree>
f01189bf:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f01189c2:	a1 6c 50 69 f0       	mov    0xf069506c,%eax
f01189c7:	83 ec 0c             	sub    $0xc,%esp
f01189ca:	50                   	push   %eax
f01189cb:	e8 94 0a ff ff       	call   f0109464 <kfree>
f01189d0:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f01189d3:	a1 74 50 69 f0       	mov    0xf0695074,%eax
f01189d8:	83 ec 0c             	sub    $0xc,%esp
f01189db:	50                   	push   %eax
f01189dc:	e8 83 0a ff ff       	call   f0109464 <kfree>
f01189e1:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f01189e4:	a1 88 50 69 f0       	mov    0xf0695088,%eax
f01189e9:	83 ec 0c             	sub    $0xc,%esp
f01189ec:	50                   	push   %eax
f01189ed:	e8 72 0a ff ff       	call   f0109464 <kfree>
f01189f2:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f01189f5:	a1 90 50 69 f0       	mov    0xf0695090,%eax
f01189fa:	83 ec 0c             	sub    $0xc,%esp
f01189fd:	50                   	push   %eax
f01189fe:	e8 61 0a ff ff       	call   f0109464 <kfree>
f0118a03:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0118a06:	a1 8c 50 69 f0       	mov    0xf069508c,%eax
f0118a0b:	83 ec 0c             	sub    $0xc,%esp
f0118a0e:	50                   	push   %eax
f0118a0f:	e8 50 0a ff ff       	call   f0109464 <kfree>
f0118a14:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0118a17:	a1 b0 50 69 f0       	mov    0xf06950b0,%eax
f0118a1c:	83 ec 0c             	sub    $0xc,%esp
f0118a1f:	50                   	push   %eax
f0118a20:	e8 3f 0a ff ff       	call   f0109464 <kfree>
f0118a25:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0118a28:	a1 c4 50 69 f0       	mov    0xf06950c4,%eax
f0118a2d:	83 ec 0c             	sub    $0xc,%esp
f0118a30:	50                   	push   %eax
f0118a31:	e8 2e 0a ff ff       	call   f0109464 <kfree>
f0118a36:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0118a39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118a3c:	83 e8 02             	sub    $0x2,%eax
f0118a3f:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f0118a46:	83 ec 0c             	sub    $0xc,%esp
f0118a49:	50                   	push   %eax
f0118a4a:	e8 15 0a ff ff       	call   f0109464 <kfree>
f0118a4f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0118a52:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118a55:	83 e8 03             	sub    $0x3,%eax
f0118a58:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f0118a5f:	83 ec 0c             	sub    $0xc,%esp
f0118a62:	50                   	push   %eax
f0118a63:	e8 fc 09 ff ff       	call   f0109464 <kfree>
f0118a68:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118a6b:	e8 35 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a70:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a73:	74 17                	je     f0118a8c <test_fastfirstfit+0x2a1>
f0118a75:	83 ec 04             	sub    $0x4,%esp
f0118a78:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118a7d:	68 fc 02 00 00       	push   $0x2fc
f0118a82:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118a87:	e8 ad 78 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0118a8c:	e8 35 58 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118a91:	89 c2                	mov    %eax,%edx
f0118a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a96:	89 d1                	mov    %edx,%ecx
f0118a98:	29 c1                	sub    %eax,%ecx
f0118a9a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118a9d:	89 d0                	mov    %edx,%eax
f0118a9f:	c1 e0 02             	shl    $0x2,%eax
f0118aa2:	01 d0                	add    %edx,%eax
f0118aa4:	01 c0                	add    %eax,%eax
f0118aa6:	01 d0                	add    %edx,%eax
f0118aa8:	c1 e8 0c             	shr    $0xc,%eax
f0118aab:	39 c1                	cmp    %eax,%ecx
f0118aad:	74 17                	je     f0118ac6 <test_fastfirstfit+0x2db>
f0118aaf:	83 ec 04             	sub    $0x4,%esp
f0118ab2:	68 98 c8 12 f0       	push   $0xf012c898
f0118ab7:	68 fd 02 00 00       	push   $0x2fd
f0118abc:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118ac1:	e8 73 78 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0118ac6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ac9:	01 c0                	add    %eax,%eax
f0118acb:	89 c2                	mov    %eax,%edx
f0118acd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ad0:	d1 e8                	shr    %eax
f0118ad2:	01 d0                	add    %edx,%eax
f0118ad4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118ad7:	e8 c9 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118adc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118adf:	e8 e2 57 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118ae4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118ae7:	83 ec 0c             	sub    $0xc,%esp
f0118aea:	ff 75 dc             	pushl  -0x24(%ebp)
f0118aed:	e8 12 07 ff ff       	call   f0109204 <kmalloc>
f0118af2:	83 c4 10             	add    $0x10,%esp
f0118af5:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0118af8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118afb:	89 d0                	mov    %edx,%eax
f0118afd:	c1 e0 02             	shl    $0x2,%eax
f0118b00:	01 d0                	add    %edx,%eax
f0118b02:	01 c0                	add    %eax,%eax
f0118b04:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118b0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118b0d:	39 c2                	cmp    %eax,%edx
f0118b0f:	74 17                	je     f0118b28 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0118b11:	83 ec 04             	sub    $0x4,%esp
f0118b14:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118b19:	68 08 03 00 00       	push   $0x308
f0118b1e:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118b23:	e8 11 78 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118b28:	e8 78 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b2d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b30:	74 17                	je     f0118b49 <test_fastfirstfit+0x35e>
f0118b32:	83 ec 04             	sub    $0x4,%esp
f0118b35:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118b3a:	68 09 03 00 00       	push   $0x309
f0118b3f:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118b44:	e8 f0 77 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118b49:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118b4c:	e8 75 57 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118b51:	29 c3                	sub    %eax,%ebx
f0118b53:	89 da                	mov    %ebx,%edx
f0118b55:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118b58:	c1 e8 0c             	shr    $0xc,%eax
f0118b5b:	39 c2                	cmp    %eax,%edx
f0118b5d:	73 17                	jae    f0118b76 <test_fastfirstfit+0x38b>
f0118b5f:	83 ec 04             	sub    $0x4,%esp
f0118b62:	68 48 c8 12 f0       	push   $0xf012c848
f0118b67:	68 0a 03 00 00       	push   $0x30a
f0118b6c:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118b71:	e8 c3 77 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0118b76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118b79:	01 c0                	add    %eax,%eax
f0118b7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118b7e:	e8 22 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b83:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118b86:	e8 3b 57 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118b8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118b8e:	83 ec 0c             	sub    $0xc,%esp
f0118b91:	ff 75 dc             	pushl  -0x24(%ebp)
f0118b94:	e8 6b 06 ff ff       	call   f0109204 <kmalloc>
f0118b99:	83 c4 10             	add    $0x10,%esp
f0118b9c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0118b9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ba2:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0118ba7:	01 c0                	add    %eax,%eax
f0118ba9:	89 c2                	mov    %eax,%edx
f0118bab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118bae:	39 c2                	cmp    %eax,%edx
f0118bb0:	74 17                	je     f0118bc9 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0118bb2:	83 ec 04             	sub    $0x4,%esp
f0118bb5:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118bba:	68 14 03 00 00       	push   $0x314
f0118bbf:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118bc4:	e8 70 77 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118bc9:	e8 d7 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118bd1:	74 17                	je     f0118bea <test_fastfirstfit+0x3ff>
f0118bd3:	83 ec 04             	sub    $0x4,%esp
f0118bd6:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118bdb:	68 15 03 00 00       	push   $0x315
f0118be0:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118be5:	e8 4f 77 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118bea:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118bed:	e8 d4 56 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118bf2:	29 c3                	sub    %eax,%ebx
f0118bf4:	89 da                	mov    %ebx,%edx
f0118bf6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118bf9:	c1 e8 0c             	shr    $0xc,%eax
f0118bfc:	39 c2                	cmp    %eax,%edx
f0118bfe:	73 17                	jae    f0118c17 <test_fastfirstfit+0x42c>
f0118c00:	83 ec 04             	sub    $0x4,%esp
f0118c03:	68 48 c8 12 f0       	push   $0xf012c848
f0118c08:	68 16 03 00 00       	push   $0x316
f0118c0d:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118c12:	e8 22 77 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0118c17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118c1a:	89 c2                	mov    %eax,%edx
f0118c1c:	01 d2                	add    %edx,%edx
f0118c1e:	01 d0                	add    %edx,%eax
f0118c20:	d1 e8                	shr    %eax
f0118c22:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118c25:	e8 7b bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118c2d:	e8 94 56 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118c32:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118c35:	83 ec 0c             	sub    $0xc,%esp
f0118c38:	ff 75 dc             	pushl  -0x24(%ebp)
f0118c3b:	e8 c4 05 ff ff       	call   f0109204 <kmalloc>
f0118c40:	83 c4 10             	add    $0x10,%esp
f0118c43:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0118c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118c49:	83 e8 03             	sub    $0x3,%eax
f0118c4c:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118c50:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118c56:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118c59:	39 c2                	cmp    %eax,%edx
f0118c5b:	74 17                	je     f0118c74 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0118c5d:	83 ec 04             	sub    $0x4,%esp
f0118c60:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118c65:	68 20 03 00 00       	push   $0x320
f0118c6a:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118c6f:	e8 c5 76 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118c74:	e8 2c bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c7c:	74 17                	je     f0118c95 <test_fastfirstfit+0x4aa>
f0118c7e:	83 ec 04             	sub    $0x4,%esp
f0118c81:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118c86:	68 21 03 00 00       	push   $0x321
f0118c8b:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118c90:	e8 a4 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118c95:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118c98:	e8 29 56 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118c9d:	29 c3                	sub    %eax,%ebx
f0118c9f:	89 da                	mov    %ebx,%edx
f0118ca1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118ca4:	c1 e8 0c             	shr    $0xc,%eax
f0118ca7:	39 c2                	cmp    %eax,%edx
f0118ca9:	73 17                	jae    f0118cc2 <test_fastfirstfit+0x4d7>
f0118cab:	83 ec 04             	sub    $0x4,%esp
f0118cae:	68 48 c8 12 f0       	push   $0xf012c848
f0118cb3:	68 22 03 00 00       	push   $0x322
f0118cb8:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118cbd:	e8 77 76 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118cc2:	e8 de bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118cca:	e8 f7 55 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118ccf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118cd2:	83 ec 0c             	sub    $0xc,%esp
f0118cd5:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118cd8:	e8 27 05 ff ff       	call   f0109204 <kmalloc>
f0118cdd:	83 c4 10             	add    $0x10,%esp
f0118ce0:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0118ce3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118ce6:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118ceb:	74 17                	je     f0118d04 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0118ced:	83 ec 04             	sub    $0x4,%esp
f0118cf0:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118cf5:	68 2b 03 00 00       	push   $0x32b
f0118cfa:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118cff:	e8 35 76 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118d04:	e8 9c bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d0c:	74 17                	je     f0118d25 <test_fastfirstfit+0x53a>
f0118d0e:	83 ec 04             	sub    $0x4,%esp
f0118d11:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118d16:	68 2c 03 00 00       	push   $0x32c
f0118d1b:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118d20:	e8 14 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118d25:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118d28:	e8 99 55 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118d2d:	29 c3                	sub    %eax,%ebx
f0118d2f:	89 da                	mov    %ebx,%edx
f0118d31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118d34:	c1 e8 0c             	shr    $0xc,%eax
f0118d37:	39 c2                	cmp    %eax,%edx
f0118d39:	73 17                	jae    f0118d52 <test_fastfirstfit+0x567>
f0118d3b:	83 ec 04             	sub    $0x4,%esp
f0118d3e:	68 48 c8 12 f0       	push   $0xf012c848
f0118d43:	68 2d 03 00 00       	push   $0x32d
f0118d48:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118d4d:	e8 e7 75 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d52:	e8 4e bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d57:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118d5a:	e8 67 55 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118d5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118d62:	83 ec 0c             	sub    $0xc,%esp
f0118d65:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118d68:	e8 97 04 ff ff       	call   f0109204 <kmalloc>
f0118d6d:	83 c4 10             	add    $0x10,%esp
f0118d70:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0118d73:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118d76:	89 d0                	mov    %edx,%eax
f0118d78:	c1 e0 02             	shl    $0x2,%eax
f0118d7b:	01 d0                	add    %edx,%eax
f0118d7d:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118d83:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118d86:	39 c2                	cmp    %eax,%edx
f0118d88:	74 17                	je     f0118da1 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0118d8a:	83 ec 04             	sub    $0x4,%esp
f0118d8d:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118d92:	68 36 03 00 00       	push   $0x336
f0118d97:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118d9c:	e8 98 75 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118da1:	e8 ff ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118da6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118da9:	74 17                	je     f0118dc2 <test_fastfirstfit+0x5d7>
f0118dab:	83 ec 04             	sub    $0x4,%esp
f0118dae:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118db3:	68 37 03 00 00       	push   $0x337
f0118db8:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118dbd:	e8 77 75 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118dc2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118dc5:	e8 fc 54 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118dca:	29 c3                	sub    %eax,%ebx
f0118dcc:	89 da                	mov    %ebx,%edx
f0118dce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118dd1:	c1 e8 0c             	shr    $0xc,%eax
f0118dd4:	39 c2                	cmp    %eax,%edx
f0118dd6:	73 17                	jae    f0118def <test_fastfirstfit+0x604>
f0118dd8:	83 ec 04             	sub    $0x4,%esp
f0118ddb:	68 48 c8 12 f0       	push   $0xf012c848
f0118de0:	68 38 03 00 00       	push   $0x338
f0118de5:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118dea:	e8 4a 75 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118def:	e8 b1 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118df4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118df7:	e8 ca 54 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118dfc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118dff:	83 ec 0c             	sub    $0xc,%esp
f0118e02:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118e05:	e8 fa 03 ff ff       	call   f0109204 <kmalloc>
f0118e0a:	83 c4 10             	add    $0x10,%esp
f0118e0d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0118e10:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e13:	89 d0                	mov    %edx,%eax
f0118e15:	c1 e0 02             	shl    $0x2,%eax
f0118e18:	01 d0                	add    %edx,%eax
f0118e1a:	c1 e0 02             	shl    $0x2,%eax
f0118e1d:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118e23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118e26:	39 c2                	cmp    %eax,%edx
f0118e28:	74 17                	je     f0118e41 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0118e2a:	83 ec 04             	sub    $0x4,%esp
f0118e2d:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118e32:	68 41 03 00 00       	push   $0x341
f0118e37:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118e3c:	e8 f8 74 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118e41:	e8 5f ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e46:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e49:	74 17                	je     f0118e62 <test_fastfirstfit+0x677>
f0118e4b:	83 ec 04             	sub    $0x4,%esp
f0118e4e:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118e53:	68 42 03 00 00       	push   $0x342
f0118e58:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118e5d:	e8 d7 74 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118e62:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118e65:	e8 5c 54 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118e6a:	29 c3                	sub    %eax,%ebx
f0118e6c:	89 da                	mov    %ebx,%edx
f0118e6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118e71:	c1 e8 0c             	shr    $0xc,%eax
f0118e74:	39 c2                	cmp    %eax,%edx
f0118e76:	73 17                	jae    f0118e8f <test_fastfirstfit+0x6a4>
f0118e78:	83 ec 04             	sub    $0x4,%esp
f0118e7b:	68 48 c8 12 f0       	push   $0xf012c848
f0118e80:	68 43 03 00 00       	push   $0x343
f0118e85:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118e8a:	e8 aa 74 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e8f:	e8 11 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e94:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118e97:	e8 2a 54 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118e9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118e9f:	83 ec 0c             	sub    $0xc,%esp
f0118ea2:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118ea5:	e8 5a 03 ff ff       	call   f0109204 <kmalloc>
f0118eaa:	83 c4 10             	add    $0x10,%esp
f0118ead:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0118eb0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118eb3:	89 d0                	mov    %edx,%eax
f0118eb5:	c1 e0 02             	shl    $0x2,%eax
f0118eb8:	01 d0                	add    %edx,%eax
f0118eba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118ec1:	01 d0                	add    %edx,%eax
f0118ec3:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118ec9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118ecc:	39 c2                	cmp    %eax,%edx
f0118ece:	74 17                	je     f0118ee7 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0118ed0:	83 ec 04             	sub    $0x4,%esp
f0118ed3:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118ed8:	68 4c 03 00 00       	push   $0x34c
f0118edd:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118ee2:	e8 52 74 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118ee7:	e8 b9 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118eec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118eef:	74 17                	je     f0118f08 <test_fastfirstfit+0x71d>
f0118ef1:	83 ec 04             	sub    $0x4,%esp
f0118ef4:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118ef9:	68 4d 03 00 00       	push   $0x34d
f0118efe:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118f03:	e8 31 74 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118f08:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118f0b:	e8 b6 53 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118f10:	29 c3                	sub    %eax,%ebx
f0118f12:	89 da                	mov    %ebx,%edx
f0118f14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118f17:	c1 e8 0c             	shr    $0xc,%eax
f0118f1a:	39 c2                	cmp    %eax,%edx
f0118f1c:	73 17                	jae    f0118f35 <test_fastfirstfit+0x74a>
f0118f1e:	83 ec 04             	sub    $0x4,%esp
f0118f21:	68 48 c8 12 f0       	push   $0xf012c848
f0118f26:	68 4e 03 00 00       	push   $0x34e
f0118f2b:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118f30:	e8 04 74 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118f35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118f38:	d1 e8                	shr    %eax
f0118f3a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118f3d:	e8 63 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f42:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118f45:	e8 7c 53 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118f4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118f4d:	83 ec 0c             	sub    $0xc,%esp
f0118f50:	ff 75 dc             	pushl  -0x24(%ebp)
f0118f53:	e8 ac 02 ff ff       	call   f0109204 <kmalloc>
f0118f58:	83 c4 10             	add    $0x10,%esp
f0118f5b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0118f5e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118f61:	89 d0                	mov    %edx,%eax
f0118f63:	c1 e0 02             	shl    $0x2,%eax
f0118f66:	01 d0                	add    %edx,%eax
f0118f68:	01 c0                	add    %eax,%eax
f0118f6a:	89 c1                	mov    %eax,%ecx
f0118f6c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118f6f:	89 d0                	mov    %edx,%eax
f0118f71:	c1 e0 02             	shl    $0x2,%eax
f0118f74:	01 d0                	add    %edx,%eax
f0118f76:	d1 e8                	shr    %eax
f0118f78:	01 c8                	add    %ecx,%eax
f0118f7a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118f80:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118f83:	39 c2                	cmp    %eax,%edx
f0118f85:	74 17                	je     f0118f9e <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0118f87:	83 ec 04             	sub    $0x4,%esp
f0118f8a:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0118f8f:	68 58 03 00 00       	push   $0x358
f0118f94:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118f99:	e8 9b 73 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118f9e:	e8 02 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118fa3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118fa6:	74 17                	je     f0118fbf <test_fastfirstfit+0x7d4>
f0118fa8:	83 ec 04             	sub    $0x4,%esp
f0118fab:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0118fb0:	68 59 03 00 00       	push   $0x359
f0118fb5:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118fba:	e8 7a 73 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118fbf:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118fc2:	e8 ff 52 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0118fc7:	29 c3                	sub    %eax,%ebx
f0118fc9:	89 da                	mov    %ebx,%edx
f0118fcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118fce:	c1 e8 0c             	shr    $0xc,%eax
f0118fd1:	39 c2                	cmp    %eax,%edx
f0118fd3:	73 17                	jae    f0118fec <test_fastfirstfit+0x801>
f0118fd5:	83 ec 04             	sub    $0x4,%esp
f0118fd8:	68 48 c8 12 f0       	push   $0xf012c848
f0118fdd:	68 5a 03 00 00       	push   $0x35a
f0118fe2:	68 c7 c7 12 f0       	push   $0xf012c7c7
f0118fe7:	e8 4d 73 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118fec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118fef:	d1 e8                	shr    %eax
f0118ff1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118ff4:	e8 ac b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ff9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118ffc:	e8 c5 52 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119001:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119004:	83 ec 0c             	sub    $0xc,%esp
f0119007:	ff 75 dc             	pushl  -0x24(%ebp)
f011900a:	e8 f5 01 ff ff       	call   f0109204 <kmalloc>
f011900f:	83 c4 10             	add    $0x10,%esp
f0119012:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0119015:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119018:	83 e8 03             	sub    $0x3,%eax
f011901b:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f011901f:	89 c2                	mov    %eax,%edx
f0119021:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119024:	89 c1                	mov    %eax,%ecx
f0119026:	01 c9                	add    %ecx,%ecx
f0119028:	01 c8                	add    %ecx,%eax
f011902a:	d1 e8                	shr    %eax
f011902c:	01 d0                	add    %edx,%eax
f011902e:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119034:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119037:	39 c2                	cmp    %eax,%edx
f0119039:	74 17                	je     f0119052 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f011903b:	83 ec 04             	sub    $0x4,%esp
f011903e:	68 d8 c8 12 f0       	push   $0xf012c8d8
f0119043:	68 64 03 00 00       	push   $0x364
f0119048:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011904d:	e8 e7 72 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119052:	e8 4e b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119057:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011905a:	74 17                	je     f0119073 <test_fastfirstfit+0x888>
f011905c:	83 ec 04             	sub    $0x4,%esp
f011905f:	68 e0 c7 12 f0       	push   $0xf012c7e0
f0119064:	68 65 03 00 00       	push   $0x365
f0119069:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011906e:	e8 c6 72 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119073:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119076:	e8 4b 52 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011907b:	29 c3                	sub    %eax,%ebx
f011907d:	89 da                	mov    %ebx,%edx
f011907f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119082:	c1 e8 0c             	shr    $0xc,%eax
f0119085:	39 c2                	cmp    %eax,%edx
f0119087:	73 17                	jae    f01190a0 <test_fastfirstfit+0x8b5>
f0119089:	83 ec 04             	sub    $0x4,%esp
f011908c:	68 48 c8 12 f0       	push   $0xf012c848
f0119091:	68 66 03 00 00       	push   $0x366
f0119096:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011909b:	e8 99 72 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f01190a0:	83 ec 0c             	sub    $0xc,%esp
f01190a3:	68 f8 c8 12 f0       	push   $0xf012c8f8
f01190a8:	e8 de 7e fe ff       	call   f0100f8b <cprintf>
f01190ad:	83 c4 10             	add    $0x10,%esp
	return 1;
f01190b0:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01190b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01190b8:	c9                   	leave  
f01190b9:	c3                   	ret    

f01190ba <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f01190ba:	55                   	push   %ebp
f01190bb:	89 e5                	mov    %esp,%ebp
f01190bd:	57                   	push   %edi
f01190be:	53                   	push   %ebx
f01190bf:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01190c5:	83 ec 0c             	sub    $0xc,%esp
f01190c8:	68 68 a8 12 f0       	push   $0xf012a868
f01190cd:	e8 b9 7e fe ff       	call   f0100f8b <cprintf>
f01190d2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01190d5:	83 ec 0c             	sub    $0xc,%esp
f01190d8:	68 98 a8 12 f0       	push   $0xf012a898
f01190dd:	e8 a9 7e fe ff       	call   f0100f8b <cprintf>
f01190e2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01190e5:	83 ec 0c             	sub    $0xc,%esp
f01190e8:	68 68 a8 12 f0       	push   $0xf012a868
f01190ed:	e8 99 7e fe ff       	call   f0100f8b <cprintf>
f01190f2:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01190f5:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f01190f9:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f01190fd:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f0119103:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0119109:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119110:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119117:	e8 aa 51 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011911c:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011911f:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f0119125:	b9 14 00 00 00       	mov    $0x14,%ecx
f011912a:	b8 00 00 00 00       	mov    $0x0,%eax
f011912f:	89 d7                	mov    %edx,%edi
f0119131:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119133:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0119139:	b9 14 00 00 00       	mov    $0x14,%ecx
f011913e:	b8 00 00 00 00       	mov    $0x0,%eax
f0119143:	89 d7                	mov    %edx,%edi
f0119145:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119147:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011914e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119155:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011915c:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119162:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119167:	b8 00 00 00 00       	mov    $0x0,%eax
f011916c:	89 d7                	mov    %edx,%edi
f011916e:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119170:	83 ec 0c             	sub    $0xc,%esp
f0119173:	68 3c c9 12 f0       	push   $0xf012c93c
f0119178:	e8 0e 7e fe ff       	call   f0100f8b <cprintf>
f011917d:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119180:	e8 41 51 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119185:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119188:	e8 18 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011918d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119190:	83 ec 0c             	sub    $0xc,%esp
f0119193:	68 00 fc 1f 00       	push   $0x1ffc00
f0119198:	e8 67 00 ff ff       	call   f0109204 <kmalloc>
f011919d:	83 c4 10             	add    $0x10,%esp
f01191a0:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01191a6:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f01191ac:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01191b1:	74 17                	je     f01191ca <test_kfree_bestfirstfit+0x110>
f01191b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191ba:	83 ec 0c             	sub    $0xc,%esp
f01191bd:	68 74 c9 12 f0       	push   $0xf012c974
f01191c2:	e8 c4 7d fe ff       	call   f0100f8b <cprintf>
f01191c7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191ca:	e8 d6 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191cf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01191d2:	74 17                	je     f01191eb <test_kfree_bestfirstfit+0x131>
f01191d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191db:	83 ec 0c             	sub    $0xc,%esp
f01191de:	68 c8 c9 12 f0       	push   $0xf012c9c8
f01191e3:	e8 a3 7d fe ff       	call   f0100f8b <cprintf>
f01191e8:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01191eb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01191ee:	e8 d3 50 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01191f3:	29 c3                	sub    %eax,%ebx
f01191f5:	89 d8                	mov    %ebx,%eax
f01191f7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01191fc:	77 17                	ja     f0119215 <test_kfree_bestfirstfit+0x15b>
f01191fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119205:	83 ec 0c             	sub    $0xc,%esp
f0119208:	68 38 ca 12 f0       	push   $0xf012ca38
f011920d:	e8 79 7d fe ff       	call   f0100f8b <cprintf>
f0119212:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f0119215:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f011921c:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011921f:	e8 a2 50 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119224:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119227:	e8 79 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011922c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011922f:	83 ec 0c             	sub    $0xc,%esp
f0119232:	68 00 fc 1f 00       	push   $0x1ffc00
f0119237:	e8 c8 ff fe ff       	call   f0109204 <kmalloc>
f011923c:	83 c4 10             	add    $0x10,%esp
f011923f:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119245:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011924b:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119250:	74 17                	je     f0119269 <test_kfree_bestfirstfit+0x1af>
f0119252:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119259:	83 ec 0c             	sub    $0xc,%esp
f011925c:	68 80 ca 12 f0       	push   $0xf012ca80
f0119261:	e8 25 7d fe ff       	call   f0100f8b <cprintf>
f0119266:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119269:	e8 37 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011926e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119271:	74 17                	je     f011928a <test_kfree_bestfirstfit+0x1d0>
f0119273:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011927a:	83 ec 0c             	sub    $0xc,%esp
f011927d:	68 d4 ca 12 f0       	push   $0xf012cad4
f0119282:	e8 04 7d fe ff       	call   f0100f8b <cprintf>
f0119287:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011928a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011928d:	e8 34 50 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119292:	29 c3                	sub    %eax,%ebx
f0119294:	89 d8                	mov    %ebx,%eax
f0119296:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011929b:	77 17                	ja     f01192b4 <test_kfree_bestfirstfit+0x1fa>
f011929d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192a4:	83 ec 0c             	sub    $0xc,%esp
f01192a7:	68 44 cb 12 f0       	push   $0xf012cb44
f01192ac:	e8 da 7c fe ff       	call   f0100f8b <cprintf>
f01192b1:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f01192b4:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f01192bb:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f01192be:	e8 03 50 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01192c3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01192c6:	e8 da b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192cb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f01192ce:	83 ec 0c             	sub    $0xc,%esp
f01192d1:	68 00 1c 00 00       	push   $0x1c00
f01192d6:	e8 29 ff fe ff       	call   f0109204 <kmalloc>
f01192db:	83 c4 10             	add    $0x10,%esp
f01192de:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01192e4:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01192ea:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01192ef:	74 17                	je     f0119308 <test_kfree_bestfirstfit+0x24e>
f01192f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192f8:	83 ec 0c             	sub    $0xc,%esp
f01192fb:	68 8c cb 12 f0       	push   $0xf012cb8c
f0119300:	e8 86 7c fe ff       	call   f0100f8b <cprintf>
f0119305:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119308:	e8 98 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011930d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119310:	74 17                	je     f0119329 <test_kfree_bestfirstfit+0x26f>
f0119312:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119319:	83 ec 0c             	sub    $0xc,%esp
f011931c:	68 e0 cb 12 f0       	push   $0xf012cbe0
f0119321:	e8 65 7c fe ff       	call   f0100f8b <cprintf>
f0119326:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119329:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011932c:	e8 95 4f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119331:	29 c3                	sub    %eax,%ebx
f0119333:	89 d8                	mov    %ebx,%eax
f0119335:	83 f8 01             	cmp    $0x1,%eax
f0119338:	77 17                	ja     f0119351 <test_kfree_bestfirstfit+0x297>
f011933a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119341:	83 ec 0c             	sub    $0xc,%esp
f0119344:	68 50 cc 12 f0       	push   $0xf012cc50
f0119349:	e8 3d 7c fe ff       	call   f0100f8b <cprintf>
f011934e:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119351:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119358:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011935b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119361:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119364:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011936b:	eb 0e                	jmp    f011937b <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f011936d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119370:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119373:	01 d0                	add    %edx,%eax
f0119375:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119378:	ff 45 f4             	incl   -0xc(%ebp)
f011937b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119381:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119384:	7f e7                	jg     f011936d <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119386:	e8 3b 4f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011938b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011938e:	e8 12 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119393:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119396:	83 ec 0c             	sub    $0xc,%esp
f0119399:	68 00 fc 2f 00       	push   $0x2ffc00
f011939e:	e8 61 fe fe ff       	call   f0109204 <kmalloc>
f01193a3:	83 c4 10             	add    $0x10,%esp
f01193a6:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01193ac:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01193b2:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01193b7:	74 17                	je     f01193d0 <test_kfree_bestfirstfit+0x316>
f01193b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193c0:	83 ec 0c             	sub    $0xc,%esp
f01193c3:	68 98 cc 12 f0       	push   $0xf012cc98
f01193c8:	e8 be 7b fe ff       	call   f0100f8b <cprintf>
f01193cd:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193d0:	e8 d0 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193d5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01193d8:	74 17                	je     f01193f1 <test_kfree_bestfirstfit+0x337>
f01193da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193e1:	83 ec 0c             	sub    $0xc,%esp
f01193e4:	68 ec cc 12 f0       	push   $0xf012ccec
f01193e9:	e8 9d 7b fe ff       	call   f0100f8b <cprintf>
f01193ee:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01193f1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01193f4:	e8 cd 4e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01193f9:	29 c3                	sub    %eax,%ebx
f01193fb:	89 d8                	mov    %ebx,%eax
f01193fd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119402:	77 17                	ja     f011941b <test_kfree_bestfirstfit+0x361>
f0119404:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011940b:	83 ec 0c             	sub    $0xc,%esp
f011940e:	68 5c cd 12 f0       	push   $0xf012cd5c
f0119413:	e8 73 7b fe ff       	call   f0100f8b <cprintf>
f0119418:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011941b:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119422:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119425:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011942b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011942e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119435:	eb 0e                	jmp    f0119445 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119437:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011943a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011943d:	01 d0                	add    %edx,%eax
f011943f:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119442:	ff 45 f4             	incl   -0xc(%ebp)
f0119445:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011944b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011944e:	7f e7                	jg     f0119437 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119450:	e8 71 4e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119455:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119458:	e8 48 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011945d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119460:	83 ec 0c             	sub    $0xc,%esp
f0119463:	68 00 fc 5f 00       	push   $0x5ffc00
f0119468:	e8 97 fd fe ff       	call   f0109204 <kmalloc>
f011946d:	83 c4 10             	add    $0x10,%esp
f0119470:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119476:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011947c:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119481:	74 17                	je     f011949a <test_kfree_bestfirstfit+0x3e0>
f0119483:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011948a:	83 ec 0c             	sub    $0xc,%esp
f011948d:	68 a4 cd 12 f0       	push   $0xf012cda4
f0119492:	e8 f4 7a fe ff       	call   f0100f8b <cprintf>
f0119497:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011949a:	e8 06 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011949f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01194a2:	74 17                	je     f01194bb <test_kfree_bestfirstfit+0x401>
f01194a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194ab:	83 ec 0c             	sub    $0xc,%esp
f01194ae:	68 f8 cd 12 f0       	push   $0xf012cdf8
f01194b3:	e8 d3 7a fe ff       	call   f0100f8b <cprintf>
f01194b8:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01194bb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01194be:	e8 03 4e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01194c3:	29 c3                	sub    %eax,%ebx
f01194c5:	89 d8                	mov    %ebx,%eax
f01194c7:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01194cc:	77 17                	ja     f01194e5 <test_kfree_bestfirstfit+0x42b>
f01194ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194d5:	83 ec 0c             	sub    $0xc,%esp
f01194d8:	68 68 ce 12 f0       	push   $0xf012ce68
f01194dd:	e8 a9 7a fe ff       	call   f0100f8b <cprintf>
f01194e2:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f01194e5:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f01194ec:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f01194ef:	e8 d2 4d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01194f4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01194f7:	e8 a9 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194fc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f01194ff:	83 ec 0c             	sub    $0xc,%esp
f0119502:	68 00 38 00 00       	push   $0x3800
f0119507:	e8 f8 fc fe ff       	call   f0109204 <kmalloc>
f011950c:	83 c4 10             	add    $0x10,%esp
f011950f:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119515:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011951b:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119520:	74 17                	je     f0119539 <test_kfree_bestfirstfit+0x47f>
f0119522:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119529:	83 ec 0c             	sub    $0xc,%esp
f011952c:	68 b0 ce 12 f0       	push   $0xf012ceb0
f0119531:	e8 55 7a fe ff       	call   f0100f8b <cprintf>
f0119536:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119539:	e8 67 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011953e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119541:	74 17                	je     f011955a <test_kfree_bestfirstfit+0x4a0>
f0119543:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011954a:	83 ec 0c             	sub    $0xc,%esp
f011954d:	68 04 cf 12 f0       	push   $0xf012cf04
f0119552:	e8 34 7a fe ff       	call   f0100f8b <cprintf>
f0119557:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011955a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011955d:	e8 64 4d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119562:	29 c3                	sub    %eax,%ebx
f0119564:	89 d8                	mov    %ebx,%eax
f0119566:	83 f8 03             	cmp    $0x3,%eax
f0119569:	77 17                	ja     f0119582 <test_kfree_bestfirstfit+0x4c8>
f011956b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119572:	83 ec 0c             	sub    $0xc,%esp
f0119575:	68 74 cf 12 f0       	push   $0xf012cf74
f011957a:	e8 0c 7a fe ff       	call   f0100f8b <cprintf>
f011957f:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119582:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119589:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011958f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119592:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119599:	eb 0e                	jmp    f01195a9 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f011959b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011959e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01195a1:	01 d0                	add    %edx,%eax
f01195a3:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f01195a6:	ff 45 f4             	incl   -0xc(%ebp)
f01195a9:	8b 45 80             	mov    -0x80(%ebp),%eax
f01195ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01195af:	7f ea                	jg     f011959b <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f01195b1:	e8 10 4d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01195b6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f01195b9:	e8 e7 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195be:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f01195c1:	83 ec 0c             	sub    $0xc,%esp
f01195c4:	68 00 08 00 00       	push   $0x800
f01195c9:	e8 36 fc fe ff       	call   f0109204 <kmalloc>
f01195ce:	83 c4 10             	add    $0x10,%esp
f01195d1:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01195d7:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01195dd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01195e2:	76 28                	jbe    f011960c <test_kfree_bestfirstfit+0x552>
f01195e4:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f01195ea:	83 ec 0c             	sub    $0xc,%esp
f01195ed:	6a 00                	push   $0x0
f01195ef:	e8 dd fa fe ff       	call   f01090d1 <sbrk>
f01195f4:	83 c4 10             	add    $0x10,%esp
f01195f7:	39 c3                	cmp    %eax,%ebx
f01195f9:	73 11                	jae    f011960c <test_kfree_bestfirstfit+0x552>
f01195fb:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119601:	89 c2                	mov    %eax,%edx
f0119603:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f0119608:	39 c2                	cmp    %eax,%edx
f011960a:	72 17                	jb     f0119623 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011960c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119613:	83 ec 0c             	sub    $0xc,%esp
f0119616:	68 bc cf 12 f0       	push   $0xf012cfbc
f011961b:	e8 6b 79 fe ff       	call   f0100f8b <cprintf>
f0119620:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119623:	e8 7d b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119628:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011962b:	74 17                	je     f0119644 <test_kfree_bestfirstfit+0x58a>
f011962d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119634:	83 ec 0c             	sub    $0xc,%esp
f0119637:	68 48 d0 12 f0       	push   $0xf012d048
f011963c:	e8 4a 79 fe ff       	call   f0100f8b <cprintf>
f0119641:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119644:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f011964b:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011964e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119654:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119657:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011965e:	eb 0e                	jmp    f011966e <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119660:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119663:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119666:	01 d0                	add    %edx,%eax
f0119668:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011966b:	ff 45 f4             	incl   -0xc(%ebp)
f011966e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119674:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119677:	7f e7                	jg     f0119660 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119679:	e8 27 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011967e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119681:	83 ec 0c             	sub    $0xc,%esp
f0119684:	68 00 08 00 00       	push   $0x800
f0119689:	e8 76 fb fe ff       	call   f0109204 <kmalloc>
f011968e:	83 c4 10             	add    $0x10,%esp
f0119691:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119697:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011969d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01196a2:	76 28                	jbe    f01196cc <test_kfree_bestfirstfit+0x612>
f01196a4:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f01196aa:	83 ec 0c             	sub    $0xc,%esp
f01196ad:	6a 00                	push   $0x0
f01196af:	e8 1d fa fe ff       	call   f01090d1 <sbrk>
f01196b4:	83 c4 10             	add    $0x10,%esp
f01196b7:	39 c3                	cmp    %eax,%ebx
f01196b9:	73 11                	jae    f01196cc <test_kfree_bestfirstfit+0x612>
f01196bb:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01196c1:	89 c2                	mov    %eax,%edx
f01196c3:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01196c8:	39 c2                	cmp    %eax,%edx
f01196ca:	72 17                	jb     f01196e3 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01196cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196d3:	83 ec 0c             	sub    $0xc,%esp
f01196d6:	68 b8 d0 12 f0       	push   $0xf012d0b8
f01196db:	e8 ab 78 fe ff       	call   f0100f8b <cprintf>
f01196e0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01196e3:	e8 bd b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196e8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01196eb:	74 17                	je     f0119704 <test_kfree_bestfirstfit+0x64a>
f01196ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196f4:	83 ec 0c             	sub    $0xc,%esp
f01196f7:	68 44 d1 12 f0       	push   $0xf012d144
f01196fc:	e8 8a 78 fe ff       	call   f0100f8b <cprintf>
f0119701:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119704:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011970b:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011970e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119714:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119717:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011971e:	eb 0e                	jmp    f011972e <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119720:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119723:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119726:	01 d0                	add    %edx,%eax
f0119728:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011972b:	ff 45 f4             	incl   -0xc(%ebp)
f011972e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119734:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119737:	7f e7                	jg     f0119720 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119739:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011973c:	e8 85 4b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119741:	29 c3                	sub    %eax,%ebx
f0119743:	89 d8                	mov    %ebx,%eax
f0119745:	83 f8 01             	cmp    $0x1,%eax
f0119748:	74 17                	je     f0119761 <test_kfree_bestfirstfit+0x6a7>
f011974a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119751:	83 ec 0c             	sub    $0xc,%esp
f0119754:	68 b4 d1 12 f0       	push   $0xf012d1b4
f0119759:	e8 2d 78 fe ff       	call   f0100f8b <cprintf>
f011975e:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119761:	83 ec 0c             	sub    $0xc,%esp
f0119764:	68 d8 d1 12 f0       	push   $0xf012d1d8
f0119769:	e8 1d 78 fe ff       	call   f0100f8b <cprintf>
f011976e:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119771:	e8 50 4b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119776:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119779:	e8 27 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011977e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119781:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119787:	83 ec 0c             	sub    $0xc,%esp
f011978a:	50                   	push   %eax
f011978b:	e8 d4 fc fe ff       	call   f0109464 <kfree>
f0119790:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119793:	e8 0d b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119798:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011979b:	74 17                	je     f01197b4 <test_kfree_bestfirstfit+0x6fa>
f011979d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197a4:	83 ec 0c             	sub    $0xc,%esp
f01197a7:	68 08 d2 12 f0       	push   $0xf012d208
f01197ac:	e8 da 77 fe ff       	call   f0100f8b <cprintf>
f01197b1:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f01197b4:	e8 0d 4b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01197b9:	89 c2                	mov    %eax,%edx
f01197bb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01197be:	29 c2                	sub    %eax,%edx
f01197c0:	89 d0                	mov    %edx,%eax
f01197c2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01197c7:	77 17                	ja     f01197e0 <test_kfree_bestfirstfit+0x726>
f01197c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197d0:	83 ec 0c             	sub    $0xc,%esp
f01197d3:	68 78 d2 12 f0       	push   $0xf012d278
f01197d8:	e8 ae 77 fe ff       	call   f0100f8b <cprintf>
f01197dd:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f01197e0:	e8 e1 4a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01197e5:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01197e8:	e8 b8 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197ed:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f01197f0:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01197f6:	83 ec 0c             	sub    $0xc,%esp
f01197f9:	50                   	push   %eax
f01197fa:	e8 65 fc fe ff       	call   f0109464 <kfree>
f01197ff:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119802:	e8 9e b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119807:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011980a:	74 17                	je     f0119823 <test_kfree_bestfirstfit+0x769>
f011980c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119813:	83 ec 0c             	sub    $0xc,%esp
f0119816:	68 b4 d2 12 f0       	push   $0xf012d2b4
f011981b:	e8 6b 77 fe ff       	call   f0100f8b <cprintf>
f0119820:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119823:	e8 9e 4a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119828:	89 c2                	mov    %eax,%edx
f011982a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011982d:	39 c2                	cmp    %eax,%edx
f011982f:	74 17                	je     f0119848 <test_kfree_bestfirstfit+0x78e>
f0119831:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119838:	83 ec 0c             	sub    $0xc,%esp
f011983b:	68 24 d3 12 f0       	push   $0xf012d324
f0119840:	e8 46 77 fe ff       	call   f0100f8b <cprintf>
f0119845:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119848:	e8 79 4a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011984d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119850:	e8 50 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119855:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119858:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011985e:	83 ec 0c             	sub    $0xc,%esp
f0119861:	50                   	push   %eax
f0119862:	e8 fd fb fe ff       	call   f0109464 <kfree>
f0119867:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011986a:	e8 36 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011986f:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119872:	74 17                	je     f011988b <test_kfree_bestfirstfit+0x7d1>
f0119874:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011987b:	83 ec 0c             	sub    $0xc,%esp
f011987e:	68 84 d3 12 f0       	push   $0xf012d384
f0119883:	e8 03 77 fe ff       	call   f0100f8b <cprintf>
f0119888:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011988b:	e8 36 4a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119890:	89 c2                	mov    %eax,%edx
f0119892:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119895:	29 c2                	sub    %eax,%edx
f0119897:	89 d0                	mov    %edx,%eax
f0119899:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011989e:	77 17                	ja     f01198b7 <test_kfree_bestfirstfit+0x7fd>
f01198a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198a7:	83 ec 0c             	sub    $0xc,%esp
f01198aa:	68 f4 d3 12 f0       	push   $0xf012d3f4
f01198af:	e8 d7 76 fe ff       	call   f0100f8b <cprintf>
f01198b4:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f01198b7:	e8 0a 4a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01198bc:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01198bf:	e8 e1 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198c4:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f01198c7:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f01198cd:	83 ec 0c             	sub    $0xc,%esp
f01198d0:	50                   	push   %eax
f01198d1:	e8 8e fb fe ff       	call   f0109464 <kfree>
f01198d6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198d9:	e8 c7 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198de:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01198e1:	74 17                	je     f01198fa <test_kfree_bestfirstfit+0x840>
f01198e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198ea:	83 ec 0c             	sub    $0xc,%esp
f01198ed:	68 30 d4 12 f0       	push   $0xf012d430
f01198f2:	e8 94 76 fe ff       	call   f0100f8b <cprintf>
f01198f7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f01198fa:	e8 c7 49 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f01198ff:	89 c2                	mov    %eax,%edx
f0119901:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119904:	29 c2                	sub    %eax,%edx
f0119906:	89 d0                	mov    %edx,%eax
f0119908:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011990d:	77 17                	ja     f0119926 <test_kfree_bestfirstfit+0x86c>
f011990f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119916:	83 ec 0c             	sub    $0xc,%esp
f0119919:	68 a0 d4 12 f0       	push   $0xf012d4a0
f011991e:	e8 68 76 fe ff       	call   f0100f8b <cprintf>
f0119923:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119926:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011992a:	74 04                	je     f0119930 <test_kfree_bestfirstfit+0x876>
f011992c:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119930:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0119937:	83 ec 0c             	sub    $0xc,%esp
f011993a:	68 dc d4 12 f0       	push   $0xf012d4dc
f011993f:	e8 47 76 fe ff       	call   f0100f8b <cprintf>
f0119944:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0119947:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011994d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0119950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119957:	eb 1e                	jmp    f0119977 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0119959:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011995f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119962:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119965:	01 c8                	add    %ecx,%eax
f0119967:	8a 00                	mov    (%eax),%al
f0119969:	0f be c0             	movsbl %al,%eax
f011996c:	01 d0                	add    %edx,%eax
f011996e:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119974:	ff 45 f4             	incl   -0xc(%ebp)
f0119977:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011997d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119980:	7f d7                	jg     f0119959 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119982:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119988:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011998e:	89 c1                	mov    %eax,%ecx
f0119990:	01 c9                	add    %ecx,%ecx
f0119992:	01 c8                	add    %ecx,%eax
f0119994:	39 c2                	cmp    %eax,%edx
f0119996:	74 17                	je     f01199af <test_kfree_bestfirstfit+0x8f5>
f0119998:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011999f:	83 ec 0c             	sub    $0xc,%esp
f01199a2:	68 24 d5 12 f0       	push   $0xf012d524
f01199a7:	e8 df 75 fe ff       	call   f0100f8b <cprintf>
f01199ac:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f01199af:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01199b5:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f01199b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199bf:	eb 1e                	jmp    f01199df <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f01199c1:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f01199c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01199ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199cd:	01 c8                	add    %ecx,%eax
f01199cf:	8a 00                	mov    (%eax),%al
f01199d1:	0f be c0             	movsbl %al,%eax
f01199d4:	01 d0                	add    %edx,%eax
f01199d6:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f01199dc:	ff 45 f4             	incl   -0xc(%ebp)
f01199df:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01199e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01199e8:	7f d7                	jg     f01199c1 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f01199ea:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01199f0:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f01199f6:	c1 e2 02             	shl    $0x2,%edx
f01199f9:	39 d0                	cmp    %edx,%eax
f01199fb:	74 17                	je     f0119a14 <test_kfree_bestfirstfit+0x95a>
f01199fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a04:	83 ec 0c             	sub    $0xc,%esp
f0119a07:	68 5c d5 12 f0       	push   $0xf012d55c
f0119a0c:	e8 7a 75 fe ff       	call   f0100f8b <cprintf>
f0119a11:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f0119a14:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119a1a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f0119a1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a24:	eb 1e                	jmp    f0119a44 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f0119a26:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f0119a2c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119a2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a32:	01 c8                	add    %ecx,%eax
f0119a34:	8a 00                	mov    (%eax),%al
f0119a36:	0f be c0             	movsbl %al,%eax
f0119a39:	01 d0                	add    %edx,%eax
f0119a3b:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f0119a41:	ff 45 f4             	incl   -0xc(%ebp)
f0119a44:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119a4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a4d:	7f d7                	jg     f0119a26 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0119a4f:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f0119a55:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0119a5b:	89 d0                	mov    %edx,%eax
f0119a5d:	c1 e0 02             	shl    $0x2,%eax
f0119a60:	01 d0                	add    %edx,%eax
f0119a62:	39 c1                	cmp    %eax,%ecx
f0119a64:	74 17                	je     f0119a7d <test_kfree_bestfirstfit+0x9c3>
f0119a66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a6d:	83 ec 0c             	sub    $0xc,%esp
f0119a70:	68 94 d5 12 f0       	push   $0xf012d594
f0119a75:	e8 11 75 fe ff       	call   f0100f8b <cprintf>
f0119a7a:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0119a7d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119a83:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f0119a86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a8d:	eb 1e                	jmp    f0119aad <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f0119a8f:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f0119a95:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119a98:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a9b:	01 c8                	add    %ecx,%eax
f0119a9d:	8a 00                	mov    (%eax),%al
f0119a9f:	0f be c0             	movsbl %al,%eax
f0119aa2:	01 d0                	add    %edx,%eax
f0119aa4:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f0119aaa:	ff 45 f4             	incl   -0xc(%ebp)
f0119aad:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119ab0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119ab3:	7f da                	jg     f0119a8f <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f0119ab5:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f0119abb:	8b 55 80             	mov    -0x80(%ebp),%edx
f0119abe:	89 d0                	mov    %edx,%eax
f0119ac0:	01 c0                	add    %eax,%eax
f0119ac2:	01 d0                	add    %edx,%eax
f0119ac4:	01 c0                	add    %eax,%eax
f0119ac6:	01 d0                	add    %edx,%eax
f0119ac8:	39 c1                	cmp    %eax,%ecx
f0119aca:	74 17                	je     f0119ae3 <test_kfree_bestfirstfit+0xa29>
f0119acc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ad3:	83 ec 0c             	sub    $0xc,%esp
f0119ad6:	68 cc d5 12 f0       	push   $0xf012d5cc
f0119adb:	e8 ab 74 fe ff       	call   f0100f8b <cprintf>
f0119ae0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119ae3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119ae7:	74 04                	je     f0119aed <test_kfree_bestfirstfit+0xa33>
f0119ae9:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119aed:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f0119af4:	83 ec 0c             	sub    $0xc,%esp
f0119af7:	68 04 d6 12 f0       	push   $0xf012d604
f0119afc:	e8 8a 74 fe ff       	call   f0100f8b <cprintf>
f0119b01:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f0119b04:	e8 bd 47 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119b09:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119b0c:	e8 94 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b11:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f0119b14:	83 ec 0c             	sub    $0xc,%esp
f0119b17:	68 00 04 00 00       	push   $0x400
f0119b1c:	e8 e3 f6 fe ff       	call   f0109204 <kmalloc>
f0119b21:	83 c4 10             	add    $0x10,%esp
f0119b24:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f0119b2a:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0119b30:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119b36:	39 c2                	cmp    %eax,%edx
f0119b38:	74 17                	je     f0119b51 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b41:	83 ec 0c             	sub    $0xc,%esp
f0119b44:	68 24 d6 12 f0       	push   $0xf012d624
f0119b49:	e8 3d 74 fe ff       	call   f0100f8b <cprintf>
f0119b4e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b51:	e8 4f ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b56:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b59:	74 17                	je     f0119b72 <test_kfree_bestfirstfit+0xab8>
f0119b5b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b62:	83 ec 0c             	sub    $0xc,%esp
f0119b65:	68 78 d6 12 f0       	push   $0xf012d678
f0119b6a:	e8 1c 74 fe ff       	call   f0100f8b <cprintf>
f0119b6f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0119b72:	e8 4f 47 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119b77:	89 c2                	mov    %eax,%edx
f0119b79:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119b7c:	39 c2                	cmp    %eax,%edx
f0119b7e:	74 17                	je     f0119b97 <test_kfree_bestfirstfit+0xadd>
f0119b80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b87:	83 ec 0c             	sub    $0xc,%esp
f0119b8a:	68 e8 d6 12 f0       	push   $0xf012d6e8
f0119b8f:	e8 f7 73 fe ff       	call   f0100f8b <cprintf>
f0119b94:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f0119b97:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f0119b9e:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119ba4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f0119ba7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119bae:	eb 0e                	jmp    f0119bbe <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f0119bb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119bb3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119bb6:	01 d0                	add    %edx,%eax
f0119bb8:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0119bbb:	ff 45 f4             	incl   -0xc(%ebp)
f0119bbe:	8b 45 88             	mov    -0x78(%ebp),%eax
f0119bc1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119bc4:	7f ea                	jg     f0119bb0 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f0119bc6:	e8 fb 46 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119bcb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119bce:	e8 d2 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bd3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f0119bd6:	83 ec 0c             	sub    $0xc,%esp
f0119bd9:	68 00 00 30 00       	push   $0x300000
f0119bde:	e8 21 f6 fe ff       	call   f0109204 <kmalloc>
f0119be3:	83 c4 10             	add    $0x10,%esp
f0119be6:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119bec:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119bf2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119bf7:	74 17                	je     f0119c10 <test_kfree_bestfirstfit+0xb56>
f0119bf9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c00:	83 ec 0c             	sub    $0xc,%esp
f0119c03:	68 64 d7 12 f0       	push   $0xf012d764
f0119c08:	e8 7e 73 fe ff       	call   f0100f8b <cprintf>
f0119c0d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c10:	e8 90 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c15:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c18:	74 17                	je     f0119c31 <test_kfree_bestfirstfit+0xb77>
f0119c1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c21:	83 ec 0c             	sub    $0xc,%esp
f0119c24:	68 b8 d7 12 f0       	push   $0xf012d7b8
f0119c29:	e8 5d 73 fe ff       	call   f0100f8b <cprintf>
f0119c2e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119c31:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119c34:	e8 8d 46 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119c39:	29 c3                	sub    %eax,%ebx
f0119c3b:	89 d8                	mov    %ebx,%eax
f0119c3d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119c42:	77 17                	ja     f0119c5b <test_kfree_bestfirstfit+0xba1>
f0119c44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c4b:	83 ec 0c             	sub    $0xc,%esp
f0119c4e:	68 28 d8 12 f0       	push   $0xf012d828
f0119c53:	e8 33 73 fe ff       	call   f0100f8b <cprintf>
f0119c58:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f0119c5b:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f0119c62:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119c68:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f0119c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c72:	eb 0e                	jmp    f0119c82 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f0119c74:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c77:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c7a:	01 d0                	add    %edx,%eax
f0119c7c:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f0119c7f:	ff 45 f4             	incl   -0xc(%ebp)
f0119c82:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0119c85:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c88:	7f ea                	jg     f0119c74 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f0119c8a:	e8 37 46 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119c8f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119c92:	e8 0e ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c97:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f0119c9a:	83 ec 0c             	sub    $0xc,%esp
f0119c9d:	68 00 00 10 00       	push   $0x100000
f0119ca2:	e8 5d f5 fe ff       	call   f0109204 <kmalloc>
f0119ca7:	83 c4 10             	add    $0x10,%esp
f0119caa:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119cb0:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119cb6:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0119cbb:	74 17                	je     f0119cd4 <test_kfree_bestfirstfit+0xc1a>
f0119cbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cc4:	83 ec 0c             	sub    $0xc,%esp
f0119cc7:	68 70 d8 12 f0       	push   $0xf012d870
f0119ccc:	e8 ba 72 fe ff       	call   f0100f8b <cprintf>
f0119cd1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119cd4:	e8 cc ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cd9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119cdc:	74 17                	je     f0119cf5 <test_kfree_bestfirstfit+0xc3b>
f0119cde:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ce5:	83 ec 0c             	sub    $0xc,%esp
f0119ce8:	68 c4 d8 12 f0       	push   $0xf012d8c4
f0119ced:	e8 99 72 fe ff       	call   f0100f8b <cprintf>
f0119cf2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119cf5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119cf8:	e8 c9 45 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119cfd:	29 c3                	sub    %eax,%ebx
f0119cff:	89 d8                	mov    %ebx,%eax
f0119d01:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119d06:	77 17                	ja     f0119d1f <test_kfree_bestfirstfit+0xc65>
f0119d08:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d0f:	83 ec 0c             	sub    $0xc,%esp
f0119d12:	68 34 d9 12 f0       	push   $0xf012d934
f0119d17:	e8 6f 72 fe ff       	call   f0100f8b <cprintf>
f0119d1c:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f0119d1f:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f0119d26:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119d2c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f0119d2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d36:	eb 0e                	jmp    f0119d46 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f0119d38:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d3b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119d3e:	01 d0                	add    %edx,%eax
f0119d40:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f0119d43:	ff 45 f4             	incl   -0xc(%ebp)
f0119d46:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119d49:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119d4c:	7f ea                	jg     f0119d38 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0119d4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119d52:	74 04                	je     f0119d58 <test_kfree_bestfirstfit+0xc9e>
f0119d54:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119d58:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f0119d5f:	83 ec 0c             	sub    $0xc,%esp
f0119d62:	68 7c d9 12 f0       	push   $0xf012d97c
f0119d67:	e8 1f 72 fe ff       	call   f0100f8b <cprintf>
f0119d6c:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f0119d6f:	e8 52 45 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119d74:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d77:	e8 29 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d7c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f0119d7f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119d85:	83 ec 0c             	sub    $0xc,%esp
f0119d88:	50                   	push   %eax
f0119d89:	e8 d6 f6 fe ff       	call   f0109464 <kfree>
f0119d8e:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d91:	e8 0f ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d96:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d99:	74 17                	je     f0119db2 <test_kfree_bestfirstfit+0xcf8>
f0119d9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119da2:	83 ec 0c             	sub    $0xc,%esp
f0119da5:	68 a8 d9 12 f0       	push   $0xf012d9a8
f0119daa:	e8 dc 71 fe ff       	call   f0100f8b <cprintf>
f0119daf:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119db2:	e8 0f 45 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119db7:	89 c2                	mov    %eax,%edx
f0119db9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119dbc:	29 c2                	sub    %eax,%edx
f0119dbe:	89 d0                	mov    %edx,%eax
f0119dc0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119dc5:	77 17                	ja     f0119dde <test_kfree_bestfirstfit+0xd24>
f0119dc7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dce:	83 ec 0c             	sub    $0xc,%esp
f0119dd1:	68 18 da 12 f0       	push   $0xf012da18
f0119dd6:	e8 b0 71 fe ff       	call   f0100f8b <cprintf>
f0119ddb:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f0119dde:	e8 e3 44 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119de3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119de6:	e8 ba aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119deb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f0119dee:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119df4:	83 ec 0c             	sub    $0xc,%esp
f0119df7:	50                   	push   %eax
f0119df8:	e8 67 f6 fe ff       	call   f0109464 <kfree>
f0119dfd:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e00:	e8 a0 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e05:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e08:	74 17                	je     f0119e21 <test_kfree_bestfirstfit+0xd67>
f0119e0a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e11:	83 ec 0c             	sub    $0xc,%esp
f0119e14:	68 54 da 12 f0       	push   $0xf012da54
f0119e19:	e8 6d 71 fe ff       	call   f0100f8b <cprintf>
f0119e1e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e21:	e8 a0 44 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119e26:	89 c2                	mov    %eax,%edx
f0119e28:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e2b:	29 c2                	sub    %eax,%edx
f0119e2d:	89 d0                	mov    %edx,%eax
f0119e2f:	83 f8 01             	cmp    $0x1,%eax
f0119e32:	77 17                	ja     f0119e4b <test_kfree_bestfirstfit+0xd91>
f0119e34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e3b:	83 ec 0c             	sub    $0xc,%esp
f0119e3e:	68 c4 da 12 f0       	push   $0xf012dac4
f0119e43:	e8 43 71 fe ff       	call   f0100f8b <cprintf>
f0119e48:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119e4b:	e8 76 44 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119e50:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e53:	e8 4d aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e58:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f0119e5b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119e61:	83 ec 0c             	sub    $0xc,%esp
f0119e64:	50                   	push   %eax
f0119e65:	e8 fa f5 fe ff       	call   f0109464 <kfree>
f0119e6a:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e6d:	e8 33 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e72:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e75:	74 17                	je     f0119e8e <test_kfree_bestfirstfit+0xdd4>
f0119e77:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e7e:	83 ec 0c             	sub    $0xc,%esp
f0119e81:	68 00 db 12 f0       	push   $0xf012db00
f0119e86:	e8 00 71 fe ff       	call   f0100f8b <cprintf>
f0119e8b:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e8e:	e8 33 44 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119e93:	89 c2                	mov    %eax,%edx
f0119e95:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e98:	29 c2                	sub    %eax,%edx
f0119e9a:	89 d0                	mov    %edx,%eax
f0119e9c:	83 f8 03             	cmp    $0x3,%eax
f0119e9f:	77 17                	ja     f0119eb8 <test_kfree_bestfirstfit+0xdfe>
f0119ea1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea8:	83 ec 0c             	sub    $0xc,%esp
f0119eab:	68 70 db 12 f0       	push   $0xf012db70
f0119eb0:	e8 d6 70 fe ff       	call   f0100f8b <cprintf>
f0119eb5:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f0119eb8:	e8 09 44 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119ebd:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ec0:	e8 e0 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ec5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f0119ec8:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119ece:	83 ec 0c             	sub    $0xc,%esp
f0119ed1:	50                   	push   %eax
f0119ed2:	e8 8d f5 fe ff       	call   f0109464 <kfree>
f0119ed7:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119eda:	e8 c6 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119edf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119ee2:	74 17                	je     f0119efb <test_kfree_bestfirstfit+0xe41>
f0119ee4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eeb:	83 ec 0c             	sub    $0xc,%esp
f0119eee:	68 ac db 12 f0       	push   $0xf012dbac
f0119ef3:	e8 93 70 fe ff       	call   f0100f8b <cprintf>
f0119ef8:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119efb:	e8 c6 43 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119f00:	89 c2                	mov    %eax,%edx
f0119f02:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119f05:	29 c2                	sub    %eax,%edx
f0119f07:	89 d0                	mov    %edx,%eax
f0119f09:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119f0e:	77 17                	ja     f0119f27 <test_kfree_bestfirstfit+0xe6d>
f0119f10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f17:	83 ec 0c             	sub    $0xc,%esp
f0119f1a:	68 1c dc 12 f0       	push   $0xf012dc1c
f0119f1f:	e8 67 70 fe ff       	call   f0100f8b <cprintf>
f0119f24:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f0119f27:	e8 9a 43 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119f2c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f2f:	e8 71 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f34:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f0119f37:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119f3d:	83 ec 0c             	sub    $0xc,%esp
f0119f40:	50                   	push   %eax
f0119f41:	e8 1e f5 fe ff       	call   f0109464 <kfree>
f0119f46:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f49:	e8 57 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f4e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f51:	74 17                	je     f0119f6a <test_kfree_bestfirstfit+0xeb0>
f0119f53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f5a:	83 ec 0c             	sub    $0xc,%esp
f0119f5d:	68 58 dc 12 f0       	push   $0xf012dc58
f0119f62:	e8 24 70 fe ff       	call   f0100f8b <cprintf>
f0119f67:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f6a:	e8 57 43 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119f6f:	89 c2                	mov    %eax,%edx
f0119f71:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119f74:	29 c2                	sub    %eax,%edx
f0119f76:	89 d0                	mov    %edx,%eax
f0119f78:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119f7d:	77 17                	ja     f0119f96 <test_kfree_bestfirstfit+0xedc>
f0119f7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f86:	83 ec 0c             	sub    $0xc,%esp
f0119f89:	68 c8 dc 12 f0       	push   $0xf012dcc8
f0119f8e:	e8 f8 6f fe ff       	call   f0100f8b <cprintf>
f0119f93:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f0119f96:	e8 2b 43 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119f9b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f9e:	e8 02 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119fa3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f0119fa6:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119fac:	83 ec 0c             	sub    $0xc,%esp
f0119faf:	50                   	push   %eax
f0119fb0:	e8 af f4 fe ff       	call   f0109464 <kfree>
f0119fb5:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119fb8:	e8 e8 a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119fbd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119fc0:	74 17                	je     f0119fd9 <test_kfree_bestfirstfit+0xf1f>
f0119fc2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fc9:	83 ec 0c             	sub    $0xc,%esp
f0119fcc:	68 04 dd 12 f0       	push   $0xf012dd04
f0119fd1:	e8 b5 6f fe ff       	call   f0100f8b <cprintf>
f0119fd6:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119fd9:	e8 e8 42 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f0119fde:	89 c2                	mov    %eax,%edx
f0119fe0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119fe3:	39 c2                	cmp    %eax,%edx
f0119fe5:	74 17                	je     f0119ffe <test_kfree_bestfirstfit+0xf44>
f0119fe7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fee:	83 ec 0c             	sub    $0xc,%esp
f0119ff1:	68 74 dd 12 f0       	push   $0xf012dd74
f0119ff6:	e8 90 6f fe ff       	call   f0100f8b <cprintf>
f0119ffb:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f0119ffe:	e8 c3 42 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a003:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a006:	e8 9a a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a00b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a00e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a014:	83 ec 0c             	sub    $0xc,%esp
f011a017:	50                   	push   %eax
f011a018:	e8 47 f4 fe ff       	call   f0109464 <kfree>
f011a01d:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a020:	e8 80 a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a025:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a028:	74 17                	je     f011a041 <test_kfree_bestfirstfit+0xf87>
f011a02a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a031:	83 ec 0c             	sub    $0xc,%esp
f011a034:	68 b0 dd 12 f0       	push   $0xf012ddb0
f011a039:	e8 4d 6f fe ff       	call   f0100f8b <cprintf>
f011a03e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a041:	e8 80 42 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a046:	89 c2                	mov    %eax,%edx
f011a048:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a04b:	39 c2                	cmp    %eax,%edx
f011a04d:	74 17                	je     f011a066 <test_kfree_bestfirstfit+0xfac>
f011a04f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a056:	83 ec 0c             	sub    $0xc,%esp
f011a059:	68 20 de 12 f0       	push   $0xf012de20
f011a05e:	e8 28 6f fe ff       	call   f0100f8b <cprintf>
f011a063:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a066:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a06a:	74 04                	je     f011a070 <test_kfree_bestfirstfit+0xfb6>
f011a06c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a070:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a077:	83 ec 0c             	sub    $0xc,%esp
f011a07a:	68 80 de 12 f0       	push   $0xf012de80
f011a07f:	e8 07 6f fe ff       	call   f0100f8b <cprintf>
f011a084:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a087:	83 ec 0c             	sub    $0xc,%esp
f011a08a:	6a 03                	push   $0x3
f011a08c:	e8 5e 46 ff ff       	call   f010e6ef <sys_bypassPageFault>
f011a091:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a094:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a09b:	e9 af 00 00 00       	jmp    f011a14f <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a0a0:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a0a4:	0f 84 a1 00 00 00    	je     f011a14b <test_kfree_bestfirstfit+0x1091>
f011a0aa:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a0ae:	0f 84 97 00 00 00    	je     f011a14b <test_kfree_bestfirstfit+0x1091>
f011a0b4:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a0b8:	0f 84 8d 00 00 00    	je     f011a14b <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a0be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0c1:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a0c8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a0cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0ce:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a0d1:	e8 07 46 ff ff       	call   f010e6dd <sys_rcr2>
f011a0d6:	89 c2                	mov    %eax,%edx
f011a0d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0db:	39 c2                	cmp    %eax,%edx
f011a0dd:	74 1d                	je     f011a0fc <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a0df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a0e3:	74 17                	je     f011a0fc <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a0e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0ec:	83 ec 0c             	sub    $0xc,%esp
f011a0ef:	68 c0 de 12 f0       	push   $0xf012dec0
f011a0f4:	e8 92 6e fe ff       	call   f0100f8b <cprintf>
f011a0f9:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a0fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0ff:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a106:	89 c2                	mov    %eax,%edx
f011a108:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a10b:	01 d0                	add    %edx,%eax
f011a10d:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a110:	e8 c8 45 ff ff       	call   f010e6dd <sys_rcr2>
f011a115:	89 c2                	mov    %eax,%edx
f011a117:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a11a:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a121:	89 c1                	mov    %eax,%ecx
f011a123:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a126:	01 c8                	add    %ecx,%eax
f011a128:	39 c2                	cmp    %eax,%edx
f011a12a:	74 20                	je     f011a14c <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a12c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a130:	74 1a                	je     f011a14c <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a132:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a139:	83 ec 0c             	sub    $0xc,%esp
f011a13c:	68 0c df 12 f0       	push   $0xf012df0c
f011a141:	e8 45 6e fe ff       	call   f0100f8b <cprintf>
f011a146:	83 c4 10             	add    $0x10,%esp
f011a149:	eb 01                	jmp    f011a14c <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a14b:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a14c:	ff 45 f4             	incl   -0xc(%ebp)
f011a14f:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a153:	0f 8e 47 ff ff ff    	jle    f011a0a0 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a159:	83 ec 0c             	sub    $0xc,%esp
f011a15c:	6a 00                	push   $0x0
f011a15e:	e8 8c 45 ff ff       	call   f010e6ef <sys_bypassPageFault>
f011a163:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a166:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a16a:	74 04                	je     f011a170 <test_kfree_bestfirstfit+0x10b6>
f011a16c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a170:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a177:	83 ec 0c             	sub    $0xc,%esp
f011a17a:	68 58 df 12 f0       	push   $0xf012df58
f011a17f:	e8 07 6e fe ff       	call   f0100f8b <cprintf>
f011a184:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a187:	e8 3a 41 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a18c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a18f:	e8 11 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a194:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a197:	83 ec 0c             	sub    $0xc,%esp
f011a19a:	68 00 04 00 00       	push   $0x400
f011a19f:	e8 60 f0 fe ff       	call   f0109204 <kmalloc>
f011a1a4:	83 c4 10             	add    $0x10,%esp
f011a1a7:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a1ad:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a1b3:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a1b9:	39 c2                	cmp    %eax,%edx
f011a1bb:	74 17                	je     f011a1d4 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a1bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1c4:	83 ec 0c             	sub    $0xc,%esp
f011a1c7:	68 7c df 12 f0       	push   $0xf012df7c
f011a1cc:	e8 ba 6d fe ff       	call   f0100f8b <cprintf>
f011a1d1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1d4:	e8 cc a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a1d9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a1dc:	74 17                	je     f011a1f5 <test_kfree_bestfirstfit+0x113b>
f011a1de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1e5:	83 ec 0c             	sub    $0xc,%esp
f011a1e8:	68 d0 df 12 f0       	push   $0xf012dfd0
f011a1ed:	e8 99 6d fe ff       	call   f0100f8b <cprintf>
f011a1f2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a1f5:	e8 cc 40 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a1fa:	89 c2                	mov    %eax,%edx
f011a1fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1ff:	39 c2                	cmp    %eax,%edx
f011a201:	74 17                	je     f011a21a <test_kfree_bestfirstfit+0x1160>
f011a203:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a20a:	83 ec 0c             	sub    $0xc,%esp
f011a20d:	68 40 e0 12 f0       	push   $0xf012e040
f011a212:	e8 74 6d fe ff       	call   f0100f8b <cprintf>
f011a217:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a21a:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a221:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a227:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a22a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a231:	eb 0e                	jmp    f011a241 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a233:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a236:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a239:	01 d0                	add    %edx,%eax
f011a23b:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a23e:	ff 45 f4             	incl   -0xc(%ebp)
f011a241:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a244:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a247:	7f ea                	jg     f011a233 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a249:	e8 78 40 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a24e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a251:	e8 4f a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a256:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a259:	83 ec 0c             	sub    $0xc,%esp
f011a25c:	68 00 08 00 00       	push   $0x800
f011a261:	e8 9e ef fe ff       	call   f0109204 <kmalloc>
f011a266:	83 c4 10             	add    $0x10,%esp
f011a269:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a26f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a275:	05 08 04 00 00       	add    $0x408,%eax
f011a27a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a27d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a283:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a286:	74 35                	je     f011a2bd <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a288:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a28f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a295:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a29b:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a2a1:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a2a7:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a2ad:	50                   	push   %eax
f011a2ae:	51                   	push   %ecx
f011a2af:	52                   	push   %edx
f011a2b0:	68 bc e0 12 f0       	push   $0xf012e0bc
f011a2b5:	e8 d1 6c fe ff       	call   f0100f8b <cprintf>
f011a2ba:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a2bd:	e8 e3 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2c2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a2c5:	74 17                	je     f011a2de <test_kfree_bestfirstfit+0x1224>
f011a2c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2ce:	83 ec 0c             	sub    $0xc,%esp
f011a2d1:	68 30 e1 12 f0       	push   $0xf012e130
f011a2d6:	e8 b0 6c fe ff       	call   f0100f8b <cprintf>
f011a2db:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a2de:	e8 e3 3f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a2e3:	89 c2                	mov    %eax,%edx
f011a2e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a2e8:	39 c2                	cmp    %eax,%edx
f011a2ea:	74 17                	je     f011a303 <test_kfree_bestfirstfit+0x1249>
f011a2ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2f3:	83 ec 0c             	sub    $0xc,%esp
f011a2f6:	68 a0 e1 12 f0       	push   $0xf012e1a0
f011a2fb:	e8 8b 6c fe ff       	call   f0100f8b <cprintf>
f011a300:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a303:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a30a:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a310:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a313:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a31a:	eb 0e                	jmp    f011a32a <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a31c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a31f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a322:	01 d0                	add    %edx,%eax
f011a324:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a327:	ff 45 f4             	incl   -0xc(%ebp)
f011a32a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a32d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a330:	7f ea                	jg     f011a31c <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a332:	e8 8f 3f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a337:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a33a:	e8 66 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a33f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a342:	83 ec 0c             	sub    $0xc,%esp
f011a345:	68 00 06 00 00       	push   $0x600
f011a34a:	e8 b5 ee fe ff       	call   f0109204 <kmalloc>
f011a34f:	83 c4 10             	add    $0x10,%esp
f011a352:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a358:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a35e:	05 10 0c 00 00       	add    $0xc10,%eax
f011a363:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a366:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a36c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a36f:	74 17                	je     f011a388 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a371:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a378:	83 ec 0c             	sub    $0xc,%esp
f011a37b:	68 1c e2 12 f0       	push   $0xf012e21c
f011a380:	e8 06 6c fe ff       	call   f0100f8b <cprintf>
f011a385:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a388:	e8 18 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a38d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a390:	74 17                	je     f011a3a9 <test_kfree_bestfirstfit+0x12ef>
f011a392:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a399:	83 ec 0c             	sub    $0xc,%esp
f011a39c:	68 70 e2 12 f0       	push   $0xf012e270
f011a3a1:	e8 e5 6b fe ff       	call   f0100f8b <cprintf>
f011a3a6:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a3a9:	e8 18 3f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a3ae:	89 c2                	mov    %eax,%edx
f011a3b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a3b3:	39 c2                	cmp    %eax,%edx
f011a3b5:	74 17                	je     f011a3ce <test_kfree_bestfirstfit+0x1314>
f011a3b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3be:	83 ec 0c             	sub    $0xc,%esp
f011a3c1:	68 e0 e2 12 f0       	push   $0xf012e2e0
f011a3c6:	e8 c0 6b fe ff       	call   f0100f8b <cprintf>
f011a3cb:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011a3ce:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011a3d5:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a3db:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a3de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3e5:	eb 0e                	jmp    f011a3f5 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011a3e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3ea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3ed:	01 d0                	add    %edx,%eax
f011a3ef:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a3f2:	ff 45 f4             	incl   -0xc(%ebp)
f011a3f5:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a3f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3fb:	7f ea                	jg     f011a3e7 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011a3fd:	e8 c4 3e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a402:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a405:	e8 9b a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a40a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011a40d:	83 ec 0c             	sub    $0xc,%esp
f011a410:	68 00 00 e0 01       	push   $0x1e00000
f011a415:	e8 ea ed fe ff       	call   f0109204 <kmalloc>
f011a41a:	83 c4 10             	add    $0x10,%esp
f011a41d:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a423:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a429:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a42e:	74 17                	je     f011a447 <test_kfree_bestfirstfit+0x138d>
f011a430:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a437:	83 ec 0c             	sub    $0xc,%esp
f011a43a:	68 5c e3 12 f0       	push   $0xf012e35c
f011a43f:	e8 47 6b fe ff       	call   f0100f8b <cprintf>
f011a444:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a447:	e8 59 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a44c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a44f:	74 17                	je     f011a468 <test_kfree_bestfirstfit+0x13ae>
f011a451:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a458:	83 ec 0c             	sub    $0xc,%esp
f011a45b:	68 b0 e3 12 f0       	push   $0xf012e3b0
f011a460:	e8 26 6b fe ff       	call   f0100f8b <cprintf>
f011a465:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a468:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a46b:	e8 56 3e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a470:	29 c3                	sub    %eax,%ebx
f011a472:	89 d8                	mov    %ebx,%eax
f011a474:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011a479:	77 17                	ja     f011a492 <test_kfree_bestfirstfit+0x13d8>
f011a47b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a482:	83 ec 0c             	sub    $0xc,%esp
f011a485:	68 20 e4 12 f0       	push   $0xf012e420
f011a48a:	e8 fc 6a fe ff       	call   f0100f8b <cprintf>
f011a48f:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011a492:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011a499:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a49f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a4a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4a9:	eb 0e                	jmp    f011a4b9 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011a4ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a4ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4b1:	01 d0                	add    %edx,%eax
f011a4b3:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a4b6:	ff 45 f4             	incl   -0xc(%ebp)
f011a4b9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a4bc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4bf:	7f ea                	jg     f011a4ab <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011a4c1:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a4c7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a4ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4d1:	eb 1e                	jmp    f011a4f1 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011a4d3:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011a4d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a4dc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4df:	01 c8                	add    %ecx,%eax
f011a4e1:	8a 00                	mov    (%eax),%al
f011a4e3:	0f be c0             	movsbl %al,%eax
f011a4e6:	01 d0                	add    %edx,%eax
f011a4e8:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a4ee:	ff 45 f4             	incl   -0xc(%ebp)
f011a4f1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a4f4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4f7:	7f da                	jg     f011a4d3 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011a4f9:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011a4ff:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011a502:	89 d0                	mov    %edx,%eax
f011a504:	c1 e0 02             	shl    $0x2,%eax
f011a507:	01 d0                	add    %edx,%eax
f011a509:	01 c0                	add    %eax,%eax
f011a50b:	39 c1                	cmp    %eax,%ecx
f011a50d:	74 17                	je     f011a526 <test_kfree_bestfirstfit+0x146c>
f011a50f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a516:	83 ec 0c             	sub    $0xc,%esp
f011a519:	68 68 e4 12 f0       	push   $0xf012e468
f011a51e:	e8 68 6a fe ff       	call   f0100f8b <cprintf>
f011a523:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011a526:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a52c:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a52f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a536:	eb 1e                	jmp    f011a556 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011a538:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011a53e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a541:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a544:	01 c8                	add    %ecx,%eax
f011a546:	8a 00                	mov    (%eax),%al
f011a548:	0f be c0             	movsbl %al,%eax
f011a54b:	01 d0                	add    %edx,%eax
f011a54d:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a553:	ff 45 f4             	incl   -0xc(%ebp)
f011a556:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a559:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a55c:	7f da                	jg     f011a538 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011a55e:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011a564:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a567:	89 d0                	mov    %edx,%eax
f011a569:	c1 e0 02             	shl    $0x2,%eax
f011a56c:	01 d0                	add    %edx,%eax
f011a56e:	01 c0                	add    %eax,%eax
f011a570:	01 d0                	add    %edx,%eax
f011a572:	39 c1                	cmp    %eax,%ecx
f011a574:	74 17                	je     f011a58d <test_kfree_bestfirstfit+0x14d3>
f011a576:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a57d:	83 ec 0c             	sub    $0xc,%esp
f011a580:	68 98 e4 12 f0       	push   $0xf012e498
f011a585:	e8 01 6a fe ff       	call   f0100f8b <cprintf>
f011a58a:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011a58d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a593:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a596:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a59d:	eb 1e                	jmp    f011a5bd <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011a59f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011a5a5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a5a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5ab:	01 c8                	add    %ecx,%eax
f011a5ad:	8a 00                	mov    (%eax),%al
f011a5af:	0f be c0             	movsbl %al,%eax
f011a5b2:	01 d0                	add    %edx,%eax
f011a5b4:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a5ba:	ff 45 f4             	incl   -0xc(%ebp)
f011a5bd:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a5c0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5c3:	7f da                	jg     f011a59f <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011a5c5:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011a5cb:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011a5ce:	89 d0                	mov    %edx,%eax
f011a5d0:	01 c0                	add    %eax,%eax
f011a5d2:	01 d0                	add    %edx,%eax
f011a5d4:	c1 e0 02             	shl    $0x2,%eax
f011a5d7:	39 c1                	cmp    %eax,%ecx
f011a5d9:	74 17                	je     f011a5f2 <test_kfree_bestfirstfit+0x1538>
f011a5db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5e2:	83 ec 0c             	sub    $0xc,%esp
f011a5e5:	68 c8 e4 12 f0       	push   $0xf012e4c8
f011a5ea:	e8 9c 69 fe ff       	call   f0100f8b <cprintf>
f011a5ef:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011a5f2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a5f8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a5fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a602:	eb 1e                	jmp    f011a622 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011a604:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011a60a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a60d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a610:	01 c8                	add    %ecx,%eax
f011a612:	8a 00                	mov    (%eax),%al
f011a614:	0f be c0             	movsbl %al,%eax
f011a617:	01 d0                	add    %edx,%eax
f011a619:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a61f:	ff 45 f4             	incl   -0xc(%ebp)
f011a622:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a625:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a628:	7f da                	jg     f011a604 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011a62a:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011a630:	8b 55 98             	mov    -0x68(%ebp),%edx
f011a633:	89 d0                	mov    %edx,%eax
f011a635:	01 c0                	add    %eax,%eax
f011a637:	01 d0                	add    %edx,%eax
f011a639:	c1 e0 02             	shl    $0x2,%eax
f011a63c:	01 d0                	add    %edx,%eax
f011a63e:	39 c1                	cmp    %eax,%ecx
f011a640:	74 17                	je     f011a659 <test_kfree_bestfirstfit+0x159f>
f011a642:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a649:	83 ec 0c             	sub    $0xc,%esp
f011a64c:	68 f8 e4 12 f0       	push   $0xf012e4f8
f011a651:	e8 35 69 fe ff       	call   f0100f8b <cprintf>
f011a656:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011a659:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a65d:	74 04                	je     f011a663 <test_kfree_bestfirstfit+0x15a9>
f011a65f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a663:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011a66a:	83 ec 0c             	sub    $0xc,%esp
f011a66d:	68 25 e5 12 f0       	push   $0xf012e525
f011a672:	e8 14 69 fe ff       	call   f0100f8b <cprintf>
f011a677:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a67a:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011a681:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011a688:	eb 4e                	jmp    f011a6d8 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011a68a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a68d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011a692:	83 ec 04             	sub    $0x4,%esp
f011a695:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011a69b:	51                   	push   %ecx
f011a69c:	52                   	push   %edx
f011a69d:	50                   	push   %eax
f011a69e:	e8 4c dd fe ff       	call   f01083ef <get_page_table>
f011a6a3:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a6a6:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011a6ac:	85 c0                	test   %eax,%eax
f011a6ae:	75 1d                	jne    f011a6cd <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011a6b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6b4:	74 17                	je     f011a6cd <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011a6b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6bd:	83 ec 0c             	sub    $0xc,%esp
f011a6c0:	68 44 e5 12 f0       	push   $0xf012e544
f011a6c5:	e8 c1 68 fe ff       	call   f0100f8b <cprintf>
f011a6ca:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a6cd:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011a6d4:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011a6d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a6dc:	78 ac                	js     f011a68a <test_kfree_bestfirstfit+0x15d0>
f011a6de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a6e2:	7f 09                	jg     f011a6ed <test_kfree_bestfirstfit+0x1633>
f011a6e4:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011a6eb:	76 9d                	jbe    f011a68a <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011a6ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6f1:	74 04                	je     f011a6f7 <test_kfree_bestfirstfit+0x163d>
f011a6f3:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011a6f7:	83 ec 08             	sub    $0x8,%esp
f011a6fa:	ff 75 f0             	pushl  -0x10(%ebp)
f011a6fd:	68 ac e5 12 f0       	push   $0xf012e5ac
f011a702:	e8 84 68 fe ff       	call   f0100f8b <cprintf>
f011a707:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a70a:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011a70f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a712:	5b                   	pop    %ebx
f011a713:	5f                   	pop    %edi
f011a714:	5d                   	pop    %ebp
f011a715:	c3                   	ret    

f011a716 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011a716:	55                   	push   %ebp
f011a717:	89 e5                	mov    %esp,%ebp
f011a719:	57                   	push   %edi
f011a71a:	53                   	push   %ebx
f011a71b:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a721:	83 ec 0c             	sub    $0xc,%esp
f011a724:	68 68 a8 12 f0       	push   $0xf012a868
f011a729:	e8 5d 68 fe ff       	call   f0100f8b <cprintf>
f011a72e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a731:	83 ec 0c             	sub    $0xc,%esp
f011a734:	68 98 a8 12 f0       	push   $0xf012a898
f011a739:	e8 4d 68 fe ff       	call   f0100f8b <cprintf>
f011a73e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a741:	83 ec 0c             	sub    $0xc,%esp
f011a744:	68 68 a8 12 f0       	push   $0xf012a868
f011a749:	e8 3d 68 fe ff       	call   f0100f8b <cprintf>
f011a74e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a751:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011a755:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011a759:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011a75f:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011a765:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a76c:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a773:	e8 4e 3b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a778:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011a77b:	83 ec 0c             	sub    $0xc,%esp
f011a77e:	68 d0 e5 12 f0       	push   $0xf012e5d0
f011a783:	e8 03 68 fe ff       	call   f0100f8b <cprintf>
f011a788:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a78b:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011a791:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a796:	b8 00 00 00 00       	mov    $0x0,%eax
f011a79b:	89 d7                	mov    %edx,%edi
f011a79d:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a79f:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011a7a5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a7aa:	b8 00 00 00 00       	mov    $0x0,%eax
f011a7af:	89 d7                	mov    %edx,%edi
f011a7b1:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011a7b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a7ba:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a7c1:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011a7c7:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a7cc:	b8 00 00 00 00       	mov    $0x0,%eax
f011a7d1:	89 d7                	mov    %edx,%edi
f011a7d3:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a7d5:	e8 ec 3a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a7da:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a7dd:	e8 c3 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7e2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a7e5:	83 ec 0c             	sub    $0xc,%esp
f011a7e8:	68 00 fc 1f 00       	push   $0x1ffc00
f011a7ed:	e8 12 ea fe ff       	call   f0109204 <kmalloc>
f011a7f2:	83 c4 10             	add    $0x10,%esp
f011a7f5:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7fb:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a801:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a806:	74 17                	je     f011a81f <test_kheap_phys_addr+0x109>
f011a808:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a80f:	83 ec 0c             	sub    $0xc,%esp
f011a812:	68 74 c9 12 f0       	push   $0xf012c974
f011a817:	e8 6f 67 fe ff       	call   f0100f8b <cprintf>
f011a81c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a81f:	e8 81 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a824:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a827:	74 17                	je     f011a840 <test_kheap_phys_addr+0x12a>
f011a829:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a830:	83 ec 0c             	sub    $0xc,%esp
f011a833:	68 c8 c9 12 f0       	push   $0xf012c9c8
f011a838:	e8 4e 67 fe ff       	call   f0100f8b <cprintf>
f011a83d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a840:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a843:	e8 7e 3a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a848:	29 c3                	sub    %eax,%ebx
f011a84a:	89 d8                	mov    %ebx,%eax
f011a84c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a851:	77 17                	ja     f011a86a <test_kheap_phys_addr+0x154>
f011a853:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a85a:	83 ec 0c             	sub    $0xc,%esp
f011a85d:	68 38 ca 12 f0       	push   $0xf012ca38
f011a862:	e8 24 67 fe ff       	call   f0100f8b <cprintf>
f011a867:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a86a:	e8 57 3a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a86f:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a872:	e8 2e a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a877:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a87a:	83 ec 0c             	sub    $0xc,%esp
f011a87d:	68 00 fc 1f 00       	push   $0x1ffc00
f011a882:	e8 7d e9 fe ff       	call   f0109204 <kmalloc>
f011a887:	83 c4 10             	add    $0x10,%esp
f011a88a:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a890:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a896:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a89b:	74 17                	je     f011a8b4 <test_kheap_phys_addr+0x19e>
f011a89d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8a4:	83 ec 0c             	sub    $0xc,%esp
f011a8a7:	68 80 ca 12 f0       	push   $0xf012ca80
f011a8ac:	e8 da 66 fe ff       	call   f0100f8b <cprintf>
f011a8b1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8b4:	e8 ec 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8b9:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a8bc:	74 17                	je     f011a8d5 <test_kheap_phys_addr+0x1bf>
f011a8be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8c5:	83 ec 0c             	sub    $0xc,%esp
f011a8c8:	68 d4 ca 12 f0       	push   $0xf012cad4
f011a8cd:	e8 b9 66 fe ff       	call   f0100f8b <cprintf>
f011a8d2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a8d5:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a8d8:	e8 e9 39 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a8dd:	29 c3                	sub    %eax,%ebx
f011a8df:	89 d8                	mov    %ebx,%eax
f011a8e1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a8e6:	77 17                	ja     f011a8ff <test_kheap_phys_addr+0x1e9>
f011a8e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8ef:	83 ec 0c             	sub    $0xc,%esp
f011a8f2:	68 44 cb 12 f0       	push   $0xf012cb44
f011a8f7:	e8 8f 66 fe ff       	call   f0100f8b <cprintf>
f011a8fc:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8ff:	e8 c2 39 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a904:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a907:	e8 99 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a90c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011a90f:	83 ec 0c             	sub    $0xc,%esp
f011a912:	68 00 04 00 00       	push   $0x400
f011a917:	e8 e8 e8 fe ff       	call   f0109204 <kmalloc>
f011a91c:	83 c4 10             	add    $0x10,%esp
f011a91f:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a925:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a92b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a930:	76 28                	jbe    f011a95a <test_kheap_phys_addr+0x244>
f011a932:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011a938:	83 ec 0c             	sub    $0xc,%esp
f011a93b:	6a 00                	push   $0x0
f011a93d:	e8 8f e7 fe ff       	call   f01090d1 <sbrk>
f011a942:	83 c4 10             	add    $0x10,%esp
f011a945:	39 c3                	cmp    %eax,%ebx
f011a947:	73 11                	jae    f011a95a <test_kheap_phys_addr+0x244>
f011a949:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a94f:	89 c2                	mov    %eax,%edx
f011a951:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a956:	39 c2                	cmp    %eax,%edx
f011a958:	72 17                	jb     f011a971 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a95a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a961:	83 ec 0c             	sub    $0xc,%esp
f011a964:	68 00 e6 12 f0       	push   $0xf012e600
f011a969:	e8 1d 66 fe ff       	call   f0100f8b <cprintf>
f011a96e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a971:	e8 2f 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a976:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a979:	74 17                	je     f011a992 <test_kheap_phys_addr+0x27c>
f011a97b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a982:	83 ec 0c             	sub    $0xc,%esp
f011a985:	68 e0 cb 12 f0       	push   $0xf012cbe0
f011a98a:	e8 fc 65 fe ff       	call   f0100f8b <cprintf>
f011a98f:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a992:	e8 2f 39 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011a997:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a99a:	e8 06 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a99f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a9a2:	83 ec 0c             	sub    $0xc,%esp
f011a9a5:	68 00 08 00 00       	push   $0x800
f011a9aa:	e8 55 e8 fe ff       	call   f0109204 <kmalloc>
f011a9af:	83 c4 10             	add    $0x10,%esp
f011a9b2:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a9b8:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a9be:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a9c3:	76 28                	jbe    f011a9ed <test_kheap_phys_addr+0x2d7>
f011a9c5:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011a9cb:	83 ec 0c             	sub    $0xc,%esp
f011a9ce:	6a 00                	push   $0x0
f011a9d0:	e8 fc e6 fe ff       	call   f01090d1 <sbrk>
f011a9d5:	83 c4 10             	add    $0x10,%esp
f011a9d8:	39 c3                	cmp    %eax,%ebx
f011a9da:	73 11                	jae    f011a9ed <test_kheap_phys_addr+0x2d7>
f011a9dc:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a9e2:	89 c2                	mov    %eax,%edx
f011a9e4:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a9e9:	39 c2                	cmp    %eax,%edx
f011a9eb:	72 17                	jb     f011aa04 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a9ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9f4:	83 ec 0c             	sub    $0xc,%esp
f011a9f7:	68 8c e6 12 f0       	push   $0xf012e68c
f011a9fc:	e8 8a 65 fe ff       	call   f0100f8b <cprintf>
f011aa01:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa04:	e8 9c 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa09:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aa0c:	74 17                	je     f011aa25 <test_kheap_phys_addr+0x30f>
f011aa0e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa15:	83 ec 0c             	sub    $0xc,%esp
f011aa18:	68 ec cc 12 f0       	push   $0xf012ccec
f011aa1d:	e8 69 65 fe ff       	call   f0100f8b <cprintf>
f011aa22:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011aa25:	e8 9c 38 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011aa2a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa2d:	e8 73 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa32:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011aa35:	83 ec 0c             	sub    $0xc,%esp
f011aa38:	68 00 06 00 00       	push   $0x600
f011aa3d:	e8 c2 e7 fe ff       	call   f0109204 <kmalloc>
f011aa42:	83 c4 10             	add    $0x10,%esp
f011aa45:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011aa4b:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aa51:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011aa56:	76 28                	jbe    f011aa80 <test_kheap_phys_addr+0x36a>
f011aa58:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011aa5e:	83 ec 0c             	sub    $0xc,%esp
f011aa61:	6a 00                	push   $0x0
f011aa63:	e8 69 e6 fe ff       	call   f01090d1 <sbrk>
f011aa68:	83 c4 10             	add    $0x10,%esp
f011aa6b:	39 c3                	cmp    %eax,%ebx
f011aa6d:	73 11                	jae    f011aa80 <test_kheap_phys_addr+0x36a>
f011aa6f:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aa75:	89 c2                	mov    %eax,%edx
f011aa77:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011aa7c:	39 c2                	cmp    %eax,%edx
f011aa7e:	72 17                	jb     f011aa97 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011aa80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa87:	83 ec 0c             	sub    $0xc,%esp
f011aa8a:	68 18 e7 12 f0       	push   $0xf012e718
f011aa8f:	e8 f7 64 fe ff       	call   f0100f8b <cprintf>
f011aa94:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa97:	e8 09 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa9c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aa9f:	74 17                	je     f011aab8 <test_kheap_phys_addr+0x3a2>
f011aaa1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaa8:	83 ec 0c             	sub    $0xc,%esp
f011aaab:	68 f8 cd 12 f0       	push   $0xf012cdf8
f011aab0:	e8 d6 64 fe ff       	call   f0100f8b <cprintf>
f011aab5:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011aab8:	e8 09 38 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011aabd:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aac0:	e8 e0 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aac5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011aac8:	83 ec 0c             	sub    $0xc,%esp
f011aacb:	68 00 1c 00 00       	push   $0x1c00
f011aad0:	e8 2f e7 fe ff       	call   f0109204 <kmalloc>
f011aad5:	83 c4 10             	add    $0x10,%esp
f011aad8:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aade:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011aae4:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011aae9:	74 17                	je     f011ab02 <test_kheap_phys_addr+0x3ec>
f011aaeb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaf2:	83 ec 0c             	sub    $0xc,%esp
f011aaf5:	68 b0 ce 12 f0       	push   $0xf012ceb0
f011aafa:	e8 8c 64 fe ff       	call   f0100f8b <cprintf>
f011aaff:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab02:	e8 9e 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab07:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ab0a:	74 17                	je     f011ab23 <test_kheap_phys_addr+0x40d>
f011ab0c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab13:	83 ec 0c             	sub    $0xc,%esp
f011ab16:	68 04 cf 12 f0       	push   $0xf012cf04
f011ab1b:	e8 6b 64 fe ff       	call   f0100f8b <cprintf>
f011ab20:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab23:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ab26:	e8 9b 37 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ab2b:	29 c3                	sub    %eax,%ebx
f011ab2d:	89 d8                	mov    %ebx,%eax
f011ab2f:	83 f8 01             	cmp    $0x1,%eax
f011ab32:	77 17                	ja     f011ab4b <test_kheap_phys_addr+0x435>
f011ab34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab3b:	83 ec 0c             	sub    $0xc,%esp
f011ab3e:	68 74 cf 12 f0       	push   $0xf012cf74
f011ab43:	e8 43 64 fe ff       	call   f0100f8b <cprintf>
f011ab48:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab4b:	e8 76 37 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ab50:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab53:	e8 4d 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab58:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ab5b:	83 ec 0c             	sub    $0xc,%esp
f011ab5e:	68 00 fc 2f 00       	push   $0x2ffc00
f011ab63:	e8 9c e6 fe ff       	call   f0109204 <kmalloc>
f011ab68:	83 c4 10             	add    $0x10,%esp
f011ab6b:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab71:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ab77:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ab7c:	74 17                	je     f011ab95 <test_kheap_phys_addr+0x47f>
f011ab7e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab85:	83 ec 0c             	sub    $0xc,%esp
f011ab88:	68 a4 e7 12 f0       	push   $0xf012e7a4
f011ab8d:	e8 f9 63 fe ff       	call   f0100f8b <cprintf>
f011ab92:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab95:	e8 0b 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab9a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ab9d:	74 17                	je     f011abb6 <test_kheap_phys_addr+0x4a0>
f011ab9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aba6:	83 ec 0c             	sub    $0xc,%esp
f011aba9:	68 48 d0 12 f0       	push   $0xf012d048
f011abae:	e8 d8 63 fe ff       	call   f0100f8b <cprintf>
f011abb3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011abb6:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011abb9:	e8 08 37 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011abbe:	29 c3                	sub    %eax,%ebx
f011abc0:	89 d8                	mov    %ebx,%eax
f011abc2:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011abc7:	77 17                	ja     f011abe0 <test_kheap_phys_addr+0x4ca>
f011abc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abd0:	83 ec 0c             	sub    $0xc,%esp
f011abd3:	68 f8 e7 12 f0       	push   $0xf012e7f8
f011abd8:	e8 ae 63 fe ff       	call   f0100f8b <cprintf>
f011abdd:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011abe0:	e8 e1 36 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011abe5:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011abe8:	e8 b8 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011abed:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011abf0:	83 ec 0c             	sub    $0xc,%esp
f011abf3:	68 00 fc 5f 00       	push   $0x5ffc00
f011abf8:	e8 07 e6 fe ff       	call   f0109204 <kmalloc>
f011abfd:	83 c4 10             	add    $0x10,%esp
f011ac00:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac06:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011ac0c:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011ac11:	74 17                	je     f011ac2a <test_kheap_phys_addr+0x514>
f011ac13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac1a:	83 ec 0c             	sub    $0xc,%esp
f011ac1d:	68 40 e8 12 f0       	push   $0xf012e840
f011ac22:	e8 64 63 fe ff       	call   f0100f8b <cprintf>
f011ac27:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac2a:	e8 76 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ac2f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ac32:	74 17                	je     f011ac4b <test_kheap_phys_addr+0x535>
f011ac34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac3b:	83 ec 0c             	sub    $0xc,%esp
f011ac3e:	68 44 d1 12 f0       	push   $0xf012d144
f011ac43:	e8 43 63 fe ff       	call   f0100f8b <cprintf>
f011ac48:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac4b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ac4e:	e8 73 36 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ac53:	29 c3                	sub    %eax,%ebx
f011ac55:	89 d8                	mov    %ebx,%eax
f011ac57:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ac5c:	77 17                	ja     f011ac75 <test_kheap_phys_addr+0x55f>
f011ac5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac65:	83 ec 0c             	sub    $0xc,%esp
f011ac68:	68 94 e8 12 f0       	push   $0xf012e894
f011ac6d:	e8 19 63 fe ff       	call   f0100f8b <cprintf>
f011ac72:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ac75:	e8 4c 36 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ac7a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac7d:	e8 23 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ac82:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ac85:	83 ec 0c             	sub    $0xc,%esp
f011ac88:	68 00 38 00 00       	push   $0x3800
f011ac8d:	e8 72 e5 fe ff       	call   f0109204 <kmalloc>
f011ac92:	83 c4 10             	add    $0x10,%esp
f011ac95:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac9b:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011aca1:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011aca6:	74 17                	je     f011acbf <test_kheap_phys_addr+0x5a9>
f011aca8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acaf:	83 ec 0c             	sub    $0xc,%esp
f011acb2:	68 dc e8 12 f0       	push   $0xf012e8dc
f011acb7:	e8 cf 62 fe ff       	call   f0100f8b <cprintf>
f011acbc:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011acbf:	e8 e1 9b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011acc4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011acc7:	74 17                	je     f011ace0 <test_kheap_phys_addr+0x5ca>
f011acc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acd0:	83 ec 0c             	sub    $0xc,%esp
f011acd3:	68 30 e9 12 f0       	push   $0xf012e930
f011acd8:	e8 ae 62 fe ff       	call   f0100f8b <cprintf>
f011acdd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ace0:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ace3:	e8 de 35 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ace8:	29 c3                	sub    %eax,%ebx
f011acea:	89 d8                	mov    %ebx,%eax
f011acec:	83 f8 03             	cmp    $0x3,%eax
f011acef:	77 17                	ja     f011ad08 <test_kheap_phys_addr+0x5f2>
f011acf1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acf8:	83 ec 0c             	sub    $0xc,%esp
f011acfb:	68 a0 e9 12 f0       	push   $0xf012e9a0
f011ad00:	e8 86 62 fe ff       	call   f0100f8b <cprintf>
f011ad05:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011ad08:	83 ec 0c             	sub    $0xc,%esp
f011ad0b:	68 e8 e9 12 f0       	push   $0xf012e9e8
f011ad10:	e8 76 62 fe ff       	call   f0100f8b <cprintf>
f011ad15:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ad18:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011ad1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011ad26:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ad2d:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011ad32:	05 00 10 00 00       	add    $0x1000,%eax
f011ad37:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011ad3a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ad3d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ad40:	eb 2e                	jmp    f011ad70 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011ad42:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011ad45:	8d 43 01             	lea    0x1(%ebx),%eax
f011ad48:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ad4b:	83 ec 0c             	sub    $0xc,%esp
f011ad4e:	ff 75 e8             	pushl  -0x18(%ebp)
f011ad51:	e8 f4 e7 fe ff       	call   f010954a <kheap_physical_address>
f011ad56:	83 c4 10             	add    $0x10,%esp
f011ad59:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011ad60:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ad63:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad66:	01 d0                	add    %edx,%eax
f011ad68:	05 00 10 00 00       	add    $0x1000,%eax
f011ad6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ad70:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad73:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ad76:	72 ca                	jb     f011ad42 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011ad78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ad7b:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011ad7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ad85:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ad88:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ad8b:	e9 ce 00 00 00       	jmp    f011ae5e <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ad90:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ad95:	83 ec 04             	sub    $0x4,%esp
f011ad98:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011ad9e:	52                   	push   %edx
f011ad9f:	ff 75 e8             	pushl  -0x18(%ebp)
f011ada2:	50                   	push   %eax
f011ada3:	e8 47 d6 fe ff       	call   f01083ef <get_page_table>
f011ada8:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011adab:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011adb1:	85 c0                	test   %eax,%eax
f011adb3:	75 1e                	jne    f011add3 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011adb5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adbc:	83 ec 04             	sub    $0x4,%esp
f011adbf:	68 34 ea 12 f0       	push   $0xf012ea34
f011adc4:	68 e8 05 00 00       	push   $0x5e8
f011adc9:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011adce:	e8 66 55 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011add3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011add6:	c1 e8 0c             	shr    $0xc,%eax
f011add9:	25 ff 03 00 00       	and    $0x3ff,%eax
f011adde:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ade1:	eb 62                	jmp    f011ae45 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011ade3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ade9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011adec:	c1 e2 02             	shl    $0x2,%edx
f011adef:	01 d0                	add    %edx,%eax
f011adf1:	8b 00                	mov    (%eax),%eax
f011adf3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011adf8:	89 c2                	mov    %eax,%edx
f011adfa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011adfd:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ae02:	01 c2                	add    %eax,%edx
f011ae04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ae07:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011ae0e:	39 c2                	cmp    %eax,%edx
f011ae10:	74 1d                	je     f011ae2f <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011ae12:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ae16:	74 17                	je     f011ae2f <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011ae18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae1f:	83 ec 0c             	sub    $0xc,%esp
f011ae22:	68 94 ea 12 f0       	push   $0xf012ea94
f011ae27:	e8 5f 61 fe ff       	call   f0100f8b <cprintf>
f011ae2c:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011ae2f:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ae32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ae35:	01 d0                	add    %edx,%eax
f011ae37:	05 00 10 00 00       	add    $0x1000,%eax
f011ae3c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011ae3f:	ff 45 e4             	incl   -0x1c(%ebp)
f011ae42:	ff 45 f4             	incl   -0xc(%ebp)
f011ae45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ae48:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011ae4b:	7d 11                	jge    f011ae5e <test_kheap_phys_addr+0x748>
f011ae4d:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011ae54:	7f 08                	jg     f011ae5e <test_kheap_phys_addr+0x748>
f011ae56:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ae59:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ae5c:	72 85                	jb     f011ade3 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011ae5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ae61:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ae64:	0f 82 26 ff ff ff    	jb     f011ad90 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011ae6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ae6e:	74 04                	je     f011ae74 <test_kheap_phys_addr+0x75e>
f011ae70:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ae74:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011ae7b:	83 ec 0c             	sub    $0xc,%esp
f011ae7e:	68 b8 ea 12 f0       	push   $0xf012eab8
f011ae83:	e8 03 61 fe ff       	call   f0100f8b <cprintf>
f011ae88:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011ae8b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011ae92:	e9 b0 00 00 00       	jmp    f011af47 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011ae97:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ae9a:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011aea1:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011aea4:	83 ec 0c             	sub    $0xc,%esp
f011aea7:	ff 75 90             	pushl  -0x70(%ebp)
f011aeaa:	e8 9b e6 fe ff       	call   f010954a <kheap_physical_address>
f011aeaf:	83 c4 10             	add    $0x10,%esp
f011aeb2:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011aeb5:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011aeba:	83 ec 04             	sub    $0x4,%esp
f011aebd:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011aec3:	52                   	push   %edx
f011aec4:	ff 75 90             	pushl  -0x70(%ebp)
f011aec7:	50                   	push   %eax
f011aec8:	e8 22 d5 fe ff       	call   f01083ef <get_page_table>
f011aecd:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011aed0:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011aed6:	85 c0                	test   %eax,%eax
f011aed8:	75 1e                	jne    f011aef8 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011aeda:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aee1:	83 ec 04             	sub    $0x4,%esp
f011aee4:	68 08 eb 12 f0       	push   $0xf012eb08
f011aee9:	68 05 06 00 00       	push   $0x605
f011aeee:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011aef3:	e8 41 54 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011aef8:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011aefe:	8b 55 90             	mov    -0x70(%ebp),%edx
f011af01:	c1 ea 0c             	shr    $0xc,%edx
f011af04:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011af0a:	c1 e2 02             	shl    $0x2,%edx
f011af0d:	01 d0                	add    %edx,%eax
f011af0f:	8b 00                	mov    (%eax),%eax
f011af11:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011af16:	89 c2                	mov    %eax,%edx
f011af18:	8b 45 90             	mov    -0x70(%ebp),%eax
f011af1b:	25 ff 0f 00 00       	and    $0xfff,%eax
f011af20:	01 d0                	add    %edx,%eax
f011af22:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011af25:	74 1d                	je     f011af44 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011af27:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af2b:	74 17                	je     f011af44 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011af2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af34:	83 ec 0c             	sub    $0xc,%esp
f011af37:	68 68 eb 12 f0       	push   $0xf012eb68
f011af3c:	e8 4a 60 fe ff       	call   f0100f8b <cprintf>
f011af41:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011af44:	ff 45 e0             	incl   -0x20(%ebp)
f011af47:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011af4b:	0f 8e 46 ff ff ff    	jle    f011ae97 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011af51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af55:	74 04                	je     f011af5b <test_kheap_phys_addr+0x845>
f011af57:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011af5b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011af62:	83 ec 0c             	sub    $0xc,%esp
f011af65:	68 8c eb 12 f0       	push   $0xf012eb8c
f011af6a:	e8 1c 60 fe ff       	call   f0100f8b <cprintf>
f011af6f:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011af72:	e8 4f 33 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011af77:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011af7a:	e8 26 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af7f:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011af82:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011af88:	83 ec 0c             	sub    $0xc,%esp
f011af8b:	50                   	push   %eax
f011af8c:	e8 d3 e4 fe ff       	call   f0109464 <kfree>
f011af91:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af94:	e8 0c 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af99:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011af9c:	74 17                	je     f011afb5 <test_kheap_phys_addr+0x89f>
f011af9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afa5:	83 ec 0c             	sub    $0xc,%esp
f011afa8:	68 78 d6 12 f0       	push   $0xf012d678
f011afad:	e8 d9 5f fe ff       	call   f0100f8b <cprintf>
f011afb2:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011afb5:	e8 0c 33 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011afba:	89 c2                	mov    %eax,%edx
f011afbc:	8b 45 88             	mov    -0x78(%ebp),%eax
f011afbf:	29 c2                	sub    %eax,%edx
f011afc1:	89 d0                	mov    %edx,%eax
f011afc3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011afc8:	77 17                	ja     f011afe1 <test_kheap_phys_addr+0x8cb>
f011afca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afd1:	83 ec 0c             	sub    $0xc,%esp
f011afd4:	68 b4 eb 12 f0       	push   $0xf012ebb4
f011afd9:	e8 ad 5f fe ff       	call   f0100f8b <cprintf>
f011afde:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011afe1:	e8 e0 32 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011afe6:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afe9:	e8 b7 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afee:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011aff1:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011aff7:	83 ec 0c             	sub    $0xc,%esp
f011affa:	50                   	push   %eax
f011affb:	e8 64 e4 fe ff       	call   f0109464 <kfree>
f011b000:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b003:	e8 9d 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b008:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b00b:	74 17                	je     f011b024 <test_kheap_phys_addr+0x90e>
f011b00d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b014:	83 ec 0c             	sub    $0xc,%esp
f011b017:	68 b8 d7 12 f0       	push   $0xf012d7b8
f011b01c:	e8 6a 5f fe ff       	call   f0100f8b <cprintf>
f011b021:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b024:	e8 9d 32 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b029:	89 c2                	mov    %eax,%edx
f011b02b:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b02e:	29 c2                	sub    %eax,%edx
f011b030:	89 d0                	mov    %edx,%eax
f011b032:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b037:	77 17                	ja     f011b050 <test_kheap_phys_addr+0x93a>
f011b039:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b040:	83 ec 0c             	sub    $0xc,%esp
f011b043:	68 f0 eb 12 f0       	push   $0xf012ebf0
f011b048:	e8 3e 5f fe ff       	call   f0100f8b <cprintf>
f011b04d:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b050:	e8 71 32 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b055:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b058:	e8 48 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b05d:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b060:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b066:	83 ec 0c             	sub    $0xc,%esp
f011b069:	50                   	push   %eax
f011b06a:	e8 f5 e3 fe ff       	call   f0109464 <kfree>
f011b06f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b072:	e8 2e 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b077:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b07a:	74 17                	je     f011b093 <test_kheap_phys_addr+0x97d>
f011b07c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b083:	83 ec 0c             	sub    $0xc,%esp
f011b086:	68 c4 d8 12 f0       	push   $0xf012d8c4
f011b08b:	e8 fb 5e fe ff       	call   f0100f8b <cprintf>
f011b090:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b093:	e8 2e 32 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b098:	89 c2                	mov    %eax,%edx
f011b09a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b09d:	29 c2                	sub    %eax,%edx
f011b09f:	89 d0                	mov    %edx,%eax
f011b0a1:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b0a6:	77 17                	ja     f011b0bf <test_kheap_phys_addr+0x9a9>
f011b0a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0af:	83 ec 0c             	sub    $0xc,%esp
f011b0b2:	68 2c ec 12 f0       	push   $0xf012ec2c
f011b0b7:	e8 cf 5e fe ff       	call   f0100f8b <cprintf>
f011b0bc:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b0bf:	83 ec 0c             	sub    $0xc,%esp
f011b0c2:	68 68 ec 12 f0       	push   $0xf012ec68
f011b0c7:	e8 bf 5e fe ff       	call   f0100f8b <cprintf>
f011b0cc:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b0cf:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b0d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b0dd:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b0e4:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b0e7:	8b 15 d8 ed 17 f0    	mov    0xf017edd8,%edx
f011b0ed:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b0f3:	01 d0                	add    %edx,%eax
f011b0f5:	05 00 10 00 00       	add    $0x1000,%eax
f011b0fa:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b100:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b106:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b109:	eb 25                	jmp    f011b130 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b10b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b10e:	8d 43 01             	lea    0x1(%ebx),%eax
f011b111:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b114:	83 ec 0c             	sub    $0xc,%esp
f011b117:	ff 75 d8             	pushl  -0x28(%ebp)
f011b11a:	e8 2b e4 fe ff       	call   f010954a <kheap_physical_address>
f011b11f:	83 c4 10             	add    $0x10,%esp
f011b122:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b129:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b130:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b133:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b136:	72 d3                	jb     f011b10b <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b138:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b13b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b141:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b148:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b14e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b151:	e9 f4 00 00 00       	jmp    f011b24a <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b156:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b15b:	83 ec 04             	sub    $0x4,%esp
f011b15e:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b164:	52                   	push   %edx
f011b165:	ff 75 d8             	pushl  -0x28(%ebp)
f011b168:	50                   	push   %eax
f011b169:	e8 81 d2 fe ff       	call   f01083ef <get_page_table>
f011b16e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b171:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b177:	85 c0                	test   %eax,%eax
f011b179:	75 24                	jne    f011b19f <test_kheap_phys_addr+0xa89>
				if (correct)
f011b17b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b17f:	74 1e                	je     f011b19f <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b181:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b188:	83 ec 04             	sub    $0x4,%esp
f011b18b:	68 b8 ec 12 f0       	push   $0xf012ecb8
f011b190:	68 43 06 00 00       	push   $0x643
f011b195:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011b19a:	e8 9a 51 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b19f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b1a2:	c1 e8 0c             	shr    $0xc,%eax
f011b1a5:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b1aa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b1ad:	eb 7b                	jmp    f011b22a <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b1af:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b1b6:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b1bc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b1bf:	c1 e2 02             	shl    $0x2,%edx
f011b1c2:	01 d0                	add    %edx,%eax
f011b1c4:	8b 00                	mov    (%eax),%eax
f011b1c6:	83 e0 01             	and    $0x1,%eax
f011b1c9:	85 c0                	test   %eax,%eax
f011b1cb:	74 24                	je     f011b1f1 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b1cd:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b1d3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b1d6:	c1 e2 02             	shl    $0x2,%edx
f011b1d9:	01 d0                	add    %edx,%eax
f011b1db:	8b 00                	mov    (%eax),%eax
f011b1dd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b1e2:	89 c2                	mov    %eax,%edx
f011b1e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b1e7:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b1ec:	01 d0                	add    %edx,%eax
f011b1ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b1f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b1f4:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b1fb:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b1fe:	74 1d                	je     f011b21d <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b200:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b204:	74 17                	je     f011b21d <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b206:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b20d:	83 ec 0c             	sub    $0xc,%esp
f011b210:	68 18 ed 12 f0       	push   $0xf012ed18
f011b215:	e8 71 5d fe ff       	call   f0100f8b <cprintf>
f011b21a:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b21d:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b224:	ff 45 d4             	incl   -0x2c(%ebp)
f011b227:	ff 45 f4             	incl   -0xc(%ebp)
f011b22a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b22d:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b233:	7d 15                	jge    f011b24a <test_kheap_phys_addr+0xb34>
f011b235:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b23c:	7f 0c                	jg     f011b24a <test_kheap_phys_addr+0xb34>
f011b23e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b241:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b244:	0f 82 65 ff ff ff    	jb     f011b1af <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b24a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b24d:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b250:	0f 82 00 ff ff ff    	jb     f011b156 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b256:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b25a:	74 04                	je     f011b260 <test_kheap_phys_addr+0xb4a>
f011b25c:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b260:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b267:	83 ec 0c             	sub    $0xc,%esp
f011b26a:	68 3c ed 12 f0       	push   $0xf012ed3c
f011b26f:	e8 17 5d fe ff       	call   f0100f8b <cprintf>
f011b274:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b277:	83 ec 0c             	sub    $0xc,%esp
f011b27a:	6a 00                	push   $0x0
f011b27c:	e8 50 de fe ff       	call   f01090d1 <sbrk>
f011b281:	83 c4 10             	add    $0x10,%esp
f011b284:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b289:	77 17                	ja     f011b2a2 <test_kheap_phys_addr+0xb8c>
f011b28b:	83 ec 04             	sub    $0x4,%esp
f011b28e:	68 94 ed 12 f0       	push   $0xf012ed94
f011b293:	68 5e 06 00 00       	push   $0x65e
f011b298:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011b29d:	e8 97 50 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b2a2:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b2a9:	e9 af 00 00 00       	jmp    f011b35d <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b2ae:	83 ec 0c             	sub    $0xc,%esp
f011b2b1:	ff 75 d0             	pushl  -0x30(%ebp)
f011b2b4:	e8 91 e2 fe ff       	call   f010954a <kheap_physical_address>
f011b2b9:	83 c4 10             	add    $0x10,%esp
f011b2bc:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b2c2:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b2c7:	83 ec 04             	sub    $0x4,%esp
f011b2ca:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b2d0:	52                   	push   %edx
f011b2d1:	ff 75 d0             	pushl  -0x30(%ebp)
f011b2d4:	50                   	push   %eax
f011b2d5:	e8 15 d1 fe ff       	call   f01083ef <get_page_table>
f011b2da:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b2dd:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b2e3:	85 c0                	test   %eax,%eax
f011b2e5:	75 24                	jne    f011b30b <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b2e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2eb:	74 1e                	je     f011b30b <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b2ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2f4:	83 ec 04             	sub    $0x4,%esp
f011b2f7:	68 b0 ed 12 f0       	push   $0xf012edb0
f011b2fc:	68 66 06 00 00       	push   $0x666
f011b301:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011b306:	e8 2e 50 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b30b:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b311:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b314:	c1 ea 0c             	shr    $0xc,%edx
f011b317:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b31d:	c1 e2 02             	shl    $0x2,%edx
f011b320:	01 d0                	add    %edx,%eax
f011b322:	8b 00                	mov    (%eax),%eax
f011b324:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b329:	89 c2                	mov    %eax,%edx
f011b32b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b32e:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b333:	01 d0                	add    %edx,%eax
f011b335:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b33b:	74 1d                	je     f011b35a <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b33d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b341:	74 17                	je     f011b35a <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b343:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b34a:	83 ec 0c             	sub    $0xc,%esp
f011b34d:	68 10 ee 12 f0       	push   $0xf012ee10
f011b352:	e8 34 5c fe ff       	call   f0100f8b <cprintf>
f011b357:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b35a:	ff 45 d0             	incl   -0x30(%ebp)
f011b35d:	83 ec 0c             	sub    $0xc,%esp
f011b360:	6a 00                	push   $0x0
f011b362:	e8 6a dd fe ff       	call   f01090d1 <sbrk>
f011b367:	83 c4 10             	add    $0x10,%esp
f011b36a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b36d:	0f 87 3b ff ff ff    	ja     f011b2ae <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b373:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b377:	74 04                	je     f011b37d <test_kheap_phys_addr+0xc67>
f011b379:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b37d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011b384:	83 ec 0c             	sub    $0xc,%esp
f011b387:	68 34 ee 12 f0       	push   $0xf012ee34
f011b38c:	e8 fa 5b fe ff       	call   f0100f8b <cprintf>
f011b391:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011b394:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011b39b:	10 00 f9 
		i = 0;
f011b39e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b3a5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b3ab:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b3ae:	eb 0a                	jmp    f011b3ba <test_kheap_phys_addr+0xca4>
		{
			i++;
f011b3b0:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b3b3:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011b3ba:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011b3c1:	76 ed                	jbe    f011b3b0 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011b3c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3c6:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011b3cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b3d3:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b3d9:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011b3dc:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011b3e3:	e9 cb 00 00 00       	jmp    f011b4b3 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011b3e8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011b3eb:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b3f0:	83 ec 04             	sub    $0x4,%esp
f011b3f3:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011b3f9:	51                   	push   %ecx
f011b3fa:	52                   	push   %edx
f011b3fb:	50                   	push   %eax
f011b3fc:	e8 ee cf fe ff       	call   f01083ef <get_page_table>
f011b401:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b404:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011b40a:	85 c0                	test   %eax,%eax
f011b40c:	75 24                	jne    f011b432 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011b40e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b412:	74 1e                	je     f011b432 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b414:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b41b:	83 ec 04             	sub    $0x4,%esp
f011b41e:	68 70 ee 12 f0       	push   $0xf012ee70
f011b423:	68 88 06 00 00       	push   $0x688
f011b428:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011b42d:	e8 07 4f fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b432:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011b439:	eb 59                	jmp    f011b494 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011b43b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b43e:	c1 e0 0c             	shl    $0xc,%eax
f011b441:	89 c2                	mov    %eax,%edx
f011b443:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b449:	01 d0                	add    %edx,%eax
f011b44b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011b451:	83 ec 0c             	sub    $0xc,%esp
f011b454:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b45a:	e8 eb e0 fe ff       	call   f010954a <kheap_physical_address>
f011b45f:	83 c4 10             	add    $0x10,%esp
f011b462:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011b468:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011b46f:	74 1d                	je     f011b48e <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b471:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b475:	74 17                	je     f011b48e <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011b477:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b47e:	83 ec 0c             	sub    $0xc,%esp
f011b481:	68 d0 ee 12 f0       	push   $0xf012eed0
f011b486:	e8 00 5b fe ff       	call   f0100f8b <cprintf>
f011b48b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b48e:	ff 45 c8             	incl   -0x38(%ebp)
f011b491:	ff 45 f4             	incl   -0xc(%ebp)
f011b494:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b497:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b49d:	7d 09                	jge    f011b4a8 <test_kheap_phys_addr+0xd92>
f011b49f:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011b4a6:	7e 93                	jle    f011b43b <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b4a8:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011b4af:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011b4b3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b4b7:	0f 88 2b ff ff ff    	js     f011b3e8 <test_kheap_phys_addr+0xcd2>
f011b4bd:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b4c1:	7f 0d                	jg     f011b4d0 <test_kheap_phys_addr+0xdba>
f011b4c3:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011b4ca:	0f 86 18 ff ff ff    	jbe    f011b3e8 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011b4d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b4d4:	74 04                	je     f011b4da <test_kheap_phys_addr+0xdc4>
f011b4d6:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011b4da:	83 ec 08             	sub    $0x8,%esp
f011b4dd:	ff 75 f0             	pushl  -0x10(%ebp)
f011b4e0:	68 f4 ee 12 f0       	push   $0xf012eef4
f011b4e5:	e8 a1 5a fe ff       	call   f0100f8b <cprintf>
f011b4ea:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b4ed:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b4f2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b4f5:	5b                   	pop    %ebx
f011b4f6:	5f                   	pop    %edi
f011b4f7:	5d                   	pop    %ebp
f011b4f8:	c3                   	ret    

f011b4f9 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011b4f9:	55                   	push   %ebp
f011b4fa:	89 e5                	mov    %esp,%ebp
f011b4fc:	57                   	push   %edi
f011b4fd:	56                   	push   %esi
f011b4fe:	53                   	push   %ebx
f011b4ff:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011b505:	89 e0                	mov    %esp,%eax
f011b507:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b509:	83 ec 0c             	sub    $0xc,%esp
f011b50c:	68 68 a8 12 f0       	push   $0xf012a868
f011b511:	e8 75 5a fe ff       	call   f0100f8b <cprintf>
f011b516:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b519:	83 ec 0c             	sub    $0xc,%esp
f011b51c:	68 98 a8 12 f0       	push   $0xf012a898
f011b521:	e8 65 5a fe ff       	call   f0100f8b <cprintf>
f011b526:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b529:	83 ec 0c             	sub    $0xc,%esp
f011b52c:	68 68 a8 12 f0       	push   $0xf012a868
f011b531:	e8 55 5a fe ff       	call   f0100f8b <cprintf>
f011b536:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b539:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011b53d:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011b541:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011b547:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011b54d:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b554:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b55b:	e8 66 2d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b560:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b563:	83 ec 0c             	sub    $0xc,%esp
f011b566:	68 d0 e5 12 f0       	push   $0xf012e5d0
f011b56b:	e8 1b 5a fe ff       	call   f0100f8b <cprintf>
f011b570:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b573:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011b579:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b57e:	b8 00 00 00 00       	mov    $0x0,%eax
f011b583:	89 d7                	mov    %edx,%edi
f011b585:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b587:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011b58d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b592:	b8 00 00 00 00       	mov    $0x0,%eax
f011b597:	89 d7                	mov    %edx,%edi
f011b599:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011b59b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b5a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011b5a9:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b5af:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b5b4:	b8 00 00 00 00       	mov    $0x0,%eax
f011b5b9:	89 d7                	mov    %edx,%edi
f011b5bb:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b5bd:	e8 04 2d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b5c2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b5c5:	e8 db 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5ca:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b5cd:	83 ec 0c             	sub    $0xc,%esp
f011b5d0:	68 00 fc 1f 00       	push   $0x1ffc00
f011b5d5:	e8 2a dc fe ff       	call   f0109204 <kmalloc>
f011b5da:	83 c4 10             	add    $0x10,%esp
f011b5dd:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b5e3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b5e9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b5ee:	74 17                	je     f011b607 <test_kheap_virt_addr+0x10e>
f011b5f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5f7:	83 ec 0c             	sub    $0xc,%esp
f011b5fa:	68 74 c9 12 f0       	push   $0xf012c974
f011b5ff:	e8 87 59 fe ff       	call   f0100f8b <cprintf>
f011b604:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b607:	e8 99 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b60c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b60f:	74 17                	je     f011b628 <test_kheap_virt_addr+0x12f>
f011b611:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b618:	83 ec 0c             	sub    $0xc,%esp
f011b61b:	68 c8 c9 12 f0       	push   $0xf012c9c8
f011b620:	e8 66 59 fe ff       	call   f0100f8b <cprintf>
f011b625:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b628:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b62b:	e8 96 2c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b630:	29 c3                	sub    %eax,%ebx
f011b632:	89 d8                	mov    %ebx,%eax
f011b634:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b639:	77 17                	ja     f011b652 <test_kheap_virt_addr+0x159>
f011b63b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b642:	83 ec 0c             	sub    $0xc,%esp
f011b645:	68 38 ca 12 f0       	push   $0xf012ca38
f011b64a:	e8 3c 59 fe ff       	call   f0100f8b <cprintf>
f011b64f:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b652:	e8 6f 2c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b657:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b65a:	e8 46 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b65f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b662:	83 ec 0c             	sub    $0xc,%esp
f011b665:	68 00 fc 1f 00       	push   $0x1ffc00
f011b66a:	e8 95 db fe ff       	call   f0109204 <kmalloc>
f011b66f:	83 c4 10             	add    $0x10,%esp
f011b672:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b678:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b67e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b683:	74 17                	je     f011b69c <test_kheap_virt_addr+0x1a3>
f011b685:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b68c:	83 ec 0c             	sub    $0xc,%esp
f011b68f:	68 80 ca 12 f0       	push   $0xf012ca80
f011b694:	e8 f2 58 fe ff       	call   f0100f8b <cprintf>
f011b699:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b69c:	e8 04 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6a1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b6a4:	74 17                	je     f011b6bd <test_kheap_virt_addr+0x1c4>
f011b6a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b6ad:	83 ec 0c             	sub    $0xc,%esp
f011b6b0:	68 d4 ca 12 f0       	push   $0xf012cad4
f011b6b5:	e8 d1 58 fe ff       	call   f0100f8b <cprintf>
f011b6ba:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b6bd:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b6c0:	e8 01 2c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b6c5:	29 c3                	sub    %eax,%ebx
f011b6c7:	89 d8                	mov    %ebx,%eax
f011b6c9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b6ce:	77 17                	ja     f011b6e7 <test_kheap_virt_addr+0x1ee>
f011b6d0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b6d7:	83 ec 0c             	sub    $0xc,%esp
f011b6da:	68 44 cb 12 f0       	push   $0xf012cb44
f011b6df:	e8 a7 58 fe ff       	call   f0100f8b <cprintf>
f011b6e4:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b6e7:	e8 da 2b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b6ec:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b6ef:	e8 b1 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6f4:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b6f7:	83 ec 0c             	sub    $0xc,%esp
f011b6fa:	68 00 04 00 00       	push   $0x400
f011b6ff:	e8 00 db fe ff       	call   f0109204 <kmalloc>
f011b704:	83 c4 10             	add    $0x10,%esp
f011b707:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b70d:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b713:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b718:	76 28                	jbe    f011b742 <test_kheap_virt_addr+0x249>
f011b71a:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011b720:	83 ec 0c             	sub    $0xc,%esp
f011b723:	6a 00                	push   $0x0
f011b725:	e8 a7 d9 fe ff       	call   f01090d1 <sbrk>
f011b72a:	83 c4 10             	add    $0x10,%esp
f011b72d:	39 c3                	cmp    %eax,%ebx
f011b72f:	73 11                	jae    f011b742 <test_kheap_virt_addr+0x249>
f011b731:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b737:	89 c2                	mov    %eax,%edx
f011b739:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b73e:	39 c2                	cmp    %eax,%edx
f011b740:	72 17                	jb     f011b759 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b742:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b749:	83 ec 0c             	sub    $0xc,%esp
f011b74c:	68 00 e6 12 f0       	push   $0xf012e600
f011b751:	e8 35 58 fe ff       	call   f0100f8b <cprintf>
f011b756:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b759:	e8 47 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b75e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b761:	74 17                	je     f011b77a <test_kheap_virt_addr+0x281>
f011b763:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b76a:	83 ec 0c             	sub    $0xc,%esp
f011b76d:	68 e0 cb 12 f0       	push   $0xf012cbe0
f011b772:	e8 14 58 fe ff       	call   f0100f8b <cprintf>
f011b777:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b77a:	e8 47 2b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b77f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b782:	e8 1e 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b787:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b78a:	83 ec 0c             	sub    $0xc,%esp
f011b78d:	68 00 08 00 00       	push   $0x800
f011b792:	e8 6d da fe ff       	call   f0109204 <kmalloc>
f011b797:	83 c4 10             	add    $0x10,%esp
f011b79a:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b7a0:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b7a6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b7ab:	76 28                	jbe    f011b7d5 <test_kheap_virt_addr+0x2dc>
f011b7ad:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b7b3:	83 ec 0c             	sub    $0xc,%esp
f011b7b6:	6a 00                	push   $0x0
f011b7b8:	e8 14 d9 fe ff       	call   f01090d1 <sbrk>
f011b7bd:	83 c4 10             	add    $0x10,%esp
f011b7c0:	39 c3                	cmp    %eax,%ebx
f011b7c2:	73 11                	jae    f011b7d5 <test_kheap_virt_addr+0x2dc>
f011b7c4:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b7ca:	89 c2                	mov    %eax,%edx
f011b7cc:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b7d1:	39 c2                	cmp    %eax,%edx
f011b7d3:	72 17                	jb     f011b7ec <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b7d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7dc:	83 ec 0c             	sub    $0xc,%esp
f011b7df:	68 8c e6 12 f0       	push   $0xf012e68c
f011b7e4:	e8 a2 57 fe ff       	call   f0100f8b <cprintf>
f011b7e9:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b7ec:	e8 b4 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b7f1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b7f4:	74 17                	je     f011b80d <test_kheap_virt_addr+0x314>
f011b7f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7fd:	83 ec 0c             	sub    $0xc,%esp
f011b800:	68 ec cc 12 f0       	push   $0xf012ccec
f011b805:	e8 81 57 fe ff       	call   f0100f8b <cprintf>
f011b80a:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b80d:	e8 b4 2a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b812:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b815:	e8 8b 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b81a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b81d:	83 ec 0c             	sub    $0xc,%esp
f011b820:	68 00 06 00 00       	push   $0x600
f011b825:	e8 da d9 fe ff       	call   f0109204 <kmalloc>
f011b82a:	83 c4 10             	add    $0x10,%esp
f011b82d:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b833:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b839:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b83e:	76 28                	jbe    f011b868 <test_kheap_virt_addr+0x36f>
f011b840:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b846:	83 ec 0c             	sub    $0xc,%esp
f011b849:	6a 00                	push   $0x0
f011b84b:	e8 81 d8 fe ff       	call   f01090d1 <sbrk>
f011b850:	83 c4 10             	add    $0x10,%esp
f011b853:	39 c3                	cmp    %eax,%ebx
f011b855:	73 11                	jae    f011b868 <test_kheap_virt_addr+0x36f>
f011b857:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b85d:	89 c2                	mov    %eax,%edx
f011b85f:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b864:	39 c2                	cmp    %eax,%edx
f011b866:	72 17                	jb     f011b87f <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b868:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b86f:	83 ec 0c             	sub    $0xc,%esp
f011b872:	68 18 e7 12 f0       	push   $0xf012e718
f011b877:	e8 0f 57 fe ff       	call   f0100f8b <cprintf>
f011b87c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b87f:	e8 21 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b884:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b887:	74 17                	je     f011b8a0 <test_kheap_virt_addr+0x3a7>
f011b889:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b890:	83 ec 0c             	sub    $0xc,%esp
f011b893:	68 f8 cd 12 f0       	push   $0xf012cdf8
f011b898:	e8 ee 56 fe ff       	call   f0100f8b <cprintf>
f011b89d:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b8a0:	e8 21 2a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b8a5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b8a8:	e8 f8 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8ad:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b8b0:	83 ec 0c             	sub    $0xc,%esp
f011b8b3:	68 00 1c 00 00       	push   $0x1c00
f011b8b8:	e8 47 d9 fe ff       	call   f0109204 <kmalloc>
f011b8bd:	83 c4 10             	add    $0x10,%esp
f011b8c0:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b8c6:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b8cc:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b8d1:	74 17                	je     f011b8ea <test_kheap_virt_addr+0x3f1>
f011b8d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8da:	83 ec 0c             	sub    $0xc,%esp
f011b8dd:	68 b0 ce 12 f0       	push   $0xf012ceb0
f011b8e2:	e8 a4 56 fe ff       	call   f0100f8b <cprintf>
f011b8e7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8ea:	e8 b6 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8ef:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b8f2:	74 17                	je     f011b90b <test_kheap_virt_addr+0x412>
f011b8f4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8fb:	83 ec 0c             	sub    $0xc,%esp
f011b8fe:	68 04 cf 12 f0       	push   $0xf012cf04
f011b903:	e8 83 56 fe ff       	call   f0100f8b <cprintf>
f011b908:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b90b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b90e:	e8 b3 29 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b913:	29 c3                	sub    %eax,%ebx
f011b915:	89 d8                	mov    %ebx,%eax
f011b917:	83 f8 01             	cmp    $0x1,%eax
f011b91a:	77 17                	ja     f011b933 <test_kheap_virt_addr+0x43a>
f011b91c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b923:	83 ec 0c             	sub    $0xc,%esp
f011b926:	68 74 cf 12 f0       	push   $0xf012cf74
f011b92b:	e8 5b 56 fe ff       	call   f0100f8b <cprintf>
f011b930:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b933:	e8 8e 29 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b938:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b93b:	e8 65 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b940:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b943:	83 ec 0c             	sub    $0xc,%esp
f011b946:	68 00 fc 2f 00       	push   $0x2ffc00
f011b94b:	e8 b4 d8 fe ff       	call   f0109204 <kmalloc>
f011b950:	83 c4 10             	add    $0x10,%esp
f011b953:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b959:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b95f:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b964:	74 17                	je     f011b97d <test_kheap_virt_addr+0x484>
f011b966:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b96d:	83 ec 0c             	sub    $0xc,%esp
f011b970:	68 a4 e7 12 f0       	push   $0xf012e7a4
f011b975:	e8 11 56 fe ff       	call   f0100f8b <cprintf>
f011b97a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b97d:	e8 23 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b982:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b985:	74 17                	je     f011b99e <test_kheap_virt_addr+0x4a5>
f011b987:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b98e:	83 ec 0c             	sub    $0xc,%esp
f011b991:	68 48 d0 12 f0       	push   $0xf012d048
f011b996:	e8 f0 55 fe ff       	call   f0100f8b <cprintf>
f011b99b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b99e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b9a1:	e8 20 29 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b9a6:	29 c3                	sub    %eax,%ebx
f011b9a8:	89 d8                	mov    %ebx,%eax
f011b9aa:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b9af:	77 17                	ja     f011b9c8 <test_kheap_virt_addr+0x4cf>
f011b9b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9b8:	83 ec 0c             	sub    $0xc,%esp
f011b9bb:	68 f8 e7 12 f0       	push   $0xf012e7f8
f011b9c0:	e8 c6 55 fe ff       	call   f0100f8b <cprintf>
f011b9c5:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b9c8:	e8 f9 28 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011b9cd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b9d0:	e8 d0 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b9d5:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b9d8:	83 ec 0c             	sub    $0xc,%esp
f011b9db:	68 00 fc 5f 00       	push   $0x5ffc00
f011b9e0:	e8 1f d8 fe ff       	call   f0109204 <kmalloc>
f011b9e5:	83 c4 10             	add    $0x10,%esp
f011b9e8:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b9ee:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b9f4:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b9f9:	74 17                	je     f011ba12 <test_kheap_virt_addr+0x519>
f011b9fb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba02:	83 ec 0c             	sub    $0xc,%esp
f011ba05:	68 40 e8 12 f0       	push   $0xf012e840
f011ba0a:	e8 7c 55 fe ff       	call   f0100f8b <cprintf>
f011ba0f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba12:	e8 8e 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ba17:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ba1a:	74 17                	je     f011ba33 <test_kheap_virt_addr+0x53a>
f011ba1c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba23:	83 ec 0c             	sub    $0xc,%esp
f011ba26:	68 44 d1 12 f0       	push   $0xf012d144
f011ba2b:	e8 5b 55 fe ff       	call   f0100f8b <cprintf>
f011ba30:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ba33:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ba36:	e8 8b 28 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ba3b:	29 c3                	sub    %eax,%ebx
f011ba3d:	89 d8                	mov    %ebx,%eax
f011ba3f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ba44:	77 17                	ja     f011ba5d <test_kheap_virt_addr+0x564>
f011ba46:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba4d:	83 ec 0c             	sub    $0xc,%esp
f011ba50:	68 94 e8 12 f0       	push   $0xf012e894
f011ba55:	e8 31 55 fe ff       	call   f0100f8b <cprintf>
f011ba5a:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ba5d:	e8 64 28 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ba62:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ba65:	e8 3b 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ba6a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ba6d:	83 ec 0c             	sub    $0xc,%esp
f011ba70:	68 00 38 00 00       	push   $0x3800
f011ba75:	e8 8a d7 fe ff       	call   f0109204 <kmalloc>
f011ba7a:	83 c4 10             	add    $0x10,%esp
f011ba7d:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ba83:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011ba89:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011ba8e:	74 17                	je     f011baa7 <test_kheap_virt_addr+0x5ae>
f011ba90:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba97:	83 ec 0c             	sub    $0xc,%esp
f011ba9a:	68 dc e8 12 f0       	push   $0xf012e8dc
f011ba9f:	e8 e7 54 fe ff       	call   f0100f8b <cprintf>
f011baa4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011baa7:	e8 f9 8d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011baac:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011baaf:	74 17                	je     f011bac8 <test_kheap_virt_addr+0x5cf>
f011bab1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bab8:	83 ec 0c             	sub    $0xc,%esp
f011babb:	68 30 e9 12 f0       	push   $0xf012e930
f011bac0:	e8 c6 54 fe ff       	call   f0100f8b <cprintf>
f011bac5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bac8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bacb:	e8 f6 27 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bad0:	29 c3                	sub    %eax,%ebx
f011bad2:	89 d8                	mov    %ebx,%eax
f011bad4:	83 f8 03             	cmp    $0x3,%eax
f011bad7:	77 17                	ja     f011baf0 <test_kheap_virt_addr+0x5f7>
f011bad9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bae0:	83 ec 0c             	sub    $0xc,%esp
f011bae3:	68 a0 e9 12 f0       	push   $0xf012e9a0
f011bae8:	e8 9e 54 fe ff       	call   f0100f8b <cprintf>
f011baed:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011baf0:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011baf7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011bafa:	c1 e8 0c             	shr    $0xc,%eax
f011bafd:	89 c2                	mov    %eax,%edx
f011baff:	4a                   	dec    %edx
f011bb00:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011bb03:	c1 e0 02             	shl    $0x2,%eax
f011bb06:	8d 50 03             	lea    0x3(%eax),%edx
f011bb09:	b8 10 00 00 00       	mov    $0x10,%eax
f011bb0e:	48                   	dec    %eax
f011bb0f:	01 d0                	add    %edx,%eax
f011bb11:	bf 10 00 00 00       	mov    $0x10,%edi
f011bb16:	ba 00 00 00 00       	mov    $0x0,%edx
f011bb1b:	f7 f7                	div    %edi
f011bb1d:	6b c0 10             	imul   $0x10,%eax,%eax
f011bb20:	29 c4                	sub    %eax,%esp
f011bb22:	89 e0                	mov    %esp,%eax
f011bb24:	83 c0 03             	add    $0x3,%eax
f011bb27:	c1 e8 02             	shr    $0x2,%eax
f011bb2a:	c1 e0 02             	shl    $0x2,%eax
f011bb2d:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011bb30:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011bb33:	c1 e8 0c             	shr    $0xc,%eax
f011bb36:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011bb39:	83 ec 0c             	sub    $0xc,%esp
f011bb3c:	68 28 ef 12 f0       	push   $0xf012ef28
f011bb41:	e8 45 54 fe ff       	call   f0100f8b <cprintf>
f011bb46:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011bb49:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011bb50:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011bb55:	05 00 10 00 00       	add    $0x1000,%eax
f011bb5a:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011bb5d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011bb64:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011bb67:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011bb6a:	e9 2d 01 00 00       	jmp    f011bc9c <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bb6f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011bb74:	83 ec 04             	sub    $0x4,%esp
f011bb77:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011bb7d:	52                   	push   %edx
f011bb7e:	ff 75 dc             	pushl  -0x24(%ebp)
f011bb81:	50                   	push   %eax
f011bb82:	e8 68 c8 fe ff       	call   f01083ef <get_page_table>
f011bb87:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bb8a:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011bb90:	85 c0                	test   %eax,%eax
f011bb92:	75 1e                	jne    f011bbb2 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bb94:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb9b:	83 ec 04             	sub    $0x4,%esp
f011bb9e:	68 34 ea 12 f0       	push   $0xf012ea34
f011bba3:	68 27 07 00 00       	push   $0x727
f011bba8:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011bbad:	e8 87 47 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011bbb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bbb5:	c1 e8 0c             	shr    $0xc,%eax
f011bbb8:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bbbd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bbc0:	e9 ba 00 00 00       	jmp    f011bc7f <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011bbc5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011bbc8:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011bbcb:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011bbd1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bbd4:	c1 e2 02             	shl    $0x2,%edx
f011bbd7:	01 d0                	add    %edx,%eax
f011bbd9:	8b 00                	mov    (%eax),%eax
f011bbdb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bbe0:	89 c2                	mov    %eax,%edx
f011bbe2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bbe5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bbe8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bbeb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bbee:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bbf1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bbf4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bbf7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bbfa:	83 ec 0c             	sub    $0xc,%esp
f011bbfd:	50                   	push   %eax
f011bbfe:	e8 a4 d9 fe ff       	call   f01095a7 <kheap_virtual_address>
f011bc03:	83 c4 10             	add    $0x10,%esp
f011bc06:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011bc09:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011bc0c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bc0f:	01 d0                	add    %edx,%eax
f011bc11:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bc14:	74 5c                	je     f011bc72 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011bc16:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bc1a:	74 56                	je     f011bc72 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011bc1c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bc1f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bc22:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bc25:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011bc2b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011bc2e:	c1 e1 02             	shl    $0x2,%ecx
f011bc31:	01 ca                	add    %ecx,%edx
f011bc33:	8b 12                	mov    (%edx),%edx
f011bc35:	89 d1                	mov    %edx,%ecx
f011bc37:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011bc3d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011bc40:	8b 55 90             	mov    -0x70(%ebp),%edx
f011bc43:	01 da                	add    %ebx,%edx
f011bc45:	83 ec 0c             	sub    $0xc,%esp
f011bc48:	50                   	push   %eax
f011bc49:	51                   	push   %ecx
f011bc4a:	52                   	push   %edx
f011bc4b:	ff 75 8c             	pushl  -0x74(%ebp)
f011bc4e:	68 74 ef 12 f0       	push   $0xf012ef74
f011bc53:	e8 33 53 fe ff       	call   f0100f8b <cprintf>
f011bc58:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011bc5b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc62:	83 ec 0c             	sub    $0xc,%esp
f011bc65:	68 b8 ef 12 f0       	push   $0xf012efb8
f011bc6a:	e8 1c 53 fe ff       	call   f0100f8b <cprintf>
f011bc6f:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011bc72:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011bc79:	ff 45 d4             	incl   -0x2c(%ebp)
f011bc7c:	ff 45 d8             	incl   -0x28(%ebp)
f011bc7f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bc82:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011bc85:	7d 15                	jge    f011bc9c <test_kheap_virt_addr+0x7a3>
f011bc87:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bc8e:	7f 0c                	jg     f011bc9c <test_kheap_virt_addr+0x7a3>
f011bc90:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bc93:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bc96:	0f 82 29 ff ff ff    	jb     f011bbc5 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bc9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bc9f:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bca2:	0f 82 c7 fe ff ff    	jb     f011bb6f <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bca8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bcac:	74 04                	je     f011bcb2 <test_kheap_virt_addr+0x7b9>
f011bcae:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011bcb2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011bcb9:	83 ec 0c             	sub    $0xc,%esp
f011bcbc:	68 dc ef 12 f0       	push   $0xf012efdc
f011bcc1:	e8 c5 52 fe ff       	call   f0100f8b <cprintf>
f011bcc6:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011bcc9:	e8 f8 25 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bcce:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011bcd1:	e8 cf 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcd6:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011bcd9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bcdf:	83 ec 0c             	sub    $0xc,%esp
f011bce2:	50                   	push   %eax
f011bce3:	e8 7c d7 fe ff       	call   f0109464 <kfree>
f011bce8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bceb:	e8 b5 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcf0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bcf3:	74 17                	je     f011bd0c <test_kheap_virt_addr+0x813>
f011bcf5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcfc:	83 ec 0c             	sub    $0xc,%esp
f011bcff:	68 04 f0 12 f0       	push   $0xf012f004
f011bd04:	e8 82 52 fe ff       	call   f0100f8b <cprintf>
f011bd09:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bd0c:	e8 b5 25 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bd11:	89 c2                	mov    %eax,%edx
f011bd13:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bd16:	29 c2                	sub    %eax,%edx
f011bd18:	89 d0                	mov    %edx,%eax
f011bd1a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd1f:	77 17                	ja     f011bd38 <test_kheap_virt_addr+0x83f>
f011bd21:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd28:	83 ec 0c             	sub    $0xc,%esp
f011bd2b:	68 74 f0 12 f0       	push   $0xf012f074
f011bd30:	e8 56 52 fe ff       	call   f0100f8b <cprintf>
f011bd35:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd38:	e8 89 25 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bd3d:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd40:	e8 60 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd45:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011bd48:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bd4e:	83 ec 0c             	sub    $0xc,%esp
f011bd51:	50                   	push   %eax
f011bd52:	e8 0d d7 fe ff       	call   f0109464 <kfree>
f011bd57:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd5a:	e8 46 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd5f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bd62:	74 17                	je     f011bd7b <test_kheap_virt_addr+0x882>
f011bd64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd6b:	83 ec 0c             	sub    $0xc,%esp
f011bd6e:	68 b0 f0 12 f0       	push   $0xf012f0b0
f011bd73:	e8 13 52 fe ff       	call   f0100f8b <cprintf>
f011bd78:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bd7b:	e8 46 25 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bd80:	89 c2                	mov    %eax,%edx
f011bd82:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bd85:	29 c2                	sub    %eax,%edx
f011bd87:	89 d0                	mov    %edx,%eax
f011bd89:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd8e:	77 17                	ja     f011bda7 <test_kheap_virt_addr+0x8ae>
f011bd90:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd97:	83 ec 0c             	sub    $0xc,%esp
f011bd9a:	68 20 f1 12 f0       	push   $0xf012f120
f011bd9f:	e8 e7 51 fe ff       	call   f0100f8b <cprintf>
f011bda4:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bda7:	e8 1a 25 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bdac:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bdaf:	e8 f1 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bdb4:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011bdb7:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bdbd:	83 ec 0c             	sub    $0xc,%esp
f011bdc0:	50                   	push   %eax
f011bdc1:	e8 9e d6 fe ff       	call   f0109464 <kfree>
f011bdc6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdc9:	e8 d7 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bdce:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bdd1:	74 17                	je     f011bdea <test_kheap_virt_addr+0x8f1>
f011bdd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdda:	83 ec 0c             	sub    $0xc,%esp
f011bddd:	68 5c f1 12 f0       	push   $0xf012f15c
f011bde2:	e8 a4 51 fe ff       	call   f0100f8b <cprintf>
f011bde7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bdea:	e8 d7 24 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011bdef:	89 c2                	mov    %eax,%edx
f011bdf1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bdf4:	29 c2                	sub    %eax,%edx
f011bdf6:	89 d0                	mov    %edx,%eax
f011bdf8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bdfd:	77 17                	ja     f011be16 <test_kheap_virt_addr+0x91d>
f011bdff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be06:	83 ec 0c             	sub    $0xc,%esp
f011be09:	68 cc f1 12 f0       	push   $0xf012f1cc
f011be0e:	e8 78 51 fe ff       	call   f0100f8b <cprintf>
f011be13:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011be16:	83 ec 0c             	sub    $0xc,%esp
f011be19:	68 08 f2 12 f0       	push   $0xf012f208
f011be1e:	e8 68 51 fe ff       	call   f0100f8b <cprintf>
f011be23:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011be26:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011be2d:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011be32:	05 00 10 00 00       	add    $0x1000,%eax
f011be37:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011be3d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011be44:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011be4b:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011be4e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be54:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011be57:	eb 44                	jmp    f011be9d <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011be59:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be5c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011be5f:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011be62:	83 ec 0c             	sub    $0xc,%esp
f011be65:	50                   	push   %eax
f011be66:	e8 3c d7 fe ff       	call   f01095a7 <kheap_virtual_address>
f011be6b:	83 c4 10             	add    $0x10,%esp
f011be6e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011be74:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011be7b:	74 1d                	je     f011be9a <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011be7d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011be81:	74 17                	je     f011be9a <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011be83:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be8a:	83 ec 0c             	sub    $0xc,%esp
f011be8d:	68 58 f2 12 f0       	push   $0xf012f258
f011be92:	e8 f4 50 fe ff       	call   f0100f8b <cprintf>
f011be97:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011be9a:	ff 45 d0             	incl   -0x30(%ebp)
f011be9d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bea3:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011bea9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011beac:	39 c2                	cmp    %eax,%edx
f011beae:	77 a9                	ja     f011be59 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011beb0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011beb6:	05 00 04 00 00       	add    $0x400,%eax
f011bebb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bebe:	eb 64                	jmp    f011bf24 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bec0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bec3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bec6:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bec9:	83 ec 0c             	sub    $0xc,%esp
f011becc:	50                   	push   %eax
f011becd:	e8 d5 d6 fe ff       	call   f01095a7 <kheap_virtual_address>
f011bed2:	83 c4 10             	add    $0x10,%esp
f011bed5:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011bedb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bede:	c1 e0 0c             	shl    $0xc,%eax
f011bee1:	89 c2                	mov    %eax,%edx
f011bee3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bee9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011beec:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011beef:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bef2:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bef5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011befa:	01 c8                	add    %ecx,%eax
f011befc:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bf02:	74 1d                	je     f011bf21 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011bf04:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bf08:	74 17                	je     f011bf21 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011bf0a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf11:	83 ec 0c             	sub    $0xc,%esp
f011bf14:	68 7c f2 12 f0       	push   $0xf012f27c
f011bf19:	e8 6d 50 fe ff       	call   f0100f8b <cprintf>
f011bf1e:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bf21:	ff 45 d0             	incl   -0x30(%ebp)
f011bf24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bf2a:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011bf30:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bf33:	39 c2                	cmp    %eax,%edx
f011bf35:	77 89                	ja     f011bec0 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bf37:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bf3d:	05 02 07 00 00       	add    $0x702,%eax
f011bf42:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bf45:	eb 44                	jmp    f011bf8b <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bf47:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bf4a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bf4d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bf50:	83 ec 0c             	sub    $0xc,%esp
f011bf53:	50                   	push   %eax
f011bf54:	e8 4e d6 fe ff       	call   f01095a7 <kheap_virtual_address>
f011bf59:	83 c4 10             	add    $0x10,%esp
f011bf5c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011bf62:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011bf69:	74 1d                	je     f011bf88 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011bf6b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bf6f:	74 17                	je     f011bf88 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011bf71:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf78:	83 ec 0c             	sub    $0xc,%esp
f011bf7b:	68 a0 f2 12 f0       	push   $0xf012f2a0
f011bf80:	e8 06 50 fe ff       	call   f0100f8b <cprintf>
f011bf85:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bf88:	ff 45 d0             	incl   -0x30(%ebp)
f011bf8b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bf91:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011bf97:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bf9a:	39 c2                	cmp    %eax,%edx
f011bf9c:	77 a9                	ja     f011bf47 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011bf9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bfa4:	05 02 0d 00 00       	add    $0xd02,%eax
f011bfa9:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bfac:	eb 64                	jmp    f011c012 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bfae:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bfb1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bfb4:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bfb7:	83 ec 0c             	sub    $0xc,%esp
f011bfba:	50                   	push   %eax
f011bfbb:	e8 e7 d5 fe ff       	call   f01095a7 <kheap_virtual_address>
f011bfc0:	83 c4 10             	add    $0x10,%esp
f011bfc3:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011bfc9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bfcc:	c1 e0 0c             	shl    $0xc,%eax
f011bfcf:	89 c2                	mov    %eax,%edx
f011bfd1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bfd7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bfda:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bfdd:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bfe0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bfe3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bfe8:	01 c8                	add    %ecx,%eax
f011bfea:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bff0:	74 1d                	je     f011c00f <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011bff2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bff6:	74 17                	je     f011c00f <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011bff8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfff:	83 ec 0c             	sub    $0xc,%esp
f011c002:	68 c4 f2 12 f0       	push   $0xf012f2c4
f011c007:	e8 7f 4f fe ff       	call   f0100f8b <cprintf>
f011c00c:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c00f:	ff 45 d0             	incl   -0x30(%ebp)
f011c012:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c018:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c01e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c021:	39 c2                	cmp    %eax,%edx
f011c023:	77 89                	ja     f011bfae <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c025:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c029:	74 04                	je     f011c02f <test_kheap_virt_addr+0xb36>
f011c02b:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c02f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c036:	83 ec 0c             	sub    $0xc,%esp
f011c039:	68 e8 f2 12 f0       	push   $0xf012f2e8
f011c03e:	e8 48 4f fe ff       	call   f0100f8b <cprintf>
f011c043:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c046:	83 ec 0c             	sub    $0xc,%esp
f011c049:	6a 00                	push   $0x0
f011c04b:	e8 81 d0 fe ff       	call   f01090d1 <sbrk>
f011c050:	83 c4 10             	add    $0x10,%esp
f011c053:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c058:	77 17                	ja     f011c071 <test_kheap_virt_addr+0xb78>
f011c05a:	83 ec 04             	sub    $0x4,%esp
f011c05d:	68 2f f3 12 f0       	push   $0xf012f32f
f011c062:	68 92 07 00 00       	push   $0x792
f011c067:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011c06c:	e8 c8 42 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c071:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c078:	e9 d1 00 00 00       	jmp    f011c14e <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c07d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011c082:	83 ec 04             	sub    $0x4,%esp
f011c085:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c08b:	52                   	push   %edx
f011c08c:	ff 75 cc             	pushl  -0x34(%ebp)
f011c08f:	50                   	push   %eax
f011c090:	e8 5a c3 fe ff       	call   f01083ef <get_page_table>
f011c095:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c098:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c09e:	85 c0                	test   %eax,%eax
f011c0a0:	75 1e                	jne    f011c0c0 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c0a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a9:	83 ec 04             	sub    $0x4,%esp
f011c0ac:	68 b8 ec 12 f0       	push   $0xf012ecb8
f011c0b1:	68 98 07 00 00       	push   $0x798
f011c0b6:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011c0bb:	e8 79 42 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c0c0:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c0c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c0c9:	c1 ea 0c             	shr    $0xc,%edx
f011c0cc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c0d2:	c1 e2 02             	shl    $0x2,%edx
f011c0d5:	01 d0                	add    %edx,%eax
f011c0d7:	8b 00                	mov    (%eax),%eax
f011c0d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c0de:	89 c2                	mov    %eax,%edx
f011c0e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c0e3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c0e8:	01 d0                	add    %edx,%eax
f011c0ea:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c0f0:	83 ec 0c             	sub    $0xc,%esp
f011c0f3:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c0f9:	e8 a9 d4 fe ff       	call   f01095a7 <kheap_virtual_address>
f011c0fe:	83 c4 10             	add    $0x10,%esp
f011c101:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c107:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c10d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c110:	74 39                	je     f011c14b <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c112:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c116:	74 33                	je     f011c14b <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c118:	ff 75 cc             	pushl  -0x34(%ebp)
f011c11b:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c121:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c127:	68 48 f3 12 f0       	push   $0xf012f348
f011c12c:	e8 5a 4e fe ff       	call   f0100f8b <cprintf>
f011c131:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c134:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c13b:	83 ec 0c             	sub    $0xc,%esp
f011c13e:	68 74 f3 12 f0       	push   $0xf012f374
f011c143:	e8 43 4e fe ff       	call   f0100f8b <cprintf>
f011c148:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c14b:	ff 45 cc             	incl   -0x34(%ebp)
f011c14e:	83 ec 0c             	sub    $0xc,%esp
f011c151:	6a 00                	push   $0x0
f011c153:	e8 79 cf fe ff       	call   f01090d1 <sbrk>
f011c158:	83 c4 10             	add    $0x10,%esp
f011c15b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c15e:	0f 87 19 ff ff ff    	ja     f011c07d <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c164:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c168:	74 04                	je     f011c16e <test_kheap_virt_addr+0xc75>
f011c16a:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c16e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c175:	83 ec 0c             	sub    $0xc,%esp
f011c178:	68 98 f3 12 f0       	push   $0xf012f398
f011c17d:	e8 09 4e fe ff       	call   f0100f8b <cprintf>
f011c182:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c185:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c18c:	eb 5a                	jmp    f011c1e8 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c18e:	83 ec 0c             	sub    $0xc,%esp
f011c191:	ff 75 c8             	pushl  -0x38(%ebp)
f011c194:	e8 0e d4 fe ff       	call   f01095a7 <kheap_virtual_address>
f011c199:	83 c4 10             	add    $0x10,%esp
f011c19c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c1a2:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c1a9:	74 36                	je     f011c1e1 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c1ab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c1af:	74 30                	je     f011c1e1 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c1b1:	83 ec 04             	sub    $0x4,%esp
f011c1b4:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c1ba:	ff 75 c8             	pushl  -0x38(%ebp)
f011c1bd:	68 d7 f3 12 f0       	push   $0xf012f3d7
f011c1c2:	e8 c4 4d fe ff       	call   f0100f8b <cprintf>
f011c1c7:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c1ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1d1:	83 ec 0c             	sub    $0xc,%esp
f011c1d4:	68 f4 f3 12 f0       	push   $0xf012f3f4
f011c1d9:	e8 ad 4d fe ff       	call   f0100f8b <cprintf>
f011c1de:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c1e1:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c1e8:	b8 90 84 b0 00       	mov    $0xb08490,%eax
f011c1ed:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c1f0:	72 9c                	jb     f011c18e <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c1f2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c1f6:	74 04                	je     f011c1fc <test_kheap_virt_addr+0xd03>
f011c1f8:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c1fc:	83 ec 08             	sub    $0x8,%esp
f011c1ff:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c202:	68 18 f4 12 f0       	push   $0xf012f418
f011c207:	e8 7f 4d fe ff       	call   f0100f8b <cprintf>
f011c20c:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c20f:	b8 01 00 00 00       	mov    $0x1,%eax
f011c214:	89 f4                	mov    %esi,%esp

}
f011c216:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c219:	5b                   	pop    %ebx
f011c21a:	5e                   	pop    %esi
f011c21b:	5f                   	pop    %edi
f011c21c:	5d                   	pop    %ebp
f011c21d:	c3                   	ret    

f011c21e <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c21e:	55                   	push   %ebp
f011c21f:	89 e5                	mov    %esp,%ebp
f011c221:	57                   	push   %edi
f011c222:	56                   	push   %esi
f011c223:	53                   	push   %ebx
f011c224:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c22a:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c230:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c235:	b8 00 00 00 00       	mov    $0x0,%eax
f011c23a:	89 d7                	mov    %edx,%edi
f011c23c:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c23e:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c245:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c24c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c253:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c258:	0f b6 c0             	movzbl %al,%eax
f011c25b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c25e:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c265:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c268:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c26b:	39 c2                	cmp    %eax,%edx
f011c26d:	73 02                	jae    f011c271 <test_ksbrk+0x53>
f011c26f:	89 c2                	mov    %eax,%edx
f011c271:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c276:	0f b6 c0             	movzbl %al,%eax
f011c279:	c1 e0 04             	shl    $0x4,%eax
f011c27c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c27f:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c286:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c289:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c28c:	39 c8                	cmp    %ecx,%eax
f011c28e:	73 02                	jae    f011c292 <test_ksbrk+0x74>
f011c290:	89 c8                	mov    %ecx,%eax
f011c292:	01 d0                	add    %edx,%eax
f011c294:	83 c0 10             	add    $0x10,%eax
f011c297:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c29c:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c29f:	83 ec 0c             	sub    $0xc,%esp
f011c2a2:	68 4c f4 12 f0       	push   $0xf012f44c
f011c2a7:	e8 df 4c fe ff       	call   f0100f8b <cprintf>
f011c2ac:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c2af:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c2b6:	e8 0b 20 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c2bb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c2be:	e8 e2 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c2c3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c2c6:	83 ec 10             	sub    $0x10,%esp
f011c2c9:	89 e0                	mov    %esp,%eax
f011c2cb:	89 c2                	mov    %eax,%edx
f011c2cd:	bb f0 d3 6b f0       	mov    $0xf06bd3f0,%ebx
f011c2d2:	b8 04 00 00 00       	mov    $0x4,%eax
f011c2d7:	89 d7                	mov    %edx,%edi
f011c2d9:	89 de                	mov    %ebx,%esi
f011c2db:	89 c1                	mov    %eax,%ecx
f011c2dd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c2df:	e8 53 3e 00 00       	call   f0120137 <print_blocks_list>
f011c2e4:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c2e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c2ea:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c2ed:	29 c2                	sub    %eax,%edx
f011c2ef:	89 d0                	mov    %edx,%eax
f011c2f1:	83 ec 0c             	sub    $0xc,%esp
f011c2f4:	50                   	push   %eax
f011c2f5:	e8 0a cf fe ff       	call   f0109204 <kmalloc>
f011c2fa:	83 c4 10             	add    $0x10,%esp
f011c2fd:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c303:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c306:	89 c2                	mov    %eax,%edx
f011c308:	c1 ea 1f             	shr    $0x1f,%edx
f011c30b:	01 d0                	add    %edx,%eax
f011c30d:	d1 f8                	sar    %eax
f011c30f:	89 c2                	mov    %eax,%edx
f011c311:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c314:	01 d0                	add    %edx,%eax
f011c316:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c319:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c31f:	6a 01                	push   $0x1
f011c321:	ff 75 b8             	pushl  -0x48(%ebp)
f011c324:	ff 75 ac             	pushl  -0x54(%ebp)
f011c327:	50                   	push   %eax
f011c328:	e8 c8 43 ff ff       	call   f01106f5 <check_block>
f011c32d:	83 c4 10             	add    $0x10,%esp
f011c330:	85 c0                	test   %eax,%eax
f011c332:	75 17                	jne    f011c34b <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c334:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c33b:	83 ec 0c             	sub    $0xc,%esp
f011c33e:	68 9d f4 12 f0       	push   $0xf012f49d
f011c343:	e8 43 4c fe ff       	call   f0100f8b <cprintf>
f011c348:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c34b:	e8 76 1f ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c350:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c353:	74 17                	je     f011c36c <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c355:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c35c:	83 ec 0c             	sub    $0xc,%esp
f011c35f:	68 b4 f4 12 f0       	push   $0xf012f4b4
f011c364:	e8 22 4c fe ff       	call   f0100f8b <cprintf>
f011c369:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c36c:	e8 34 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c371:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c374:	74 17                	je     f011c38d <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c376:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c37d:	83 ec 0c             	sub    $0xc,%esp
f011c380:	68 d4 f4 12 f0       	push   $0xf012f4d4
f011c385:	e8 01 4c fe ff       	call   f0100f8b <cprintf>
f011c38a:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011c38d:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c392:	0f b6 c0             	movzbl %al,%eax
f011c395:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011c398:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011c39f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011c3a2:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011c3a5:	39 c2                	cmp    %eax,%edx
f011c3a7:	73 02                	jae    f011c3ab <test_ksbrk+0x18d>
f011c3a9:	89 c2                	mov    %eax,%edx
f011c3ab:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c3b0:	0f b6 c0             	movzbl %al,%eax
f011c3b3:	c1 e0 04             	shl    $0x4,%eax
f011c3b6:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011c3b9:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011c3c0:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011c3c3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c3c6:	39 c8                	cmp    %ecx,%eax
f011c3c8:	73 02                	jae    f011c3cc <test_ksbrk+0x1ae>
f011c3ca:	89 c8                	mov    %ecx,%eax
f011c3cc:	01 d0                	add    %edx,%eax
f011c3ce:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011c3d3:	29 c2                	sub    %eax,%edx
f011c3d5:	89 d0                	mov    %edx,%eax
f011c3d7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c3da:	e8 e7 1e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c3df:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c3e2:	e8 be 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3e7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c3ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c3ed:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c3f0:	29 c2                	sub    %eax,%edx
f011c3f2:	89 d0                	mov    %edx,%eax
f011c3f4:	83 ec 0c             	sub    $0xc,%esp
f011c3f7:	50                   	push   %eax
f011c3f8:	e8 07 ce fe ff       	call   f0109204 <kmalloc>
f011c3fd:	83 c4 10             	add    $0x10,%esp
f011c400:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011c406:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c409:	89 c2                	mov    %eax,%edx
f011c40b:	c1 ea 1f             	shr    $0x1f,%edx
f011c40e:	01 d0                	add    %edx,%eax
f011c410:	d1 f8                	sar    %eax
f011c412:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011c418:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c41b:	01 d0                	add    %edx,%eax
f011c41d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c420:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c426:	6a 01                	push   $0x1
f011c428:	ff 75 b8             	pushl  -0x48(%ebp)
f011c42b:	ff 75 ac             	pushl  -0x54(%ebp)
f011c42e:	50                   	push   %eax
f011c42f:	e8 c1 42 ff ff       	call   f01106f5 <check_block>
f011c434:	83 c4 10             	add    $0x10,%esp
f011c437:	85 c0                	test   %eax,%eax
f011c439:	75 17                	jne    f011c452 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011c43b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c442:	83 ec 0c             	sub    $0xc,%esp
f011c445:	68 42 f5 12 f0       	push   $0xf012f542
f011c44a:	e8 3c 4b fe ff       	call   f0100f8b <cprintf>
f011c44f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c452:	e8 6f 1e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c457:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c45a:	74 17                	je     f011c473 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011c45c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c463:	83 ec 0c             	sub    $0xc,%esp
f011c466:	68 5c f5 12 f0       	push   $0xf012f55c
f011c46b:	e8 1b 4b fe ff       	call   f0100f8b <cprintf>
f011c470:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c473:	e8 2d 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c478:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c47b:	74 17                	je     f011c494 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c47d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c484:	83 ec 0c             	sub    $0xc,%esp
f011c487:	68 7c f5 12 f0       	push   $0xf012f57c
f011c48c:	e8 fa 4a fe ff       	call   f0100f8b <cprintf>
f011c491:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011c494:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c49b:	e8 26 1e ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c4a0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c4a3:	e8 fd 83 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c4a8:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c4ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4ae:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c4b1:	29 c2                	sub    %eax,%edx
f011c4b3:	89 d0                	mov    %edx,%eax
f011c4b5:	83 ec 0c             	sub    $0xc,%esp
f011c4b8:	50                   	push   %eax
f011c4b9:	e8 46 cd fe ff       	call   f0109204 <kmalloc>
f011c4be:	83 c4 10             	add    $0x10,%esp
f011c4c1:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c4c7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4ca:	89 c2                	mov    %eax,%edx
f011c4cc:	c1 ea 1f             	shr    $0x1f,%edx
f011c4cf:	01 d0                	add    %edx,%eax
f011c4d1:	d1 f8                	sar    %eax
f011c4d3:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011c4d8:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c4db:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c4e1:	6a 01                	push   $0x1
f011c4e3:	ff 75 b8             	pushl  -0x48(%ebp)
f011c4e6:	ff 75 ac             	pushl  -0x54(%ebp)
f011c4e9:	50                   	push   %eax
f011c4ea:	e8 06 42 ff ff       	call   f01106f5 <check_block>
f011c4ef:	83 c4 10             	add    $0x10,%esp
f011c4f2:	85 c0                	test   %eax,%eax
f011c4f4:	75 17                	jne    f011c50d <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011c4f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4fd:	83 ec 0c             	sub    $0xc,%esp
f011c500:	68 ea f5 12 f0       	push   $0xf012f5ea
f011c505:	e8 81 4a fe ff       	call   f0100f8b <cprintf>
f011c50a:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c50d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c510:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011c513:	b8 00 10 00 00       	mov    $0x1000,%eax
f011c518:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011c51b:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c51e:	6a 00                	push   $0x0
f011c520:	ff 75 98             	pushl  -0x68(%ebp)
f011c523:	ff 75 ac             	pushl  -0x54(%ebp)
f011c526:	ff 75 ac             	pushl  -0x54(%ebp)
f011c529:	e8 c7 41 ff ff       	call   f01106f5 <check_block>
f011c52e:	83 c4 10             	add    $0x10,%esp
f011c531:	85 c0                	test   %eax,%eax
f011c533:	75 17                	jne    f011c54c <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011c535:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c53c:	83 ec 0c             	sub    $0xc,%esp
f011c53f:	68 01 f6 12 f0       	push   $0xf012f601
f011c544:	e8 42 4a fe ff       	call   f0100f8b <cprintf>
f011c549:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011c54c:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c553:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c556:	8b 00                	mov    (%eax),%eax
f011c558:	83 f8 01             	cmp    $0x1,%eax
f011c55b:	74 17                	je     f011c574 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011c55d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c564:	83 ec 0c             	sub    $0xc,%esp
f011c567:	68 18 f6 12 f0       	push   $0xf012f618
f011c56c:	e8 1a 4a fe ff       	call   f0100f8b <cprintf>
f011c571:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c574:	83 ec 0c             	sub    $0xc,%esp
f011c577:	6a 00                	push   $0x0
f011c579:	e8 53 cb fe ff       	call   f01090d1 <sbrk>
f011c57e:	83 c4 10             	add    $0x10,%esp
f011c581:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011c584:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c58b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c58e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c591:	74 1d                	je     f011c5b0 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c593:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c59a:	83 ec 04             	sub    $0x4,%esp
f011c59d:	ff 75 90             	pushl  -0x70(%ebp)
f011c5a0:	ff 75 8c             	pushl  -0x74(%ebp)
f011c5a3:	68 44 f6 12 f0       	push   $0xf012f644
f011c5a8:	e8 de 49 fe ff       	call   f0100f8b <cprintf>
f011c5ad:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c5b0:	e8 11 1d ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c5b5:	89 c2                	mov    %eax,%edx
f011c5b7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c5ba:	29 d0                	sub    %edx,%eax
f011c5bc:	83 f8 01             	cmp    $0x1,%eax
f011c5bf:	74 17                	je     f011c5d8 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011c5c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5c8:	83 ec 0c             	sub    $0xc,%esp
f011c5cb:	68 78 f6 12 f0       	push   $0xf012f678
f011c5d0:	e8 b6 49 fe ff       	call   f0100f8b <cprintf>
f011c5d5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c5d8:	e8 c8 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c5dd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c5e0:	74 17                	je     f011c5f9 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c5e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5e9:	83 ec 0c             	sub    $0xc,%esp
f011c5ec:	68 98 f6 12 f0       	push   $0xf012f698
f011c5f1:	e8 95 49 fe ff       	call   f0100f8b <cprintf>
f011c5f6:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011c5f9:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c600:	e8 c1 1c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c605:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c608:	e8 98 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c60d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011c610:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c613:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c616:	29 c2                	sub    %eax,%edx
f011c618:	89 d0                	mov    %edx,%eax
f011c61a:	83 ec 0c             	sub    $0xc,%esp
f011c61d:	50                   	push   %eax
f011c61e:	e8 e1 cb fe ff       	call   f0109204 <kmalloc>
f011c623:	83 c4 10             	add    $0x10,%esp
f011c626:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011c62c:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011c633:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011c639:	6a 01                	push   $0x1
f011c63b:	ff 75 b8             	pushl  -0x48(%ebp)
f011c63e:	ff 75 ac             	pushl  -0x54(%ebp)
f011c641:	50                   	push   %eax
f011c642:	e8 ae 40 ff ff       	call   f01106f5 <check_block>
f011c647:	83 c4 10             	add    $0x10,%esp
f011c64a:	85 c0                	test   %eax,%eax
f011c64c:	75 17                	jne    f011c665 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011c64e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c655:	83 ec 0c             	sub    $0xc,%esp
f011c658:	68 07 f7 12 f0       	push   $0xf012f707
f011c65d:	e8 29 49 fe ff       	call   f0100f8b <cprintf>
f011c662:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c665:	e8 5c 1c ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c66a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c66d:	74 17                	je     f011c686 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011c66f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c676:	83 ec 0c             	sub    $0xc,%esp
f011c679:	68 20 f7 12 f0       	push   $0xf012f720
f011c67e:	e8 08 49 fe ff       	call   f0100f8b <cprintf>
f011c683:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c686:	e8 1a 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c68b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c68e:	74 17                	je     f011c6a7 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c690:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c697:	83 ec 0c             	sub    $0xc,%esp
f011c69a:	68 40 f7 12 f0       	push   $0xf012f740
f011c69f:	e8 e7 48 fe ff       	call   f0100f8b <cprintf>
f011c6a4:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011c6a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6ab:	74 04                	je     f011c6b1 <test_ksbrk+0x493>
		eval += 25;
f011c6ad:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011c6b1:	83 ec 0c             	sub    $0xc,%esp
f011c6b4:	68 b0 f7 12 f0       	push   $0xf012f7b0
f011c6b9:	e8 cd 48 fe ff       	call   f0100f8b <cprintf>
f011c6be:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011c6c1:	83 ec 0c             	sub    $0xc,%esp
f011c6c4:	6a 00                	push   $0x0
f011c6c6:	e8 06 ca fe ff       	call   f01090d1 <sbrk>
f011c6cb:	83 c4 10             	add    $0x10,%esp
f011c6ce:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011c6d1:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c6d8:	e8 e9 1b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c6dd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c6e0:	e8 c0 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c6e5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c6e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c6eb:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c6ee:	29 c2                	sub    %eax,%edx
f011c6f0:	89 d0                	mov    %edx,%eax
f011c6f2:	83 ec 0c             	sub    $0xc,%esp
f011c6f5:	50                   	push   %eax
f011c6f6:	e8 09 cb fe ff       	call   f0109204 <kmalloc>
f011c6fb:	83 c4 10             	add    $0x10,%esp
f011c6fe:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c704:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c707:	89 c2                	mov    %eax,%edx
f011c709:	c1 ea 1f             	shr    $0x1f,%edx
f011c70c:	01 d0                	add    %edx,%eax
f011c70e:	d1 f8                	sar    %eax
f011c710:	89 c2                	mov    %eax,%edx
f011c712:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c715:	01 d0                	add    %edx,%eax
f011c717:	83 e8 04             	sub    $0x4,%eax
f011c71a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c71d:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c723:	6a 01                	push   $0x1
f011c725:	ff 75 b8             	pushl  -0x48(%ebp)
f011c728:	ff 75 ac             	pushl  -0x54(%ebp)
f011c72b:	50                   	push   %eax
f011c72c:	e8 c4 3f ff ff       	call   f01106f5 <check_block>
f011c731:	83 c4 10             	add    $0x10,%esp
f011c734:	85 c0                	test   %eax,%eax
f011c736:	75 17                	jne    f011c74f <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011c738:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c73f:	83 ec 0c             	sub    $0xc,%esp
f011c742:	68 13 f8 12 f0       	push   $0xf012f813
f011c747:	e8 3f 48 fe ff       	call   f0100f8b <cprintf>
f011c74c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c74f:	e8 72 1b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c754:	89 c2                	mov    %eax,%edx
f011c756:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c759:	29 d0                	sub    %edx,%eax
f011c75b:	83 f8 01             	cmp    $0x1,%eax
f011c75e:	74 17                	je     f011c777 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011c760:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c767:	83 ec 0c             	sub    $0xc,%esp
f011c76a:	68 2c f8 12 f0       	push   $0xf012f82c
f011c76f:	e8 17 48 fe ff       	call   f0100f8b <cprintf>
f011c774:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c777:	e8 29 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c77c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c77f:	74 17                	je     f011c798 <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c781:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c788:	83 ec 0c             	sub    $0xc,%esp
f011c78b:	68 4c f8 12 f0       	push   $0xf012f84c
f011c790:	e8 f6 47 fe ff       	call   f0100f8b <cprintf>
f011c795:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011c798:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c79f:	e8 22 1b ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c7a4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c7a7:	e8 f9 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c7ac:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c7af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c7b2:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c7b5:	29 c2                	sub    %eax,%edx
f011c7b7:	89 d0                	mov    %edx,%eax
f011c7b9:	83 ec 0c             	sub    $0xc,%esp
f011c7bc:	50                   	push   %eax
f011c7bd:	e8 42 ca fe ff       	call   f0109204 <kmalloc>
f011c7c2:	83 c4 10             	add    $0x10,%esp
f011c7c5:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011c7cb:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c7d2:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c7d8:	6a 01                	push   $0x1
f011c7da:	ff 75 b8             	pushl  -0x48(%ebp)
f011c7dd:	ff 75 ac             	pushl  -0x54(%ebp)
f011c7e0:	50                   	push   %eax
f011c7e1:	e8 0f 3f ff ff       	call   f01106f5 <check_block>
f011c7e6:	83 c4 10             	add    $0x10,%esp
f011c7e9:	85 c0                	test   %eax,%eax
f011c7eb:	75 17                	jne    f011c804 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011c7ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7f4:	83 ec 0c             	sub    $0xc,%esp
f011c7f7:	68 ba f8 12 f0       	push   $0xf012f8ba
f011c7fc:	e8 8a 47 fe ff       	call   f0100f8b <cprintf>
f011c801:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c804:	e8 bd 1a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c809:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c80c:	74 17                	je     f011c825 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011c80e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c815:	83 ec 0c             	sub    $0xc,%esp
f011c818:	68 d4 f8 12 f0       	push   $0xf012f8d4
f011c81d:	e8 69 47 fe ff       	call   f0100f8b <cprintf>
f011c822:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c825:	e8 7b 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c82a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c82d:	74 17                	je     f011c846 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c82f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c836:	83 ec 0c             	sub    $0xc,%esp
f011c839:	68 f4 f8 12 f0       	push   $0xf012f8f4
f011c83e:	e8 48 47 fe ff       	call   f0100f8b <cprintf>
f011c843:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011c846:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c84d:	e8 74 1a ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c852:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c855:	e8 4b 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c85a:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c85d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c860:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c863:	29 c2                	sub    %eax,%edx
f011c865:	89 d0                	mov    %edx,%eax
f011c867:	83 ec 0c             	sub    $0xc,%esp
f011c86a:	50                   	push   %eax
f011c86b:	e8 94 c9 fe ff       	call   f0109204 <kmalloc>
f011c870:	83 c4 10             	add    $0x10,%esp
f011c873:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011c879:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c880:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c886:	6a 01                	push   $0x1
f011c888:	ff 75 b8             	pushl  -0x48(%ebp)
f011c88b:	ff 75 ac             	pushl  -0x54(%ebp)
f011c88e:	50                   	push   %eax
f011c88f:	e8 61 3e ff ff       	call   f01106f5 <check_block>
f011c894:	83 c4 10             	add    $0x10,%esp
f011c897:	85 c0                	test   %eax,%eax
f011c899:	75 17                	jne    f011c8b2 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011c89b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8a2:	83 ec 0c             	sub    $0xc,%esp
f011c8a5:	68 62 f9 12 f0       	push   $0xf012f962
f011c8aa:	e8 dc 46 fe ff       	call   f0100f8b <cprintf>
f011c8af:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c8b2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c8b5:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011c8b8:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c8bf:	6a 00                	push   $0x0
f011c8c1:	ff 75 98             	pushl  -0x68(%ebp)
f011c8c4:	ff 75 ac             	pushl  -0x54(%ebp)
f011c8c7:	ff 75 ac             	pushl  -0x54(%ebp)
f011c8ca:	e8 26 3e ff ff       	call   f01106f5 <check_block>
f011c8cf:	83 c4 10             	add    $0x10,%esp
f011c8d2:	85 c0                	test   %eax,%eax
f011c8d4:	75 17                	jne    f011c8ed <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011c8d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8dd:	83 ec 0c             	sub    $0xc,%esp
f011c8e0:	68 79 f9 12 f0       	push   $0xf012f979
f011c8e5:	e8 a1 46 fe ff       	call   f0100f8b <cprintf>
f011c8ea:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011c8ed:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c8f0:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011c8f5:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c8f8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c8fb:	8b 00                	mov    (%eax),%eax
f011c8fd:	83 f8 01             	cmp    $0x1,%eax
f011c900:	74 17                	je     f011c919 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011c902:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c909:	83 ec 0c             	sub    $0xc,%esp
f011c90c:	68 90 f9 12 f0       	push   $0xf012f990
f011c911:	e8 75 46 fe ff       	call   f0100f8b <cprintf>
f011c916:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c919:	83 ec 0c             	sub    $0xc,%esp
f011c91c:	6a 00                	push   $0x0
f011c91e:	e8 ae c7 fe ff       	call   f01090d1 <sbrk>
f011c923:	83 c4 10             	add    $0x10,%esp
f011c926:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011c929:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c92c:	05 00 20 00 00       	add    $0x2000,%eax
f011c931:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c934:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c937:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c93a:	74 1d                	je     f011c959 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c93c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c943:	83 ec 04             	sub    $0x4,%esp
f011c946:	ff 75 90             	pushl  -0x70(%ebp)
f011c949:	ff 75 8c             	pushl  -0x74(%ebp)
f011c94c:	68 bc f9 12 f0       	push   $0xf012f9bc
f011c951:	e8 35 46 fe ff       	call   f0100f8b <cprintf>
f011c956:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c959:	e8 68 19 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011c95e:	89 c2                	mov    %eax,%edx
f011c960:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c963:	29 d0                	sub    %edx,%eax
f011c965:	83 f8 01             	cmp    $0x1,%eax
f011c968:	74 17                	je     f011c981 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011c96a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c971:	83 ec 0c             	sub    $0xc,%esp
f011c974:	68 f0 f9 12 f0       	push   $0xf012f9f0
f011c979:	e8 0d 46 fe ff       	call   f0100f8b <cprintf>
f011c97e:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c981:	e8 1f 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c986:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c989:	74 17                	je     f011c9a2 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c98b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c992:	83 ec 0c             	sub    $0xc,%esp
f011c995:	68 10 fa 12 f0       	push   $0xf012fa10
f011c99a:	e8 ec 45 fe ff       	call   f0100f8b <cprintf>
f011c99f:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011c9a2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c9a6:	74 04                	je     f011c9ac <test_ksbrk+0x78e>
		eval += 25;
f011c9a8:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011c9ac:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011c9b3:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011c9b9:	bb 4c fd 12 f0       	mov    $0xf012fd4c,%ebx
f011c9be:	ba 05 00 00 00       	mov    $0x5,%edx
f011c9c3:	89 c7                	mov    %eax,%edi
f011c9c5:	89 de                	mov    %ebx,%esi
f011c9c7:	89 d1                	mov    %edx,%ecx
f011c9c9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011c9cb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011c9d1:	bb 60 fd 12 f0       	mov    $0xf012fd60,%ebx
f011c9d6:	ba 05 00 00 00       	mov    $0x5,%edx
f011c9db:	89 c7                	mov    %eax,%edi
f011c9dd:	89 de                	mov    %ebx,%esi
f011c9df:	89 d1                	mov    %edx,%ecx
f011c9e1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011c9e3:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011c9e9:	bb 74 fd 12 f0       	mov    $0xf012fd74,%ebx
f011c9ee:	ba 05 00 00 00       	mov    $0x5,%edx
f011c9f3:	89 c7                	mov    %eax,%edi
f011c9f5:	89 de                	mov    %ebx,%esi
f011c9f7:	89 d1                	mov    %edx,%ecx
f011c9f9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011c9fb:	83 ec 04             	sub    $0x4,%esp
f011c9fe:	68 00 00 00 f8       	push   $0xf8000000
f011ca03:	68 00 10 00 00       	push   $0x1000
f011ca08:	68 00 00 00 f6       	push   $0xf6000000
f011ca0d:	e8 a8 c5 fe ff       	call   f0108fba <initialize_kheap_dynamic_allocator>
f011ca12:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011ca15:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011ca1c:	eb 1b                	jmp    f011ca39 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011ca1e:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ca23:	83 ec 08             	sub    $0x8,%esp
f011ca26:	ff 75 dc             	pushl  -0x24(%ebp)
f011ca29:	50                   	push   %eax
f011ca2a:	e8 b0 bd fe ff       	call   f01087df <unmap_frame>
f011ca2f:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011ca32:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011ca39:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011ca40:	76 dc                	jbe    f011ca1e <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011ca42:	83 ec 0c             	sub    $0xc,%esp
f011ca45:	68 80 fa 12 f0       	push   $0xf012fa80
f011ca4a:	e8 3c 45 fe ff       	call   f0100f8b <cprintf>
f011ca4f:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011ca52:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ca59:	e9 21 01 00 00       	jmp    f011cb7f <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011ca5e:	e8 63 18 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ca63:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011ca66:	e8 3a 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca6b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011ca6e:	83 ec 0c             	sub    $0xc,%esp
f011ca71:	6a 00                	push   $0x0
f011ca73:	e8 59 c6 fe ff       	call   f01090d1 <sbrk>
f011ca78:	83 c4 10             	add    $0x10,%esp
f011ca7b:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011ca7e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ca81:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011ca88:	83 ec 0c             	sub    $0xc,%esp
f011ca8b:	50                   	push   %eax
f011ca8c:	e8 40 c6 fe ff       	call   f01090d1 <sbrk>
f011ca91:	83 c4 10             	add    $0x10,%esp
f011ca94:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011ca97:	83 ec 0c             	sub    $0xc,%esp
f011ca9a:	6a 00                	push   $0x0
f011ca9c:	e8 30 c6 fe ff       	call   f01090d1 <sbrk>
f011caa1:	83 c4 10             	add    $0x10,%esp
f011caa4:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011caa7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011caae:	e8 f2 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cab3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cab6:	74 1a                	je     f011cad2 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011cab8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011cabf:	83 ec 08             	sub    $0x8,%esp
f011cac2:	ff 75 d8             	pushl  -0x28(%ebp)
f011cac5:	68 c4 fa 12 f0       	push   $0xf012fac4
f011caca:	e8 bc 44 fe ff       	call   f0100f8b <cprintf>
f011cacf:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011cad2:	e8 ef 17 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011cad7:	89 c2                	mov    %eax,%edx
f011cad9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cadc:	29 d0                	sub    %edx,%eax
f011cade:	89 c2                	mov    %eax,%edx
f011cae0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cae3:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011caea:	39 c2                	cmp    %eax,%edx
f011caec:	74 1a                	je     f011cb08 <test_ksbrk+0x8ea>
			{
				correct = 0;
f011caee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011caf5:	83 ec 08             	sub    $0x8,%esp
f011caf8:	ff 75 d8             	pushl  -0x28(%ebp)
f011cafb:	68 34 fb 12 f0       	push   $0xf012fb34
f011cb00:	e8 86 44 fe ff       	call   f0100f8b <cprintf>
f011cb05:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011cb08:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb0b:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011cb12:	8b 45 80             	mov    -0x80(%ebp),%eax
f011cb15:	39 c2                	cmp    %eax,%edx
f011cb17:	74 25                	je     f011cb3e <test_ksbrk+0x920>
			{
				correct = 0;
f011cb19:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011cb20:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb23:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011cb2a:	ff 75 80             	pushl  -0x80(%ebp)
f011cb2d:	50                   	push   %eax
f011cb2e:	ff 75 d8             	pushl  -0x28(%ebp)
f011cb31:	68 54 fb 12 f0       	push   $0xf012fb54
f011cb36:	e8 50 44 fe ff       	call   f0100f8b <cprintf>
f011cb3b:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011cb3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb41:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb48:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011cb4b:	74 25                	je     f011cb72 <test_ksbrk+0x954>
			{
				correct = 0;
f011cb4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011cb54:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb57:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb5e:	ff 75 90             	pushl  -0x70(%ebp)
f011cb61:	50                   	push   %eax
f011cb62:	ff 75 d8             	pushl  -0x28(%ebp)
f011cb65:	68 8c fb 12 f0       	push   $0xf012fb8c
f011cb6a:	e8 1c 44 fe ff       	call   f0100f8b <cprintf>
f011cb6f:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011cb72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb76:	74 04                	je     f011cb7c <test_ksbrk+0x95e>
				eval += 10;
f011cb78:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011cb7c:	ff 45 d8             	incl   -0x28(%ebp)
f011cb7f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011cb82:	8d 50 ff             	lea    -0x1(%eax),%edx
f011cb85:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb88:	39 c2                	cmp    %eax,%edx
f011cb8a:	0f 87 ce fe ff ff    	ja     f011ca5e <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011cb90:	83 ec 0c             	sub    $0xc,%esp
f011cb93:	68 c0 fb 12 f0       	push   $0xf012fbc0
f011cb98:	e8 ee 43 fe ff       	call   f0100f8b <cprintf>
f011cb9d:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011cba0:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011cba3:	48                   	dec    %eax
f011cba4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011cba7:	e9 18 01 00 00       	jmp    f011ccc4 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011cbac:	e8 15 17 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011cbb1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011cbb4:	e8 ec 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cbb9:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011cbbc:	83 ec 0c             	sub    $0xc,%esp
f011cbbf:	6a 00                	push   $0x0
f011cbc1:	e8 0b c5 fe ff       	call   f01090d1 <sbrk>
f011cbc6:	83 c4 10             	add    $0x10,%esp
f011cbc9:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011cbcc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cbcf:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011cbd6:	83 ec 0c             	sub    $0xc,%esp
f011cbd9:	50                   	push   %eax
f011cbda:	e8 f2 c4 fe ff       	call   f01090d1 <sbrk>
f011cbdf:	83 c4 10             	add    $0x10,%esp
f011cbe2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011cbe8:	83 ec 0c             	sub    $0xc,%esp
f011cbeb:	6a 00                	push   $0x0
f011cbed:	e8 df c4 fe ff       	call   f01090d1 <sbrk>
f011cbf2:	83 c4 10             	add    $0x10,%esp
f011cbf5:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011cbf8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cbff:	e8 a1 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc04:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cc07:	74 1a                	je     f011cc23 <test_ksbrk+0xa05>
			{
				correct = 0;
f011cc09:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011cc10:	83 ec 08             	sub    $0x8,%esp
f011cc13:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc16:	68 10 fc 12 f0       	push   $0xf012fc10
f011cc1b:	e8 6b 43 fe ff       	call   f0100f8b <cprintf>
f011cc20:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cc23:	e8 9e 16 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011cc28:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cc2b:	74 1a                	je     f011cc47 <test_ksbrk+0xa29>
			{
				correct = 0;
f011cc2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011cc34:	83 ec 08             	sub    $0x8,%esp
f011cc37:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc3a:	68 80 fc 12 f0       	push   $0xf012fc80
f011cc3f:	e8 47 43 fe ff       	call   f0100f8b <cprintf>
f011cc44:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011cc47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc4a:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011cc51:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cc57:	39 c2                	cmp    %eax,%edx
f011cc59:	74 28                	je     f011cc83 <test_ksbrk+0xa65>
			{
				correct = 0;
f011cc5b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011cc62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc65:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011cc6c:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011cc72:	50                   	push   %eax
f011cc73:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc76:	68 a0 fc 12 f0       	push   $0xf012fca0
f011cc7b:	e8 0b 43 fe ff       	call   f0100f8b <cprintf>
f011cc80:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011cc83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc86:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cc8d:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011cc90:	74 25                	je     f011ccb7 <test_ksbrk+0xa99>
			{
				correct = 0;
f011cc92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011cc99:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc9c:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cca3:	ff 75 90             	pushl  -0x70(%ebp)
f011cca6:	50                   	push   %eax
f011cca7:	ff 75 d4             	pushl  -0x2c(%ebp)
f011ccaa:	68 d8 fc 12 f0       	push   $0xf012fcd8
f011ccaf:	e8 d7 42 fe ff       	call   f0100f8b <cprintf>
f011ccb4:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011ccb7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ccbb:	74 04                	je     f011ccc1 <test_ksbrk+0xaa3>
				eval += 10;
f011ccbd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011ccc1:	ff 45 d4             	incl   -0x2c(%ebp)
f011ccc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ccc7:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ccca:	0f 82 dc fe ff ff    	jb     f011cbac <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011ccd0:	83 ec 08             	sub    $0x8,%esp
f011ccd3:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ccd6:	68 0c fd 12 f0       	push   $0xf012fd0c
f011ccdb:	e8 ab 42 fe ff       	call   f0100f8b <cprintf>
f011cce0:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011cce3:	83 ec 0c             	sub    $0xc,%esp
f011cce6:	68 36 fd 12 f0       	push   $0xf012fd36
f011cceb:	e8 9b 42 fe ff       	call   f0100f8b <cprintf>
f011ccf0:	83 c4 10             	add    $0x10,%esp
	return 0;
f011ccf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ccf8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ccfb:	5b                   	pop    %ebx
f011ccfc:	5e                   	pop    %esi
f011ccfd:	5f                   	pop    %edi
f011ccfe:	5d                   	pop    %ebp
f011ccff:	c3                   	ret    

f011cd00 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011cd00:	55                   	push   %ebp
f011cd01:	89 e5                	mov    %esp,%ebp
f011cd03:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd06:	83 ec 04             	sub    $0x4,%esp
f011cd09:	68 88 fd 12 f0       	push   $0xf012fd88
f011cd0e:	68 c3 08 00 00       	push   $0x8c3
f011cd13:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cd18:	e8 1c 36 fe ff       	call   f0100339 <_panic>

f011cd1d <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011cd1d:	55                   	push   %ebp
f011cd1e:	89 e5                	mov    %esp,%ebp
f011cd20:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd23:	83 ec 04             	sub    $0x4,%esp
f011cd26:	68 88 fd 12 f0       	push   $0xf012fd88
f011cd2b:	68 c8 08 00 00       	push   $0x8c8
f011cd30:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cd35:	e8 ff 35 fe ff       	call   f0100339 <_panic>

f011cd3a <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011cd3a:	55                   	push   %ebp
f011cd3b:	89 e5                	mov    %esp,%ebp
f011cd3d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd40:	83 ec 04             	sub    $0x4,%esp
f011cd43:	68 88 fd 12 f0       	push   $0xf012fd88
f011cd48:	68 cd 08 00 00       	push   $0x8cd
f011cd4d:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cd52:	e8 e2 35 fe ff       	call   f0100339 <_panic>

f011cd57 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011cd57:	55                   	push   %ebp
f011cd58:	89 e5                	mov    %esp,%ebp
f011cd5a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd5d:	83 ec 04             	sub    $0x4,%esp
f011cd60:	68 88 fd 12 f0       	push   $0xf012fd88
f011cd65:	68 d2 08 00 00       	push   $0x8d2
f011cd6a:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cd6f:	e8 c5 35 fe ff       	call   f0100339 <_panic>

f011cd74 <test_kfree>:
}

int test_kfree()
{
f011cd74:	55                   	push   %ebp
f011cd75:	89 e5                	mov    %esp,%ebp
f011cd77:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd7a:	83 ec 04             	sub    $0x4,%esp
f011cd7d:	68 88 fd 12 f0       	push   $0xf012fd88
f011cd82:	68 d7 08 00 00       	push   $0x8d7
f011cd87:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cd8c:	e8 a8 35 fe ff       	call   f0100339 <_panic>

f011cd91 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011cd91:	55                   	push   %ebp
f011cd92:	89 e5                	mov    %esp,%ebp
f011cd94:	57                   	push   %edi
f011cd95:	56                   	push   %esi
f011cd96:	53                   	push   %ebx
f011cd97:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011cd9d:	a0 dc ed 17 f0       	mov    0xf017eddc,%al
f011cda2:	84 c0                	test   %al,%al
f011cda4:	74 56                	je     f011cdfc <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011cda6:	c6 05 dc ed 17 f0 00 	movb   $0x0,0xf017eddc
		initFreeFrames = sys_calculate_free_frames() ;
f011cdad:	e8 14 15 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011cdb2:	a3 a8 81 b0 f0       	mov    %eax,0xf0b081a8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011cdb7:	e8 e9 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cdbc:	a3 a4 81 b0 f0       	mov    %eax,0xf0b081a4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011cdc1:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011cdc7:	bb ed fe 12 f0       	mov    $0xf012feed,%ebx
f011cdcc:	ba 11 00 00 00       	mov    $0x11,%edx
f011cdd1:	89 c7                	mov    %eax,%edi
f011cdd3:	89 de                	mov    %ebx,%esi
f011cdd5:	89 d1                	mov    %edx,%ecx
f011cdd7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011cdd9:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011cddf:	b9 53 00 00 00       	mov    $0x53,%ecx
f011cde4:	b0 00                	mov    $0x0,%al
f011cde6:	89 d7                	mov    %edx,%edi
f011cde8:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011cdea:	83 ec 0c             	sub    $0xc,%esp
f011cded:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011cdf3:	50                   	push   %eax
f011cdf4:	e8 02 51 fe ff       	call   f0101efb <execute_command>
f011cdf9:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011cdfc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011ce03:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011ce0a:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f011ce0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011ce12:	eb 2b                	jmp    f011ce3f <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011ce14:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ce17:	83 c0 20             	add    $0x20,%eax
f011ce1a:	83 ec 08             	sub    $0x8,%esp
f011ce1d:	68 98 fd 12 f0       	push   $0xf012fd98
f011ce22:	50                   	push   %eax
f011ce23:	e8 ea 28 00 00       	call   f011f712 <strcmp>
f011ce28:	83 c4 10             	add    $0x10,%esp
f011ce2b:	85 c0                	test   %eax,%eax
f011ce2d:	75 08                	jne    f011ce37 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011ce2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ce32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011ce35:	eb 2f                	jmp    f011ce66 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011ce37:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011ce3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011ce3f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ce43:	74 08                	je     f011ce4d <test_three_creation_functions+0xbc>
f011ce45:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ce48:	8b 40 08             	mov    0x8(%eax),%eax
f011ce4b:	eb 05                	jmp    f011ce52 <test_three_creation_functions+0xc1>
f011ce4d:	b8 00 00 00 00       	mov    $0x0,%eax
f011ce52:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f011ce57:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011ce5c:	85 c0                	test   %eax,%eax
f011ce5e:	75 b4                	jne    f011ce14 <test_three_creation_functions+0x83>
f011ce60:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ce64:	75 ae                	jne    f011ce14 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011ce66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ce69:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011ce6f:	85 c0                	test   %eax,%eax
f011ce71:	74 17                	je     f011ce8a <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011ce73:	83 ec 04             	sub    $0x4,%esp
f011ce76:	68 a0 fd 12 f0       	push   $0xf012fda0
f011ce7b:	68 f8 08 00 00       	push   $0x8f8
f011ce80:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011ce85:	e8 af 34 fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011ce8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ce8d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ce93:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011ce96:	e8 2b 14 ff ff       	call   f010e2c6 <sys_calculate_free_frames>
f011ce9b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011ce9e:	e8 02 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cea3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011cea6:	a1 a4 81 b0 f0       	mov    0xf0b081a4,%eax
f011ceab:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011ceae:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011ceb1:	74 17                	je     f011ceca <test_three_creation_functions+0x139>
f011ceb3:	83 ec 04             	sub    $0x4,%esp
f011ceb6:	68 e0 c7 12 f0       	push   $0xf012c7e0
f011cebb:	68 02 09 00 00       	push   $0x902
f011cec0:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cec5:	e8 6f 34 fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011ceca:	a1 a8 81 b0 f0       	mov    0xf0b081a8,%eax
f011cecf:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011ced2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ced5:	83 c2 15             	add    $0x15,%edx
f011ced8:	39 d0                	cmp    %edx,%eax
f011ceda:	74 17                	je     f011cef3 <test_three_creation_functions+0x162>
f011cedc:	83 ec 04             	sub    $0x4,%esp
f011cedf:	68 f0 fd 12 f0       	push   $0xf012fdf0
f011cee4:	68 04 09 00 00       	push   $0x904
f011cee9:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011ceee:	e8 46 34 fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011cef3:	83 ec 0c             	sub    $0xc,%esp
f011cef6:	68 00 10 00 00       	push   $0x1000
f011cefb:	e8 04 c3 fe ff       	call   f0109204 <kmalloc>
f011cf00:	83 c4 10             	add    $0x10,%esp
f011cf03:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011cf06:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf09:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011cf0e:	74 17                	je     f011cf27 <test_three_creation_functions+0x196>
f011cf10:	83 ec 04             	sub    $0x4,%esp
f011cf13:	68 30 fe 12 f0       	push   $0xf012fe30
f011cf18:	68 08 09 00 00       	push   $0x908
f011cf1d:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cf22:	e8 12 34 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011cf27:	83 ec 0c             	sub    $0xc,%esp
f011cf2a:	68 a0 fe 12 f0       	push   $0xf012fea0
f011cf2f:	e8 57 40 fe ff       	call   f0100f8b <cprintf>
f011cf34:	83 c4 10             	add    $0x10,%esp

	return 1;
f011cf37:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011cf3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cf3f:	5b                   	pop    %ebx
f011cf40:	5e                   	pop    %esi
f011cf41:	5f                   	pop    %edi
f011cf42:	5d                   	pop    %ebp
f011cf43:	c3                   	ret    

f011cf44 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011cf44:	55                   	push   %ebp
f011cf45:	89 e5                	mov    %esp,%ebp
f011cf47:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf4a:	83 ec 04             	sub    $0x4,%esp
f011cf4d:	68 88 fd 12 f0       	push   $0xf012fd88
f011cf52:	68 16 09 00 00       	push   $0x916
f011cf57:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cf5c:	e8 d8 33 fe ff       	call   f0100339 <_panic>

f011cf61 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011cf61:	55                   	push   %ebp
f011cf62:	89 e5                	mov    %esp,%ebp
f011cf64:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf67:	83 ec 04             	sub    $0x4,%esp
f011cf6a:	68 88 fd 12 f0       	push   $0xf012fd88
f011cf6f:	68 1e 09 00 00       	push   $0x91e
f011cf74:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cf79:	e8 bb 33 fe ff       	call   f0100339 <_panic>

f011cf7e <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011cf7e:	55                   	push   %ebp
f011cf7f:	89 e5                	mov    %esp,%ebp
f011cf81:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf84:	83 ec 04             	sub    $0x4,%esp
f011cf87:	68 88 fd 12 f0       	push   $0xf012fd88
f011cf8c:	68 25 09 00 00       	push   $0x925
f011cf91:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cf96:	e8 9e 33 fe ff       	call   f0100339 <_panic>

f011cf9b <test_kfreelast>:

}


int test_kfreelast()
{
f011cf9b:	55                   	push   %ebp
f011cf9c:	89 e5                	mov    %esp,%ebp
f011cf9e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cfa1:	83 ec 04             	sub    $0x4,%esp
f011cfa4:	68 88 fd 12 f0       	push   $0xf012fd88
f011cfa9:	68 2c 09 00 00       	push   $0x92c
f011cfae:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cfb3:	e8 81 33 fe ff       	call   f0100339 <_panic>

f011cfb8 <test_krealloc>:

}

int test_krealloc() {
f011cfb8:	55                   	push   %ebp
f011cfb9:	89 e5                	mov    %esp,%ebp
f011cfbb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cfbe:	83 ec 04             	sub    $0x4,%esp
f011cfc1:	68 88 fd 12 f0       	push   $0xf012fd88
f011cfc6:	68 31 09 00 00       	push   $0x931
f011cfcb:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cfd0:	e8 64 33 fe ff       	call   f0100339 <_panic>

f011cfd5 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011cfd5:	55                   	push   %ebp
f011cfd6:	89 e5                	mov    %esp,%ebp
f011cfd8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cfdb:	83 ec 04             	sub    $0x4,%esp
f011cfde:	68 88 fd 12 f0       	push   $0xf012fd88
f011cfe3:	68 36 09 00 00       	push   $0x936
f011cfe8:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011cfed:	e8 47 33 fe ff       	call   f0100339 <_panic>

f011cff2 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011cff2:	55                   	push   %ebp
f011cff3:	89 e5                	mov    %esp,%ebp
f011cff5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cff8:	83 ec 04             	sub    $0x4,%esp
f011cffb:	68 88 fd 12 f0       	push   $0xf012fd88
f011d000:	68 3c 09 00 00       	push   $0x93c
f011d005:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011d00a:	e8 2a 33 fe ff       	call   f0100339 <_panic>

f011d00f <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d00f:	55                   	push   %ebp
f011d010:	89 e5                	mov    %esp,%ebp
f011d012:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d015:	83 ec 04             	sub    $0x4,%esp
f011d018:	68 88 fd 12 f0       	push   $0xf012fd88
f011d01d:	68 41 09 00 00       	push   $0x941
f011d022:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011d027:	e8 0d 33 fe ff       	call   f0100339 <_panic>

f011d02c <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d02c:	55                   	push   %ebp
f011d02d:	89 e5                	mov    %esp,%ebp
f011d02f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d032:	83 ec 04             	sub    $0x4,%esp
f011d035:	68 88 fd 12 f0       	push   $0xf012fd88
f011d03a:	68 47 09 00 00       	push   $0x947
f011d03f:	68 c7 c7 12 f0       	push   $0xf012c7c7
f011d044:	e8 f0 32 fe ff       	call   f0100339 <_panic>

f011d049 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d049:	55                   	push   %ebp
f011d04a:	89 e5                	mov    %esp,%ebp
f011d04c:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d04f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d056:	e9 84 00 00 00       	jmp    f011d0df <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d05b:	83 ec 08             	sub    $0x8,%esp
f011d05e:	ff 75 f4             	pushl  -0xc(%ebp)
f011d061:	68 54 ff 12 f0       	push   $0xf012ff54
f011d066:	e8 20 3f fe ff       	call   f0100f8b <cprintf>
f011d06b:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d06e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d075:	eb 4c                	jmp    f011d0c3 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d077:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d07a:	89 d0                	mov    %edx,%eax
f011d07c:	c1 e0 02             	shl    $0x2,%eax
f011d07f:	01 d0                	add    %edx,%eax
f011d081:	c1 e0 03             	shl    $0x3,%eax
f011d084:	89 c2                	mov    %eax,%edx
f011d086:	8b 45 08             	mov    0x8(%ebp),%eax
f011d089:	01 c2                	add    %eax,%edx
f011d08b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d08e:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d091:	85 c0                	test   %eax,%eax
f011d093:	74 36                	je     f011d0cb <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d095:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d098:	89 d0                	mov    %edx,%eax
f011d09a:	c1 e0 02             	shl    $0x2,%eax
f011d09d:	01 d0                	add    %edx,%eax
f011d09f:	c1 e0 03             	shl    $0x3,%eax
f011d0a2:	89 c2                	mov    %eax,%edx
f011d0a4:	8b 45 08             	mov    0x8(%ebp),%eax
f011d0a7:	01 c2                	add    %eax,%edx
f011d0a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d0ac:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d0af:	83 ec 08             	sub    $0x8,%esp
f011d0b2:	50                   	push   %eax
f011d0b3:	68 5c ff 12 f0       	push   $0xf012ff5c
f011d0b8:	e8 ce 3e fe ff       	call   f0100f8b <cprintf>
f011d0bd:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d0c0:	ff 45 f0             	incl   -0x10(%ebp)
f011d0c3:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d0c7:	7e ae                	jle    f011d077 <print_order+0x2e>
f011d0c9:	eb 01                	jmp    f011d0cc <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d0cb:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d0cc:	83 ec 0c             	sub    $0xc,%esp
f011d0cf:	68 61 ff 12 f0       	push   $0xf012ff61
f011d0d4:	e8 b2 3e fe ff       	call   f0100f8b <cprintf>
f011d0d9:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d0dc:	ff 45 f4             	incl   -0xc(%ebp)
f011d0df:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d0e3:	0f 8e 72 ff ff ff    	jle    f011d05b <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d0e9:	90                   	nop
f011d0ea:	c9                   	leave  
f011d0eb:	c3                   	ret    

f011d0ec <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d0ec:	55                   	push   %ebp
f011d0ed:	89 e5                	mov    %esp,%ebp
f011d0ef:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d0f2:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d0f9:	83 ec 0c             	sub    $0xc,%esp
f011d0fc:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d101:	e8 3f 25 ff ff       	call   f010f645 <acquire_spinlock>
f011d106:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d109:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d110:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d117:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d11a:	8b 45 10             	mov    0x10(%ebp),%eax
f011d11d:	01 d0                	add    %edx,%eax
f011d11f:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d122:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011d127:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d12a:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011d12f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d132:	ff 75 e8             	pushl  -0x18(%ebp)
f011d135:	ff 75 0c             	pushl  0xc(%ebp)
f011d138:	ff 75 08             	pushl  0x8(%ebp)
f011d13b:	68 64 ff 12 f0       	push   $0xf012ff64
f011d140:	e8 46 3e fe ff       	call   f0100f8b <cprintf>
f011d145:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d148:	eb 34                	jmp    f011d17e <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d14a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d14d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d150:	7d 05                	jge    f011d157 <find_in_range+0x6b>
			{
				i++;
f011d152:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d155:	eb 1e                	jmp    f011d175 <find_in_range+0x89>
			}
			if (i >= end)
f011d157:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d15a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d15d:	7d 29                	jge    f011d188 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d15f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d162:	8b 40 10             	mov    0x10(%eax),%eax
f011d165:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d168:	75 08                	jne    f011d172 <find_in_range+0x86>
			{
				ret = i;
f011d16a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d16d:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d170:	eb 17                	jmp    f011d189 <find_in_range+0x9d>
			}
			i++;
f011d172:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d175:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d178:	8b 40 0c             	mov    0xc(%eax),%eax
f011d17b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d17e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d181:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d184:	7c c4                	jl     f011d14a <find_in_range+0x5e>
f011d186:	eb 01                	jmp    f011d189 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d188:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d189:	83 ec 0c             	sub    $0xc,%esp
f011d18c:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d191:	e8 36 25 ff ff       	call   f010f6cc <release_spinlock>
f011d196:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d199:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d19c:	c9                   	leave  
f011d19d:	c3                   	ret    

f011d19e <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d19e:	55                   	push   %ebp
f011d19f:	89 e5                	mov    %esp,%ebp
f011d1a1:	57                   	push   %edi
f011d1a2:	56                   	push   %esi
f011d1a3:	53                   	push   %ebx
f011d1a4:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d1a7:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d1ac:	84 c0                	test   %al,%al
f011d1ae:	0f 84 9b 01 00 00    	je     f011d34f <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d1b4:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d1bb:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d1be:	bb dc 00 13 f0       	mov    $0xf01300dc,%ebx
f011d1c3:	ba 05 00 00 00       	mov    $0x5,%edx
f011d1c8:	89 c7                	mov    %eax,%edi
f011d1ca:	89 de                	mov    %ebx,%esi
f011d1cc:	89 d1                	mov    %edx,%ecx
f011d1ce:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d1d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d1d7:	e9 44 01 00 00       	jmp    f011d320 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d1dc:	6a 00                	push   $0x0
f011d1de:	6a 00                	push   $0x0
f011d1e0:	68 f4 01 00 00       	push   $0x1f4
f011d1e5:	68 95 ff 12 f0       	push   $0xf012ff95
f011d1ea:	e8 36 d7 fe ff       	call   f010a925 <env_create>
f011d1ef:	83 c4 10             	add    $0x10,%esp
f011d1f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d1f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d1f8:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d1fd:	99                   	cltd   
f011d1fe:	f7 f9                	idiv   %ecx
f011d200:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d203:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d206:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d20a:	83 ec 08             	sub    $0x8,%esp
f011d20d:	50                   	push   %eax
f011d20e:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d211:	e8 70 94 fe ff       	call   f0106686 <env_set_nice>
f011d216:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d219:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d21d:	75 14                	jne    f011d233 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d21f:	83 ec 04             	sub    $0x4,%esp
f011d222:	68 9d ff 12 f0       	push   $0xf012ff9d
f011d227:	6a 53                	push   $0x53
f011d229:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d22e:	e8 06 31 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d233:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d236:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d23c:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d241:	74 14                	je     f011d257 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d243:	83 ec 04             	sub    $0x4,%esp
f011d246:	68 d4 ff 12 f0       	push   $0xf012ffd4
f011d24b:	6a 55                	push   $0x55
f011d24d:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d252:	e8 e2 30 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d257:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d25a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d25e:	83 c0 0a             	add    $0xa,%eax
f011d261:	83 f8 14             	cmp    $0x14,%eax
f011d264:	0f 87 a5 00 00 00    	ja     f011d30f <test_bsd_nice_0+0x171>
f011d26a:	8b 04 85 f0 00 13 f0 	mov    -0xfecff10(,%eax,4),%eax
f011d271:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d273:	a1 5c d0 6b f0       	mov    0xf06bd05c,%eax
f011d278:	8d 50 01             	lea    0x1(%eax),%edx
f011d27b:	89 15 5c d0 6b f0    	mov    %edx,0xf06bd05c
f011d281:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d284:	8b 52 10             	mov    0x10(%edx),%edx
f011d287:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d28e:	eb 7f                	jmp    f011d30f <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d290:	a1 60 d0 6b f0       	mov    0xf06bd060,%eax
f011d295:	8d 50 01             	lea    0x1(%eax),%edx
f011d298:	89 15 60 d0 6b f0    	mov    %edx,0xf06bd060
f011d29e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d2a1:	8b 52 10             	mov    0x10(%edx),%edx
f011d2a4:	83 c0 0a             	add    $0xa,%eax
f011d2a7:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d2ae:	eb 5f                	jmp    f011d30f <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d2b0:	a1 64 d0 6b f0       	mov    0xf06bd064,%eax
f011d2b5:	8d 50 01             	lea    0x1(%eax),%edx
f011d2b8:	89 15 64 d0 6b f0    	mov    %edx,0xf06bd064
f011d2be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d2c1:	8b 52 10             	mov    0x10(%edx),%edx
f011d2c4:	83 c0 14             	add    $0x14,%eax
f011d2c7:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d2ce:	eb 3f                	jmp    f011d30f <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d2d0:	a1 68 d0 6b f0       	mov    0xf06bd068,%eax
f011d2d5:	8d 50 01             	lea    0x1(%eax),%edx
f011d2d8:	89 15 68 d0 6b f0    	mov    %edx,0xf06bd068
f011d2de:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d2e1:	8b 52 10             	mov    0x10(%edx),%edx
f011d2e4:	83 c0 1e             	add    $0x1e,%eax
f011d2e7:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d2ee:	eb 1f                	jmp    f011d30f <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d2f0:	a1 6c d0 6b f0       	mov    0xf06bd06c,%eax
f011d2f5:	8d 50 01             	lea    0x1(%eax),%edx
f011d2f8:	89 15 6c d0 6b f0    	mov    %edx,0xf06bd06c
f011d2fe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d301:	8b 52 10             	mov    0x10(%edx),%edx
f011d304:	83 c0 28             	add    $0x28,%eax
f011d307:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d30e:	90                   	nop
			}
			sched_new_env(env);
f011d30f:	83 ec 0c             	sub    $0xc,%esp
f011d312:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d315:	e8 02 84 fe ff       	call   f010571c <sched_new_env>
f011d31a:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d31d:	ff 45 e4             	incl   -0x1c(%ebp)
f011d320:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d324:	0f 8e b2 fe ff ff    	jle    f011d1dc <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d32a:	83 ec 0c             	sub    $0xc,%esp
f011d32d:	68 04 00 13 f0       	push   $0xf0130004
f011d332:	e8 54 3c fe ff       	call   f0100f8b <cprintf>
f011d337:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d33a:	83 ec 0c             	sub    $0xc,%esp
f011d33d:	68 53 00 13 f0       	push   $0xf0130053
f011d342:	e8 b4 4b fe ff       	call   f0101efb <execute_command>
f011d347:	83 c4 10             	add    $0x10,%esp
f011d34a:	e9 c0 00 00 00       	jmp    f011d40f <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d34f:	83 ec 0c             	sub    $0xc,%esp
f011d352:	68 5a 00 13 f0       	push   $0xf013005a
f011d357:	e8 2f 3c fe ff       	call   f0100f8b <cprintf>
f011d35c:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d35f:	e8 f0 8a fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d364:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d36b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d372:	e9 87 00 00 00       	jmp    f011d3fe <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d377:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d37e:	eb 52                	jmp    f011d3d2 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d380:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d383:	8b 14 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%edx
f011d38a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d38d:	89 c8                	mov    %ecx,%eax
f011d38f:	c1 e0 02             	shl    $0x2,%eax
f011d392:	01 c8                	add    %ecx,%eax
f011d394:	01 c0                	add    %eax,%eax
f011d396:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d399:	01 c8                	add    %ecx,%eax
f011d39b:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d3a2:	83 ec 04             	sub    $0x4,%esp
f011d3a5:	52                   	push   %edx
f011d3a6:	ff 75 e0             	pushl  -0x20(%ebp)
f011d3a9:	50                   	push   %eax
f011d3aa:	e8 3d fd ff ff       	call   f011d0ec <find_in_range>
f011d3af:	83 c4 10             	add    $0x10,%esp
f011d3b2:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d3b5:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d3b9:	75 14                	jne    f011d3cf <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011d3bb:	83 ec 04             	sub    $0x4,%esp
f011d3be:	68 6c 00 13 f0       	push   $0xf013006c
f011d3c3:	6a 7b                	push   $0x7b
f011d3c5:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d3ca:	e8 6a 2f fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d3cf:	ff 45 d8             	incl   -0x28(%ebp)
f011d3d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d3d5:	89 d0                	mov    %edx,%eax
f011d3d7:	c1 e0 02             	shl    $0x2,%eax
f011d3da:	01 d0                	add    %edx,%eax
f011d3dc:	01 c0                	add    %eax,%eax
f011d3de:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d3e1:	01 d0                	add    %edx,%eax
f011d3e3:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d3ea:	85 c0                	test   %eax,%eax
f011d3ec:	75 92                	jne    f011d380 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d3ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d3f1:	8b 04 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%eax
f011d3f8:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d3fb:	ff 45 dc             	incl   -0x24(%ebp)
f011d3fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d402:	0f 8e 6f ff ff ff    	jle    f011d377 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d408:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011d40f:	83 ec 0c             	sub    $0xc,%esp
f011d412:	68 a0 00 13 f0       	push   $0xf01300a0
f011d417:	e8 6f 3b fe ff       	call   f0100f8b <cprintf>
f011d41c:	83 c4 10             	add    $0x10,%esp
}
f011d41f:	90                   	nop
f011d420:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d423:	5b                   	pop    %ebx
f011d424:	5e                   	pop    %esi
f011d425:	5f                   	pop    %edi
f011d426:	5d                   	pop    %ebp
f011d427:	c3                   	ret    

f011d428 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011d428:	55                   	push   %ebp
f011d429:	89 e5                	mov    %esp,%ebp
f011d42b:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011d42e:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d433:	84 c0                	test   %al,%al
f011d435:	0f 84 50 01 00 00    	je     f011d58b <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011d43b:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011d442:	6a 00                	push   $0x0
f011d444:	6a 00                	push   $0x0
f011d446:	68 f4 01 00 00       	push   $0x1f4
f011d44b:	68 95 ff 12 f0       	push   $0xf012ff95
f011d450:	e8 d0 d4 fe ff       	call   f010a925 <env_create>
f011d455:	83 c4 10             	add    $0x10,%esp
f011d458:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011d45b:	6a 00                	push   $0x0
f011d45d:	6a 00                	push   $0x0
f011d45f:	68 f4 01 00 00       	push   $0x1f4
f011d464:	68 44 01 13 f0       	push   $0xf0130144
f011d469:	e8 b7 d4 fe ff       	call   f010a925 <env_create>
f011d46e:	83 c4 10             	add    $0x10,%esp
f011d471:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011d474:	6a 00                	push   $0x0
f011d476:	6a 00                	push   $0x0
f011d478:	68 f4 01 00 00       	push   $0x1f4
f011d47d:	68 51 01 13 f0       	push   $0xf0130151
f011d482:	e8 9e d4 fe ff       	call   f010a925 <env_create>
f011d487:	83 c4 10             	add    $0x10,%esp
f011d48a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011d48d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d491:	74 0c                	je     f011d49f <test_bsd_nice_1+0x77>
f011d493:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d497:	74 06                	je     f011d49f <test_bsd_nice_1+0x77>
f011d499:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d49d:	75 17                	jne    f011d4b6 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011d49f:	83 ec 04             	sub    $0x4,%esp
f011d4a2:	68 9d ff 12 f0       	push   $0xf012ff9d
f011d4a7:	68 8e 00 00 00       	push   $0x8e
f011d4ac:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d4b1:	e8 83 2e fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011d4b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d4b9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d4bf:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d4c4:	75 20                	jne    f011d4e6 <test_bsd_nice_1+0xbe>
f011d4c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d4c9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d4cf:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d4d4:	75 10                	jne    f011d4e6 <test_bsd_nice_1+0xbe>
f011d4d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d4d9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d4df:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d4e4:	74 35                	je     f011d51b <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011d4e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d4e9:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011d4ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d4f2:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011d4f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d4fb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d501:	83 ec 08             	sub    $0x8,%esp
f011d504:	51                   	push   %ecx
f011d505:	52                   	push   %edx
f011d506:	50                   	push   %eax
f011d507:	68 60 01 13 f0       	push   $0xf0130160
f011d50c:	68 90 00 00 00       	push   $0x90
f011d511:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d516:	e8 1e 2e fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011d51b:	83 ec 0c             	sub    $0xc,%esp
f011d51e:	ff 75 ec             	pushl  -0x14(%ebp)
f011d521:	e8 f6 81 fe ff       	call   f010571c <sched_new_env>
f011d526:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011d529:	83 ec 0c             	sub    $0xc,%esp
f011d52c:	ff 75 e8             	pushl  -0x18(%ebp)
f011d52f:	e8 e8 81 fe ff       	call   f010571c <sched_new_env>
f011d534:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011d537:	83 ec 0c             	sub    $0xc,%esp
f011d53a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d53d:	e8 da 81 fe ff       	call   f010571c <sched_new_env>
f011d542:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011d545:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d548:	8b 40 10             	mov    0x10(%eax),%eax
f011d54b:	a3 c0 81 b0 f0       	mov    %eax,0xf0b081c0
		prog_orders[1][0] = fibEnv->env_id;
f011d550:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d553:	8b 40 10             	mov    0x10(%eax),%eax
f011d556:	a3 e8 81 b0 f0       	mov    %eax,0xf0b081e8
		prog_orders[2][0] = fibposnEnv->env_id;
f011d55b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d55e:	8b 40 10             	mov    0x10(%eax),%eax
f011d561:	a3 10 82 b0 f0       	mov    %eax,0xf0b08210
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d566:	83 ec 0c             	sub    $0xc,%esp
f011d569:	68 04 00 13 f0       	push   $0xf0130004
f011d56e:	e8 18 3a fe ff       	call   f0100f8b <cprintf>
f011d573:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d576:	83 ec 0c             	sub    $0xc,%esp
f011d579:	68 53 00 13 f0       	push   $0xf0130053
f011d57e:	e8 78 49 fe ff       	call   f0101efb <execute_command>
f011d583:	83 c4 10             	add    $0x10,%esp
f011d586:	e9 9e 00 00 00       	jmp    f011d629 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011d58b:	83 ec 0c             	sub    $0xc,%esp
f011d58e:	68 5a 00 13 f0       	push   $0xf013005a
f011d593:	e8 f3 39 fe ff       	call   f0100f8b <cprintf>
f011d598:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d59b:	e8 b4 88 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011d5a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011d5a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011d5ae:	83 ec 0c             	sub    $0xc,%esp
f011d5b1:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d5b6:	e8 8a 20 ff ff       	call   f010f645 <acquire_spinlock>
f011d5bb:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d5be:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011d5c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d5c6:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011d5cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d5ce:	eb 41                	jmp    f011d611 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011d5d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d5d3:	89 d0                	mov    %edx,%eax
f011d5d5:	c1 e0 02             	shl    $0x2,%eax
f011d5d8:	01 d0                	add    %edx,%eax
f011d5da:	c1 e0 03             	shl    $0x3,%eax
f011d5dd:	05 c0 81 b0 f0       	add    $0xf0b081c0,%eax
f011d5e2:	8b 10                	mov    (%eax),%edx
f011d5e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d5e7:	8b 40 10             	mov    0x10(%eax),%eax
f011d5ea:	39 c2                	cmp    %eax,%edx
f011d5ec:	74 17                	je     f011d605 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011d5ee:	83 ec 04             	sub    $0x4,%esp
f011d5f1:	68 6c 00 13 f0       	push   $0xf013006c
f011d5f6:	68 ab 00 00 00       	push   $0xab
f011d5fb:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d600:	e8 34 2d fe ff       	call   f0100339 <_panic>
				i++;
f011d605:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d608:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d60b:	8b 40 0c             	mov    0xc(%eax),%eax
f011d60e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d611:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d614:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011d617:	7c b7                	jl     f011d5d0 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d619:	83 ec 0c             	sub    $0xc,%esp
f011d61c:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d621:	e8 a6 20 ff ff       	call   f010f6cc <release_spinlock>
f011d626:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011d629:	83 ec 0c             	sub    $0xc,%esp
f011d62c:	68 cc 01 13 f0       	push   $0xf01301cc
f011d631:	e8 55 39 fe ff       	call   f0100f8b <cprintf>
f011d636:	83 c4 10             	add    $0x10,%esp
}
f011d639:	90                   	nop
f011d63a:	c9                   	leave  
f011d63b:	c3                   	ret    

f011d63c <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011d63c:	55                   	push   %ebp
f011d63d:	89 e5                	mov    %esp,%ebp
f011d63f:	57                   	push   %edi
f011d640:	56                   	push   %esi
f011d641:	53                   	push   %ebx
f011d642:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d645:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d64a:	84 c0                	test   %al,%al
f011d64c:	0f 84 ae 01 00 00    	je     f011d800 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011d652:	83 ec 0c             	sub    $0xc,%esp
f011d655:	6a 01                	push   $0x1
f011d657:	e8 fe 10 00 00       	call   f011e75a <chksch>
f011d65c:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011d65f:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011d666:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d669:	bb 50 02 13 f0       	mov    $0xf0130250,%ebx
f011d66e:	ba 05 00 00 00       	mov    $0x5,%edx
f011d673:	89 c7                	mov    %eax,%edi
f011d675:	89 de                	mov    %ebx,%esi
f011d677:	89 d1                	mov    %edx,%ecx
f011d679:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d67b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d682:	e9 4a 01 00 00       	jmp    f011d7d1 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011d687:	6a 00                	push   $0x0
f011d689:	6a 00                	push   $0x0
f011d68b:	68 10 27 00 00       	push   $0x2710
f011d690:	68 08 02 13 f0       	push   $0xf0130208
f011d695:	e8 8b d2 fe ff       	call   f010a925 <env_create>
f011d69a:	83 c4 10             	add    $0x10,%esp
f011d69d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d6a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d6a3:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d6a8:	99                   	cltd   
f011d6a9:	f7 f9                	idiv   %ecx
f011d6ab:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d6ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d6b1:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d6b5:	83 ec 08             	sub    $0x8,%esp
f011d6b8:	50                   	push   %eax
f011d6b9:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d6bc:	e8 c5 8f fe ff       	call   f0106686 <env_set_nice>
f011d6c1:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d6c4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d6c8:	75 17                	jne    f011d6e1 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011d6ca:	83 ec 04             	sub    $0x4,%esp
f011d6cd:	68 9d ff 12 f0       	push   $0xf012ff9d
f011d6d2:	68 c1 00 00 00       	push   $0xc1
f011d6d7:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d6dc:	e8 58 2c fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011d6e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d6e4:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d6ea:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011d6ef:	74 17                	je     f011d708 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011d6f1:	83 ec 04             	sub    $0x4,%esp
f011d6f4:	68 d4 ff 12 f0       	push   $0xf012ffd4
f011d6f9:	68 c3 00 00 00       	push   $0xc3
f011d6fe:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d703:	e8 31 2c fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d708:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d70b:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d70f:	83 c0 0f             	add    $0xf,%eax
f011d712:	83 f8 1e             	cmp    $0x1e,%eax
f011d715:	0f 87 a5 00 00 00    	ja     f011d7c0 <test_bsd_nice_2+0x184>
f011d71b:	8b 04 85 64 02 13 f0 	mov    -0xfecfd9c(,%eax,4),%eax
f011d722:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d724:	a1 5c d0 6b f0       	mov    0xf06bd05c,%eax
f011d729:	8d 50 01             	lea    0x1(%eax),%edx
f011d72c:	89 15 5c d0 6b f0    	mov    %edx,0xf06bd05c
f011d732:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d735:	8b 52 10             	mov    0x10(%edx),%edx
f011d738:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d73f:	eb 7f                	jmp    f011d7c0 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d741:	a1 60 d0 6b f0       	mov    0xf06bd060,%eax
f011d746:	8d 50 01             	lea    0x1(%eax),%edx
f011d749:	89 15 60 d0 6b f0    	mov    %edx,0xf06bd060
f011d74f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d752:	8b 52 10             	mov    0x10(%edx),%edx
f011d755:	83 c0 0a             	add    $0xa,%eax
f011d758:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d75f:	eb 5f                	jmp    f011d7c0 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d761:	a1 64 d0 6b f0       	mov    0xf06bd064,%eax
f011d766:	8d 50 01             	lea    0x1(%eax),%edx
f011d769:	89 15 64 d0 6b f0    	mov    %edx,0xf06bd064
f011d76f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d772:	8b 52 10             	mov    0x10(%edx),%edx
f011d775:	83 c0 14             	add    $0x14,%eax
f011d778:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d77f:	eb 3f                	jmp    f011d7c0 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d781:	a1 68 d0 6b f0       	mov    0xf06bd068,%eax
f011d786:	8d 50 01             	lea    0x1(%eax),%edx
f011d789:	89 15 68 d0 6b f0    	mov    %edx,0xf06bd068
f011d78f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d792:	8b 52 10             	mov    0x10(%edx),%edx
f011d795:	83 c0 1e             	add    $0x1e,%eax
f011d798:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d79f:	eb 1f                	jmp    f011d7c0 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d7a1:	a1 6c d0 6b f0       	mov    0xf06bd06c,%eax
f011d7a6:	8d 50 01             	lea    0x1(%eax),%edx
f011d7a9:	89 15 6c d0 6b f0    	mov    %edx,0xf06bd06c
f011d7af:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d7b2:	8b 52 10             	mov    0x10(%edx),%edx
f011d7b5:	83 c0 28             	add    $0x28,%eax
f011d7b8:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d7bf:	90                   	nop
			}
			sched_new_env(env);
f011d7c0:	83 ec 0c             	sub    $0xc,%esp
f011d7c3:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d7c6:	e8 51 7f fe ff       	call   f010571c <sched_new_env>
f011d7cb:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d7ce:	ff 45 e4             	incl   -0x1c(%ebp)
f011d7d1:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011d7d5:	0f 8e ac fe ff ff    	jle    f011d687 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d7db:	83 ec 0c             	sub    $0xc,%esp
f011d7de:	68 04 00 13 f0       	push   $0xf0130004
f011d7e3:	e8 a3 37 fe ff       	call   f0100f8b <cprintf>
f011d7e8:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d7eb:	83 ec 0c             	sub    $0xc,%esp
f011d7ee:	68 53 00 13 f0       	push   $0xf0130053
f011d7f3:	e8 03 47 fe ff       	call   f0101efb <execute_command>
f011d7f8:	83 c4 10             	add    $0x10,%esp
f011d7fb:	e9 d0 00 00 00       	jmp    f011d8d0 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011d800:	83 ec 0c             	sub    $0xc,%esp
f011d803:	6a 00                	push   $0x0
f011d805:	e8 50 0f 00 00       	call   f011e75a <chksch>
f011d80a:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011d80d:	83 ec 0c             	sub    $0xc,%esp
f011d810:	68 5a 00 13 f0       	push   $0xf013005a
f011d815:	e8 71 37 fe ff       	call   f0100f8b <cprintf>
f011d81a:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d81d:	e8 32 86 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d822:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d829:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d830:	e9 8a 00 00 00       	jmp    f011d8bf <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d835:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d83c:	eb 55                	jmp    f011d893 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d83e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d841:	8b 14 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%edx
f011d848:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d84b:	89 c8                	mov    %ecx,%eax
f011d84d:	c1 e0 02             	shl    $0x2,%eax
f011d850:	01 c8                	add    %ecx,%eax
f011d852:	01 c0                	add    %eax,%eax
f011d854:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d857:	01 c8                	add    %ecx,%eax
f011d859:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d860:	83 ec 04             	sub    $0x4,%esp
f011d863:	52                   	push   %edx
f011d864:	ff 75 e0             	pushl  -0x20(%ebp)
f011d867:	50                   	push   %eax
f011d868:	e8 7f f8 ff ff       	call   f011d0ec <find_in_range>
f011d86d:	83 c4 10             	add    $0x10,%esp
f011d870:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d873:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d877:	75 17                	jne    f011d890 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011d879:	83 ec 04             	sub    $0x4,%esp
f011d87c:	68 6c 00 13 f0       	push   $0xf013006c
f011d881:	68 ea 00 00 00       	push   $0xea
f011d886:	68 b6 ff 12 f0       	push   $0xf012ffb6
f011d88b:	e8 a9 2a fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d890:	ff 45 d8             	incl   -0x28(%ebp)
f011d893:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d896:	89 d0                	mov    %edx,%eax
f011d898:	c1 e0 02             	shl    $0x2,%eax
f011d89b:	01 d0                	add    %edx,%eax
f011d89d:	01 c0                	add    %eax,%eax
f011d89f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d8a2:	01 d0                	add    %edx,%eax
f011d8a4:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d8ab:	85 c0                	test   %eax,%eax
f011d8ad:	75 8f                	jne    f011d83e <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d8af:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d8b2:	8b 04 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%eax
f011d8b9:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d8bc:	ff 45 dc             	incl   -0x24(%ebp)
f011d8bf:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d8c3:	0f 8e 6c ff ff ff    	jle    f011d835 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d8c9:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011d8d0:	83 ec 0c             	sub    $0xc,%esp
f011d8d3:	68 14 02 13 f0       	push   $0xf0130214
f011d8d8:	e8 ae 36 fe ff       	call   f0100f8b <cprintf>
f011d8dd:	83 c4 10             	add    $0x10,%esp
}
f011d8e0:	90                   	nop
f011d8e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d8e4:	5b                   	pop    %ebx
f011d8e5:	5e                   	pop    %esi
f011d8e6:	5f                   	pop    %edi
f011d8e7:	5d                   	pop    %ebp
f011d8e8:	c3                   	ret    

f011d8e9 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011d8e9:	55                   	push   %ebp
f011d8ea:	89 e5                	mov    %esp,%ebp
f011d8ec:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011d8ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d8f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011d8f5:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011d8fb:	89 10                	mov    %edx,(%eax)
}
f011d8fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011d900:	c9                   	leave  
f011d901:	c2 04 00             	ret    $0x4

f011d904 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011d904:	55                   	push   %ebp
f011d905:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011d907:	8b 45 08             	mov    0x8(%ebp),%eax
f011d90a:	85 c0                	test   %eax,%eax
f011d90c:	78 16                	js     f011d924 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011d90e:	8b 45 08             	mov    0x8(%ebp),%eax
f011d911:	05 00 20 00 00       	add    $0x2000,%eax
f011d916:	85 c0                	test   %eax,%eax
f011d918:	79 05                	jns    f011d91f <fix_round+0x1b>
f011d91a:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d91f:	c1 f8 0e             	sar    $0xe,%eax
f011d922:	eb 14                	jmp    f011d938 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011d924:	8b 45 08             	mov    0x8(%ebp),%eax
f011d927:	2d 00 20 00 00       	sub    $0x2000,%eax
f011d92c:	85 c0                	test   %eax,%eax
f011d92e:	79 05                	jns    f011d935 <fix_round+0x31>
f011d930:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d935:	c1 f8 0e             	sar    $0xe,%eax
}
f011d938:	5d                   	pop    %ebp
f011d939:	c3                   	ret    

f011d93a <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011d93a:	55                   	push   %ebp
f011d93b:	89 e5                	mov    %esp,%ebp
f011d93d:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011d940:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011d944:	79 16                	jns    f011d95c <fix_scale+0x22>
f011d946:	68 e0 02 13 f0       	push   $0xf01302e0
f011d94b:	68 e7 02 13 f0       	push   $0xf01302e7
f011d950:	6a 5a                	push   $0x5a
f011d952:	68 fc 02 13 f0       	push   $0xf01302fc
f011d957:	e8 dd 29 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011d95c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d95f:	0f af 45 10          	imul   0x10(%ebp),%eax
f011d963:	89 c2                	mov    %eax,%edx
f011d965:	8b 45 08             	mov    0x8(%ebp),%eax
f011d968:	83 ec 08             	sub    $0x8,%esp
f011d96b:	52                   	push   %edx
f011d96c:	50                   	push   %eax
f011d96d:	e8 77 ff ff ff       	call   f011d8e9 <__mk_fix>
f011d972:	83 c4 0c             	add    $0xc,%esp
}
f011d975:	8b 45 08             	mov    0x8(%ebp),%eax
f011d978:	c9                   	leave  
f011d979:	c2 04 00             	ret    $0x4

f011d97c <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011d97c:	55                   	push   %ebp
f011d97d:	89 e5                	mov    %esp,%ebp
f011d97f:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011d982:	83 ec 08             	sub    $0x8,%esp
f011d985:	68 10 03 13 f0       	push   $0xf0130310
f011d98a:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d98f:	e8 80 1c ff ff       	call   f010f614 <init_spinlock>
f011d994:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011d997:	83 ec 0c             	sub    $0xc,%esp
f011d99a:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d99f:	e8 a1 1c ff ff       	call   f010f645 <acquire_spinlock>
f011d9a4:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011d9a7:	c7 05 a8 d1 6b f0 00 	movl   $0x0,0xf06bd1a8
f011d9ae:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011d9b1:	83 ec 0c             	sub    $0xc,%esp
f011d9b4:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d9b9:	e8 0e 1d ff ff       	call   f010f6cc <release_spinlock>
f011d9be:	83 c4 10             	add    $0x10,%esp
}
f011d9c1:	90                   	nop
f011d9c2:	c9                   	leave  
f011d9c3:	c3                   	ret    

f011d9c4 <inctst>:
void inctst()
{
f011d9c4:	55                   	push   %ebp
f011d9c5:	89 e5                	mov    %esp,%ebp
f011d9c7:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011d9ca:	83 ec 0c             	sub    $0xc,%esp
f011d9cd:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d9d2:	e8 6e 1c ff ff       	call   f010f645 <acquire_spinlock>
f011d9d7:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011d9da:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011d9df:	40                   	inc    %eax
f011d9e0:	a3 a8 d1 6b f0       	mov    %eax,0xf06bd1a8
	}
	release_spinlock(&tstcntlock);
f011d9e5:	83 ec 0c             	sub    $0xc,%esp
f011d9e8:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d9ed:	e8 da 1c ff ff       	call   f010f6cc <release_spinlock>
f011d9f2:	83 c4 10             	add    $0x10,%esp
}
f011d9f5:	90                   	nop
f011d9f6:	c9                   	leave  
f011d9f7:	c3                   	ret    

f011d9f8 <gettst>:
uint32 gettst()
{
f011d9f8:	55                   	push   %ebp
f011d9f9:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011d9fb:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
}
f011da00:	5d                   	pop    %ebp
f011da01:	c3                   	ret    

f011da02 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011da02:	55                   	push   %ebp
f011da03:	89 e5                	mov    %esp,%ebp
f011da05:	83 ec 28             	sub    $0x28,%esp
f011da08:	8b 45 14             	mov    0x14(%ebp),%eax
f011da0b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011da0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011da15:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011da19:	83 f8 65             	cmp    $0x65,%eax
f011da1c:	74 5d                	je     f011da7b <tst+0x79>
f011da1e:	83 f8 65             	cmp    $0x65,%eax
f011da21:	7f 0a                	jg     f011da2d <tst+0x2b>
f011da23:	83 f8 62             	cmp    $0x62,%eax
f011da26:	74 73                	je     f011da9b <tst+0x99>
f011da28:	e9 91 00 00 00       	jmp    f011dabe <tst+0xbc>
f011da2d:	83 f8 67             	cmp    $0x67,%eax
f011da30:	74 29                	je     f011da5b <tst+0x59>
f011da32:	83 f8 6c             	cmp    $0x6c,%eax
f011da35:	0f 85 83 00 00 00    	jne    f011dabe <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011da3b:	8b 45 08             	mov    0x8(%ebp),%eax
f011da3e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da41:	73 09                	jae    f011da4c <tst+0x4a>
			chk = 1;
f011da43:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da4a:	eb 68                	jmp    f011dab4 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011da4c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da50:	74 62                	je     f011dab4 <tst+0xb2>
			chk = 1;
f011da52:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da59:	eb 59                	jmp    f011dab4 <tst+0xb2>
	case 'g':
		if (n > v1)
f011da5b:	8b 45 08             	mov    0x8(%ebp),%eax
f011da5e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da61:	76 09                	jbe    f011da6c <tst+0x6a>
			chk = 1;
f011da63:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da6a:	eb 4b                	jmp    f011dab7 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011da6c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da70:	74 45                	je     f011dab7 <tst+0xb5>
			chk = 1;
f011da72:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da79:	eb 3c                	jmp    f011dab7 <tst+0xb5>
	case 'e':
		if (n == v1)
f011da7b:	8b 45 08             	mov    0x8(%ebp),%eax
f011da7e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da81:	75 09                	jne    f011da8c <tst+0x8a>
			chk = 1;
f011da83:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da8a:	eb 2e                	jmp    f011daba <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011da8c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da90:	74 28                	je     f011daba <tst+0xb8>
			chk = 1;
f011da92:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da99:	eb 1f                	jmp    f011daba <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011da9b:	8b 45 08             	mov    0x8(%ebp),%eax
f011da9e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011daa1:	72 1a                	jb     f011dabd <tst+0xbb>
f011daa3:	8b 45 08             	mov    0x8(%ebp),%eax
f011daa6:	3b 45 10             	cmp    0x10(%ebp),%eax
f011daa9:	77 12                	ja     f011dabd <tst+0xbb>
			chk = 1;
f011daab:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011dab2:	eb 09                	jmp    f011dabd <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011dab4:	90                   	nop
f011dab5:	eb 07                	jmp    f011dabe <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011dab7:	90                   	nop
f011dab8:	eb 04                	jmp    f011dabe <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011daba:	90                   	nop
f011dabb:	eb 01                	jmp    f011dabe <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011dabd:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011dabe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011dac2:	75 14                	jne    f011dad8 <tst+0xd6>
f011dac4:	83 ec 04             	sub    $0x4,%esp
f011dac7:	68 1c 03 13 f0       	push   $0xf013031c
f011dacc:	6a 48                	push   $0x48
f011dace:	68 2f 03 13 f0       	push   $0xf013032f
f011dad3:	e8 61 28 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011dad8:	83 ec 0c             	sub    $0xc,%esp
f011dadb:	68 c0 da 6b f0       	push   $0xf06bdac0
f011dae0:	e8 60 1b ff ff       	call   f010f645 <acquire_spinlock>
f011dae5:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011dae8:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011daed:	40                   	inc    %eax
f011daee:	a3 a8 d1 6b f0       	mov    %eax,0xf06bd1a8
	}
	release_spinlock(&tstcntlock);
f011daf3:	83 ec 0c             	sub    $0xc,%esp
f011daf6:	68 c0 da 6b f0       	push   $0xf06bdac0
f011dafb:	e8 cc 1b ff ff       	call   f010f6cc <release_spinlock>
f011db00:	83 c4 10             	add    $0x10,%esp

	return;
f011db03:	90                   	nop
}
f011db04:	c9                   	leave  
f011db05:	c3                   	ret    

f011db06 <chktst>:

void chktst(uint32 n)
{
f011db06:	55                   	push   %ebp
f011db07:	89 e5                	mov    %esp,%ebp
f011db09:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011db0c:	83 ec 0c             	sub    $0xc,%esp
f011db0f:	68 c0 da 6b f0       	push   $0xf06bdac0
f011db14:	e8 2c 1b ff ff       	call   f010f645 <acquire_spinlock>
f011db19:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011db1c:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011db21:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011db24:	83 ec 0c             	sub    $0xc,%esp
f011db27:	68 c0 da 6b f0       	push   $0xf06bdac0
f011db2c:	e8 9b 1b ff ff       	call   f010f6cc <release_spinlock>
f011db31:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011db34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011db37:	3b 45 08             	cmp    0x8(%ebp),%eax
f011db3a:	75 12                	jne    f011db4e <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011db3c:	83 ec 0c             	sub    $0xc,%esp
f011db3f:	68 48 03 13 f0       	push   $0xf0130348
f011db44:	e8 42 34 fe ff       	call   f0100f8b <cprintf>
f011db49:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011db4c:	eb 14                	jmp    f011db62 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011db4e:	83 ec 04             	sub    $0x4,%esp
f011db51:	68 74 03 13 f0       	push   $0xf0130374
f011db56:	6a 5e                	push   $0x5e
f011db58:	68 2f 03 13 f0       	push   $0xf013032f
f011db5d:	e8 d7 27 fe ff       	call   f0100339 <_panic>
}
f011db62:	c9                   	leave  
f011db63:	c3                   	ret    

f011db64 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011db64:	55                   	push   %ebp
f011db65:	89 e5                	mov    %esp,%ebp
f011db67:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011db6a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011db6e:	77 07                	ja     f011db77 <nearest_pow2_ceil+0x13>
f011db70:	b8 01 00 00 00       	mov    $0x1,%eax
f011db75:	eb 20                	jmp    f011db97 <nearest_pow2_ceil+0x33>
	int power = 2;
f011db77:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011db7e:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011db81:	eb 08                	jmp    f011db8b <nearest_pow2_ceil+0x27>
		power <<= 1;
f011db83:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011db86:	01 c0                	add    %eax,%eax
f011db88:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011db8b:	d1 6d 08             	shrl   0x8(%ebp)
f011db8e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011db92:	75 ef                	jne    f011db83 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011db94:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011db97:	c9                   	leave  
f011db98:	c3                   	ret    

f011db99 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011db99:	55                   	push   %ebp
f011db9a:	89 e5                	mov    %esp,%ebp
f011db9c:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011db9f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011dba3:	77 07                	ja     f011dbac <log2_ceil+0x13>
f011dba5:	b8 01 00 00 00       	mov    $0x1,%eax
f011dbaa:	eb 1b                	jmp    f011dbc7 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011dbac:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011dbb3:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011dbb6:	eb 03                	jmp    f011dbbb <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011dbb8:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011dbbb:	d1 6d 08             	shrl   0x8(%ebp)
f011dbbe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011dbc2:	75 f4                	jne    f011dbb8 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011dbc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011dbc7:	c9                   	leave  
f011dbc8:	c3                   	ret    

f011dbc9 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011dbc9:	55                   	push   %ebp
f011dbca:	89 e5                	mov    %esp,%ebp
f011dbcc:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011dbcf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011dbd6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011dbdd:	eb 12                	jmp    f011dbf1 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011dbdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dbe2:	89 d0                	mov    %edx,%eax
f011dbe4:	c1 e0 02             	shl    $0x2,%eax
f011dbe7:	01 d0                	add    %edx,%eax
f011dbe9:	01 c0                	add    %eax,%eax
f011dbeb:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011dbee:	ff 45 f0             	incl   -0x10(%ebp)
f011dbf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dbf4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011dbf7:	7c e6                	jl     f011dbdf <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011dbf9:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011dbfc:	83 ec 04             	sub    $0x4,%esp
f011dbff:	ff 75 f4             	pushl  -0xc(%ebp)
f011dc02:	ff 75 08             	pushl  0x8(%ebp)
f011dc05:	50                   	push   %eax
f011dc06:	e8 2f fd ff ff       	call   f011d93a <fix_scale>
f011dc0b:	83 c4 0c             	add    $0xc,%esp
f011dc0e:	83 ec 0c             	sub    $0xc,%esp
f011dc11:	ff 75 dc             	pushl  -0x24(%ebp)
f011dc14:	e8 eb fc ff ff       	call   f011d904 <fix_round>
f011dc19:	83 c4 10             	add    $0x10,%esp
f011dc1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011dc1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dc22:	99                   	cltd   
f011dc23:	f7 7d f4             	idivl  -0xc(%ebp)
f011dc26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011dc29:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dc2c:	99                   	cltd   
f011dc2d:	f7 7d f4             	idivl  -0xc(%ebp)
f011dc30:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011dc33:	83 ec 08             	sub    $0x8,%esp
f011dc36:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dc39:	50                   	push   %eax
f011dc3a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dc3d:	e8 6a 1e 00 00       	call   f011faac <ltostr>
f011dc42:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011dc45:	83 ec 08             	sub    $0x8,%esp
f011dc48:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011dc4b:	50                   	push   %eax
f011dc4c:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc4f:	e8 58 1e 00 00       	call   f011faac <ltostr>
f011dc54:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011dc57:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011dc5a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011dc5f:	f7 e9                	imul   %ecx
f011dc61:	c1 fa 02             	sar    $0x2,%edx
f011dc64:	89 c8                	mov    %ecx,%eax
f011dc66:	c1 f8 1f             	sar    $0x1f,%eax
f011dc69:	29 c2                	sub    %eax,%edx
f011dc6b:	89 d0                	mov    %edx,%eax
f011dc6d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011dc70:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011dc77:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011dc7e:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011dc84:	eb 31                	jmp    f011dcb7 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011dc86:	83 ec 04             	sub    $0x4,%esp
f011dc89:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dc8c:	50                   	push   %eax
f011dc8d:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dc90:	50                   	push   %eax
f011dc91:	68 90 03 13 f0       	push   $0xf0130390
f011dc96:	e8 ea 1e 00 00       	call   f011fb85 <strcconcat>
f011dc9b:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011dc9e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011dca1:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011dca6:	f7 e9                	imul   %ecx
f011dca8:	c1 fa 02             	sar    $0x2,%edx
f011dcab:	89 c8                	mov    %ecx,%eax
f011dcad:	c1 f8 1f             	sar    $0x1f,%eax
f011dcb0:	29 c2                	sub    %eax,%edx
f011dcb2:	89 d0                	mov    %edx,%eax
f011dcb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011dcb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dcba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dcbd:	7c c7                	jl     f011dc86 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011dcbf:	83 ec 04             	sub    $0x4,%esp
f011dcc2:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011dcc5:	50                   	push   %eax
f011dcc6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011dcc9:	50                   	push   %eax
f011dcca:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dccd:	50                   	push   %eax
f011dcce:	e8 b2 1e 00 00       	call   f011fb85 <strcconcat>
f011dcd3:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011dcd6:	83 ec 04             	sub    $0x4,%esp
f011dcd9:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dcdc:	50                   	push   %eax
f011dcdd:	68 92 03 13 f0       	push   $0xf0130392
f011dce2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dce5:	50                   	push   %eax
f011dce6:	e8 9a 1e 00 00       	call   f011fb85 <strcconcat>
f011dceb:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011dcee:	83 ec 04             	sub    $0x4,%esp
f011dcf1:	ff 75 10             	pushl  0x10(%ebp)
f011dcf4:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011dcf7:	50                   	push   %eax
f011dcf8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dcfb:	50                   	push   %eax
f011dcfc:	e8 84 1e 00 00       	call   f011fb85 <strcconcat>
f011dd01:	83 c4 10             	add    $0x10,%esp

}
f011dd04:	90                   	nop
f011dd05:	c9                   	leave  
f011dd06:	c3                   	ret    

f011dd07 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011dd07:	55                   	push   %ebp
f011dd08:	89 e5                	mov    %esp,%ebp
f011dd0a:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011dd10:	83 ec 0c             	sub    $0xc,%esp
f011dd13:	68 94 03 13 f0       	push   $0xf0130394
f011dd18:	e8 e9 18 00 00       	call   f011f606 <strlen>
f011dd1d:	83 c4 10             	add    $0x10,%esp
f011dd20:	83 ec 04             	sub    $0x4,%esp
f011dd23:	50                   	push   %eax
f011dd24:	68 94 03 13 f0       	push   $0xf0130394
f011dd29:	ff 75 08             	pushl  0x8(%ebp)
f011dd2c:	e8 19 1a 00 00       	call   f011f74a <strncmp>
f011dd31:	83 c4 10             	add    $0x10,%esp
f011dd34:	85 c0                	test   %eax,%eax
f011dd36:	0f 85 8a 00 00 00    	jne    f011ddc6 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011dd3c:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011dd3f:	50                   	push   %eax
f011dd40:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011dd46:	50                   	push   %eax
f011dd47:	68 a2 03 13 f0       	push   $0xf01303a2
f011dd4c:	ff 75 08             	pushl  0x8(%ebp)
f011dd4f:	e8 c7 1e 00 00       	call   f011fc1b <strsplit>
f011dd54:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011dd57:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011dd5d:	83 ec 04             	sub    $0x4,%esp
f011dd60:	6a 0a                	push   $0xa
f011dd62:	6a 00                	push   $0x0
f011dd64:	50                   	push   %eax
f011dd65:	e8 fc 1b 00 00       	call   f011f966 <strtol>
f011dd6a:	83 c4 10             	add    $0x10,%esp
f011dd6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011dd70:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011dd77:	83 ec 04             	sub    $0x4,%esp
f011dd7a:	6a 00                	push   $0x0
f011dd7c:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dd7f:	50                   	push   %eax
f011dd80:	ff 75 e0             	pushl  -0x20(%ebp)
f011dd83:	e8 6b d6 fe ff       	call   f010b3f3 <envid2env>
f011dd88:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011dd8b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011dd8e:	8b 40 10             	mov    0x10(%eax),%eax
f011dd91:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dd94:	74 19                	je     f011ddaf <sys_utilities+0xa8>
f011dd96:	68 a4 03 13 f0       	push   $0xf01303a4
f011dd9b:	68 e7 02 13 f0       	push   $0xf01302e7
f011dda0:	68 a4 00 00 00       	push   $0xa4
f011dda5:	68 2f 03 13 f0       	push   $0xf013032f
f011ddaa:	e8 8a 25 fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011ddaf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ddb2:	83 ec 08             	sub    $0x8,%esp
f011ddb5:	ff 75 0c             	pushl  0xc(%ebp)
f011ddb8:	50                   	push   %eax
f011ddb9:	e8 c8 88 fe ff       	call   f0106686 <env_set_nice>
f011ddbe:	83 c4 10             	add    $0x10,%esp
f011ddc1:	e9 12 04 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011ddc6:	83 ec 0c             	sub    $0xc,%esp
f011ddc9:	68 b9 03 13 f0       	push   $0xf01303b9
f011ddce:	e8 33 18 00 00       	call   f011f606 <strlen>
f011ddd3:	83 c4 10             	add    $0x10,%esp
f011ddd6:	83 ec 04             	sub    $0x4,%esp
f011ddd9:	50                   	push   %eax
f011ddda:	68 b9 03 13 f0       	push   $0xf01303b9
f011dddf:	ff 75 08             	pushl  0x8(%ebp)
f011dde2:	e8 63 19 00 00       	call   f011f74a <strncmp>
f011dde7:	83 c4 10             	add    $0x10,%esp
f011ddea:	85 c0                	test   %eax,%eax
f011ddec:	0f 85 a6 01 00 00    	jne    f011df98 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011ddf2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ddf5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011ddf8:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ddfb:	50                   	push   %eax
f011ddfc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011de02:	50                   	push   %eax
f011de03:	68 a2 03 13 f0       	push   $0xf01303a2
f011de08:	ff 75 08             	pushl  0x8(%ebp)
f011de0b:	e8 0b 1e 00 00       	call   f011fc1b <strsplit>
f011de10:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011de13:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011de19:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011de1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011de23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011de2a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011de31:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de34:	8b 00                	mov    (%eax),%eax
f011de36:	85 c0                	test   %eax,%eax
f011de38:	79 1c                	jns    f011de56 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011de3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011de41:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de44:	8b 00                	mov    (%eax),%eax
f011de46:	f7 d8                	neg    %eax
f011de48:	89 c2                	mov    %eax,%edx
f011de4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de4d:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011de4f:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011de56:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011de5d:	83 ec 0c             	sub    $0xc,%esp
f011de60:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011de65:	e8 db 17 ff ff       	call   f010f645 <acquire_spinlock>
f011de6a:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011de6d:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011de72:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011de75:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011de7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011de7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011de80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011de83:	eb 6c                	jmp    f011def1 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011de85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de88:	83 c0 20             	add    $0x20,%eax
f011de8b:	83 ec 08             	sub    $0x8,%esp
f011de8e:	ff 75 d8             	pushl  -0x28(%ebp)
f011de91:	50                   	push   %eax
f011de92:	e8 7b 18 00 00       	call   f011f712 <strcmp>
f011de97:	83 c4 10             	add    $0x10,%esp
f011de9a:	85 c0                	test   %eax,%eax
f011de9c:	75 46                	jne    f011dee4 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011de9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dea1:	8b 00                	mov    (%eax),%eax
f011dea3:	8d 50 ff             	lea    -0x1(%eax),%edx
f011dea6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dea9:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011deab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011deaf:	74 14                	je     f011dec5 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011deb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011deb4:	8b 40 10             	mov    0x10(%eax),%eax
f011deb7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011deba:	7d 1d                	jge    f011ded9 <sys_utilities+0x1d2>
					{
						success = 0;
f011debc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011dec3:	eb 32                	jmp    f011def7 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011dec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dec8:	8b 40 10             	mov    0x10(%eax),%eax
f011decb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dece:	7e 09                	jle    f011ded9 <sys_utilities+0x1d2>
					{
						success = 0;
f011ded0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011ded7:	eb 1e                	jmp    f011def7 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011ded9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dedc:	8b 40 10             	mov    0x10(%eax),%eax
f011dedf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011dee2:	eb 01                	jmp    f011dee5 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011dee4:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011dee5:	ff 4d e4             	decl   -0x1c(%ebp)
f011dee8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011deeb:	8b 40 0c             	mov    0xc(%eax),%eax
f011deee:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011def1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011def5:	7f 8e                	jg     f011de85 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011def7:	83 ec 0c             	sub    $0xc,%esp
f011defa:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011deff:	e8 c8 17 ff ff       	call   f010f6cc <release_spinlock>
f011df04:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011df07:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df0a:	8b 00                	mov    (%eax),%eax
f011df0c:	85 c0                	test   %eax,%eax
f011df0e:	75 06                	jne    f011df16 <sys_utilities+0x20f>
f011df10:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011df14:	75 41                	jne    f011df57 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011df16:	83 ec 0c             	sub    $0xc,%esp
f011df19:	68 cc 03 13 f0       	push   $0xf01303cc
f011df1e:	e8 68 30 fe ff       	call   f0100f8b <cprintf>
f011df23:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011df26:	83 ec 08             	sub    $0x8,%esp
f011df29:	ff 75 d8             	pushl  -0x28(%ebp)
f011df2c:	68 fc 03 13 f0       	push   $0xf01303fc
f011df31:	e8 55 30 fe ff       	call   f0100f8b <cprintf>
f011df36:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011df39:	83 ec 0c             	sub    $0xc,%esp
f011df3c:	68 cc 03 13 f0       	push   $0xf01303cc
f011df41:	e8 45 30 fe ff       	call   f0100f8b <cprintf>
f011df46:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011df49:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df4c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011df52:	e9 81 02 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011df57:	83 ec 0c             	sub    $0xc,%esp
f011df5a:	68 1c 04 13 f0       	push   $0xf013041c
f011df5f:	e8 27 30 fe ff       	call   f0100f8b <cprintf>
f011df64:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011df67:	83 ec 08             	sub    $0x8,%esp
f011df6a:	ff 75 d8             	pushl  -0x28(%ebp)
f011df6d:	68 54 04 13 f0       	push   $0xf0130454
f011df72:	e8 14 30 fe ff       	call   f0100f8b <cprintf>
f011df77:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011df7a:	83 ec 0c             	sub    $0xc,%esp
f011df7d:	68 1c 04 13 f0       	push   $0xf013041c
f011df82:	e8 04 30 fe ff       	call   f0100f8b <cprintf>
f011df87:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011df8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df8d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011df93:	e9 40 02 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011df98:	83 ec 08             	sub    $0x8,%esp
f011df9b:	68 77 04 13 f0       	push   $0xf0130477
f011dfa0:	ff 75 08             	pushl  0x8(%ebp)
f011dfa3:	e8 6a 17 00 00       	call   f011f712 <strcmp>
f011dfa8:	83 c4 10             	add    $0x10,%esp
f011dfab:	85 c0                	test   %eax,%eax
f011dfad:	75 77                	jne    f011e026 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011dfaf:	a1 e0 ed 17 f0       	mov    0xf017ede0,%eax
f011dfb4:	85 c0                	test   %eax,%eax
f011dfb6:	74 34                	je     f011dfec <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011dfb8:	c7 05 e0 ed 17 f0 00 	movl   $0x0,0xf017ede0
f011dfbf:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011dfc2:	83 ec 08             	sub    $0x8,%esp
f011dfc5:	68 81 04 13 f0       	push   $0xf0130481
f011dfca:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011dfcf:	e8 31 1a ff ff       	call   f010fa05 <init_channel>
f011dfd4:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011dfd7:	83 ec 08             	sub    $0x8,%esp
f011dfda:	68 8e 04 13 f0       	push   $0xf013048e
f011dfdf:	68 20 84 b0 f0       	push   $0xf0b08420
f011dfe4:	e8 2b 16 ff ff       	call   f010f614 <init_spinlock>
f011dfe9:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011dfec:	83 ec 0c             	sub    $0xc,%esp
f011dfef:	68 20 84 b0 f0       	push   $0xf0b08420
f011dff4:	e8 4c 16 ff ff       	call   f010f645 <acquire_spinlock>
f011dff9:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011dffc:	83 ec 08             	sub    $0x8,%esp
f011dfff:	68 20 84 b0 f0       	push   $0xf0b08420
f011e004:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011e009:	e8 24 1a ff ff       	call   f010fa32 <sleep>
f011e00e:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e011:	83 ec 0c             	sub    $0xc,%esp
f011e014:	68 20 84 b0 f0       	push   $0xf0b08420
f011e019:	e8 ae 16 ff ff       	call   f010f6cc <release_spinlock>
f011e01e:	83 c4 10             	add    $0x10,%esp
f011e021:	e9 b2 01 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e026:	83 ec 08             	sub    $0x8,%esp
f011e029:	68 a0 04 13 f0       	push   $0xf01304a0
f011e02e:	ff 75 08             	pushl  0x8(%ebp)
f011e031:	e8 dc 16 00 00       	call   f011f712 <strcmp>
f011e036:	83 c4 10             	add    $0x10,%esp
f011e039:	85 c0                	test   %eax,%eax
f011e03b:	75 15                	jne    f011e052 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e03d:	83 ec 0c             	sub    $0xc,%esp
f011e040:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011e045:	e8 55 1a ff ff       	call   f010fa9f <wakeup_one>
f011e04a:	83 c4 10             	add    $0x10,%esp
f011e04d:	e9 86 01 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e052:	83 ec 08             	sub    $0x8,%esp
f011e055:	68 ae 04 13 f0       	push   $0xf01304ae
f011e05a:	ff 75 08             	pushl  0x8(%ebp)
f011e05d:	e8 b0 16 00 00       	call   f011f712 <strcmp>
f011e062:	83 c4 10             	add    $0x10,%esp
f011e065:	85 c0                	test   %eax,%eax
f011e067:	75 15                	jne    f011e07e <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e069:	83 ec 0c             	sub    $0xc,%esp
f011e06c:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011e071:	e8 ad 1a ff ff       	call   f010fb23 <wakeup_all>
f011e076:	83 c4 10             	add    $0x10,%esp
f011e079:	e9 5a 01 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e07e:	83 ec 08             	sub    $0x8,%esp
f011e081:	68 bc 04 13 f0       	push   $0xf01304bc
f011e086:	ff 75 08             	pushl  0x8(%ebp)
f011e089:	e8 84 16 00 00       	call   f011f712 <strcmp>
f011e08e:	83 c4 10             	add    $0x10,%esp
f011e091:	85 c0                	test   %eax,%eax
f011e093:	75 17                	jne    f011e0ac <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e095:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e098:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e09b:	a1 ac 82 b0 f0       	mov    0xf0b082ac,%eax
f011e0a0:	89 c2                	mov    %eax,%edx
f011e0a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e0a5:	89 10                	mov    %edx,(%eax)
f011e0a7:	e9 2c 01 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e0ac:	83 ec 08             	sub    $0x8,%esp
f011e0af:	68 d1 04 13 f0       	push   $0xf01304d1
f011e0b4:	ff 75 08             	pushl  0x8(%ebp)
f011e0b7:	e8 56 16 00 00       	call   f011f712 <strcmp>
f011e0bc:	83 c4 10             	add    $0x10,%esp
f011e0bf:	85 c0                	test   %eax,%eax
f011e0c1:	75 1a                	jne    f011e0dd <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e0c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e0c6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e0c9:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e0ce:	8b 40 0c             	mov    0xc(%eax),%eax
f011e0d1:	89 c2                	mov    %eax,%edx
f011e0d3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e0d6:	89 10                	mov    %edx,(%eax)
f011e0d8:	e9 fb 00 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e0dd:	83 ec 08             	sub    $0x8,%esp
f011e0e0:	68 e7 04 13 f0       	push   $0xf01304e7
f011e0e5:	ff 75 08             	pushl  0x8(%ebp)
f011e0e8:	e8 25 16 00 00       	call   f011f712 <strcmp>
f011e0ed:	83 c4 10             	add    $0x10,%esp
f011e0f0:	85 c0                	test   %eax,%eax
f011e0f2:	75 3d                	jne    f011e131 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e0f4:	a1 e4 ed 17 f0       	mov    0xf017ede4,%eax
f011e0f9:	85 c0                	test   %eax,%eax
f011e0fb:	74 1f                	je     f011e11c <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e0fd:	c7 05 e4 ed 17 f0 00 	movl   $0x0,0xf017ede4
f011e104:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e107:	83 ec 08             	sub    $0x8,%esp
f011e10a:	68 fc 04 13 f0       	push   $0xf01304fc
f011e10f:	68 00 83 b0 f0       	push   $0xf0b08300
f011e114:	e8 86 17 ff ff       	call   f010f89f <init_sleeplock>
f011e119:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e11c:	83 ec 0c             	sub    $0xc,%esp
f011e11f:	68 00 83 b0 f0       	push   $0xf0b08300
f011e124:	e8 3a 18 ff ff       	call   f010f963 <acquire_sleeplock>
f011e129:	83 c4 10             	add    $0x10,%esp
f011e12c:	e9 a7 00 00 00       	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e131:	83 ec 08             	sub    $0x8,%esp
f011e134:	68 0c 05 13 f0       	push   $0xf013050c
f011e139:	ff 75 08             	pushl  0x8(%ebp)
f011e13c:	e8 d1 15 00 00       	call   f011f712 <strcmp>
f011e141:	83 c4 10             	add    $0x10,%esp
f011e144:	85 c0                	test   %eax,%eax
f011e146:	75 12                	jne    f011e15a <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e148:	83 ec 0c             	sub    $0xc,%esp
f011e14b:	68 00 83 b0 f0       	push   $0xf0b08300
f011e150:	e8 68 18 ff ff       	call   f010f9bd <release_sleeplock>
f011e155:	83 c4 10             	add    $0x10,%esp
f011e158:	eb 7e                	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e15a:	83 ec 08             	sub    $0x8,%esp
f011e15d:	68 21 05 13 f0       	push   $0xf0130521
f011e162:	ff 75 08             	pushl  0x8(%ebp)
f011e165:	e8 a8 15 00 00       	call   f011f712 <strcmp>
f011e16a:	83 c4 10             	add    $0x10,%esp
f011e16d:	85 c0                	test   %eax,%eax
f011e16f:	75 14                	jne    f011e185 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e171:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e174:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e177:	a1 80 83 b0 f0       	mov    0xf0b08380,%eax
f011e17c:	89 c2                	mov    %eax,%edx
f011e17e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e181:	89 10                	mov    %edx,(%eax)
f011e183:	eb 53                	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e185:	83 ec 08             	sub    $0x8,%esp
f011e188:	68 36 05 13 f0       	push   $0xf0130536
f011e18d:	ff 75 08             	pushl  0x8(%ebp)
f011e190:	e8 7d 15 00 00       	call   f011f712 <strcmp>
f011e195:	83 c4 10             	add    $0x10,%esp
f011e198:	85 c0                	test   %eax,%eax
f011e19a:	75 13                	jne    f011e1af <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e19c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e19f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e1a2:	8b 15 00 83 b0 f0    	mov    0xf0b08300,%edx
f011e1a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e1ab:	89 10                	mov    %edx,(%eax)
f011e1ad:	eb 29                	jmp    f011e1d8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e1af:	83 ec 08             	sub    $0x8,%esp
f011e1b2:	68 47 05 13 f0       	push   $0xf0130547
f011e1b7:	ff 75 08             	pushl  0x8(%ebp)
f011e1ba:	e8 53 15 00 00       	call   f011f712 <strcmp>
f011e1bf:	83 c4 10             	add    $0x10,%esp
f011e1c2:	85 c0                	test   %eax,%eax
f011e1c4:	75 12                	jne    f011e1d8 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e1c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e1c9:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e1cc:	a1 04 84 b0 f0       	mov    0xf0b08404,%eax
f011e1d1:	89 c2                	mov    %eax,%edx
f011e1d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e1d6:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e1d8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e1dc:	79 5b                	jns    f011e239 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e1de:	83 ec 08             	sub    $0x8,%esp
f011e1e1:	68 58 05 13 f0       	push   $0xf0130558
f011e1e6:	ff 75 08             	pushl  0x8(%ebp)
f011e1e9:	e8 24 15 00 00       	call   f011f712 <strcmp>
f011e1ee:	83 c4 10             	add    $0x10,%esp
f011e1f1:	85 c0                	test   %eax,%eax
f011e1f3:	75 44                	jne    f011e239 <sys_utilities+0x532>
		{
			switch (value)
f011e1f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e1f8:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e1fb:	74 07                	je     f011e204 <sys_utilities+0x4fd>
f011e1fd:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e200:	74 19                	je     f011e21b <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e202:	eb 35                	jmp    f011e239 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e204:	83 ec 0c             	sub    $0xc,%esp
f011e207:	68 68 05 13 f0       	push   $0xf0130568
f011e20c:	e8 7a 2d fe ff       	call   f0100f8b <cprintf>
f011e211:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e214:	e8 7e 0d ff ff       	call   f010ef97 <setPageReplacmentAlgorithmFIFO>
				break;
f011e219:	eb 1e                	jmp    f011e239 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e21b:	83 ec 0c             	sub    $0xc,%esp
f011e21e:	68 d8 05 13 f0       	push   $0xf01305d8
f011e223:	e8 63 2d fe ff       	call   f0100f8b <cprintf>
f011e228:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e22b:	83 ec 0c             	sub    $0xc,%esp
f011e22e:	6a 02                	push   $0x2
f011e230:	e8 1f 0d ff ff       	call   f010ef54 <setPageReplacmentAlgorithmLRU>
f011e235:	83 c4 10             	add    $0x10,%esp
				break;
f011e238:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e239:	90                   	nop
f011e23a:	c9                   	leave  
f011e23b:	c3                   	ret    

f011e23c <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e23c:	55                   	push   %ebp
f011e23d:	89 e5                	mov    %esp,%ebp
f011e23f:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e242:	8b 45 08             	mov    0x8(%ebp),%eax
f011e245:	8b 00                	mov    (%eax),%eax
f011e247:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e24a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e24d:	8b 00                	mov    (%eax),%eax
f011e24f:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e252:	eb 52                	jmp    f011e2a6 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e254:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e257:	8b 00                	mov    (%eax),%eax
f011e259:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e25c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e25f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e262:	75 12                	jne    f011e276 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e264:	83 ec 0c             	sub    $0xc,%esp
f011e267:	68 4c 06 13 f0       	push   $0xf013064c
f011e26c:	e8 1a 2d fe ff       	call   f0100f8b <cprintf>
f011e271:	83 c4 10             	add    $0x10,%esp
			break;
f011e274:	eb 3f                	jmp    f011e2b5 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e276:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e27a:	74 38                	je     f011e2b4 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e27c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e27f:	8b 00                	mov    (%eax),%eax
f011e281:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e284:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e287:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e28a:	75 12                	jne    f011e29e <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e28c:	83 ec 0c             	sub    $0xc,%esp
f011e28f:	68 68 06 13 f0       	push   $0xf0130668
f011e294:	e8 f2 2c fe ff       	call   f0100f8b <cprintf>
f011e299:	83 c4 10             	add    $0x10,%esp
			break;
f011e29c:	eb 17                	jmp    f011e2b5 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e29e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e2a1:	8b 00                	mov    (%eax),%eax
f011e2a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e2a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e2aa:	74 09                	je     f011e2b5 <detect_loop_in_FrameInfo_list+0x79>
f011e2ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e2b0:	75 a2                	jne    f011e254 <detect_loop_in_FrameInfo_list+0x18>
f011e2b2:	eb 01                	jmp    f011e2b5 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e2b4:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e2b5:	83 ec 0c             	sub    $0xc,%esp
f011e2b8:	68 7f 06 13 f0       	push   $0xf013067f
f011e2bd:	e8 c9 2c fe ff       	call   f0100f8b <cprintf>
f011e2c2:	83 c4 10             	add    $0x10,%esp
}
f011e2c5:	90                   	nop
f011e2c6:	c9                   	leave  
f011e2c7:	c3                   	ret    

f011e2c8 <scarce_memory>:

void scarce_memory()
{
f011e2c8:	55                   	push   %ebp
f011e2c9:	89 e5                	mov    %esp,%ebp
f011e2cb:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e2ce:	a1 90 d4 6b f0       	mov    0xf06bd490,%eax
f011e2d3:	ba 64 00 00 00       	mov    $0x64,%edx
f011e2d8:	29 c2                	sub    %eax,%edx
f011e2da:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011e2df:	0f af c2             	imul   %edx,%eax
f011e2e2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e2e7:	f7 e2                	mul    %edx
f011e2e9:	89 d0                	mov    %edx,%eax
f011e2eb:	c1 e8 05             	shr    $0x5,%eax
f011e2ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e2f1:	a1 90 d4 6b f0       	mov    0xf06bd490,%eax
f011e2f6:	ba 64 00 00 00       	mov    $0x64,%edx
f011e2fb:	29 c2                	sub    %eax,%edx
f011e2fd:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011e302:	89 d1                	mov    %edx,%ecx
f011e304:	0f af c8             	imul   %eax,%ecx
f011e307:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e30c:	f7 e1                	mul    %ecx
f011e30e:	c1 ea 05             	shr    $0x5,%edx
f011e311:	89 d0                	mov    %edx,%eax
f011e313:	c1 e0 02             	shl    $0x2,%eax
f011e316:	01 d0                	add    %edx,%eax
f011e318:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e31f:	01 d0                	add    %edx,%eax
f011e321:	c1 e0 02             	shl    $0x2,%eax
f011e324:	29 c1                	sub    %eax,%ecx
f011e326:	89 ca                	mov    %ecx,%edx
f011e328:	85 d2                	test   %edx,%edx
f011e32a:	74 03                	je     f011e32f <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e32c:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e32f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e336:	83 ec 0c             	sub    $0xc,%esp
f011e339:	68 80 d3 6b f0       	push   $0xf06bd380
f011e33e:	e8 02 13 ff ff       	call   f010f645 <acquire_spinlock>
f011e343:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e346:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f011e34b:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e34e:	8b 15 58 d5 6b f0    	mov    0xf06bd558,%edx
f011e354:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e357:	29 c2                	sub    %eax,%edx
f011e359:	89 d0                	mov    %edx,%eax
f011e35b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e35e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e361:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e364:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e367:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e36e:	eb 12                	jmp    f011e382 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e370:	83 ec 0c             	sub    $0xc,%esp
f011e373:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e376:	50                   	push   %eax
f011e377:	e8 36 9e fe ff       	call   f01081b2 <allocate_frame>
f011e37c:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e37f:	ff 45 f0             	incl   -0x10(%ebp)
f011e382:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e385:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e388:	76 e6                	jbe    f011e370 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011e38a:	83 ec 0c             	sub    $0xc,%esp
f011e38d:	68 80 d3 6b f0       	push   $0xf06bd380
f011e392:	e8 35 13 ff ff       	call   f010f6cc <release_spinlock>
f011e397:	83 c4 10             	add    $0x10,%esp

}
f011e39a:	90                   	nop
f011e39b:	c9                   	leave  
f011e39c:	c3                   	ret    

f011e39d <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011e39d:	55                   	push   %ebp
f011e39e:	89 e5                	mov    %esp,%ebp
f011e3a0:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011e3a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011e3aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011e3b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011e3b8:	e8 e6 cf fe ff       	call   f010b3a3 <get_cpu_proc>
f011e3bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011e3c0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e3c4:	75 19                	jne    f011e3df <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011e3c6:	68 99 06 13 f0       	push   $0xf0130699
f011e3cb:	68 e7 02 13 f0       	push   $0xf01302e7
f011e3d0:	68 79 01 00 00       	push   $0x179
f011e3d5:	68 2f 03 13 f0       	push   $0xf013032f
f011e3da:	e8 5a 1f fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011e3df:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e3e3:	0f 85 d6 01 00 00    	jne    f011e5bf <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011e3e9:	83 ec 0c             	sub    $0xc,%esp
f011e3ec:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e3f1:	e8 4f 12 ff ff       	call   f010f645 <acquire_spinlock>
f011e3f6:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e3f9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011e400:	e9 d2 00 00 00       	jmp    f011e4d7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011e405:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e40c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e411:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e414:	c1 e2 04             	shl    $0x4,%edx
f011e417:	01 d0                	add    %edx,%eax
f011e419:	8b 00                	mov    (%eax),%eax
f011e41b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e41e:	eb 7c                	jmp    f011e49c <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011e420:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e423:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e429:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e42c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e42f:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e435:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e438:	0f af c2             	imul   %edx,%eax
f011e43b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e440:	f7 e2                	mul    %edx
f011e442:	89 d0                	mov    %edx,%eax
f011e444:	c1 e8 05             	shr    $0x5,%eax
f011e447:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e44a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e44d:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e453:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e456:	89 d1                	mov    %edx,%ecx
f011e458:	0f af c8             	imul   %eax,%ecx
f011e45b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e460:	f7 e1                	mul    %ecx
f011e462:	c1 ea 05             	shr    $0x5,%edx
f011e465:	89 d0                	mov    %edx,%eax
f011e467:	c1 e0 02             	shl    $0x2,%eax
f011e46a:	01 d0                	add    %edx,%eax
f011e46c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e473:	01 d0                	add    %edx,%eax
f011e475:	c1 e0 02             	shl    $0x2,%eax
f011e478:	29 c1                	sub    %eax,%ecx
f011e47a:	89 ca                	mov    %ecx,%edx
f011e47c:	85 d2                	test   %edx,%edx
f011e47e:	74 03                	je     f011e483 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011e480:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011e483:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e486:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e489:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e48e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e491:	c1 e2 04             	shl    $0x4,%edx
f011e494:	01 d0                	add    %edx,%eax
f011e496:	8b 40 08             	mov    0x8(%eax),%eax
f011e499:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e49c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e4a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e4a4:	c1 e2 04             	shl    $0x4,%edx
f011e4a7:	01 d0                	add    %edx,%eax
f011e4a9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e4ad:	74 08                	je     f011e4b7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011e4af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011e4b2:	8b 52 08             	mov    0x8(%edx),%edx
f011e4b5:	eb 05                	jmp    f011e4bc <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011e4b7:	ba 00 00 00 00       	mov    $0x0,%edx
f011e4bc:	89 50 08             	mov    %edx,0x8(%eax)
f011e4bf:	8b 40 08             	mov    0x8(%eax),%eax
f011e4c2:	85 c0                	test   %eax,%eax
f011e4c4:	0f 85 56 ff ff ff    	jne    f011e420 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011e4ca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e4ce:	0f 85 4c ff ff ff    	jne    f011e420 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e4d4:	ff 45 e8             	incl   -0x18(%ebp)
f011e4d7:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e4dc:	0f b6 c0             	movzbl %al,%eax
f011e4df:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e4e2:	0f 8f 1d ff ff ff    	jg     f011e405 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011e4e8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e4ef:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f011e4f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e4f7:	eb 1a                	jmp    f011e513 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011e4f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4fc:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e502:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011e505:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e508:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e50b:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011e510:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e513:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e517:	74 08                	je     f011e521 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011e519:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e51c:	8b 40 08             	mov    0x8(%eax),%eax
f011e51f:	eb 05                	jmp    f011e526 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011e521:	b8 00 00 00 00       	mov    $0x0,%eax
f011e526:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f011e52b:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011e530:	85 c0                	test   %eax,%eax
f011e532:	75 c5                	jne    f011e4f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011e534:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e538:	75 bf                	jne    f011e4f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e53a:	83 ec 0c             	sub    $0xc,%esp
f011e53d:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e542:	e8 85 11 ff ff       	call   f010f6cc <release_spinlock>
f011e547:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011e54a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e54e:	0f 84 d4 00 00 00    	je     f011e628 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e554:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e557:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e55d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e560:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e563:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e569:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e56c:	0f af c2             	imul   %edx,%eax
f011e56f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e574:	f7 e2                	mul    %edx
f011e576:	89 d0                	mov    %edx,%eax
f011e578:	c1 e8 05             	shr    $0x5,%eax
f011e57b:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e57e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e581:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e587:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e58a:	89 d1                	mov    %edx,%ecx
f011e58c:	0f af c8             	imul   %eax,%ecx
f011e58f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e594:	f7 e1                	mul    %ecx
f011e596:	c1 ea 05             	shr    $0x5,%edx
f011e599:	89 d0                	mov    %edx,%eax
f011e59b:	c1 e0 02             	shl    $0x2,%eax
f011e59e:	01 d0                	add    %edx,%eax
f011e5a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e5a7:	01 d0                	add    %edx,%eax
f011e5a9:	c1 e0 02             	shl    $0x2,%eax
f011e5ac:	29 c1                	sub    %eax,%ecx
f011e5ae:	89 ca                	mov    %ecx,%edx
f011e5b0:	85 d2                	test   %edx,%edx
f011e5b2:	74 03                	je     f011e5b7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011e5b4:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e5b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011e5ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e5bd:	eb 69                	jmp    f011e628 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e5bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e5c2:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e5c8:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e5cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e5ce:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e5d4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e5d7:	0f af c2             	imul   %edx,%eax
f011e5da:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e5df:	f7 e2                	mul    %edx
f011e5e1:	89 d0                	mov    %edx,%eax
f011e5e3:	c1 e8 05             	shr    $0x5,%eax
f011e5e6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e5e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e5ec:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e5f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e5f5:	89 d1                	mov    %edx,%ecx
f011e5f7:	0f af c8             	imul   %eax,%ecx
f011e5fa:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e5ff:	f7 e1                	mul    %ecx
f011e601:	c1 ea 05             	shr    $0x5,%edx
f011e604:	89 d0                	mov    %edx,%eax
f011e606:	c1 e0 02             	shl    $0x2,%eax
f011e609:	01 d0                	add    %edx,%eax
f011e60b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e612:	01 d0                	add    %edx,%eax
f011e614:	c1 e0 02             	shl    $0x2,%eax
f011e617:	29 c1                	sub    %eax,%ecx
f011e619:	89 ca                	mov    %ecx,%edx
f011e61b:	85 d2                	test   %edx,%edx
f011e61d:	74 03                	je     f011e622 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011e61f:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e622:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e625:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011e628:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e62b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e62e:	01 c2                	add    %eax,%edx
f011e630:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e633:	01 d0                	add    %edx,%eax
}
f011e635:	c9                   	leave  
f011e636:	c3                   	ret    

f011e637 <schenv>:


void schenv()
{
f011e637:	55                   	push   %ebp
f011e638:	89 e5                	mov    %esp,%ebp
f011e63a:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011e63d:	c6 05 a0 da 6b f0 00 	movb   $0x0,0xf06bdaa0
	__ne = NULL;
f011e644:	c7 05 ac d7 6b f0 00 	movl   $0x0,0xf06bd7ac
f011e64b:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011e64e:	83 ec 0c             	sub    $0xc,%esp
f011e651:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e656:	e8 ea 0f ff ff       	call   f010f645 <acquire_spinlock>
f011e65b:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e65e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e665:	eb 3f                	jmp    f011e6a6 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011e667:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e66c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e66f:	c1 e2 04             	shl    $0x4,%edx
f011e672:	01 d0                	add    %edx,%eax
f011e674:	83 ec 0c             	sub    $0xc,%esp
f011e677:	50                   	push   %eax
f011e678:	e8 15 69 fe ff       	call   f0104f92 <queue_size>
f011e67d:	83 c4 10             	add    $0x10,%esp
f011e680:	85 c0                	test   %eax,%eax
f011e682:	74 1f                	je     f011e6a3 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011e684:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e689:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e68c:	c1 e2 04             	shl    $0x4,%edx
f011e68f:	01 d0                	add    %edx,%eax
f011e691:	8b 40 04             	mov    0x4(%eax),%eax
f011e694:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
				__nl = i;
f011e699:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e69c:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
				break;
f011e6a1:	eb 10                	jmp    f011e6b3 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e6a3:	ff 45 f4             	incl   -0xc(%ebp)
f011e6a6:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e6ab:	0f b6 c0             	movzbl %al,%eax
f011e6ae:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e6b1:	7f b4                	jg     f011e667 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011e6b3:	83 ec 0c             	sub    $0xc,%esp
f011e6b6:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e6bb:	e8 0c 10 ff ff       	call   f010f6cc <release_spinlock>
f011e6c0:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011e6c3:	e8 db cc fe ff       	call   f010b3a3 <get_cpu_proc>
f011e6c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011e6cb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e6cf:	0f 84 82 00 00 00    	je     f011e757 <schenv+0x120>
	{
		if (__ne != NULL)
f011e6d5:	a1 ac d7 6b f0       	mov    0xf06bd7ac,%eax
f011e6da:	85 c0                	test   %eax,%eax
f011e6dc:	74 49                	je     f011e727 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011e6de:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6e3:	0f b6 c0             	movzbl %al,%eax
f011e6e6:	8d 50 01             	lea    0x1(%eax),%edx
f011e6e9:	a0 a0 da 6b f0       	mov    0xf06bdaa0,%al
f011e6ee:	0f b6 c0             	movzbl %al,%eax
f011e6f1:	39 c2                	cmp    %eax,%edx
f011e6f3:	7d 62                	jge    f011e757 <schenv+0x120>
			{
				__ne = cur_env;
f011e6f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e6f8:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e6fd:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e702:	0f b6 c0             	movzbl %al,%eax
f011e705:	8a 15 04 da 6b f0    	mov    0xf06bda04,%dl
f011e70b:	0f b6 d2             	movzbl %dl,%edx
f011e70e:	4a                   	dec    %edx
f011e70f:	39 d0                	cmp    %edx,%eax
f011e711:	7d 08                	jge    f011e71b <schenv+0xe4>
f011e713:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e718:	40                   	inc    %eax
f011e719:	eb 05                	jmp    f011e720 <schenv+0xe9>
f011e71b:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e720:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011e725:	eb 30                	jmp    f011e757 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011e727:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e72a:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e72f:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e734:	0f b6 c0             	movzbl %al,%eax
f011e737:	8a 15 04 da 6b f0    	mov    0xf06bda04,%dl
f011e73d:	0f b6 d2             	movzbl %dl,%edx
f011e740:	4a                   	dec    %edx
f011e741:	39 d0                	cmp    %edx,%eax
f011e743:	7d 08                	jge    f011e74d <schenv+0x116>
f011e745:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e74a:	40                   	inc    %eax
f011e74b:	eb 05                	jmp    f011e752 <schenv+0x11b>
f011e74d:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e752:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
		}
	}
}
f011e757:	90                   	nop
f011e758:	c9                   	leave  
f011e759:	c3                   	ret    

f011e75a <chksch>:

void chksch(uint8 onoff)
{
f011e75a:	55                   	push   %ebp
f011e75b:	89 e5                	mov    %esp,%ebp
f011e75d:	83 ec 18             	sub    $0x18,%esp
f011e760:	8b 45 08             	mov    0x8(%ebp),%eax
f011e763:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e766:	e8 a7 7f fe ff       	call   f0106712 <isSchedMethodBSD>
f011e76b:	85 c0                	test   %eax,%eax
f011e76d:	74 48                	je     f011e7b7 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011e76f:	e8 4c 7f fe ff       	call   f01066c0 <get_load_average>
f011e774:	a3 28 da 6b f0       	mov    %eax,0xf06bda28
f011e779:	a1 28 da 6b f0       	mov    0xf06bda28,%eax
f011e77e:	a3 5c d5 6b f0       	mov    %eax,0xf06bd55c
		acquire_spinlock(&ProcessQueues.qlock);
f011e783:	83 ec 0c             	sub    $0xc,%esp
f011e786:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e78b:	e8 b5 0e ff ff       	call   f010f645 <acquire_spinlock>
f011e790:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011e793:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011e798:	a3 00 d4 6b f0       	mov    %eax,0xf06bd400
		}
		release_spinlock(&ProcessQueues.qlock);
f011e79d:	83 ec 0c             	sub    $0xc,%esp
f011e7a0:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e7a5:	e8 22 0f ff ff       	call   f010f6cc <release_spinlock>
f011e7aa:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011e7ad:	c7 05 bc d7 6b f0 01 	movl   $0x1,0xf06bd7bc
f011e7b4:	00 00 00 
	}
	__chkstatus = onoff;
f011e7b7:	8a 45 f4             	mov    -0xc(%ebp),%al
f011e7ba:	a2 a8 d7 6b f0       	mov    %al,0xf06bd7a8
}
f011e7bf:	90                   	nop
f011e7c0:	c9                   	leave  
f011e7c1:	c3                   	ret    

f011e7c2 <chk1>:
void chk1()
{
f011e7c2:	55                   	push   %ebp
f011e7c3:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011e7c5:	90                   	nop
f011e7c6:	5d                   	pop    %ebp
f011e7c7:	c3                   	ret    

f011e7c8 <chk2>:
void chk2(struct Env* __se)
{
f011e7c8:	55                   	push   %ebp
f011e7c9:	89 e5                	mov    %esp,%ebp
f011e7cb:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011e7ce:	a0 a8 d7 6b f0       	mov    0xf06bd7a8,%al
f011e7d3:	84 c0                	test   %al,%al
f011e7d5:	0f 84 59 03 00 00    	je     f011eb34 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e7db:	e8 32 7f fe ff       	call   f0106712 <isSchedMethodBSD>
f011e7e0:	85 c0                	test   %eax,%eax
f011e7e2:	0f 84 4d 03 00 00    	je     f011eb35 <chk2+0x36d>
	{
		__nla = get_load_average();
f011e7e8:	e8 d3 7e fe ff       	call   f01066c0 <get_load_average>
f011e7ed:	a3 94 d4 6b f0       	mov    %eax,0xf06bd494
		acquire_spinlock(&ProcessQueues.qlock);
f011e7f2:	83 ec 0c             	sub    $0xc,%esp
f011e7f5:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e7fa:	e8 46 0e ff ff       	call   f010f645 <acquire_spinlock>
f011e7ff:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e802:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011e807:	a3 b0 d7 6b f0       	mov    %eax,0xf06bd7b0
		}
		release_spinlock(&ProcessQueues.qlock);
f011e80c:	83 ec 0c             	sub    $0xc,%esp
f011e80f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e814:	e8 b3 0e ff ff       	call   f010f6cc <release_spinlock>
f011e819:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011e81c:	a1 bc d7 6b f0       	mov    0xf06bd7bc,%eax
f011e821:	85 c0                	test   %eax,%eax
f011e823:	74 72                	je     f011e897 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011e825:	83 ec 0c             	sub    $0xc,%esp
f011e828:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e82d:	e8 13 0e ff ff       	call   f010f645 <acquire_spinlock>
f011e832:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011e835:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e839:	0f 95 c0             	setne  %al
f011e83c:	0f b6 c0             	movzbl %al,%eax
f011e83f:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e844:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e849:	0f b6 c0             	movzbl %al,%eax
f011e84c:	48                   	dec    %eax
f011e84d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e850:	eb 20                	jmp    f011e872 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e852:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e857:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e85a:	c1 e2 04             	shl    $0x4,%edx
f011e85d:	01 d0                	add    %edx,%eax
f011e85f:	8b 40 0c             	mov    0xc(%eax),%eax
f011e862:	8b 15 74 d9 6b f0    	mov    0xf06bd974,%edx
f011e868:	01 d0                	add    %edx,%eax
f011e86a:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e86f:	ff 4d f4             	decl   -0xc(%ebp)
f011e872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e876:	79 da                	jns    f011e852 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011e878:	c7 05 bc d7 6b f0 00 	movl   $0x0,0xf06bd7bc
f011e87f:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011e882:	83 ec 0c             	sub    $0xc,%esp
f011e885:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e88a:	e8 3d 0e ff ff       	call   f010f6cc <release_spinlock>
f011e88f:	83 c4 10             	add    $0x10,%esp
f011e892:	e9 91 02 00 00       	jmp    f011eb28 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011e897:	8b 15 00 d4 6b f0    	mov    0xf06bd400,%edx
f011e89d:	a1 b0 d7 6b f0       	mov    0xf06bd7b0,%eax
f011e8a2:	39 c2                	cmp    %eax,%edx
f011e8a4:	74 63                	je     f011e909 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011e8a6:	83 ec 0c             	sub    $0xc,%esp
f011e8a9:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e8ae:	e8 92 0d ff ff       	call   f010f645 <acquire_spinlock>
f011e8b3:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011e8b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e8ba:	0f 95 c0             	setne  %al
f011e8bd:	0f b6 c0             	movzbl %al,%eax
f011e8c0:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e8c5:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e8ca:	0f b6 c0             	movzbl %al,%eax
f011e8cd:	48                   	dec    %eax
f011e8ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e8d1:	eb 20                	jmp    f011e8f3 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e8d3:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e8d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011e8db:	c1 e2 04             	shl    $0x4,%edx
f011e8de:	01 d0                	add    %edx,%eax
f011e8e0:	8b 40 0c             	mov    0xc(%eax),%eax
f011e8e3:	8b 15 74 d9 6b f0    	mov    0xf06bd974,%edx
f011e8e9:	01 d0                	add    %edx,%eax
f011e8eb:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e8f0:	ff 4d f0             	decl   -0x10(%ebp)
f011e8f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e8f7:	79 da                	jns    f011e8d3 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011e8f9:	83 ec 0c             	sub    $0xc,%esp
f011e8fc:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e901:	e8 c6 0d ff ff       	call   f010f6cc <release_spinlock>
f011e906:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011e909:	e8 4b 7d fe ff       	call   f0106659 <timer_ticks>
f011e90e:	6a 00                	push   $0x0
f011e910:	68 e8 03 00 00       	push   $0x3e8
f011e915:	52                   	push   %edx
f011e916:	50                   	push   %eax
f011e917:	e8 f0 31 00 00       	call   f0121b0c <__moddi3>
f011e91c:	83 c4 10             	add    $0x10,%esp
f011e91f:	09 d0                	or     %edx,%eax
f011e921:	85 c0                	test   %eax,%eax
f011e923:	75 32                	jne    f011e957 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011e925:	8b 15 5c d5 6b f0    	mov    0xf06bd55c,%edx
f011e92b:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011e930:	39 c2                	cmp    %eax,%edx
f011e932:	75 19                	jne    f011e94d <chk2+0x185>
f011e934:	68 a9 06 13 f0       	push   $0xf01306a9
f011e939:	68 e7 02 13 f0       	push   $0xf01302e7
f011e93e:	68 35 02 00 00       	push   $0x235
f011e943:	68 2f 03 13 f0       	push   $0xf013032f
f011e948:	e8 7c 1a fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011e94d:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011e952:	a3 5c d5 6b f0       	mov    %eax,0xf06bd55c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011e957:	e8 fd 7c fe ff       	call   f0106659 <timer_ticks>
f011e95c:	6a 00                	push   $0x0
f011e95e:	6a 64                	push   $0x64
f011e960:	52                   	push   %edx
f011e961:	50                   	push   %eax
f011e962:	e8 a5 31 00 00       	call   f0121b0c <__moddi3>
f011e967:	83 c4 10             	add    $0x10,%esp
f011e96a:	09 d0                	or     %edx,%eax
f011e96c:	85 c0                	test   %eax,%eax
f011e96e:	0f 85 b4 01 00 00    	jne    f011eb28 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011e974:	8b 0d 28 da 6b f0    	mov    0xf06bda28,%ecx
f011e97a:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e97f:	f7 e9                	imul   %ecx
f011e981:	c1 fa 05             	sar    $0x5,%edx
f011e984:	89 c8                	mov    %ecx,%eax
f011e986:	c1 f8 1f             	sar    $0x1f,%eax
f011e989:	29 c2                	sub    %eax,%edx
f011e98b:	89 d0                	mov    %edx,%eax
f011e98d:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011e990:	8b 0d 28 da 6b f0    	mov    0xf06bda28,%ecx
f011e996:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e99b:	f7 e9                	imul   %ecx
f011e99d:	c1 fa 05             	sar    $0x5,%edx
f011e9a0:	89 c8                	mov    %ecx,%eax
f011e9a2:	c1 f8 1f             	sar    $0x1f,%eax
f011e9a5:	29 c2                	sub    %eax,%edx
f011e9a7:	89 d0                	mov    %edx,%eax
f011e9a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011e9ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e9af:	89 d0                	mov    %edx,%eax
f011e9b1:	c1 e0 02             	shl    $0x2,%eax
f011e9b4:	01 d0                	add    %edx,%eax
f011e9b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e9bd:	01 d0                	add    %edx,%eax
f011e9bf:	c1 e0 02             	shl    $0x2,%eax
f011e9c2:	29 c1                	sub    %eax,%ecx
f011e9c4:	89 c8                	mov    %ecx,%eax
f011e9c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011e9c9:	8b 0d 94 d4 6b f0    	mov    0xf06bd494,%ecx
f011e9cf:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e9d4:	f7 e9                	imul   %ecx
f011e9d6:	c1 fa 05             	sar    $0x5,%edx
f011e9d9:	89 c8                	mov    %ecx,%eax
f011e9db:	c1 f8 1f             	sar    $0x1f,%eax
f011e9de:	29 c2                	sub    %eax,%edx
f011e9e0:	89 d0                	mov    %edx,%eax
f011e9e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011e9e5:	8b 0d 94 d4 6b f0    	mov    0xf06bd494,%ecx
f011e9eb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e9f0:	f7 e9                	imul   %ecx
f011e9f2:	c1 fa 05             	sar    $0x5,%edx
f011e9f5:	89 c8                	mov    %ecx,%eax
f011e9f7:	c1 f8 1f             	sar    $0x1f,%eax
f011e9fa:	29 c2                	sub    %eax,%edx
f011e9fc:	89 d0                	mov    %edx,%eax
f011e9fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011ea01:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ea04:	89 d0                	mov    %edx,%eax
f011ea06:	c1 e0 02             	shl    $0x2,%eax
f011ea09:	01 d0                	add    %edx,%eax
f011ea0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ea12:	01 d0                	add    %edx,%eax
f011ea14:	c1 e0 02             	shl    $0x2,%eax
f011ea17:	29 c1                	sub    %eax,%ecx
f011ea19:	89 c8                	mov    %ecx,%eax
f011ea1b:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011ea1e:	8b 15 b0 d7 6b f0    	mov    0xf06bd7b0,%edx
f011ea24:	a1 00 d4 6b f0       	mov    0xf06bd400,%eax
f011ea29:	39 c2                	cmp    %eax,%edx
f011ea2b:	0f 85 ed 00 00 00    	jne    f011eb1e <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011ea31:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011ea36:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea39:	7e 5b                	jle    f011ea96 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011ea3b:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011ea40:	83 ec 08             	sub    $0x8,%esp
f011ea43:	ff 75 e0             	pushl  -0x20(%ebp)
f011ea46:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ea49:	ff 75 e8             	pushl  -0x18(%ebp)
f011ea4c:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea4f:	50                   	push   %eax
f011ea50:	68 bc 06 13 f0       	push   $0xf01306bc
f011ea55:	e8 31 25 fe ff       	call   f0100f8b <cprintf>
f011ea5a:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011ea5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea60:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea63:	0f 8f b5 00 00 00    	jg     f011eb1e <chk2+0x356>
f011ea69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea6c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea6f:	75 0c                	jne    f011ea7d <chk2+0x2b5>
f011ea71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ea74:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ea77:	0f 8d a1 00 00 00    	jge    f011eb1e <chk2+0x356>
f011ea7d:	68 04 07 13 f0       	push   $0xf0130704
f011ea82:	68 e7 02 13 f0       	push   $0xf01302e7
f011ea87:	68 4a 02 00 00       	push   $0x24a
f011ea8c:	68 2f 03 13 f0       	push   $0xf013032f
f011ea91:	e8 33 19 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011ea96:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011ea9b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea9e:	7d 53                	jge    f011eaf3 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011eaa0:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011eaa5:	83 ec 08             	sub    $0x8,%esp
f011eaa8:	ff 75 e0             	pushl  -0x20(%ebp)
f011eaab:	ff 75 e4             	pushl  -0x1c(%ebp)
f011eaae:	ff 75 e8             	pushl  -0x18(%ebp)
f011eab1:	ff 75 ec             	pushl  -0x14(%ebp)
f011eab4:	50                   	push   %eax
f011eab5:	68 44 07 13 f0       	push   $0xf0130744
f011eaba:	e8 cc 24 fe ff       	call   f0100f8b <cprintf>
f011eabf:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011eac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011eac5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011eac8:	7c 54                	jl     f011eb1e <chk2+0x356>
f011eaca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011eacd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ead0:	75 08                	jne    f011eada <chk2+0x312>
f011ead2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ead5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ead8:	7e 44                	jle    f011eb1e <chk2+0x356>
f011eada:	68 8c 07 13 f0       	push   $0xf013078c
f011eadf:	68 e7 02 13 f0       	push   $0xf01302e7
f011eae4:	68 50 02 00 00       	push   $0x250
f011eae9:	68 2f 03 13 f0       	push   $0xf013032f
f011eaee:	e8 d6 18 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011eaf3:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011eaf8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011eafb:	75 21                	jne    f011eb1e <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011eafd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011eb00:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011eb03:	74 19                	je     f011eb1e <chk2+0x356>
f011eb05:	68 cc 07 13 f0       	push   $0xf01307cc
f011eb0a:	68 e7 02 13 f0       	push   $0xf01302e7
f011eb0f:	68 54 02 00 00       	push   $0x254
f011eb14:	68 2f 03 13 f0       	push   $0xf013032f
f011eb19:	e8 ab 18 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011eb1e:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011eb23:	a3 28 da 6b f0       	mov    %eax,0xf06bda28
			}
		}
		__pnexit = __nnexit;
f011eb28:	a1 b0 d7 6b f0       	mov    0xf06bd7b0,%eax
f011eb2d:	a3 00 d4 6b f0       	mov    %eax,0xf06bd400
f011eb32:	eb 01                	jmp    f011eb35 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011eb34:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011eb35:	c9                   	leave  
f011eb36:	c3                   	ret    

f011eb37 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011eb37:	55                   	push   %ebp
f011eb38:	89 e5                	mov    %esp,%ebp
f011eb3a:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011eb3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eb44:	eb 40                	jmp    f011eb86 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011eb46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb49:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011eb4f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011eb54:	83 ec 08             	sub    $0x8,%esp
f011eb57:	52                   	push   %edx
f011eb58:	50                   	push   %eax
f011eb59:	e8 af 01 00 00       	call   f011ed0d <check_va2pa>
f011eb5e:	83 c4 10             	add    $0x10,%esp
f011eb61:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011eb64:	74 19                	je     f011eb7f <check_boot_pgdir+0x48>
f011eb66:	68 e0 07 13 f0       	push   $0xf01307e0
f011eb6b:	68 e7 02 13 f0       	push   $0xf01302e7
f011eb70:	68 9b 02 00 00       	push   $0x29b
f011eb75:	68 2f 03 13 f0       	push   $0xf013032f
f011eb7a:	e8 ba 17 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011eb7f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011eb86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb89:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011eb8f:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f011eb94:	39 c2                	cmp    %eax,%edx
f011eb96:	72 ae                	jb     f011eb46 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011eb98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eb9f:	e9 81 00 00 00       	jmp    f011ec25 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011eba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eba7:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011ebac:	85 c0                	test   %eax,%eax
f011ebae:	74 6d                	je     f011ec1d <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011ebb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ebb3:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011ebb9:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ebbe:	83 ec 08             	sub    $0x8,%esp
f011ebc1:	52                   	push   %edx
f011ebc2:	50                   	push   %eax
f011ebc3:	e8 45 01 00 00       	call   f011ed0d <check_va2pa>
f011ebc8:	83 c4 10             	add    $0x10,%esp
f011ebcb:	c7 45 f0 00 60 17 f0 	movl   $0xf0176000,-0x10(%ebp)
f011ebd2:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011ebd9:	77 17                	ja     f011ebf2 <check_boot_pgdir+0xbb>
f011ebdb:	ff 75 f0             	pushl  -0x10(%ebp)
f011ebde:	68 18 08 13 f0       	push   $0xf0130818
f011ebe3:	68 a9 02 00 00       	push   $0x2a9
f011ebe8:	68 2f 03 13 f0       	push   $0xf013032f
f011ebed:	e8 47 17 fe ff       	call   f0100339 <_panic>
f011ebf2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ebf5:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011ebfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ebfe:	01 ca                	add    %ecx,%edx
f011ec00:	39 d0                	cmp    %edx,%eax
f011ec02:	74 1a                	je     f011ec1e <check_boot_pgdir+0xe7>
f011ec04:	68 4c 08 13 f0       	push   $0xf013084c
f011ec09:	68 e7 02 13 f0       	push   $0xf01302e7
f011ec0e:	68 a9 02 00 00       	push   $0x2a9
f011ec13:	68 2f 03 13 f0       	push   $0xf013032f
f011ec18:	e8 1c 17 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011ec1d:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011ec1e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011ec25:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011ec2c:	0f 86 72 ff ff ff    	jbe    f011eba4 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011ec32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ec39:	e9 af 00 00 00       	jmp    f011eced <check_boot_pgdir+0x1b6>
		switch (i) {
f011ec3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec41:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011ec46:	74 11                	je     f011ec59 <check_boot_pgdir+0x122>
f011ec48:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011ec4d:	72 36                	jb     f011ec85 <check_boot_pgdir+0x14e>
f011ec4f:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011ec54:	83 f8 02             	cmp    $0x2,%eax
f011ec57:	77 2c                	ja     f011ec85 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011ec59:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ec5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec61:	c1 e2 02             	shl    $0x2,%edx
f011ec64:	01 d0                	add    %edx,%eax
f011ec66:	8b 00                	mov    (%eax),%eax
f011ec68:	85 c0                	test   %eax,%eax
f011ec6a:	75 7a                	jne    f011ece6 <check_boot_pgdir+0x1af>
f011ec6c:	68 d2 08 13 f0       	push   $0xf01308d2
f011ec71:	68 e7 02 13 f0       	push   $0xf01302e7
f011ec76:	68 b4 02 00 00       	push   $0x2b4
f011ec7b:	68 2f 03 13 f0       	push   $0xf013032f
f011ec80:	e8 b4 16 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011ec85:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011ec8c:	76 2c                	jbe    f011ecba <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011ec8e:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ec93:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec96:	c1 e2 02             	shl    $0x2,%edx
f011ec99:	01 d0                	add    %edx,%eax
f011ec9b:	8b 00                	mov    (%eax),%eax
f011ec9d:	85 c0                	test   %eax,%eax
f011ec9f:	75 48                	jne    f011ece9 <check_boot_pgdir+0x1b2>
f011eca1:	68 d2 08 13 f0       	push   $0xf01308d2
f011eca6:	68 e7 02 13 f0       	push   $0xf01302e7
f011ecab:	68 b8 02 00 00       	push   $0x2b8
f011ecb0:	68 2f 03 13 f0       	push   $0xf013032f
f011ecb5:	e8 7f 16 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011ecba:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ecbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ecc2:	c1 e2 02             	shl    $0x2,%edx
f011ecc5:	01 d0                	add    %edx,%eax
f011ecc7:	8b 00                	mov    (%eax),%eax
f011ecc9:	85 c0                	test   %eax,%eax
f011eccb:	74 1c                	je     f011ece9 <check_boot_pgdir+0x1b2>
f011eccd:	68 e8 08 13 f0       	push   $0xf01308e8
f011ecd2:	68 e7 02 13 f0       	push   $0xf01302e7
f011ecd7:	68 ba 02 00 00       	push   $0x2ba
f011ecdc:	68 2f 03 13 f0       	push   $0xf013032f
f011ece1:	e8 53 16 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011ece6:	90                   	nop
f011ece7:	eb 01                	jmp    f011ecea <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011ece9:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011ecea:	ff 45 f4             	incl   -0xc(%ebp)
f011eced:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011ecf4:	0f 86 44 ff ff ff    	jbe    f011ec3e <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011ecfa:	83 ec 0c             	sub    $0xc,%esp
f011ecfd:	68 04 09 13 f0       	push   $0xf0130904
f011ed02:	e8 84 22 fe ff       	call   f0100f8b <cprintf>
f011ed07:	83 c4 10             	add    $0x10,%esp
}
f011ed0a:	90                   	nop
f011ed0b:	c9                   	leave  
f011ed0c:	c3                   	ret    

f011ed0d <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011ed0d:	55                   	push   %ebp
f011ed0e:	89 e5                	mov    %esp,%ebp
f011ed10:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011ed13:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed16:	c1 e8 16             	shr    $0x16,%eax
f011ed19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed20:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed23:	01 d0                	add    %edx,%eax
f011ed25:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011ed28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed2b:	8b 00                	mov    (%eax),%eax
f011ed2d:	83 e0 01             	and    $0x1,%eax
f011ed30:	85 c0                	test   %eax,%eax
f011ed32:	75 0a                	jne    f011ed3e <check_va2pa+0x31>
		return ~0;
f011ed34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011ed39:	e9 87 00 00 00       	jmp    f011edc5 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011ed3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed41:	8b 00                	mov    (%eax),%eax
f011ed43:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ed48:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ed4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed4e:	c1 e8 0c             	shr    $0xc,%eax
f011ed51:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ed54:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011ed59:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011ed5c:	72 17                	jb     f011ed75 <check_va2pa+0x68>
f011ed5e:	ff 75 f0             	pushl  -0x10(%ebp)
f011ed61:	68 28 09 13 f0       	push   $0xf0130928
f011ed66:	68 d0 02 00 00       	push   $0x2d0
f011ed6b:	68 2f 03 13 f0       	push   $0xf013032f
f011ed70:	e8 c4 15 fe ff       	call   f0100339 <_panic>
f011ed75:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed78:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011ed7d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011ed80:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed83:	c1 e8 0c             	shr    $0xc,%eax
f011ed86:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ed8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed92:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ed95:	01 d0                	add    %edx,%eax
f011ed97:	8b 00                	mov    (%eax),%eax
f011ed99:	83 e0 01             	and    $0x1,%eax
f011ed9c:	85 c0                	test   %eax,%eax
f011ed9e:	75 07                	jne    f011eda7 <check_va2pa+0x9a>
		return ~0;
f011eda0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011eda5:	eb 1e                	jmp    f011edc5 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011eda7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011edaa:	c1 e8 0c             	shr    $0xc,%eax
f011edad:	25 ff 03 00 00       	and    $0x3ff,%eax
f011edb2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011edb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011edbc:	01 d0                	add    %edx,%eax
f011edbe:	8b 00                	mov    (%eax),%eax
f011edc0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011edc5:	c9                   	leave  
f011edc6:	c3                   	ret    

f011edc7 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011edc7:	55                   	push   %ebp
f011edc8:	89 e5                	mov    %esp,%ebp
f011edca:	53                   	push   %ebx
f011edcb:	83 ec 14             	sub    $0x14,%esp
f011edce:	8b 45 10             	mov    0x10(%ebp),%eax
f011edd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011edd4:	8b 45 14             	mov    0x14(%ebp),%eax
f011edd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011edda:	8b 45 18             	mov    0x18(%ebp),%eax
f011eddd:	ba 00 00 00 00       	mov    $0x0,%edx
f011ede2:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011ede5:	77 55                	ja     f011ee3c <printnum+0x75>
f011ede7:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011edea:	72 05                	jb     f011edf1 <printnum+0x2a>
f011edec:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011edef:	77 4b                	ja     f011ee3c <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011edf1:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011edf4:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011edf7:	8b 45 18             	mov    0x18(%ebp),%eax
f011edfa:	ba 00 00 00 00       	mov    $0x0,%edx
f011edff:	52                   	push   %edx
f011ee00:	50                   	push   %eax
f011ee01:	ff 75 f4             	pushl  -0xc(%ebp)
f011ee04:	ff 75 f0             	pushl  -0x10(%ebp)
f011ee07:	e8 98 2e 00 00       	call   f0121ca4 <__udivdi3>
f011ee0c:	83 c4 10             	add    $0x10,%esp
f011ee0f:	83 ec 04             	sub    $0x4,%esp
f011ee12:	ff 75 20             	pushl  0x20(%ebp)
f011ee15:	53                   	push   %ebx
f011ee16:	ff 75 18             	pushl  0x18(%ebp)
f011ee19:	52                   	push   %edx
f011ee1a:	50                   	push   %eax
f011ee1b:	ff 75 0c             	pushl  0xc(%ebp)
f011ee1e:	ff 75 08             	pushl  0x8(%ebp)
f011ee21:	e8 a1 ff ff ff       	call   f011edc7 <printnum>
f011ee26:	83 c4 20             	add    $0x20,%esp
f011ee29:	eb 1a                	jmp    f011ee45 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011ee2b:	83 ec 08             	sub    $0x8,%esp
f011ee2e:	ff 75 0c             	pushl  0xc(%ebp)
f011ee31:	ff 75 20             	pushl  0x20(%ebp)
f011ee34:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee37:	ff d0                	call   *%eax
f011ee39:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011ee3c:	ff 4d 1c             	decl   0x1c(%ebp)
f011ee3f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011ee43:	7f e6                	jg     f011ee2b <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011ee45:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011ee48:	bb 00 00 00 00       	mov    $0x0,%ebx
f011ee4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ee50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ee53:	53                   	push   %ebx
f011ee54:	51                   	push   %ecx
f011ee55:	52                   	push   %edx
f011ee56:	50                   	push   %eax
f011ee57:	e8 58 2f 00 00       	call   f0121db4 <__umoddi3>
f011ee5c:	83 c4 10             	add    $0x10,%esp
f011ee5f:	05 74 0b 13 f0       	add    $0xf0130b74,%eax
f011ee64:	8a 00                	mov    (%eax),%al
f011ee66:	0f be c0             	movsbl %al,%eax
f011ee69:	83 ec 08             	sub    $0x8,%esp
f011ee6c:	ff 75 0c             	pushl  0xc(%ebp)
f011ee6f:	50                   	push   %eax
f011ee70:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee73:	ff d0                	call   *%eax
f011ee75:	83 c4 10             	add    $0x10,%esp
}
f011ee78:	90                   	nop
f011ee79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011ee7c:	c9                   	leave  
f011ee7d:	c3                   	ret    

f011ee7e <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011ee7e:	55                   	push   %ebp
f011ee7f:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011ee81:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011ee85:	7e 1c                	jle    f011eea3 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011ee87:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee8a:	8b 00                	mov    (%eax),%eax
f011ee8c:	8d 50 08             	lea    0x8(%eax),%edx
f011ee8f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee92:	89 10                	mov    %edx,(%eax)
f011ee94:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee97:	8b 00                	mov    (%eax),%eax
f011ee99:	83 e8 08             	sub    $0x8,%eax
f011ee9c:	8b 50 04             	mov    0x4(%eax),%edx
f011ee9f:	8b 00                	mov    (%eax),%eax
f011eea1:	eb 40                	jmp    f011eee3 <getuint+0x65>
	else if (lflag)
f011eea3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011eea7:	74 1e                	je     f011eec7 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011eea9:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeac:	8b 00                	mov    (%eax),%eax
f011eeae:	8d 50 04             	lea    0x4(%eax),%edx
f011eeb1:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeb4:	89 10                	mov    %edx,(%eax)
f011eeb6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeb9:	8b 00                	mov    (%eax),%eax
f011eebb:	83 e8 04             	sub    $0x4,%eax
f011eebe:	8b 00                	mov    (%eax),%eax
f011eec0:	ba 00 00 00 00       	mov    $0x0,%edx
f011eec5:	eb 1c                	jmp    f011eee3 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011eec7:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeca:	8b 00                	mov    (%eax),%eax
f011eecc:	8d 50 04             	lea    0x4(%eax),%edx
f011eecf:	8b 45 08             	mov    0x8(%ebp),%eax
f011eed2:	89 10                	mov    %edx,(%eax)
f011eed4:	8b 45 08             	mov    0x8(%ebp),%eax
f011eed7:	8b 00                	mov    (%eax),%eax
f011eed9:	83 e8 04             	sub    $0x4,%eax
f011eedc:	8b 00                	mov    (%eax),%eax
f011eede:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011eee3:	5d                   	pop    %ebp
f011eee4:	c3                   	ret    

f011eee5 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011eee5:	55                   	push   %ebp
f011eee6:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011eee8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011eeec:	7e 1c                	jle    f011ef0a <getint+0x25>
		return va_arg(*ap, long long);
f011eeee:	8b 45 08             	mov    0x8(%ebp),%eax
f011eef1:	8b 00                	mov    (%eax),%eax
f011eef3:	8d 50 08             	lea    0x8(%eax),%edx
f011eef6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eef9:	89 10                	mov    %edx,(%eax)
f011eefb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eefe:	8b 00                	mov    (%eax),%eax
f011ef00:	83 e8 08             	sub    $0x8,%eax
f011ef03:	8b 50 04             	mov    0x4(%eax),%edx
f011ef06:	8b 00                	mov    (%eax),%eax
f011ef08:	eb 38                	jmp    f011ef42 <getint+0x5d>
	else if (lflag)
f011ef0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ef0e:	74 1a                	je     f011ef2a <getint+0x45>
		return va_arg(*ap, long);
f011ef10:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef13:	8b 00                	mov    (%eax),%eax
f011ef15:	8d 50 04             	lea    0x4(%eax),%edx
f011ef18:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef1b:	89 10                	mov    %edx,(%eax)
f011ef1d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef20:	8b 00                	mov    (%eax),%eax
f011ef22:	83 e8 04             	sub    $0x4,%eax
f011ef25:	8b 00                	mov    (%eax),%eax
f011ef27:	99                   	cltd   
f011ef28:	eb 18                	jmp    f011ef42 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011ef2a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef2d:	8b 00                	mov    (%eax),%eax
f011ef2f:	8d 50 04             	lea    0x4(%eax),%edx
f011ef32:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef35:	89 10                	mov    %edx,(%eax)
f011ef37:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef3a:	8b 00                	mov    (%eax),%eax
f011ef3c:	83 e8 04             	sub    $0x4,%eax
f011ef3f:	8b 00                	mov    (%eax),%eax
f011ef41:	99                   	cltd   
}
f011ef42:	5d                   	pop    %ebp
f011ef43:	c3                   	ret    

f011ef44 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011ef44:	55                   	push   %ebp
f011ef45:	89 e5                	mov    %esp,%ebp
f011ef47:	56                   	push   %esi
f011ef48:	53                   	push   %ebx
f011ef49:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ef4c:	eb 17                	jmp    f011ef65 <vprintfmt+0x21>
			if (ch == '\0')
f011ef4e:	85 db                	test   %ebx,%ebx
f011ef50:	0f 84 c1 03 00 00    	je     f011f317 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011ef56:	83 ec 08             	sub    $0x8,%esp
f011ef59:	ff 75 0c             	pushl  0xc(%ebp)
f011ef5c:	53                   	push   %ebx
f011ef5d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef60:	ff d0                	call   *%eax
f011ef62:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ef65:	8b 45 10             	mov    0x10(%ebp),%eax
f011ef68:	8d 50 01             	lea    0x1(%eax),%edx
f011ef6b:	89 55 10             	mov    %edx,0x10(%ebp)
f011ef6e:	8a 00                	mov    (%eax),%al
f011ef70:	0f b6 d8             	movzbl %al,%ebx
f011ef73:	83 fb 25             	cmp    $0x25,%ebx
f011ef76:	75 d6                	jne    f011ef4e <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011ef78:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011ef7c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011ef83:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011ef8a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011ef91:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011ef98:	8b 45 10             	mov    0x10(%ebp),%eax
f011ef9b:	8d 50 01             	lea    0x1(%eax),%edx
f011ef9e:	89 55 10             	mov    %edx,0x10(%ebp)
f011efa1:	8a 00                	mov    (%eax),%al
f011efa3:	0f b6 d8             	movzbl %al,%ebx
f011efa6:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011efa9:	83 f8 5b             	cmp    $0x5b,%eax
f011efac:	0f 87 3d 03 00 00    	ja     f011f2ef <vprintfmt+0x3ab>
f011efb2:	8b 04 85 98 0b 13 f0 	mov    -0xfecf468(,%eax,4),%eax
f011efb9:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011efbb:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011efbf:	eb d7                	jmp    f011ef98 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011efc1:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011efc5:	eb d1                	jmp    f011ef98 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011efc7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011efce:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011efd1:	89 d0                	mov    %edx,%eax
f011efd3:	c1 e0 02             	shl    $0x2,%eax
f011efd6:	01 d0                	add    %edx,%eax
f011efd8:	01 c0                	add    %eax,%eax
f011efda:	01 d8                	add    %ebx,%eax
f011efdc:	83 e8 30             	sub    $0x30,%eax
f011efdf:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011efe2:	8b 45 10             	mov    0x10(%ebp),%eax
f011efe5:	8a 00                	mov    (%eax),%al
f011efe7:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011efea:	83 fb 2f             	cmp    $0x2f,%ebx
f011efed:	7e 3e                	jle    f011f02d <vprintfmt+0xe9>
f011efef:	83 fb 39             	cmp    $0x39,%ebx
f011eff2:	7f 39                	jg     f011f02d <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011eff4:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011eff7:	eb d5                	jmp    f011efce <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011eff9:	8b 45 14             	mov    0x14(%ebp),%eax
f011effc:	83 c0 04             	add    $0x4,%eax
f011efff:	89 45 14             	mov    %eax,0x14(%ebp)
f011f002:	8b 45 14             	mov    0x14(%ebp),%eax
f011f005:	83 e8 04             	sub    $0x4,%eax
f011f008:	8b 00                	mov    (%eax),%eax
f011f00a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f00d:	eb 1f                	jmp    f011f02e <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f00f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f013:	79 83                	jns    f011ef98 <vprintfmt+0x54>
				width = 0;
f011f015:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f01c:	e9 77 ff ff ff       	jmp    f011ef98 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f021:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f028:	e9 6b ff ff ff       	jmp    f011ef98 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f02d:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f02e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f032:	0f 89 60 ff ff ff    	jns    f011ef98 <vprintfmt+0x54>
				width = precision, precision = -1;
f011f038:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f03b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f03e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f045:	e9 4e ff ff ff       	jmp    f011ef98 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f04a:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f04d:	e9 46 ff ff ff       	jmp    f011ef98 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f052:	8b 45 14             	mov    0x14(%ebp),%eax
f011f055:	83 c0 04             	add    $0x4,%eax
f011f058:	89 45 14             	mov    %eax,0x14(%ebp)
f011f05b:	8b 45 14             	mov    0x14(%ebp),%eax
f011f05e:	83 e8 04             	sub    $0x4,%eax
f011f061:	8b 00                	mov    (%eax),%eax
f011f063:	83 ec 08             	sub    $0x8,%esp
f011f066:	ff 75 0c             	pushl  0xc(%ebp)
f011f069:	50                   	push   %eax
f011f06a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f06d:	ff d0                	call   *%eax
f011f06f:	83 c4 10             	add    $0x10,%esp
			break;
f011f072:	e9 9b 02 00 00       	jmp    f011f312 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f077:	8b 45 14             	mov    0x14(%ebp),%eax
f011f07a:	83 c0 04             	add    $0x4,%eax
f011f07d:	89 45 14             	mov    %eax,0x14(%ebp)
f011f080:	8b 45 14             	mov    0x14(%ebp),%eax
f011f083:	83 e8 04             	sub    $0x4,%eax
f011f086:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f088:	85 db                	test   %ebx,%ebx
f011f08a:	79 02                	jns    f011f08e <vprintfmt+0x14a>
				err = -err;
f011f08c:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f08e:	83 fb 64             	cmp    $0x64,%ebx
f011f091:	7f 0b                	jg     f011f09e <vprintfmt+0x15a>
f011f093:	8b 34 9d e0 09 13 f0 	mov    -0xfecf620(,%ebx,4),%esi
f011f09a:	85 f6                	test   %esi,%esi
f011f09c:	75 19                	jne    f011f0b7 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f09e:	53                   	push   %ebx
f011f09f:	68 85 0b 13 f0       	push   $0xf0130b85
f011f0a4:	ff 75 0c             	pushl  0xc(%ebp)
f011f0a7:	ff 75 08             	pushl  0x8(%ebp)
f011f0aa:	e8 70 02 00 00       	call   f011f31f <printfmt>
f011f0af:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f0b2:	e9 5b 02 00 00       	jmp    f011f312 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f0b7:	56                   	push   %esi
f011f0b8:	68 8e 0b 13 f0       	push   $0xf0130b8e
f011f0bd:	ff 75 0c             	pushl  0xc(%ebp)
f011f0c0:	ff 75 08             	pushl  0x8(%ebp)
f011f0c3:	e8 57 02 00 00       	call   f011f31f <printfmt>
f011f0c8:	83 c4 10             	add    $0x10,%esp
			break;
f011f0cb:	e9 42 02 00 00       	jmp    f011f312 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f0d0:	8b 45 14             	mov    0x14(%ebp),%eax
f011f0d3:	83 c0 04             	add    $0x4,%eax
f011f0d6:	89 45 14             	mov    %eax,0x14(%ebp)
f011f0d9:	8b 45 14             	mov    0x14(%ebp),%eax
f011f0dc:	83 e8 04             	sub    $0x4,%eax
f011f0df:	8b 30                	mov    (%eax),%esi
f011f0e1:	85 f6                	test   %esi,%esi
f011f0e3:	75 05                	jne    f011f0ea <vprintfmt+0x1a6>
				p = "(null)";
f011f0e5:	be 91 0b 13 f0       	mov    $0xf0130b91,%esi
			if (width > 0 && padc != '-')
f011f0ea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f0ee:	7e 6d                	jle    f011f15d <vprintfmt+0x219>
f011f0f0:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f0f4:	74 67                	je     f011f15d <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f0f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f0f9:	83 ec 08             	sub    $0x8,%esp
f011f0fc:	50                   	push   %eax
f011f0fd:	56                   	push   %esi
f011f0fe:	e8 26 05 00 00       	call   f011f629 <strnlen>
f011f103:	83 c4 10             	add    $0x10,%esp
f011f106:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f109:	eb 16                	jmp    f011f121 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f10b:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f10f:	83 ec 08             	sub    $0x8,%esp
f011f112:	ff 75 0c             	pushl  0xc(%ebp)
f011f115:	50                   	push   %eax
f011f116:	8b 45 08             	mov    0x8(%ebp),%eax
f011f119:	ff d0                	call   *%eax
f011f11b:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f11e:	ff 4d e4             	decl   -0x1c(%ebp)
f011f121:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f125:	7f e4                	jg     f011f10b <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f127:	eb 34                	jmp    f011f15d <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f129:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f12d:	74 1c                	je     f011f14b <vprintfmt+0x207>
f011f12f:	83 fb 1f             	cmp    $0x1f,%ebx
f011f132:	7e 05                	jle    f011f139 <vprintfmt+0x1f5>
f011f134:	83 fb 7e             	cmp    $0x7e,%ebx
f011f137:	7e 12                	jle    f011f14b <vprintfmt+0x207>
					putch('?', putdat);
f011f139:	83 ec 08             	sub    $0x8,%esp
f011f13c:	ff 75 0c             	pushl  0xc(%ebp)
f011f13f:	6a 3f                	push   $0x3f
f011f141:	8b 45 08             	mov    0x8(%ebp),%eax
f011f144:	ff d0                	call   *%eax
f011f146:	83 c4 10             	add    $0x10,%esp
f011f149:	eb 0f                	jmp    f011f15a <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f14b:	83 ec 08             	sub    $0x8,%esp
f011f14e:	ff 75 0c             	pushl  0xc(%ebp)
f011f151:	53                   	push   %ebx
f011f152:	8b 45 08             	mov    0x8(%ebp),%eax
f011f155:	ff d0                	call   *%eax
f011f157:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f15a:	ff 4d e4             	decl   -0x1c(%ebp)
f011f15d:	89 f0                	mov    %esi,%eax
f011f15f:	8d 70 01             	lea    0x1(%eax),%esi
f011f162:	8a 00                	mov    (%eax),%al
f011f164:	0f be d8             	movsbl %al,%ebx
f011f167:	85 db                	test   %ebx,%ebx
f011f169:	74 24                	je     f011f18f <vprintfmt+0x24b>
f011f16b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f16f:	78 b8                	js     f011f129 <vprintfmt+0x1e5>
f011f171:	ff 4d e0             	decl   -0x20(%ebp)
f011f174:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f178:	79 af                	jns    f011f129 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f17a:	eb 13                	jmp    f011f18f <vprintfmt+0x24b>
				putch(' ', putdat);
f011f17c:	83 ec 08             	sub    $0x8,%esp
f011f17f:	ff 75 0c             	pushl  0xc(%ebp)
f011f182:	6a 20                	push   $0x20
f011f184:	8b 45 08             	mov    0x8(%ebp),%eax
f011f187:	ff d0                	call   *%eax
f011f189:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f18c:	ff 4d e4             	decl   -0x1c(%ebp)
f011f18f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f193:	7f e7                	jg     f011f17c <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f195:	e9 78 01 00 00       	jmp    f011f312 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f19a:	83 ec 08             	sub    $0x8,%esp
f011f19d:	ff 75 e8             	pushl  -0x18(%ebp)
f011f1a0:	8d 45 14             	lea    0x14(%ebp),%eax
f011f1a3:	50                   	push   %eax
f011f1a4:	e8 3c fd ff ff       	call   f011eee5 <getint>
f011f1a9:	83 c4 10             	add    $0x10,%esp
f011f1ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f1af:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f1b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f1b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f1b8:	85 d2                	test   %edx,%edx
f011f1ba:	79 23                	jns    f011f1df <vprintfmt+0x29b>
				putch('-', putdat);
f011f1bc:	83 ec 08             	sub    $0x8,%esp
f011f1bf:	ff 75 0c             	pushl  0xc(%ebp)
f011f1c2:	6a 2d                	push   $0x2d
f011f1c4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1c7:	ff d0                	call   *%eax
f011f1c9:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f1cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f1cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f1d2:	f7 d8                	neg    %eax
f011f1d4:	83 d2 00             	adc    $0x0,%edx
f011f1d7:	f7 da                	neg    %edx
f011f1d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f1dc:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f1df:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f1e6:	e9 bc 00 00 00       	jmp    f011f2a7 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f1eb:	83 ec 08             	sub    $0x8,%esp
f011f1ee:	ff 75 e8             	pushl  -0x18(%ebp)
f011f1f1:	8d 45 14             	lea    0x14(%ebp),%eax
f011f1f4:	50                   	push   %eax
f011f1f5:	e8 84 fc ff ff       	call   f011ee7e <getuint>
f011f1fa:	83 c4 10             	add    $0x10,%esp
f011f1fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f200:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f203:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f20a:	e9 98 00 00 00       	jmp    f011f2a7 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f20f:	83 ec 08             	sub    $0x8,%esp
f011f212:	ff 75 0c             	pushl  0xc(%ebp)
f011f215:	6a 58                	push   $0x58
f011f217:	8b 45 08             	mov    0x8(%ebp),%eax
f011f21a:	ff d0                	call   *%eax
f011f21c:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f21f:	83 ec 08             	sub    $0x8,%esp
f011f222:	ff 75 0c             	pushl  0xc(%ebp)
f011f225:	6a 58                	push   $0x58
f011f227:	8b 45 08             	mov    0x8(%ebp),%eax
f011f22a:	ff d0                	call   *%eax
f011f22c:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f22f:	83 ec 08             	sub    $0x8,%esp
f011f232:	ff 75 0c             	pushl  0xc(%ebp)
f011f235:	6a 58                	push   $0x58
f011f237:	8b 45 08             	mov    0x8(%ebp),%eax
f011f23a:	ff d0                	call   *%eax
f011f23c:	83 c4 10             	add    $0x10,%esp
			break;
f011f23f:	e9 ce 00 00 00       	jmp    f011f312 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f244:	83 ec 08             	sub    $0x8,%esp
f011f247:	ff 75 0c             	pushl  0xc(%ebp)
f011f24a:	6a 30                	push   $0x30
f011f24c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f24f:	ff d0                	call   *%eax
f011f251:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f254:	83 ec 08             	sub    $0x8,%esp
f011f257:	ff 75 0c             	pushl  0xc(%ebp)
f011f25a:	6a 78                	push   $0x78
f011f25c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f25f:	ff d0                	call   *%eax
f011f261:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f264:	8b 45 14             	mov    0x14(%ebp),%eax
f011f267:	83 c0 04             	add    $0x4,%eax
f011f26a:	89 45 14             	mov    %eax,0x14(%ebp)
f011f26d:	8b 45 14             	mov    0x14(%ebp),%eax
f011f270:	83 e8 04             	sub    $0x4,%eax
f011f273:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f275:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f278:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f27f:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f286:	eb 1f                	jmp    f011f2a7 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f288:	83 ec 08             	sub    $0x8,%esp
f011f28b:	ff 75 e8             	pushl  -0x18(%ebp)
f011f28e:	8d 45 14             	lea    0x14(%ebp),%eax
f011f291:	50                   	push   %eax
f011f292:	e8 e7 fb ff ff       	call   f011ee7e <getuint>
f011f297:	83 c4 10             	add    $0x10,%esp
f011f29a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f29d:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f2a0:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f2a7:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f2ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f2ae:	83 ec 04             	sub    $0x4,%esp
f011f2b1:	52                   	push   %edx
f011f2b2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f2b5:	50                   	push   %eax
f011f2b6:	ff 75 f4             	pushl  -0xc(%ebp)
f011f2b9:	ff 75 f0             	pushl  -0x10(%ebp)
f011f2bc:	ff 75 0c             	pushl  0xc(%ebp)
f011f2bf:	ff 75 08             	pushl  0x8(%ebp)
f011f2c2:	e8 00 fb ff ff       	call   f011edc7 <printnum>
f011f2c7:	83 c4 20             	add    $0x20,%esp
			break;
f011f2ca:	eb 46                	jmp    f011f312 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f2cc:	83 ec 08             	sub    $0x8,%esp
f011f2cf:	ff 75 0c             	pushl  0xc(%ebp)
f011f2d2:	53                   	push   %ebx
f011f2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f2d6:	ff d0                	call   *%eax
f011f2d8:	83 c4 10             	add    $0x10,%esp
			break;
f011f2db:	eb 35                	jmp    f011f312 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f2dd:	c6 05 a0 d2 6b f0 00 	movb   $0x0,0xf06bd2a0
			break;
f011f2e4:	eb 2c                	jmp    f011f312 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f2e6:	c6 05 a0 d2 6b f0 01 	movb   $0x1,0xf06bd2a0
			break;
f011f2ed:	eb 23                	jmp    f011f312 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f2ef:	83 ec 08             	sub    $0x8,%esp
f011f2f2:	ff 75 0c             	pushl  0xc(%ebp)
f011f2f5:	6a 25                	push   $0x25
f011f2f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f2fa:	ff d0                	call   *%eax
f011f2fc:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f2ff:	ff 4d 10             	decl   0x10(%ebp)
f011f302:	eb 03                	jmp    f011f307 <vprintfmt+0x3c3>
f011f304:	ff 4d 10             	decl   0x10(%ebp)
f011f307:	8b 45 10             	mov    0x10(%ebp),%eax
f011f30a:	48                   	dec    %eax
f011f30b:	8a 00                	mov    (%eax),%al
f011f30d:	3c 25                	cmp    $0x25,%al
f011f30f:	75 f3                	jne    f011f304 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f311:	90                   	nop
		}
	}
f011f312:	e9 35 fc ff ff       	jmp    f011ef4c <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f317:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f318:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f31b:	5b                   	pop    %ebx
f011f31c:	5e                   	pop    %esi
f011f31d:	5d                   	pop    %ebp
f011f31e:	c3                   	ret    

f011f31f <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f31f:	55                   	push   %ebp
f011f320:	89 e5                	mov    %esp,%ebp
f011f322:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f325:	8d 45 10             	lea    0x10(%ebp),%eax
f011f328:	83 c0 04             	add    $0x4,%eax
f011f32b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f32e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f331:	ff 75 f4             	pushl  -0xc(%ebp)
f011f334:	50                   	push   %eax
f011f335:	ff 75 0c             	pushl  0xc(%ebp)
f011f338:	ff 75 08             	pushl  0x8(%ebp)
f011f33b:	e8 04 fc ff ff       	call   f011ef44 <vprintfmt>
f011f340:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f343:	90                   	nop
f011f344:	c9                   	leave  
f011f345:	c3                   	ret    

f011f346 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f346:	55                   	push   %ebp
f011f347:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f349:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f34c:	8b 40 08             	mov    0x8(%eax),%eax
f011f34f:	8d 50 01             	lea    0x1(%eax),%edx
f011f352:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f355:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f358:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f35b:	8b 10                	mov    (%eax),%edx
f011f35d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f360:	8b 40 04             	mov    0x4(%eax),%eax
f011f363:	39 c2                	cmp    %eax,%edx
f011f365:	73 12                	jae    f011f379 <sprintputch+0x33>
		*b->buf++ = ch;
f011f367:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f36a:	8b 00                	mov    (%eax),%eax
f011f36c:	8d 48 01             	lea    0x1(%eax),%ecx
f011f36f:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f372:	89 0a                	mov    %ecx,(%edx)
f011f374:	8b 55 08             	mov    0x8(%ebp),%edx
f011f377:	88 10                	mov    %dl,(%eax)
}
f011f379:	90                   	nop
f011f37a:	5d                   	pop    %ebp
f011f37b:	c3                   	ret    

f011f37c <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f37c:	55                   	push   %ebp
f011f37d:	89 e5                	mov    %esp,%ebp
f011f37f:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f382:	8b 45 08             	mov    0x8(%ebp),%eax
f011f385:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f388:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f38b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f38e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f391:	01 d0                	add    %edx,%eax
f011f393:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f396:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011f39d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f3a1:	74 06                	je     f011f3a9 <vsnprintf+0x2d>
f011f3a3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f3a7:	7f 07                	jg     f011f3b0 <vsnprintf+0x34>
		return -E_INVAL;
f011f3a9:	b8 03 00 00 00       	mov    $0x3,%eax
f011f3ae:	eb 20                	jmp    f011f3d0 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011f3b0:	ff 75 14             	pushl  0x14(%ebp)
f011f3b3:	ff 75 10             	pushl  0x10(%ebp)
f011f3b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011f3b9:	50                   	push   %eax
f011f3ba:	68 46 f3 11 f0       	push   $0xf011f346
f011f3bf:	e8 80 fb ff ff       	call   f011ef44 <vprintfmt>
f011f3c4:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011f3c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f3ca:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011f3cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f3d0:	c9                   	leave  
f011f3d1:	c3                   	ret    

f011f3d2 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011f3d2:	55                   	push   %ebp
f011f3d3:	89 e5                	mov    %esp,%ebp
f011f3d5:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011f3d8:	8d 45 10             	lea    0x10(%ebp),%eax
f011f3db:	83 c0 04             	add    $0x4,%eax
f011f3de:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011f3e1:	8b 45 10             	mov    0x10(%ebp),%eax
f011f3e4:	ff 75 f4             	pushl  -0xc(%ebp)
f011f3e7:	50                   	push   %eax
f011f3e8:	ff 75 0c             	pushl  0xc(%ebp)
f011f3eb:	ff 75 08             	pushl  0x8(%ebp)
f011f3ee:	e8 89 ff ff ff       	call   f011f37c <vsnprintf>
f011f3f3:	83 c4 10             	add    $0x10,%esp
f011f3f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011f3f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011f3fc:	c9                   	leave  
f011f3fd:	c3                   	ret    

f011f3fe <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011f3fe:	55                   	push   %ebp
f011f3ff:	89 e5                	mov    %esp,%ebp
f011f401:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011f404:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f408:	74 13                	je     f011f41d <readline+0x1f>
		cprintf("%s", prompt);
f011f40a:	83 ec 08             	sub    $0x8,%esp
f011f40d:	ff 75 08             	pushl  0x8(%ebp)
f011f410:	68 08 0d 13 f0       	push   $0xf0130d08
f011f415:	e8 71 1b fe ff       	call   f0100f8b <cprintf>
f011f41a:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011f41d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011f424:	83 ec 0c             	sub    $0xc,%esp
f011f427:	6a 00                	push   $0x0
f011f429:	e8 6a 1a fe ff       	call   f0100e98 <iscons>
f011f42e:	83 c4 10             	add    $0x10,%esp
f011f431:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011f434:	e8 46 1a fe ff       	call   f0100e7f <getchar>
f011f439:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011f43c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f440:	79 22                	jns    f011f464 <readline+0x66>
			if (c != -E_EOF)
f011f442:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f446:	0f 84 ad 00 00 00    	je     f011f4f9 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011f44c:	83 ec 08             	sub    $0x8,%esp
f011f44f:	ff 75 ec             	pushl  -0x14(%ebp)
f011f452:	68 0b 0d 13 f0       	push   $0xf0130d0b
f011f457:	e8 2f 1b fe ff       	call   f0100f8b <cprintf>
f011f45c:	83 c4 10             	add    $0x10,%esp
			break;
f011f45f:	e9 95 00 00 00       	jmp    f011f4f9 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011f464:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f468:	7e 34                	jle    f011f49e <readline+0xa0>
f011f46a:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f471:	7f 2b                	jg     f011f49e <readline+0xa0>
			if (echoing)
f011f473:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f477:	74 0e                	je     f011f487 <readline+0x89>
				cputchar(c);
f011f479:	83 ec 0c             	sub    $0xc,%esp
f011f47c:	ff 75 ec             	pushl  -0x14(%ebp)
f011f47f:	e8 e4 19 fe ff       	call   f0100e68 <cputchar>
f011f484:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011f487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f48a:	8d 50 01             	lea    0x1(%eax),%edx
f011f48d:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f490:	89 c2                	mov    %eax,%edx
f011f492:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f495:	01 d0                	add    %edx,%eax
f011f497:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f49a:	88 10                	mov    %dl,(%eax)
f011f49c:	eb 56                	jmp    f011f4f4 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011f49e:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f4a2:	75 1f                	jne    f011f4c3 <readline+0xc5>
f011f4a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f4a8:	7e 19                	jle    f011f4c3 <readline+0xc5>
			if (echoing)
f011f4aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f4ae:	74 0e                	je     f011f4be <readline+0xc0>
				cputchar(c);
f011f4b0:	83 ec 0c             	sub    $0xc,%esp
f011f4b3:	ff 75 ec             	pushl  -0x14(%ebp)
f011f4b6:	e8 ad 19 fe ff       	call   f0100e68 <cputchar>
f011f4bb:	83 c4 10             	add    $0x10,%esp

			i--;
f011f4be:	ff 4d f4             	decl   -0xc(%ebp)
f011f4c1:	eb 31                	jmp    f011f4f4 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011f4c3:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f4c7:	74 0a                	je     f011f4d3 <readline+0xd5>
f011f4c9:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f4cd:	0f 85 61 ff ff ff    	jne    f011f434 <readline+0x36>
			if (echoing)
f011f4d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f4d7:	74 0e                	je     f011f4e7 <readline+0xe9>
				cputchar(c);
f011f4d9:	83 ec 0c             	sub    $0xc,%esp
f011f4dc:	ff 75 ec             	pushl  -0x14(%ebp)
f011f4df:	e8 84 19 fe ff       	call   f0100e68 <cputchar>
f011f4e4:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011f4e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f4ed:	01 d0                	add    %edx,%eax
f011f4ef:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011f4f2:	eb 06                	jmp    f011f4fa <readline+0xfc>
		}
	}
f011f4f4:	e9 3b ff ff ff       	jmp    f011f434 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011f4f9:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011f4fa:	90                   	nop
f011f4fb:	c9                   	leave  
f011f4fc:	c3                   	ret    

f011f4fd <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011f4fd:	55                   	push   %ebp
f011f4fe:	89 e5                	mov    %esp,%ebp
f011f500:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011f503:	e8 2d ec fe ff       	call   f010e135 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011f508:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f50c:	74 13                	je     f011f521 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011f50e:	83 ec 08             	sub    $0x8,%esp
f011f511:	ff 75 08             	pushl  0x8(%ebp)
f011f514:	68 08 0d 13 f0       	push   $0xf0130d08
f011f519:	e8 6d 1a fe ff       	call   f0100f8b <cprintf>
f011f51e:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011f521:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011f528:	83 ec 0c             	sub    $0xc,%esp
f011f52b:	6a 00                	push   $0x0
f011f52d:	e8 66 19 fe ff       	call   f0100e98 <iscons>
f011f532:	83 c4 10             	add    $0x10,%esp
f011f535:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011f538:	e8 42 19 fe ff       	call   f0100e7f <getchar>
f011f53d:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011f540:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f544:	79 22                	jns    f011f568 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011f546:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f54a:	0f 84 ad 00 00 00    	je     f011f5fd <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011f550:	83 ec 08             	sub    $0x8,%esp
f011f553:	ff 75 ec             	pushl  -0x14(%ebp)
f011f556:	68 0b 0d 13 f0       	push   $0xf0130d0b
f011f55b:	e8 2b 1a fe ff       	call   f0100f8b <cprintf>
f011f560:	83 c4 10             	add    $0x10,%esp
				break;
f011f563:	e9 95 00 00 00       	jmp    f011f5fd <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011f568:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f56c:	7e 34                	jle    f011f5a2 <atomic_readline+0xa5>
f011f56e:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f575:	7f 2b                	jg     f011f5a2 <atomic_readline+0xa5>
				if (echoing)
f011f577:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f57b:	74 0e                	je     f011f58b <atomic_readline+0x8e>
					cputchar(c);
f011f57d:	83 ec 0c             	sub    $0xc,%esp
f011f580:	ff 75 ec             	pushl  -0x14(%ebp)
f011f583:	e8 e0 18 fe ff       	call   f0100e68 <cputchar>
f011f588:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011f58b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f58e:	8d 50 01             	lea    0x1(%eax),%edx
f011f591:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f594:	89 c2                	mov    %eax,%edx
f011f596:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f599:	01 d0                	add    %edx,%eax
f011f59b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f59e:	88 10                	mov    %dl,(%eax)
f011f5a0:	eb 56                	jmp    f011f5f8 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011f5a2:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f5a6:	75 1f                	jne    f011f5c7 <atomic_readline+0xca>
f011f5a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f5ac:	7e 19                	jle    f011f5c7 <atomic_readline+0xca>
				if (echoing)
f011f5ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f5b2:	74 0e                	je     f011f5c2 <atomic_readline+0xc5>
					cputchar(c);
f011f5b4:	83 ec 0c             	sub    $0xc,%esp
f011f5b7:	ff 75 ec             	pushl  -0x14(%ebp)
f011f5ba:	e8 a9 18 fe ff       	call   f0100e68 <cputchar>
f011f5bf:	83 c4 10             	add    $0x10,%esp
				i--;
f011f5c2:	ff 4d f4             	decl   -0xc(%ebp)
f011f5c5:	eb 31                	jmp    f011f5f8 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011f5c7:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f5cb:	74 0a                	je     f011f5d7 <atomic_readline+0xda>
f011f5cd:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f5d1:	0f 85 61 ff ff ff    	jne    f011f538 <atomic_readline+0x3b>
				if (echoing)
f011f5d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f5db:	74 0e                	je     f011f5eb <atomic_readline+0xee>
					cputchar(c);
f011f5dd:	83 ec 0c             	sub    $0xc,%esp
f011f5e0:	ff 75 ec             	pushl  -0x14(%ebp)
f011f5e3:	e8 80 18 fe ff       	call   f0100e68 <cputchar>
f011f5e8:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011f5eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f5ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5f1:	01 d0                	add    %edx,%eax
f011f5f3:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011f5f6:	eb 06                	jmp    f011f5fe <atomic_readline+0x101>
			}
		}
f011f5f8:	e9 3b ff ff ff       	jmp    f011f538 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011f5fd:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011f5fe:	e8 40 eb fe ff       	call   f010e143 <sys_unlock_cons>
}
f011f603:	90                   	nop
f011f604:	c9                   	leave  
f011f605:	c3                   	ret    

f011f606 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011f606:	55                   	push   %ebp
f011f607:	89 e5                	mov    %esp,%ebp
f011f609:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011f60c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f613:	eb 06                	jmp    f011f61b <strlen+0x15>
		n++;
f011f615:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011f618:	ff 45 08             	incl   0x8(%ebp)
f011f61b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f61e:	8a 00                	mov    (%eax),%al
f011f620:	84 c0                	test   %al,%al
f011f622:	75 f1                	jne    f011f615 <strlen+0xf>
		n++;
	return n;
f011f624:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f627:	c9                   	leave  
f011f628:	c3                   	ret    

f011f629 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011f629:	55                   	push   %ebp
f011f62a:	89 e5                	mov    %esp,%ebp
f011f62c:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f62f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f636:	eb 09                	jmp    f011f641 <strnlen+0x18>
		n++;
f011f638:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f63b:	ff 45 08             	incl   0x8(%ebp)
f011f63e:	ff 4d 0c             	decl   0xc(%ebp)
f011f641:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f645:	74 09                	je     f011f650 <strnlen+0x27>
f011f647:	8b 45 08             	mov    0x8(%ebp),%eax
f011f64a:	8a 00                	mov    (%eax),%al
f011f64c:	84 c0                	test   %al,%al
f011f64e:	75 e8                	jne    f011f638 <strnlen+0xf>
		n++;
	return n;
f011f650:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f653:	c9                   	leave  
f011f654:	c3                   	ret    

f011f655 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011f655:	55                   	push   %ebp
f011f656:	89 e5                	mov    %esp,%ebp
f011f658:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011f65b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f65e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011f661:	90                   	nop
f011f662:	8b 45 08             	mov    0x8(%ebp),%eax
f011f665:	8d 50 01             	lea    0x1(%eax),%edx
f011f668:	89 55 08             	mov    %edx,0x8(%ebp)
f011f66b:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f66e:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f671:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f674:	8a 12                	mov    (%edx),%dl
f011f676:	88 10                	mov    %dl,(%eax)
f011f678:	8a 00                	mov    (%eax),%al
f011f67a:	84 c0                	test   %al,%al
f011f67c:	75 e4                	jne    f011f662 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011f67e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f681:	c9                   	leave  
f011f682:	c3                   	ret    

f011f683 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011f683:	55                   	push   %ebp
f011f684:	89 e5                	mov    %esp,%ebp
f011f686:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011f689:	8b 45 08             	mov    0x8(%ebp),%eax
f011f68c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011f68f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f696:	eb 1f                	jmp    f011f6b7 <strncpy+0x34>
		*dst++ = *src;
f011f698:	8b 45 08             	mov    0x8(%ebp),%eax
f011f69b:	8d 50 01             	lea    0x1(%eax),%edx
f011f69e:	89 55 08             	mov    %edx,0x8(%ebp)
f011f6a1:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f6a4:	8a 12                	mov    (%edx),%dl
f011f6a6:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011f6a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6ab:	8a 00                	mov    (%eax),%al
f011f6ad:	84 c0                	test   %al,%al
f011f6af:	74 03                	je     f011f6b4 <strncpy+0x31>
			src++;
f011f6b1:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011f6b4:	ff 45 fc             	incl   -0x4(%ebp)
f011f6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f6ba:	3b 45 10             	cmp    0x10(%ebp),%eax
f011f6bd:	72 d9                	jb     f011f698 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011f6bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011f6c2:	c9                   	leave  
f011f6c3:	c3                   	ret    

f011f6c4 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011f6c4:	55                   	push   %ebp
f011f6c5:	89 e5                	mov    %esp,%ebp
f011f6c7:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011f6ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011f6d0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f6d4:	74 30                	je     f011f706 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011f6d6:	eb 16                	jmp    f011f6ee <strlcpy+0x2a>
			*dst++ = *src++;
f011f6d8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6db:	8d 50 01             	lea    0x1(%eax),%edx
f011f6de:	89 55 08             	mov    %edx,0x8(%ebp)
f011f6e1:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f6e4:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f6e7:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f6ea:	8a 12                	mov    (%edx),%dl
f011f6ec:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011f6ee:	ff 4d 10             	decl   0x10(%ebp)
f011f6f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f6f5:	74 09                	je     f011f700 <strlcpy+0x3c>
f011f6f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6fa:	8a 00                	mov    (%eax),%al
f011f6fc:	84 c0                	test   %al,%al
f011f6fe:	75 d8                	jne    f011f6d8 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011f700:	8b 45 08             	mov    0x8(%ebp),%eax
f011f703:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011f706:	8b 55 08             	mov    0x8(%ebp),%edx
f011f709:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f70c:	29 c2                	sub    %eax,%edx
f011f70e:	89 d0                	mov    %edx,%eax
}
f011f710:	c9                   	leave  
f011f711:	c3                   	ret    

f011f712 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011f712:	55                   	push   %ebp
f011f713:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011f715:	eb 06                	jmp    f011f71d <strcmp+0xb>
		p++, q++;
f011f717:	ff 45 08             	incl   0x8(%ebp)
f011f71a:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011f71d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f720:	8a 00                	mov    (%eax),%al
f011f722:	84 c0                	test   %al,%al
f011f724:	74 0e                	je     f011f734 <strcmp+0x22>
f011f726:	8b 45 08             	mov    0x8(%ebp),%eax
f011f729:	8a 10                	mov    (%eax),%dl
f011f72b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f72e:	8a 00                	mov    (%eax),%al
f011f730:	38 c2                	cmp    %al,%dl
f011f732:	74 e3                	je     f011f717 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011f734:	8b 45 08             	mov    0x8(%ebp),%eax
f011f737:	8a 00                	mov    (%eax),%al
f011f739:	0f b6 d0             	movzbl %al,%edx
f011f73c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f73f:	8a 00                	mov    (%eax),%al
f011f741:	0f b6 c0             	movzbl %al,%eax
f011f744:	29 c2                	sub    %eax,%edx
f011f746:	89 d0                	mov    %edx,%eax
}
f011f748:	5d                   	pop    %ebp
f011f749:	c3                   	ret    

f011f74a <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011f74a:	55                   	push   %ebp
f011f74b:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011f74d:	eb 09                	jmp    f011f758 <strncmp+0xe>
		n--, p++, q++;
f011f74f:	ff 4d 10             	decl   0x10(%ebp)
f011f752:	ff 45 08             	incl   0x8(%ebp)
f011f755:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011f758:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f75c:	74 17                	je     f011f775 <strncmp+0x2b>
f011f75e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f761:	8a 00                	mov    (%eax),%al
f011f763:	84 c0                	test   %al,%al
f011f765:	74 0e                	je     f011f775 <strncmp+0x2b>
f011f767:	8b 45 08             	mov    0x8(%ebp),%eax
f011f76a:	8a 10                	mov    (%eax),%dl
f011f76c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f76f:	8a 00                	mov    (%eax),%al
f011f771:	38 c2                	cmp    %al,%dl
f011f773:	74 da                	je     f011f74f <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011f775:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f779:	75 07                	jne    f011f782 <strncmp+0x38>
		return 0;
f011f77b:	b8 00 00 00 00       	mov    $0x0,%eax
f011f780:	eb 14                	jmp    f011f796 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011f782:	8b 45 08             	mov    0x8(%ebp),%eax
f011f785:	8a 00                	mov    (%eax),%al
f011f787:	0f b6 d0             	movzbl %al,%edx
f011f78a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f78d:	8a 00                	mov    (%eax),%al
f011f78f:	0f b6 c0             	movzbl %al,%eax
f011f792:	29 c2                	sub    %eax,%edx
f011f794:	89 d0                	mov    %edx,%eax
}
f011f796:	5d                   	pop    %ebp
f011f797:	c3                   	ret    

f011f798 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011f798:	55                   	push   %ebp
f011f799:	89 e5                	mov    %esp,%ebp
f011f79b:	83 ec 04             	sub    $0x4,%esp
f011f79e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7a1:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f7a4:	eb 12                	jmp    f011f7b8 <strchr+0x20>
		if (*s == c)
f011f7a6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7a9:	8a 00                	mov    (%eax),%al
f011f7ab:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f7ae:	75 05                	jne    f011f7b5 <strchr+0x1d>
			return (char *) s;
f011f7b0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7b3:	eb 11                	jmp    f011f7c6 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011f7b5:	ff 45 08             	incl   0x8(%ebp)
f011f7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7bb:	8a 00                	mov    (%eax),%al
f011f7bd:	84 c0                	test   %al,%al
f011f7bf:	75 e5                	jne    f011f7a6 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011f7c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f7c6:	c9                   	leave  
f011f7c7:	c3                   	ret    

f011f7c8 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011f7c8:	55                   	push   %ebp
f011f7c9:	89 e5                	mov    %esp,%ebp
f011f7cb:	83 ec 04             	sub    $0x4,%esp
f011f7ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7d1:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f7d4:	eb 0d                	jmp    f011f7e3 <strfind+0x1b>
		if (*s == c)
f011f7d6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7d9:	8a 00                	mov    (%eax),%al
f011f7db:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f7de:	74 0e                	je     f011f7ee <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011f7e0:	ff 45 08             	incl   0x8(%ebp)
f011f7e3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7e6:	8a 00                	mov    (%eax),%al
f011f7e8:	84 c0                	test   %al,%al
f011f7ea:	75 ea                	jne    f011f7d6 <strfind+0xe>
f011f7ec:	eb 01                	jmp    f011f7ef <strfind+0x27>
		if (*s == c)
			break;
f011f7ee:	90                   	nop
	return (char *) s;
f011f7ef:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f7f2:	c9                   	leave  
f011f7f3:	c3                   	ret    

f011f7f4 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011f7f4:	55                   	push   %ebp
f011f7f5:	89 e5                	mov    %esp,%ebp
f011f7f7:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011f7fa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011f800:	8b 45 10             	mov    0x10(%ebp),%eax
f011f803:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011f806:	eb 0e                	jmp    f011f816 <memset+0x22>
		*p++ = c;
f011f808:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f80b:	8d 50 01             	lea    0x1(%eax),%edx
f011f80e:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011f811:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f814:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011f816:	ff 4d f8             	decl   -0x8(%ebp)
f011f819:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011f81d:	79 e9                	jns    f011f808 <memset+0x14>
		*p++ = c;

	return v;
f011f81f:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f822:	c9                   	leave  
f011f823:	c3                   	ret    

f011f824 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011f824:	55                   	push   %ebp
f011f825:	89 e5                	mov    %esp,%ebp
f011f827:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f82a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f82d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f830:	8b 45 08             	mov    0x8(%ebp),%eax
f011f833:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011f836:	eb 16                	jmp    f011f84e <memcpy+0x2a>
		*d++ = *s++;
f011f838:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f83b:	8d 50 01             	lea    0x1(%eax),%edx
f011f83e:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f841:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f844:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f847:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f84a:	8a 12                	mov    (%edx),%dl
f011f84c:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011f84e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f851:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f854:	89 55 10             	mov    %edx,0x10(%ebp)
f011f857:	85 c0                	test   %eax,%eax
f011f859:	75 dd                	jne    f011f838 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011f85b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f85e:	c9                   	leave  
f011f85f:	c3                   	ret    

f011f860 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011f860:	55                   	push   %ebp
f011f861:	89 e5                	mov    %esp,%ebp
f011f863:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f866:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f869:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f86c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f86f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011f872:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f875:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f878:	73 50                	jae    f011f8ca <memmove+0x6a>
f011f87a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f87d:	8b 45 10             	mov    0x10(%ebp),%eax
f011f880:	01 d0                	add    %edx,%eax
f011f882:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f885:	76 43                	jbe    f011f8ca <memmove+0x6a>
		s += n;
f011f887:	8b 45 10             	mov    0x10(%ebp),%eax
f011f88a:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011f88d:	8b 45 10             	mov    0x10(%ebp),%eax
f011f890:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011f893:	eb 10                	jmp    f011f8a5 <memmove+0x45>
			*--d = *--s;
f011f895:	ff 4d f8             	decl   -0x8(%ebp)
f011f898:	ff 4d fc             	decl   -0x4(%ebp)
f011f89b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f89e:	8a 10                	mov    (%eax),%dl
f011f8a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f8a3:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011f8a5:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8a8:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f8ab:	89 55 10             	mov    %edx,0x10(%ebp)
f011f8ae:	85 c0                	test   %eax,%eax
f011f8b0:	75 e3                	jne    f011f895 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011f8b2:	eb 23                	jmp    f011f8d7 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011f8b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f8b7:	8d 50 01             	lea    0x1(%eax),%edx
f011f8ba:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f8bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f8c0:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f8c3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f8c6:	8a 12                	mov    (%edx),%dl
f011f8c8:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011f8ca:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8cd:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f8d0:	89 55 10             	mov    %edx,0x10(%ebp)
f011f8d3:	85 c0                	test   %eax,%eax
f011f8d5:	75 dd                	jne    f011f8b4 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011f8d7:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f8da:	c9                   	leave  
f011f8db:	c3                   	ret    

f011f8dc <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011f8dc:	55                   	push   %ebp
f011f8dd:	89 e5                	mov    %esp,%ebp
f011f8df:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011f8e2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8e5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011f8e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f8eb:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011f8ee:	eb 2a                	jmp    f011f91a <memcmp+0x3e>
		if (*s1 != *s2)
f011f8f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f8f3:	8a 10                	mov    (%eax),%dl
f011f8f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f8f8:	8a 00                	mov    (%eax),%al
f011f8fa:	38 c2                	cmp    %al,%dl
f011f8fc:	74 16                	je     f011f914 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011f8fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f901:	8a 00                	mov    (%eax),%al
f011f903:	0f b6 d0             	movzbl %al,%edx
f011f906:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f909:	8a 00                	mov    (%eax),%al
f011f90b:	0f b6 c0             	movzbl %al,%eax
f011f90e:	29 c2                	sub    %eax,%edx
f011f910:	89 d0                	mov    %edx,%eax
f011f912:	eb 18                	jmp    f011f92c <memcmp+0x50>
		s1++, s2++;
f011f914:	ff 45 fc             	incl   -0x4(%ebp)
f011f917:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011f91a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f91d:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f920:	89 55 10             	mov    %edx,0x10(%ebp)
f011f923:	85 c0                	test   %eax,%eax
f011f925:	75 c9                	jne    f011f8f0 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011f927:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f92c:	c9                   	leave  
f011f92d:	c3                   	ret    

f011f92e <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011f92e:	55                   	push   %ebp
f011f92f:	89 e5                	mov    %esp,%ebp
f011f931:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011f934:	8b 55 08             	mov    0x8(%ebp),%edx
f011f937:	8b 45 10             	mov    0x10(%ebp),%eax
f011f93a:	01 d0                	add    %edx,%eax
f011f93c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011f93f:	eb 15                	jmp    f011f956 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011f941:	8b 45 08             	mov    0x8(%ebp),%eax
f011f944:	8a 00                	mov    (%eax),%al
f011f946:	0f b6 d0             	movzbl %al,%edx
f011f949:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f94c:	0f b6 c0             	movzbl %al,%eax
f011f94f:	39 c2                	cmp    %eax,%edx
f011f951:	74 0d                	je     f011f960 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011f953:	ff 45 08             	incl   0x8(%ebp)
f011f956:	8b 45 08             	mov    0x8(%ebp),%eax
f011f959:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011f95c:	72 e3                	jb     f011f941 <memfind+0x13>
f011f95e:	eb 01                	jmp    f011f961 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011f960:	90                   	nop
	return (void *) s;
f011f961:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f964:	c9                   	leave  
f011f965:	c3                   	ret    

f011f966 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011f966:	55                   	push   %ebp
f011f967:	89 e5                	mov    %esp,%ebp
f011f969:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011f96c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011f973:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f97a:	eb 03                	jmp    f011f97f <strtol+0x19>
		s++;
f011f97c:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f97f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f982:	8a 00                	mov    (%eax),%al
f011f984:	3c 20                	cmp    $0x20,%al
f011f986:	74 f4                	je     f011f97c <strtol+0x16>
f011f988:	8b 45 08             	mov    0x8(%ebp),%eax
f011f98b:	8a 00                	mov    (%eax),%al
f011f98d:	3c 09                	cmp    $0x9,%al
f011f98f:	74 eb                	je     f011f97c <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011f991:	8b 45 08             	mov    0x8(%ebp),%eax
f011f994:	8a 00                	mov    (%eax),%al
f011f996:	3c 2b                	cmp    $0x2b,%al
f011f998:	75 05                	jne    f011f99f <strtol+0x39>
		s++;
f011f99a:	ff 45 08             	incl   0x8(%ebp)
f011f99d:	eb 13                	jmp    f011f9b2 <strtol+0x4c>
	else if (*s == '-')
f011f99f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9a2:	8a 00                	mov    (%eax),%al
f011f9a4:	3c 2d                	cmp    $0x2d,%al
f011f9a6:	75 0a                	jne    f011f9b2 <strtol+0x4c>
		s++, neg = 1;
f011f9a8:	ff 45 08             	incl   0x8(%ebp)
f011f9ab:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011f9b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f9b6:	74 06                	je     f011f9be <strtol+0x58>
f011f9b8:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011f9bc:	75 20                	jne    f011f9de <strtol+0x78>
f011f9be:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9c1:	8a 00                	mov    (%eax),%al
f011f9c3:	3c 30                	cmp    $0x30,%al
f011f9c5:	75 17                	jne    f011f9de <strtol+0x78>
f011f9c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9ca:	40                   	inc    %eax
f011f9cb:	8a 00                	mov    (%eax),%al
f011f9cd:	3c 78                	cmp    $0x78,%al
f011f9cf:	75 0d                	jne    f011f9de <strtol+0x78>
		s += 2, base = 16;
f011f9d1:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011f9d5:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011f9dc:	eb 28                	jmp    f011fa06 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011f9de:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f9e2:	75 15                	jne    f011f9f9 <strtol+0x93>
f011f9e4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9e7:	8a 00                	mov    (%eax),%al
f011f9e9:	3c 30                	cmp    $0x30,%al
f011f9eb:	75 0c                	jne    f011f9f9 <strtol+0x93>
		s++, base = 8;
f011f9ed:	ff 45 08             	incl   0x8(%ebp)
f011f9f0:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011f9f7:	eb 0d                	jmp    f011fa06 <strtol+0xa0>
	else if (base == 0)
f011f9f9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f9fd:	75 07                	jne    f011fa06 <strtol+0xa0>
		base = 10;
f011f9ff:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011fa06:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa09:	8a 00                	mov    (%eax),%al
f011fa0b:	3c 2f                	cmp    $0x2f,%al
f011fa0d:	7e 19                	jle    f011fa28 <strtol+0xc2>
f011fa0f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa12:	8a 00                	mov    (%eax),%al
f011fa14:	3c 39                	cmp    $0x39,%al
f011fa16:	7f 10                	jg     f011fa28 <strtol+0xc2>
			dig = *s - '0';
f011fa18:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa1b:	8a 00                	mov    (%eax),%al
f011fa1d:	0f be c0             	movsbl %al,%eax
f011fa20:	83 e8 30             	sub    $0x30,%eax
f011fa23:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fa26:	eb 42                	jmp    f011fa6a <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011fa28:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa2b:	8a 00                	mov    (%eax),%al
f011fa2d:	3c 60                	cmp    $0x60,%al
f011fa2f:	7e 19                	jle    f011fa4a <strtol+0xe4>
f011fa31:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa34:	8a 00                	mov    (%eax),%al
f011fa36:	3c 7a                	cmp    $0x7a,%al
f011fa38:	7f 10                	jg     f011fa4a <strtol+0xe4>
			dig = *s - 'a' + 10;
f011fa3a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa3d:	8a 00                	mov    (%eax),%al
f011fa3f:	0f be c0             	movsbl %al,%eax
f011fa42:	83 e8 57             	sub    $0x57,%eax
f011fa45:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fa48:	eb 20                	jmp    f011fa6a <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011fa4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa4d:	8a 00                	mov    (%eax),%al
f011fa4f:	3c 40                	cmp    $0x40,%al
f011fa51:	7e 39                	jle    f011fa8c <strtol+0x126>
f011fa53:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa56:	8a 00                	mov    (%eax),%al
f011fa58:	3c 5a                	cmp    $0x5a,%al
f011fa5a:	7f 30                	jg     f011fa8c <strtol+0x126>
			dig = *s - 'A' + 10;
f011fa5c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa5f:	8a 00                	mov    (%eax),%al
f011fa61:	0f be c0             	movsbl %al,%eax
f011fa64:	83 e8 37             	sub    $0x37,%eax
f011fa67:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011fa6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa6d:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fa70:	7d 19                	jge    f011fa8b <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011fa72:	ff 45 08             	incl   0x8(%ebp)
f011fa75:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fa78:	0f af 45 10          	imul   0x10(%ebp),%eax
f011fa7c:	89 c2                	mov    %eax,%edx
f011fa7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa81:	01 d0                	add    %edx,%eax
f011fa83:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011fa86:	e9 7b ff ff ff       	jmp    f011fa06 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011fa8b:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011fa8c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fa90:	74 08                	je     f011fa9a <strtol+0x134>
		*endptr = (char *) s;
f011fa92:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa95:	8b 55 08             	mov    0x8(%ebp),%edx
f011fa98:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011fa9a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011fa9e:	74 07                	je     f011faa7 <strtol+0x141>
f011faa0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011faa3:	f7 d8                	neg    %eax
f011faa5:	eb 03                	jmp    f011faaa <strtol+0x144>
f011faa7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011faaa:	c9                   	leave  
f011faab:	c3                   	ret    

f011faac <ltostr>:

void
ltostr(long value, char *str)
{
f011faac:	55                   	push   %ebp
f011faad:	89 e5                	mov    %esp,%ebp
f011faaf:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011fab2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011fab9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011fac0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fac4:	79 13                	jns    f011fad9 <ltostr+0x2d>
	{
		neg = 1;
f011fac6:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011facd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fad0:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011fad3:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011fad6:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011fad9:	8b 45 08             	mov    0x8(%ebp),%eax
f011fadc:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011fae1:	99                   	cltd   
f011fae2:	f7 f9                	idiv   %ecx
f011fae4:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011fae7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011faea:	8d 50 01             	lea    0x1(%eax),%edx
f011faed:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011faf0:	89 c2                	mov    %eax,%edx
f011faf2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011faf5:	01 d0                	add    %edx,%eax
f011faf7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fafa:	83 c2 30             	add    $0x30,%edx
f011fafd:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011faff:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011fb02:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011fb07:	f7 e9                	imul   %ecx
f011fb09:	c1 fa 02             	sar    $0x2,%edx
f011fb0c:	89 c8                	mov    %ecx,%eax
f011fb0e:	c1 f8 1f             	sar    $0x1f,%eax
f011fb11:	29 c2                	sub    %eax,%edx
f011fb13:	89 d0                	mov    %edx,%eax
f011fb15:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011fb18:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fb1c:	75 bb                	jne    f011fad9 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011fb1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011fb25:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fb28:	48                   	dec    %eax
f011fb29:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011fb2c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011fb30:	74 3d                	je     f011fb6f <ltostr+0xc3>
		start = 1 ;
f011fb32:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011fb39:	eb 34                	jmp    f011fb6f <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011fb3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb41:	01 d0                	add    %edx,%eax
f011fb43:	8a 00                	mov    (%eax),%al
f011fb45:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011fb48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb4e:	01 c2                	add    %eax,%edx
f011fb50:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011fb53:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb56:	01 c8                	add    %ecx,%eax
f011fb58:	8a 00                	mov    (%eax),%al
f011fb5a:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011fb5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fb5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb62:	01 c2                	add    %eax,%edx
f011fb64:	8a 45 eb             	mov    -0x15(%ebp),%al
f011fb67:	88 02                	mov    %al,(%edx)
		start++ ;
f011fb69:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011fb6c:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011fb6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb72:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fb75:	7c c4                	jl     f011fb3b <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011fb77:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011fb7a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb7d:	01 d0                	add    %edx,%eax
f011fb7f:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011fb82:	90                   	nop
f011fb83:	c9                   	leave  
f011fb84:	c3                   	ret    

f011fb85 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011fb85:	55                   	push   %ebp
f011fb86:	89 e5                	mov    %esp,%ebp
f011fb88:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011fb8b:	ff 75 08             	pushl  0x8(%ebp)
f011fb8e:	e8 73 fa ff ff       	call   f011f606 <strlen>
f011fb93:	83 c4 04             	add    $0x4,%esp
f011fb96:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011fb99:	ff 75 0c             	pushl  0xc(%ebp)
f011fb9c:	e8 65 fa ff ff       	call   f011f606 <strlen>
f011fba1:	83 c4 04             	add    $0x4,%esp
f011fba4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011fba7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011fbae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fbb5:	eb 17                	jmp    f011fbce <strcconcat+0x49>
		final[s] = str1[s] ;
f011fbb7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fbba:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbbd:	01 c2                	add    %eax,%edx
f011fbbf:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011fbc2:	8b 45 08             	mov    0x8(%ebp),%eax
f011fbc5:	01 c8                	add    %ecx,%eax
f011fbc7:	8a 00                	mov    (%eax),%al
f011fbc9:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011fbcb:	ff 45 fc             	incl   -0x4(%ebp)
f011fbce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fbd1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011fbd4:	7c e1                	jl     f011fbb7 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011fbd6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011fbdd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011fbe4:	eb 1f                	jmp    f011fc05 <strcconcat+0x80>
		final[s++] = str2[i] ;
f011fbe6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fbe9:	8d 50 01             	lea    0x1(%eax),%edx
f011fbec:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fbef:	89 c2                	mov    %eax,%edx
f011fbf1:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbf4:	01 c2                	add    %eax,%edx
f011fbf6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011fbf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbfc:	01 c8                	add    %ecx,%eax
f011fbfe:	8a 00                	mov    (%eax),%al
f011fc00:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011fc02:	ff 45 f8             	incl   -0x8(%ebp)
f011fc05:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fc08:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fc0b:	7c d9                	jl     f011fbe6 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011fc0d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fc10:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc13:	01 d0                	add    %edx,%eax
f011fc15:	c6 00 00             	movb   $0x0,(%eax)
}
f011fc18:	90                   	nop
f011fc19:	c9                   	leave  
f011fc1a:	c3                   	ret    

f011fc1b <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011fc1b:	55                   	push   %ebp
f011fc1c:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011fc1e:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc21:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011fc27:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc2a:	8b 00                	mov    (%eax),%eax
f011fc2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc33:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc36:	01 d0                	add    %edx,%eax
f011fc38:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fc3e:	eb 0c                	jmp    f011fc4c <strsplit+0x31>
			*string++ = 0;
f011fc40:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc43:	8d 50 01             	lea    0x1(%eax),%edx
f011fc46:	89 55 08             	mov    %edx,0x8(%ebp)
f011fc49:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fc4c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc4f:	8a 00                	mov    (%eax),%al
f011fc51:	84 c0                	test   %al,%al
f011fc53:	74 18                	je     f011fc6d <strsplit+0x52>
f011fc55:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc58:	8a 00                	mov    (%eax),%al
f011fc5a:	0f be c0             	movsbl %al,%eax
f011fc5d:	50                   	push   %eax
f011fc5e:	ff 75 0c             	pushl  0xc(%ebp)
f011fc61:	e8 32 fb ff ff       	call   f011f798 <strchr>
f011fc66:	83 c4 08             	add    $0x8,%esp
f011fc69:	85 c0                	test   %eax,%eax
f011fc6b:	75 d3                	jne    f011fc40 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011fc6d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc70:	8a 00                	mov    (%eax),%al
f011fc72:	84 c0                	test   %al,%al
f011fc74:	74 5a                	je     f011fcd0 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011fc76:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc79:	8b 00                	mov    (%eax),%eax
f011fc7b:	83 f8 0f             	cmp    $0xf,%eax
f011fc7e:	75 07                	jne    f011fc87 <strsplit+0x6c>
		{
			return 0;
f011fc80:	b8 00 00 00 00       	mov    $0x0,%eax
f011fc85:	eb 66                	jmp    f011fced <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011fc87:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc8a:	8b 00                	mov    (%eax),%eax
f011fc8c:	8d 48 01             	lea    0x1(%eax),%ecx
f011fc8f:	8b 55 14             	mov    0x14(%ebp),%edx
f011fc92:	89 0a                	mov    %ecx,(%edx)
f011fc94:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc9b:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc9e:	01 c2                	add    %eax,%edx
f011fca0:	8b 45 08             	mov    0x8(%ebp),%eax
f011fca3:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fca5:	eb 03                	jmp    f011fcaa <strsplit+0x8f>
			string++;
f011fca7:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fcaa:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcad:	8a 00                	mov    (%eax),%al
f011fcaf:	84 c0                	test   %al,%al
f011fcb1:	74 8b                	je     f011fc3e <strsplit+0x23>
f011fcb3:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcb6:	8a 00                	mov    (%eax),%al
f011fcb8:	0f be c0             	movsbl %al,%eax
f011fcbb:	50                   	push   %eax
f011fcbc:	ff 75 0c             	pushl  0xc(%ebp)
f011fcbf:	e8 d4 fa ff ff       	call   f011f798 <strchr>
f011fcc4:	83 c4 08             	add    $0x8,%esp
f011fcc7:	85 c0                	test   %eax,%eax
f011fcc9:	74 dc                	je     f011fca7 <strsplit+0x8c>
			string++;
	}
f011fccb:	e9 6e ff ff ff       	jmp    f011fc3e <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011fcd0:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011fcd1:	8b 45 14             	mov    0x14(%ebp),%eax
f011fcd4:	8b 00                	mov    (%eax),%eax
f011fcd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fcdd:	8b 45 10             	mov    0x10(%ebp),%eax
f011fce0:	01 d0                	add    %edx,%eax
f011fce2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011fce8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011fced:	c9                   	leave  
f011fcee:	c3                   	ret    

f011fcef <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011fcef:	55                   	push   %ebp
f011fcf0:	89 e5                	mov    %esp,%ebp
f011fcf2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011fcf5:	83 ec 04             	sub    $0x4,%esp
f011fcf8:	68 1c 0d 13 f0       	push   $0xf0130d1c
f011fcfd:	68 3f 01 00 00       	push   $0x13f
f011fd02:	68 3e 0d 13 f0       	push   $0xf0130d3e
f011fd07:	e8 2d 06 fe ff       	call   f0100339 <_panic>

f011fd0c <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011fd0c:	55                   	push   %ebp
f011fd0d:	89 e5                	mov    %esp,%ebp
f011fd0f:	83 ec 18             	sub    $0x18,%esp
f011fd12:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fd19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd1c:	89 c2                	mov    %eax,%edx
f011fd1e:	ec                   	in     (%dx),%al
f011fd1f:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fd22:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fd25:	0f b6 c0             	movzbl %al,%eax
f011fd28:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fd2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fd2e:	25 c0 00 00 00       	and    $0xc0,%eax
f011fd33:	83 f8 40             	cmp    $0x40,%eax
f011fd36:	75 10                	jne    f011fd48 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011fd38:	83 ec 0c             	sub    $0xc,%esp
f011fd3b:	68 c0 d1 6b f0       	push   $0xf06bd1c0
f011fd40:	e8 5a fd fe ff       	call   f010fa9f <wakeup_one>
f011fd45:	83 c4 10             	add    $0x10,%esp
	}

}
f011fd48:	90                   	nop
f011fd49:	c9                   	leave  
f011fd4a:	c3                   	ret    

f011fd4b <ide_init>:

void ide_init()
{
f011fd4b:	55                   	push   %ebp
f011fd4c:	89 e5                	mov    %esp,%ebp
f011fd4e:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011fd51:	83 ec 08             	sub    $0x8,%esp
f011fd54:	68 0c fd 11 f0       	push   $0xf011fd0c
f011fd59:	6a 0e                	push   $0xe
f011fd5b:	e8 dc de fe ff       	call   f010dc3c <irq_install_handler>
f011fd60:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011fd63:	83 ec 08             	sub    $0x8,%esp
f011fd66:	68 4c 0d 13 f0       	push   $0xf0130d4c
f011fd6b:	68 c0 d1 6b f0       	push   $0xf06bd1c0
f011fd70:	e8 90 fc fe ff       	call   f010fa05 <init_channel>
f011fd75:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011fd78:	83 ec 08             	sub    $0x8,%esp
f011fd7b:	68 59 0d 13 f0       	push   $0xf0130d59
f011fd80:	68 e0 d7 6b f0       	push   $0xf06bd7e0
f011fd85:	e8 8a f8 fe ff       	call   f010f614 <init_spinlock>
f011fd8a:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011fd8d:	90                   	nop
f011fd8e:	c9                   	leave  
f011fd8f:	c3                   	ret    

f011fd90 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011fd90:	55                   	push   %ebp
f011fd91:	89 e5                	mov    %esp,%ebp
f011fd93:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fd96:	90                   	nop
f011fd97:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fd9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fda1:	89 c2                	mov    %eax,%edx
f011fda3:	ec                   	in     (%dx),%al
f011fda4:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fda7:	8a 45 ef             	mov    -0x11(%ebp),%al
f011fdaa:	0f b6 c0             	movzbl %al,%eax
f011fdad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fdb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fdb3:	25 c0 00 00 00       	and    $0xc0,%eax
f011fdb8:	83 f8 40             	cmp    $0x40,%eax
f011fdbb:	75 da                	jne    f011fd97 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011fdbd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fdc1:	74 24                	je     f011fde7 <ide_wait_ready+0x57>
f011fdc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fdc6:	83 e0 21             	and    $0x21,%eax
f011fdc9:	85 c0                	test   %eax,%eax
f011fdcb:	74 1a                	je     f011fde7 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011fdcd:	83 ec 0c             	sub    $0xc,%esp
f011fdd0:	ff 75 f4             	pushl  -0xc(%ebp)
f011fdd3:	ff 75 f4             	pushl  -0xc(%ebp)
f011fdd6:	68 6c 0d 13 f0       	push   $0xf0130d6c
f011fddb:	6a 5d                	push   $0x5d
f011fddd:	68 8f 0d 13 f0       	push   $0xf0130d8f
f011fde2:	e8 52 05 fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011fde7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fdec:	c9                   	leave  
f011fded:	c3                   	ret    

f011fdee <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011fdee:	55                   	push   %ebp
f011fdef:	89 e5                	mov    %esp,%ebp
f011fdf1:	57                   	push   %edi
f011fdf2:	53                   	push   %ebx
f011fdf3:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011fdf6:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011fdfd:	76 16                	jbe    f011fe15 <ide_read+0x27>
f011fdff:	68 9a 0d 13 f0       	push   $0xf0130d9a
f011fe04:	68 a7 0d 13 f0       	push   $0xf0130da7
f011fe09:	6a 68                	push   $0x68
f011fe0b:	68 8f 0d 13 f0       	push   $0xf0130d8f
f011fe10:	e8 24 05 fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011fe15:	83 ec 0c             	sub    $0xc,%esp
f011fe18:	6a 00                	push   $0x0
f011fe1a:	e8 71 ff ff ff       	call   f011fd90 <ide_wait_ready>
f011fe1f:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011fe22:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe25:	0f b6 c0             	movzbl %al,%eax
f011fe28:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011fe2f:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011fe32:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011fe35:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fe38:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011fe39:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe3c:	0f b6 c0             	movzbl %al,%eax
f011fe3f:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011fe46:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011fe49:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011fe4c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fe4f:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011fe50:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe53:	c1 e8 08             	shr    $0x8,%eax
f011fe56:	0f b6 c0             	movzbl %al,%eax
f011fe59:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011fe60:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011fe63:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011fe66:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011fe69:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011fe6a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe6d:	c1 e8 10             	shr    $0x10,%eax
f011fe70:	0f b6 c0             	movzbl %al,%eax
f011fe73:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011fe7a:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011fe7d:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011fe80:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fe83:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011fe84:	a1 70 d0 6b f0       	mov    0xf06bd070,%eax
f011fe89:	83 e0 01             	and    $0x1,%eax
f011fe8c:	c1 e0 04             	shl    $0x4,%eax
f011fe8f:	88 c2                	mov    %al,%dl
f011fe91:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe94:	c1 e8 18             	shr    $0x18,%eax
f011fe97:	83 e0 0f             	and    $0xf,%eax
f011fe9a:	09 d0                	or     %edx,%eax
f011fe9c:	83 c8 e0             	or     $0xffffffe0,%eax
f011fe9f:	0f b6 c0             	movzbl %al,%eax
f011fea2:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011fea9:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011feac:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011feaf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011feb2:	ee                   	out    %al,(%dx)
f011feb3:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011feba:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011febe:	8a 45 d7             	mov    -0x29(%ebp),%al
f011fec1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011fec4:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011fec5:	eb 55                	jmp    f011ff1c <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011fec7:	83 ec 0c             	sub    $0xc,%esp
f011feca:	6a 01                	push   $0x1
f011fecc:	e8 bf fe ff ff       	call   f011fd90 <ide_wait_ready>
f011fed1:	83 c4 10             	add    $0x10,%esp
f011fed4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fed7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fedb:	79 05                	jns    f011fee2 <ide_read+0xf4>
			return r;
f011fedd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fee0:	eb 45                	jmp    f011ff27 <ide_read+0x139>
f011fee2:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011fee9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011feec:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011feef:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011fef6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fef9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011fefc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011feff:	89 cb                	mov    %ecx,%ebx
f011ff01:	89 df                	mov    %ebx,%edi
f011ff03:	89 c1                	mov    %eax,%ecx
f011ff05:	fc                   	cld    
f011ff06:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011ff08:	89 c8                	mov    %ecx,%eax
f011ff0a:	89 fb                	mov    %edi,%ebx
f011ff0c:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011ff0f:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011ff12:	ff 4d 10             	decl   0x10(%ebp)
f011ff15:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011ff1c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ff20:	75 a5                	jne    f011fec7 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011ff22:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ff27:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ff2a:	5b                   	pop    %ebx
f011ff2b:	5f                   	pop    %edi
f011ff2c:	5d                   	pop    %ebp
f011ff2d:	c3                   	ret    

f011ff2e <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011ff2e:	55                   	push   %ebp
f011ff2f:	89 e5                	mov    %esp,%ebp
f011ff31:	56                   	push   %esi
f011ff32:	53                   	push   %ebx
f011ff33:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011ff36:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011ff3d:	76 19                	jbe    f011ff58 <ide_write+0x2a>
f011ff3f:	68 9a 0d 13 f0       	push   $0xf0130d9a
f011ff44:	68 a7 0d 13 f0       	push   $0xf0130da7
f011ff49:	68 82 00 00 00       	push   $0x82
f011ff4e:	68 8f 0d 13 f0       	push   $0xf0130d8f
f011ff53:	e8 e1 03 fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011ff58:	83 ec 0c             	sub    $0xc,%esp
f011ff5b:	6a 00                	push   $0x0
f011ff5d:	e8 2e fe ff ff       	call   f011fd90 <ide_wait_ready>
f011ff62:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011ff65:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff68:	0f b6 c0             	movzbl %al,%eax
f011ff6b:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011ff72:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011ff75:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011ff78:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ff7b:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011ff7c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff7f:	0f b6 c0             	movzbl %al,%eax
f011ff82:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011ff89:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011ff8c:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011ff8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ff92:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011ff93:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff96:	c1 e8 08             	shr    $0x8,%eax
f011ff99:	0f b6 c0             	movzbl %al,%eax
f011ff9c:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011ffa3:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011ffa6:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011ffa9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ffac:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011ffad:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffb0:	c1 e8 10             	shr    $0x10,%eax
f011ffb3:	0f b6 c0             	movzbl %al,%eax
f011ffb6:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011ffbd:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011ffc0:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011ffc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ffc6:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011ffc7:	a1 70 d0 6b f0       	mov    0xf06bd070,%eax
f011ffcc:	83 e0 01             	and    $0x1,%eax
f011ffcf:	c1 e0 04             	shl    $0x4,%eax
f011ffd2:	88 c2                	mov    %al,%dl
f011ffd4:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffd7:	c1 e8 18             	shr    $0x18,%eax
f011ffda:	83 e0 0f             	and    $0xf,%eax
f011ffdd:	09 d0                	or     %edx,%eax
f011ffdf:	83 c8 e0             	or     $0xffffffe0,%eax
f011ffe2:	0f b6 c0             	movzbl %al,%eax
f011ffe5:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011ffec:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011ffef:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011fff2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011fff5:	ee                   	out    %al,(%dx)
f011fff6:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011fffd:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0120001:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120004:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120007:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120008:	eb 55                	jmp    f012005f <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f012000a:	83 ec 0c             	sub    $0xc,%esp
f012000d:	6a 01                	push   $0x1
f012000f:	e8 7c fd ff ff       	call   f011fd90 <ide_wait_ready>
f0120014:	83 c4 10             	add    $0x10,%esp
f0120017:	89 45 dc             	mov    %eax,-0x24(%ebp)
f012001a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012001e:	79 05                	jns    f0120025 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0120020:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120023:	eb 45                	jmp    f012006a <ide_write+0x13c>
f0120025:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f012002c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012002f:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120032:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120039:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012003c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f012003f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120042:	89 cb                	mov    %ecx,%ebx
f0120044:	89 de                	mov    %ebx,%esi
f0120046:	89 c1                	mov    %eax,%ecx
f0120048:	fc                   	cld    
f0120049:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f012004b:	89 c8                	mov    %ecx,%eax
f012004d:	89 f3                	mov    %esi,%ebx
f012004f:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120052:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120055:	ff 4d 10             	decl   0x10(%ebp)
f0120058:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f012005f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120063:	75 a5                	jne    f012000a <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120065:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012006a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012006d:	5b                   	pop    %ebx
f012006e:	5e                   	pop    %esi
f012006f:	5d                   	pop    %ebp
f0120070:	c3                   	ret    

f0120071 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120071:	55                   	push   %ebp
f0120072:	89 e5                	mov    %esp,%ebp
f0120074:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120077:	8b 45 08             	mov    0x8(%ebp),%eax
f012007a:	83 e8 04             	sub    $0x4,%eax
f012007d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120080:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120083:	8b 00                	mov    (%eax),%eax
f0120085:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120088:	c9                   	leave  
f0120089:	c3                   	ret    

f012008a <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f012008a:	55                   	push   %ebp
f012008b:	89 e5                	mov    %esp,%ebp
f012008d:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120090:	8b 45 08             	mov    0x8(%ebp),%eax
f0120093:	83 e8 04             	sub    $0x4,%eax
f0120096:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120099:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012009c:	8b 00                	mov    (%eax),%eax
f012009e:	83 e0 01             	and    $0x1,%eax
f01200a1:	85 c0                	test   %eax,%eax
f01200a3:	0f 94 c0             	sete   %al
}
f01200a6:	c9                   	leave  
f01200a7:	c3                   	ret    

f01200a8 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f01200a8:	55                   	push   %ebp
f01200a9:	89 e5                	mov    %esp,%ebp
f01200ab:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f01200ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f01200b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200b8:	83 f8 02             	cmp    $0x2,%eax
f01200bb:	74 2b                	je     f01200e8 <alloc_block+0x40>
f01200bd:	83 f8 02             	cmp    $0x2,%eax
f01200c0:	7f 07                	jg     f01200c9 <alloc_block+0x21>
f01200c2:	83 f8 01             	cmp    $0x1,%eax
f01200c5:	74 0e                	je     f01200d5 <alloc_block+0x2d>
f01200c7:	eb 58                	jmp    f0120121 <alloc_block+0x79>
f01200c9:	83 f8 03             	cmp    $0x3,%eax
f01200cc:	74 2d                	je     f01200fb <alloc_block+0x53>
f01200ce:	83 f8 04             	cmp    $0x4,%eax
f01200d1:	74 3b                	je     f012010e <alloc_block+0x66>
f01200d3:	eb 4c                	jmp    f0120121 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f01200d5:	83 ec 0c             	sub    $0xc,%esp
f01200d8:	ff 75 08             	pushl  0x8(%ebp)
f01200db:	e8 11 03 00 00       	call   f01203f1 <alloc_block_FF>
f01200e0:	83 c4 10             	add    $0x10,%esp
f01200e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200e6:	eb 4a                	jmp    f0120132 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01200e8:	83 ec 0c             	sub    $0xc,%esp
f01200eb:	ff 75 08             	pushl  0x8(%ebp)
f01200ee:	e8 fa 19 00 00       	call   f0121aed <alloc_block_NF>
f01200f3:	83 c4 10             	add    $0x10,%esp
f01200f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200f9:	eb 37                	jmp    f0120132 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01200fb:	83 ec 0c             	sub    $0xc,%esp
f01200fe:	ff 75 08             	pushl  0x8(%ebp)
f0120101:	e8 a7 07 00 00       	call   f01208ad <alloc_block_BF>
f0120106:	83 c4 10             	add    $0x10,%esp
f0120109:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012010c:	eb 24                	jmp    f0120132 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f012010e:	83 ec 0c             	sub    $0xc,%esp
f0120111:	ff 75 08             	pushl  0x8(%ebp)
f0120114:	e8 b7 19 00 00       	call   f0121ad0 <alloc_block_WF>
f0120119:	83 c4 10             	add    $0x10,%esp
f012011c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012011f:	eb 11                	jmp    f0120132 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0120121:	83 ec 0c             	sub    $0xc,%esp
f0120124:	68 bc 0d 13 f0       	push   $0xf0130dbc
f0120129:	e8 5d 0e fe ff       	call   f0100f8b <cprintf>
f012012e:	83 c4 10             	add    $0x10,%esp
		break;
f0120131:	90                   	nop
	}
	return va;
f0120132:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120135:	c9                   	leave  
f0120136:	c3                   	ret    

f0120137 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0120137:	55                   	push   %ebp
f0120138:	89 e5                	mov    %esp,%ebp
f012013a:	53                   	push   %ebx
f012013b:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f012013e:	83 ec 0c             	sub    $0xc,%esp
f0120141:	68 dc 0d 13 f0       	push   $0xf0130ddc
f0120146:	e8 40 0e fe ff       	call   f0100f8b <cprintf>
f012014b:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f012014e:	83 ec 0c             	sub    $0xc,%esp
f0120151:	68 07 0e 13 f0       	push   $0xf0130e07
f0120156:	e8 30 0e fe ff       	call   f0100f8b <cprintf>
f012015b:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f012015e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120161:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120164:	eb 37                	jmp    f012019d <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120166:	83 ec 0c             	sub    $0xc,%esp
f0120169:	ff 75 f4             	pushl  -0xc(%ebp)
f012016c:	e8 19 ff ff ff       	call   f012008a <is_free_block>
f0120171:	83 c4 10             	add    $0x10,%esp
f0120174:	0f be d8             	movsbl %al,%ebx
f0120177:	83 ec 0c             	sub    $0xc,%esp
f012017a:	ff 75 f4             	pushl  -0xc(%ebp)
f012017d:	e8 ef fe ff ff       	call   f0120071 <get_block_size>
f0120182:	83 c4 10             	add    $0x10,%esp
f0120185:	83 ec 04             	sub    $0x4,%esp
f0120188:	53                   	push   %ebx
f0120189:	50                   	push   %eax
f012018a:	68 1f 0e 13 f0       	push   $0xf0130e1f
f012018f:	e8 f7 0d fe ff       	call   f0100f8b <cprintf>
f0120194:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120197:	8b 45 10             	mov    0x10(%ebp),%eax
f012019a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012019d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01201a1:	74 07                	je     f01201aa <print_blocks_list+0x73>
f01201a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201a6:	8b 00                	mov    (%eax),%eax
f01201a8:	eb 05                	jmp    f01201af <print_blocks_list+0x78>
f01201aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01201af:	89 45 10             	mov    %eax,0x10(%ebp)
f01201b2:	8b 45 10             	mov    0x10(%ebp),%eax
f01201b5:	85 c0                	test   %eax,%eax
f01201b7:	75 ad                	jne    f0120166 <print_blocks_list+0x2f>
f01201b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01201bd:	75 a7                	jne    f0120166 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f01201bf:	83 ec 0c             	sub    $0xc,%esp
f01201c2:	68 dc 0d 13 f0       	push   $0xf0130ddc
f01201c7:	e8 bf 0d fe ff       	call   f0100f8b <cprintf>
f01201cc:	83 c4 10             	add    $0x10,%esp

}
f01201cf:	90                   	nop
f01201d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01201d3:	c9                   	leave  
f01201d4:	c3                   	ret    

f01201d5 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f01201d5:	55                   	push   %ebp
f01201d6:	89 e5                	mov    %esp,%ebp
f01201d8:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f01201db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201de:	83 e0 01             	and    $0x1,%eax
f01201e1:	85 c0                	test   %eax,%eax
f01201e3:	74 03                	je     f01201e8 <initialize_dynamic_allocator+0x13>
f01201e5:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01201e8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01201ec:	0f 84 c7 01 00 00    	je     f01203b9 <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f01201f2:	c7 05 74 d0 6b f0 01 	movl   $0x1,0xf06bd074
f01201f9:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01201fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01201ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120202:	01 d0                	add    %edx,%eax
f0120204:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0120209:	0f 87 ad 01 00 00    	ja     f01203bc <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f012020f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120212:	85 c0                	test   %eax,%eax
f0120214:	0f 89 a5 01 00 00    	jns    f01203bf <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f012021a:	8b 55 08             	mov    0x8(%ebp),%edx
f012021d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120220:	01 d0                	add    %edx,%eax
f0120222:	83 e8 04             	sub    $0x4,%eax
f0120225:	a3 14 da 6b f0       	mov    %eax,0xf06bda14
     struct BlockElement * element = NULL;
f012022a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120231:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120236:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120239:	e9 87 00 00 00       	jmp    f01202c5 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f012023e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120242:	75 14                	jne    f0120258 <initialize_dynamic_allocator+0x83>
f0120244:	83 ec 04             	sub    $0x4,%esp
f0120247:	68 37 0e 13 f0       	push   $0xf0130e37
f012024c:	6a 79                	push   $0x79
f012024e:	68 55 0e 13 f0       	push   $0xf0130e55
f0120253:	e8 e1 00 fe ff       	call   f0100339 <_panic>
f0120258:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012025b:	8b 00                	mov    (%eax),%eax
f012025d:	85 c0                	test   %eax,%eax
f012025f:	74 10                	je     f0120271 <initialize_dynamic_allocator+0x9c>
f0120261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120264:	8b 00                	mov    (%eax),%eax
f0120266:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120269:	8b 52 04             	mov    0x4(%edx),%edx
f012026c:	89 50 04             	mov    %edx,0x4(%eax)
f012026f:	eb 0b                	jmp    f012027c <initialize_dynamic_allocator+0xa7>
f0120271:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120274:	8b 40 04             	mov    0x4(%eax),%eax
f0120277:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012027c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012027f:	8b 40 04             	mov    0x4(%eax),%eax
f0120282:	85 c0                	test   %eax,%eax
f0120284:	74 0f                	je     f0120295 <initialize_dynamic_allocator+0xc0>
f0120286:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120289:	8b 40 04             	mov    0x4(%eax),%eax
f012028c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012028f:	8b 12                	mov    (%edx),%edx
f0120291:	89 10                	mov    %edx,(%eax)
f0120293:	eb 0a                	jmp    f012029f <initialize_dynamic_allocator+0xca>
f0120295:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120298:	8b 00                	mov    (%eax),%eax
f012029a:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012029f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01202a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01202b2:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01202b7:	48                   	dec    %eax
f01202b8:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f01202bd:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01202c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01202c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01202c9:	74 07                	je     f01202d2 <initialize_dynamic_allocator+0xfd>
f01202cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202ce:	8b 00                	mov    (%eax),%eax
f01202d0:	eb 05                	jmp    f01202d7 <initialize_dynamic_allocator+0x102>
f01202d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01202d7:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f01202dc:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01202e1:	85 c0                	test   %eax,%eax
f01202e3:	0f 85 55 ff ff ff    	jne    f012023e <initialize_dynamic_allocator+0x69>
f01202e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01202ed:	0f 85 4b ff ff ff    	jne    f012023e <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01202f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01202f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01202f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202fc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f0120302:	a1 14 da 6b f0       	mov    0xf06bda14,%eax
f0120307:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
    end_block->info = 1;
f012030c:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f0120311:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0120317:	8b 45 08             	mov    0x8(%ebp),%eax
f012031a:	83 c0 08             	add    $0x8,%eax
f012031d:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120320:	8b 45 08             	mov    0x8(%ebp),%eax
f0120323:	83 c0 04             	add    $0x4,%eax
f0120326:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120329:	83 ea 08             	sub    $0x8,%edx
f012032c:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f012032e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120331:	8b 45 08             	mov    0x8(%ebp),%eax
f0120334:	01 d0                	add    %edx,%eax
f0120336:	83 e8 08             	sub    $0x8,%eax
f0120339:	8b 55 0c             	mov    0xc(%ebp),%edx
f012033c:	83 ea 08             	sub    $0x8,%edx
f012033f:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120341:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120344:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f012034a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012034d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120354:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120358:	75 17                	jne    f0120371 <initialize_dynamic_allocator+0x19c>
f012035a:	83 ec 04             	sub    $0x4,%esp
f012035d:	68 70 0e 13 f0       	push   $0xf0130e70
f0120362:	68 90 00 00 00       	push   $0x90
f0120367:	68 55 0e 13 f0       	push   $0xf0130e55
f012036c:	e8 c8 ff fd ff       	call   f0100339 <_panic>
f0120371:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120377:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012037a:	89 10                	mov    %edx,(%eax)
f012037c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012037f:	8b 00                	mov    (%eax),%eax
f0120381:	85 c0                	test   %eax,%eax
f0120383:	74 0d                	je     f0120392 <initialize_dynamic_allocator+0x1bd>
f0120385:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012038a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012038d:	89 50 04             	mov    %edx,0x4(%eax)
f0120390:	eb 08                	jmp    f012039a <initialize_dynamic_allocator+0x1c5>
f0120392:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120395:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012039a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012039d:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01203a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01203a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01203ac:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01203b1:	40                   	inc    %eax
f01203b2:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01203b7:	eb 07                	jmp    f01203c0 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f01203b9:	90                   	nop
f01203ba:	eb 04                	jmp    f01203c0 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f01203bc:	90                   	nop
f01203bd:	eb 01                	jmp    f01203c0 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f01203bf:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f01203c0:	c9                   	leave  
f01203c1:	c3                   	ret    

f01203c2 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f01203c2:	55                   	push   %ebp
f01203c3:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f01203c5:	8b 45 10             	mov    0x10(%ebp),%eax
f01203c8:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f01203cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01203ce:	8d 50 fc             	lea    -0x4(%eax),%edx
f01203d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203d4:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f01203d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01203d9:	83 e8 04             	sub    $0x4,%eax
f01203dc:	8b 00                	mov    (%eax),%eax
f01203de:	83 e0 fe             	and    $0xfffffffe,%eax
f01203e1:	8d 50 f8             	lea    -0x8(%eax),%edx
f01203e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01203e7:	01 c2                	add    %eax,%edx
f01203e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203ec:	89 02                	mov    %eax,(%edx)
}
f01203ee:	90                   	nop
f01203ef:	5d                   	pop    %ebp
f01203f0:	c3                   	ret    

f01203f1 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f01203f1:	55                   	push   %ebp
f01203f2:	89 e5                	mov    %esp,%ebp
f01203f4:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01203f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01203fa:	83 e0 01             	and    $0x1,%eax
f01203fd:	85 c0                	test   %eax,%eax
f01203ff:	74 03                	je     f0120404 <alloc_block_FF+0x13>
f0120401:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120404:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120408:	77 07                	ja     f0120411 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f012040a:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120411:	a1 74 d0 6b f0       	mov    0xf06bd074,%eax
f0120416:	85 c0                	test   %eax,%eax
f0120418:	75 73                	jne    f012048d <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f012041a:	8b 45 08             	mov    0x8(%ebp),%eax
f012041d:	83 c0 10             	add    $0x10,%eax
f0120420:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120423:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f012042a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012042d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120430:	01 d0                	add    %edx,%eax
f0120432:	48                   	dec    %eax
f0120433:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120436:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120439:	ba 00 00 00 00       	mov    $0x0,%edx
f012043e:	f7 75 ec             	divl   -0x14(%ebp)
f0120441:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120444:	29 d0                	sub    %edx,%eax
f0120446:	c1 e8 0c             	shr    $0xc,%eax
f0120449:	83 ec 0c             	sub    $0xc,%esp
f012044c:	50                   	push   %eax
f012044d:	e8 7f 8c fe ff       	call   f01090d1 <sbrk>
f0120452:	83 c4 10             	add    $0x10,%esp
f0120455:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120458:	83 ec 0c             	sub    $0xc,%esp
f012045b:	6a 00                	push   $0x0
f012045d:	e8 6f 8c fe ff       	call   f01090d1 <sbrk>
f0120462:	83 c4 10             	add    $0x10,%esp
f0120465:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120468:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012046b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f012046e:	83 ec 08             	sub    $0x8,%esp
f0120471:	50                   	push   %eax
f0120472:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120475:	e8 5b fd ff ff       	call   f01201d5 <initialize_dynamic_allocator>
f012047a:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f012047d:	83 ec 0c             	sub    $0xc,%esp
f0120480:	68 93 0e 13 f0       	push   $0xf0130e93
f0120485:	e8 01 0b fe ff       	call   f0100f8b <cprintf>
f012048a:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f012048d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120491:	75 0a                	jne    f012049d <alloc_block_FF+0xac>
	        return NULL;
f0120493:	b8 00 00 00 00       	mov    $0x0,%eax
f0120498:	e9 0e 04 00 00       	jmp    f01208ab <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f012049d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f01204a4:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01204a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01204ac:	e9 f3 02 00 00       	jmp    f01207a4 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f01204b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204b4:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f01204b7:	83 ec 0c             	sub    $0xc,%esp
f01204ba:	ff 75 bc             	pushl  -0x44(%ebp)
f01204bd:	e8 af fb ff ff       	call   f0120071 <get_block_size>
f01204c2:	83 c4 10             	add    $0x10,%esp
f01204c5:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f01204c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01204cb:	83 c0 08             	add    $0x8,%eax
f01204ce:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01204d1:	0f 87 c5 02 00 00    	ja     f012079c <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01204d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01204da:	83 c0 18             	add    $0x18,%eax
f01204dd:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01204e0:	0f 87 19 02 00 00    	ja     f01206ff <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f01204e6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01204e9:	2b 45 08             	sub    0x8(%ebp),%eax
f01204ec:	83 e8 08             	sub    $0x8,%eax
f01204ef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f01204f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01204f5:	8d 50 08             	lea    0x8(%eax),%edx
f01204f8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01204fb:	01 d0                	add    %edx,%eax
f01204fd:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120500:	8b 45 08             	mov    0x8(%ebp),%eax
f0120503:	83 c0 08             	add    $0x8,%eax
f0120506:	83 ec 04             	sub    $0x4,%esp
f0120509:	6a 01                	push   $0x1
f012050b:	50                   	push   %eax
f012050c:	ff 75 bc             	pushl  -0x44(%ebp)
f012050f:	e8 ae fe ff ff       	call   f01203c2 <set_block_data>
f0120514:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012051a:	8b 40 04             	mov    0x4(%eax),%eax
f012051d:	85 c0                	test   %eax,%eax
f012051f:	75 68                	jne    f0120589 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120521:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120525:	75 17                	jne    f012053e <alloc_block_FF+0x14d>
f0120527:	83 ec 04             	sub    $0x4,%esp
f012052a:	68 70 0e 13 f0       	push   $0xf0130e70
f012052f:	68 d7 00 00 00       	push   $0xd7
f0120534:	68 55 0e 13 f0       	push   $0xf0130e55
f0120539:	e8 fb fd fd ff       	call   f0100339 <_panic>
f012053e:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120544:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120547:	89 10                	mov    %edx,(%eax)
f0120549:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012054c:	8b 00                	mov    (%eax),%eax
f012054e:	85 c0                	test   %eax,%eax
f0120550:	74 0d                	je     f012055f <alloc_block_FF+0x16e>
f0120552:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120557:	8b 55 b0             	mov    -0x50(%ebp),%edx
f012055a:	89 50 04             	mov    %edx,0x4(%eax)
f012055d:	eb 08                	jmp    f0120567 <alloc_block_FF+0x176>
f012055f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120562:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120567:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012056a:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012056f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120572:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120579:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012057e:	40                   	inc    %eax
f012057f:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120584:	e9 dc 00 00 00       	jmp    f0120665 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120589:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012058c:	8b 00                	mov    (%eax),%eax
f012058e:	85 c0                	test   %eax,%eax
f0120590:	75 65                	jne    f01205f7 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120592:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120596:	75 17                	jne    f01205af <alloc_block_FF+0x1be>
f0120598:	83 ec 04             	sub    $0x4,%esp
f012059b:	68 a4 0e 13 f0       	push   $0xf0130ea4
f01205a0:	68 db 00 00 00       	push   $0xdb
f01205a5:	68 55 0e 13 f0       	push   $0xf0130e55
f01205aa:	e8 8a fd fd ff       	call   f0100339 <_panic>
f01205af:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f01205b5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205b8:	89 50 04             	mov    %edx,0x4(%eax)
f01205bb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205be:	8b 40 04             	mov    0x4(%eax),%eax
f01205c1:	85 c0                	test   %eax,%eax
f01205c3:	74 0c                	je     f01205d1 <alloc_block_FF+0x1e0>
f01205c5:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f01205ca:	8b 55 b0             	mov    -0x50(%ebp),%edx
f01205cd:	89 10                	mov    %edx,(%eax)
f01205cf:	eb 08                	jmp    f01205d9 <alloc_block_FF+0x1e8>
f01205d1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205d4:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01205d9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205dc:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01205e1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01205ea:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01205ef:	40                   	inc    %eax
f01205f0:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01205f5:	eb 6e                	jmp    f0120665 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f01205f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01205fb:	74 06                	je     f0120603 <alloc_block_FF+0x212>
f01205fd:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120601:	75 17                	jne    f012061a <alloc_block_FF+0x229>
f0120603:	83 ec 04             	sub    $0x4,%esp
f0120606:	68 c8 0e 13 f0       	push   $0xf0130ec8
f012060b:	68 df 00 00 00       	push   $0xdf
f0120610:	68 55 0e 13 f0       	push   $0xf0130e55
f0120615:	e8 1f fd fd ff       	call   f0100339 <_panic>
f012061a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012061d:	8b 10                	mov    (%eax),%edx
f012061f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120622:	89 10                	mov    %edx,(%eax)
f0120624:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120627:	8b 00                	mov    (%eax),%eax
f0120629:	85 c0                	test   %eax,%eax
f012062b:	74 0b                	je     f0120638 <alloc_block_FF+0x247>
f012062d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120630:	8b 00                	mov    (%eax),%eax
f0120632:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120635:	89 50 04             	mov    %edx,0x4(%eax)
f0120638:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012063b:	8b 55 b0             	mov    -0x50(%ebp),%edx
f012063e:	89 10                	mov    %edx,(%eax)
f0120640:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120643:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120646:	89 50 04             	mov    %edx,0x4(%eax)
f0120649:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012064c:	8b 00                	mov    (%eax),%eax
f012064e:	85 c0                	test   %eax,%eax
f0120650:	75 08                	jne    f012065a <alloc_block_FF+0x269>
f0120652:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120655:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012065a:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012065f:	40                   	inc    %eax
f0120660:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120665:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120669:	75 17                	jne    f0120682 <alloc_block_FF+0x291>
f012066b:	83 ec 04             	sub    $0x4,%esp
f012066e:	68 37 0e 13 f0       	push   $0xf0130e37
f0120673:	68 e1 00 00 00       	push   $0xe1
f0120678:	68 55 0e 13 f0       	push   $0xf0130e55
f012067d:	e8 b7 fc fd ff       	call   f0100339 <_panic>
f0120682:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120685:	8b 00                	mov    (%eax),%eax
f0120687:	85 c0                	test   %eax,%eax
f0120689:	74 10                	je     f012069b <alloc_block_FF+0x2aa>
f012068b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012068e:	8b 00                	mov    (%eax),%eax
f0120690:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120693:	8b 52 04             	mov    0x4(%edx),%edx
f0120696:	89 50 04             	mov    %edx,0x4(%eax)
f0120699:	eb 0b                	jmp    f01206a6 <alloc_block_FF+0x2b5>
f012069b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012069e:	8b 40 04             	mov    0x4(%eax),%eax
f01206a1:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01206a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206a9:	8b 40 04             	mov    0x4(%eax),%eax
f01206ac:	85 c0                	test   %eax,%eax
f01206ae:	74 0f                	je     f01206bf <alloc_block_FF+0x2ce>
f01206b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206b3:	8b 40 04             	mov    0x4(%eax),%eax
f01206b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01206b9:	8b 12                	mov    (%edx),%edx
f01206bb:	89 10                	mov    %edx,(%eax)
f01206bd:	eb 0a                	jmp    f01206c9 <alloc_block_FF+0x2d8>
f01206bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206c2:	8b 00                	mov    (%eax),%eax
f01206c4:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01206c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01206d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206d5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01206dc:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01206e1:	48                   	dec    %eax
f01206e2:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				set_block_data(new_block_va, remaining_size, 0);
f01206e7:	83 ec 04             	sub    $0x4,%esp
f01206ea:	6a 00                	push   $0x0
f01206ec:	ff 75 b4             	pushl  -0x4c(%ebp)
f01206ef:	ff 75 b0             	pushl  -0x50(%ebp)
f01206f2:	e8 cb fc ff ff       	call   f01203c2 <set_block_data>
f01206f7:	83 c4 10             	add    $0x10,%esp
f01206fa:	e9 95 00 00 00       	jmp    f0120794 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f01206ff:	83 ec 04             	sub    $0x4,%esp
f0120702:	6a 01                	push   $0x1
f0120704:	ff 75 b8             	pushl  -0x48(%ebp)
f0120707:	ff 75 bc             	pushl  -0x44(%ebp)
f012070a:	e8 b3 fc ff ff       	call   f01203c2 <set_block_data>
f012070f:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120712:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120716:	75 17                	jne    f012072f <alloc_block_FF+0x33e>
f0120718:	83 ec 04             	sub    $0x4,%esp
f012071b:	68 37 0e 13 f0       	push   $0xf0130e37
f0120720:	68 e8 00 00 00       	push   $0xe8
f0120725:	68 55 0e 13 f0       	push   $0xf0130e55
f012072a:	e8 0a fc fd ff       	call   f0100339 <_panic>
f012072f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120732:	8b 00                	mov    (%eax),%eax
f0120734:	85 c0                	test   %eax,%eax
f0120736:	74 10                	je     f0120748 <alloc_block_FF+0x357>
f0120738:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012073b:	8b 00                	mov    (%eax),%eax
f012073d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120740:	8b 52 04             	mov    0x4(%edx),%edx
f0120743:	89 50 04             	mov    %edx,0x4(%eax)
f0120746:	eb 0b                	jmp    f0120753 <alloc_block_FF+0x362>
f0120748:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012074b:	8b 40 04             	mov    0x4(%eax),%eax
f012074e:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120753:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120756:	8b 40 04             	mov    0x4(%eax),%eax
f0120759:	85 c0                	test   %eax,%eax
f012075b:	74 0f                	je     f012076c <alloc_block_FF+0x37b>
f012075d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120760:	8b 40 04             	mov    0x4(%eax),%eax
f0120763:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120766:	8b 12                	mov    (%edx),%edx
f0120768:	89 10                	mov    %edx,(%eax)
f012076a:	eb 0a                	jmp    f0120776 <alloc_block_FF+0x385>
f012076c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012076f:	8b 00                	mov    (%eax),%eax
f0120771:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120776:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120779:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012077f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120782:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120789:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012078e:	48                   	dec    %eax
f012078f:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
	            }
	            return va;
f0120794:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120797:	e9 0f 01 00 00       	jmp    f01208ab <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f012079c:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01207a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01207a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01207a8:	74 07                	je     f01207b1 <alloc_block_FF+0x3c0>
f01207aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207ad:	8b 00                	mov    (%eax),%eax
f01207af:	eb 05                	jmp    f01207b6 <alloc_block_FF+0x3c5>
f01207b1:	b8 00 00 00 00       	mov    $0x0,%eax
f01207b6:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f01207bb:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01207c0:	85 c0                	test   %eax,%eax
f01207c2:	0f 85 e9 fc ff ff    	jne    f01204b1 <alloc_block_FF+0xc0>
f01207c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01207cc:	0f 85 df fc ff ff    	jne    f01204b1 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f01207d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01207d5:	83 c0 08             	add    $0x8,%eax
f01207d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01207db:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01207e2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01207e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01207e8:	01 d0                	add    %edx,%eax
f01207ea:	48                   	dec    %eax
f01207eb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01207ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207f1:	ba 00 00 00 00       	mov    $0x0,%edx
f01207f6:	f7 75 d8             	divl   -0x28(%ebp)
f01207f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207fc:	29 d0                	sub    %edx,%eax
f01207fe:	c1 e8 0c             	shr    $0xc,%eax
f0120801:	83 ec 0c             	sub    $0xc,%esp
f0120804:	50                   	push   %eax
f0120805:	e8 c7 88 fe ff       	call   f01090d1 <sbrk>
f012080a:	83 c4 10             	add    $0x10,%esp
f012080d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0120810:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0120814:	75 0a                	jne    f0120820 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0120816:	b8 00 00 00 00       	mov    $0x0,%eax
f012081b:	e9 8b 00 00 00       	jmp    f01208ab <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120820:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0120827:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012082a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012082d:	01 d0                	add    %edx,%eax
f012082f:	48                   	dec    %eax
f0120830:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120833:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120836:	ba 00 00 00 00       	mov    $0x0,%edx
f012083b:	f7 75 cc             	divl   -0x34(%ebp)
f012083e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120841:	29 d0                	sub    %edx,%eax
f0120843:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120846:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120849:	01 d0                	add    %edx,%eax
f012084b:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
			end_block->info = 1;
f0120850:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f0120855:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f012085b:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120862:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120865:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120868:	01 d0                	add    %edx,%eax
f012086a:	48                   	dec    %eax
f012086b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f012086e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120871:	ba 00 00 00 00       	mov    $0x0,%edx
f0120876:	f7 75 c4             	divl   -0x3c(%ebp)
f0120879:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012087c:	29 d0                	sub    %edx,%eax
f012087e:	83 ec 04             	sub    $0x4,%esp
f0120881:	6a 01                	push   $0x1
f0120883:	50                   	push   %eax
f0120884:	ff 75 d0             	pushl  -0x30(%ebp)
f0120887:	e8 36 fb ff ff       	call   f01203c2 <set_block_data>
f012088c:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f012088f:	83 ec 0c             	sub    $0xc,%esp
f0120892:	ff 75 d0             	pushl  -0x30(%ebp)
f0120895:	e8 1b 0a 00 00       	call   f01212b5 <free_block>
f012089a:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f012089d:	83 ec 0c             	sub    $0xc,%esp
f01208a0:	ff 75 08             	pushl  0x8(%ebp)
f01208a3:	e8 49 fb ff ff       	call   f01203f1 <alloc_block_FF>
f01208a8:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f01208ab:	c9                   	leave  
f01208ac:	c3                   	ret    

f01208ad <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f01208ad:	55                   	push   %ebp
f01208ae:	89 e5                	mov    %esp,%ebp
f01208b0:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01208b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01208b6:	83 e0 01             	and    $0x1,%eax
f01208b9:	85 c0                	test   %eax,%eax
f01208bb:	74 03                	je     f01208c0 <alloc_block_BF+0x13>
f01208bd:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01208c0:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f01208c4:	77 07                	ja     f01208cd <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f01208c6:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01208cd:	a1 74 d0 6b f0       	mov    0xf06bd074,%eax
f01208d2:	85 c0                	test   %eax,%eax
f01208d4:	75 73                	jne    f0120949 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01208d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01208d9:	83 c0 10             	add    $0x10,%eax
f01208dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01208df:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01208e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01208e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01208ec:	01 d0                	add    %edx,%eax
f01208ee:	48                   	dec    %eax
f01208ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01208f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208f5:	ba 00 00 00 00       	mov    $0x0,%edx
f01208fa:	f7 75 e0             	divl   -0x20(%ebp)
f01208fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120900:	29 d0                	sub    %edx,%eax
f0120902:	c1 e8 0c             	shr    $0xc,%eax
f0120905:	83 ec 0c             	sub    $0xc,%esp
f0120908:	50                   	push   %eax
f0120909:	e8 c3 87 fe ff       	call   f01090d1 <sbrk>
f012090e:	83 c4 10             	add    $0x10,%esp
f0120911:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120914:	83 ec 0c             	sub    $0xc,%esp
f0120917:	6a 00                	push   $0x0
f0120919:	e8 b3 87 fe ff       	call   f01090d1 <sbrk>
f012091e:	83 c4 10             	add    $0x10,%esp
f0120921:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120924:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120927:	2b 45 d8             	sub    -0x28(%ebp),%eax
f012092a:	83 ec 08             	sub    $0x8,%esp
f012092d:	50                   	push   %eax
f012092e:	ff 75 d8             	pushl  -0x28(%ebp)
f0120931:	e8 9f f8 ff ff       	call   f01201d5 <initialize_dynamic_allocator>
f0120936:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120939:	83 ec 0c             	sub    $0xc,%esp
f012093c:	68 93 0e 13 f0       	push   $0xf0130e93
f0120941:	e8 45 06 fe ff       	call   f0100f8b <cprintf>
f0120946:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0120949:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0120950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0120957:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f012095e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120965:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012096a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012096d:	e9 1d 01 00 00       	jmp    f0120a8f <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120972:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120975:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0120978:	83 ec 0c             	sub    $0xc,%esp
f012097b:	ff 75 a8             	pushl  -0x58(%ebp)
f012097e:	e8 ee f6 ff ff       	call   f0120071 <get_block_size>
f0120983:	83 c4 10             	add    $0x10,%esp
f0120986:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0120989:	8b 45 08             	mov    0x8(%ebp),%eax
f012098c:	83 c0 08             	add    $0x8,%eax
f012098f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120992:	0f 87 ef 00 00 00    	ja     f0120a87 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120998:	8b 45 08             	mov    0x8(%ebp),%eax
f012099b:	83 c0 18             	add    $0x18,%eax
f012099e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01209a1:	77 1d                	ja     f01209c0 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f01209a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209a6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01209a9:	0f 86 d8 00 00 00    	jbe    f0120a87 <alloc_block_BF+0x1da>
				{
					best_va = va;
f01209af:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01209b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f01209b5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01209b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01209bb:	e9 c7 00 00 00       	jmp    f0120a87 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f01209c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c3:	83 c0 08             	add    $0x8,%eax
f01209c6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01209c9:	0f 85 9d 00 00 00    	jne    f0120a6c <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f01209cf:	83 ec 04             	sub    $0x4,%esp
f01209d2:	6a 01                	push   $0x1
f01209d4:	ff 75 a4             	pushl  -0x5c(%ebp)
f01209d7:	ff 75 a8             	pushl  -0x58(%ebp)
f01209da:	e8 e3 f9 ff ff       	call   f01203c2 <set_block_data>
f01209df:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01209e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01209e6:	75 17                	jne    f01209ff <alloc_block_BF+0x152>
f01209e8:	83 ec 04             	sub    $0x4,%esp
f01209eb:	68 37 0e 13 f0       	push   $0xf0130e37
f01209f0:	68 2c 01 00 00       	push   $0x12c
f01209f5:	68 55 0e 13 f0       	push   $0xf0130e55
f01209fa:	e8 3a f9 fd ff       	call   f0100339 <_panic>
f01209ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a02:	8b 00                	mov    (%eax),%eax
f0120a04:	85 c0                	test   %eax,%eax
f0120a06:	74 10                	je     f0120a18 <alloc_block_BF+0x16b>
f0120a08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a0b:	8b 00                	mov    (%eax),%eax
f0120a0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a10:	8b 52 04             	mov    0x4(%edx),%edx
f0120a13:	89 50 04             	mov    %edx,0x4(%eax)
f0120a16:	eb 0b                	jmp    f0120a23 <alloc_block_BF+0x176>
f0120a18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a1b:	8b 40 04             	mov    0x4(%eax),%eax
f0120a1e:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a26:	8b 40 04             	mov    0x4(%eax),%eax
f0120a29:	85 c0                	test   %eax,%eax
f0120a2b:	74 0f                	je     f0120a3c <alloc_block_BF+0x18f>
f0120a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a30:	8b 40 04             	mov    0x4(%eax),%eax
f0120a33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a36:	8b 12                	mov    (%edx),%edx
f0120a38:	89 10                	mov    %edx,(%eax)
f0120a3a:	eb 0a                	jmp    f0120a46 <alloc_block_BF+0x199>
f0120a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a3f:	8b 00                	mov    (%eax),%eax
f0120a41:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120a46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a49:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120a4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a52:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a59:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120a5e:	48                   	dec    %eax
f0120a5f:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
					return va;
f0120a64:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120a67:	e9 24 04 00 00       	jmp    f0120e90 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f0120a6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a6f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120a72:	76 13                	jbe    f0120a87 <alloc_block_BF+0x1da>
					{
						internal = 1;
f0120a74:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f0120a7b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120a7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0120a81:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120a84:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f0120a87:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0120a8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120a8f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120a93:	74 07                	je     f0120a9c <alloc_block_BF+0x1ef>
f0120a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a98:	8b 00                	mov    (%eax),%eax
f0120a9a:	eb 05                	jmp    f0120aa1 <alloc_block_BF+0x1f4>
f0120a9c:	b8 00 00 00 00       	mov    $0x0,%eax
f0120aa1:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0120aa6:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0120aab:	85 c0                	test   %eax,%eax
f0120aad:	0f 85 bf fe ff ff    	jne    f0120972 <alloc_block_BF+0xc5>
f0120ab3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ab7:	0f 85 b5 fe ff ff    	jne    f0120972 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0120abd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120ac1:	0f 84 26 02 00 00    	je     f0120ced <alloc_block_BF+0x440>
f0120ac7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120acb:	0f 85 1c 02 00 00    	jne    f0120ced <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f0120ad1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120ad4:	2b 45 08             	sub    0x8(%ebp),%eax
f0120ad7:	83 e8 08             	sub    $0x8,%eax
f0120ada:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0120add:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ae0:	8d 50 08             	lea    0x8(%eax),%edx
f0120ae3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ae6:	01 d0                	add    %edx,%eax
f0120ae8:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0120aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aee:	83 c0 08             	add    $0x8,%eax
f0120af1:	83 ec 04             	sub    $0x4,%esp
f0120af4:	6a 01                	push   $0x1
f0120af6:	50                   	push   %eax
f0120af7:	ff 75 f0             	pushl  -0x10(%ebp)
f0120afa:	e8 c3 f8 ff ff       	call   f01203c2 <set_block_data>
f0120aff:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f0120b02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b05:	8b 40 04             	mov    0x4(%eax),%eax
f0120b08:	85 c0                	test   %eax,%eax
f0120b0a:	75 68                	jne    f0120b74 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b0c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120b10:	75 17                	jne    f0120b29 <alloc_block_BF+0x27c>
f0120b12:	83 ec 04             	sub    $0x4,%esp
f0120b15:	68 70 0e 13 f0       	push   $0xf0130e70
f0120b1a:	68 45 01 00 00       	push   $0x145
f0120b1f:	68 55 0e 13 f0       	push   $0xf0130e55
f0120b24:	e8 10 f8 fd ff       	call   f0100339 <_panic>
f0120b29:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120b2f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b32:	89 10                	mov    %edx,(%eax)
f0120b34:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b37:	8b 00                	mov    (%eax),%eax
f0120b39:	85 c0                	test   %eax,%eax
f0120b3b:	74 0d                	je     f0120b4a <alloc_block_BF+0x29d>
f0120b3d:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120b42:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120b45:	89 50 04             	mov    %edx,0x4(%eax)
f0120b48:	eb 08                	jmp    f0120b52 <alloc_block_BF+0x2a5>
f0120b4a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b4d:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120b52:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b55:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120b5a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b64:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120b69:	40                   	inc    %eax
f0120b6a:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120b6f:	e9 dc 00 00 00       	jmp    f0120c50 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0120b74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b77:	8b 00                	mov    (%eax),%eax
f0120b79:	85 c0                	test   %eax,%eax
f0120b7b:	75 65                	jne    f0120be2 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b7d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120b81:	75 17                	jne    f0120b9a <alloc_block_BF+0x2ed>
f0120b83:	83 ec 04             	sub    $0x4,%esp
f0120b86:	68 a4 0e 13 f0       	push   $0xf0130ea4
f0120b8b:	68 4a 01 00 00       	push   $0x14a
f0120b90:	68 55 0e 13 f0       	push   $0xf0130e55
f0120b95:	e8 9f f7 fd ff       	call   f0100339 <_panic>
f0120b9a:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f0120ba0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120ba3:	89 50 04             	mov    %edx,0x4(%eax)
f0120ba6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120ba9:	8b 40 04             	mov    0x4(%eax),%eax
f0120bac:	85 c0                	test   %eax,%eax
f0120bae:	74 0c                	je     f0120bbc <alloc_block_BF+0x30f>
f0120bb0:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0120bb5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120bb8:	89 10                	mov    %edx,(%eax)
f0120bba:	eb 08                	jmp    f0120bc4 <alloc_block_BF+0x317>
f0120bbc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bbf:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120bc4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bc7:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120bcc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bcf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120bd5:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120bda:	40                   	inc    %eax
f0120bdb:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120be0:	eb 6e                	jmp    f0120c50 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f0120be2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120be6:	74 06                	je     f0120bee <alloc_block_BF+0x341>
f0120be8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120bec:	75 17                	jne    f0120c05 <alloc_block_BF+0x358>
f0120bee:	83 ec 04             	sub    $0x4,%esp
f0120bf1:	68 c8 0e 13 f0       	push   $0xf0130ec8
f0120bf6:	68 4f 01 00 00       	push   $0x14f
f0120bfb:	68 55 0e 13 f0       	push   $0xf0130e55
f0120c00:	e8 34 f7 fd ff       	call   f0100339 <_panic>
f0120c05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c08:	8b 10                	mov    (%eax),%edx
f0120c0a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120c0d:	89 10                	mov    %edx,(%eax)
f0120c0f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120c12:	8b 00                	mov    (%eax),%eax
f0120c14:	85 c0                	test   %eax,%eax
f0120c16:	74 0b                	je     f0120c23 <alloc_block_BF+0x376>
f0120c18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c1b:	8b 00                	mov    (%eax),%eax
f0120c1d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120c20:	89 50 04             	mov    %edx,0x4(%eax)
f0120c23:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c26:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120c29:	89 10                	mov    %edx,(%eax)
f0120c2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120c2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c31:	89 50 04             	mov    %edx,0x4(%eax)
f0120c34:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120c37:	8b 00                	mov    (%eax),%eax
f0120c39:	85 c0                	test   %eax,%eax
f0120c3b:	75 08                	jne    f0120c45 <alloc_block_BF+0x398>
f0120c3d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120c40:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120c45:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120c4a:	40                   	inc    %eax
f0120c4b:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0120c50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120c54:	75 17                	jne    f0120c6d <alloc_block_BF+0x3c0>
f0120c56:	83 ec 04             	sub    $0x4,%esp
f0120c59:	68 37 0e 13 f0       	push   $0xf0130e37
f0120c5e:	68 51 01 00 00       	push   $0x151
f0120c63:	68 55 0e 13 f0       	push   $0xf0130e55
f0120c68:	e8 cc f6 fd ff       	call   f0100339 <_panic>
f0120c6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c70:	8b 00                	mov    (%eax),%eax
f0120c72:	85 c0                	test   %eax,%eax
f0120c74:	74 10                	je     f0120c86 <alloc_block_BF+0x3d9>
f0120c76:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c79:	8b 00                	mov    (%eax),%eax
f0120c7b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c7e:	8b 52 04             	mov    0x4(%edx),%edx
f0120c81:	89 50 04             	mov    %edx,0x4(%eax)
f0120c84:	eb 0b                	jmp    f0120c91 <alloc_block_BF+0x3e4>
f0120c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c89:	8b 40 04             	mov    0x4(%eax),%eax
f0120c8c:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120c91:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c94:	8b 40 04             	mov    0x4(%eax),%eax
f0120c97:	85 c0                	test   %eax,%eax
f0120c99:	74 0f                	je     f0120caa <alloc_block_BF+0x3fd>
f0120c9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c9e:	8b 40 04             	mov    0x4(%eax),%eax
f0120ca1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120ca4:	8b 12                	mov    (%edx),%edx
f0120ca6:	89 10                	mov    %edx,(%eax)
f0120ca8:	eb 0a                	jmp    f0120cb4 <alloc_block_BF+0x407>
f0120caa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cad:	8b 00                	mov    (%eax),%eax
f0120caf:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120cb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cb7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120cbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cc0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120cc7:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120ccc:	48                   	dec    %eax
f0120ccd:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			set_block_data(new_block_va, remaining_size, 0);
f0120cd2:	83 ec 04             	sub    $0x4,%esp
f0120cd5:	6a 00                	push   $0x0
f0120cd7:	ff 75 d0             	pushl  -0x30(%ebp)
f0120cda:	ff 75 cc             	pushl  -0x34(%ebp)
f0120cdd:	e8 e0 f6 ff ff       	call   f01203c2 <set_block_data>
f0120ce2:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0120ce5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ce8:	e9 a3 01 00 00       	jmp    f0120e90 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0120ced:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0120cf1:	0f 85 9d 00 00 00    	jne    f0120d94 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f0120cf7:	83 ec 04             	sub    $0x4,%esp
f0120cfa:	6a 01                	push   $0x1
f0120cfc:	ff 75 ec             	pushl  -0x14(%ebp)
f0120cff:	ff 75 f0             	pushl  -0x10(%ebp)
f0120d02:	e8 bb f6 ff ff       	call   f01203c2 <set_block_data>
f0120d07:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0120d0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120d0e:	75 17                	jne    f0120d27 <alloc_block_BF+0x47a>
f0120d10:	83 ec 04             	sub    $0x4,%esp
f0120d13:	68 37 0e 13 f0       	push   $0xf0130e37
f0120d18:	68 58 01 00 00       	push   $0x158
f0120d1d:	68 55 0e 13 f0       	push   $0xf0130e55
f0120d22:	e8 12 f6 fd ff       	call   f0100339 <_panic>
f0120d27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d2a:	8b 00                	mov    (%eax),%eax
f0120d2c:	85 c0                	test   %eax,%eax
f0120d2e:	74 10                	je     f0120d40 <alloc_block_BF+0x493>
f0120d30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d33:	8b 00                	mov    (%eax),%eax
f0120d35:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d38:	8b 52 04             	mov    0x4(%edx),%edx
f0120d3b:	89 50 04             	mov    %edx,0x4(%eax)
f0120d3e:	eb 0b                	jmp    f0120d4b <alloc_block_BF+0x49e>
f0120d40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d43:	8b 40 04             	mov    0x4(%eax),%eax
f0120d46:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120d4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d4e:	8b 40 04             	mov    0x4(%eax),%eax
f0120d51:	85 c0                	test   %eax,%eax
f0120d53:	74 0f                	je     f0120d64 <alloc_block_BF+0x4b7>
f0120d55:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d58:	8b 40 04             	mov    0x4(%eax),%eax
f0120d5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d5e:	8b 12                	mov    (%edx),%edx
f0120d60:	89 10                	mov    %edx,(%eax)
f0120d62:	eb 0a                	jmp    f0120d6e <alloc_block_BF+0x4c1>
f0120d64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d67:	8b 00                	mov    (%eax),%eax
f0120d69:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d71:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d7a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d81:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120d86:	48                   	dec    %eax
f0120d87:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		return best_va;
f0120d8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d8f:	e9 fc 00 00 00       	jmp    f0120e90 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0120d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d97:	83 c0 08             	add    $0x8,%eax
f0120d9a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120d9d:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120da4:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120da7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120daa:	01 d0                	add    %edx,%eax
f0120dac:	48                   	dec    %eax
f0120dad:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120db0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120db3:	ba 00 00 00 00       	mov    $0x0,%edx
f0120db8:	f7 75 c4             	divl   -0x3c(%ebp)
f0120dbb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120dbe:	29 d0                	sub    %edx,%eax
f0120dc0:	c1 e8 0c             	shr    $0xc,%eax
f0120dc3:	83 ec 0c             	sub    $0xc,%esp
f0120dc6:	50                   	push   %eax
f0120dc7:	e8 05 83 fe ff       	call   f01090d1 <sbrk>
f0120dcc:	83 c4 10             	add    $0x10,%esp
f0120dcf:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0120dd2:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0120dd6:	75 0a                	jne    f0120de2 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f0120dd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0120ddd:	e9 ae 00 00 00       	jmp    f0120e90 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120de2:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0120de9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120dec:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120def:	01 d0                	add    %edx,%eax
f0120df1:	48                   	dec    %eax
f0120df2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0120df5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120df8:	ba 00 00 00 00       	mov    $0x0,%edx
f0120dfd:	f7 75 b8             	divl   -0x48(%ebp)
f0120e00:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120e03:	29 d0                	sub    %edx,%eax
f0120e05:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120e08:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120e0b:	01 d0                	add    %edx,%eax
f0120e0d:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
				end_block->info = 1;
f0120e12:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f0120e17:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0120e1d:	83 ec 0c             	sub    $0xc,%esp
f0120e20:	68 fc 0e 13 f0       	push   $0xf0130efc
f0120e25:	e8 61 01 fe ff       	call   f0100f8b <cprintf>
f0120e2a:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f0120e2d:	83 ec 08             	sub    $0x8,%esp
f0120e30:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e33:	68 01 0f 13 f0       	push   $0xf0130f01
f0120e38:	e8 4e 01 fe ff       	call   f0100f8b <cprintf>
f0120e3d:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120e40:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0120e47:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120e4a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e4d:	01 d0                	add    %edx,%eax
f0120e4f:	48                   	dec    %eax
f0120e50:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0120e53:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120e56:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e5b:	f7 75 b0             	divl   -0x50(%ebp)
f0120e5e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120e61:	29 d0                	sub    %edx,%eax
f0120e63:	83 ec 04             	sub    $0x4,%esp
f0120e66:	6a 01                	push   $0x1
f0120e68:	50                   	push   %eax
f0120e69:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e6c:	e8 51 f5 ff ff       	call   f01203c2 <set_block_data>
f0120e71:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0120e74:	83 ec 0c             	sub    $0xc,%esp
f0120e77:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e7a:	e8 36 04 00 00       	call   f01212b5 <free_block>
f0120e7f:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0120e82:	83 ec 0c             	sub    $0xc,%esp
f0120e85:	ff 75 08             	pushl  0x8(%ebp)
f0120e88:	e8 20 fa ff ff       	call   f01208ad <alloc_block_BF>
f0120e8d:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0120e90:	c9                   	leave  
f0120e91:	c3                   	ret    

f0120e92 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0120e92:	55                   	push   %ebp
f0120e93:	89 e5                	mov    %esp,%ebp
f0120e95:	53                   	push   %ebx
f0120e96:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f0120e99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0120ea0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0120ea7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120eab:	74 1e                	je     f0120ecb <merging+0x39>
f0120ead:	ff 75 08             	pushl  0x8(%ebp)
f0120eb0:	e8 bc f1 ff ff       	call   f0120071 <get_block_size>
f0120eb5:	83 c4 04             	add    $0x4,%esp
f0120eb8:	89 c2                	mov    %eax,%edx
f0120eba:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ebd:	01 d0                	add    %edx,%eax
f0120ebf:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120ec2:	75 07                	jne    f0120ecb <merging+0x39>
		prev_is_free = 1;
f0120ec4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0120ecb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120ecf:	74 1e                	je     f0120eef <merging+0x5d>
f0120ed1:	ff 75 10             	pushl  0x10(%ebp)
f0120ed4:	e8 98 f1 ff ff       	call   f0120071 <get_block_size>
f0120ed9:	83 c4 04             	add    $0x4,%esp
f0120edc:	89 c2                	mov    %eax,%edx
f0120ede:	8b 45 10             	mov    0x10(%ebp),%eax
f0120ee1:	01 d0                	add    %edx,%eax
f0120ee3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120ee6:	75 07                	jne    f0120eef <merging+0x5d>
		next_is_free = 1;
f0120ee8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0120eef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ef3:	0f 84 cc 00 00 00    	je     f0120fc5 <merging+0x133>
f0120ef9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120efd:	0f 84 c2 00 00 00    	je     f0120fc5 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0120f03:	ff 75 08             	pushl  0x8(%ebp)
f0120f06:	e8 66 f1 ff ff       	call   f0120071 <get_block_size>
f0120f0b:	83 c4 04             	add    $0x4,%esp
f0120f0e:	89 c3                	mov    %eax,%ebx
f0120f10:	ff 75 10             	pushl  0x10(%ebp)
f0120f13:	e8 59 f1 ff ff       	call   f0120071 <get_block_size>
f0120f18:	83 c4 04             	add    $0x4,%esp
f0120f1b:	01 c3                	add    %eax,%ebx
f0120f1d:	ff 75 0c             	pushl  0xc(%ebp)
f0120f20:	e8 4c f1 ff ff       	call   f0120071 <get_block_size>
f0120f25:	83 c4 04             	add    $0x4,%esp
f0120f28:	01 d8                	add    %ebx,%eax
f0120f2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120f2d:	6a 00                	push   $0x0
f0120f2f:	ff 75 ec             	pushl  -0x14(%ebp)
f0120f32:	ff 75 08             	pushl  0x8(%ebp)
f0120f35:	e8 88 f4 ff ff       	call   f01203c2 <set_block_data>
f0120f3a:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0120f3d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120f41:	75 17                	jne    f0120f5a <merging+0xc8>
f0120f43:	83 ec 04             	sub    $0x4,%esp
f0120f46:	68 37 0e 13 f0       	push   $0xf0130e37
f0120f4b:	68 7d 01 00 00       	push   $0x17d
f0120f50:	68 55 0e 13 f0       	push   $0xf0130e55
f0120f55:	e8 df f3 fd ff       	call   f0100339 <_panic>
f0120f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f5d:	8b 00                	mov    (%eax),%eax
f0120f5f:	85 c0                	test   %eax,%eax
f0120f61:	74 10                	je     f0120f73 <merging+0xe1>
f0120f63:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f66:	8b 00                	mov    (%eax),%eax
f0120f68:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120f6b:	8b 52 04             	mov    0x4(%edx),%edx
f0120f6e:	89 50 04             	mov    %edx,0x4(%eax)
f0120f71:	eb 0b                	jmp    f0120f7e <merging+0xec>
f0120f73:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f76:	8b 40 04             	mov    0x4(%eax),%eax
f0120f79:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120f7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f81:	8b 40 04             	mov    0x4(%eax),%eax
f0120f84:	85 c0                	test   %eax,%eax
f0120f86:	74 0f                	je     f0120f97 <merging+0x105>
f0120f88:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f8b:	8b 40 04             	mov    0x4(%eax),%eax
f0120f8e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120f91:	8b 12                	mov    (%edx),%edx
f0120f93:	89 10                	mov    %edx,(%eax)
f0120f95:	eb 0a                	jmp    f0120fa1 <merging+0x10f>
f0120f97:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f9a:	8b 00                	mov    (%eax),%eax
f0120f9c:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fa4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120faa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fad:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120fb4:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120fb9:	48                   	dec    %eax
f0120fba:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0120fbf:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120fc0:	e9 ea 02 00 00       	jmp    f01212af <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0120fc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120fc9:	74 3b                	je     f0121006 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0120fcb:	83 ec 0c             	sub    $0xc,%esp
f0120fce:	ff 75 08             	pushl  0x8(%ebp)
f0120fd1:	e8 9b f0 ff ff       	call   f0120071 <get_block_size>
f0120fd6:	83 c4 10             	add    $0x10,%esp
f0120fd9:	89 c3                	mov    %eax,%ebx
f0120fdb:	83 ec 0c             	sub    $0xc,%esp
f0120fde:	ff 75 10             	pushl  0x10(%ebp)
f0120fe1:	e8 8b f0 ff ff       	call   f0120071 <get_block_size>
f0120fe6:	83 c4 10             	add    $0x10,%esp
f0120fe9:	01 d8                	add    %ebx,%eax
f0120feb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120fee:	83 ec 04             	sub    $0x4,%esp
f0120ff1:	6a 00                	push   $0x0
f0120ff3:	ff 75 e8             	pushl  -0x18(%ebp)
f0120ff6:	ff 75 08             	pushl  0x8(%ebp)
f0120ff9:	e8 c4 f3 ff ff       	call   f01203c2 <set_block_data>
f0120ffe:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121001:	e9 a9 02 00 00       	jmp    f01212af <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0121006:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012100a:	0f 84 2d 01 00 00    	je     f012113d <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0121010:	83 ec 0c             	sub    $0xc,%esp
f0121013:	ff 75 10             	pushl  0x10(%ebp)
f0121016:	e8 56 f0 ff ff       	call   f0120071 <get_block_size>
f012101b:	83 c4 10             	add    $0x10,%esp
f012101e:	89 c3                	mov    %eax,%ebx
f0121020:	83 ec 0c             	sub    $0xc,%esp
f0121023:	ff 75 0c             	pushl  0xc(%ebp)
f0121026:	e8 46 f0 ff ff       	call   f0120071 <get_block_size>
f012102b:	83 c4 10             	add    $0x10,%esp
f012102e:	01 d8                	add    %ebx,%eax
f0121030:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0121033:	83 ec 04             	sub    $0x4,%esp
f0121036:	6a 00                	push   $0x0
f0121038:	ff 75 e4             	pushl  -0x1c(%ebp)
f012103b:	ff 75 10             	pushl  0x10(%ebp)
f012103e:	e8 7f f3 ff ff       	call   f01203c2 <set_block_data>
f0121043:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0121046:	8b 45 10             	mov    0x10(%ebp),%eax
f0121049:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f012104c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121050:	74 06                	je     f0121058 <merging+0x1c6>
f0121052:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121056:	75 17                	jne    f012106f <merging+0x1dd>
f0121058:	83 ec 04             	sub    $0x4,%esp
f012105b:	68 10 0f 13 f0       	push   $0xf0130f10
f0121060:	68 8d 01 00 00       	push   $0x18d
f0121065:	68 55 0e 13 f0       	push   $0xf0130e55
f012106a:	e8 ca f2 fd ff       	call   f0100339 <_panic>
f012106f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121072:	8b 50 04             	mov    0x4(%eax),%edx
f0121075:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121078:	89 50 04             	mov    %edx,0x4(%eax)
f012107b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012107e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121081:	89 10                	mov    %edx,(%eax)
f0121083:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121086:	8b 40 04             	mov    0x4(%eax),%eax
f0121089:	85 c0                	test   %eax,%eax
f012108b:	74 0d                	je     f012109a <merging+0x208>
f012108d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121090:	8b 40 04             	mov    0x4(%eax),%eax
f0121093:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121096:	89 10                	mov    %edx,(%eax)
f0121098:	eb 08                	jmp    f01210a2 <merging+0x210>
f012109a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012109d:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01210a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01210a8:	89 50 04             	mov    %edx,0x4(%eax)
f01210ab:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01210b0:	40                   	inc    %eax
f01210b1:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		LIST_REMOVE(&freeBlocksList, next_block);
f01210b6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01210ba:	75 17                	jne    f01210d3 <merging+0x241>
f01210bc:	83 ec 04             	sub    $0x4,%esp
f01210bf:	68 37 0e 13 f0       	push   $0xf0130e37
f01210c4:	68 8e 01 00 00       	push   $0x18e
f01210c9:	68 55 0e 13 f0       	push   $0xf0130e55
f01210ce:	e8 66 f2 fd ff       	call   f0100339 <_panic>
f01210d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210d6:	8b 00                	mov    (%eax),%eax
f01210d8:	85 c0                	test   %eax,%eax
f01210da:	74 10                	je     f01210ec <merging+0x25a>
f01210dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210df:	8b 00                	mov    (%eax),%eax
f01210e1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01210e4:	8b 52 04             	mov    0x4(%edx),%edx
f01210e7:	89 50 04             	mov    %edx,0x4(%eax)
f01210ea:	eb 0b                	jmp    f01210f7 <merging+0x265>
f01210ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210ef:	8b 40 04             	mov    0x4(%eax),%eax
f01210f2:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01210f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210fa:	8b 40 04             	mov    0x4(%eax),%eax
f01210fd:	85 c0                	test   %eax,%eax
f01210ff:	74 0f                	je     f0121110 <merging+0x27e>
f0121101:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121104:	8b 40 04             	mov    0x4(%eax),%eax
f0121107:	8b 55 0c             	mov    0xc(%ebp),%edx
f012110a:	8b 12                	mov    (%edx),%edx
f012110c:	89 10                	mov    %edx,(%eax)
f012110e:	eb 0a                	jmp    f012111a <merging+0x288>
f0121110:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121113:	8b 00                	mov    (%eax),%eax
f0121115:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012111a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012111d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121123:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121126:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012112d:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121132:	48                   	dec    %eax
f0121133:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121138:	e9 72 01 00 00       	jmp    f01212af <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f012113d:	8b 45 10             	mov    0x10(%ebp),%eax
f0121140:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121143:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121147:	74 79                	je     f01211c2 <merging+0x330>
f0121149:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012114d:	74 73                	je     f01211c2 <merging+0x330>
f012114f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121153:	74 06                	je     f012115b <merging+0x2c9>
f0121155:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121159:	75 17                	jne    f0121172 <merging+0x2e0>
f012115b:	83 ec 04             	sub    $0x4,%esp
f012115e:	68 c8 0e 13 f0       	push   $0xf0130ec8
f0121163:	68 94 01 00 00       	push   $0x194
f0121168:	68 55 0e 13 f0       	push   $0xf0130e55
f012116d:	e8 c7 f1 fd ff       	call   f0100339 <_panic>
f0121172:	8b 45 08             	mov    0x8(%ebp),%eax
f0121175:	8b 10                	mov    (%eax),%edx
f0121177:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012117a:	89 10                	mov    %edx,(%eax)
f012117c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012117f:	8b 00                	mov    (%eax),%eax
f0121181:	85 c0                	test   %eax,%eax
f0121183:	74 0b                	je     f0121190 <merging+0x2fe>
f0121185:	8b 45 08             	mov    0x8(%ebp),%eax
f0121188:	8b 00                	mov    (%eax),%eax
f012118a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012118d:	89 50 04             	mov    %edx,0x4(%eax)
f0121190:	8b 45 08             	mov    0x8(%ebp),%eax
f0121193:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121196:	89 10                	mov    %edx,(%eax)
f0121198:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012119b:	8b 55 08             	mov    0x8(%ebp),%edx
f012119e:	89 50 04             	mov    %edx,0x4(%eax)
f01211a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211a4:	8b 00                	mov    (%eax),%eax
f01211a6:	85 c0                	test   %eax,%eax
f01211a8:	75 08                	jne    f01211b2 <merging+0x320>
f01211aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211ad:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01211b2:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01211b7:	40                   	inc    %eax
f01211b8:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01211bd:	e9 ce 00 00 00       	jmp    f0121290 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f01211c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01211c6:	74 65                	je     f012122d <merging+0x39b>
f01211c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01211cc:	75 17                	jne    f01211e5 <merging+0x353>
f01211ce:	83 ec 04             	sub    $0x4,%esp
f01211d1:	68 a4 0e 13 f0       	push   $0xf0130ea4
f01211d6:	68 95 01 00 00       	push   $0x195
f01211db:	68 55 0e 13 f0       	push   $0xf0130e55
f01211e0:	e8 54 f1 fd ff       	call   f0100339 <_panic>
f01211e5:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f01211eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211ee:	89 50 04             	mov    %edx,0x4(%eax)
f01211f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211f4:	8b 40 04             	mov    0x4(%eax),%eax
f01211f7:	85 c0                	test   %eax,%eax
f01211f9:	74 0c                	je     f0121207 <merging+0x375>
f01211fb:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0121200:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121203:	89 10                	mov    %edx,(%eax)
f0121205:	eb 08                	jmp    f012120f <merging+0x37d>
f0121207:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012120a:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012120f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121212:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121217:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012121a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121220:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121225:	40                   	inc    %eax
f0121226:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f012122b:	eb 63                	jmp    f0121290 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f012122d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121231:	75 17                	jne    f012124a <merging+0x3b8>
f0121233:	83 ec 04             	sub    $0x4,%esp
f0121236:	68 70 0e 13 f0       	push   $0xf0130e70
f012123b:	68 98 01 00 00       	push   $0x198
f0121240:	68 55 0e 13 f0       	push   $0xf0130e55
f0121245:	e8 ef f0 fd ff       	call   f0100339 <_panic>
f012124a:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0121250:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121253:	89 10                	mov    %edx,(%eax)
f0121255:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121258:	8b 00                	mov    (%eax),%eax
f012125a:	85 c0                	test   %eax,%eax
f012125c:	74 0d                	je     f012126b <merging+0x3d9>
f012125e:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121263:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121266:	89 50 04             	mov    %edx,0x4(%eax)
f0121269:	eb 08                	jmp    f0121273 <merging+0x3e1>
f012126b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012126e:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121273:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121276:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012127b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012127e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121285:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012128a:	40                   	inc    %eax
f012128b:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		}
		set_block_data(va, get_block_size(va), 0);
f0121290:	83 ec 0c             	sub    $0xc,%esp
f0121293:	ff 75 10             	pushl  0x10(%ebp)
f0121296:	e8 d6 ed ff ff       	call   f0120071 <get_block_size>
f012129b:	83 c4 10             	add    $0x10,%esp
f012129e:	83 ec 04             	sub    $0x4,%esp
f01212a1:	6a 00                	push   $0x0
f01212a3:	50                   	push   %eax
f01212a4:	ff 75 10             	pushl  0x10(%ebp)
f01212a7:	e8 16 f1 ff ff       	call   f01203c2 <set_block_data>
f01212ac:	83 c4 10             	add    $0x10,%esp
	}
}
f01212af:	90                   	nop
f01212b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01212b3:	c9                   	leave  
f01212b4:	c3                   	ret    

f01212b5 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f01212b5:	55                   	push   %ebp
f01212b6:	89 e5                	mov    %esp,%ebp
f01212b8:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f01212bb:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212c0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f01212c3:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f01212c8:	3b 45 08             	cmp    0x8(%ebp),%eax
f01212cb:	73 1b                	jae    f01212e8 <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f01212cd:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f01212d2:	83 ec 04             	sub    $0x4,%esp
f01212d5:	ff 75 08             	pushl  0x8(%ebp)
f01212d8:	6a 00                	push   $0x0
f01212da:	50                   	push   %eax
f01212db:	e8 b2 fb ff ff       	call   f0120e92 <merging>
f01212e0:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01212e3:	e9 8b 00 00 00       	jmp    f0121373 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01212e8:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212ed:	3b 45 08             	cmp    0x8(%ebp),%eax
f01212f0:	76 18                	jbe    f012130a <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01212f2:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212f7:	83 ec 04             	sub    $0x4,%esp
f01212fa:	ff 75 08             	pushl  0x8(%ebp)
f01212fd:	50                   	push   %eax
f01212fe:	6a 00                	push   $0x0
f0121300:	e8 8d fb ff ff       	call   f0120e92 <merging>
f0121305:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121308:	eb 69                	jmp    f0121373 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f012130a:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012130f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121312:	eb 39                	jmp    f012134d <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0121314:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121317:	3b 45 08             	cmp    0x8(%ebp),%eax
f012131a:	73 29                	jae    f0121345 <free_block+0x90>
f012131c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012131f:	8b 00                	mov    (%eax),%eax
f0121321:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121324:	76 1f                	jbe    f0121345 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0121326:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121329:	8b 00                	mov    (%eax),%eax
f012132b:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f012132e:	83 ec 04             	sub    $0x4,%esp
f0121331:	ff 75 08             	pushl  0x8(%ebp)
f0121334:	ff 75 f0             	pushl  -0x10(%ebp)
f0121337:	ff 75 f4             	pushl  -0xc(%ebp)
f012133a:	e8 53 fb ff ff       	call   f0120e92 <merging>
f012133f:	83 c4 10             	add    $0x10,%esp
			break;
f0121342:	90                   	nop
		}
	}
}
f0121343:	eb 2e                	jmp    f0121373 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121345:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f012134a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012134d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121351:	74 07                	je     f012135a <free_block+0xa5>
f0121353:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121356:	8b 00                	mov    (%eax),%eax
f0121358:	eb 05                	jmp    f012135f <free_block+0xaa>
f012135a:	b8 00 00 00 00       	mov    $0x0,%eax
f012135f:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0121364:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0121369:	85 c0                	test   %eax,%eax
f012136b:	75 a7                	jne    f0121314 <free_block+0x5f>
f012136d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121371:	75 a1                	jne    f0121314 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121373:	90                   	nop
f0121374:	c9                   	leave  
f0121375:	c3                   	ret    

f0121376 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121376:	55                   	push   %ebp
f0121377:	89 e5                	mov    %esp,%ebp
f0121379:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f012137c:	ff 75 08             	pushl  0x8(%ebp)
f012137f:	e8 ed ec ff ff       	call   f0120071 <get_block_size>
f0121384:	83 c4 04             	add    $0x4,%esp
f0121387:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f012138a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121391:	eb 17                	jmp    f01213aa <copy_data+0x34>
f0121393:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121396:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121399:	01 c2                	add    %eax,%edx
f012139b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f012139e:	8b 45 08             	mov    0x8(%ebp),%eax
f01213a1:	01 c8                	add    %ecx,%eax
f01213a3:	8a 00                	mov    (%eax),%al
f01213a5:	88 02                	mov    %al,(%edx)
f01213a7:	ff 45 fc             	incl   -0x4(%ebp)
f01213aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01213ad:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01213b0:	72 e1                	jb     f0121393 <copy_data+0x1d>
}
f01213b2:	90                   	nop
f01213b3:	c9                   	leave  
f01213b4:	c3                   	ret    

f01213b5 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f01213b5:	55                   	push   %ebp
f01213b6:	89 e5                	mov    %esp,%ebp
f01213b8:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f01213bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01213bf:	75 23                	jne    f01213e4 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f01213c1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01213c5:	74 13                	je     f01213da <realloc_block_FF+0x25>
f01213c7:	83 ec 0c             	sub    $0xc,%esp
f01213ca:	ff 75 0c             	pushl  0xc(%ebp)
f01213cd:	e8 1f f0 ff ff       	call   f01203f1 <alloc_block_FF>
f01213d2:	83 c4 10             	add    $0x10,%esp
f01213d5:	e9 f4 06 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
		return NULL;
f01213da:	b8 00 00 00 00       	mov    $0x0,%eax
f01213df:	e9 ea 06 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01213e4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01213e8:	75 18                	jne    f0121402 <realloc_block_FF+0x4d>
	{
		free_block(va);
f01213ea:	83 ec 0c             	sub    $0xc,%esp
f01213ed:	ff 75 08             	pushl  0x8(%ebp)
f01213f0:	e8 c0 fe ff ff       	call   f01212b5 <free_block>
f01213f5:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01213f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01213fd:	e9 cc 06 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f0121402:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121406:	77 07                	ja     f012140f <realloc_block_FF+0x5a>
f0121408:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f012140f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121412:	83 e0 01             	and    $0x1,%eax
f0121415:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121418:	8b 45 0c             	mov    0xc(%ebp),%eax
f012141b:	83 c0 08             	add    $0x8,%eax
f012141e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121421:	83 ec 0c             	sub    $0xc,%esp
f0121424:	ff 75 08             	pushl  0x8(%ebp)
f0121427:	e8 45 ec ff ff       	call   f0120071 <get_block_size>
f012142c:	83 c4 10             	add    $0x10,%esp
f012142f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121432:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121435:	83 e8 08             	sub    $0x8,%eax
f0121438:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f012143b:	8b 45 08             	mov    0x8(%ebp),%eax
f012143e:	83 e8 04             	sub    $0x4,%eax
f0121441:	8b 00                	mov    (%eax),%eax
f0121443:	83 e0 fe             	and    $0xfffffffe,%eax
f0121446:	89 c2                	mov    %eax,%edx
f0121448:	8b 45 08             	mov    0x8(%ebp),%eax
f012144b:	01 d0                	add    %edx,%eax
f012144d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121450:	83 ec 0c             	sub    $0xc,%esp
f0121453:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121456:	e8 16 ec ff ff       	call   f0120071 <get_block_size>
f012145b:	83 c4 10             	add    $0x10,%esp
f012145e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121461:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121464:	83 e8 08             	sub    $0x8,%eax
f0121467:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f012146a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012146d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121470:	75 08                	jne    f012147a <realloc_block_FF+0xc5>
	{
		 return va;
f0121472:	8b 45 08             	mov    0x8(%ebp),%eax
f0121475:	e9 54 06 00 00       	jmp    f0121ace <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f012147a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012147d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121480:	0f 83 e5 03 00 00    	jae    f012186b <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121486:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121489:	2b 45 0c             	sub    0xc(%ebp),%eax
f012148c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f012148f:	83 ec 0c             	sub    $0xc,%esp
f0121492:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121495:	e8 f0 eb ff ff       	call   f012008a <is_free_block>
f012149a:	83 c4 10             	add    $0x10,%esp
f012149d:	84 c0                	test   %al,%al
f012149f:	0f 84 3b 01 00 00    	je     f01215e0 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f01214a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01214a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01214ab:	01 d0                	add    %edx,%eax
f01214ad:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f01214b0:	83 ec 04             	sub    $0x4,%esp
f01214b3:	6a 01                	push   $0x1
f01214b5:	ff 75 f0             	pushl  -0x10(%ebp)
f01214b8:	ff 75 08             	pushl  0x8(%ebp)
f01214bb:	e8 02 ef ff ff       	call   f01203c2 <set_block_data>
f01214c0:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f01214c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01214c6:	83 e8 04             	sub    $0x4,%eax
f01214c9:	8b 00                	mov    (%eax),%eax
f01214cb:	83 e0 fe             	and    $0xfffffffe,%eax
f01214ce:	89 c2                	mov    %eax,%edx
f01214d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01214d3:	01 d0                	add    %edx,%eax
f01214d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f01214d8:	83 ec 04             	sub    $0x4,%esp
f01214db:	6a 00                	push   $0x0
f01214dd:	ff 75 cc             	pushl  -0x34(%ebp)
f01214e0:	ff 75 c8             	pushl  -0x38(%ebp)
f01214e3:	e8 da ee ff ff       	call   f01203c2 <set_block_data>
f01214e8:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01214eb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01214ef:	74 06                	je     f01214f7 <realloc_block_FF+0x142>
f01214f1:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01214f5:	75 17                	jne    f012150e <realloc_block_FF+0x159>
f01214f7:	83 ec 04             	sub    $0x4,%esp
f01214fa:	68 c8 0e 13 f0       	push   $0xf0130ec8
f01214ff:	68 f6 01 00 00       	push   $0x1f6
f0121504:	68 55 0e 13 f0       	push   $0xf0130e55
f0121509:	e8 2b ee fd ff       	call   f0100339 <_panic>
f012150e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121511:	8b 10                	mov    (%eax),%edx
f0121513:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121516:	89 10                	mov    %edx,(%eax)
f0121518:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012151b:	8b 00                	mov    (%eax),%eax
f012151d:	85 c0                	test   %eax,%eax
f012151f:	74 0b                	je     f012152c <realloc_block_FF+0x177>
f0121521:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121524:	8b 00                	mov    (%eax),%eax
f0121526:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121529:	89 50 04             	mov    %edx,0x4(%eax)
f012152c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012152f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121532:	89 10                	mov    %edx,(%eax)
f0121534:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121537:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012153a:	89 50 04             	mov    %edx,0x4(%eax)
f012153d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121540:	8b 00                	mov    (%eax),%eax
f0121542:	85 c0                	test   %eax,%eax
f0121544:	75 08                	jne    f012154e <realloc_block_FF+0x199>
f0121546:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121549:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012154e:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121553:	40                   	inc    %eax
f0121554:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121559:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012155d:	75 17                	jne    f0121576 <realloc_block_FF+0x1c1>
f012155f:	83 ec 04             	sub    $0x4,%esp
f0121562:	68 37 0e 13 f0       	push   $0xf0130e37
f0121567:	68 f7 01 00 00       	push   $0x1f7
f012156c:	68 55 0e 13 f0       	push   $0xf0130e55
f0121571:	e8 c3 ed fd ff       	call   f0100339 <_panic>
f0121576:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121579:	8b 00                	mov    (%eax),%eax
f012157b:	85 c0                	test   %eax,%eax
f012157d:	74 10                	je     f012158f <realloc_block_FF+0x1da>
f012157f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121582:	8b 00                	mov    (%eax),%eax
f0121584:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121587:	8b 52 04             	mov    0x4(%edx),%edx
f012158a:	89 50 04             	mov    %edx,0x4(%eax)
f012158d:	eb 0b                	jmp    f012159a <realloc_block_FF+0x1e5>
f012158f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121592:	8b 40 04             	mov    0x4(%eax),%eax
f0121595:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012159a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012159d:	8b 40 04             	mov    0x4(%eax),%eax
f01215a0:	85 c0                	test   %eax,%eax
f01215a2:	74 0f                	je     f01215b3 <realloc_block_FF+0x1fe>
f01215a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01215a7:	8b 40 04             	mov    0x4(%eax),%eax
f01215aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01215ad:	8b 12                	mov    (%edx),%edx
f01215af:	89 10                	mov    %edx,(%eax)
f01215b1:	eb 0a                	jmp    f01215bd <realloc_block_FF+0x208>
f01215b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01215b6:	8b 00                	mov    (%eax),%eax
f01215b8:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01215bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01215c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01215c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01215c9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01215d0:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01215d5:	48                   	dec    %eax
f01215d6:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01215db:	e9 83 02 00 00       	jmp    f0121863 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f01215e0:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f01215e4:	0f 86 69 02 00 00    	jbe    f0121853 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f01215ea:	83 ec 04             	sub    $0x4,%esp
f01215ed:	6a 01                	push   $0x1
f01215ef:	ff 75 f0             	pushl  -0x10(%ebp)
f01215f2:	ff 75 08             	pushl  0x8(%ebp)
f01215f5:	e8 c8 ed ff ff       	call   f01203c2 <set_block_data>
f01215fa:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01215fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121600:	83 e8 04             	sub    $0x4,%eax
f0121603:	8b 00                	mov    (%eax),%eax
f0121605:	83 e0 fe             	and    $0xfffffffe,%eax
f0121608:	89 c2                	mov    %eax,%edx
f012160a:	8b 45 08             	mov    0x8(%ebp),%eax
f012160d:	01 d0                	add    %edx,%eax
f012160f:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121612:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121617:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f012161a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f012161e:	75 68                	jne    f0121688 <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121620:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121624:	75 17                	jne    f012163d <realloc_block_FF+0x288>
f0121626:	83 ec 04             	sub    $0x4,%esp
f0121629:	68 70 0e 13 f0       	push   $0xf0130e70
f012162e:	68 06 02 00 00       	push   $0x206
f0121633:	68 55 0e 13 f0       	push   $0xf0130e55
f0121638:	e8 fc ec fd ff       	call   f0100339 <_panic>
f012163d:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0121643:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121646:	89 10                	mov    %edx,(%eax)
f0121648:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012164b:	8b 00                	mov    (%eax),%eax
f012164d:	85 c0                	test   %eax,%eax
f012164f:	74 0d                	je     f012165e <realloc_block_FF+0x2a9>
f0121651:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121656:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121659:	89 50 04             	mov    %edx,0x4(%eax)
f012165c:	eb 08                	jmp    f0121666 <realloc_block_FF+0x2b1>
f012165e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121661:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121666:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121669:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012166e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121671:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121678:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012167d:	40                   	inc    %eax
f012167e:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0121683:	e9 b0 01 00 00       	jmp    f0121838 <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121688:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012168d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121690:	76 68                	jbe    f01216fa <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121692:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121696:	75 17                	jne    f01216af <realloc_block_FF+0x2fa>
f0121698:	83 ec 04             	sub    $0x4,%esp
f012169b:	68 70 0e 13 f0       	push   $0xf0130e70
f01216a0:	68 0b 02 00 00       	push   $0x20b
f01216a5:	68 55 0e 13 f0       	push   $0xf0130e55
f01216aa:	e8 8a ec fd ff       	call   f0100339 <_panic>
f01216af:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f01216b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216b8:	89 10                	mov    %edx,(%eax)
f01216ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216bd:	8b 00                	mov    (%eax),%eax
f01216bf:	85 c0                	test   %eax,%eax
f01216c1:	74 0d                	je     f01216d0 <realloc_block_FF+0x31b>
f01216c3:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01216c8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01216cb:	89 50 04             	mov    %edx,0x4(%eax)
f01216ce:	eb 08                	jmp    f01216d8 <realloc_block_FF+0x323>
f01216d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216d3:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01216d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216db:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01216e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216e3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01216ea:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01216ef:	40                   	inc    %eax
f01216f0:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01216f5:	e9 3e 01 00 00       	jmp    f0121838 <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f01216fa:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01216ff:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121702:	73 68                	jae    f012176c <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121704:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121708:	75 17                	jne    f0121721 <realloc_block_FF+0x36c>
f012170a:	83 ec 04             	sub    $0x4,%esp
f012170d:	68 a4 0e 13 f0       	push   $0xf0130ea4
f0121712:	68 10 02 00 00       	push   $0x210
f0121717:	68 55 0e 13 f0       	push   $0xf0130e55
f012171c:	e8 18 ec fd ff       	call   f0100339 <_panic>
f0121721:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f0121727:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012172a:	89 50 04             	mov    %edx,0x4(%eax)
f012172d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121730:	8b 40 04             	mov    0x4(%eax),%eax
f0121733:	85 c0                	test   %eax,%eax
f0121735:	74 0c                	je     f0121743 <realloc_block_FF+0x38e>
f0121737:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f012173c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012173f:	89 10                	mov    %edx,(%eax)
f0121741:	eb 08                	jmp    f012174b <realloc_block_FF+0x396>
f0121743:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121746:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012174b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012174e:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121753:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121756:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012175c:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121761:	40                   	inc    %eax
f0121762:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0121767:	e9 cc 00 00 00       	jmp    f0121838 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f012176c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121773:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121778:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012177b:	e9 8a 00 00 00       	jmp    f012180a <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121780:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121783:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121786:	73 7a                	jae    f0121802 <realloc_block_FF+0x44d>
f0121788:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012178b:	8b 00                	mov    (%eax),%eax
f012178d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121790:	73 70                	jae    f0121802 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121796:	74 06                	je     f012179e <realloc_block_FF+0x3e9>
f0121798:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012179c:	75 17                	jne    f01217b5 <realloc_block_FF+0x400>
f012179e:	83 ec 04             	sub    $0x4,%esp
f01217a1:	68 c8 0e 13 f0       	push   $0xf0130ec8
f01217a6:	68 1a 02 00 00       	push   $0x21a
f01217ab:	68 55 0e 13 f0       	push   $0xf0130e55
f01217b0:	e8 84 eb fd ff       	call   f0100339 <_panic>
f01217b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01217b8:	8b 10                	mov    (%eax),%edx
f01217ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217bd:	89 10                	mov    %edx,(%eax)
f01217bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217c2:	8b 00                	mov    (%eax),%eax
f01217c4:	85 c0                	test   %eax,%eax
f01217c6:	74 0b                	je     f01217d3 <realloc_block_FF+0x41e>
f01217c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01217cb:	8b 00                	mov    (%eax),%eax
f01217cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01217d0:	89 50 04             	mov    %edx,0x4(%eax)
f01217d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01217d6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01217d9:	89 10                	mov    %edx,(%eax)
f01217db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01217e1:	89 50 04             	mov    %edx,0x4(%eax)
f01217e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217e7:	8b 00                	mov    (%eax),%eax
f01217e9:	85 c0                	test   %eax,%eax
f01217eb:	75 08                	jne    f01217f5 <realloc_block_FF+0x440>
f01217ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217f0:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01217f5:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01217fa:	40                   	inc    %eax
f01217fb:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
							break;
f0121800:	eb 36                	jmp    f0121838 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0121802:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0121807:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012180a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012180e:	74 07                	je     f0121817 <realloc_block_FF+0x462>
f0121810:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121813:	8b 00                	mov    (%eax),%eax
f0121815:	eb 05                	jmp    f012181c <realloc_block_FF+0x467>
f0121817:	b8 00 00 00 00       	mov    $0x0,%eax
f012181c:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0121821:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0121826:	85 c0                	test   %eax,%eax
f0121828:	0f 85 52 ff ff ff    	jne    f0121780 <realloc_block_FF+0x3cb>
f012182e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121832:	0f 85 48 ff ff ff    	jne    f0121780 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0121838:	83 ec 04             	sub    $0x4,%esp
f012183b:	6a 00                	push   $0x0
f012183d:	ff 75 d8             	pushl  -0x28(%ebp)
f0121840:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121843:	e8 7a eb ff ff       	call   f01203c2 <set_block_data>
f0121848:	83 c4 10             	add    $0x10,%esp
				return va;
f012184b:	8b 45 08             	mov    0x8(%ebp),%eax
f012184e:	e9 7b 02 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121853:	83 ec 0c             	sub    $0xc,%esp
f0121856:	68 45 0f 13 f0       	push   $0xf0130f45
f012185b:	e8 2b f7 fd ff       	call   f0100f8b <cprintf>
f0121860:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121863:	8b 45 08             	mov    0x8(%ebp),%eax
f0121866:	e9 63 02 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f012186b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012186e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121871:	0f 86 4d 02 00 00    	jbe    f0121ac4 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121877:	83 ec 0c             	sub    $0xc,%esp
f012187a:	ff 75 e4             	pushl  -0x1c(%ebp)
f012187d:	e8 08 e8 ff ff       	call   f012008a <is_free_block>
f0121882:	83 c4 10             	add    $0x10,%esp
f0121885:	84 c0                	test   %al,%al
f0121887:	0f 84 37 02 00 00    	je     f0121ac4 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f012188d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121890:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121893:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121896:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121899:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012189c:	76 38                	jbe    f01218d6 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f012189e:	83 ec 0c             	sub    $0xc,%esp
f01218a1:	ff 75 08             	pushl  0x8(%ebp)
f01218a4:	e8 0c fa ff ff       	call   f01212b5 <free_block>
f01218a9:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f01218ac:	83 ec 0c             	sub    $0xc,%esp
f01218af:	ff 75 0c             	pushl  0xc(%ebp)
f01218b2:	e8 3a eb ff ff       	call   f01203f1 <alloc_block_FF>
f01218b7:	83 c4 10             	add    $0x10,%esp
f01218ba:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f01218bd:	83 ec 08             	sub    $0x8,%esp
f01218c0:	ff 75 c0             	pushl  -0x40(%ebp)
f01218c3:	ff 75 08             	pushl  0x8(%ebp)
f01218c6:	e8 ab fa ff ff       	call   f0121376 <copy_data>
f01218cb:	83 c4 10             	add    $0x10,%esp
				return new_va;
f01218ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01218d1:	e9 f8 01 00 00       	jmp    f0121ace <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f01218d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01218d9:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f01218dc:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f01218df:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01218e3:	0f 87 a0 00 00 00    	ja     f0121989 <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f01218e9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01218ed:	75 17                	jne    f0121906 <realloc_block_FF+0x551>
f01218ef:	83 ec 04             	sub    $0x4,%esp
f01218f2:	68 37 0e 13 f0       	push   $0xf0130e37
f01218f7:	68 38 02 00 00       	push   $0x238
f01218fc:	68 55 0e 13 f0       	push   $0xf0130e55
f0121901:	e8 33 ea fd ff       	call   f0100339 <_panic>
f0121906:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121909:	8b 00                	mov    (%eax),%eax
f012190b:	85 c0                	test   %eax,%eax
f012190d:	74 10                	je     f012191f <realloc_block_FF+0x56a>
f012190f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121912:	8b 00                	mov    (%eax),%eax
f0121914:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121917:	8b 52 04             	mov    0x4(%edx),%edx
f012191a:	89 50 04             	mov    %edx,0x4(%eax)
f012191d:	eb 0b                	jmp    f012192a <realloc_block_FF+0x575>
f012191f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121922:	8b 40 04             	mov    0x4(%eax),%eax
f0121925:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012192a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012192d:	8b 40 04             	mov    0x4(%eax),%eax
f0121930:	85 c0                	test   %eax,%eax
f0121932:	74 0f                	je     f0121943 <realloc_block_FF+0x58e>
f0121934:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121937:	8b 40 04             	mov    0x4(%eax),%eax
f012193a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012193d:	8b 12                	mov    (%edx),%edx
f012193f:	89 10                	mov    %edx,(%eax)
f0121941:	eb 0a                	jmp    f012194d <realloc_block_FF+0x598>
f0121943:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121946:	8b 00                	mov    (%eax),%eax
f0121948:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012194d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121950:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121956:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121959:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121960:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121965:	48                   	dec    %eax
f0121966:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f012196b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012196e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121971:	01 d0                	add    %edx,%eax
f0121973:	83 ec 04             	sub    $0x4,%esp
f0121976:	6a 01                	push   $0x1
f0121978:	50                   	push   %eax
f0121979:	ff 75 08             	pushl  0x8(%ebp)
f012197c:	e8 41 ea ff ff       	call   f01203c2 <set_block_data>
f0121981:	83 c4 10             	add    $0x10,%esp
f0121984:	e9 36 01 00 00       	jmp    f0121abf <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0121989:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012198c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012198f:	01 d0                	add    %edx,%eax
f0121991:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0121994:	83 ec 04             	sub    $0x4,%esp
f0121997:	6a 01                	push   $0x1
f0121999:	ff 75 f0             	pushl  -0x10(%ebp)
f012199c:	ff 75 08             	pushl  0x8(%ebp)
f012199f:	e8 1e ea ff ff       	call   f01203c2 <set_block_data>
f01219a4:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01219a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01219aa:	83 e8 04             	sub    $0x4,%eax
f01219ad:	8b 00                	mov    (%eax),%eax
f01219af:	83 e0 fe             	and    $0xfffffffe,%eax
f01219b2:	89 c2                	mov    %eax,%edx
f01219b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01219b7:	01 d0                	add    %edx,%eax
f01219b9:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01219bc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01219c0:	74 06                	je     f01219c8 <realloc_block_FF+0x613>
f01219c2:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f01219c6:	75 17                	jne    f01219df <realloc_block_FF+0x62a>
f01219c8:	83 ec 04             	sub    $0x4,%esp
f01219cb:	68 c8 0e 13 f0       	push   $0xf0130ec8
f01219d0:	68 44 02 00 00       	push   $0x244
f01219d5:	68 55 0e 13 f0       	push   $0xf0130e55
f01219da:	e8 5a e9 fd ff       	call   f0100339 <_panic>
f01219df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01219e2:	8b 10                	mov    (%eax),%edx
f01219e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219e7:	89 10                	mov    %edx,(%eax)
f01219e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219ec:	8b 00                	mov    (%eax),%eax
f01219ee:	85 c0                	test   %eax,%eax
f01219f0:	74 0b                	je     f01219fd <realloc_block_FF+0x648>
f01219f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01219f5:	8b 00                	mov    (%eax),%eax
f01219f7:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01219fa:	89 50 04             	mov    %edx,0x4(%eax)
f01219fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a00:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0121a03:	89 10                	mov    %edx,(%eax)
f0121a05:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121a08:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121a0b:	89 50 04             	mov    %edx,0x4(%eax)
f0121a0e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121a11:	8b 00                	mov    (%eax),%eax
f0121a13:	85 c0                	test   %eax,%eax
f0121a15:	75 08                	jne    f0121a1f <realloc_block_FF+0x66a>
f0121a17:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121a1a:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121a1f:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121a24:	40                   	inc    %eax
f0121a25:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121a2a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121a2e:	75 17                	jne    f0121a47 <realloc_block_FF+0x692>
f0121a30:	83 ec 04             	sub    $0x4,%esp
f0121a33:	68 37 0e 13 f0       	push   $0xf0130e37
f0121a38:	68 45 02 00 00       	push   $0x245
f0121a3d:	68 55 0e 13 f0       	push   $0xf0130e55
f0121a42:	e8 f2 e8 fd ff       	call   f0100339 <_panic>
f0121a47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a4a:	8b 00                	mov    (%eax),%eax
f0121a4c:	85 c0                	test   %eax,%eax
f0121a4e:	74 10                	je     f0121a60 <realloc_block_FF+0x6ab>
f0121a50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a53:	8b 00                	mov    (%eax),%eax
f0121a55:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121a58:	8b 52 04             	mov    0x4(%edx),%edx
f0121a5b:	89 50 04             	mov    %edx,0x4(%eax)
f0121a5e:	eb 0b                	jmp    f0121a6b <realloc_block_FF+0x6b6>
f0121a60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a63:	8b 40 04             	mov    0x4(%eax),%eax
f0121a66:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121a6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a6e:	8b 40 04             	mov    0x4(%eax),%eax
f0121a71:	85 c0                	test   %eax,%eax
f0121a73:	74 0f                	je     f0121a84 <realloc_block_FF+0x6cf>
f0121a75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a78:	8b 40 04             	mov    0x4(%eax),%eax
f0121a7b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121a7e:	8b 12                	mov    (%edx),%edx
f0121a80:	89 10                	mov    %edx,(%eax)
f0121a82:	eb 0a                	jmp    f0121a8e <realloc_block_FF+0x6d9>
f0121a84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a87:	8b 00                	mov    (%eax),%eax
f0121a89:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0121a8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a91:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121a97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a9a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121aa1:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121aa6:	48                   	dec    %eax
f0121aa7:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				set_block_data(next_new_va, remaining_size, 0);
f0121aac:	83 ec 04             	sub    $0x4,%esp
f0121aaf:	6a 00                	push   $0x0
f0121ab1:	ff 75 bc             	pushl  -0x44(%ebp)
f0121ab4:	ff 75 b8             	pushl  -0x48(%ebp)
f0121ab7:	e8 06 e9 ff ff       	call   f01203c2 <set_block_data>
f0121abc:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0121abf:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ac2:	eb 0a                	jmp    f0121ace <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0121ac4:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f0121acb:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0121ace:	c9                   	leave  
f0121acf:	c3                   	ret    

f0121ad0 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0121ad0:	55                   	push   %ebp
f0121ad1:	89 e5                	mov    %esp,%ebp
f0121ad3:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0121ad6:	83 ec 04             	sub    $0x4,%esp
f0121ad9:	68 4c 0f 13 f0       	push   $0xf0130f4c
f0121ade:	68 58 02 00 00       	push   $0x258
f0121ae3:	68 55 0e 13 f0       	push   $0xf0130e55
f0121ae8:	e8 4c e8 fd ff       	call   f0100339 <_panic>

f0121aed <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0121aed:	55                   	push   %ebp
f0121aee:	89 e5                	mov    %esp,%ebp
f0121af0:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0121af3:	83 ec 04             	sub    $0x4,%esp
f0121af6:	68 74 0f 13 f0       	push   $0xf0130f74
f0121afb:	68 61 02 00 00       	push   $0x261
f0121b00:	68 55 0e 13 f0       	push   $0xf0130e55
f0121b05:	e8 2f e8 fd ff       	call   f0100339 <_panic>
f0121b0a:	66 90                	xchg   %ax,%ax

f0121b0c <__moddi3>:
f0121b0c:	55                   	push   %ebp
f0121b0d:	57                   	push   %edi
f0121b0e:	56                   	push   %esi
f0121b0f:	53                   	push   %ebx
f0121b10:	83 ec 2c             	sub    $0x2c,%esp
f0121b13:	8b 74 24 40          	mov    0x40(%esp),%esi
f0121b17:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0121b1b:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0121b1f:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0121b23:	89 d8                	mov    %ebx,%eax
f0121b25:	85 ff                	test   %edi,%edi
f0121b27:	0f 88 d3 00 00 00    	js     f0121c00 <__moddi3+0xf4>
f0121b2d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0121b34:	00 
f0121b35:	85 c0                	test   %eax,%eax
f0121b37:	0f 88 ab 00 00 00    	js     f0121be8 <__moddi3+0xdc>
f0121b3d:	89 0c 24             	mov    %ecx,(%esp)
f0121b40:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0121b44:	89 74 24 10          	mov    %esi,0x10(%esp)
f0121b48:	89 fb                	mov    %edi,%ebx
f0121b4a:	8b 14 24             	mov    (%esp),%edx
f0121b4d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0121b51:	89 d0                	mov    %edx,%eax
f0121b53:	89 54 24 18          	mov    %edx,0x18(%esp)
f0121b57:	89 ca                	mov    %ecx,%edx
f0121b59:	8b 0c 24             	mov    (%esp),%ecx
f0121b5c:	89 34 24             	mov    %esi,(%esp)
f0121b5f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0121b63:	85 d2                	test   %edx,%edx
f0121b65:	75 15                	jne    f0121b7c <__moddi3+0x70>
f0121b67:	89 c7                	mov    %eax,%edi
f0121b69:	39 d8                	cmp    %ebx,%eax
f0121b6b:	76 5b                	jbe    f0121bc8 <__moddi3+0xbc>
f0121b6d:	89 f0                	mov    %esi,%eax
f0121b6f:	89 da                	mov    %ebx,%edx
f0121b71:	f7 f7                	div    %edi
f0121b73:	89 d3                	mov    %edx,%ebx
f0121b75:	89 d8                	mov    %ebx,%eax
f0121b77:	31 d2                	xor    %edx,%edx
f0121b79:	eb 09                	jmp    f0121b84 <__moddi3+0x78>
f0121b7b:	90                   	nop
f0121b7c:	39 fa                	cmp    %edi,%edx
f0121b7e:	76 1c                	jbe    f0121b9c <__moddi3+0x90>
f0121b80:	89 f0                	mov    %esi,%eax
f0121b82:	89 fa                	mov    %edi,%edx
f0121b84:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0121b88:	85 c9                	test   %ecx,%ecx
f0121b8a:	74 07                	je     f0121b93 <__moddi3+0x87>
f0121b8c:	f7 d8                	neg    %eax
f0121b8e:	83 d2 00             	adc    $0x0,%edx
f0121b91:	f7 da                	neg    %edx
f0121b93:	83 c4 2c             	add    $0x2c,%esp
f0121b96:	5b                   	pop    %ebx
f0121b97:	5e                   	pop    %esi
f0121b98:	5f                   	pop    %edi
f0121b99:	5d                   	pop    %ebp
f0121b9a:	c3                   	ret    
f0121b9b:	90                   	nop
f0121b9c:	0f bd c2             	bsr    %edx,%eax
f0121b9f:	83 f0 1f             	xor    $0x1f,%eax
f0121ba2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0121ba6:	75 6c                	jne    f0121c14 <__moddi3+0x108>
f0121ba8:	39 fa                	cmp    %edi,%edx
f0121baa:	72 05                	jb     f0121bb1 <__moddi3+0xa5>
f0121bac:	3b 0c 24             	cmp    (%esp),%ecx
f0121baf:	77 0e                	ja     f0121bbf <__moddi3+0xb3>
f0121bb1:	8b 34 24             	mov    (%esp),%esi
f0121bb4:	29 ce                	sub    %ecx,%esi
f0121bb6:	19 d3                	sbb    %edx,%ebx
f0121bb8:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0121bbc:	89 34 24             	mov    %esi,(%esp)
f0121bbf:	8b 04 24             	mov    (%esp),%eax
f0121bc2:	8b 54 24 14          	mov    0x14(%esp),%edx
f0121bc6:	eb bc                	jmp    f0121b84 <__moddi3+0x78>
f0121bc8:	85 c9                	test   %ecx,%ecx
f0121bca:	75 0b                	jne    f0121bd7 <__moddi3+0xcb>
f0121bcc:	b8 01 00 00 00       	mov    $0x1,%eax
f0121bd1:	31 d2                	xor    %edx,%edx
f0121bd3:	f7 f1                	div    %ecx
f0121bd5:	89 c1                	mov    %eax,%ecx
f0121bd7:	89 d8                	mov    %ebx,%eax
f0121bd9:	31 d2                	xor    %edx,%edx
f0121bdb:	f7 f1                	div    %ecx
f0121bdd:	8b 04 24             	mov    (%esp),%eax
f0121be0:	f7 f1                	div    %ecx
f0121be2:	89 d3                	mov    %edx,%ebx
f0121be4:	eb 8f                	jmp    f0121b75 <__moddi3+0x69>
f0121be6:	66 90                	xchg   %ax,%ax
f0121be8:	89 c8                	mov    %ecx,%eax
f0121bea:	89 da                	mov    %ebx,%edx
f0121bec:	f7 d8                	neg    %eax
f0121bee:	83 d2 00             	adc    $0x0,%edx
f0121bf1:	f7 da                	neg    %edx
f0121bf3:	89 04 24             	mov    %eax,(%esp)
f0121bf6:	89 54 24 04          	mov    %edx,0x4(%esp)
f0121bfa:	e9 45 ff ff ff       	jmp    f0121b44 <__moddi3+0x38>
f0121bff:	90                   	nop
f0121c00:	f7 de                	neg    %esi
f0121c02:	83 d7 00             	adc    $0x0,%edi
f0121c05:	f7 df                	neg    %edi
f0121c07:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0121c0e:	ff 
f0121c0f:	e9 21 ff ff ff       	jmp    f0121b35 <__moddi3+0x29>
f0121c14:	b8 20 00 00 00       	mov    $0x20,%eax
f0121c19:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121c1d:	29 f8                	sub    %edi,%eax
f0121c1f:	89 c6                	mov    %eax,%esi
f0121c21:	89 44 24 14          	mov    %eax,0x14(%esp)
f0121c25:	89 f9                	mov    %edi,%ecx
f0121c27:	d3 e2                	shl    %cl,%edx
f0121c29:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0121c2d:	89 e8                	mov    %ebp,%eax
f0121c2f:	89 f1                	mov    %esi,%ecx
f0121c31:	d3 e8                	shr    %cl,%eax
f0121c33:	09 d0                	or     %edx,%eax
f0121c35:	89 04 24             	mov    %eax,(%esp)
f0121c38:	89 ea                	mov    %ebp,%edx
f0121c3a:	89 f9                	mov    %edi,%ecx
f0121c3c:	d3 e2                	shl    %cl,%edx
f0121c3e:	89 d7                	mov    %edx,%edi
f0121c40:	89 da                	mov    %ebx,%edx
f0121c42:	d3 e2                	shl    %cl,%edx
f0121c44:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0121c48:	d3 e5                	shl    %cl,%ebp
f0121c4a:	8b 44 24 10          	mov    0x10(%esp),%eax
f0121c4e:	89 f1                	mov    %esi,%ecx
f0121c50:	d3 e8                	shr    %cl,%eax
f0121c52:	09 d0                	or     %edx,%eax
f0121c54:	d3 eb                	shr    %cl,%ebx
f0121c56:	89 da                	mov    %ebx,%edx
f0121c58:	f7 34 24             	divl   (%esp)
f0121c5b:	89 d3                	mov    %edx,%ebx
f0121c5d:	f7 e7                	mul    %edi
f0121c5f:	89 c6                	mov    %eax,%esi
f0121c61:	89 d1                	mov    %edx,%ecx
f0121c63:	39 d3                	cmp    %edx,%ebx
f0121c65:	72 29                	jb     f0121c90 <__moddi3+0x184>
f0121c67:	74 33                	je     f0121c9c <__moddi3+0x190>
f0121c69:	89 e8                	mov    %ebp,%eax
f0121c6b:	29 f0                	sub    %esi,%eax
f0121c6d:	19 cb                	sbb    %ecx,%ebx
f0121c6f:	89 de                	mov    %ebx,%esi
f0121c71:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0121c75:	d3 e6                	shl    %cl,%esi
f0121c77:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121c7b:	89 f9                	mov    %edi,%ecx
f0121c7d:	d3 e8                	shr    %cl,%eax
f0121c7f:	09 c6                	or     %eax,%esi
f0121c81:	89 f0                	mov    %esi,%eax
f0121c83:	89 f9                	mov    %edi,%ecx
f0121c85:	d3 eb                	shr    %cl,%ebx
f0121c87:	89 da                	mov    %ebx,%edx
f0121c89:	e9 f6 fe ff ff       	jmp    f0121b84 <__moddi3+0x78>
f0121c8e:	66 90                	xchg   %ax,%ax
f0121c90:	29 f8                	sub    %edi,%eax
f0121c92:	1b 14 24             	sbb    (%esp),%edx
f0121c95:	89 d1                	mov    %edx,%ecx
f0121c97:	89 c6                	mov    %eax,%esi
f0121c99:	eb ce                	jmp    f0121c69 <__moddi3+0x15d>
f0121c9b:	90                   	nop
f0121c9c:	39 c5                	cmp    %eax,%ebp
f0121c9e:	72 f0                	jb     f0121c90 <__moddi3+0x184>
f0121ca0:	89 d9                	mov    %ebx,%ecx
f0121ca2:	eb c5                	jmp    f0121c69 <__moddi3+0x15d>

f0121ca4 <__udivdi3>:
f0121ca4:	55                   	push   %ebp
f0121ca5:	57                   	push   %edi
f0121ca6:	56                   	push   %esi
f0121ca7:	53                   	push   %ebx
f0121ca8:	83 ec 1c             	sub    $0x1c,%esp
f0121cab:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0121caf:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0121cb3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121cb7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0121cbb:	89 ca                	mov    %ecx,%edx
f0121cbd:	89 f8                	mov    %edi,%eax
f0121cbf:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0121cc3:	85 f6                	test   %esi,%esi
f0121cc5:	75 2d                	jne    f0121cf4 <__udivdi3+0x50>
f0121cc7:	39 cf                	cmp    %ecx,%edi
f0121cc9:	77 65                	ja     f0121d30 <__udivdi3+0x8c>
f0121ccb:	89 fd                	mov    %edi,%ebp
f0121ccd:	85 ff                	test   %edi,%edi
f0121ccf:	75 0b                	jne    f0121cdc <__udivdi3+0x38>
f0121cd1:	b8 01 00 00 00       	mov    $0x1,%eax
f0121cd6:	31 d2                	xor    %edx,%edx
f0121cd8:	f7 f7                	div    %edi
f0121cda:	89 c5                	mov    %eax,%ebp
f0121cdc:	31 d2                	xor    %edx,%edx
f0121cde:	89 c8                	mov    %ecx,%eax
f0121ce0:	f7 f5                	div    %ebp
f0121ce2:	89 c1                	mov    %eax,%ecx
f0121ce4:	89 d8                	mov    %ebx,%eax
f0121ce6:	f7 f5                	div    %ebp
f0121ce8:	89 cf                	mov    %ecx,%edi
f0121cea:	89 fa                	mov    %edi,%edx
f0121cec:	83 c4 1c             	add    $0x1c,%esp
f0121cef:	5b                   	pop    %ebx
f0121cf0:	5e                   	pop    %esi
f0121cf1:	5f                   	pop    %edi
f0121cf2:	5d                   	pop    %ebp
f0121cf3:	c3                   	ret    
f0121cf4:	39 ce                	cmp    %ecx,%esi
f0121cf6:	77 28                	ja     f0121d20 <__udivdi3+0x7c>
f0121cf8:	0f bd fe             	bsr    %esi,%edi
f0121cfb:	83 f7 1f             	xor    $0x1f,%edi
f0121cfe:	75 40                	jne    f0121d40 <__udivdi3+0x9c>
f0121d00:	39 ce                	cmp    %ecx,%esi
f0121d02:	72 0a                	jb     f0121d0e <__udivdi3+0x6a>
f0121d04:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0121d08:	0f 87 9e 00 00 00    	ja     f0121dac <__udivdi3+0x108>
f0121d0e:	b8 01 00 00 00       	mov    $0x1,%eax
f0121d13:	89 fa                	mov    %edi,%edx
f0121d15:	83 c4 1c             	add    $0x1c,%esp
f0121d18:	5b                   	pop    %ebx
f0121d19:	5e                   	pop    %esi
f0121d1a:	5f                   	pop    %edi
f0121d1b:	5d                   	pop    %ebp
f0121d1c:	c3                   	ret    
f0121d1d:	8d 76 00             	lea    0x0(%esi),%esi
f0121d20:	31 ff                	xor    %edi,%edi
f0121d22:	31 c0                	xor    %eax,%eax
f0121d24:	89 fa                	mov    %edi,%edx
f0121d26:	83 c4 1c             	add    $0x1c,%esp
f0121d29:	5b                   	pop    %ebx
f0121d2a:	5e                   	pop    %esi
f0121d2b:	5f                   	pop    %edi
f0121d2c:	5d                   	pop    %ebp
f0121d2d:	c3                   	ret    
f0121d2e:	66 90                	xchg   %ax,%ax
f0121d30:	89 d8                	mov    %ebx,%eax
f0121d32:	f7 f7                	div    %edi
f0121d34:	31 ff                	xor    %edi,%edi
f0121d36:	89 fa                	mov    %edi,%edx
f0121d38:	83 c4 1c             	add    $0x1c,%esp
f0121d3b:	5b                   	pop    %ebx
f0121d3c:	5e                   	pop    %esi
f0121d3d:	5f                   	pop    %edi
f0121d3e:	5d                   	pop    %ebp
f0121d3f:	c3                   	ret    
f0121d40:	bd 20 00 00 00       	mov    $0x20,%ebp
f0121d45:	89 eb                	mov    %ebp,%ebx
f0121d47:	29 fb                	sub    %edi,%ebx
f0121d49:	89 f9                	mov    %edi,%ecx
f0121d4b:	d3 e6                	shl    %cl,%esi
f0121d4d:	89 c5                	mov    %eax,%ebp
f0121d4f:	88 d9                	mov    %bl,%cl
f0121d51:	d3 ed                	shr    %cl,%ebp
f0121d53:	89 e9                	mov    %ebp,%ecx
f0121d55:	09 f1                	or     %esi,%ecx
f0121d57:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0121d5b:	89 f9                	mov    %edi,%ecx
f0121d5d:	d3 e0                	shl    %cl,%eax
f0121d5f:	89 c5                	mov    %eax,%ebp
f0121d61:	89 d6                	mov    %edx,%esi
f0121d63:	88 d9                	mov    %bl,%cl
f0121d65:	d3 ee                	shr    %cl,%esi
f0121d67:	89 f9                	mov    %edi,%ecx
f0121d69:	d3 e2                	shl    %cl,%edx
f0121d6b:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121d6f:	88 d9                	mov    %bl,%cl
f0121d71:	d3 e8                	shr    %cl,%eax
f0121d73:	09 c2                	or     %eax,%edx
f0121d75:	89 d0                	mov    %edx,%eax
f0121d77:	89 f2                	mov    %esi,%edx
f0121d79:	f7 74 24 0c          	divl   0xc(%esp)
f0121d7d:	89 d6                	mov    %edx,%esi
f0121d7f:	89 c3                	mov    %eax,%ebx
f0121d81:	f7 e5                	mul    %ebp
f0121d83:	39 d6                	cmp    %edx,%esi
f0121d85:	72 19                	jb     f0121da0 <__udivdi3+0xfc>
f0121d87:	74 0b                	je     f0121d94 <__udivdi3+0xf0>
f0121d89:	89 d8                	mov    %ebx,%eax
f0121d8b:	31 ff                	xor    %edi,%edi
f0121d8d:	e9 58 ff ff ff       	jmp    f0121cea <__udivdi3+0x46>
f0121d92:	66 90                	xchg   %ax,%ax
f0121d94:	8b 54 24 08          	mov    0x8(%esp),%edx
f0121d98:	89 f9                	mov    %edi,%ecx
f0121d9a:	d3 e2                	shl    %cl,%edx
f0121d9c:	39 c2                	cmp    %eax,%edx
f0121d9e:	73 e9                	jae    f0121d89 <__udivdi3+0xe5>
f0121da0:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0121da3:	31 ff                	xor    %edi,%edi
f0121da5:	e9 40 ff ff ff       	jmp    f0121cea <__udivdi3+0x46>
f0121daa:	66 90                	xchg   %ax,%ax
f0121dac:	31 c0                	xor    %eax,%eax
f0121dae:	e9 37 ff ff ff       	jmp    f0121cea <__udivdi3+0x46>
f0121db3:	90                   	nop

f0121db4 <__umoddi3>:
f0121db4:	55                   	push   %ebp
f0121db5:	57                   	push   %edi
f0121db6:	56                   	push   %esi
f0121db7:	53                   	push   %ebx
f0121db8:	83 ec 1c             	sub    $0x1c,%esp
f0121dbb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0121dbf:	8b 74 24 34          	mov    0x34(%esp),%esi
f0121dc3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121dc7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0121dcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0121dcf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0121dd3:	89 f3                	mov    %esi,%ebx
f0121dd5:	89 fa                	mov    %edi,%edx
f0121dd7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121ddb:	89 34 24             	mov    %esi,(%esp)
f0121dde:	85 c0                	test   %eax,%eax
f0121de0:	75 1a                	jne    f0121dfc <__umoddi3+0x48>
f0121de2:	39 f7                	cmp    %esi,%edi
f0121de4:	0f 86 a2 00 00 00    	jbe    f0121e8c <__umoddi3+0xd8>
f0121dea:	89 c8                	mov    %ecx,%eax
f0121dec:	89 f2                	mov    %esi,%edx
f0121dee:	f7 f7                	div    %edi
f0121df0:	89 d0                	mov    %edx,%eax
f0121df2:	31 d2                	xor    %edx,%edx
f0121df4:	83 c4 1c             	add    $0x1c,%esp
f0121df7:	5b                   	pop    %ebx
f0121df8:	5e                   	pop    %esi
f0121df9:	5f                   	pop    %edi
f0121dfa:	5d                   	pop    %ebp
f0121dfb:	c3                   	ret    
f0121dfc:	39 f0                	cmp    %esi,%eax
f0121dfe:	0f 87 ac 00 00 00    	ja     f0121eb0 <__umoddi3+0xfc>
f0121e04:	0f bd e8             	bsr    %eax,%ebp
f0121e07:	83 f5 1f             	xor    $0x1f,%ebp
f0121e0a:	0f 84 ac 00 00 00    	je     f0121ebc <__umoddi3+0x108>
f0121e10:	bf 20 00 00 00       	mov    $0x20,%edi
f0121e15:	29 ef                	sub    %ebp,%edi
f0121e17:	89 fe                	mov    %edi,%esi
f0121e19:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0121e1d:	89 e9                	mov    %ebp,%ecx
f0121e1f:	d3 e0                	shl    %cl,%eax
f0121e21:	89 d7                	mov    %edx,%edi
f0121e23:	89 f1                	mov    %esi,%ecx
f0121e25:	d3 ef                	shr    %cl,%edi
f0121e27:	09 c7                	or     %eax,%edi
f0121e29:	89 e9                	mov    %ebp,%ecx
f0121e2b:	d3 e2                	shl    %cl,%edx
f0121e2d:	89 14 24             	mov    %edx,(%esp)
f0121e30:	89 d8                	mov    %ebx,%eax
f0121e32:	d3 e0                	shl    %cl,%eax
f0121e34:	89 c2                	mov    %eax,%edx
f0121e36:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121e3a:	d3 e0                	shl    %cl,%eax
f0121e3c:	89 44 24 04          	mov    %eax,0x4(%esp)
f0121e40:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121e44:	89 f1                	mov    %esi,%ecx
f0121e46:	d3 e8                	shr    %cl,%eax
f0121e48:	09 d0                	or     %edx,%eax
f0121e4a:	d3 eb                	shr    %cl,%ebx
f0121e4c:	89 da                	mov    %ebx,%edx
f0121e4e:	f7 f7                	div    %edi
f0121e50:	89 d3                	mov    %edx,%ebx
f0121e52:	f7 24 24             	mull   (%esp)
f0121e55:	89 c6                	mov    %eax,%esi
f0121e57:	89 d1                	mov    %edx,%ecx
f0121e59:	39 d3                	cmp    %edx,%ebx
f0121e5b:	0f 82 87 00 00 00    	jb     f0121ee8 <__umoddi3+0x134>
f0121e61:	0f 84 91 00 00 00    	je     f0121ef8 <__umoddi3+0x144>
f0121e67:	8b 54 24 04          	mov    0x4(%esp),%edx
f0121e6b:	29 f2                	sub    %esi,%edx
f0121e6d:	19 cb                	sbb    %ecx,%ebx
f0121e6f:	89 d8                	mov    %ebx,%eax
f0121e71:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0121e75:	d3 e0                	shl    %cl,%eax
f0121e77:	89 e9                	mov    %ebp,%ecx
f0121e79:	d3 ea                	shr    %cl,%edx
f0121e7b:	09 d0                	or     %edx,%eax
f0121e7d:	89 e9                	mov    %ebp,%ecx
f0121e7f:	d3 eb                	shr    %cl,%ebx
f0121e81:	89 da                	mov    %ebx,%edx
f0121e83:	83 c4 1c             	add    $0x1c,%esp
f0121e86:	5b                   	pop    %ebx
f0121e87:	5e                   	pop    %esi
f0121e88:	5f                   	pop    %edi
f0121e89:	5d                   	pop    %ebp
f0121e8a:	c3                   	ret    
f0121e8b:	90                   	nop
f0121e8c:	89 fd                	mov    %edi,%ebp
f0121e8e:	85 ff                	test   %edi,%edi
f0121e90:	75 0b                	jne    f0121e9d <__umoddi3+0xe9>
f0121e92:	b8 01 00 00 00       	mov    $0x1,%eax
f0121e97:	31 d2                	xor    %edx,%edx
f0121e99:	f7 f7                	div    %edi
f0121e9b:	89 c5                	mov    %eax,%ebp
f0121e9d:	89 f0                	mov    %esi,%eax
f0121e9f:	31 d2                	xor    %edx,%edx
f0121ea1:	f7 f5                	div    %ebp
f0121ea3:	89 c8                	mov    %ecx,%eax
f0121ea5:	f7 f5                	div    %ebp
f0121ea7:	89 d0                	mov    %edx,%eax
f0121ea9:	e9 44 ff ff ff       	jmp    f0121df2 <__umoddi3+0x3e>
f0121eae:	66 90                	xchg   %ax,%ax
f0121eb0:	89 c8                	mov    %ecx,%eax
f0121eb2:	89 f2                	mov    %esi,%edx
f0121eb4:	83 c4 1c             	add    $0x1c,%esp
f0121eb7:	5b                   	pop    %ebx
f0121eb8:	5e                   	pop    %esi
f0121eb9:	5f                   	pop    %edi
f0121eba:	5d                   	pop    %ebp
f0121ebb:	c3                   	ret    
f0121ebc:	3b 04 24             	cmp    (%esp),%eax
f0121ebf:	72 06                	jb     f0121ec7 <__umoddi3+0x113>
f0121ec1:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121ec5:	77 0f                	ja     f0121ed6 <__umoddi3+0x122>
f0121ec7:	89 f2                	mov    %esi,%edx
f0121ec9:	29 f9                	sub    %edi,%ecx
f0121ecb:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0121ecf:	89 14 24             	mov    %edx,(%esp)
f0121ed2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121ed6:	8b 44 24 04          	mov    0x4(%esp),%eax
f0121eda:	8b 14 24             	mov    (%esp),%edx
f0121edd:	83 c4 1c             	add    $0x1c,%esp
f0121ee0:	5b                   	pop    %ebx
f0121ee1:	5e                   	pop    %esi
f0121ee2:	5f                   	pop    %edi
f0121ee3:	5d                   	pop    %ebp
f0121ee4:	c3                   	ret    
f0121ee5:	8d 76 00             	lea    0x0(%esi),%esi
f0121ee8:	2b 04 24             	sub    (%esp),%eax
f0121eeb:	19 fa                	sbb    %edi,%edx
f0121eed:	89 d1                	mov    %edx,%ecx
f0121eef:	89 c6                	mov    %eax,%esi
f0121ef1:	e9 71 ff ff ff       	jmp    f0121e67 <__umoddi3+0xb3>
f0121ef6:	66 90                	xchg   %ax,%ax
f0121ef8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0121efc:	72 ea                	jb     f0121ee8 <__umoddi3+0x134>
f0121efe:	89 d9                	mov    %ebx,%ecx
f0121f00:	e9 62 ff ff ff       	jmp    f0121e67 <__umoddi3+0xb3>
