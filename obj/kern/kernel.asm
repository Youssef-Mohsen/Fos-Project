
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 c4 1a 6c f0 01 	movl   $0x1,0xf06c1ac4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba d0 d7 b0 f0       	mov    $0xf0b0d7d0,%edx
f010006a:	b8 84 88 69 f0       	mov    $0xf0698884,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 84 88 69 f0       	push   $0xf0698884
f010007e:	e8 ed fd 01 00       	call   f011fe70 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 a0 25 12 f0       	push   $0xf01225a0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 e7 25 12 f0       	push   $0xf01225e7
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 fb 25 12 f0       	push   $0xf01225fb
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 0f 26 12 f0       	push   $0xf012260f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 1b 26 12 f0       	push   $0xf012261b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 23 26 12 f0       	push   $0xf0122623
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 9c 91 00 00       	call   f01092c4 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 09 f5 00 00       	call   f010f639 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 f2 f5 00 00       	call   f010f736 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 cd f5 00 00       	call   f010f71e <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 ed f5 00 00       	call   f010f74e <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 5e 02 02 00       	call   f01203c7 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 31 26 12 f0       	push   $0xf0122631
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 74 ac 00 00       	call   f010adf2 <env_init>
		ts_init();
f010017e:	e8 58 ce 00 00       	call   f010cfdb <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 1b 26 12 f0       	push   $0xf012261b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 44 26 12 f0       	push   $0xf0122644
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 6d 26 12 f0       	push   $0xf012266d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 83 26 12 f0       	push   $0xf0122683
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 a0 26 12 f0       	push   $0xf01226a0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 bf 26 12 f0       	push   $0xf01226bf
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 dc 26 12 f0       	push   $0xf01226dc
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 00 27 12 f0       	push   $0xf0122700
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 20 27 12 f0       	push   $0xf0122720
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 44 27 12 f0       	push   $0xf0122744
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 dc 2d 6c f0 00 	movl   $0x0,0xf06c2ddc
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 8c 27 12 f0       	push   $0xf012278c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 b8 27 12 f0       	push   $0xf01227b8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 dd 27 12 f0       	push   $0xf01227dd
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 e4 27 12 f0       	push   $0xf01227e4
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 2c 28 12 f0       	push   $0xf012282c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 74 28 12 f0       	push   $0xf0122874
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 2c 28 12 f0       	push   $0xf012282c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 e4 27 12 f0       	push   $0xf01227e4
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 b9 28 12 f0       	push   $0xf01228b9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 02 b7 00 00       	call   f010ba46 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 c0 28 12 f0       	push   $0xf01228c0
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 e5 28 12 f0       	push   $0xf01228e5
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 5e b6 00 00       	call   f010ba04 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 e7 28 12 f0       	push   $0xf01228e7
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 f1 28 12 f0       	push   $0xf01228f1
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 e5 28 12 f0       	push   $0xf01228e5
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 00 b6 00 00       	call   f010ba46 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 a5 b5 00 00       	call   f010ba04 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 f1 28 12 f0       	push   $0xf01228f1
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 e5 28 12 f0       	push   $0xf01228e5
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 8e b5 00 00       	call   f010ba46 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 33 b5 00 00       	call   f010ba04 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 0a 29 12 f0       	push   $0xf012290a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 e5 28 12 f0       	push   $0xf01228e5
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 c4 88 69 f0       	mov    0xf06988c4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 28 29 12 f0       	push   $0xf0122928
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 c4 88 69 f0       	mov    %eax,0xf06988c4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 6a dc 00 00       	call   f010e2df <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 c8 88 69 f0 b4 	movl   $0x3b4,0xf06988c8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 c8 88 69 f0 d4 	movl   $0x3d4,0xf06988c8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 cc 88 69 f0       	mov    %eax,0xf06988cc
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f010087a:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		text_length = 0;
f01008a6:	c7 05 c0 88 69 f0 00 	movl   $0x0,0xf06988c0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d d0 88 69 f0 	mov    0xf06988d0,%cx
f01008b7:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d cc 88 69 f0    	mov    0xf06988cc,%ecx
f0100972:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 d0 88 69 f0 	mov    %dx,0xf06988d0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 c0 88 69 f0    	mov    0xf06988c0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 c0 88 69 f0       	mov    %eax,0xf06988c0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 b5 f4 01 00       	call   f011fea0 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 c8 88 69 f0    	mov    0xf06988c8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 c8 88 69 f0    	mov    0xf06988c8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 f1 17 f0    	mov    -0xfe80ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 f5 17 f0 	mov    -0xfe80ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 c0 88 69 f0    	mov    0xf06988c0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 c0 88 69 f0       	mov    %eax,0xf06988c0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 3b 29 12 f0       	push   $0xf012293b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 ca d5 00 00       	call   f010e2df <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 e4 8a 69 f0    	mov    %edx,0xf0698ae4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 e0 88 69 f0    	mov    %dl,-0xf967720(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 e4 8a 69 f0 00 	movl   $0x0,0xf0698ae4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 e0 8a 69 f0    	mov    0xf0698ae0,%edx
f0100d7f:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 e0 8a 69 f0    	mov    %edx,0xf0698ae0
f0100d96:	8a 80 e0 88 69 f0    	mov    -0xf967720(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 e0 8a 69 f0 00 	movl   $0x0,0xf0698ae0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 e0 8a 69 f0    	mov    0xf0698ae0,%edx
f0100dd0:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 e0 8a 69 f0    	mov    %edx,0xf0698ae0
f0100de7:	8a 80 e0 88 69 f0    	mov    -0xf967720(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 e0 8a 69 f0 00 	movl   $0x0,0xf0698ae0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 c4 88 69 f0       	mov    0xf06988c4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 47 29 12 f0       	push   $0xf0122947
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 85 ab 00 00       	call   f010ba46 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 64 29 12 f0       	push   $0xf0122964
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 8b 29 12 f0       	push   $0xf012298b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 3e ab 00 00       	call   f010ba46 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 a0 29 12 f0       	push   $0xf01229a0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 8b 29 12 f0       	push   $0xf012298b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 3d e6 01 00       	call   f011f5c0 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 8a ec 01 00       	call   f011fc82 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 c0 0e 6e f0       	push   $0xf06e0ec0
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 8d ee 01 00       	call   f011fea0 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 c8 eb 01 00       	call   f011fc82 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 c0 0e 6e f0       	push   $0xf06e0ec0
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 cb ed 01 00       	call   f011fea0 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 08 ed 01 00       	call   f011fe70 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 cc 29 12 f0       	push   $0xf01229cc
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 cf 29 12 f0       	push   $0xf01229cf
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 a0 2e 6c f0       	push   $0xf06c2ea0
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 ad e9 01 00       	call   f011fc82 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 c2 e9 01 00       	call   f011fcd1 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 65 e9 01 00       	call   f011fc82 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 df 29 12 f0       	push   $0xf01229df
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 40 ef 01 00       	call   f0120297 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 e4 29 12 f0       	push   $0xf01229e4
f010137e:	50                   	push   %eax
f010137f:	e8 0a ea 01 00       	call   f011fd8e <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 e8 29 12 f0       	push   $0xf01229e8
f0101399:	50                   	push   %eax
f010139a:	e8 ef e9 01 00       	call   f011fd8e <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 ed 29 12 f0       	push   $0xf01229ed
f01013b4:	50                   	push   %eax
f01013b5:	e8 d4 e9 01 00       	call   f011fd8e <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 ed 29 12 f0       	push   $0xf01229ed
f01013d5:	50                   	push   %eax
f01013d6:	e8 b3 e9 01 00       	call   f011fd8e <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 5b e8 01 00       	call   f011fc82 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 5d e8 01 00       	call   f011fcd1 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 3c e8 01 00       	call   f011fcd1 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 b9 e7 01 00       	call   f011fc82 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 d4 e8 01 00       	call   f011fdc6 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 09 e7 01 00       	call   f011fc82 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 d4 e8 01 00       	call   f011fe70 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 3f e7 01 00       	call   f011fcff <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 7f e6 01 00       	call   f011fc82 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 97 e7 01 00       	call   f011fdc6 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 e2 e5 01 00       	call   f011fc82 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 82 e5 01 00       	call   f011fc82 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 4d e7 01 00       	call   f011fe70 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 b8 e5 01 00       	call   f011fcff <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 fa e4 01 00       	call   f011fc82 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 15 e6 01 00       	call   f011fdc6 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 60 e4 01 00       	call   f011fc82 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 06 e4 01 00       	call   f011fc82 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 d1 e5 01 00       	call   f011fe70 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 3c e4 01 00       	call   f011fcff <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 a0 2e 6c f0       	push   $0xf06c2ea0
f0101929:	e8 54 e3 01 00       	call   f011fc82 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 fb e2 01 00       	call   f011fc82 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 e8 e2 01 00       	call   f011fc82 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 a0 2e 6c f0    	lea    -0xf93d160(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 8d e2 01 00       	call   f011fc82 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 a0 be 6d f0    	lea    -0xf924160(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 82 e2 01 00       	call   f011fea0 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 a0 0a 6e f0       	push   $0xf06e0aa0
f0101c3a:	e8 61 e2 01 00       	call   f011fea0 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 31 e1 01 00       	call   f011fd8e <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 f5 17 f0       	mov    %eax,0xf017f530
f0101c6f:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 13 e2 01 00       	call   f011fea0 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 dc 2d 6c f0       	mov    0xf06c2ddc,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb f7 29 12 f0       	mov    $0xf01229f7,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb f7 2d 12 f0       	mov    $0xf0122df7,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb f7 31 12 f0       	mov    $0xf01231f7,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 dc 2d 6c f0 00 	movl   $0x0,0xf06c2ddc
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 58 2d 6c f0 00 	movl   $0x0,0xf06c2d58
f0101d59:	00 00 00 
f0101d5c:	c7 05 5c 2d 6c f0 00 	movl   $0x0,0xf06c2d5c
f0101d63:	00 00 00 
f0101d66:	c7 05 64 2d 6c f0 00 	movl   $0x0,0xf06c2d64
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 ea e0 01 00       	call   f011fe70 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 f1 29 12 f0       	push   $0xf01229f1
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 f4 9e 00 00       	call   f010bcd3 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 80 2e 6c f0       	mov    %eax,0xf06c2e80
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 80 2e 6c f0       	mov    0xf06c2e80,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 80 2e 6c f0    	mov    %edx,0xf06c2e80
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
f0101e98:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 80 2e 6c f0       	mov    %eax,0xf06c2e80
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 80 2e 6c f0       	mov    0xf06c2e80,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 80 2e 6c f0    	mov    %edx,0xf06c2e80
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
f0101ed4:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 df 29 12 f0       	push   $0xf01229df
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 81 e3 01 00       	call   f0120297 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 f7 35 12 f0       	push   $0xf01235f7
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 10 36 12 f0       	push   $0xf0123610
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 61 36 12 f0       	push   $0xf0123661
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 7c 36 12 f0       	push   $0xf012367c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ac 36 12 f0       	push   $0xf01236ac
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 61 36 12 f0       	push   $0xf0123661
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 d6 36 12 f0       	push   $0xf01236d6
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f010203b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 e0 36 12 f0       	push   $0xf01236e0
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 43 37 12 f0       	push   $0xf0123743
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 4c 37 12 f0       	push   $0xf012374c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f010218b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 f5 17 f0       	add    $0xf017f548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 54 37 12 f0       	push   $0xf0123754
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 61 36 12 f0       	push   $0xf0123661
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f0102292:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 b0 da 01 00       	call   f011fd8e <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010238d:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023a3:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010248c:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01024a2:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 78 1b 6c f0 00 	movl   $0x0,0xf06c1b78
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 78 1b 6c f0 02 	movl   $0x2,0xf06c1b78
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 78 1b 6c f0 03 	movl   $0x3,0xf06c1b78
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 78 1b 6c f0 04 	movl   $0x4,0xf06c1b78
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 c4 1a 6c f0 01 	movl   $0x1,0xf06c1ac4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 c4 1a 6c f0 02 	movl   $0x2,0xf06c1ac4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 c4 1a 6c f0 03 	movl   $0x3,0xf06c1ac4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 c4 1a 6c f0 04 	movl   $0x4,0xf06c1ac4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 74 37 12 f0       	push   $0xf0123774
f0102662:	6a 56                	push   $0x56
f0102664:	68 9c 37 12 f0       	push   $0xf012379c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 f5 17 f0       	add    $0xf017f544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 1f 40 12 f0       	push   $0xf012401f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 28 40 12 f0       	push   $0xf0124028
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 3d 40 12 f0       	push   $0xf012403d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 59 40 12 f0       	push   $0xf0124059
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 74 40 12 f0       	push   $0xf0124074
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 81 25 12 00       	mov    $0x122581,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 81 25 12 f0       	push   $0xf0122581
f010278e:	68 b0 40 12 f0       	push   $0xf01240b0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 84 88 69 00       	mov    $0x698884,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 84 88 69 f0       	push   $0xf0698884
f01027a9:	68 ec 40 12 f0       	push   $0xf01240ec
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 d0 d7 b0 00       	mov    $0xb0d7d0,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 d0 d7 b0 f0       	push   $0xf0b0d7d0
f01027c4:	68 34 41 12 f0       	push   $0xf0124134
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 d0 d7 b0 f0       	mov    $0xf0b0d7d0,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 70 41 12 f0       	push   $0xf0124170
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 b8 d7 01 00       	call   f011ffe2 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 77 d7 01 00       	call   f011ffe2 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 0d 92 00 00       	call   f010ba96 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 41 d7 01 00       	call   f011ffe2 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 9c 41 12 f0       	push   $0xf012419c
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 bb d6 01 00       	call   f011ffe2 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 38 d3 01 00       	call   f011fc82 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 3d d6 01 00       	call   f011ffe2 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 c6 41 12 f0       	push   $0xf01241c6
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 f1 d5 01 00       	call   f011ffe2 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 87 90 00 00       	call   f010ba96 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 bb d5 01 00       	call   f011ffe2 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 c6 41 12 f0       	push   $0xf01241c6
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 e0 41 12 f0       	push   $0xf01241e0
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 2a d5 01 00       	call   f011ffe2 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 0a 42 12 f0       	push   $0xf012420a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 0d 42 12 f0       	push   $0xf012420d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 cd d4 01 00       	call   f011ffe2 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 63 8f 00 00       	call   f010ba96 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 97 d4 01 00       	call   f011ffe2 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 7c d4 01 00       	call   f011ffe2 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 0f 42 12 f0       	push   $0xf012420f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 e0 d3 01 00       	call   f011ffe2 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 76 8e 00 00       	call   f010ba96 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 99 d3 01 00       	call   f011ffe2 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 6a 6c 00 00       	call   f01098ef <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 fc 6a 00 00       	call   f010978d <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 20 42 12 f0       	push   $0xf0124220
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 a4 d2 01 00       	call   f011ffe2 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 3a 8d 00 00       	call   f010ba96 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 5d d2 01 00       	call   f011ffe2 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 4a 42 12 f0       	push   $0xf012424a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 64 42 12 f0       	push   $0xf0124264
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 a8 42 12 f0       	push   $0xf01242a8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 90 1c 6c f0       	mov    0xf06c1c90,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 00 43 12 f0       	push   $0xf0124300
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 62 c7 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 3c 43 12 f0       	push   $0xf012433c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 8d d0 01 00       	call   f011ffe2 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 72 d0 01 00       	call   f011ffe2 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 57 d0 01 00       	call   f011ffe2 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 e1 c6 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 26 d0 01 00       	call   f011ffe2 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 09 d0 01 00       	call   f011ffe2 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 ee cf 01 00       	call   f011ffe2 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 7b c6 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 e8 43 12 f0       	push   $0xf01243e8
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 a6 cf 01 00       	call   f011ffe2 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 78 44 12 f0       	push   $0xf0124478
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 19 c6 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 10 45 12 f0       	push   $0xf0124510
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 68 45 12 f0       	push   $0xf0124568
f010309d:	68 ad 45 12 f0       	push   $0xf01245ad
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 c2 45 12 f0       	push   $0xf01245c2
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 68 45 12 f0       	push   $0xf0124568
f01030bc:	68 ad 45 12 f0       	push   $0xf01245ad
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 c2 45 12 f0       	push   $0xf01245c2
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 e1 7e 00 00       	call   f010afc8 <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 d6 45 12 f0       	push   $0xf01245d6
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 e8 45 12 f0       	push   $0xf01245e8
f0103117:	68 ad 45 12 f0       	push   $0xf01245ad
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 c2 45 12 f0       	push   $0xf01245c2
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 18 46 12 f0       	push   $0xf0124618
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 90 1c 6c f0 00 	movl   $0x0,0xf06c1c90
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 17 ce 01 00       	call   f011ffe2 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 18 46 12 f0       	push   $0xf0124618
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 90 1c 6c f0 00 	movl   $0x0,0xf06c1c90
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 30 46 12 f0       	push   $0xf0124630
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 2d cd 01 00       	call   f011ffe2 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 2a c3 00 00       	call   f010f5f6 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 90 46 12 f0       	push   $0xf0124690
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 04 c3 00 00       	call   f010f5f6 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 d4 46 12 f0       	push   $0xf01246d4
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 14 47 12 f0       	push   $0xf0124714
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 a2 cc 01 00       	call   f011ffe2 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 18 c3 00 00       	call   f010f669 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 68 47 12 f0       	push   $0xf0124768
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 b3 c2 00 00       	call   f010f629 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 9c 47 12 f0       	push   $0xf012479c
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 a1 c2 00 00       	call   f010f639 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 c8 47 12 f0       	push   $0xf01247c8
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 8f c2 00 00       	call   f010f649 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 f0 47 12 f0       	push   $0xf01247f0
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 f6 cb 01 00       	call   f011ffe2 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 24 48 12 f0       	push   $0xf0124824
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 a2 cb 01 00       	call   f011ffe2 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 6f cb 01 00       	call   f011ffe2 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 5c 48 12 f0       	push   $0xf012485c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 a4 19 6c f0    	mov    0xf06c19a4,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 89 48 12 f0       	push   $0xf0124889
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 0d 42 12 f0       	push   $0xf012420d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 ca ca 01 00       	call   f011ffe2 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 af ca 01 00       	call   f011ffe2 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 90 48 12 f0       	push   $0xf0124890
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 0d 42 12 f0       	push   $0xf012420d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 cc 48 12 f0       	push   $0xf01248cc
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 a4 19 6c f0    	mov    0xf06c19a4,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 89 48 12 f0       	push   $0xf0124889
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 0d 42 12 f0       	push   $0xf012420d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 00 49 12 f0       	push   $0xf0124900
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 90 48 12 f0       	push   $0xf0124890
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 3c 49 12 f0       	push   $0xf012493c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 71 c9 01 00       	call   f011ffe2 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 50 b7 01 00       	call   f011edd6 <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 64 49 12 f0       	push   $0xf0124964
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 8c 49 12 f0       	push   $0xf012498c
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 ce bf 00 00       	call   f010f697 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 b0 49 12 f0       	push   $0xf01249b0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 95 bf 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 d8 49 12 f0       	push   $0xf01249d8
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 72 bf 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 18 4a 12 f0       	push   $0xf0124a18
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 85 bf 00 00       	call   f010f6b2 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 54 4a 12 f0       	push   $0xf0124a54
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 85 bf 00 00       	call   f010f6cd <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 78 4a 12 f0       	push   $0xf0124a78
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 a8 4a 12 f0       	push   $0xf0124aa8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 d4 4a 12 f0       	push   $0xf0124ad4
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 04 4b 12 f0       	push   $0xf0124b04
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 34 4b 12 f0       	push   $0xf0124b34
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 64 4b 12 f0       	push   $0xf0124b64
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 94 4b 12 f0       	push   $0xf0124b94
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 c0 4b 12 f0       	push   $0xf0124bc0
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 ec 4b 12 f0       	push   $0xf0124bec
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 18 4c 12 f0       	push   $0xf0124c18
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 44 4c 12 f0       	push   $0xf0124c44
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 70 4c 12 f0       	push   $0xf0124c70
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 70 4c 12 f0       	push   $0xf0124c70
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 a4 4c 12 f0       	push   $0xf0124ca4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 d4 4c 12 f0       	push   $0xf0124cd4
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 04 4d 12 f0       	push   $0xf0124d04
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 38 4d 12 f0       	push   $0xf0124d38
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 74 4d 12 f0       	push   $0xf0124d74
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 a4 4d 12 f0       	push   $0xf0124da4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 d0 4d 12 f0       	push   $0xf0124dd0
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 fc 4d 12 f0       	push   $0xf0124dfc
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 2c 4e 12 f0       	push   $0xf0124e2c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 65 bd 00 00       	call   f010f744 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 5c 4e 12 f0       	push   $0xf0124e5c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 1f bd 00 00       	call   f010f71e <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 98 4e 12 f0       	push   $0xf0124e98
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 20 bd 00 00       	call   f010f744 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 5c 4e 12 f0       	push   $0xf0124e5c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 da bc 00 00       	call   f010f71e <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 bc 4e 12 f0       	push   $0xf0124ebc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 c8 bc 00 00       	call   f010f736 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 a3 bc 00 00       	call   f010f71e <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 dc 4e 12 f0       	push   $0xf0124edc
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 91 bc 00 00       	call   f010f736 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 6c bc 00 00       	call   f010f71e <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 a2 bc 00 00       	call   f010f75c <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 f8 4e 12 f0       	push   $0xf0124ef8
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 28 4f 12 f0       	push   $0xf0124f28
f0103ada:	e8 9b bf 01 00       	call   f011fa7a <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 f0 c4 01 00       	call   f011ffe2 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 50 bc 00 00       	call   f010f74e <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 56 bc 00 00       	call   f010f75c <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 54 4f 12 f0       	push   $0xf0124f54
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 79 4f 12 f0       	push   $0xf0124f79
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 0b bc 00 00       	call   f010f744 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 94 4f 12 f0       	push   $0xf0124f94
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 d8 bb 00 00       	call   f010f72c <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 65 c4 01 00       	call   f011ffe2 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 c5 bb 00 00       	call   f010f74e <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 cb bb 00 00       	call   f010f75c <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 54 4f 12 f0       	push   $0xf0124f54
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 90 bb 00 00       	call   f010f744 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 94 4f 12 f0       	push   $0xf0124f94
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 5d bb 00 00       	call   f010f72c <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 74 bb 00 00       	call   f010f75c <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 2a 50 12 f0       	push   $0xf012502a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 a7 c6 00 00       	call   f01102bb <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 2d c8 01 00       	call   f012046a <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 3e c9 01 00       	call   f01205aa <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 48 50 12 f0       	push   $0xf0125048
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 5f 50 12 f0       	push   $0xf012505f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 c0 2c 6c f0 00 	movl   $0x0,0xf06c2cc0
f0103c9f:	00 00 00 
f0103ca2:	c7 05 c4 2c 6c f0 00 	movl   $0x0,0xf06c2cc4
f0103ca9:	00 00 00 
f0103cac:	c7 05 cc 2c 6c f0 00 	movl   $0x0,0xf06c2ccc
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 7c 50 12 f0       	push   $0xf012507c
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 5f 50 12 f0       	push   $0xf012505f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103d36:	8b 1d a0 13 6c f0    	mov    0xf06c13a0,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103d68:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103d81:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 a0 13 6c f0    	mov    0xf06c13a0,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103e0a:	e8 c5 be 00 00       	call   f010fcd4 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 c0 2c 6c f0       	mov    0xf06c2cc0,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 9f 50 12 f0       	push   $0xf012509f
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 5f 50 12 f0       	push   $0xf012505f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103ed6:	e8 80 be 00 00       	call   f010fd5b <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103efc:	e8 d3 bd 00 00       	call   f010fcd4 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 7c 50 12 f0       	push   $0xf012507c
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 5f 50 12 f0       	push   $0xf012505f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103f5b:	8b 1d a0 13 6c f0    	mov    0xf06c13a0,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103f8d:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103fa6:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103fd4:	e8 82 bd 00 00       	call   f010fd5b <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 d3 58 00 00       	call   f01098ef <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 c0 50 12 f0       	push   $0xf01250c0
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 5f 50 12 f0       	push   $0xf012505f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 85 54 00 00       	call   f010950e <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 ce 57 00 00       	call   f0109892 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 8f bd 01 00       	call   f011fe70 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 7c 1b 6c f0       	mov    0xf06c1b7c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 f0 50 12 f0       	push   $0xf01250f0
f0104192:	68 16 51 12 f0       	push   $0xf0125116
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 5f 50 12 f0       	push   $0xf012505f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 f0 50 12 f0       	push   $0xf01250f0
f0104245:	68 16 51 12 f0       	push   $0xf0125116
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 5f 50 12 f0       	push   $0xf012505f
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 f0 50 12 f0       	push   $0xf01250f0
f010430b:	68 16 51 12 f0       	push   $0xf0125116
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 5f 50 12 f0       	push   $0xf012505f
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 2c 51 12 f0       	push   $0xf012512c
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 5f 50 12 f0       	push   $0xf012505f
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 78 51 12 f0       	push   $0xf0125178
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 5f 50 12 f0       	push   $0xf012505f
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 ff 56 00 00       	call   f0109c86 <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 77 52 00 00       	call   f01098ef <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 a1 50 00 00       	call   f010978d <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 79 50 00 00       	call   f010978d <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 2f 50 00 00       	call   f010978d <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 64 4d 00 00       	call   f010950e <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 c0 50 00 00       	call   f0109892 <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 7b b6 01 00       	call   f011fe70 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 9a 50 00 00       	call   f01098ef <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f01048b3:	e8 1c b4 00 00       	call   f010fcd4 <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f01048cb:	e8 8b b4 00 00       	call   f010fd5b <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 0c 4c 00 00       	call   f010950e <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 68 4f 00 00       	call   f0109892 <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 23 b5 01 00       	call   f011fe70 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 f0 50 12 f0       	push   $0xf01250f0
f010496b:	68 16 51 12 f0       	push   $0xf0125116
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 5f 50 12 f0       	push   $0xf012505f
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 f4 51 12 f0       	push   $0xf01251f4
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 56 ba 01 00       	call   f01205aa <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 88 1c 6c f0 00 	movl   $0x0,0xf06c1c88
f0104c05:	00 00 00 
f0104c08:	c7 05 8c 1c 6c f0 00 	movl   $0x0,0xf06c1c8c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 be 96 00 00       	call   f010e2df <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 18 52 12 f0       	push   $0xf0125218
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 74 52 12 f0       	push   $0xf0125274
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 18 52 12 f0       	push   $0xf0125218
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 74 52 12 f0       	push   $0xf0125274
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 88 52 12 f0       	push   $0xf0125288
f0104fbb:	68 96 52 12 f0       	push   $0xf0125296
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 ab 52 12 f0       	push   $0xf01252ab
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 c4 52 12 f0       	push   $0xf01252c4
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 ab 52 12 f0       	push   $0xf01252ab
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 e7 52 12 f0       	push   $0xf01252e7
f0105072:	6a 44                	push   $0x44
f0105074:	68 ab 52 12 f0       	push   $0xf01252ab
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 88 52 12 f0       	push   $0xf0125288
f0105104:	68 96 52 12 f0       	push   $0xf0125296
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 ab 52 12 f0       	push   $0xf01252ab
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 e7 52 12 f0       	push   $0xf01252e7
f010512d:	6a 52                	push   $0x52
f010512f:	68 ab 52 12 f0       	push   $0xf01252ab
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105227:	e8 a8 aa 00 00       	call   f010fcd4 <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 47 45 00 00       	call   f010978d <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 2d 45 00 00       	call   f010978d <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 e0 15 6c f0       	push   $0xf06c15e0
f010526b:	e8 eb aa 00 00       	call   f010fd5b <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105284:	e8 64 ac 00 00       	call   f010feed <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 08 53 12 f0       	push   $0xf0125308
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 ab 52 12 f0       	push   $0xf01252ab
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 49 53 12 f0       	push   $0xf0125349
f01052b2:	68 96 52 12 f0       	push   $0xf0125296
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 ab 52 12 f0       	push   $0xf01252ab
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 e0 15 6c f0       	push   $0xf06c15e0
f01052f5:	e8 f3 ab 00 00       	call   f010feed <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 08 53 12 f0       	push   $0xf0125308
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 ab 52 12 f0       	push   $0xf01252ab
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 58 53 12 f0       	push   $0xf0125358
f010532e:	68 96 52 12 f0       	push   $0xf0125296
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 ab 52 12 f0       	push   $0xf01252ab
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 e7 52 12 f0       	push   $0xf01252e7
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 ab 52 12 f0       	push   $0xf01252ab
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105453:	e8 95 aa 00 00       	call   f010feed <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 08 53 12 f0       	push   $0xf0125308
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 ab 52 12 f0       	push   $0xf01252ab
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 49 53 12 f0       	push   $0xf0125349
f0105481:	68 96 52 12 f0       	push   $0xf0125296
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 ab 52 12 f0       	push   $0xf01252ab
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 50 16 6c f0       	push   $0xf06c1650
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 e0 15 6c f0       	push   $0xf06c15e0
f01054c3:	e8 25 aa 00 00       	call   f010feed <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 08 53 12 f0       	push   $0xf0125308
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 ab 52 12 f0       	push   $0xf01252ab
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 84 53 12 f0       	push   $0xf0125384
f01054fc:	68 96 52 12 f0       	push   $0xf0125296
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 ab 52 12 f0       	push   $0xf01252ab
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 e7 52 12 f0       	push   $0xf01252e7
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 ab 52 12 f0       	push   $0xf01252ab
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 54 16 6c f0       	mov    %eax,0xf06c1654
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 50 16 6c f0       	mov    %eax,0xf06c1650
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 5c 16 6c f0       	mov    0xf06c165c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 5c 16 6c f0       	mov    %eax,0xf06c165c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 e0 15 6c f0       	push   $0xf06c15e0
f01055b3:	e8 35 a9 00 00       	call   f010feed <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 08 53 12 f0       	push   $0xf0125308
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 ab 52 12 f0       	push   $0xf01252ab
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 49 53 12 f0       	push   $0xf0125349
f01055e1:	68 96 52 12 f0       	push   $0xf0125296
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 ab 52 12 f0       	push   $0xf01252ab
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 4a a1 00 00       	call   f010f744 <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 bf 76 00 00       	call   f010ccc8 <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 60 16 6c f0       	push   $0xf06c1660
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 e0 15 6c f0       	push   $0xf06c15e0
f010563a:	e8 ae a8 00 00       	call   f010feed <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 08 53 12 f0       	push   $0xf0125308
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 ab 52 12 f0       	push   $0xf01252ab
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 b0 53 12 f0       	push   $0xf01253b0
f0105673:	68 96 52 12 f0       	push   $0xf0125296
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 ab 52 12 f0       	push   $0xf01252ab
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 e7 52 12 f0       	push   $0xf01252e7
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 ab 52 12 f0       	push   $0xf01252ab
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 64 16 6c f0       	mov    %eax,0xf06c1664
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 60 16 6c f0       	mov    %eax,0xf06c1660
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 6c 16 6c f0       	mov    %eax,0xf06c166c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 e0 15 6c f0       	push   $0xf06c15e0
f010572a:	e8 a5 a5 00 00       	call   f010fcd4 <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 db 53 12 f0       	push   $0xf01253db
f010573d:	68 96 52 12 f0       	push   $0xf0125296
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 ab 52 12 f0       	push   $0xf01252ab
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105767:	e8 ef a5 00 00       	call   f010fd5b <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105780:	e8 4f a5 00 00       	call   f010fcd4 <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 e0 15 6c f0       	push   $0xf06c15e0
f01057d7:	e8 7f a5 00 00       	call   f010fd5b <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105804:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 e0 15 6c f0       	push   $0xf06c15e0
f010581e:	e8 38 a5 00 00       	call   f010fd5b <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105837:	e8 b1 a6 00 00       	call   f010feed <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105850:	e8 7f a4 00 00       	call   f010fcd4 <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f01058b6:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 e7 52 12 f0       	push   $0xf01252e7
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 ab 52 12 f0       	push   $0xf01252ab
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 0b 60 00 00       	call   f010ba46 <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 e3 53 12 f0       	push   $0xf01253e3
f0105a49:	68 96 52 12 f0       	push   $0xf0125296
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 ab 52 12 f0       	push   $0xf01252ab
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 28 61 00 00       	call   f010bbc7 <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105aad:	e8 a9 a2 00 00       	call   f010fd5b <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105ac6:	e8 09 a2 00 00       	call   f010fcd4 <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 f4 53 12 f0       	push   $0xf01253f4
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105b4c:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 1c 54 12 f0       	push   $0xf012541c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 e7 52 12 f0       	push   $0xf01252e7
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 ab 52 12 f0       	push   $0xf01252ab
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 48 54 12 f0       	push   $0xf0125448
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0105d65:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105d7c:	e8 da 9f 00 00       	call   f010fd5b <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 69 5c 00 00       	call   f010b9fe <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 6e 54 12 f0       	push   $0xf012546e
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 94 5c 00 00       	call   f010ba46 <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 e3 53 12 f0       	push   $0xf01253e3
f0105dc0:	68 96 52 12 f0       	push   $0xf0125296
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 ab 52 12 f0       	push   $0xf01252ab
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 74 54 12 f0       	push   $0xf0125474
f0105df5:	68 96 52 12 f0       	push   $0xf0125296
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 ab 52 12 f0       	push   $0xf01252ab
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 98 54 12 f0       	push   $0xf0125498
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 cc 5b 00 00       	call   f010b9fe <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 6e 54 12 f0       	push   $0xf012546e
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 76 5d 00 00       	call   f010bbc7 <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105e62:	e8 6d 9e 00 00       	call   f010fcd4 <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 c4 54 12 f0       	push   $0xf01254c4
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 e6 54 12 f0       	push   $0xf01254e6
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105ecb:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 f0 54 12 f0       	push   $0xf01254f0
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 0c 55 12 f0       	push   $0xf012550c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 40 55 12 f0       	push   $0xf0125540
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 e6 54 12 f0       	push   $0xf01254e6
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 68 55 12 f0       	push   $0xf0125568
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 0c 55 12 f0       	push   $0xf012550c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 8c 55 12 f0       	push   $0xf012558c
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 e6 54 12 f0       	push   $0xf01254e6
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0106041:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 ae 55 12 f0       	push   $0xf01255ae
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 e0 15 6c f0       	push   $0xf06c15e0
f010606a:	e8 ec 9c 00 00       	call   f010fd5b <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106083:	e8 4c 9c 00 00       	call   f010fcd4 <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 5c 16 6c f0       	mov    0xf06c165c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 50 16 6c f0       	push   $0xf06c1650
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 e0 15 6c f0       	push   $0xf06c15e0
f01060d7:	e8 7f 9c 00 00       	call   f010fd5b <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 cc 55 12 f0       	push   $0xf01255cc
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 ab 52 12 f0       	push   $0xf01252ab
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106118:	e8 b7 9b 00 00       	call   f010fcd4 <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 08 56 12 f0       	push   $0xf0125608
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 34 56 12 f0       	push   $0xf0125634
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 80 58 00 00       	call   f010b9fe <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 6e 54 12 f0       	push   $0xf012546e
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f01061b1:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 47 56 12 f0       	push   $0xf0125647
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 0c 55 12 f0       	push   $0xf012550c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 64 56 12 f0       	push   $0xf0125664
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 34 56 12 f0       	push   $0xf0125634
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 e7 52 12 f0       	push   $0xf01252e7
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 ab 52 12 f0       	push   $0xf01252ab
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 00 57 00 00       	call   f010b9fe <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 6e 54 12 f0       	push   $0xf012546e
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 68 55 12 f0       	push   $0xf0125568
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 0c 55 12 f0       	push   $0xf012550c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 98 56 12 f0       	push   $0xf0125698
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 34 56 12 f0       	push   $0xf0125634
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 0b 56 00 00       	call   f010b9fe <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 6e 54 12 f0       	push   $0xf012546e
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0106426:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 ae 55 12 f0       	push   $0xf01255ae
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 fa 55 00 00       	call   f010ba46 <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 74 54 12 f0       	push   $0xf0125474
f010646b:	68 96 52 12 f0       	push   $0xf0125296
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 ab 52 12 f0       	push   $0xf01252ab
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 98 54 12 f0       	push   $0xf0125498
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 56 55 00 00       	call   f010b9fe <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 6e 54 12 f0       	push   $0xf012546e
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 07 57 00 00       	call   f010bbc7 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 e0 15 6c f0       	push   $0xf06c15e0
f01064c8:	e8 8e 98 00 00       	call   f010fd5b <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 e0 15 6c f0       	push   $0xf06c15e0
f01064e3:	e8 ec 97 00 00       	call   f010fcd4 <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 e7 52 12 f0       	push   $0xf01252e7
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 ab 52 12 f0       	push   $0xf01252ab
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 e0 15 6c f0       	push   $0xf06c15e0
f010664e:	e8 08 97 00 00       	call   f010fd5b <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 88 1c 6c f0       	mov    0xf06c1c88,%eax
f0106661:	8b 15 8c 1c 6c f0    	mov    0xf06c1c8c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 c4 56 12 f0       	push   $0xf01256c4
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 ab 52 12 f0       	push   $0xf01252ab
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 c4 56 12 f0       	push   $0xf01256c4
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 ab 52 12 f0       	push   $0xf01252ab
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 c4 56 12 f0       	push   $0xf01256c4
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 ab 52 12 f0       	push   $0xf01252ab
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 c4 56 12 f0       	push   $0xf01256c4
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 ab 52 12 f0       	push   $0xf01252ab
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 b8 17 6c f0 00 	movl   $0x0,0xf06c17b8
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 50 16 6c f0       	push   $0xf06c1650
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 60 16 6c f0       	push   $0xf06c1660
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 d8 56 12 f0       	push   $0xf01256d8
f0106781:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106786:	e8 18 95 00 00       	call   f010fca3 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 ec 56 12 f0       	push   $0xf01256ec
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 22 57 12 f0       	push   $0xf0125722
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 67 86 01 00       	call   f011ee3e <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 e0 15 6c f0       	push   $0xf06c15e0
f01067fb:	e8 d4 94 00 00       	call   f010fcd4 <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f0106808:	8b 04 85 4c f9 17 f0 	mov    -0xfe806b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 2d 52 00 00       	call   f010ba46 <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 48 52 00 00       	call   f010ba6f <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 0f 86 01 00       	call   f011ee44 <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 2c 52 00 00       	call   f010ba6f <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 14 52 00 00       	call   f010ba6f <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 81 54 00 00       	call   f010bcea <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 34 57 12 f0       	push   $0xf0125734
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 22 57 12 f0       	push   $0xf0125722
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 88 51 00 00       	call   f010ba46 <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 6b 57 12 f0       	push   $0xf012576b
f01068d2:	68 85 57 12 f0       	push   $0xf0125785
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 22 57 12 f0       	push   $0xf0125722
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 9a 57 12 f0       	push   $0xf012579a
f01068fd:	68 85 57 12 f0       	push   $0xf0125785
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 22 57 12 f0       	push   $0xf0125722
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 ba 53 00 00       	call   f010bcd3 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 4c 51 00 00       	call   f010ba6f <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106990:	e8 c6 93 00 00       	call   f010fd5b <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 44 2d 6c f0 01 	movb   $0x1,0xf06c2d44
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 45 2b 00 00       	call   f010950e <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 70 16 6c f0       	mov    %eax,0xf06c1670
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 2c 2b 00 00       	call   f010950e <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 a4 19 6c f0       	mov    %eax,0xf06c19a4
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 b0 57 12 f0       	push   $0xf01257b0
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 d4 1a 6c f0 00 	movl   $0x0,0xf06c1ad4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 d8 57 12 f0       	push   $0xf01257d8
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 22 57 12 f0       	push   $0xf0125722
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 d8 57 12 f0       	push   $0xf01257d8
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 22 57 12 f0       	push   $0xf0125722
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106ab4:	e8 34 94 00 00       	call   f010feed <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 ec 57 12 f0       	push   $0xf01257ec
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 22 57 12 f0       	push   $0xf0125722
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 63 4f 00 00       	call   f010ba46 <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106b3d:	e8 ab 93 00 00       	call   f010feed <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 38 58 12 f0       	push   $0xf0125838
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 22 57 12 f0       	push   $0xf0125722
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 d8 57 12 f0       	push   $0xf01257d8
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 22 57 12 f0       	push   $0xf0125722
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106b85:	e8 63 93 00 00       	call   f010feed <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 88 58 12 f0       	push   $0xf0125888
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 22 57 12 f0       	push   $0xf0125722
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 d8 57 12 f0       	push   $0xf01257d8
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 22 57 12 f0       	push   $0xf0125722
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 d8 57 12 f0       	push   $0xf01257d8
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 22 57 12 f0       	push   $0xf0125722
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 88 1c 6c f0       	mov    0xf06c1c88,%eax
f0106bea:	8b 15 8c 1c 6c f0    	mov    0xf06c1c8c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 88 1c 6c f0       	mov    %eax,0xf06c1c88
f0106bfb:	89 15 8c 1c 6c f0    	mov    %edx,0xf06c1c8c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 40 4e 00 00       	call   f010ba46 <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 53 8a 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 29 4f 00 00       	call   f010bb68 <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 f8 4d 00 00       	call   f010ba46 <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 c7 30 00 00       	call   f0109d4a <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 c4 2f 00 00       	call   f0109c86 <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 9a 30 00 00       	call   f0109e26 <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 80 30 00 00       	call   f0109e4a <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 ec 8a 69 f0 01 	movl   $0x1,0xf0698aec
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 c0 17 6c f0       	mov    $0xf06c17c0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 81 5f 00 00       	call   f010d116 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 c8 8c 01 00       	call   f011fe70 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 d5 58 12 f0       	push   $0xf01258d5
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 ec 58 12 f0       	push   $0xf01258ec
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 fb 58 12 f0       	push   $0xf01258fb
f010727e:	6a 61                	push   $0x61
f0107280:	68 ec 58 12 f0       	push   $0xf01258ec
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 a0 2c 6c f0       	mov    %eax,0xf06c2ca0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 04 59 12 f0       	push   $0xf0125904
f0107662:	6a 57                	push   $0x57
f0107664:	68 38 59 12 f0       	push   $0xf0125938
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 e4 2d 6c f0       	mov    %eax,0xf06c2de4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 04 59 12 f0       	push   $0xf0125904
f0107693:	6a 63                	push   $0x63
f0107695:	68 38 59 12 f0       	push   $0xf0125938
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 99 25 00 00       	call   f0109c86 <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 78 18 6c f0    	mov    0xf06c1878,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 e0 1a 6c f0       	mov    %eax,0xf06c1ae0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 a0 13 6c f0       	mov    %eax,0xf06c13a0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 3e 6a 01 00       	call   f011e1e0 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 58 59 12 f0       	push   $0xf0125958
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 f0 8a 69 f0       	mov    %eax,0xf0698af0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 f0 8a 69 f0       	mov    0xf0698af0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 04 59 12 f0       	push   $0xf0125904
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 38 59 12 f0       	push   $0xf0125938
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 a0 2c 6c f0    	mov    0xf06c2ca0,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 42 79 01 00       	call   f011f1b3 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 b0 17 6c f0 19 	movl   $0x19,0xf06c17b0
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 98 1c 6c f0 d0 	movl   $0xf0b0d7d0,0xf06c1c98
f0107899:	d7 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 98 1c 6c f0       	mov    %eax,0xf06c1c98

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 98 1c 6c f0    	mov    0xf06c1c98,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 98 1c 6c f0       	mov    %eax,0xf06c1c98

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 81 85 01 00       	call   f011fe70 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 80 59 12 f0       	push   $0xf0125980
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 38 59 12 f0       	push   $0xf0125938
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 04 59 12 f0       	push   $0xf0125904
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 38 59 12 f0       	push   $0xf0125938
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 78 18 6c f0       	mov    %eax,0xf06c1878

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 b0 59 12 f0       	push   $0xf01259b0
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 d3 59 12 f0       	push   $0xf01259d3
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 04 59 12 f0       	push   $0xf0125904
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 38 59 12 f0       	push   $0xf0125938
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 04 59 12 f0       	push   $0xf0125904
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 38 59 12 f0       	push   $0xf0125938
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 f0 59 12 f0       	push   $0xf01259f0
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 15 5a 12 f0       	push   $0xf0125a15
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 80 16 6c f0 00 	movl   $0x0,0xf06c1680
f0107ddc:	00 00 00 
f0107ddf:	c7 05 84 16 6c f0 00 	movl   $0x0,0xf06c1684
f0107de6:	00 00 00 
f0107de9:	c7 05 8c 16 6c f0 00 	movl   $0x0,0xf06c168c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 90 16 6c f0 00 	movl   $0x0,0xf06c1690
f0107dfa:	00 00 00 
f0107dfd:	c7 05 94 16 6c f0 00 	movl   $0x0,0xf06c1694
f0107e04:	00 00 00 
f0107e07:	c7 05 9c 16 6c f0 00 	movl   $0x0,0xf06c169c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 2f 5a 12 f0       	push   $0xf0125a2f
f0107e19:	68 a0 16 6c f0       	push   $0xf06c16a0
f0107e1e:	e8 80 7e 00 00       	call   f010fca3 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 7c 1b 6c f0 00 	movl   $0xf0001000,0xf06c1b7c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 4c 2d 6c f0 00 	movl   $0xf0002000,0xf06c2d4c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 7c 1b 6c f0    	mov    0xf06c1b7c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 40 5a 12 f0       	push   $0xf0125a40
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 63 5a 12 f0       	push   $0xf0125a63
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0107f37:	8b 1d e0 1a 6c f0    	mov    0xf06c1ae0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f0107f69:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0107f82:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 80 5a 12 f0       	push   $0xf0125a80
f0108012:	6a 68                	push   $0x68
f0108014:	68 63 5a 12 f0       	push   $0xf0125a63
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 40 5a 12 f0       	push   $0xf0125a40
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 63 5a 12 f0       	push   $0xf0125a63
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0108108:	8b 1d e0 1a 6c f0    	mov    0xf06c1ae0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f010813a:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0108153:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 c4 7c 01 00       	call   f011fe70 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 a0 16 6c f0       	push   $0xf06c16a0
f01081c0:	e8 28 7d 00 00       	call   f010feed <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 a0 16 6c f0       	push   $0xf06c16a0
f01081d9:	e8 f6 7a 00 00       	call   f010fcd4 <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 b4 5a 12 f0       	push   $0xf0125ab4
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 63 5a 12 f0       	push   $0xf0125a63
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 01 5b 12 f0       	push   $0xf0125b01
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 63 5a 12 f0       	push   $0xf0125a63
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 be 1a 00 00       	call   f0109d93 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 a0 16 6c f0       	push   $0xf06c16a0
f01082f7:	e8 5f 7a 00 00       	call   f010fd5b <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108314:	e8 d4 7b 00 00       	call   f010feed <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 a0 16 6c f0       	push   $0xf06c16a0
f010832d:	e8 a2 79 00 00       	call   f010fcd4 <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 40 5a 12 f0       	push   $0xf0125a40
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 63 5a 12 f0       	push   $0xf0125a63
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 80 16 6c f0       	mov    0xf06c1680,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 a0 16 6c f0       	push   $0xf06c16a0
f01083b4:	e8 a2 79 00 00       	call   f010fd5b <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 bf 14 00 00       	call   f01098ef <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 20 5b 12 f0       	push   $0xf0125b20
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 63 5a 12 f0       	push   $0xf0125a63
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 bc 72 00 00       	call   f010f766 <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 11 14 00 00       	call   f01098ef <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 20 5b 12 f0       	push   $0xf0125b20
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 63 5a 12 f0       	push   $0xf0125a63
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 b5 0f 00 00       	call   f010950e <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 4f 5b 12 f0       	push   $0xf0125b4f
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 63 5a 12 f0       	push   $0xf0125a63
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 f7 12 00 00       	call   f0109892 <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 bb 78 01 00       	call   f011fe70 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 20 5b 12 f0       	push   $0xf0125b20
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 63 5a 12 f0       	push   $0xf0125a63
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 03 78 01 00       	call   f011fe70 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 6c 5b 12 f0       	push   $0xf0125b6c
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 27 10 00 00       	call   f01098ef <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 20 5b 12 f0       	push   $0xf0125b20
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 63 5a 12 f0       	push   $0xf0125a63
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108987:	e8 61 75 00 00       	call   f010feed <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 a0 16 6c f0       	push   $0xf06c16a0
f01089a0:	e8 2f 73 00 00       	call   f010fcd4 <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 80 16 6c f0       	mov    0xf06c1680,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 88 16 6c f0       	mov    0xf06c1688,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 88 16 6c f0       	mov    %eax,0xf06c1688
f01089e3:	a1 88 16 6c f0       	mov    0xf06c1688,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 9c 16 6c f0       	mov    0xf06c169c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108a08:	e8 4e 73 00 00       	call   f010fd5b <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 40 15 6c f0 00 	movl   $0x0,0xf06c1540
f0108a51:	00 00 00 
f0108a54:	c7 05 44 15 6c f0 00 	movl   $0x0,0xf06c1544
f0108a5b:	00 00 00 
f0108a5e:	c7 05 4c 15 6c f0 00 	movl   $0x0,0xf06c154c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 9c 5b 12 f0       	push   $0xf0125b9c
f0108a70:	68 50 15 6c f0       	push   $0xf06c1550
f0108a75:	e8 29 72 00 00       	call   f010fca3 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 4b 01 00 00       	call   f0108bdf <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 8c 16 6c f0    	mov    0xf06c168c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 36 0a 00 00       	call   f010950e <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 71 73 01 00       	call   f011fe70 <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 60                	push   $0x60
f0108b41:	e8 c8 09 00 00       	call   f010950e <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108b4c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b50:	75 0a                	jne    f0108b5c <create_share+0x55>
f0108b52:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b57:	e9 81 00 00 00       	jmp    f0108bdd <create_share+0xd6>
	created_share->references=1;
f0108b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b5f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b69:	01 c0                	add    %eax,%eax
f0108b6b:	d1 f8                	sar    %eax
f0108b6d:	89 c2                	mov    %eax,%edx
f0108b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b72:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b77:	83 ec 0c             	sub    $0xc,%esp
f0108b7a:	50                   	push   %eax
f0108b7b:	e8 2f ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b80:	83 c4 10             	add    $0x10,%esp
f0108b83:	89 c2                	mov    %eax,%edx
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8e:	8b 40 54             	mov    0x54(%eax),%eax
f0108b91:	85 c0                	test   %eax,%eax
f0108b93:	75 15                	jne    f0108baa <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108b95:	83 ec 0c             	sub    $0xc,%esp
f0108b98:	ff 75 e8             	pushl  -0x18(%ebp)
f0108b9b:	e8 ed 0b 00 00       	call   f010978d <kfree>
f0108ba0:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ba8:	eb 33                	jmp    f0108bdd <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8b 55 08             	mov    0x8(%ebp),%edx
f0108bb0:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108bb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb6:	83 c0 08             	add    $0x8,%eax
f0108bb9:	83 ec 08             	sub    $0x8,%esp
f0108bbc:	ff 75 0c             	pushl  0xc(%ebp)
f0108bbf:	50                   	push   %eax
f0108bc0:	e8 0c 71 01 00       	call   f011fcd1 <strcpy>
f0108bc5:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108bc8:	8b 55 10             	mov    0x10(%ebp),%edx
f0108bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bce:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bd4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bd7:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108bdd:	c9                   	leave  
f0108bde:	c3                   	ret    

f0108bdf <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bdf:	55                   	push   %ebp
f0108be0:	89 e5                	mov    %esp,%ebp
f0108be2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108bec:	83 ec 0c             	sub    $0xc,%esp
f0108bef:	68 50 15 6c f0       	push   $0xf06c1550
f0108bf4:	e8 db 70 00 00       	call   f010fcd4 <acquire_spinlock>
f0108bf9:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bfc:	a1 40 15 6c f0       	mov    0xf06c1540,%eax
f0108c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c04:	eb 41                	jmp    f0108c47 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c09:	8b 40 04             	mov    0x4(%eax),%eax
f0108c0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c0f:	75 2e                	jne    f0108c3f <get_share+0x60>
f0108c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c14:	83 c0 08             	add    $0x8,%eax
f0108c17:	83 ec 08             	sub    $0x8,%esp
f0108c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1d:	50                   	push   %eax
f0108c1e:	e8 6b 71 01 00       	call   f011fd8e <strcmp>
f0108c23:	83 c4 10             	add    $0x10,%esp
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 15                	jne    f0108c3f <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c2a:	83 ec 0c             	sub    $0xc,%esp
f0108c2d:	68 50 15 6c f0       	push   $0xf06c1550
f0108c32:	e8 24 71 00 00       	call   f010fd5b <release_spinlock>
f0108c37:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3d:	eb 44                	jmp    f0108c83 <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c3f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0108c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c4b:	74 08                	je     f0108c55 <get_share+0x76>
f0108c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c50:	8b 40 58             	mov    0x58(%eax),%eax
f0108c53:	eb 05                	jmp    f0108c5a <get_share+0x7b>
f0108c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c5a:	a3 48 15 6c f0       	mov    %eax,0xf06c1548
f0108c5f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0108c64:	85 c0                	test   %eax,%eax
f0108c66:	75 9e                	jne    f0108c06 <get_share+0x27>
f0108c68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c6c:	75 98                	jne    f0108c06 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c6e:	83 ec 0c             	sub    $0xc,%esp
f0108c71:	68 50 15 6c f0       	push   $0xf06c1550
f0108c76:	e8 e0 70 00 00       	call   f010fd5b <release_spinlock>
f0108c7b:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c83:	c9                   	leave  
f0108c84:	c3                   	ret    

f0108c85 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c85:	55                   	push   %ebp
f0108c86:	89 e5                	mov    %esp,%ebp
f0108c88:	83 ec 48             	sub    $0x48,%esp
f0108c8b:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c91:	e8 b0 2d 00 00       	call   f010ba46 <get_cpu_proc>
f0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c99:	83 ec 08             	sub    $0x8,%esp
f0108c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c9f:	ff 75 08             	pushl  0x8(%ebp)
f0108ca2:	e8 38 ff ff ff       	call   f0108bdf <get_share>
f0108ca7:	83 c4 10             	add    $0x10,%esp
f0108caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108cad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108cb1:	74 0a                	je     f0108cbd <createSharedObject+0x38>
f0108cb3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb8:	e9 7f 01 00 00       	jmp    f0108e3c <createSharedObject+0x1b7>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cbd:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cc1:	50                   	push   %eax
f0108cc2:	ff 75 10             	pushl  0x10(%ebp)
f0108cc5:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc8:	ff 75 08             	pushl  0x8(%ebp)
f0108ccb:	e8 37 fe ff ff       	call   f0108b07 <create_share>
f0108cd0:	83 c4 10             	add    $0x10,%esp
f0108cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108cd6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cda:	75 0a                	jne    f0108ce6 <createSharedObject+0x61>
f0108cdc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108ce1:	e9 56 01 00 00       	jmp    f0108e3c <createSharedObject+0x1b7>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108ce6:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ced:	8b 55 10             	mov    0x10(%ebp),%edx
f0108cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	48                   	dec    %eax
f0108cf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cfc:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d01:	f7 75 e4             	divl   -0x1c(%ebp)
f0108d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d07:	29 d0                	sub    %edx,%eax
f0108d09:	c1 e8 0c             	shr    $0xc,%eax
f0108d0c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int k = 0; k < num_pages; k++)
f0108d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d16:	e9 8b 00 00 00       	jmp    f0108da6 <createSharedObject+0x121>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d1b:	83 ec 0c             	sub    $0xc,%esp
f0108d1e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d21:	50                   	push   %eax
f0108d22:	e8 8b f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d27:	83 c4 10             	add    $0x10,%esp
f0108d2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0108d2d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0108d31:	75 5c                	jne    f0108d8f <createSharedObject+0x10a>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f0108d33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d36:	c1 e0 0c             	shl    $0xc,%eax
f0108d39:	89 c2                	mov    %eax,%edx
f0108d3b:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3e:	01 d0                	add    %edx,%eax
f0108d40:	89 c1                	mov    %eax,%ecx
f0108d42:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d48:	8b 40 64             	mov    0x64(%eax),%eax
f0108d4b:	6a 06                	push   $0x6
f0108d4d:	51                   	push   %ecx
f0108d4e:	52                   	push   %edx
f0108d4f:	50                   	push   %eax
f0108d50:	e8 2a f9 ff ff       	call   f010867f <map_frame>
f0108d55:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d5b:	8b 40 54             	mov    0x54(%eax),%eax
f0108d5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d61:	c1 e2 02             	shl    $0x2,%edx
f0108d64:	01 c2                	add    %eax,%edx
f0108d66:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d69:	89 02                	mov    %eax,(%edx)
			isTableExist[PDX((uint32)((uint32)virtual_address + (k * PAGE_SIZE)))]++;
f0108d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d6e:	c1 e0 0c             	shl    $0xc,%eax
f0108d71:	89 c2                	mov    %eax,%edx
f0108d73:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d76:	01 d0                	add    %edx,%eax
f0108d78:	c1 e8 16             	shr    $0x16,%eax
f0108d7b:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f0108d82:	42                   	inc    %edx
f0108d83:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0108d8a:	ff 45 f4             	incl   -0xc(%ebp)
f0108d8d:	eb 17                	jmp    f0108da6 <createSharedObject+0x121>
			created_share->framesStorage[k] = ptr_frame_info;
			isTableExist[PDX((uint32)((uint32)virtual_address + (k * PAGE_SIZE)))]++;
		}
		else
		{
			panic("No Memory");
f0108d8f:	83 ec 04             	sub    $0x4,%esp
f0108d92:	68 a8 5b 12 f0       	push   $0xf0125ba8
f0108d97:	68 a6 00 00 00       	push   $0xa6
f0108d9c:	68 b4 5b 12 f0       	push   $0xf0125bb4
f0108da1:	e8 93 75 ff ff       	call   f0100339 <_panic>
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0108da6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108da9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108dac:	0f 82 69 ff ff ff    	jb     f0108d1b <createSharedObject+0x96>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108db2:	83 ec 0c             	sub    $0xc,%esp
f0108db5:	68 50 15 6c f0       	push   $0xf06c1550
f0108dba:	e8 15 6f 00 00       	call   f010fcd4 <acquire_spinlock>
f0108dbf:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108dc2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108dc6:	75 17                	jne    f0108ddf <createSharedObject+0x15a>
f0108dc8:	83 ec 04             	sub    $0x4,%esp
f0108dcb:	68 d8 5b 12 f0       	push   $0xf0125bd8
f0108dd0:	68 ab 00 00 00       	push   $0xab
f0108dd5:	68 b4 5b 12 f0       	push   $0xf0125bb4
f0108dda:	e8 5a 75 ff ff       	call   f0100339 <_panic>
f0108ddf:	8b 15 44 15 6c f0    	mov    0xf06c1544,%edx
f0108de5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de8:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108deb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dee:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108df1:	85 c0                	test   %eax,%eax
f0108df3:	74 0d                	je     f0108e02 <createSharedObject+0x17d>
f0108df5:	a1 44 15 6c f0       	mov    0xf06c1544,%eax
f0108dfa:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108dfd:	89 50 58             	mov    %edx,0x58(%eax)
f0108e00:	eb 08                	jmp    f0108e0a <createSharedObject+0x185>
f0108e02:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e05:	a3 40 15 6c f0       	mov    %eax,0xf06c1540
f0108e0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e0d:	a3 44 15 6c f0       	mov    %eax,0xf06c1544
f0108e12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e15:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108e1c:	a1 4c 15 6c f0       	mov    0xf06c154c,%eax
f0108e21:	40                   	inc    %eax
f0108e22:	a3 4c 15 6c f0       	mov    %eax,0xf06c154c
	release_spinlock(&AllShares.shareslock);
f0108e27:	83 ec 0c             	sub    $0xc,%esp
f0108e2a:	68 50 15 6c f0       	push   $0xf06c1550
f0108e2f:	e8 27 6f 00 00       	call   f010fd5b <release_spinlock>
f0108e34:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f0108e37:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e3a:	8b 00                	mov    (%eax),%eax
}
f0108e3c:	c9                   	leave  
f0108e3d:	c3                   	ret    

f0108e3e <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e3e:	55                   	push   %ebp
f0108e3f:	89 e5                	mov    %esp,%ebp
f0108e41:	53                   	push   %ebx
f0108e42:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e45:	e8 fc 2b 00 00       	call   f010ba46 <get_cpu_proc>
f0108e4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e4d:	83 ec 08             	sub    $0x8,%esp
f0108e50:	ff 75 0c             	pushl  0xc(%ebp)
f0108e53:	ff 75 08             	pushl  0x8(%ebp)
f0108e56:	e8 84 fd ff ff       	call   f0108bdf <get_share>
f0108e5b:	83 c4 10             	add    $0x10,%esp
f0108e5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e61:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e65:	75 0a                	jne    f0108e71 <getSharedObject+0x33>
f0108e67:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e6c:	e9 d6 00 00 00       	jmp    f0108f47 <getSharedObject+0x109>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e71:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e7b:	8b 40 48             	mov    0x48(%eax),%eax
f0108e7e:	89 c2                	mov    %eax,%edx
f0108e80:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e83:	01 d0                	add    %edx,%eax
f0108e85:	48                   	dec    %eax
f0108e86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e8c:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e91:	f7 75 e8             	divl   -0x18(%ebp)
f0108e94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e97:	29 d0                	sub    %edx,%eax
f0108e99:	85 c0                	test   %eax,%eax
f0108e9b:	79 05                	jns    f0108ea2 <getSharedObject+0x64>
f0108e9d:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108ea2:	c1 f8 0c             	sar    $0xc,%eax
f0108ea5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108eaf:	eb 63                	jmp    f0108f14 <getSharedObject+0xd6>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f0108eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eb4:	8a 40 50             	mov    0x50(%eax),%al
f0108eb7:	0f b6 c0             	movzbl %al,%eax
f0108eba:	01 c0                	add    %eax,%eax
f0108ebc:	83 c8 04             	or     $0x4,%eax
f0108ebf:	89 c3                	mov    %eax,%ebx
f0108ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ec4:	c1 e0 0c             	shl    $0xc,%eax
f0108ec7:	89 c2                	mov    %eax,%edx
f0108ec9:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ecc:	01 d0                	add    %edx,%eax
f0108ece:	89 c1                	mov    %eax,%ecx
f0108ed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ed3:	8b 40 54             	mov    0x54(%eax),%eax
f0108ed6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ed9:	c1 e2 02             	shl    $0x2,%edx
f0108edc:	01 d0                	add    %edx,%eax
f0108ede:	8b 10                	mov    (%eax),%edx
f0108ee0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ee3:	8b 40 64             	mov    0x64(%eax),%eax
f0108ee6:	53                   	push   %ebx
f0108ee7:	51                   	push   %ecx
f0108ee8:	52                   	push   %edx
f0108ee9:	50                   	push   %eax
f0108eea:	e8 90 f7 ff ff       	call   f010867f <map_frame>
f0108eef:	83 c4 10             	add    $0x10,%esp
		isTableExist[PDX((uint32)((uint32)virtual_address + (i * PAGE_SIZE)))]++;
f0108ef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ef5:	c1 e0 0c             	shl    $0xc,%eax
f0108ef8:	89 c2                	mov    %eax,%edx
f0108efa:	8b 45 10             	mov    0x10(%ebp),%eax
f0108efd:	01 d0                	add    %edx,%eax
f0108eff:	c1 e8 16             	shr    $0x16,%eax
f0108f02:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f0108f09:	42                   	inc    %edx
f0108f0a:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108f11:	ff 45 f4             	incl   -0xc(%ebp)
f0108f14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f17:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108f1a:	72 95                	jb     f0108eb1 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
		isTableExist[PDX((uint32)((uint32)virtual_address + (i * PAGE_SIZE)))]++;
	}
	shared_obj->references++;
f0108f1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f1f:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f22:	8d 50 01             	lea    0x1(%eax),%edx
f0108f25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f28:	89 50 4c             	mov    %edx,0x4c(%eax)
	cprintf("References : %d\n",shared_obj->references);
f0108f2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f2e:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f31:	83 ec 08             	sub    $0x8,%esp
f0108f34:	50                   	push   %eax
f0108f35:	68 fb 5b 12 f0       	push   $0xf0125bfb
f0108f3a:	e8 4c 80 ff ff       	call   f0100f8b <cprintf>
f0108f3f:	83 c4 10             	add    $0x10,%esp
	return shared_obj->ID;
f0108f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f45:	8b 00                	mov    (%eax),%eax
}
f0108f47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108f4a:	c9                   	leave  
f0108f4b:	c3                   	ret    

f0108f4c <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108f4c:	55                   	push   %ebp
f0108f4d:	89 e5                	mov    %esp,%ebp
f0108f4f:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108f52:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f56:	0f 84 ca 00 00 00    	je     f0109026 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f0108f5c:	83 ec 0c             	sub    $0xc,%esp
f0108f5f:	68 50 15 6c f0       	push   $0xf06c1550
f0108f64:	e8 6b 6d 00 00       	call   f010fcd4 <acquire_spinlock>
f0108f69:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f0108f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f70:	75 17                	jne    f0108f89 <free_share+0x3d>
f0108f72:	83 ec 04             	sub    $0x4,%esp
f0108f75:	68 0c 5c 12 f0       	push   $0xf0125c0c
f0108f7a:	68 da 00 00 00       	push   $0xda
f0108f7f:	68 b4 5b 12 f0       	push   $0xf0125bb4
f0108f84:	e8 b0 73 ff ff       	call   f0100339 <_panic>
f0108f89:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f8c:	8b 40 58             	mov    0x58(%eax),%eax
f0108f8f:	85 c0                	test   %eax,%eax
f0108f91:	74 11                	je     f0108fa4 <free_share+0x58>
f0108f93:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f96:	8b 40 58             	mov    0x58(%eax),%eax
f0108f99:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f9c:	8b 52 5c             	mov    0x5c(%edx),%edx
f0108f9f:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108fa2:	eb 0b                	jmp    f0108faf <free_share+0x63>
f0108fa4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fa7:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108faa:	a3 44 15 6c f0       	mov    %eax,0xf06c1544
f0108faf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fb2:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108fb5:	85 c0                	test   %eax,%eax
f0108fb7:	74 11                	je     f0108fca <free_share+0x7e>
f0108fb9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fbc:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108fbf:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fc2:	8b 52 58             	mov    0x58(%edx),%edx
f0108fc5:	89 50 58             	mov    %edx,0x58(%eax)
f0108fc8:	eb 0b                	jmp    f0108fd5 <free_share+0x89>
f0108fca:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fcd:	8b 40 58             	mov    0x58(%eax),%eax
f0108fd0:	a3 40 15 6c f0       	mov    %eax,0xf06c1540
f0108fd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fd8:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108fdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fe2:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f0108fe9:	a1 4c 15 6c f0       	mov    0xf06c154c,%eax
f0108fee:	48                   	dec    %eax
f0108fef:	a3 4c 15 6c f0       	mov    %eax,0xf06c154c
    release_spinlock(&AllShares.shareslock);
f0108ff4:	83 ec 0c             	sub    $0xc,%esp
f0108ff7:	68 50 15 6c f0       	push   $0xf06c1550
f0108ffc:	e8 5a 6d 00 00       	call   f010fd5b <release_spinlock>
f0109001:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f0109004:	8b 45 08             	mov    0x8(%ebp),%eax
f0109007:	8b 40 54             	mov    0x54(%eax),%eax
f010900a:	83 ec 0c             	sub    $0xc,%esp
f010900d:	50                   	push   %eax
f010900e:	e8 7a 07 00 00       	call   f010978d <kfree>
f0109013:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f0109016:	83 ec 0c             	sub    $0xc,%esp
f0109019:	ff 75 08             	pushl  0x8(%ebp)
f010901c:	e8 6c 07 00 00       	call   f010978d <kfree>
f0109021:	83 c4 10             	add    $0x10,%esp
f0109024:	eb 01                	jmp    f0109027 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0109026:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f0109027:	c9                   	leave  
f0109028:	c3                   	ret    

f0109029 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f0109029:	55                   	push   %ebp
f010902a:	89 e5                	mov    %esp,%ebp
f010902c:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f010902f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0109036:	83 ec 0c             	sub    $0xc,%esp
f0109039:	68 50 15 6c f0       	push   $0xf06c1550
f010903e:	e8 91 6c 00 00       	call   f010fcd4 <acquire_spinlock>
f0109043:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109046:	a1 40 15 6c f0       	mov    0xf06c1540,%eax
f010904b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010904e:	eb 27                	jmp    f0109077 <get_Share_id+0x4e>
            if(founded->ID == sharedObjectID)
f0109050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109053:	8b 00                	mov    (%eax),%eax
f0109055:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109058:	75 15                	jne    f010906f <get_Share_id+0x46>
            {
                release_spinlock(&AllShares.shareslock);
f010905a:	83 ec 0c             	sub    $0xc,%esp
f010905d:	68 50 15 6c f0       	push   $0xf06c1550
f0109062:	e8 f4 6c 00 00       	call   f010fd5b <release_spinlock>
f0109067:	83 c4 10             	add    $0x10,%esp
                return founded;
f010906a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010906d:	eb 44                	jmp    f01090b3 <get_Share_id+0x8a>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010906f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0109074:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109077:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010907b:	74 08                	je     f0109085 <get_Share_id+0x5c>
f010907d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109080:	8b 40 58             	mov    0x58(%eax),%eax
f0109083:	eb 05                	jmp    f010908a <get_Share_id+0x61>
f0109085:	b8 00 00 00 00       	mov    $0x0,%eax
f010908a:	a3 48 15 6c f0       	mov    %eax,0xf06c1548
f010908f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0109094:	85 c0                	test   %eax,%eax
f0109096:	75 b8                	jne    f0109050 <get_Share_id+0x27>
f0109098:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010909c:	75 b2                	jne    f0109050 <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f010909e:	83 ec 0c             	sub    $0xc,%esp
f01090a1:	68 50 15 6c f0       	push   $0xf06c1550
f01090a6:	e8 b0 6c 00 00       	call   f010fd5b <release_spinlock>
f01090ab:	83 c4 10             	add    $0x10,%esp
        return NULL;
f01090ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01090b3:	c9                   	leave  
f01090b4:	c3                   	ret    

f01090b5 <freeSharedObject>:
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f01090b5:	55                   	push   %ebp
f01090b6:	89 e5                	mov    %esp,%ebp
f01090b8:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
    //panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
		struct Env* myenv = get_cpu_proc();
f01090bb:	e8 86 29 00 00       	call   f010ba46 <get_cpu_proc>
f01090c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f01090c3:	83 ec 08             	sub    $0x8,%esp
f01090c6:	ff 75 0c             	pushl  0xc(%ebp)
f01090c9:	ff 75 08             	pushl  0x8(%ebp)
f01090cc:	e8 58 ff ff ff       	call   f0109029 <get_Share_id>
f01090d1:	83 c4 10             	add    $0x10,%esp
f01090d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        cprintf("Share : %x \n",ptr_share);
f01090d7:	83 ec 08             	sub    $0x8,%esp
f01090da:	ff 75 ec             	pushl  -0x14(%ebp)
f01090dd:	68 2a 5c 12 f0       	push   $0xf0125c2a
f01090e2:	e8 a4 7e ff ff       	call   f0100f8b <cprintf>
f01090e7:	83 c4 10             	add    $0x10,%esp
        if(ptr_share == NULL) return -1;
f01090ea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01090ee:	75 0a                	jne    f01090fa <freeSharedObject+0x45>
f01090f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01090f5:	e9 53 01 00 00       	jmp    f010924d <freeSharedObject+0x198>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01090fa:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0109101:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109104:	8b 40 48             	mov    0x48(%eax),%eax
f0109107:	89 c2                	mov    %eax,%edx
f0109109:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010910c:	01 d0                	add    %edx,%eax
f010910e:	48                   	dec    %eax
f010910f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109112:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109115:	ba 00 00 00 00       	mov    $0x0,%edx
f010911a:	f7 75 e8             	divl   -0x18(%ebp)
f010911d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109120:	29 d0                	sub    %edx,%eax
f0109122:	85 c0                	test   %eax,%eax
f0109124:	79 05                	jns    f010912b <freeSharedObject+0x76>
f0109126:	05 ff 0f 00 00       	add    $0xfff,%eax
f010912b:	c1 f8 0c             	sar    $0xc,%eax
f010912e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        uint32* ptr_page_table;
        for(int k = 0;k<no_of_pages;k++)
f0109131:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109138:	e9 b5 00 00 00       	jmp    f01091f2 <freeSharedObject+0x13d>
		{
			unmap_frame(myenv->env_page_directory, (uint32)startVA + k*PAGE_SIZE);
f010913d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109140:	c1 e0 0c             	shl    $0xc,%eax
f0109143:	89 c2                	mov    %eax,%edx
f0109145:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109148:	01 c2                	add    %eax,%edx
f010914a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010914d:	8b 40 64             	mov    0x64(%eax),%eax
f0109150:	83 ec 08             	sub    $0x8,%esp
f0109153:	52                   	push   %edx
f0109154:	50                   	push   %eax
f0109155:	e8 85 f6 ff ff       	call   f01087df <unmap_frame>
f010915a:	83 c4 10             	add    $0x10,%esp
			int ret = get_page_table(myenv->env_page_directory, (uint32)startVA+ k*PAGE_SIZE, &ptr_page_table);
f010915d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109160:	c1 e0 0c             	shl    $0xc,%eax
f0109163:	89 c2                	mov    %eax,%edx
f0109165:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109168:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010916b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010916e:	8b 40 64             	mov    0x64(%eax),%eax
f0109171:	83 ec 04             	sub    $0x4,%esp
f0109174:	8d 55 d4             	lea    -0x2c(%ebp),%edx
f0109177:	52                   	push   %edx
f0109178:	51                   	push   %ecx
f0109179:	50                   	push   %eax
f010917a:	e8 70 f2 ff ff       	call   f01083ef <get_page_table>
f010917f:	83 c4 10             	add    $0x10,%esp
f0109182:	89 45 dc             	mov    %eax,-0x24(%ebp)
			isTableExist[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))]--;
f0109185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109188:	c1 e0 0c             	shl    $0xc,%eax
f010918b:	89 c2                	mov    %eax,%edx
f010918d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109190:	01 d0                	add    %edx,%eax
f0109192:	c1 e8 16             	shr    $0x16,%eax
f0109195:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f010919c:	4a                   	dec    %edx
f010919d:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
			//cprintf("Page Index : %d\n",isTableExist[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))]);
			if(isTableExist[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] <= 0)
f01091a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091a7:	c1 e0 0c             	shl    $0xc,%eax
f01091aa:	89 c2                	mov    %eax,%edx
f01091ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091af:	01 d0                	add    %edx,%eax
f01091b1:	c1 e8 16             	shr    $0x16,%eax
f01091b4:	8b 04 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%eax
f01091bb:	85 c0                	test   %eax,%eax
f01091bd:	75 30                	jne    f01091ef <freeSharedObject+0x13a>
			{
				kfree((void*)ptr_page_table);
f01091bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01091c2:	83 ec 0c             	sub    $0xc,%esp
f01091c5:	50                   	push   %eax
f01091c6:	e8 c2 05 00 00       	call   f010978d <kfree>
f01091cb:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
f01091ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091d1:	8b 40 64             	mov    0x64(%eax),%eax
f01091d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01091d7:	c1 e2 0c             	shl    $0xc,%edx
f01091da:	89 d1                	mov    %edx,%ecx
f01091dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01091df:	01 ca                	add    %ecx,%edx
f01091e1:	c1 ea 16             	shr    $0x16,%edx
f01091e4:	c1 e2 02             	shl    $0x2,%edx
f01091e7:	01 d0                	add    %edx,%eax
f01091e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
        cprintf("Share : %x \n",ptr_share);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        uint32* ptr_page_table;
        for(int k = 0;k<no_of_pages;k++)
f01091ef:	ff 45 f4             	incl   -0xc(%ebp)
f01091f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091f5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01091f8:	0f 82 3f ff ff ff    	jb     f010913d <freeSharedObject+0x88>
				kfree((void*)ptr_page_table);
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
			}
		}

        ptr_share->references--;
f01091fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109201:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109204:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109207:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010920a:	89 50 4c             	mov    %edx,0x4c(%eax)

        if(ptr_share->references < 1){
f010920d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109210:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109213:	85 c0                	test   %eax,%eax
f0109215:	75 0e                	jne    f0109225 <freeSharedObject+0x170>
            free_share(ptr_share);
f0109217:	83 ec 0c             	sub    $0xc,%esp
f010921a:	ff 75 ec             	pushl  -0x14(%ebp)
f010921d:	e8 2a fd ff ff       	call   f0108f4c <free_share>
f0109222:	83 c4 10             	add    $0x10,%esp
        }
        cprintf("References2 : %d\n",ptr_share->references);
f0109225:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109228:	8b 40 4c             	mov    0x4c(%eax),%eax
f010922b:	83 ec 08             	sub    $0x8,%esp
f010922e:	50                   	push   %eax
f010922f:	68 37 5c 12 f0       	push   $0xf0125c37
f0109234:	e8 52 7d ff ff       	call   f0100f8b <cprintf>
f0109239:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010923c:	0f 20 d8             	mov    %cr3,%eax
f010923f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109242:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109245:	0f 22 d8             	mov    %eax,%cr3
        tlbflush();
        return 0;
f0109248:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010924d:	c9                   	leave  
f010924e:	c3                   	ret    

f010924f <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010924f:	55                   	push   %ebp
f0109250:	89 e5                	mov    %esp,%ebp
f0109252:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0109257:	83 f8 01             	cmp    $0x1,%eax
f010925a:	75 04                	jne    f0109260 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010925c:	b0 01                	mov    $0x1,%al
f010925e:	eb 02                	jmp    f0109262 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0109260:	b0 00                	mov    $0x0,%al
f0109262:	5d                   	pop    %ebp
f0109263:	c3                   	ret    

f0109264 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0109264:	55                   	push   %ebp
f0109265:	89 e5                	mov    %esp,%ebp
f0109267:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f010926c:	83 f8 02             	cmp    $0x2,%eax
f010926f:	75 04                	jne    f0109275 <isKHeapPlacementStrategyBESTFIT+0x11>
f0109271:	b0 01                	mov    $0x1,%al
f0109273:	eb 02                	jmp    f0109277 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109275:	b0 00                	mov    $0x0,%al
f0109277:	5d                   	pop    %ebp
f0109278:	c3                   	ret    

f0109279 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109279:	55                   	push   %ebp
f010927a:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010927c:	8b 45 08             	mov    0x8(%ebp),%eax
f010927f:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0109285:	29 d0                	sub    %edx,%eax
f0109287:	c1 f8 03             	sar    $0x3,%eax
f010928a:	89 c2                	mov    %eax,%edx
f010928c:	89 d0                	mov    %edx,%eax
f010928e:	c1 e0 02             	shl    $0x2,%eax
f0109291:	01 d0                	add    %edx,%eax
f0109293:	c1 e0 02             	shl    $0x2,%eax
f0109296:	01 d0                	add    %edx,%eax
f0109298:	c1 e0 02             	shl    $0x2,%eax
f010929b:	01 d0                	add    %edx,%eax
f010929d:	89 c1                	mov    %eax,%ecx
f010929f:	c1 e1 08             	shl    $0x8,%ecx
f01092a2:	01 c8                	add    %ecx,%eax
f01092a4:	89 c1                	mov    %eax,%ecx
f01092a6:	c1 e1 10             	shl    $0x10,%ecx
f01092a9:	01 c8                	add    %ecx,%eax
f01092ab:	01 c0                	add    %eax,%eax
f01092ad:	01 d0                	add    %edx,%eax
}
f01092af:	5d                   	pop    %ebp
f01092b0:	c3                   	ret    

f01092b1 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01092b1:	55                   	push   %ebp
f01092b2:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01092b4:	ff 75 08             	pushl  0x8(%ebp)
f01092b7:	e8 bd ff ff ff       	call   f0109279 <to_frame_number>
f01092bc:	83 c4 04             	add    $0x4,%esp
f01092bf:	c1 e0 0c             	shl    $0xc,%eax
}
f01092c2:	c9                   	leave  
f01092c3:	c3                   	ret    

f01092c4 <initialize_kheap_dynamic_allocator>:

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];

int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f01092c4:	55                   	push   %ebp
f01092c5:	89 e5                	mov    %esp,%ebp
f01092c7:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f01092ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01092cd:	a3 48 2d 6c f0       	mov    %eax,0xf06c2d48
	hard_limit = daLimit;
f01092d2:	8b 45 10             	mov    0x10(%ebp),%eax
f01092d5:	a3 74 1b 6c f0       	mov    %eax,0xf06c1b74
	brk = daStart + initSizeToAllocate;
f01092da:	8b 55 08             	mov    0x8(%ebp),%edx
f01092dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092e0:	01 d0                	add    %edx,%eax
f01092e2:	a3 40 2d 6c f0       	mov    %eax,0xf06c2d40

	if(brk > daLimit) panic("exceeds Limit");
f01092e7:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f01092ec:	3b 45 10             	cmp    0x10(%ebp),%eax
f01092ef:	76 14                	jbe    f0109305 <initialize_kheap_dynamic_allocator+0x41>
f01092f1:	83 ec 04             	sub    $0x4,%esp
f01092f4:	68 4c 5c 12 f0       	push   $0xf0125c4c
f01092f9:	6a 1b                	push   $0x1b
f01092fb:	68 5a 5c 12 f0       	push   $0xf0125c5a
f0109300:	e8 34 70 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0109305:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f010930c:	8b 45 10             	mov    0x10(%ebp),%eax
f010930f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f0109312:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109315:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0109318:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010931b:	c1 e8 0c             	shr    $0xc,%eax
f010931e:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f0109321:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109328:	e9 8a 00 00 00       	jmp    f01093b7 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f010932d:	83 ec 0c             	sub    $0xc,%esp
f0109330:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0109333:	50                   	push   %eax
f0109334:	e8 79 ee ff ff       	call   f01081b2 <allocate_frame>
f0109339:	83 c4 10             	add    $0x10,%esp
f010933c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f010933f:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0109343:	74 5e                	je     f01093a3 <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0109345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109348:	c1 e0 0c             	shl    $0xc,%eax
f010934b:	89 c2                	mov    %eax,%edx
f010934d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109350:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109353:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109356:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010935b:	6a 02                	push   $0x2
f010935d:	51                   	push   %ecx
f010935e:	52                   	push   %edx
f010935f:	50                   	push   %eax
f0109360:	e8 1a f3 ff ff       	call   f010867f <map_frame>
f0109365:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109368:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010936b:	c1 e0 0c             	shl    $0xc,%eax
f010936e:	89 c2                	mov    %eax,%edx
f0109370:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109373:	01 d0                	add    %edx,%eax
f0109375:	83 ec 0c             	sub    $0xc,%esp
f0109378:	50                   	push   %eax
f0109379:	e8 14 05 00 00       	call   f0109892 <kheap_physical_address>
f010937e:	83 c4 10             	add    $0x10,%esp
f0109381:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109384:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109387:	c1 e8 0c             	shr    $0xc,%eax
f010938a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010938d:	c1 e2 0c             	shl    $0xc,%edx
f0109390:	89 d1                	mov    %edx,%ecx
f0109392:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109395:	01 ca                	add    %ecx,%edx
f0109397:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010939e:	ff 45 f4             	incl   -0xc(%ebp)
f01093a1:	eb 14                	jmp    f01093b7 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f01093a3:	83 ec 04             	sub    $0x4,%esp
f01093a6:	68 6b 5c 12 f0       	push   $0xf0125c6b
f01093ab:	6a 30                	push   $0x30
f01093ad:	68 5a 5c 12 f0       	push   $0xf0125c5a
f01093b2:	e8 82 6f ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f01093b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093ba:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01093bd:	0f 82 6a ff ff ff    	jb     f010932d <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f01093c3:	83 ec 08             	sub    $0x8,%esp
f01093c6:	ff 75 0c             	pushl  0xc(%ebp)
f01093c9:	ff 75 08             	pushl  0x8(%ebp)
f01093cc:	e8 80 74 01 00       	call   f0120851 <initialize_dynamic_allocator>
f01093d1:	83 c4 10             	add    $0x10,%esp

	return 0;
f01093d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01093d9:	c9                   	leave  
f01093da:	c3                   	ret    

f01093db <sbrk>:

void* sbrk(int numOfPages)
{
f01093db:	55                   	push   %ebp
f01093dc:	89 e5                	mov    %esp,%ebp
f01093de:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01093e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01093e5:	0f 8e d6 00 00 00    	jle    f01094c1 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f01093eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01093ee:	c1 e0 0c             	shl    $0xc,%eax
f01093f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01093f4:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f01093f9:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01093fc:	8b 15 40 2d 6c f0    	mov    0xf06c2d40,%edx
f0109402:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109405:	01 c2                	add    %eax,%edx
f0109407:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010940c:	39 c2                	cmp    %eax,%edx
f010940e:	76 0a                	jbe    f010941a <sbrk+0x3f>
f0109410:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109415:	e9 b9 00 00 00       	jmp    f01094d3 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f010941a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109421:	eb 7d                	jmp    f01094a0 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f0109423:	83 ec 0c             	sub    $0xc,%esp
f0109426:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109429:	50                   	push   %eax
f010942a:	e8 83 ed ff ff       	call   f01081b2 <allocate_frame>
f010942f:	83 c4 10             	add    $0x10,%esp
f0109432:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f0109435:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0109439:	74 5e                	je     f0109499 <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f010943b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010943e:	c1 e0 0c             	shl    $0xc,%eax
f0109441:	89 c2                	mov    %eax,%edx
f0109443:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109446:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109449:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010944c:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109451:	6a 02                	push   $0x2
f0109453:	51                   	push   %ecx
f0109454:	52                   	push   %edx
f0109455:	50                   	push   %eax
f0109456:	e8 24 f2 ff ff       	call   f010867f <map_frame>
f010945b:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010945e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109461:	c1 e0 0c             	shl    $0xc,%eax
f0109464:	89 c2                	mov    %eax,%edx
f0109466:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109469:	01 d0                	add    %edx,%eax
f010946b:	83 ec 0c             	sub    $0xc,%esp
f010946e:	50                   	push   %eax
f010946f:	e8 1e 04 00 00       	call   f0109892 <kheap_physical_address>
f0109474:	83 c4 10             	add    $0x10,%esp
f0109477:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f010947a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010947d:	c1 e8 0c             	shr    $0xc,%eax
f0109480:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109483:	c1 e2 0c             	shl    $0xc,%edx
f0109486:	89 d1                	mov    %edx,%ecx
f0109488:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010948b:	01 ca                	add    %ecx,%edx
f010948d:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109494:	ff 45 f4             	incl   -0xc(%ebp)
f0109497:	eb 07                	jmp    f01094a0 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f0109499:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010949e:	eb 33                	jmp    f01094d3 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f01094a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094a3:	3b 45 08             	cmp    0x8(%ebp),%eax
f01094a6:	0f 8c 77 ff ff ff    	jl     f0109423 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f01094ac:	8b 15 40 2d 6c f0    	mov    0xf06c2d40,%edx
f01094b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01094b5:	01 d0                	add    %edx,%eax
f01094b7:	a3 40 2d 6c f0       	mov    %eax,0xf06c2d40
		return (void *)prev_brk;
f01094bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094bf:	eb 12                	jmp    f01094d3 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f01094c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01094c5:	75 07                	jne    f01094ce <sbrk+0xf3>
	{
		return (void *) brk;
f01094c7:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f01094cc:	eb 05                	jmp    f01094d3 <sbrk+0xf8>
	}

	return (void *)-1;
f01094ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f01094d3:	c9                   	leave  
f01094d4:	c3                   	ret    

f01094d5 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f01094d5:	55                   	push   %ebp
f01094d6:	89 e5                	mov    %esp,%ebp
f01094d8:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f01094db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01094e2:	83 ec 04             	sub    $0x4,%esp
f01094e5:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01094e8:	50                   	push   %eax
f01094e9:	ff 75 0c             	pushl  0xc(%ebp)
f01094ec:	ff 75 08             	pushl  0x8(%ebp)
f01094ef:	e8 75 f2 ff ff       	call   f0108769 <get_frame_info>
f01094f4:	83 c4 10             	add    $0x10,%esp
f01094f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01094fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01094fe:	75 07                	jne    f0109507 <isPageAllocated+0x32>
f0109500:	b8 00 00 00 00       	mov    $0x0,%eax
f0109505:	eb 05                	jmp    f010950c <isPageAllocated+0x37>
	return 1;
f0109507:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010950c:	c9                   	leave  
f010950d:	c3                   	ret    

f010950e <kmalloc>:

void *kmalloc(unsigned int size)
{
f010950e:	55                   	push   %ebp
f010950f:	89 e5                	mov    %esp,%ebp
f0109511:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109514:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f010951b:	8b 55 08             	mov    0x8(%ebp),%edx
f010951e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109521:	01 d0                	add    %edx,%eax
f0109523:	48                   	dec    %eax
f0109524:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109527:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010952a:	ba 00 00 00 00       	mov    $0x0,%edx
f010952f:	f7 75 d8             	divl   -0x28(%ebp)
f0109532:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109535:	29 d0                	sub    %edx,%eax
f0109537:	c1 e8 0c             	shr    $0xc,%eax
f010953a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f010953d:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0109544:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f0109549:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010954c:	29 c2                	sub    %eax,%edx
f010954e:	89 d0                	mov    %edx,%eax
f0109550:	48                   	dec    %eax
f0109551:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109554:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109557:	ba 00 00 00 00       	mov    $0x0,%edx
f010955c:	f7 75 cc             	divl   -0x34(%ebp)
f010955f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109562:	29 d0                	sub    %edx,%eax
f0109564:	c1 e8 0c             	shr    $0xc,%eax
f0109567:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f010956a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109571:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109578:	77 42                	ja     f01095bc <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f010957a:	e8 d0 fc ff ff       	call   f010924f <isKHeapPlacementStrategyFIRSTFIT>
f010957f:	84 c0                	test   %al,%al
f0109581:	74 16                	je     f0109599 <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f0109583:	83 ec 0c             	sub    $0xc,%esp
f0109586:	ff 75 08             	pushl  0x8(%ebp)
f0109589:	e8 df 74 01 00       	call   f0120a6d <alloc_block_FF>
f010958e:	83 c4 10             	add    $0x10,%esp
f0109591:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109594:	e9 ef 01 00 00       	jmp    f0109788 <kmalloc+0x27a>
		else if (isKHeapPlacementStrategyBESTFIT())
f0109599:	e8 c6 fc ff ff       	call   f0109264 <isKHeapPlacementStrategyBESTFIT>
f010959e:	84 c0                	test   %al,%al
f01095a0:	0f 84 e2 01 00 00    	je     f0109788 <kmalloc+0x27a>
			ptr = alloc_block_BF(size);
f01095a6:	83 ec 0c             	sub    $0xc,%esp
f01095a9:	ff 75 08             	pushl  0x8(%ebp)
f01095ac:	e8 78 79 01 00       	call   f0120f29 <alloc_block_BF>
f01095b1:	83 c4 10             	add    $0x10,%esp
f01095b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01095b7:	e9 cc 01 00 00       	jmp    f0109788 <kmalloc+0x27a>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f01095bc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01095bf:	48                   	dec    %eax
f01095c0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01095c3:	0f 86 b8 01 00 00    	jbe    f0109781 <kmalloc+0x273>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f01095c9:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01095ce:	05 00 10 00 00       	add    $0x1000,%eax
f01095d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01095d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01095dd:	e9 86 00 00 00       	jmp    f0109668 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01095e2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01095e7:	83 ec 08             	sub    $0x8,%esp
f01095ea:	ff 75 f0             	pushl  -0x10(%ebp)
f01095ed:	50                   	push   %eax
f01095ee:	e8 e2 fe ff ff       	call   f01094d5 <isPageAllocated>
f01095f3:	83 c4 10             	add    $0x10,%esp
f01095f6:	85 c0                	test   %eax,%eax
f01095f8:	75 61                	jne    f010965b <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01095fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095fd:	05 00 10 00 00       	add    $0x1000,%eax
f0109602:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f0109605:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f010960c:	eb 3d                	jmp    f010964b <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f010960e:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f0109615:	76 0a                	jbe    f0109621 <kmalloc+0x113>
f0109617:	b8 00 00 00 00       	mov    $0x0,%eax
f010961c:	e9 6a 01 00 00       	jmp    f010978b <kmalloc+0x27d>
					if (isPageAllocated(ptr_page_directory, j))
f0109621:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109626:	83 ec 08             	sub    $0x8,%esp
f0109629:	ff 75 e8             	pushl  -0x18(%ebp)
f010962c:	50                   	push   %eax
f010962d:	e8 a3 fe ff ff       	call   f01094d5 <isPageAllocated>
f0109632:	83 c4 10             	add    $0x10,%esp
f0109635:	85 c0                	test   %eax,%eax
f0109637:	74 08                	je     f0109641 <kmalloc+0x133>
					{

						i = j;
f0109639:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010963c:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f010963f:	eb 1a                	jmp    f010965b <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f0109641:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109648:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f010964b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010964e:	48                   	dec    %eax
f010964f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109652:	77 ba                	ja     f010960e <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109654:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f010965b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010965f:	75 16                	jne    f0109677 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f0109661:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109668:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010966f:	0f 86 6d ff ff ff    	jbe    f01095e2 <kmalloc+0xd4>
f0109675:	eb 01                	jmp    f0109678 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109677:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109678:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010967c:	75 0a                	jne    f0109688 <kmalloc+0x17a>
f010967e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109683:	e9 03 01 00 00       	jmp    f010978b <kmalloc+0x27d>
		for (int k = 0; k < num_pages; k++)
f0109688:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f010968f:	eb 76                	jmp    f0109707 <kmalloc+0x1f9>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109691:	83 ec 0c             	sub    $0xc,%esp
f0109694:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109697:	50                   	push   %eax
f0109698:	e8 15 eb ff ff       	call   f01081b2 <allocate_frame>
f010969d:	83 c4 10             	add    $0x10,%esp
f01096a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f01096a3:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f01096a7:	74 47                	je     f01096f0 <kmalloc+0x1e2>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f01096a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01096ac:	c1 e0 0c             	shl    $0xc,%eax
f01096af:	89 c2                	mov    %eax,%edx
f01096b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096b4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01096b7:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01096ba:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01096bf:	6a 02                	push   $0x2
f01096c1:	51                   	push   %ecx
f01096c2:	52                   	push   %edx
f01096c3:	50                   	push   %eax
f01096c4:	e8 b6 ef ff ff       	call   f010867f <map_frame>
f01096c9:	83 c4 10             	add    $0x10,%esp
				isTableExist[PDX(i + k * PAGE_SIZE)]++;
f01096cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01096cf:	c1 e0 0c             	shl    $0xc,%eax
f01096d2:	89 c2                	mov    %eax,%edx
f01096d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096d7:	01 d0                	add    %edx,%eax
f01096d9:	c1 e8 16             	shr    $0x16,%eax
f01096dc:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f01096e3:	42                   	inc    %edx
f01096e4:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01096eb:	ff 45 e0             	incl   -0x20(%ebp)
f01096ee:	eb 17                	jmp    f0109707 <kmalloc+0x1f9>
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
				isTableExist[PDX(i + k * PAGE_SIZE)]++;
			}
			else
			{
				panic("No Memory");
f01096f0:	83 ec 04             	sub    $0x4,%esp
f01096f3:	68 6b 5c 12 f0       	push   $0xf0125c6b
f01096f8:	68 b7 00 00 00       	push   $0xb7
f01096fd:	68 5a 5c 12 f0       	push   $0xf0125c5a
f0109702:	e8 32 6c ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f0109707:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010970a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010970d:	72 82                	jb     f0109691 <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f010970f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109712:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f0109715:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010971a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010971d:	29 c2                	sub    %eax,%edx
f010971f:	89 d0                	mov    %edx,%eax
f0109721:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109726:	c1 e8 0c             	shr    $0xc,%eax
f0109729:	89 c2                	mov    %eax,%edx
f010972b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010972e:	89 04 95 e0 12 6e f0 	mov    %eax,-0xf91ed20(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f0109735:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010973c:	eb 39                	jmp    f0109777 <kmalloc+0x269>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f010973e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109741:	c1 e0 0c             	shl    $0xc,%eax
f0109744:	89 c2                	mov    %eax,%edx
f0109746:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109749:	01 d0                	add    %edx,%eax
f010974b:	83 ec 0c             	sub    $0xc,%esp
f010974e:	50                   	push   %eax
f010974f:	e8 3e 01 00 00       	call   f0109892 <kheap_physical_address>
f0109754:	83 c4 10             	add    $0x10,%esp
f0109757:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f010975a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010975d:	c1 e8 0c             	shr    $0xc,%eax
f0109760:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109763:	c1 e2 0c             	shl    $0xc,%edx
f0109766:	89 d1                	mov    %edx,%ecx
f0109768:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010976b:	01 ca                	add    %ecx,%edx
f010976d:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109774:	ff 45 dc             	incl   -0x24(%ebp)
f0109777:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010977a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010977d:	72 bf                	jb     f010973e <kmalloc+0x230>
f010977f:	eb 07                	jmp    f0109788 <kmalloc+0x27a>
		}
	}
	else
	{

		return NULL;
f0109781:	b8 00 00 00 00       	mov    $0x0,%eax
f0109786:	eb 03                	jmp    f010978b <kmalloc+0x27d>
	}
	return ptr;
f0109788:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010978b:	c9                   	leave  
f010978c:	c3                   	ret    

f010978d <kfree>:

void kfree(void *va)
{
f010978d:	55                   	push   %ebp
f010978e:	89 e5                	mov    %esp,%ebp
f0109790:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109793:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f0109798:	05 00 10 00 00       	add    $0x1000,%eax
f010979d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f01097a0:	8b 55 08             	mov    0x8(%ebp),%edx
f01097a3:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01097a8:	39 c2                	cmp    %eax,%edx
f01097aa:	73 13                	jae    f01097bf <kfree+0x32>
        free_block(va);
f01097ac:	83 ec 0c             	sub    $0xc,%esp
f01097af:	ff 75 08             	pushl  0x8(%ebp)
f01097b2:	e8 7a 81 01 00       	call   f0121931 <free_block>
f01097b7:	83 c4 10             	add    $0x10,%esp
			isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f01097ba:	e9 d0 00 00 00       	jmp    f010988f <kfree+0x102>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01097bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01097c2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01097c5:	0f 82 ad 00 00 00    	jb     f0109878 <kfree+0xeb>
f01097cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01097ce:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01097d3:	0f 87 9f 00 00 00    	ja     f0109878 <kfree+0xeb>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f01097d9:	8b 55 08             	mov    0x8(%ebp),%edx
f01097dc:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01097e1:	29 c2                	sub    %eax,%edx
f01097e3:	89 d0                	mov    %edx,%eax
f01097e5:	2d 00 10 00 00       	sub    $0x1000,%eax
f01097ea:	c1 e8 0c             	shr    $0xc,%eax
f01097ed:	8b 04 85 e0 12 6e f0 	mov    -0xf91ed20(,%eax,4),%eax
f01097f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f01097f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01097fe:	eb 6e                	jmp    f010986e <kfree+0xe1>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109803:	c1 e0 0c             	shl    $0xc,%eax
f0109806:	89 c2                	mov    %eax,%edx
f0109808:	8b 45 08             	mov    0x8(%ebp),%eax
f010980b:	01 d0                	add    %edx,%eax
f010980d:	83 ec 0c             	sub    $0xc,%esp
f0109810:	50                   	push   %eax
f0109811:	e8 7c 00 00 00       	call   f0109892 <kheap_physical_address>
f0109816:	83 c4 10             	add    $0x10,%esp
f0109819:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f010981c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010981f:	c1 e8 0c             	shr    $0xc,%eax
f0109822:	c7 04 85 e0 92 70 f0 	movl   $0x0,-0xf8f6d20(,%eax,4)
f0109829:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f010982d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109830:	c1 e0 0c             	shl    $0xc,%eax
f0109833:	89 c2                	mov    %eax,%edx
f0109835:	8b 45 08             	mov    0x8(%ebp),%eax
f0109838:	01 c2                	add    %eax,%edx
f010983a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010983f:	83 ec 08             	sub    $0x8,%esp
f0109842:	52                   	push   %edx
f0109843:	50                   	push   %eax
f0109844:	e8 96 ef ff ff       	call   f01087df <unmap_frame>
f0109849:	83 c4 10             	add    $0x10,%esp
			isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
f010984c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010984f:	c1 e0 0c             	shl    $0xc,%eax
f0109852:	89 c2                	mov    %eax,%edx
f0109854:	8b 45 08             	mov    0x8(%ebp),%eax
f0109857:	01 d0                	add    %edx,%eax
f0109859:	c1 e8 16             	shr    $0x16,%eax
f010985c:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f0109863:	4a                   	dec    %edx
f0109864:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f010986b:	ff 45 f4             	incl   -0xc(%ebp)
f010986e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109871:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109874:	72 8a                	jb     f0109800 <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109876:	eb 17                	jmp    f010988f <kfree+0x102>
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
			isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109878:	83 ec 04             	sub    $0x4,%esp
f010987b:	68 78 5c 12 f0       	push   $0xf0125c78
f0109880:	68 df 00 00 00       	push   $0xdf
f0109885:	68 5a 5c 12 f0       	push   $0xf0125c5a
f010988a:	e8 aa 6a ff ff       	call   f0100339 <_panic>
    }
}
f010988f:	90                   	nop
f0109890:	c9                   	leave  
f0109891:	c3                   	ret    

f0109892 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109892:	55                   	push   %ebp
f0109893:	89 e5                	mov    %esp,%ebp
f0109895:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109898:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f010989f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01098a4:	83 ec 04             	sub    $0x4,%esp
f01098a7:	8d 55 e8             	lea    -0x18(%ebp),%edx
f01098aa:	52                   	push   %edx
f01098ab:	ff 75 08             	pushl  0x8(%ebp)
f01098ae:	50                   	push   %eax
f01098af:	e8 b5 ee ff ff       	call   f0108769 <get_frame_info>
f01098b4:	83 c4 10             	add    $0x10,%esp
f01098b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f01098ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01098be:	75 07                	jne    f01098c7 <kheap_physical_address+0x35>
		return 0;
f01098c0:	b8 00 00 00 00       	mov    $0x0,%eax
f01098c5:	eb 26                	jmp    f01098ed <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f01098c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01098ca:	25 ff 0f 00 00       	and    $0xfff,%eax
f01098cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f01098d2:	83 ec 0c             	sub    $0xc,%esp
f01098d5:	ff 75 f4             	pushl  -0xc(%ebp)
f01098d8:	e8 d4 f9 ff ff       	call   f01092b1 <to_physical_address>
f01098dd:	83 c4 10             	add    $0x10,%esp
f01098e0:	89 c2                	mov    %eax,%edx
f01098e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098e5:	01 d0                	add    %edx,%eax
f01098e7:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f01098ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01098ed:	c9                   	leave  
f01098ee:	c3                   	ret    

f01098ef <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f01098ef:	55                   	push   %ebp
f01098f0:	89 e5                	mov    %esp,%ebp
f01098f2:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f01098f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01098f8:	25 ff 0f 00 00       	and    $0xfff,%eax
f01098fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109900:	8b 45 08             	mov    0x8(%ebp),%eax
f0109903:	c1 e8 0c             	shr    $0xc,%eax
f0109906:	8b 04 85 e0 92 70 f0 	mov    -0xf8f6d20(,%eax,4),%eax
f010990d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109910:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109914:	74 06                	je     f010991c <kheap_virtual_address+0x2d>
f0109916:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0109919:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f010991c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f010991f:	c9                   	leave  
f0109920:	c3                   	ret    

f0109921 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109921:	55                   	push   %ebp
f0109922:	89 e5                	mov    %esp,%ebp
f0109924:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f0109927:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f010992e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109932:	75 16                	jne    f010994a <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109934:	83 ec 0c             	sub    $0xc,%esp
f0109937:	ff 75 0c             	pushl  0xc(%ebp)
f010993a:	e8 cf fb ff ff       	call   f010950e <kmalloc>
f010993f:	83 c4 10             	add    $0x10,%esp
f0109942:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109945:	e9 37 03 00 00       	jmp    f0109c81 <krealloc+0x360>
	} else if(new_size == 0){
f010994a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010994e:	75 13                	jne    f0109963 <krealloc+0x42>
		kfree(va);
f0109950:	83 ec 0c             	sub    $0xc,%esp
f0109953:	ff 75 08             	pushl  0x8(%ebp)
f0109956:	e8 32 fe ff ff       	call   f010978d <kfree>
f010995b:	83 c4 10             	add    $0x10,%esp
f010995e:	e9 1e 03 00 00       	jmp    f0109c81 <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109963:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f0109968:	05 00 10 00 00       	add    $0x1000,%eax
f010996d:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f0109970:	8b 55 08             	mov    0x8(%ebp),%edx
f0109973:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f0109978:	39 c2                	cmp    %eax,%edx
f010997a:	73 19                	jae    f0109995 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f010997c:	83 ec 08             	sub    $0x8,%esp
f010997f:	ff 75 0c             	pushl  0xc(%ebp)
f0109982:	ff 75 08             	pushl  0x8(%ebp)
f0109985:	e8 a7 80 01 00       	call   f0121a31 <realloc_block_FF>
f010998a:	83 c4 10             	add    $0x10,%esp
f010998d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109990:	e9 ec 02 00 00       	jmp    f0109c81 <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109995:	8b 45 08             	mov    0x8(%ebp),%eax
f0109998:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010999b:	0f 82 c8 02 00 00    	jb     f0109c69 <krealloc+0x348>
f01099a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01099a4:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01099a9:	0f 87 ba 02 00 00    	ja     f0109c69 <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f01099af:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f01099b6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01099b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01099bc:	01 d0                	add    %edx,%eax
f01099be:	48                   	dec    %eax
f01099bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01099c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01099c5:	ba 00 00 00 00       	mov    $0x0,%edx
f01099ca:	f7 75 d4             	divl   -0x2c(%ebp)
f01099cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01099d0:	29 d0                	sub    %edx,%eax
f01099d2:	c1 e8 0c             	shr    $0xc,%eax
f01099d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f01099d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01099db:	c1 e8 0c             	shr    $0xc,%eax
f01099de:	8b 04 85 e0 12 6e f0 	mov    -0xf91ed20(,%eax,4),%eax
f01099e5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f01099e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01099eb:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01099ee:	0f 87 ee 00 00 00    	ja     f0109ae2 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f01099f4:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f01099fb:	77 63                	ja     f0109a60 <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f01099fd:	e8 4d f8 ff ff       	call   f010924f <isKHeapPlacementStrategyFIRSTFIT>
f0109a02:	84 c0                	test   %al,%al
f0109a04:	74 13                	je     f0109a19 <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f0109a06:	83 ec 0c             	sub    $0xc,%esp
f0109a09:	ff 75 0c             	pushl  0xc(%ebp)
f0109a0c:	e8 5c 70 01 00       	call   f0120a6d <alloc_block_FF>
f0109a11:	83 c4 10             	add    $0x10,%esp
f0109a14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109a17:	eb 1a                	jmp    f0109a33 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f0109a19:	e8 46 f8 ff ff       	call   f0109264 <isKHeapPlacementStrategyBESTFIT>
f0109a1e:	84 c0                	test   %al,%al
f0109a20:	74 11                	je     f0109a33 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109a22:	83 ec 0c             	sub    $0xc,%esp
f0109a25:	ff 75 0c             	pushl  0xc(%ebp)
f0109a28:	e8 fc 74 01 00       	call   f0120f29 <alloc_block_BF>
f0109a2d:	83 c4 10             	add    $0x10,%esp
f0109a30:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109a33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a37:	74 14                	je     f0109a4d <krealloc+0x12c>
f0109a39:	83 ec 04             	sub    $0x4,%esp
f0109a3c:	ff 75 0c             	pushl  0xc(%ebp)
f0109a3f:	ff 75 08             	pushl  0x8(%ebp)
f0109a42:	ff 75 f4             	pushl  -0xc(%ebp)
f0109a45:	e8 56 64 01 00       	call   f011fea0 <memcpy>
f0109a4a:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109a4d:	83 ec 0c             	sub    $0xc,%esp
f0109a50:	ff 75 08             	pushl  0x8(%ebp)
f0109a53:	e8 35 fd ff ff       	call   f010978d <kfree>
f0109a58:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109a5b:	e9 20 02 00 00       	jmp    f0109c80 <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109a60:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109a63:	c1 e0 0c             	shl    $0xc,%eax
f0109a66:	89 c2                	mov    %eax,%edx
f0109a68:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a6b:	01 d0                	add    %edx,%eax
f0109a6d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109a70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109a77:	eb 4f                	jmp    f0109ac8 <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109a79:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a7c:	c1 e0 0c             	shl    $0xc,%eax
f0109a7f:	89 c2                	mov    %eax,%edx
f0109a81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109a84:	01 d0                	add    %edx,%eax
f0109a86:	83 ec 0c             	sub    $0xc,%esp
f0109a89:	50                   	push   %eax
f0109a8a:	e8 03 fe ff ff       	call   f0109892 <kheap_physical_address>
f0109a8f:	83 c4 10             	add    $0x10,%esp
f0109a92:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109a95:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109a98:	c1 e8 0c             	shr    $0xc,%eax
f0109a9b:	c7 04 85 e0 92 70 f0 	movl   $0x0,-0xf8f6d20(,%eax,4)
f0109aa2:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109aa6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109aa9:	c1 e0 0c             	shl    $0xc,%eax
f0109aac:	89 c2                	mov    %eax,%edx
f0109aae:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109ab1:	01 c2                	add    %eax,%edx
f0109ab3:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109ab8:	83 ec 08             	sub    $0x8,%esp
f0109abb:	52                   	push   %edx
f0109abc:	50                   	push   %eax
f0109abd:	e8 1d ed ff ff       	call   f01087df <unmap_frame>
f0109ac2:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109ac5:	ff 45 f0             	incl   -0x10(%ebp)
f0109ac8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109acb:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109ace:	89 c2                	mov    %eax,%edx
f0109ad0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ad3:	39 c2                	cmp    %eax,%edx
f0109ad5:	77 a2                	ja     f0109a79 <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109ad7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ada:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109add:	e9 9e 01 00 00       	jmp    f0109c80 <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109ae2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109ae5:	c1 e0 0c             	shl    $0xc,%eax
f0109ae8:	89 c2                	mov    %eax,%edx
f0109aea:	8b 45 08             	mov    0x8(%ebp),%eax
f0109aed:	01 d0                	add    %edx,%eax
f0109aef:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109af2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109af9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109b00:	eb 33                	jmp    f0109b35 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109b02:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109b09:	0f 87 19 01 00 00    	ja     f0109c28 <krealloc+0x307>
f0109b0f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109b14:	83 ec 08             	sub    $0x8,%esp
f0109b17:	ff 75 ec             	pushl  -0x14(%ebp)
f0109b1a:	50                   	push   %eax
f0109b1b:	e8 b5 f9 ff ff       	call   f01094d5 <isPageAllocated>
f0109b20:	83 c4 10             	add    $0x10,%esp
f0109b23:	85 c0                	test   %eax,%eax
f0109b25:	0f 85 fd 00 00 00    	jne    f0109c28 <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109b2b:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109b32:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109b35:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b38:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109b3b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109b3e:	77 c2                	ja     f0109b02 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109b40:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109b4e:	eb 5c                	jmp    f0109bac <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109b50:	83 ec 0c             	sub    $0xc,%esp
f0109b53:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109b56:	50                   	push   %eax
f0109b57:	e8 56 e6 ff ff       	call   f01081b2 <allocate_frame>
f0109b5c:	83 c4 10             	add    $0x10,%esp
f0109b5f:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109b62:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109b66:	74 2d                	je     f0109b95 <krealloc+0x274>
f0109b68:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109b6b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109b6e:	01 d0                	add    %edx,%eax
f0109b70:	c1 e0 0c             	shl    $0xc,%eax
f0109b73:	89 c2                	mov    %eax,%edx
f0109b75:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b78:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109b7b:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109b7e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109b83:	6a 02                	push   $0x2
f0109b85:	51                   	push   %ecx
f0109b86:	52                   	push   %edx
f0109b87:	50                   	push   %eax
f0109b88:	e8 f2 ea ff ff       	call   f010867f <map_frame>
f0109b8d:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b90:	ff 45 e0             	incl   -0x20(%ebp)
f0109b93:	eb 17                	jmp    f0109bac <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109b95:	83 ec 04             	sub    $0x4,%esp
f0109b98:	68 6b 5c 12 f0       	push   $0xf0125c6b
f0109b9d:	68 4c 01 00 00       	push   $0x14c
f0109ba2:	68 5a 5c 12 f0       	push   $0xf0125c5a
f0109ba7:	e8 8d 67 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109bac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109baf:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109bb2:	89 c2                	mov    %eax,%edx
f0109bb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109bb7:	39 c2                	cmp    %eax,%edx
f0109bb9:	77 95                	ja     f0109b50 <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109bbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bbe:	c1 e8 0c             	shr    $0xc,%eax
f0109bc1:	89 c2                	mov    %eax,%edx
f0109bc3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109bc6:	89 04 95 e0 12 6e f0 	mov    %eax,-0xf91ed20(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109bcd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109bd4:	eb 43                	jmp    f0109c19 <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109bd6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109bd9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109bdc:	01 d0                	add    %edx,%eax
f0109bde:	c1 e0 0c             	shl    $0xc,%eax
f0109be1:	89 c2                	mov    %eax,%edx
f0109be3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109be6:	01 d0                	add    %edx,%eax
f0109be8:	83 ec 0c             	sub    $0xc,%esp
f0109beb:	50                   	push   %eax
f0109bec:	e8 a1 fc ff ff       	call   f0109892 <kheap_physical_address>
f0109bf1:	83 c4 10             	add    $0x10,%esp
f0109bf4:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109bf7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109bfa:	c1 e8 0c             	shr    $0xc,%eax
f0109bfd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109c00:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109c03:	01 ca                	add    %ecx,%edx
f0109c05:	89 d1                	mov    %edx,%ecx
f0109c07:	c1 e1 0c             	shl    $0xc,%ecx
f0109c0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c0d:	01 ca                	add    %ecx,%edx
f0109c0f:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109c16:	ff 45 dc             	incl   -0x24(%ebp)
f0109c19:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109c1c:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109c1f:	89 c2                	mov    %eax,%edx
f0109c21:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109c24:	39 c2                	cmp    %eax,%edx
f0109c26:	77 ae                	ja     f0109bd6 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109c28:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109c2c:	75 52                	jne    f0109c80 <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109c2e:	83 ec 0c             	sub    $0xc,%esp
f0109c31:	ff 75 0c             	pushl  0xc(%ebp)
f0109c34:	e8 d5 f8 ff ff       	call   f010950e <kmalloc>
f0109c39:	83 c4 10             	add    $0x10,%esp
f0109c3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109c3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109c43:	74 14                	je     f0109c59 <krealloc+0x338>
f0109c45:	83 ec 04             	sub    $0x4,%esp
f0109c48:	ff 75 0c             	pushl  0xc(%ebp)
f0109c4b:	ff 75 08             	pushl  0x8(%ebp)
f0109c4e:	ff 75 f4             	pushl  -0xc(%ebp)
f0109c51:	e8 4a 62 01 00       	call   f011fea0 <memcpy>
f0109c56:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109c59:	83 ec 0c             	sub    $0xc,%esp
f0109c5c:	ff 75 08             	pushl  0x8(%ebp)
f0109c5f:	e8 29 fb ff ff       	call   f010978d <kfree>
f0109c64:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109c67:	eb 17                	jmp    f0109c80 <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109c69:	83 ec 04             	sub    $0x4,%esp
f0109c6c:	68 a0 5c 12 f0       	push   $0xf0125ca0
f0109c71:	68 5b 01 00 00       	push   $0x15b
f0109c76:	68 5a 5c 12 f0       	push   $0xf0125c5a
f0109c7b:	e8 b9 66 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109c80:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109c84:	c9                   	leave  
f0109c85:	c3                   	ret    

f0109c86 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109c86:	55                   	push   %ebp
f0109c87:	89 e5                	mov    %esp,%ebp
f0109c89:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109c8c:	83 ec 04             	sub    $0x4,%esp
f0109c8f:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109c92:	50                   	push   %eax
f0109c93:	ff 75 0c             	pushl  0xc(%ebp)
f0109c96:	ff 75 08             	pushl  0x8(%ebp)
f0109c99:	e8 51 e7 ff ff       	call   f01083ef <get_page_table>
f0109c9e:	83 c4 10             	add    $0x10,%esp
f0109ca1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109ca4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ca7:	85 c0                	test   %eax,%eax
f0109ca9:	74 64                	je     f0109d0f <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cae:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cb1:	c1 ea 0c             	shr    $0xc,%edx
f0109cb4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109cba:	c1 e2 02             	shl    $0x2,%edx
f0109cbd:	01 c2                	add    %eax,%edx
f0109cbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cc2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109cc5:	c1 e9 0c             	shr    $0xc,%ecx
f0109cc8:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109cce:	c1 e1 02             	shl    $0x2,%ecx
f0109cd1:	01 c8                	add    %ecx,%eax
f0109cd3:	8b 00                	mov    (%eax),%eax
f0109cd5:	0b 45 10             	or     0x10(%ebp),%eax
f0109cd8:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109cda:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cdd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109ce0:	c1 ea 0c             	shr    $0xc,%edx
f0109ce3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109ce9:	c1 e2 02             	shl    $0x2,%edx
f0109cec:	01 d0                	add    %edx,%eax
f0109cee:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109cf1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109cf4:	c1 e9 0c             	shr    $0xc,%ecx
f0109cf7:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109cfd:	c1 e1 02             	shl    $0x2,%ecx
f0109d00:	01 ca                	add    %ecx,%edx
f0109d02:	8b 12                	mov    (%edx),%edx
f0109d04:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109d07:	f7 d1                	not    %ecx
f0109d09:	21 ca                	and    %ecx,%edx
f0109d0b:	89 10                	mov    %edx,(%eax)
f0109d0d:	eb 27                	jmp    f0109d36 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109d0f:	83 ec 08             	sub    $0x8,%esp
f0109d12:	ff 75 0c             	pushl  0xc(%ebp)
f0109d15:	68 cc 5c 12 f0       	push   $0xf0125ccc
f0109d1a:	e8 6c 72 ff ff       	call   f0100f8b <cprintf>
f0109d1f:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109d22:	83 ec 04             	sub    $0x4,%esp
f0109d25:	68 f4 5c 12 f0       	push   $0xf0125cf4
f0109d2a:	6a 1c                	push   $0x1c
f0109d2c:	68 68 5d 12 f0       	push   $0xf0125d68
f0109d31:	e8 03 66 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109d36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d39:	83 ec 08             	sub    $0x8,%esp
f0109d3c:	50                   	push   %eax
f0109d3d:	6a 00                	push   $0x0
f0109d3f:	e8 75 e0 ff ff       	call   f0107db9 <tlb_invalidate>
f0109d44:	83 c4 10             	add    $0x10,%esp
}
f0109d47:	90                   	nop
f0109d48:	c9                   	leave  
f0109d49:	c3                   	ret    

f0109d4a <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109d4a:	55                   	push   %ebp
f0109d4b:	89 e5                	mov    %esp,%ebp
f0109d4d:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109d50:	83 ec 04             	sub    $0x4,%esp
f0109d53:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d56:	50                   	push   %eax
f0109d57:	ff 75 0c             	pushl  0xc(%ebp)
f0109d5a:	ff 75 08             	pushl  0x8(%ebp)
f0109d5d:	e8 8d e6 ff ff       	call   f01083ef <get_page_table>
f0109d62:	83 c4 10             	add    $0x10,%esp
f0109d65:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109d68:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d6b:	85 c0                	test   %eax,%eax
f0109d6d:	74 1d                	je     f0109d8c <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109d6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d72:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d75:	c1 ea 0c             	shr    $0xc,%edx
f0109d78:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d7e:	c1 e2 02             	shl    $0x2,%edx
f0109d81:	01 d0                	add    %edx,%eax
f0109d83:	8b 00                	mov    (%eax),%eax
f0109d85:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109d8a:	eb 05                	jmp    f0109d91 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109d8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109d91:	c9                   	leave  
f0109d92:	c3                   	ret    

f0109d93 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0109d93:	55                   	push   %ebp
f0109d94:	89 e5                	mov    %esp,%ebp
f0109d96:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109d99:	83 ec 04             	sub    $0x4,%esp
f0109d9c:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d9f:	50                   	push   %eax
f0109da0:	ff 75 0c             	pushl  0xc(%ebp)
f0109da3:	ff 75 08             	pushl  0x8(%ebp)
f0109da6:	e8 44 e6 ff ff       	call   f01083ef <get_page_table>
f0109dab:	83 c4 10             	add    $0x10,%esp
f0109dae:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109db4:	85 c0                	test   %eax,%eax
f0109db6:	74 46                	je     f0109dfe <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109db8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dbb:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dbe:	c1 ea 0c             	shr    $0xc,%edx
f0109dc1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109dc7:	c1 e2 02             	shl    $0x2,%edx
f0109dca:	01 d0                	add    %edx,%eax
f0109dcc:	8b 00                	mov    (%eax),%eax
f0109dce:	83 ec 04             	sub    $0x4,%esp
f0109dd1:	50                   	push   %eax
f0109dd2:	ff 75 0c             	pushl  0xc(%ebp)
f0109dd5:	68 84 5d 12 f0       	push   $0xf0125d84
f0109dda:	e8 ac 71 ff ff       	call   f0100f8b <cprintf>
f0109ddf:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109de5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109de8:	c1 ea 0c             	shr    $0xc,%edx
f0109deb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109df1:	c1 e2 02             	shl    $0x2,%edx
f0109df4:	01 d0                	add    %edx,%eax
f0109df6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109dfc:	eb 14                	jmp    f0109e12 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109dfe:	83 ec 04             	sub    $0x4,%esp
f0109e01:	68 ac 5d 12 f0       	push   $0xf0125dac
f0109e06:	6a 47                	push   $0x47
f0109e08:	68 68 5d 12 f0       	push   $0xf0125d68
f0109e0d:	e8 27 65 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109e12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e15:	83 ec 08             	sub    $0x8,%esp
f0109e18:	50                   	push   %eax
f0109e19:	6a 00                	push   $0x0
f0109e1b:	e8 99 df ff ff       	call   f0107db9 <tlb_invalidate>
f0109e20:	83 c4 10             	add    $0x10,%esp
}
f0109e23:	90                   	nop
f0109e24:	c9                   	leave  
f0109e25:	c3                   	ret    

f0109e26 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109e26:	55                   	push   %ebp
f0109e27:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109e29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e2c:	c1 e8 16             	shr    $0x16,%eax
f0109e2f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e36:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e39:	01 d0                	add    %edx,%eax
f0109e3b:	8b 00                	mov    (%eax),%eax
f0109e3d:	83 e0 20             	and    $0x20,%eax
f0109e40:	85 c0                	test   %eax,%eax
f0109e42:	0f 95 c0             	setne  %al
f0109e45:	0f b6 c0             	movzbl %al,%eax
}
f0109e48:	5d                   	pop    %ebp
f0109e49:	c3                   	ret    

f0109e4a <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0109e4a:	55                   	push   %ebp
f0109e4b:	89 e5                	mov    %esp,%ebp
f0109e4d:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109e50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e53:	c1 e8 16             	shr    $0x16,%eax
f0109e56:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e5d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e60:	01 d0                	add    %edx,%eax
f0109e62:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e65:	c1 ea 16             	shr    $0x16,%edx
f0109e68:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109e6f:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e72:	01 ca                	add    %ecx,%edx
f0109e74:	8b 12                	mov    (%edx),%edx
f0109e76:	83 e2 df             	and    $0xffffffdf,%edx
f0109e79:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109e7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e7e:	83 ec 08             	sub    $0x8,%esp
f0109e81:	50                   	push   %eax
f0109e82:	6a 00                	push   $0x0
f0109e84:	e8 30 df ff ff       	call   f0107db9 <tlb_invalidate>
f0109e89:	83 c4 10             	add    $0x10,%esp
}
f0109e8c:	90                   	nop
f0109e8d:	c9                   	leave  
f0109e8e:	c3                   	ret    

f0109e8f <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0109e8f:	55                   	push   %ebp
f0109e90:	89 e5                	mov    %esp,%ebp
f0109e92:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0109e95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e98:	c1 e8 16             	shr    $0x16,%eax
f0109e9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109ea2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ea5:	01 d0                	add    %edx,%eax
f0109ea7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109ead:	0f 20 d8             	mov    %cr3,%eax
f0109eb0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109eb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109eb6:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109eb9:	90                   	nop
f0109eba:	c9                   	leave  
f0109ebb:	c3                   	ret    

f0109ebc <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109ebc:	55                   	push   %ebp
f0109ebd:	89 e5                	mov    %esp,%ebp
f0109ebf:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109ec2:	83 ec 0c             	sub    $0xc,%esp
f0109ec5:	6a 18                	push   $0x18
f0109ec7:	e8 42 f6 ff ff       	call   f010950e <kmalloc>
f0109ecc:	83 c4 10             	add    $0x10,%esp
f0109ecf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109ed2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109ed6:	75 14                	jne    f0109eec <env_page_ws_list_create_element+0x30>
f0109ed8:	83 ec 04             	sub    $0x4,%esp
f0109edb:	68 24 5e 12 f0       	push   $0xf0125e24
f0109ee0:	6a 19                	push   $0x19
f0109ee2:	68 54 5e 12 f0       	push   $0xf0125e54
f0109ee7:	e8 4d 64 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109eec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109eef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109ef2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ef5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109ef8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109efb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f00:	89 c2                	mov    %eax,%edx
f0109f02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f05:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109f07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f0a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109f0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f11:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f0109f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f1b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109f22:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109f25:	c9                   	leave  
f0109f26:	c3                   	ret    

f0109f27 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109f27:	55                   	push   %ebp
f0109f28:	89 e5                	mov    %esp,%ebp
f0109f2a:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f2d:	83 ec 0c             	sub    $0xc,%esp
f0109f30:	6a 02                	push   $0x2
f0109f32:	e8 4a 57 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f0109f37:	83 c4 10             	add    $0x10,%esp
f0109f3a:	85 c0                	test   %eax,%eax
f0109f3c:	0f 84 e5 03 00 00    	je     f010a327 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109f42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109f49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109f50:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f53:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109f59:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f5c:	e9 3b 02 00 00       	jmp    f010a19c <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109f61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f64:	8b 00                	mov    (%eax),%eax
f0109f66:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109f69:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f6c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f71:	89 c2                	mov    %eax,%edx
f0109f73:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109f79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109f7c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f81:	39 c2                	cmp    %eax,%edx
f0109f83:	0f 85 07 02 00 00    	jne    f010a190 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109f89:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f8c:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109f92:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109f95:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f98:	8b 10                	mov    (%eax),%edx
f0109f9a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f9d:	8b 40 64             	mov    0x64(%eax),%eax
f0109fa0:	83 ec 08             	sub    $0x8,%esp
f0109fa3:	52                   	push   %edx
f0109fa4:	50                   	push   %eax
f0109fa5:	e8 35 e8 ff ff       	call   f01087df <unmap_frame>
f0109faa:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f0109fad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109fb1:	75 14                	jne    f0109fc7 <env_page_ws_invalidate+0xa0>
f0109fb3:	83 ec 04             	sub    $0x4,%esp
f0109fb6:	68 73 5e 12 f0       	push   $0xf0125e73
f0109fbb:	6a 2f                	push   $0x2f
f0109fbd:	68 54 5e 12 f0       	push   $0xf0125e54
f0109fc2:	e8 72 63 ff ff       	call   f0100339 <_panic>
f0109fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fca:	8b 40 10             	mov    0x10(%eax),%eax
f0109fcd:	85 c0                	test   %eax,%eax
f0109fcf:	74 11                	je     f0109fe2 <env_page_ws_invalidate+0xbb>
f0109fd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fd4:	8b 40 10             	mov    0x10(%eax),%eax
f0109fd7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109fda:	8b 52 14             	mov    0x14(%edx),%edx
f0109fdd:	89 50 14             	mov    %edx,0x14(%eax)
f0109fe0:	eb 0f                	jmp    f0109ff1 <env_page_ws_invalidate+0xca>
f0109fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fe5:	8b 50 14             	mov    0x14(%eax),%edx
f0109fe8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109feb:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109ff1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ff4:	8b 40 14             	mov    0x14(%eax),%eax
f0109ff7:	85 c0                	test   %eax,%eax
f0109ff9:	74 11                	je     f010a00c <env_page_ws_invalidate+0xe5>
f0109ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ffe:	8b 40 14             	mov    0x14(%eax),%eax
f010a001:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a004:	8b 52 10             	mov    0x10(%edx),%edx
f010a007:	89 50 10             	mov    %edx,0x10(%eax)
f010a00a:	eb 0f                	jmp    f010a01b <env_page_ws_invalidate+0xf4>
f010a00c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a00f:	8b 50 10             	mov    0x10(%eax),%edx
f010a012:	8b 45 08             	mov    0x8(%ebp),%eax
f010a015:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a01b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a01e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a025:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a028:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a02f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a032:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a038:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a03b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a03e:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a044:	83 ec 0c             	sub    $0xc,%esp
f010a047:	ff 75 f0             	pushl  -0x10(%ebp)
f010a04a:	e8 3e f7 ff ff       	call   f010978d <kfree>
f010a04f:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a052:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a056:	0f 84 2b 01 00 00    	je     f010a187 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a05c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a060:	75 14                	jne    f010a076 <env_page_ws_invalidate+0x14f>
f010a062:	83 ec 04             	sub    $0x4,%esp
f010a065:	68 73 5e 12 f0       	push   $0xf0125e73
f010a06a:	6a 35                	push   $0x35
f010a06c:	68 54 5e 12 f0       	push   $0xf0125e54
f010a071:	e8 c3 62 ff ff       	call   f0100339 <_panic>
f010a076:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a079:	8b 40 10             	mov    0x10(%eax),%eax
f010a07c:	85 c0                	test   %eax,%eax
f010a07e:	74 11                	je     f010a091 <env_page_ws_invalidate+0x16a>
f010a080:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a083:	8b 40 10             	mov    0x10(%eax),%eax
f010a086:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a089:	8b 52 14             	mov    0x14(%edx),%edx
f010a08c:	89 50 14             	mov    %edx,0x14(%eax)
f010a08f:	eb 0f                	jmp    f010a0a0 <env_page_ws_invalidate+0x179>
f010a091:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a094:	8b 50 14             	mov    0x14(%eax),%edx
f010a097:	8b 45 08             	mov    0x8(%ebp),%eax
f010a09a:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a0a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0a3:	8b 40 14             	mov    0x14(%eax),%eax
f010a0a6:	85 c0                	test   %eax,%eax
f010a0a8:	74 11                	je     f010a0bb <env_page_ws_invalidate+0x194>
f010a0aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0ad:	8b 40 14             	mov    0x14(%eax),%eax
f010a0b0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a0b3:	8b 52 10             	mov    0x10(%edx),%edx
f010a0b6:	89 50 10             	mov    %edx,0x10(%eax)
f010a0b9:	eb 0f                	jmp    f010a0ca <env_page_ws_invalidate+0x1a3>
f010a0bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0be:	8b 50 10             	mov    0x10(%eax),%edx
f010a0c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0c4:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a0ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a0d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0d7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a0de:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0e1:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a0e7:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a0ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ed:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a0f3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0f7:	75 14                	jne    f010a10d <env_page_ws_invalidate+0x1e6>
f010a0f9:	83 ec 04             	sub    $0x4,%esp
f010a0fc:	68 94 5e 12 f0       	push   $0xf0125e94
f010a101:	6a 36                	push   $0x36
f010a103:	68 54 5e 12 f0       	push   $0xf0125e54
f010a108:	e8 2c 62 ff ff       	call   f0100339 <_panic>
f010a10d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a110:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a116:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a119:	89 50 14             	mov    %edx,0x14(%eax)
f010a11c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a11f:	8b 40 14             	mov    0x14(%eax),%eax
f010a122:	85 c0                	test   %eax,%eax
f010a124:	74 11                	je     f010a137 <env_page_ws_invalidate+0x210>
f010a126:	8b 45 08             	mov    0x8(%ebp),%eax
f010a129:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a12f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a132:	89 50 10             	mov    %edx,0x10(%eax)
f010a135:	eb 0c                	jmp    f010a143 <env_page_ws_invalidate+0x21c>
f010a137:	8b 45 08             	mov    0x8(%ebp),%eax
f010a13a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a13d:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a143:	8b 45 08             	mov    0x8(%ebp),%eax
f010a146:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a149:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a14f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a152:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a159:	8b 45 08             	mov    0x8(%ebp),%eax
f010a15c:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a162:	8d 50 01             	lea    0x1(%eax),%edx
f010a165:	8b 45 08             	mov    0x8(%ebp),%eax
f010a168:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a16e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a171:	8b 10                	mov    (%eax),%edx
f010a173:	8b 45 08             	mov    0x8(%ebp),%eax
f010a176:	8b 40 64             	mov    0x64(%eax),%eax
f010a179:	6a 00                	push   $0x0
f010a17b:	6a 01                	push   $0x1
f010a17d:	52                   	push   %edx
f010a17e:	50                   	push   %eax
f010a17f:	e8 02 fb ff ff       	call   f0109c86 <pt_set_page_permissions>
f010a184:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a187:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a18e:	eb 43                	jmp    f010a1d3 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a190:	8b 45 08             	mov    0x8(%ebp),%eax
f010a193:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a199:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a19c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1a0:	74 08                	je     f010a1aa <env_page_ws_invalidate+0x283>
f010a1a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1a5:	8b 40 10             	mov    0x10(%eax),%eax
f010a1a8:	eb 05                	jmp    f010a1af <env_page_ws_invalidate+0x288>
f010a1aa:	b8 00 00 00 00       	mov    $0x0,%eax
f010a1af:	8b 55 08             	mov    0x8(%ebp),%edx
f010a1b2:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a1b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1bb:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a1c1:	85 c0                	test   %eax,%eax
f010a1c3:	0f 85 98 fd ff ff    	jne    f0109f61 <env_page_ws_invalidate+0x3a>
f010a1c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1cd:	0f 85 8e fd ff ff    	jne    f0109f61 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a1d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a1d7:	0f 85 a4 02 00 00    	jne    f010a481 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a1dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a1e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1e7:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a1ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1f0:	e9 f6 00 00 00       	jmp    f010a2eb <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a1f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1f8:	8b 00                	mov    (%eax),%eax
f010a1fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a1fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a200:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a205:	89 c2                	mov    %eax,%edx
f010a207:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a20a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a20d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a210:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a215:	39 c2                	cmp    %eax,%edx
f010a217:	0f 85 c2 00 00 00    	jne    f010a2df <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a21d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a220:	8b 10                	mov    (%eax),%edx
f010a222:	8b 45 08             	mov    0x8(%ebp),%eax
f010a225:	8b 40 64             	mov    0x64(%eax),%eax
f010a228:	83 ec 08             	sub    $0x8,%esp
f010a22b:	52                   	push   %edx
f010a22c:	50                   	push   %eax
f010a22d:	e8 ad e5 ff ff       	call   f01087df <unmap_frame>
f010a232:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a235:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a239:	75 14                	jne    f010a24f <env_page_ws_invalidate+0x328>
f010a23b:	83 ec 04             	sub    $0x4,%esp
f010a23e:	68 73 5e 12 f0       	push   $0xf0125e73
f010a243:	6a 46                	push   $0x46
f010a245:	68 54 5e 12 f0       	push   $0xf0125e54
f010a24a:	e8 ea 60 ff ff       	call   f0100339 <_panic>
f010a24f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a252:	8b 40 10             	mov    0x10(%eax),%eax
f010a255:	85 c0                	test   %eax,%eax
f010a257:	74 11                	je     f010a26a <env_page_ws_invalidate+0x343>
f010a259:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a25c:	8b 40 10             	mov    0x10(%eax),%eax
f010a25f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a262:	8b 52 14             	mov    0x14(%edx),%edx
f010a265:	89 50 14             	mov    %edx,0x14(%eax)
f010a268:	eb 0f                	jmp    f010a279 <env_page_ws_invalidate+0x352>
f010a26a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a26d:	8b 50 14             	mov    0x14(%eax),%edx
f010a270:	8b 45 08             	mov    0x8(%ebp),%eax
f010a273:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a279:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a27c:	8b 40 14             	mov    0x14(%eax),%eax
f010a27f:	85 c0                	test   %eax,%eax
f010a281:	74 11                	je     f010a294 <env_page_ws_invalidate+0x36d>
f010a283:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a286:	8b 40 14             	mov    0x14(%eax),%eax
f010a289:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a28c:	8b 52 10             	mov    0x10(%edx),%edx
f010a28f:	89 50 10             	mov    %edx,0x10(%eax)
f010a292:	eb 0f                	jmp    f010a2a3 <env_page_ws_invalidate+0x37c>
f010a294:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a297:	8b 50 10             	mov    0x10(%eax),%edx
f010a29a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a29d:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a2a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2a6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a2ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2b0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a2b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ba:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a2c0:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a2c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c6:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a2cc:	83 ec 0c             	sub    $0xc,%esp
f010a2cf:	ff 75 f0             	pushl  -0x10(%ebp)
f010a2d2:	e8 b6 f4 ff ff       	call   f010978d <kfree>
f010a2d7:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a2da:	e9 a2 01 00 00       	jmp    f010a481 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a2df:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2e2:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a2e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a2eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2ef:	74 08                	je     f010a2f9 <env_page_ws_invalidate+0x3d2>
f010a2f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f4:	8b 40 10             	mov    0x10(%eax),%eax
f010a2f7:	eb 05                	jmp    f010a2fe <env_page_ws_invalidate+0x3d7>
f010a2f9:	b8 00 00 00 00       	mov    $0x0,%eax
f010a2fe:	8b 55 08             	mov    0x8(%ebp),%edx
f010a301:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a307:	8b 45 08             	mov    0x8(%ebp),%eax
f010a30a:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a310:	85 c0                	test   %eax,%eax
f010a312:	0f 85 dd fe ff ff    	jne    f010a1f5 <env_page_ws_invalidate+0x2ce>
f010a318:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a31c:	0f 85 d3 fe ff ff    	jne    f010a1f5 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a322:	e9 5a 01 00 00       	jmp    f010a481 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a327:	8b 45 08             	mov    0x8(%ebp),%eax
f010a32a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a330:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a333:	e9 10 01 00 00       	jmp    f010a448 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a338:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a33b:	8b 00                	mov    (%eax),%eax
f010a33d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a340:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a343:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a348:	89 c2                	mov    %eax,%edx
f010a34a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a34d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a350:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a353:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a358:	39 c2                	cmp    %eax,%edx
f010a35a:	0f 85 dc 00 00 00    	jne    f010a43c <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a360:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a363:	8b 10                	mov    (%eax),%edx
f010a365:	8b 45 08             	mov    0x8(%ebp),%eax
f010a368:	8b 40 64             	mov    0x64(%eax),%eax
f010a36b:	83 ec 08             	sub    $0x8,%esp
f010a36e:	52                   	push   %edx
f010a36f:	50                   	push   %eax
f010a370:	e8 6a e4 ff ff       	call   f01087df <unmap_frame>
f010a375:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a378:	8b 45 08             	mov    0x8(%ebp),%eax
f010a37b:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a381:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a384:	75 0f                	jne    f010a395 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a386:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a389:	8b 50 10             	mov    0x10(%eax),%edx
f010a38c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a38f:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a395:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a399:	75 14                	jne    f010a3af <env_page_ws_invalidate+0x488>
f010a39b:	83 ec 04             	sub    $0x4,%esp
f010a39e:	68 73 5e 12 f0       	push   $0xf0125e73
f010a3a3:	6a 5c                	push   $0x5c
f010a3a5:	68 54 5e 12 f0       	push   $0xf0125e54
f010a3aa:	e8 8a 5f ff ff       	call   f0100339 <_panic>
f010a3af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3b2:	8b 40 10             	mov    0x10(%eax),%eax
f010a3b5:	85 c0                	test   %eax,%eax
f010a3b7:	74 11                	je     f010a3ca <env_page_ws_invalidate+0x4a3>
f010a3b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3bc:	8b 40 10             	mov    0x10(%eax),%eax
f010a3bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a3c2:	8b 52 14             	mov    0x14(%edx),%edx
f010a3c5:	89 50 14             	mov    %edx,0x14(%eax)
f010a3c8:	eb 0f                	jmp    f010a3d9 <env_page_ws_invalidate+0x4b2>
f010a3ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3cd:	8b 50 14             	mov    0x14(%eax),%edx
f010a3d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a3d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3dc:	8b 40 14             	mov    0x14(%eax),%eax
f010a3df:	85 c0                	test   %eax,%eax
f010a3e1:	74 11                	je     f010a3f4 <env_page_ws_invalidate+0x4cd>
f010a3e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3e6:	8b 40 14             	mov    0x14(%eax),%eax
f010a3e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a3ec:	8b 52 10             	mov    0x10(%edx),%edx
f010a3ef:	89 50 10             	mov    %edx,0x10(%eax)
f010a3f2:	eb 0f                	jmp    f010a403 <env_page_ws_invalidate+0x4dc>
f010a3f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3f7:	8b 50 10             	mov    0x10(%eax),%edx
f010a3fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3fd:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a403:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a406:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a40d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a410:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a417:	8b 45 08             	mov    0x8(%ebp),%eax
f010a41a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a420:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a423:	8b 45 08             	mov    0x8(%ebp),%eax
f010a426:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a42c:	83 ec 0c             	sub    $0xc,%esp
f010a42f:	ff 75 ec             	pushl  -0x14(%ebp)
f010a432:	e8 56 f3 ff ff       	call   f010978d <kfree>
f010a437:	83 c4 10             	add    $0x10,%esp

				break;
f010a43a:	eb 45                	jmp    f010a481 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a43c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a43f:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a445:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a448:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a44c:	74 08                	je     f010a456 <env_page_ws_invalidate+0x52f>
f010a44e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a451:	8b 40 10             	mov    0x10(%eax),%eax
f010a454:	eb 05                	jmp    f010a45b <env_page_ws_invalidate+0x534>
f010a456:	b8 00 00 00 00       	mov    $0x0,%eax
f010a45b:	8b 55 08             	mov    0x8(%ebp),%edx
f010a45e:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a464:	8b 45 08             	mov    0x8(%ebp),%eax
f010a467:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a46d:	85 c0                	test   %eax,%eax
f010a46f:	0f 85 c3 fe ff ff    	jne    f010a338 <env_page_ws_invalidate+0x411>
f010a475:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a479:	0f 85 b9 fe ff ff    	jne    f010a338 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a47f:	eb 00                	jmp    f010a481 <env_page_ws_invalidate+0x55a>
f010a481:	90                   	nop
f010a482:	c9                   	leave  
f010a483:	c3                   	ret    

f010a484 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a484:	55                   	push   %ebp
f010a485:	89 e5                	mov    %esp,%ebp
f010a487:	53                   	push   %ebx
f010a488:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a48b:	83 ec 0c             	sub    $0xc,%esp
f010a48e:	6a 02                	push   $0x2
f010a490:	e8 ec 51 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010a495:	83 c4 10             	add    $0x10,%esp
f010a498:	85 c0                	test   %eax,%eax
f010a49a:	0f 84 fe 00 00 00    	je     f010a59e <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a4a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a4a7:	83 ec 0c             	sub    $0xc,%esp
f010a4aa:	68 b7 5e 12 f0       	push   $0xf0125eb7
f010a4af:	e8 d7 6a ff ff       	call   f0100f8b <cprintf>
f010a4b4:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a4b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ba:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a4c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4c3:	eb 2c                	jmp    f010a4f1 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a4c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4c8:	8b 10                	mov    (%eax),%edx
f010a4ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4cd:	8d 48 01             	lea    0x1(%eax),%ecx
f010a4d0:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a4d3:	83 ec 04             	sub    $0x4,%esp
f010a4d6:	52                   	push   %edx
f010a4d7:	50                   	push   %eax
f010a4d8:	68 d1 5e 12 f0       	push   $0xf0125ed1
f010a4dd:	e8 a9 6a ff ff       	call   f0100f8b <cprintf>
f010a4e2:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4e8:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4f5:	74 08                	je     f010a4ff <env_page_ws_print+0x7b>
f010a4f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4fa:	8b 40 10             	mov    0x10(%eax),%eax
f010a4fd:	eb 05                	jmp    f010a504 <env_page_ws_print+0x80>
f010a4ff:	b8 00 00 00 00       	mov    $0x0,%eax
f010a504:	8b 55 08             	mov    0x8(%ebp),%edx
f010a507:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a50d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a510:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a516:	85 c0                	test   %eax,%eax
f010a518:	75 ab                	jne    f010a4c5 <env_page_ws_print+0x41>
f010a51a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a51e:	75 a5                	jne    f010a4c5 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a520:	83 ec 0c             	sub    $0xc,%esp
f010a523:	68 d9 5e 12 f0       	push   $0xf0125ed9
f010a528:	e8 5e 6a ff ff       	call   f0100f8b <cprintf>
f010a52d:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a530:	8b 45 08             	mov    0x8(%ebp),%eax
f010a533:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a539:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a53c:	eb 2c                	jmp    f010a56a <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a53e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a541:	8b 10                	mov    (%eax),%edx
f010a543:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a546:	8d 48 01             	lea    0x1(%eax),%ecx
f010a549:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a54c:	83 ec 04             	sub    $0x4,%esp
f010a54f:	52                   	push   %edx
f010a550:	50                   	push   %eax
f010a551:	68 d1 5e 12 f0       	push   $0xf0125ed1
f010a556:	e8 30 6a ff ff       	call   f0100f8b <cprintf>
f010a55b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a55e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a561:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a567:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a56a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a56e:	74 08                	je     f010a578 <env_page_ws_print+0xf4>
f010a570:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a573:	8b 40 10             	mov    0x10(%eax),%eax
f010a576:	eb 05                	jmp    f010a57d <env_page_ws_print+0xf9>
f010a578:	b8 00 00 00 00       	mov    $0x0,%eax
f010a57d:	8b 55 08             	mov    0x8(%ebp),%edx
f010a580:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a586:	8b 45 08             	mov    0x8(%ebp),%eax
f010a589:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a58f:	85 c0                	test   %eax,%eax
f010a591:	75 ab                	jne    f010a53e <env_page_ws_print+0xba>
f010a593:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a597:	75 a5                	jne    f010a53e <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a599:	e9 5a 01 00 00       	jmp    f010a6f8 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a59e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a5a5:	83 ec 0c             	sub    $0xc,%esp
f010a5a8:	68 f4 5e 12 f0       	push   $0xf0125ef4
f010a5ad:	e8 d9 69 ff ff       	call   f0100f8b <cprintf>
f010a5b2:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a5b5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a5bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5bf:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a5c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a5c8:	e9 d1 00 00 00       	jmp    f010a69e <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a5cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5d0:	8b 00                	mov    (%eax),%eax
f010a5d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a5d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5d8:	8b 40 08             	mov    0x8(%eax),%eax
f010a5db:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a5de:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e1:	8b 40 64             	mov    0x64(%eax),%eax
f010a5e4:	83 ec 08             	sub    $0x8,%esp
f010a5e7:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a5ea:	50                   	push   %eax
f010a5eb:	e8 5a f7 ff ff       	call   f0109d4a <pt_get_page_permissions>
f010a5f0:	83 c4 10             	add    $0x10,%esp
f010a5f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a5f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a5f9:	83 e0 40             	and    $0x40,%eax
f010a5fc:	85 c0                	test   %eax,%eax
f010a5fe:	0f 95 c0             	setne  %al
f010a601:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a604:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a607:	83 e0 20             	and    $0x20,%eax
f010a60a:	85 c0                	test   %eax,%eax
f010a60c:	0f 95 c0             	setne  %al
f010a60f:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a612:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a615:	25 00 02 00 00       	and    $0x200,%eax
f010a61a:	85 c0                	test   %eax,%eax
f010a61c:	0f 95 c0             	setne  %al
f010a61f:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a622:	83 ec 04             	sub    $0x4,%esp
f010a625:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a628:	ff 75 ec             	pushl  -0x14(%ebp)
f010a62b:	68 fe 5e 12 f0       	push   $0xf0125efe
f010a630:	e8 56 69 ff ff       	call   f0100f8b <cprintf>
f010a635:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a638:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a63b:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a63e:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a642:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a646:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a64a:	83 ec 08             	sub    $0x8,%esp
f010a64d:	53                   	push   %ebx
f010a64e:	ff 75 e0             	pushl  -0x20(%ebp)
f010a651:	51                   	push   %ecx
f010a652:	52                   	push   %edx
f010a653:	50                   	push   %eax
f010a654:	68 08 5f 12 f0       	push   $0xf0125f08
f010a659:	e8 2d 69 ff ff       	call   f0100f8b <cprintf>
f010a65e:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a661:	8b 45 08             	mov    0x8(%ebp),%eax
f010a664:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a66a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a66d:	75 10                	jne    f010a67f <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a66f:	83 ec 0c             	sub    $0xc,%esp
f010a672:	68 4f 5f 12 f0       	push   $0xf0125f4f
f010a677:	e8 0f 69 ff ff       	call   f0100f8b <cprintf>
f010a67c:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a67f:	83 ec 0c             	sub    $0xc,%esp
f010a682:	68 54 5f 12 f0       	push   $0xf0125f54
f010a687:	e8 ff 68 ff ff       	call   f0100f8b <cprintf>
f010a68c:	83 c4 10             	add    $0x10,%esp
			i++;
f010a68f:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a692:	8b 45 08             	mov    0x8(%ebp),%eax
f010a695:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a69b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a69e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a6a2:	74 08                	je     f010a6ac <env_page_ws_print+0x228>
f010a6a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a6a7:	8b 40 10             	mov    0x10(%eax),%eax
f010a6aa:	eb 05                	jmp    f010a6b1 <env_page_ws_print+0x22d>
f010a6ac:	b8 00 00 00 00       	mov    $0x0,%eax
f010a6b1:	8b 55 08             	mov    0x8(%ebp),%edx
f010a6b4:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a6ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6bd:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a6c3:	85 c0                	test   %eax,%eax
f010a6c5:	0f 85 02 ff ff ff    	jne    f010a5cd <env_page_ws_print+0x149>
f010a6cb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a6cf:	0f 85 f8 fe ff ff    	jne    f010a5cd <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a6d5:	eb 13                	jmp    f010a6ea <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a6d7:	83 ec 0c             	sub    $0xc,%esp
f010a6da:	68 56 5f 12 f0       	push   $0xf0125f56
f010a6df:	e8 a7 68 ff ff       	call   f0100f8b <cprintf>
f010a6e4:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a6e7:	ff 45 ec             	incl   -0x14(%ebp)
f010a6ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6ed:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a6f3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a6f6:	77 df                	ja     f010a6d7 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a6f8:	90                   	nop
f010a6f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a6fc:	c9                   	leave  
f010a6fd:	c3                   	ret    

f010a6fe <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a6fe:	55                   	push   %ebp
f010a6ff:	89 e5                	mov    %esp,%ebp
f010a701:	53                   	push   %ebx
f010a702:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a705:	83 ec 0c             	sub    $0xc,%esp
f010a708:	68 68 5f 12 f0       	push   $0xf0125f68
f010a70d:	e8 79 68 ff ff       	call   f0100f8b <cprintf>
f010a712:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a715:	83 ec 0c             	sub    $0xc,%esp
f010a718:	68 9d 5f 12 f0       	push   $0xf0125f9d
f010a71d:	e8 69 68 ff ff       	call   f0100f8b <cprintf>
f010a722:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a725:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a72c:	e9 16 01 00 00       	jmp    f010a847 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a731:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a734:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a737:	89 d0                	mov    %edx,%eax
f010a739:	01 c0                	add    %eax,%eax
f010a73b:	01 d0                	add    %edx,%eax
f010a73d:	c1 e0 03             	shl    $0x3,%eax
f010a740:	01 c8                	add    %ecx,%eax
f010a742:	05 b0 00 00 00       	add    $0xb0,%eax
f010a747:	8a 00                	mov    (%eax),%al
f010a749:	84 c0                	test   %al,%al
f010a74b:	74 43                	je     f010a790 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a74d:	83 ec 0c             	sub    $0xc,%esp
f010a750:	68 a8 5f 12 f0       	push   $0xf0125fa8
f010a755:	e8 31 68 ff ff       	call   f0100f8b <cprintf>
f010a75a:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a75d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a760:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a766:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a769:	75 10                	jne    f010a77b <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a76b:	83 ec 0c             	sub    $0xc,%esp
f010a76e:	68 b7 5f 12 f0       	push   $0xf0125fb7
f010a773:	e8 13 68 ff ff       	call   f0100f8b <cprintf>
f010a778:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a77b:	83 ec 0c             	sub    $0xc,%esp
f010a77e:	68 54 5f 12 f0       	push   $0xf0125f54
f010a783:	e8 03 68 ff ff       	call   f0100f8b <cprintf>
f010a788:	83 c4 10             	add    $0x10,%esp
			continue;
f010a78b:	e9 b4 00 00 00       	jmp    f010a844 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a790:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a793:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a796:	89 d0                	mov    %edx,%eax
f010a798:	01 c0                	add    %eax,%eax
f010a79a:	01 d0                	add    %edx,%eax
f010a79c:	c1 e0 03             	shl    $0x3,%eax
f010a79f:	01 c8                	add    %ecx,%eax
f010a7a1:	05 ac 00 00 00       	add    $0xac,%eax
f010a7a6:	8b 00                	mov    (%eax),%eax
f010a7a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a7ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7b1:	89 d0                	mov    %edx,%eax
f010a7b3:	01 c0                	add    %eax,%eax
f010a7b5:	01 d0                	add    %edx,%eax
f010a7b7:	c1 e0 03             	shl    $0x3,%eax
f010a7ba:	01 c8                	add    %ecx,%eax
f010a7bc:	05 ac 00 00 00       	add    $0xac,%eax
f010a7c1:	8b 00                	mov    (%eax),%eax
f010a7c3:	83 ec 04             	sub    $0x4,%esp
f010a7c6:	50                   	push   %eax
f010a7c7:	ff 75 f4             	pushl  -0xc(%ebp)
f010a7ca:	68 bd 5f 12 f0       	push   $0xf0125fbd
f010a7cf:	e8 b7 67 ff ff       	call   f0100f8b <cprintf>
f010a7d4:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a7d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7dd:	89 d0                	mov    %edx,%eax
f010a7df:	01 c0                	add    %eax,%eax
f010a7e1:	01 d0                	add    %edx,%eax
f010a7e3:	c1 e0 03             	shl    $0x3,%eax
f010a7e6:	01 c8                	add    %ecx,%eax
f010a7e8:	05 b4 00 00 00       	add    $0xb4,%eax
f010a7ed:	8b 18                	mov    (%eax),%ebx
f010a7ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7f2:	8b 40 64             	mov    0x64(%eax),%eax
f010a7f5:	83 ec 08             	sub    $0x8,%esp
f010a7f8:	ff 75 f0             	pushl  -0x10(%ebp)
f010a7fb:	50                   	push   %eax
f010a7fc:	e8 25 f6 ff ff       	call   f0109e26 <pd_is_table_used>
f010a801:	83 c4 10             	add    $0x10,%esp
f010a804:	83 ec 04             	sub    $0x4,%esp
f010a807:	53                   	push   %ebx
f010a808:	50                   	push   %eax
f010a809:	68 d4 5f 12 f0       	push   $0xf0125fd4
f010a80e:	e8 78 67 ff ff       	call   f0100f8b <cprintf>
f010a813:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a816:	8b 45 08             	mov    0x8(%ebp),%eax
f010a819:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a81f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a822:	75 10                	jne    f010a834 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a824:	83 ec 0c             	sub    $0xc,%esp
f010a827:	68 4f 5f 12 f0       	push   $0xf0125f4f
f010a82c:	e8 5a 67 ff ff       	call   f0100f8b <cprintf>
f010a831:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a834:	83 ec 0c             	sub    $0xc,%esp
f010a837:	68 54 5f 12 f0       	push   $0xf0125f54
f010a83c:	e8 4a 67 ff ff       	call   f0100f8b <cprintf>
f010a841:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a844:	ff 45 f4             	incl   -0xc(%ebp)
f010a847:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a84b:	0f 86 e0 fe ff ff    	jbe    f010a731 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a851:	90                   	nop
f010a852:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a855:	c9                   	leave  
f010a856:	c3                   	ret    

f010a857 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a857:	55                   	push   %ebp
f010a858:	89 e5                	mov    %esp,%ebp
f010a85a:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a85d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a864:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a86b:	eb 22                	jmp    f010a88f <env_table_ws_get_size+0x38>
f010a86d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a870:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a873:	89 d0                	mov    %edx,%eax
f010a875:	01 c0                	add    %eax,%eax
f010a877:	01 d0                	add    %edx,%eax
f010a879:	c1 e0 03             	shl    $0x3,%eax
f010a87c:	01 c8                	add    %ecx,%eax
f010a87e:	05 b0 00 00 00       	add    $0xb0,%eax
f010a883:	8a 00                	mov    (%eax),%al
f010a885:	84 c0                	test   %al,%al
f010a887:	75 03                	jne    f010a88c <env_table_ws_get_size+0x35>
f010a889:	ff 45 f8             	incl   -0x8(%ebp)
f010a88c:	ff 45 fc             	incl   -0x4(%ebp)
f010a88f:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a893:	7e d8                	jle    f010a86d <env_table_ws_get_size+0x16>
	return counter;
f010a895:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a898:	c9                   	leave  
f010a899:	c3                   	ret    

f010a89a <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a89a:	55                   	push   %ebp
f010a89b:	89 e5                	mov    %esp,%ebp
f010a89d:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a8a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a8a7:	eb 4e                	jmp    f010a8f7 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a8a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a8af:	89 d0                	mov    %edx,%eax
f010a8b1:	01 c0                	add    %eax,%eax
f010a8b3:	01 d0                	add    %edx,%eax
f010a8b5:	c1 e0 03             	shl    $0x3,%eax
f010a8b8:	01 c8                	add    %ecx,%eax
f010a8ba:	05 ac 00 00 00       	add    $0xac,%eax
f010a8bf:	8b 00                	mov    (%eax),%eax
f010a8c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a8c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a8c7:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a8cc:	89 c2                	mov    %eax,%edx
f010a8ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a8d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a8d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8d7:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a8dc:	39 c2                	cmp    %eax,%edx
f010a8de:	75 14                	jne    f010a8f4 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a8e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8e3:	83 ec 08             	sub    $0x8,%esp
f010a8e6:	50                   	push   %eax
f010a8e7:	ff 75 08             	pushl  0x8(%ebp)
f010a8ea:	e8 bc 00 00 00       	call   f010a9ab <env_table_ws_clear_entry>
f010a8ef:	83 c4 10             	add    $0x10,%esp
			break;
f010a8f2:	eb 09                	jmp    f010a8fd <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a8f4:	ff 45 f4             	incl   -0xc(%ebp)
f010a8f7:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a8fb:	7e ac                	jle    f010a8a9 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a8fd:	90                   	nop
f010a8fe:	c9                   	leave  
f010a8ff:	c3                   	ret    

f010a900 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a900:	55                   	push   %ebp
f010a901:	89 e5                	mov    %esp,%ebp
f010a903:	53                   	push   %ebx
f010a904:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a907:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a90b:	76 19                	jbe    f010a926 <env_table_ws_set_entry+0x26>
f010a90d:	68 f8 5f 12 f0       	push   $0xf0125ff8
f010a912:	68 29 60 12 f0       	push   $0xf0126029
f010a917:	68 3f 01 00 00       	push   $0x13f
f010a91c:	68 54 5e 12 f0       	push   $0xf0125e54
f010a921:	e8 13 5a ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a926:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a92d:	76 19                	jbe    f010a948 <env_table_ws_set_entry+0x48>
f010a92f:	68 40 60 12 f0       	push   $0xf0126040
f010a934:	68 29 60 12 f0       	push   $0xf0126029
f010a939:	68 40 01 00 00       	push   $0x140
f010a93e:	68 54 5e 12 f0       	push   $0xf0125e54
f010a943:	e8 f1 59 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a948:	8b 45 10             	mov    0x10(%ebp),%eax
f010a94b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a94e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a951:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a956:	89 c1                	mov    %eax,%ecx
f010a958:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a95b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a95e:	89 d0                	mov    %edx,%eax
f010a960:	01 c0                	add    %eax,%eax
f010a962:	01 d0                	add    %edx,%eax
f010a964:	c1 e0 03             	shl    $0x3,%eax
f010a967:	01 d8                	add    %ebx,%eax
f010a969:	05 ac 00 00 00       	add    $0xac,%eax
f010a96e:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a970:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a973:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a976:	89 d0                	mov    %edx,%eax
f010a978:	01 c0                	add    %eax,%eax
f010a97a:	01 d0                	add    %edx,%eax
f010a97c:	c1 e0 03             	shl    $0x3,%eax
f010a97f:	01 c8                	add    %ecx,%eax
f010a981:	05 b0 00 00 00       	add    $0xb0,%eax
f010a986:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a989:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a98c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a98f:	89 d0                	mov    %edx,%eax
f010a991:	01 c0                	add    %eax,%eax
f010a993:	01 d0                	add    %edx,%eax
f010a995:	c1 e0 03             	shl    $0x3,%eax
f010a998:	01 c8                	add    %ecx,%eax
f010a99a:	05 b4 00 00 00       	add    $0xb4,%eax
f010a99f:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a9a5:	90                   	nop
}
f010a9a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a9a9:	c9                   	leave  
f010a9aa:	c3                   	ret    

f010a9ab <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a9ab:	55                   	push   %ebp
f010a9ac:	89 e5                	mov    %esp,%ebp
f010a9ae:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a9b1:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a9b5:	76 19                	jbe    f010a9d0 <env_table_ws_clear_entry+0x25>
f010a9b7:	68 f8 5f 12 f0       	push   $0xf0125ff8
f010a9bc:	68 29 60 12 f0       	push   $0xf0126029
f010a9c1:	68 4b 01 00 00       	push   $0x14b
f010a9c6:	68 54 5e 12 f0       	push   $0xf0125e54
f010a9cb:	e8 69 59 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a9d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9d3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9d6:	89 d0                	mov    %edx,%eax
f010a9d8:	01 c0                	add    %eax,%eax
f010a9da:	01 d0                	add    %edx,%eax
f010a9dc:	c1 e0 03             	shl    $0x3,%eax
f010a9df:	01 c8                	add    %ecx,%eax
f010a9e1:	05 ac 00 00 00       	add    $0xac,%eax
f010a9e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a9ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9ef:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9f2:	89 d0                	mov    %edx,%eax
f010a9f4:	01 c0                	add    %eax,%eax
f010a9f6:	01 d0                	add    %edx,%eax
f010a9f8:	c1 e0 03             	shl    $0x3,%eax
f010a9fb:	01 c8                	add    %ecx,%eax
f010a9fd:	05 b0 00 00 00       	add    $0xb0,%eax
f010aa02:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010aa05:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa08:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa0b:	89 d0                	mov    %edx,%eax
f010aa0d:	01 c0                	add    %eax,%eax
f010aa0f:	01 d0                	add    %edx,%eax
f010aa11:	c1 e0 03             	shl    $0x3,%eax
f010aa14:	01 c8                	add    %ecx,%eax
f010aa16:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010aa21:	90                   	nop
f010aa22:	c9                   	leave  
f010aa23:	c3                   	ret    

f010aa24 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aa24:	55                   	push   %ebp
f010aa25:	89 e5                	mov    %esp,%ebp
f010aa27:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa2a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa2e:	76 19                	jbe    f010aa49 <env_table_ws_get_virtual_address+0x25>
f010aa30:	68 f8 5f 12 f0       	push   $0xf0125ff8
f010aa35:	68 29 60 12 f0       	push   $0xf0126029
f010aa3a:	68 53 01 00 00       	push   $0x153
f010aa3f:	68 54 5e 12 f0       	push   $0xf0125e54
f010aa44:	e8 f0 58 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aa49:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa4c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa4f:	89 d0                	mov    %edx,%eax
f010aa51:	01 c0                	add    %eax,%eax
f010aa53:	01 d0                	add    %edx,%eax
f010aa55:	c1 e0 03             	shl    $0x3,%eax
f010aa58:	01 c8                	add    %ecx,%eax
f010aa5a:	05 ac 00 00 00       	add    $0xac,%eax
f010aa5f:	8b 00                	mov    (%eax),%eax
f010aa61:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aa64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa67:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aa6c:	c9                   	leave  
f010aa6d:	c3                   	ret    

f010aa6e <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aa6e:	55                   	push   %ebp
f010aa6f:	89 e5                	mov    %esp,%ebp
f010aa71:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa74:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa78:	76 19                	jbe    f010aa93 <env_table_ws_get_time_stamp+0x25>
f010aa7a:	68 f8 5f 12 f0       	push   $0xf0125ff8
f010aa7f:	68 29 60 12 f0       	push   $0xf0126029
f010aa84:	68 5a 01 00 00       	push   $0x15a
f010aa89:	68 54 5e 12 f0       	push   $0xf0125e54
f010aa8e:	e8 a6 58 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010aa93:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa96:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa99:	89 d0                	mov    %edx,%eax
f010aa9b:	01 c0                	add    %eax,%eax
f010aa9d:	01 d0                	add    %edx,%eax
f010aa9f:	c1 e0 03             	shl    $0x3,%eax
f010aaa2:	01 c8                	add    %ecx,%eax
f010aaa4:	05 b4 00 00 00       	add    $0xb4,%eax
f010aaa9:	8b 00                	mov    (%eax),%eax
}
f010aaab:	c9                   	leave  
f010aaac:	c3                   	ret    

f010aaad <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010aaad:	55                   	push   %ebp
f010aaae:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010aab0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aab3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aab6:	89 d0                	mov    %edx,%eax
f010aab8:	01 c0                	add    %eax,%eax
f010aaba:	01 d0                	add    %edx,%eax
f010aabc:	c1 e0 03             	shl    $0x3,%eax
f010aabf:	01 c8                	add    %ecx,%eax
f010aac1:	05 b0 00 00 00       	add    $0xb0,%eax
f010aac6:	8a 00                	mov    (%eax),%al
f010aac8:	0f b6 c0             	movzbl %al,%eax
}
f010aacb:	5d                   	pop    %ebp
f010aacc:	c3                   	ret    

f010aacd <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010aacd:	55                   	push   %ebp
f010aace:	89 e5                	mov    %esp,%ebp
f010aad0:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aad3:	83 ec 04             	sub    $0x4,%esp
f010aad6:	68 73 60 12 f0       	push   $0xf0126073
f010aadb:	68 6a 01 00 00       	push   $0x16a
f010aae0:	68 54 5e 12 f0       	push   $0xf0125e54
f010aae5:	e8 4f 58 ff ff       	call   f0100339 <_panic>

f010aaea <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010aaea:	55                   	push   %ebp
f010aaeb:	89 e5                	mov    %esp,%ebp
f010aaed:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aaf0:	83 ec 04             	sub    $0x4,%esp
f010aaf3:	68 73 60 12 f0       	push   $0xf0126073
f010aaf8:	68 6f 01 00 00       	push   $0x16f
f010aafd:	68 54 5e 12 f0       	push   $0xf0125e54
f010ab02:	e8 32 58 ff ff       	call   f0100339 <_panic>

f010ab07 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ab07:	55                   	push   %ebp
f010ab08:	89 e5                	mov    %esp,%ebp
f010ab0a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010ab0d:	83 ec 04             	sub    $0x4,%esp
f010ab10:	68 84 60 12 f0       	push   $0xf0126084
f010ab15:	6a 22                	push   $0x22
f010ab17:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab1c:	e8 18 58 ff ff       	call   f0100339 <_panic>

f010ab21 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ab21:	55                   	push   %ebp
f010ab22:	89 e5                	mov    %esp,%ebp
f010ab24:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ab27:	83 ec 04             	sub    $0x4,%esp
f010ab2a:	68 d0 60 12 f0       	push   $0xf01260d0
f010ab2f:	6a 35                	push   $0x35
f010ab31:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab36:	e8 fe 57 ff ff       	call   f0100339 <_panic>

f010ab3b <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ab3b:	55                   	push   %ebp
f010ab3c:	89 e5                	mov    %esp,%ebp
f010ab3e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010ab41:	83 ec 04             	sub    $0x4,%esp
f010ab44:	68 00 61 12 f0       	push   $0xf0126100
f010ab49:	6a 45                	push   $0x45
f010ab4b:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab50:	e8 e4 57 ff ff       	call   f0100339 <_panic>

f010ab55 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010ab55:	55                   	push   %ebp
f010ab56:	89 e5                	mov    %esp,%ebp
f010ab58:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010ab5b:	83 ec 04             	sub    $0x4,%esp
f010ab5e:	68 2c 61 12 f0       	push   $0xf012612c
f010ab63:	6a 53                	push   $0x53
f010ab65:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab6a:	e8 ca 57 ff ff       	call   f0100339 <_panic>

f010ab6f <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ab6f:	55                   	push   %ebp
f010ab70:	89 e5                	mov    %esp,%ebp
f010ab72:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ab75:	83 ec 04             	sub    $0x4,%esp
f010ab78:	68 5c 61 12 f0       	push   $0xf012615c
f010ab7d:	6a 5d                	push   $0x5d
f010ab7f:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab84:	e8 b0 57 ff ff       	call   f0100339 <_panic>

f010ab89 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010ab89:	55                   	push   %ebp
f010ab8a:	89 e5                	mov    %esp,%ebp
f010ab8c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010ab8f:	83 ec 04             	sub    $0x4,%esp
f010ab92:	68 94 61 12 f0       	push   $0xf0126194
f010ab97:	6a 6a                	push   $0x6a
f010ab99:	68 b2 60 12 f0       	push   $0xf01260b2
f010ab9e:	e8 96 57 ff ff       	call   f0100339 <_panic>

f010aba3 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010aba3:	55                   	push   %ebp
f010aba4:	89 e5                	mov    %esp,%ebp
f010aba6:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010aba9:	e8 98 0e 00 00       	call   f010ba46 <get_cpu_proc>
f010abae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010abb1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010abb5:	7e 61                	jle    f010ac18 <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010abb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010abba:	c1 e0 0c             	shl    $0xc,%eax
f010abbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010abc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abc3:	8b 40 7c             	mov    0x7c(%eax),%eax
f010abc6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010abc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abcc:	8b 50 7c             	mov    0x7c(%eax),%edx
f010abcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010abd2:	01 c2                	add    %eax,%edx
f010abd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abd7:	8b 40 78             	mov    0x78(%eax),%eax
f010abda:	39 c2                	cmp    %eax,%edx
f010abdc:	77 09                	ja     f010abe7 <sys_sbrk+0x44>
f010abde:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f010abe3:	85 c0                	test   %eax,%eax
f010abe5:	75 07                	jne    f010abee <sys_sbrk+0x4b>
f010abe7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010abec:	eb 3d                	jmp    f010ac2b <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010abee:	83 ec 04             	sub    $0x4,%esp
f010abf1:	ff 75 f0             	pushl  -0x10(%ebp)
f010abf4:	ff 75 ec             	pushl  -0x14(%ebp)
f010abf7:	ff 75 f4             	pushl  -0xc(%ebp)
f010abfa:	e8 2e 00 00 00       	call   f010ac2d <allocate_user_mem>
f010abff:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010ac02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac05:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ac08:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac0b:	01 c2                	add    %eax,%edx
f010ac0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac10:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010ac13:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac16:	eb 13                	jmp    f010ac2b <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010ac18:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac1c:	75 08                	jne    f010ac26 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010ac1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac21:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ac24:	eb 05                	jmp    f010ac2b <sys_sbrk+0x88>
	}

	return (void *)-1;
f010ac26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010ac2b:	c9                   	leave  
f010ac2c:	c3                   	ret    

f010ac2d <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac2d:	55                   	push   %ebp
f010ac2e:	89 e5                	mov    %esp,%ebp
f010ac30:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ac33:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ac3a:	8b 55 10             	mov    0x10(%ebp),%edx
f010ac3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac40:	01 d0                	add    %edx,%eax
f010ac42:	48                   	dec    %eax
f010ac43:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ac46:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac49:	ba 00 00 00 00       	mov    $0x0,%edx
f010ac4e:	f7 75 f0             	divl   -0x10(%ebp)
f010ac51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac54:	29 d0                	sub    %edx,%eax
f010ac56:	c1 e8 0c             	shr    $0xc,%eax
f010ac59:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010ac5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ac63:	eb 78                	jmp    f010acdd <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010ac65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac68:	c1 e0 0c             	shl    $0xc,%eax
f010ac6b:	89 c2                	mov    %eax,%edx
f010ac6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac70:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010ac73:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac76:	8b 40 64             	mov    0x64(%eax),%eax
f010ac79:	83 ec 04             	sub    $0x4,%esp
f010ac7c:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010ac7f:	52                   	push   %edx
f010ac80:	51                   	push   %ecx
f010ac81:	50                   	push   %eax
f010ac82:	e8 68 d7 ff ff       	call   f01083ef <get_page_table>
f010ac87:	83 c4 10             	add    $0x10,%esp
f010ac8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010ac8d:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010ac91:	75 23                	jne    f010acb6 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010ac93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac96:	c1 e0 0c             	shl    $0xc,%eax
f010ac99:	89 c2                	mov    %eax,%edx
f010ac9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac9e:	01 c2                	add    %eax,%edx
f010aca0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aca3:	8b 40 64             	mov    0x64(%eax),%eax
f010aca6:	83 ec 08             	sub    $0x8,%esp
f010aca9:	52                   	push   %edx
f010acaa:	50                   	push   %eax
f010acab:	e8 95 d8 ff ff       	call   f0108545 <create_page_table>
f010acb0:	83 c4 10             	add    $0x10,%esp
f010acb3:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010acb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acb9:	c1 e0 0c             	shl    $0xc,%eax
f010acbc:	89 c2                	mov    %eax,%edx
f010acbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acc1:	01 c2                	add    %eax,%edx
f010acc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010acc6:	8b 40 64             	mov    0x64(%eax),%eax
f010acc9:	6a 00                	push   $0x0
f010accb:	68 00 02 00 00       	push   $0x200
f010acd0:	52                   	push   %edx
f010acd1:	50                   	push   %eax
f010acd2:	e8 af ef ff ff       	call   f0109c86 <pt_set_page_permissions>
f010acd7:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010acda:	ff 45 f4             	incl   -0xc(%ebp)
f010acdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ace0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ace3:	72 80                	jb     f010ac65 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010ace5:	90                   	nop
f010ace6:	c9                   	leave  
f010ace7:	c3                   	ret    

f010ace8 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ace8:	55                   	push   %ebp
f010ace9:	89 e5                	mov    %esp,%ebp
f010aceb:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010acee:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010acf5:	8b 55 10             	mov    0x10(%ebp),%edx
f010acf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010acfb:	01 d0                	add    %edx,%eax
f010acfd:	48                   	dec    %eax
f010acfe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ad01:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad04:	ba 00 00 00 00       	mov    $0x0,%edx
f010ad09:	f7 75 f0             	divl   -0x10(%ebp)
f010ad0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad0f:	29 d0                	sub    %edx,%eax
f010ad11:	c1 e8 0c             	shr    $0xc,%eax
f010ad14:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010ad17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ad1e:	e9 86 00 00 00       	jmp    f010ada9 <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010ad23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad26:	c1 e0 0c             	shl    $0xc,%eax
f010ad29:	89 c2                	mov    %eax,%edx
f010ad2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad2e:	01 c2                	add    %eax,%edx
f010ad30:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad33:	8b 40 64             	mov    0x64(%eax),%eax
f010ad36:	68 00 02 00 00       	push   $0x200
f010ad3b:	6a 00                	push   $0x0
f010ad3d:	52                   	push   %edx
f010ad3e:	50                   	push   %eax
f010ad3f:	e8 42 ef ff ff       	call   f0109c86 <pt_set_page_permissions>
f010ad44:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010ad47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad4a:	c1 e0 0c             	shl    $0xc,%eax
f010ad4d:	89 c2                	mov    %eax,%edx
f010ad4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad52:	01 d0                	add    %edx,%eax
f010ad54:	83 ec 08             	sub    $0x8,%esp
f010ad57:	50                   	push   %eax
f010ad58:	ff 75 08             	pushl  0x8(%ebp)
f010ad5b:	e8 81 97 ff ff       	call   f01044e1 <pf_read_env_page>
f010ad60:	83 c4 10             	add    $0x10,%esp
f010ad63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010ad66:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010ad6a:	75 1e                	jne    f010ad8a <free_user_mem+0xa2>
f010ad6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad6f:	c1 e0 0c             	shl    $0xc,%eax
f010ad72:	89 c2                	mov    %eax,%edx
f010ad74:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad77:	01 d0                	add    %edx,%eax
f010ad79:	83 ec 08             	sub    $0x8,%esp
f010ad7c:	50                   	push   %eax
f010ad7d:	ff 75 08             	pushl  0x8(%ebp)
f010ad80:	e8 a2 f1 ff ff       	call   f0109f27 <env_page_ws_invalidate>
f010ad85:	83 c4 10             	add    $0x10,%esp
f010ad88:	eb 1c                	jmp    f010ada6 <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010ad8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad8d:	c1 e0 0c             	shl    $0xc,%eax
f010ad90:	89 c2                	mov    %eax,%edx
f010ad92:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad95:	01 d0                	add    %edx,%eax
f010ad97:	83 ec 08             	sub    $0x8,%esp
f010ad9a:	50                   	push   %eax
f010ad9b:	ff 75 08             	pushl  0x8(%ebp)
f010ad9e:	e8 01 98 ff ff       	call   f01045a4 <pf_remove_env_page>
f010ada3:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010ada6:	ff 45 f4             	incl   -0xc(%ebp)
f010ada9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010adac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010adaf:	0f 82 6e ff ff ff    	jb     f010ad23 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010adb5:	90                   	nop
f010adb6:	c9                   	leave  
f010adb7:	c3                   	ret    

f010adb8 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010adb8:	55                   	push   %ebp
f010adb9:	89 e5                	mov    %esp,%ebp
f010adbb:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010adbe:	83 ec 04             	sub    $0x4,%esp
f010adc1:	68 cc 61 12 f0       	push   $0xf01261cc
f010adc6:	68 e0 00 00 00       	push   $0xe0
f010adcb:	68 b2 60 12 f0       	push   $0xf01260b2
f010add0:	e8 64 55 ff ff       	call   f0100339 <_panic>

f010add5 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010add5:	55                   	push   %ebp
f010add6:	89 e5                	mov    %esp,%ebp
f010add8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010addb:	83 ec 04             	sub    $0x4,%esp
f010adde:	68 0c 62 12 f0       	push   $0xf012620c
f010ade3:	68 ea 00 00 00       	push   $0xea
f010ade8:	68 b2 60 12 f0       	push   $0xf01260b2
f010aded:	e8 47 55 ff ff       	call   f0100339 <_panic>

f010adf2 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010adf2:	55                   	push   %ebp
f010adf3:	89 e5                	mov    %esp,%ebp
f010adf5:	56                   	push   %esi
f010adf6:	53                   	push   %ebx
f010adf7:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010adfa:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010ae01:	e9 b0 01 00 00       	jmp    f010afb6 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010ae06:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010ae0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae0f:	89 d0                	mov    %edx,%eax
f010ae11:	c1 e0 03             	shl    $0x3,%eax
f010ae14:	01 d0                	add    %edx,%eax
f010ae16:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae1d:	01 d8                	add    %ebx,%eax
f010ae1f:	01 c0                	add    %eax,%eax
f010ae21:	01 d0                	add    %edx,%eax
f010ae23:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae2a:	01 d8                	add    %ebx,%eax
f010ae2c:	01 d0                	add    %edx,%eax
f010ae2e:	01 c8                	add    %ecx,%eax
f010ae30:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ae37:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010ae3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae40:	89 d0                	mov    %edx,%eax
f010ae42:	c1 e0 03             	shl    $0x3,%eax
f010ae45:	01 d0                	add    %edx,%eax
f010ae47:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae4e:	01 d8                	add    %ebx,%eax
f010ae50:	01 c0                	add    %eax,%eax
f010ae52:	01 d0                	add    %edx,%eax
f010ae54:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae5b:	01 d8                	add    %ebx,%eax
f010ae5d:	01 d0                	add    %edx,%eax
f010ae5f:	01 c8                	add    %ecx,%eax
f010ae61:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010ae68:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010ae6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae71:	89 d0                	mov    %edx,%eax
f010ae73:	c1 e0 03             	shl    $0x3,%eax
f010ae76:	01 d0                	add    %edx,%eax
f010ae78:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae7f:	01 d8                	add    %ebx,%eax
f010ae81:	01 c0                	add    %eax,%eax
f010ae83:	01 d0                	add    %edx,%eax
f010ae85:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae8c:	01 d8                	add    %ebx,%eax
f010ae8e:	01 d0                	add    %edx,%eax
f010ae90:	01 c8                	add    %ecx,%eax
f010ae92:	85 c0                	test   %eax,%eax
f010ae94:	75 14                	jne    f010aeaa <env_init+0xb8>
f010ae96:	83 ec 04             	sub    $0x4,%esp
f010ae99:	68 38 62 12 f0       	push   $0xf0126238
f010ae9e:	6a 65                	push   $0x65
f010aea0:	68 5b 62 12 f0       	push   $0xf012625b
f010aea5:	e8 8f 54 ff ff       	call   f0100339 <_panic>
f010aeaa:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010aeb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aeb3:	89 d0                	mov    %edx,%eax
f010aeb5:	c1 e0 03             	shl    $0x3,%eax
f010aeb8:	01 d0                	add    %edx,%eax
f010aeba:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aec1:	01 d8                	add    %ebx,%eax
f010aec3:	01 c0                	add    %eax,%eax
f010aec5:	01 d0                	add    %edx,%eax
f010aec7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aece:	01 d8                	add    %ebx,%eax
f010aed0:	01 d0                	add    %edx,%eax
f010aed2:	01 c8                	add    %ecx,%eax
f010aed4:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010aeda:	89 50 08             	mov    %edx,0x8(%eax)
f010aedd:	8b 40 08             	mov    0x8(%eax),%eax
f010aee0:	85 c0                	test   %eax,%eax
f010aee2:	74 35                	je     f010af19 <env_init+0x127>
f010aee4:	8b 0d f4 8a 69 f0    	mov    0xf0698af4,%ecx
f010aeea:	8b 1d f0 8a 69 f0    	mov    0xf0698af0,%ebx
f010aef0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aef3:	89 d0                	mov    %edx,%eax
f010aef5:	c1 e0 03             	shl    $0x3,%eax
f010aef8:	01 d0                	add    %edx,%eax
f010aefa:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010af01:	01 f0                	add    %esi,%eax
f010af03:	01 c0                	add    %eax,%eax
f010af05:	01 d0                	add    %edx,%eax
f010af07:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010af0e:	01 f0                	add    %esi,%eax
f010af10:	01 d0                	add    %edx,%eax
f010af12:	01 d8                	add    %ebx,%eax
f010af14:	89 41 0c             	mov    %eax,0xc(%ecx)
f010af17:	eb 2f                	jmp    f010af48 <env_init+0x156>
f010af19:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010af1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af22:	89 d0                	mov    %edx,%eax
f010af24:	c1 e0 03             	shl    $0x3,%eax
f010af27:	01 d0                	add    %edx,%eax
f010af29:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af30:	01 d8                	add    %ebx,%eax
f010af32:	01 c0                	add    %eax,%eax
f010af34:	01 d0                	add    %edx,%eax
f010af36:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af3d:	01 d8                	add    %ebx,%eax
f010af3f:	01 d0                	add    %edx,%eax
f010af41:	01 c8                	add    %ecx,%eax
f010af43:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010af48:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010af4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af51:	89 d0                	mov    %edx,%eax
f010af53:	c1 e0 03             	shl    $0x3,%eax
f010af56:	01 d0                	add    %edx,%eax
f010af58:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af5f:	01 d8                	add    %ebx,%eax
f010af61:	01 c0                	add    %eax,%eax
f010af63:	01 d0                	add    %edx,%eax
f010af65:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af6c:	01 d8                	add    %ebx,%eax
f010af6e:	01 d0                	add    %edx,%eax
f010af70:	01 c8                	add    %ecx,%eax
f010af72:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010af77:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010af7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af80:	89 d0                	mov    %edx,%eax
f010af82:	c1 e0 03             	shl    $0x3,%eax
f010af85:	01 d0                	add    %edx,%eax
f010af87:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af8e:	01 d8                	add    %ebx,%eax
f010af90:	01 c0                	add    %eax,%eax
f010af92:	01 d0                	add    %edx,%eax
f010af94:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af9b:	01 d8                	add    %ebx,%eax
f010af9d:	01 d0                	add    %edx,%eax
f010af9f:	01 c8                	add    %ecx,%eax
f010afa1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010afa8:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010afad:	40                   	inc    %eax
f010afae:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010afb3:	ff 4d f4             	decl   -0xc(%ebp)
f010afb6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010afba:	0f 89 46 fe ff ff    	jns    f010ae06 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010afc0:	90                   	nop
f010afc1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010afc4:	5b                   	pop    %ebx
f010afc5:	5e                   	pop    %esi
f010afc6:	5d                   	pop    %ebp
f010afc7:	c3                   	ret    

f010afc8 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010afc8:	55                   	push   %ebp
f010afc9:	89 e5                	mov    %esp,%ebp
f010afcb:	57                   	push   %edi
f010afcc:	56                   	push   %esi
f010afcd:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010afd3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010afda:	83 ec 0c             	sub    $0xc,%esp
f010afdd:	ff 75 08             	pushl  0x8(%ebp)
f010afe0:	e8 b8 1e 00 00       	call   f010ce9d <get_user_program_info>
f010afe5:	83 c4 10             	add    $0x10,%esp
f010afe8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010afeb:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010afef:	75 0a                	jne    f010affb <env_create+0x33>
	{
		return NULL;
f010aff1:	b8 00 00 00 00       	mov    $0x0,%eax
f010aff6:	e9 aa 09 00 00       	jmp    f010b9a5 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010affb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010affe:	8b 40 08             	mov    0x8(%eax),%eax
f010b001:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b004:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b00b:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b00e:	83 ec 0c             	sub    $0xc,%esp
f010b011:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b017:	50                   	push   %eax
f010b018:	e8 96 0e 00 00       	call   f010beb3 <allocate_environment>
f010b01d:	83 c4 10             	add    $0x10,%esp
f010b020:	85 c0                	test   %eax,%eax
f010b022:	79 0a                	jns    f010b02e <env_create+0x66>
	{
		return NULL;
f010b024:	b8 00 00 00 00       	mov    $0x0,%eax
f010b029:	e9 77 09 00 00       	jmp    f010b9a5 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b02e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b031:	8b 00                	mov    (%eax),%eax
f010b033:	83 ec 0c             	sub    $0xc,%esp
f010b036:	50                   	push   %eax
f010b037:	e8 46 4c 01 00       	call   f011fc82 <strlen>
f010b03c:	83 c4 10             	add    $0x10,%esp
f010b03f:	83 f8 3f             	cmp    $0x3f,%eax
f010b042:	7f 1d                	jg     f010b061 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b044:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b047:	8b 00                	mov    (%eax),%eax
f010b049:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b04f:	83 c2 20             	add    $0x20,%edx
f010b052:	83 ec 08             	sub    $0x8,%esp
f010b055:	50                   	push   %eax
f010b056:	52                   	push   %edx
f010b057:	e8 75 4c 01 00       	call   f011fcd1 <strcpy>
f010b05c:	83 c4 10             	add    $0x10,%esp
f010b05f:	eb 1d                	jmp    f010b07e <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b061:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b064:	8b 00                	mov    (%eax),%eax
f010b066:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b06c:	83 c2 20             	add    $0x20,%edx
f010b06f:	83 ec 04             	sub    $0x4,%esp
f010b072:	6a 3f                	push   $0x3f
f010b074:	50                   	push   %eax
f010b075:	52                   	push   %edx
f010b076:	e8 84 4c 01 00       	call   f011fcff <strncpy>
f010b07b:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b07e:	e8 fc 13 00 00       	call   f010c47f <create_user_directory>
f010b083:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b086:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b089:	83 ec 0c             	sub    $0xc,%esp
f010b08c:	50                   	push   %eax
f010b08d:	e8 00 e8 ff ff       	call   f0109892 <kheap_physical_address>
f010b092:	83 c4 10             	add    $0x10,%esp
f010b095:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b098:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b09e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b0a1:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b0a7:	83 ec 0c             	sub    $0xc,%esp
f010b0aa:	6a 02                	push   $0x2
f010b0ac:	e8 d0 45 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010b0b1:	83 c4 10             	add    $0x10,%esp
f010b0b4:	85 c0                	test   %eax,%eax
f010b0b6:	74 21                	je     f010b0d9 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b0b8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0be:	8b 55 10             	mov    0x10(%ebp),%edx
f010b0c1:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b0c7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b0d0:	2b 55 10             	sub    0x10(%ebp),%edx
f010b0d3:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b0d9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b0dd:	75 12                	jne    f010b0f1 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b0df:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0e5:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b0ec:	00 00 00 
f010b0ef:	eb 0f                	jmp    f010b100 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b0f1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0f7:	8b 55 14             	mov    0x14(%ebp),%edx
f010b0fa:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b100:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b106:	83 ec 04             	sub    $0x4,%esp
f010b109:	ff 75 bc             	pushl  -0x44(%ebp)
f010b10c:	ff 75 c0             	pushl  -0x40(%ebp)
f010b10f:	50                   	push   %eax
f010b110:	e8 c8 14 00 00       	call   f010c5dd <initialize_environment>
f010b115:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b118:	e8 b2 c0 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b11d:	0f 20 d8             	mov    %cr3,%eax
f010b120:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b123:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b126:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b129:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b12f:	8b 40 68             	mov    0x68(%eax),%eax
f010b132:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b138:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b13e:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b141:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b148:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b14f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b155:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b15b:	48                   	dec    %eax
f010b15c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b15f:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b166:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b169:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b16f:	83 ec 08             	sub    $0x8,%esp
f010b172:	ff 75 c8             	pushl  -0x38(%ebp)
f010b175:	50                   	push   %eax
f010b176:	e8 34 1a 00 00       	call   f010cbaf <PROGRAM_SEGMENT_FIRST>
f010b17b:	83 c4 0c             	add    $0xc,%esp
f010b17e:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b184:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b18a:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b18f:	89 c7                	mov    %eax,%edi
f010b191:	89 d6                	mov    %edx,%esi
f010b193:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b195:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b19b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b19e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b1a1:	8b 40 10             	mov    0x10(%eax),%eax
f010b1a4:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b1a7:	75 07                	jne    f010b1b0 <env_create+0x1e8>
f010b1a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b1b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b1b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b1b6:	e9 fa 02 00 00       	jmp    f010b4b5 <env_create+0x4ed>
		{
			segment_counter++;
f010b1bb:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b1be:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b1c5:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b1c8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1ce:	83 ec 0c             	sub    $0xc,%esp
f010b1d1:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b1d7:	52                   	push   %edx
f010b1d8:	ff 75 ec             	pushl  -0x14(%ebp)
f010b1db:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b1e1:	52                   	push   %edx
f010b1e2:	ff 75 f4             	pushl  -0xc(%ebp)
f010b1e5:	50                   	push   %eax
f010b1e6:	e8 86 0d 00 00       	call   f010bf71 <program_segment_alloc_map_copy_workingset>
f010b1eb:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b1ee:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b1f4:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b1f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1fa:	8b 00                	mov    (%eax),%eax
f010b1fc:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b1ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b202:	8b 40 0c             	mov    0xc(%eax),%eax
f010b205:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b208:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b20b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b20e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b211:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b216:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b219:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b220:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b223:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b226:	01 d0                	add    %edx,%eax
f010b228:	48                   	dec    %eax
f010b229:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b22c:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b22f:	ba 00 00 00 00       	mov    $0x0,%edx
f010b234:	f7 75 9c             	divl   -0x64(%ebp)
f010b237:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b23a:	29 d0                	sub    %edx,%eax
f010b23c:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b23f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b242:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b245:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b248:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b24b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b24e:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b254:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b257:	01 d0                	add    %edx,%eax
f010b259:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b25c:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b260:	74 73                	je     f010b2d5 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b262:	a1 4c 2d 6c f0       	mov    0xf06c2d4c,%eax
f010b267:	83 ec 04             	sub    $0x4,%esp
f010b26a:	68 00 10 00 00       	push   $0x1000
f010b26f:	6a 00                	push   $0x0
f010b271:	50                   	push   %eax
f010b272:	e8 f9 4b 01 00       	call   f011fe70 <memset>
f010b277:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b27a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b27d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b280:	eb 13                	jmp    f010b295 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b282:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b285:	8a 10                	mov    (%eax),%dl
f010b287:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b28a:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b28c:	ff 45 dc             	incl   -0x24(%ebp)
f010b28f:	ff 45 e4             	incl   -0x1c(%ebp)
f010b292:	ff 45 e0             	incl   -0x20(%ebp)
f010b295:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b298:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b29b:	72 e5                	jb     f010b282 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b29d:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b2a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2a9:	83 ec 04             	sub    $0x4,%esp
f010b2ac:	52                   	push   %edx
f010b2ad:	ff 75 a0             	pushl  -0x60(%ebp)
f010b2b0:	50                   	push   %eax
f010b2b1:	e8 7b 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b2b6:	83 c4 10             	add    $0x10,%esp
f010b2b9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b2bc:	75 17                	jne    f010b2d5 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b2be:	83 ec 04             	sub    $0x4,%esp
f010b2c1:	68 78 62 12 f0       	push   $0xf0126278
f010b2c6:	68 f5 00 00 00       	push   $0xf5
f010b2cb:	68 5b 62 12 f0       	push   $0xf012625b
f010b2d0:	e8 64 50 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b2d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b2d8:	8b 50 04             	mov    0x4(%eax),%edx
f010b2db:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b2de:	01 d0                	add    %edx,%eax
f010b2e0:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b2e3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b2e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b2eb:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b2ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b2f1:	8b 50 04             	mov    0x4(%eax),%edx
f010b2f4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b2f7:	01 d0                	add    %edx,%eax
f010b2f9:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b2fc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b2ff:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b302:	eb 43                	jmp    f010b347 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b304:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b307:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b30d:	83 ec 04             	sub    $0x4,%esp
f010b310:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b313:	52                   	push   %edx
f010b314:	50                   	push   %eax
f010b315:	e8 17 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b31a:	83 c4 10             	add    $0x10,%esp
f010b31d:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b320:	75 17                	jne    f010b339 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b322:	83 ec 04             	sub    $0x4,%esp
f010b325:	68 78 62 12 f0       	push   $0xf0126278
f010b32a:	68 02 01 00 00       	push   $0x102
f010b32f:	68 5b 62 12 f0       	push   $0xf012625b
f010b334:	e8 00 50 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b339:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b340:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b347:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b34a:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b34d:	72 b5                	jb     f010b304 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b34f:	a1 4c 2d 6c f0       	mov    0xf06c2d4c,%eax
f010b354:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b357:	83 ec 04             	sub    $0x4,%esp
f010b35a:	68 00 10 00 00       	push   $0x1000
f010b35f:	6a 00                	push   $0x0
f010b361:	ff 75 e0             	pushl  -0x20(%ebp)
f010b364:	e8 07 4b 01 00       	call   f011fe70 <memset>
f010b369:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b36c:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b36f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b372:	eb 13                	jmp    f010b387 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b374:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b377:	8a 10                	mov    (%eax),%dl
f010b379:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b37c:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b37e:	ff 45 dc             	incl   -0x24(%ebp)
f010b381:	ff 45 e4             	incl   -0x1c(%ebp)
f010b384:	ff 45 e0             	incl   -0x20(%ebp)
f010b387:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b38a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b38d:	72 e5                	jb     f010b374 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b38f:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b395:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b39b:	83 ec 04             	sub    $0x4,%esp
f010b39e:	52                   	push   %edx
f010b39f:	ff 75 88             	pushl  -0x78(%ebp)
f010b3a2:	50                   	push   %eax
f010b3a3:	e8 89 8e ff ff       	call   f0104231 <pf_add_env_page>
f010b3a8:	83 c4 10             	add    $0x10,%esp
f010b3ab:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b3ae:	75 17                	jne    f010b3c7 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b3b0:	83 ec 04             	sub    $0x4,%esp
f010b3b3:	68 78 62 12 f0       	push   $0xf0126278
f010b3b8:	68 11 01 00 00       	push   $0x111
f010b3bd:	68 5b 62 12 f0       	push   $0xf012625b
f010b3c2:	e8 72 4f ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b3c7:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b3ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3d1:	8b 50 04             	mov    0x4(%eax),%edx
f010b3d4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b3d7:	01 c2                	add    %eax,%edx
f010b3d9:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b3dc:	01 d0                	add    %edx,%eax
f010b3de:	48                   	dec    %eax
f010b3df:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b3e5:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b3eb:	ba 00 00 00 00       	mov    $0x0,%edx
f010b3f0:	f7 75 80             	divl   -0x80(%ebp)
f010b3f3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b3f9:	29 d0                	sub    %edx,%eax
f010b3fb:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b3fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b401:	8b 50 08             	mov    0x8(%eax),%edx
f010b404:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b407:	01 d0                	add    %edx,%eax
f010b409:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b40c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b412:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b419:	eb 41                	jmp    f010b45c <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b41b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b421:	83 ec 04             	sub    $0x4,%esp
f010b424:	6a 01                	push   $0x1
f010b426:	ff 75 d8             	pushl  -0x28(%ebp)
f010b429:	50                   	push   %eax
f010b42a:	e8 d1 8c ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b42f:	83 c4 10             	add    $0x10,%esp
f010b432:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b435:	75 17                	jne    f010b44e <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b437:	83 ec 04             	sub    $0x4,%esp
f010b43a:	68 78 62 12 f0       	push   $0xf0126278
f010b43f:	68 1e 01 00 00       	push   $0x11e
f010b444:	68 5b 62 12 f0       	push   $0xf012625b
f010b449:	e8 eb 4e ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b44e:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b455:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b45c:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b463:	10 00 00 
f010b466:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b46c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b472:	01 d0                	add    %edx,%eax
f010b474:	48                   	dec    %eax
f010b475:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b47b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b481:	ba 00 00 00 00       	mov    $0x0,%edx
f010b486:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b48c:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b492:	29 d0                	sub    %edx,%eax
f010b494:	89 c2                	mov    %eax,%edx
f010b496:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b499:	39 c2                	cmp    %eax,%edx
f010b49b:	0f 87 7a ff ff ff    	ja     f010b41b <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b4a1:	83 ec 08             	sub    $0x8,%esp
f010b4a4:	ff 75 c8             	pushl  -0x38(%ebp)
f010b4a7:	ff 75 f4             	pushl  -0xc(%ebp)
f010b4aa:	e8 f5 15 00 00       	call   f010caa4 <PROGRAM_SEGMENT_NEXT>
f010b4af:	83 c4 10             	add    $0x10,%esp
f010b4b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b4b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b4b9:	0f 85 fc fc ff ff    	jne    f010b1bb <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b4bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4c5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b4cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b4ce:	eb 77                	jmp    f010b547 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b4d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b4d3:	8b 00                	mov    (%eax),%eax
f010b4d5:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b4db:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4e1:	8b 40 64             	mov    0x64(%eax),%eax
f010b4e4:	83 ec 04             	sub    $0x4,%esp
f010b4e7:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b4ed:	52                   	push   %edx
f010b4ee:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b4f4:	50                   	push   %eax
f010b4f5:	e8 f5 ce ff ff       	call   f01083ef <get_page_table>
f010b4fa:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b4fd:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b503:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b509:	c1 ea 0c             	shr    $0xc,%edx
f010b50c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b512:	c1 e2 02             	shl    $0x2,%edx
f010b515:	01 d0                	add    %edx,%eax
f010b517:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b51d:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b523:	c1 e9 0c             	shr    $0xc,%ecx
f010b526:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b52c:	c1 e1 02             	shl    $0x2,%ecx
f010b52f:	01 ca                	add    %ecx,%edx
f010b531:	8b 12                	mov    (%edx),%edx
f010b533:	83 e2 bf             	and    $0xffffffbf,%edx
f010b536:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b538:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b53e:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b544:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b547:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b54d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b551:	74 08                	je     f010b55b <env_create+0x593>
f010b553:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b556:	8b 52 10             	mov    0x10(%edx),%edx
f010b559:	eb 05                	jmp    f010b560 <env_create+0x598>
f010b55b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b560:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b566:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b56c:	85 c0                	test   %eax,%eax
f010b56e:	0f 85 5c ff ff ff    	jne    f010b4d0 <env_create+0x508>
f010b574:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b578:	0f 85 52 ff ff ff    	jne    f010b4d0 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b57e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b581:	8b 50 08             	mov    0x8(%eax),%edx
f010b584:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b58a:	83 ec 08             	sub    $0x8,%esp
f010b58d:	52                   	push   %edx
f010b58e:	50                   	push   %eax
f010b58f:	e8 d0 14 00 00       	call   f010ca64 <set_environment_entry_point>
f010b594:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b597:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b59d:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b5a4:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b5ab:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b5ae:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b5b5:	e9 42 03 00 00       	jmp    f010b8fc <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b5ba:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b5c1:	00 00 00 
			allocate_frame(&pp);
f010b5c4:	83 ec 0c             	sub    $0xc,%esp
f010b5c7:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b5cd:	50                   	push   %eax
f010b5ce:	e8 df cb ff ff       	call   f01081b2 <allocate_frame>
f010b5d3:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b5d6:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b5dc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5e2:	8b 40 64             	mov    0x64(%eax),%eax
f010b5e5:	6a 06                	push   $0x6
f010b5e7:	ff 75 d0             	pushl  -0x30(%ebp)
f010b5ea:	52                   	push   %edx
f010b5eb:	50                   	push   %eax
f010b5ec:	e8 92 d2 ff ff       	call   f0108883 <loadtime_map_frame>
f010b5f1:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b5f4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b5f7:	83 ec 04             	sub    $0x4,%esp
f010b5fa:	68 00 10 00 00       	push   $0x1000
f010b5ff:	6a 00                	push   $0x0
f010b601:	50                   	push   %eax
f010b602:	e8 69 48 01 00       	call   f011fe70 <memset>
f010b607:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b60a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b610:	83 ec 08             	sub    $0x8,%esp
f010b613:	ff 75 d0             	pushl  -0x30(%ebp)
f010b616:	50                   	push   %eax
f010b617:	e8 a0 e8 ff ff       	call   f0109ebc <env_page_ws_list_create_element>
f010b61c:	83 c4 10             	add    $0x10,%esp
f010b61f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b622:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b626:	75 17                	jne    f010b63f <env_create+0x677>
f010b628:	83 ec 04             	sub    $0x4,%esp
f010b62b:	68 c0 62 12 f0       	push   $0xf01262c0
f010b630:	68 5d 01 00 00       	push   $0x15d
f010b635:	68 5b 62 12 f0       	push   $0xf012625b
f010b63a:	e8 fa 4c ff ff       	call   f0100339 <_panic>
f010b63f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b645:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b64b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b64e:	89 50 14             	mov    %edx,0x14(%eax)
f010b651:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b654:	8b 40 14             	mov    0x14(%eax),%eax
f010b657:	85 c0                	test   %eax,%eax
f010b659:	74 14                	je     f010b66f <env_create+0x6a7>
f010b65b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b661:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b667:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b66a:	89 50 10             	mov    %edx,0x10(%eax)
f010b66d:	eb 0f                	jmp    f010b67e <env_create+0x6b6>
f010b66f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b675:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b678:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b67e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b684:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b687:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b68d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b690:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b697:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b69d:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b6a3:	42                   	inc    %edx
f010b6a4:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b6aa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6b0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b6b6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6bc:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b6c2:	39 c2                	cmp    %eax,%edx
f010b6c4:	75 1a                	jne    f010b6e0 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b6c6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6cc:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b6d2:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b6d8:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b6de:	eb 10                	jmp    f010b6f0 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b6e0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6e6:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b6ed:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b6f0:	83 ec 0c             	sub    $0xc,%esp
f010b6f3:	6a 02                	push   $0x2
f010b6f5:	e8 87 3f 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010b6fa:	83 c4 10             	add    $0x10,%esp
f010b6fd:	85 c0                	test   %eax,%eax
f010b6ff:	0f 84 d3 01 00 00    	je     f010b8d8 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b705:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b709:	75 17                	jne    f010b722 <env_create+0x75a>
f010b70b:	83 ec 04             	sub    $0x4,%esp
f010b70e:	68 e3 62 12 f0       	push   $0xf01262e3
f010b713:	68 6a 01 00 00       	push   $0x16a
f010b718:	68 5b 62 12 f0       	push   $0xf012625b
f010b71d:	e8 17 4c ff ff       	call   f0100339 <_panic>
f010b722:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b725:	8b 40 10             	mov    0x10(%eax),%eax
f010b728:	85 c0                	test   %eax,%eax
f010b72a:	74 11                	je     f010b73d <env_create+0x775>
f010b72c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b72f:	8b 40 10             	mov    0x10(%eax),%eax
f010b732:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b735:	8b 52 14             	mov    0x14(%edx),%edx
f010b738:	89 50 14             	mov    %edx,0x14(%eax)
f010b73b:	eb 12                	jmp    f010b74f <env_create+0x787>
f010b73d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b743:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b746:	8b 52 14             	mov    0x14(%edx),%edx
f010b749:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b74f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b752:	8b 40 14             	mov    0x14(%eax),%eax
f010b755:	85 c0                	test   %eax,%eax
f010b757:	74 11                	je     f010b76a <env_create+0x7a2>
f010b759:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b75c:	8b 40 14             	mov    0x14(%eax),%eax
f010b75f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b762:	8b 52 10             	mov    0x10(%edx),%edx
f010b765:	89 50 10             	mov    %edx,0x10(%eax)
f010b768:	eb 12                	jmp    f010b77c <env_create+0x7b4>
f010b76a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b770:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b773:	8b 52 10             	mov    0x10(%edx),%edx
f010b776:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b77c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b77f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b786:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b789:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b790:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b796:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b79c:	4a                   	dec    %edx
f010b79d:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b7a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7a9:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b7af:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7b5:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b7bb:	39 c2                	cmp    %eax,%edx
f010b7bd:	0f 83 8d 00 00 00    	jae    f010b850 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b7c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b7c7:	75 17                	jne    f010b7e0 <env_create+0x818>
f010b7c9:	83 ec 04             	sub    $0x4,%esp
f010b7cc:	68 38 62 12 f0       	push   $0xf0126238
f010b7d1:	68 6f 01 00 00       	push   $0x16f
f010b7d6:	68 5b 62 12 f0       	push   $0xf012625b
f010b7db:	e8 59 4b ff ff       	call   f0100339 <_panic>
f010b7e0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7e6:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b7ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7ef:	89 50 10             	mov    %edx,0x10(%eax)
f010b7f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7f5:	8b 40 10             	mov    0x10(%eax),%eax
f010b7f8:	85 c0                	test   %eax,%eax
f010b7fa:	74 14                	je     f010b810 <env_create+0x848>
f010b7fc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b802:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b808:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b80b:	89 50 14             	mov    %edx,0x14(%eax)
f010b80e:	eb 0f                	jmp    f010b81f <env_create+0x857>
f010b810:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b816:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b819:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b81f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b825:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b828:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b82e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b831:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b838:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b83e:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b844:	42                   	inc    %edx
f010b845:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b84b:	e9 88 00 00 00       	jmp    f010b8d8 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b850:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b854:	75 17                	jne    f010b86d <env_create+0x8a5>
f010b856:	83 ec 04             	sub    $0x4,%esp
f010b859:	68 38 62 12 f0       	push   $0xf0126238
f010b85e:	68 73 01 00 00       	push   $0x173
f010b863:	68 5b 62 12 f0       	push   $0xf012625b
f010b868:	e8 cc 4a ff ff       	call   f0100339 <_panic>
f010b86d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b873:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b879:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b87c:	89 50 10             	mov    %edx,0x10(%eax)
f010b87f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b882:	8b 40 10             	mov    0x10(%eax),%eax
f010b885:	85 c0                	test   %eax,%eax
f010b887:	74 14                	je     f010b89d <env_create+0x8d5>
f010b889:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b88f:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b895:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b898:	89 50 14             	mov    %edx,0x14(%eax)
f010b89b:	eb 0f                	jmp    f010b8ac <env_create+0x8e4>
f010b89d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8a6:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b8ac:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8b5:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b8bb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b8be:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b8c5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8cb:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b8d1:	42                   	inc    %edx
f010b8d2:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b8d8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8de:	83 ec 04             	sub    $0x4,%esp
f010b8e1:	6a 01                	push   $0x1
f010b8e3:	ff 75 d0             	pushl  -0x30(%ebp)
f010b8e6:	50                   	push   %eax
f010b8e7:	e8 14 88 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b8ec:	83 c4 10             	add    $0x10,%esp
f010b8ef:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b8f5:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b8fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b8ff:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b905:	0f 83 af fc ff ff    	jae    f010b5ba <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b90b:	83 ec 0c             	sub    $0xc,%esp
f010b90e:	6a 02                	push   $0x2
f010b910:	e8 6c 3d 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010b915:	83 c4 10             	add    $0x10,%esp
f010b918:	85 c0                	test   %eax,%eax
f010b91a:	74 72                	je     f010b98e <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b91c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b923:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b929:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b92f:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b932:	eb 2b                	jmp    f010b95f <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b934:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b937:	8b 10                	mov    (%eax),%edx
f010b939:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b93f:	8b 40 64             	mov    0x64(%eax),%eax
f010b942:	6a 01                	push   $0x1
f010b944:	6a 00                	push   $0x0
f010b946:	52                   	push   %edx
f010b947:	50                   	push   %eax
f010b948:	e8 39 e3 ff ff       	call   f0109c86 <pt_set_page_permissions>
f010b94d:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b950:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b956:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b95c:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b95f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b965:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b969:	74 08                	je     f010b973 <env_create+0x9ab>
f010b96b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b96e:	8b 52 10             	mov    0x10(%edx),%edx
f010b971:	eb 05                	jmp    f010b978 <env_create+0x9b0>
f010b973:	ba 00 00 00 00       	mov    $0x0,%edx
f010b978:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b97e:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b984:	85 c0                	test   %eax,%eax
f010b986:	75 ac                	jne    f010b934 <env_create+0x96c>
f010b988:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b98c:	75 a6                	jne    f010b934 <env_create+0x96c>
f010b98e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b991:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b994:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b997:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b99a:	e8 82 b8 ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b99f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b9a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b9a8:	5e                   	pop    %esi
f010b9a9:	5f                   	pop    %edi
f010b9aa:	5d                   	pop    %ebp
f010b9ab:	c3                   	ret    

f010b9ac <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b9ac:	55                   	push   %ebp
f010b9ad:	89 e5                	mov    %esp,%ebp
f010b9af:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b9b2:	83 ec 0c             	sub    $0xc,%esp
f010b9b5:	68 e0 15 6c f0       	push   $0xf06c15e0
f010b9ba:	e8 9c 43 00 00       	call   f010fd5b <release_spinlock>
f010b9bf:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b9c2:	a1 60 f9 17 f0       	mov    0xf017f960,%eax
f010b9c7:	85 c0                	test   %eax,%eax
f010b9c9:	74 30                	je     f010b9fb <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b9cb:	e8 76 00 00 00       	call   f010ba46 <get_cpu_proc>
f010b9d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b9d6:	8b 40 10             	mov    0x10(%eax),%eax
f010b9d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b9dc:	83 c2 20             	add    $0x20,%edx
f010b9df:	83 ec 04             	sub    $0x4,%esp
f010b9e2:	50                   	push   %eax
f010b9e3:	52                   	push   %edx
f010b9e4:	68 01 63 12 f0       	push   $0xf0126301
f010b9e9:	e8 9d 55 ff ff       	call   f0100f8b <cprintf>
f010b9ee:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b9f1:	c7 05 60 f9 17 f0 00 	movl   $0x0,0xf017f960
f010b9f8:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b9fb:	90                   	nop
f010b9fc:	c9                   	leave  
f010b9fd:	c3                   	ret    

f010b9fe <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b9fe:	55                   	push   %ebp
f010b9ff:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010ba01:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010ba02:	5d                   	pop    %ebp
f010ba03:	c3                   	ret    

f010ba04 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010ba04:	55                   	push   %ebp
f010ba05:	89 e5                	mov    %esp,%ebp
f010ba07:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ba0a:	e8 37 00 00 00       	call   f010ba46 <get_cpu_proc>
f010ba0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ba12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ba16:	75 19                	jne    f010ba31 <env_exit+0x2d>
f010ba18:	68 17 63 12 f0       	push   $0xf0126317
f010ba1d:	68 27 63 12 f0       	push   $0xf0126327
f010ba22:	68 ed 01 00 00       	push   $0x1ed
f010ba27:	68 5b 62 12 f0       	push   $0xf012625b
f010ba2c:	e8 08 49 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010ba31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba34:	8b 40 10             	mov    0x10(%eax),%eax
f010ba37:	83 ec 0c             	sub    $0xc,%esp
f010ba3a:	50                   	push   %eax
f010ba3b:	e8 e9 9d ff ff       	call   f0105829 <sched_exit_env>
f010ba40:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010ba43:	90                   	nop
f010ba44:	c9                   	leave  
f010ba45:	c3                   	ret    

f010ba46 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ba46:	55                   	push   %ebp
f010ba47:	89 e5                	mov    %esp,%ebp
f010ba49:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ba4c:	e8 7e b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010ba51:	e8 b6 b6 ff ff       	call   f010710c <mycpu>
f010ba56:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010ba59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba5c:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ba62:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010ba65:	e8 b7 b7 ff ff       	call   f0107221 <popcli>
	return p;
f010ba6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ba6d:	c9                   	leave  
f010ba6e:	c3                   	ret    

f010ba6f <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ba6f:	55                   	push   %ebp
f010ba70:	89 e5                	mov    %esp,%ebp
f010ba72:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ba75:	e8 55 b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010ba7a:	e8 8d b6 ff ff       	call   f010710c <mycpu>
f010ba7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ba82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba85:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba88:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010ba8e:	e8 8e b7 ff ff       	call   f0107221 <popcli>
}
f010ba93:	90                   	nop
f010ba94:	c9                   	leave  
f010ba95:	c3                   	ret    

f010ba96 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010ba96:	55                   	push   %ebp
f010ba97:	89 e5                	mov    %esp,%ebp
f010ba99:	53                   	push   %ebx
f010ba9a:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010ba9d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010baa1:	75 16                	jne    f010bab9 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010baa3:	e8 9e ff ff ff       	call   f010ba46 <get_cpu_proc>
f010baa8:	89 c2                	mov    %eax,%edx
f010baaa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010baad:	89 10                	mov    %edx,(%eax)
		return 0;
f010baaf:	b8 00 00 00 00       	mov    $0x0,%eax
f010bab4:	e9 aa 00 00 00       	jmp    f010bb63 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bab9:	8b 1d f0 8a 69 f0    	mov    0xf0698af0,%ebx
f010babf:	83 ec 0c             	sub    $0xc,%esp
f010bac2:	68 ca 02 00 00       	push   $0x2ca
f010bac7:	e8 14 27 01 00       	call   f011e1e0 <nearest_pow2_ceil>
f010bacc:	83 c4 10             	add    $0x10,%esp
f010bacf:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bad2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad5:	21 c2                	and    %eax,%edx
f010bad7:	89 d0                	mov    %edx,%eax
f010bad9:	c1 e0 03             	shl    $0x3,%eax
f010badc:	01 d0                	add    %edx,%eax
f010bade:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bae5:	01 c8                	add    %ecx,%eax
f010bae7:	01 c0                	add    %eax,%eax
f010bae9:	01 d0                	add    %edx,%eax
f010baeb:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010baf2:	01 c8                	add    %ecx,%eax
f010baf4:	01 d0                	add    %edx,%eax
f010baf6:	01 d8                	add    %ebx,%eax
f010baf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bafb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bafe:	8b 40 18             	mov    0x18(%eax),%eax
f010bb01:	85 c0                	test   %eax,%eax
f010bb03:	74 0b                	je     f010bb10 <envid2env+0x7a>
f010bb05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb08:	8b 40 10             	mov    0x10(%eax),%eax
f010bb0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bb0e:	74 10                	je     f010bb20 <envid2env+0x8a>
		*env_store = 0;
f010bb10:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bb19:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bb1e:	eb 43                	jmp    f010bb63 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bb20:	e8 21 ff ff ff       	call   f010ba46 <get_cpu_proc>
f010bb25:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010bb28:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bb2c:	74 28                	je     f010bb56 <envid2env+0xc0>
f010bb2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb31:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bb34:	74 20                	je     f010bb56 <envid2env+0xc0>
f010bb36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb39:	8b 50 14             	mov    0x14(%eax),%edx
f010bb3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb3f:	8b 40 10             	mov    0x10(%eax),%eax
f010bb42:	39 c2                	cmp    %eax,%edx
f010bb44:	74 10                	je     f010bb56 <envid2env+0xc0>
		*env_store = 0;
f010bb46:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb49:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bb4f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bb54:	eb 0d                	jmp    f010bb63 <envid2env+0xcd>
	}

	*env_store = e;
f010bb56:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb5c:	89 10                	mov    %edx,(%eax)
	return 0;
f010bb5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bb63:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb66:	c9                   	leave  
f010bb67:	c3                   	ret    

f010bb68 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bb68:	55                   	push   %ebp
f010bb69:	89 e5                	mov    %esp,%ebp
f010bb6b:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bb6e:	83 ec 0c             	sub    $0xc,%esp
f010bb71:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bb76:	e8 59 41 00 00       	call   f010fcd4 <acquire_spinlock>
f010bb7b:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bb7e:	e8 c3 fe ff ff       	call   f010ba46 <get_cpu_proc>
f010bb83:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bb86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb8a:	75 19                	jne    f010bba5 <yield+0x3d>
f010bb8c:	68 3c 63 12 f0       	push   $0xf012633c
f010bb91:	68 27 63 12 f0       	push   $0xf0126327
f010bb96:	68 4c 02 00 00       	push   $0x24c
f010bb9b:	68 5b 62 12 f0       	push   $0xf012625b
f010bba0:	e8 94 47 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010bba5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bba8:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bbaf:	e8 13 00 00 00       	call   f010bbc7 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010bbb4:	83 ec 0c             	sub    $0xc,%esp
f010bbb7:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bbbc:	e8 9a 41 00 00       	call   f010fd5b <release_spinlock>
f010bbc1:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bbc4:	90                   	nop
f010bbc5:	c9                   	leave  
f010bbc6:	c3                   	ret    

f010bbc7 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bbc7:	55                   	push   %ebp
f010bbc8:	89 e5                	mov    %esp,%ebp
f010bbca:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bbcd:	e8 74 fe ff ff       	call   f010ba46 <get_cpu_proc>
f010bbd2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bbd5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bbd9:	75 19                	jne    f010bbf4 <sched+0x2d>
f010bbdb:	68 3c 63 12 f0       	push   $0xf012633c
f010bbe0:	68 27 63 12 f0       	push   $0xf0126327
f010bbe5:	68 60 02 00 00       	push   $0x260
f010bbea:	68 5b 62 12 f0       	push   $0xf012625b
f010bbef:	e8 45 47 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bbf4:	83 ec 0c             	sub    $0xc,%esp
f010bbf7:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bbfc:	e8 ec 42 00 00       	call   f010feed <holding_spinlock>
f010bc01:	83 c4 10             	add    $0x10,%esp
f010bc04:	85 c0                	test   %eax,%eax
f010bc06:	75 17                	jne    f010bc1f <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bc08:	83 ec 04             	sub    $0x4,%esp
f010bc0b:	68 48 63 12 f0       	push   $0xf0126348
f010bc10:	68 64 02 00 00       	push   $0x264
f010bc15:	68 5b 62 12 f0       	push   $0xf012625b
f010bc1a:	e8 1a 47 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bc1f:	e8 e8 b4 ff ff       	call   f010710c <mycpu>
f010bc24:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc2a:	83 f8 01             	cmp    $0x1,%eax
f010bc2d:	74 20                	je     f010bc4f <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bc2f:	e8 d8 b4 ff ff       	call   f010710c <mycpu>
f010bc34:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc3a:	50                   	push   %eax
f010bc3b:	68 8a 63 12 f0       	push   $0xf012638a
f010bc40:	68 67 02 00 00       	push   $0x267
f010bc45:	68 5b 62 12 f0       	push   $0xf012625b
f010bc4a:	e8 ea 46 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bc4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc52:	8b 40 18             	mov    0x18(%eax),%eax
f010bc55:	83 f8 02             	cmp    $0x2,%eax
f010bc58:	75 17                	jne    f010bc71 <sched+0xaa>
		panic("sched a running process");
f010bc5a:	83 ec 04             	sub    $0x4,%esp
f010bc5d:	68 a1 63 12 f0       	push   $0xf01263a1
f010bc62:	68 6a 02 00 00       	push   $0x26a
f010bc67:	68 5b 62 12 f0       	push   $0xf012625b
f010bc6c:	e8 c8 46 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bc71:	9c                   	pushf  
f010bc72:	58                   	pop    %eax
f010bc73:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bc76:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bc79:	25 00 02 00 00       	and    $0x200,%eax
f010bc7e:	85 c0                	test   %eax,%eax
f010bc80:	74 17                	je     f010bc99 <sched+0xd2>
		panic("sched is interruptible!");
f010bc82:	83 ec 04             	sub    $0x4,%esp
f010bc85:	68 b9 63 12 f0       	push   $0xf01263b9
f010bc8a:	68 6c 02 00 00       	push   $0x26c
f010bc8f:	68 5b 62 12 f0       	push   $0xf012625b
f010bc94:	e8 a0 46 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bc99:	e8 6e b4 ff ff       	call   f010710c <mycpu>
f010bc9e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bca7:	e8 60 b4 ff ff       	call   f010710c <mycpu>
f010bcac:	8b 40 04             	mov    0x4(%eax),%eax
f010bcaf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcb2:	83 c2 04             	add    $0x4,%edx
f010bcb5:	83 ec 08             	sub    $0x8,%esp
f010bcb8:	50                   	push   %eax
f010bcb9:	52                   	push   %edx
f010bcba:	e8 b2 8e ff ff       	call   f0104b71 <context_switch>
f010bcbf:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bcc2:	e8 45 b4 ff ff       	call   f010710c <mycpu>
f010bcc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bcca:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bcd0:	90                   	nop
f010bcd1:	c9                   	leave  
f010bcd2:	c3                   	ret    

f010bcd3 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bcd3:	55                   	push   %ebp
f010bcd4:	89 e5                	mov    %esp,%ebp
f010bcd6:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bcd9:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f010bcde:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bce1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bce4:	0f 22 d8             	mov    %eax,%cr3
}
f010bce7:	90                   	nop
f010bce8:	c9                   	leave  
f010bce9:	c3                   	ret    

f010bcea <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bcea:	55                   	push   %ebp
f010bceb:	89 e5                	mov    %esp,%ebp
f010bced:	53                   	push   %ebx
f010bcee:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bcf1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bcf5:	75 17                	jne    f010bd0e <switchuvm+0x24>
		panic("switchuvm: no process");
f010bcf7:	83 ec 04             	sub    $0x4,%esp
f010bcfa:	68 d1 63 12 f0       	push   $0xf01263d1
f010bcff:	68 81 02 00 00       	push   $0x281
f010bd04:	68 5b 62 12 f0       	push   $0xf012625b
f010bd09:	e8 2b 46 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bd0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd11:	8b 40 70             	mov    0x70(%eax),%eax
f010bd14:	85 c0                	test   %eax,%eax
f010bd16:	75 17                	jne    f010bd2f <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bd18:	83 ec 04             	sub    $0x4,%esp
f010bd1b:	68 e7 63 12 f0       	push   $0xf01263e7
f010bd20:	68 83 02 00 00       	push   $0x283
f010bd25:	68 5b 62 12 f0       	push   $0xf012625b
f010bd2a:	e8 0a 46 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010bd2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd32:	8b 40 64             	mov    0x64(%eax),%eax
f010bd35:	85 c0                	test   %eax,%eax
f010bd37:	75 17                	jne    f010bd50 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bd39:	83 ec 04             	sub    $0x4,%esp
f010bd3c:	68 fc 63 12 f0       	push   $0xf01263fc
f010bd41:	68 85 02 00 00       	push   $0x285
f010bd46:	68 5b 62 12 f0       	push   $0xf012625b
f010bd4b:	e8 e9 45 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bd50:	e8 7a b4 ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010bd55:	e8 b2 b3 ff ff       	call   f010710c <mycpu>
f010bd5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bd5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd60:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd63:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bd69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd6c:	83 c0 0c             	add    $0xc,%eax
f010bd6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd72:	83 c2 0c             	add    $0xc,%edx
f010bd75:	c1 ea 10             	shr    $0x10,%edx
f010bd78:	88 d3                	mov    %dl,%bl
f010bd7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd7d:	83 c2 0c             	add    $0xc,%edx
f010bd80:	c1 ea 18             	shr    $0x18,%edx
f010bd83:	88 d1                	mov    %dl,%cl
f010bd85:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd88:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bd8f:	68 00 
f010bd91:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd94:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bd9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd9e:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bda4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bda7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdad:	83 e2 f0             	and    $0xfffffff0,%edx
f010bdb0:	83 ca 09             	or     $0x9,%edx
f010bdb3:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbc:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdc2:	83 ca 10             	or     $0x10,%edx
f010bdc5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdce:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdd4:	83 e2 9f             	and    $0xffffff9f,%edx
f010bdd7:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde0:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bde6:	83 ca 80             	or     $0xffffff80,%edx
f010bde9:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdf8:	83 e2 f0             	and    $0xfffffff0,%edx
f010bdfb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be04:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be0a:	83 e2 ef             	and    $0xffffffef,%edx
f010be0d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be16:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be1c:	83 e2 df             	and    $0xffffffdf,%edx
f010be1f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be28:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be2e:	83 ca 40             	or     $0x40,%edx
f010be31:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be3a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be40:	83 e2 7f             	and    $0x7f,%edx
f010be43:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be4c:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010be52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be55:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be5b:	83 e2 ef             	and    $0xffffffef,%edx
f010be5e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010be64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be67:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be6d:	8b 40 70             	mov    0x70(%eax),%eax
f010be70:	05 00 80 00 00       	add    $0x8000,%eax
f010be75:	89 c2                	mov    %eax,%edx
f010be77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be7a:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010be7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be80:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010be86:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010be8c:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010be90:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010be93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be96:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be9c:	8b 40 68             	mov    0x68(%eax),%eax
f010be9f:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bea2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bea5:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010bea8:	e8 74 b3 ff ff       	call   f0107221 <popcli>
}
f010bead:	90                   	nop
f010beae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010beb1:	c9                   	leave  
f010beb2:	c3                   	ret    

f010beb3 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010beb3:	55                   	push   %ebp
f010beb4:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010beb6:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010bebc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bebf:	89 10                	mov    %edx,(%eax)
f010bec1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bec4:	8b 00                	mov    (%eax),%eax
f010bec6:	85 c0                	test   %eax,%eax
f010bec8:	75 07                	jne    f010bed1 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010beca:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010becf:	eb 11                	jmp    f010bee2 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010bed1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bed4:	8b 00                	mov    (%eax),%eax
f010bed6:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010bedd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bee2:	5d                   	pop    %ebp
f010bee3:	c3                   	ret    

f010bee4 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010bee4:	55                   	push   %ebp
f010bee5:	89 e5                	mov    %esp,%ebp
f010bee7:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010beea:	83 ec 04             	sub    $0x4,%esp
f010beed:	68 bc 05 00 00       	push   $0x5bc
f010bef2:	6a 00                	push   $0x0
f010bef4:	ff 75 08             	pushl  0x8(%ebp)
f010bef7:	e8 74 3f 01 00       	call   f011fe70 <memset>
f010befc:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010beff:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf02:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bf09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bf0d:	75 17                	jne    f010bf26 <free_environment+0x42>
f010bf0f:	83 ec 04             	sub    $0x4,%esp
f010bf12:	68 38 62 12 f0       	push   $0xf0126238
f010bf17:	68 c0 02 00 00       	push   $0x2c0
f010bf1c:	68 5b 62 12 f0       	push   $0xf012625b
f010bf21:	e8 13 44 ff ff       	call   f0100339 <_panic>
f010bf26:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010bf2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf2f:	89 50 08             	mov    %edx,0x8(%eax)
f010bf32:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf35:	8b 40 08             	mov    0x8(%eax),%eax
f010bf38:	85 c0                	test   %eax,%eax
f010bf3a:	74 0d                	je     f010bf49 <free_environment+0x65>
f010bf3c:	a1 f4 8a 69 f0       	mov    0xf0698af4,%eax
f010bf41:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf44:	89 50 0c             	mov    %edx,0xc(%eax)
f010bf47:	eb 08                	jmp    f010bf51 <free_environment+0x6d>
f010bf49:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf4c:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010bf51:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf54:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010bf59:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf5c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bf63:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010bf68:	40                   	inc    %eax
f010bf69:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
}
f010bf6e:	90                   	nop
f010bf6f:	c9                   	leave  
f010bf70:	c3                   	ret    

f010bf71 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010bf71:	55                   	push   %ebp
f010bf72:	89 e5                	mov    %esp,%ebp
f010bf74:	53                   	push   %ebx
f010bf75:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bf78:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf7b:	8b 40 0c             	mov    0xc(%eax),%eax
f010bf7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bf81:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf84:	8b 40 08             	mov    0x8(%eax),%eax
f010bf87:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010bf8a:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bf91:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bf94:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bf97:	01 c2                	add    %eax,%edx
f010bf99:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bf9c:	01 d0                	add    %edx,%eax
f010bf9e:	48                   	dec    %eax
f010bf9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bfa2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bfa5:	ba 00 00 00 00       	mov    $0x0,%edx
f010bfaa:	f7 75 dc             	divl   -0x24(%ebp)
f010bfad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bfb0:	29 d0                	sub    %edx,%eax
f010bfb2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010bfb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bfb8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bfbb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bfbe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bfc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010bfc6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010bfcd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010bfd4:	8b 45 10             	mov    0x10(%ebp),%eax
f010bfd7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010bfdd:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010bfe4:	0f 85 f5 03 00 00    	jne    f010c3df <program_segment_alloc_map_copy_workingset+0x46e>
f010bfea:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfed:	83 c0 20             	add    $0x20,%eax
f010bff0:	83 ec 08             	sub    $0x8,%esp
f010bff3:	68 10 64 12 f0       	push   $0xf0126410
f010bff8:	50                   	push   %eax
f010bff9:	e8 90 3d 01 00       	call   f011fd8e <strcmp>
f010bffe:	83 c4 10             	add    $0x10,%esp
f010c001:	85 c0                	test   %eax,%eax
f010c003:	0f 84 d6 03 00 00    	je     f010c3df <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c009:	8b 45 14             	mov    0x14(%ebp),%eax
f010c00c:	83 f8 06             	cmp    $0x6,%eax
f010c00f:	76 05                	jbe    f010c016 <program_segment_alloc_map_copy_workingset+0xa5>
f010c011:	b8 06 00 00 00       	mov    $0x6,%eax
f010c016:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c019:	e9 c1 03 00 00       	jmp    f010c3df <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c01e:	83 ec 0c             	sub    $0xc,%esp
f010c021:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c024:	50                   	push   %eax
f010c025:	e8 88 c1 ff ff       	call   f01081b2 <allocate_frame>
f010c02a:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c02d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c030:	8b 45 08             	mov    0x8(%ebp),%eax
f010c033:	8b 40 64             	mov    0x64(%eax),%eax
f010c036:	6a 06                	push   $0x6
f010c038:	ff 75 f4             	pushl  -0xc(%ebp)
f010c03b:	52                   	push   %edx
f010c03c:	50                   	push   %eax
f010c03d:	e8 41 c8 ff ff       	call   f0108883 <loadtime_map_frame>
f010c042:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c045:	83 ec 08             	sub    $0x8,%esp
f010c048:	ff 75 f4             	pushl  -0xc(%ebp)
f010c04b:	ff 75 08             	pushl  0x8(%ebp)
f010c04e:	e8 69 de ff ff       	call   f0109ebc <env_page_ws_list_create_element>
f010c053:	83 c4 10             	add    $0x10,%esp
f010c056:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c059:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c05c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c063:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c067:	75 17                	jne    f010c080 <program_segment_alloc_map_copy_workingset+0x10f>
f010c069:	83 ec 04             	sub    $0x4,%esp
f010c06c:	68 c0 62 12 f0       	push   $0xf01262c0
f010c071:	68 ea 02 00 00       	push   $0x2ea
f010c076:	68 5b 62 12 f0       	push   $0xf012625b
f010c07b:	e8 b9 42 ff ff       	call   f0100339 <_panic>
f010c080:	8b 45 08             	mov    0x8(%ebp),%eax
f010c083:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c089:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c08c:	89 50 14             	mov    %edx,0x14(%eax)
f010c08f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c092:	8b 40 14             	mov    0x14(%eax),%eax
f010c095:	85 c0                	test   %eax,%eax
f010c097:	74 11                	je     f010c0aa <program_segment_alloc_map_copy_workingset+0x139>
f010c099:	8b 45 08             	mov    0x8(%ebp),%eax
f010c09c:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c0a2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0a5:	89 50 10             	mov    %edx,0x10(%eax)
f010c0a8:	eb 0c                	jmp    f010c0b6 <program_segment_alloc_map_copy_workingset+0x145>
f010c0aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0ad:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0b0:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c0b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0b9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0bc:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c0c2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0c5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c0cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0cf:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c0d5:	8d 50 01             	lea    0x1(%eax),%edx
f010c0d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0db:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c0e1:	83 ec 0c             	sub    $0xc,%esp
f010c0e4:	6a 02                	push   $0x2
f010c0e6:	e8 96 35 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010c0eb:	83 c4 10             	add    $0x10,%esp
f010c0ee:	85 c0                	test   %eax,%eax
f010c0f0:	0f 84 b3 01 00 00    	je     f010c2a9 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c0f6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c0fa:	75 17                	jne    f010c113 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c0fc:	83 ec 04             	sub    $0x4,%esp
f010c0ff:	68 e3 62 12 f0       	push   $0xf01262e3
f010c104:	68 f6 02 00 00       	push   $0x2f6
f010c109:	68 5b 62 12 f0       	push   $0xf012625b
f010c10e:	e8 26 42 ff ff       	call   f0100339 <_panic>
f010c113:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c116:	8b 40 10             	mov    0x10(%eax),%eax
f010c119:	85 c0                	test   %eax,%eax
f010c11b:	74 11                	je     f010c12e <program_segment_alloc_map_copy_workingset+0x1bd>
f010c11d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c120:	8b 40 10             	mov    0x10(%eax),%eax
f010c123:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c126:	8b 52 14             	mov    0x14(%edx),%edx
f010c129:	89 50 14             	mov    %edx,0x14(%eax)
f010c12c:	eb 0f                	jmp    f010c13d <program_segment_alloc_map_copy_workingset+0x1cc>
f010c12e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c131:	8b 50 14             	mov    0x14(%eax),%edx
f010c134:	8b 45 08             	mov    0x8(%ebp),%eax
f010c137:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c13d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c140:	8b 40 14             	mov    0x14(%eax),%eax
f010c143:	85 c0                	test   %eax,%eax
f010c145:	74 11                	je     f010c158 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c147:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c14a:	8b 40 14             	mov    0x14(%eax),%eax
f010c14d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c150:	8b 52 10             	mov    0x10(%edx),%edx
f010c153:	89 50 10             	mov    %edx,0x10(%eax)
f010c156:	eb 0f                	jmp    f010c167 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c158:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c15b:	8b 50 10             	mov    0x10(%eax),%edx
f010c15e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c161:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c167:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c16a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c171:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c174:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c17b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c17e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c184:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c187:	8b 45 08             	mov    0x8(%ebp),%eax
f010c18a:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c190:	8b 45 08             	mov    0x8(%ebp),%eax
f010c193:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c199:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19c:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c1a2:	48                   	dec    %eax
f010c1a3:	39 c2                	cmp    %eax,%edx
f010c1a5:	0f 83 80 00 00 00    	jae    f010c22b <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c1ab:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c1af:	75 17                	jne    f010c1c8 <program_segment_alloc_map_copy_workingset+0x257>
f010c1b1:	83 ec 04             	sub    $0x4,%esp
f010c1b4:	68 38 62 12 f0       	push   $0xf0126238
f010c1b9:	68 fa 02 00 00       	push   $0x2fa
f010c1be:	68 5b 62 12 f0       	push   $0xf012625b
f010c1c3:	e8 71 41 ff ff       	call   f0100339 <_panic>
f010c1c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1cb:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c1d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1d4:	89 50 10             	mov    %edx,0x10(%eax)
f010c1d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1da:	8b 40 10             	mov    0x10(%eax),%eax
f010c1dd:	85 c0                	test   %eax,%eax
f010c1df:	74 11                	je     f010c1f2 <program_segment_alloc_map_copy_workingset+0x281>
f010c1e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e4:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c1ea:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1ed:	89 50 14             	mov    %edx,0x14(%eax)
f010c1f0:	eb 0c                	jmp    f010c1fe <program_segment_alloc_map_copy_workingset+0x28d>
f010c1f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1f5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1f8:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c1fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c201:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c204:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c20a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c20d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c214:	8b 45 08             	mov    0x8(%ebp),%eax
f010c217:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c21d:	8d 50 01             	lea    0x1(%eax),%edx
f010c220:	8b 45 08             	mov    0x8(%ebp),%eax
f010c223:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c229:	eb 7e                	jmp    f010c2a9 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c22b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c22f:	75 17                	jne    f010c248 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c231:	83 ec 04             	sub    $0x4,%esp
f010c234:	68 38 62 12 f0       	push   $0xf0126238
f010c239:	68 ff 02 00 00       	push   $0x2ff
f010c23e:	68 5b 62 12 f0       	push   $0xf012625b
f010c243:	e8 f1 40 ff ff       	call   f0100339 <_panic>
f010c248:	8b 45 08             	mov    0x8(%ebp),%eax
f010c24b:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c251:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c254:	89 50 10             	mov    %edx,0x10(%eax)
f010c257:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c25a:	8b 40 10             	mov    0x10(%eax),%eax
f010c25d:	85 c0                	test   %eax,%eax
f010c25f:	74 11                	je     f010c272 <program_segment_alloc_map_copy_workingset+0x301>
f010c261:	8b 45 08             	mov    0x8(%ebp),%eax
f010c264:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c26a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c26d:	89 50 14             	mov    %edx,0x14(%eax)
f010c270:	eb 0c                	jmp    f010c27e <program_segment_alloc_map_copy_workingset+0x30d>
f010c272:	8b 45 08             	mov    0x8(%ebp),%eax
f010c275:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c278:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c27e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c281:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c284:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c28a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c28d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c294:	8b 45 08             	mov    0x8(%ebp),%eax
f010c297:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c29d:	8d 50 01             	lea    0x1(%eax),%edx
f010c2a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2a3:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c2a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ac:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c2b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2b5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c2bb:	39 c2                	cmp    %eax,%edx
f010c2bd:	75 14                	jne    f010c2d3 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c2bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c2:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c2c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2cb:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c2d1:	eb 0d                	jmp    f010c2e0 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d6:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c2dd:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c2e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2e3:	c1 e8 16             	shr    $0x16,%eax
f010c2e6:	89 c2                	mov    %eax,%edx
f010c2e8:	8b 45 18             	mov    0x18(%ebp),%eax
f010c2eb:	8b 00                	mov    (%eax),%eax
f010c2ed:	39 c2                	cmp    %eax,%edx
f010c2ef:	0f 84 d3 00 00 00    	je     f010c3c8 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c2f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f8:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c2fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c301:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c304:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c307:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c30c:	89 c1                	mov    %eax,%ecx
f010c30e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c311:	89 d0                	mov    %edx,%eax
f010c313:	01 c0                	add    %eax,%eax
f010c315:	01 d0                	add    %edx,%eax
f010c317:	c1 e0 03             	shl    $0x3,%eax
f010c31a:	01 d8                	add    %ebx,%eax
f010c31c:	05 ac 00 00 00       	add    $0xac,%eax
f010c321:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c323:	8b 45 08             	mov    0x8(%ebp),%eax
f010c326:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c32c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c32f:	89 d0                	mov    %edx,%eax
f010c331:	01 c0                	add    %eax,%eax
f010c333:	01 d0                	add    %edx,%eax
f010c335:	c1 e0 03             	shl    $0x3,%eax
f010c338:	01 c8                	add    %ecx,%eax
f010c33a:	05 b0 00 00 00       	add    $0xb0,%eax
f010c33f:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c342:	8b 45 08             	mov    0x8(%ebp),%eax
f010c345:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c34b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c34e:	89 d0                	mov    %edx,%eax
f010c350:	01 c0                	add    %eax,%eax
f010c352:	01 d0                	add    %edx,%eax
f010c354:	c1 e0 03             	shl    $0x3,%eax
f010c357:	01 c8                	add    %ecx,%eax
f010c359:	05 b4 00 00 00       	add    $0xb4,%eax
f010c35e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c364:	8b 45 08             	mov    0x8(%ebp),%eax
f010c367:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c36d:	8d 50 01             	lea    0x1(%eax),%edx
f010c370:	8b 45 08             	mov    0x8(%ebp),%eax
f010c373:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c379:	8b 45 08             	mov    0x8(%ebp),%eax
f010c37c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c382:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c387:	ba 00 00 00 00       	mov    $0x0,%edx
f010c38c:	f7 f1                	div    %ecx
f010c38e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c391:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c397:	8b 45 08             	mov    0x8(%ebp),%eax
f010c39a:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c3a0:	85 c0                	test   %eax,%eax
f010c3a2:	75 17                	jne    f010c3bb <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c3a4:	83 ec 04             	sub    $0x4,%esp
f010c3a7:	68 14 64 12 f0       	push   $0xf0126414
f010c3ac:	68 27 03 00 00       	push   $0x327
f010c3b1:	68 5b 62 12 f0       	push   $0xf012625b
f010c3b6:	e8 7e 3f ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c3bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3be:	c1 e8 16             	shr    $0x16,%eax
f010c3c1:	89 c2                	mov    %eax,%edx
f010c3c3:	8b 45 18             	mov    0x18(%ebp),%eax
f010c3c6:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c3c8:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3cb:	8b 00                	mov    (%eax),%eax
f010c3cd:	8d 50 01             	lea    0x1(%eax),%edx
f010c3d0:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3d3:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c3d5:	ff 45 f0             	incl   -0x10(%ebp)
f010c3d8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3e2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c3e5:	73 0c                	jae    f010c3f3 <program_segment_alloc_map_copy_workingset+0x482>
f010c3e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c3ea:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c3ed:	0f 82 2b fc ff ff    	jb     f010c01e <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c3f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3f6:	8b 00                	mov    (%eax),%eax
f010c3f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c3fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3fe:	8b 40 0c             	mov    0xc(%eax),%eax
f010c401:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c404:	eb 10                	jmp    f010c416 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c406:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c409:	8a 10                	mov    (%eax),%dl
f010c40b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c40e:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c410:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c413:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c416:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c419:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c41c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c41f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c424:	89 c2                	mov    %eax,%edx
f010c426:	8b 45 10             	mov    0x10(%ebp),%eax
f010c429:	8b 00                	mov    (%eax),%eax
f010c42b:	c1 e0 0c             	shl    $0xc,%eax
f010c42e:	01 c2                	add    %eax,%edx
f010c430:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c433:	39 c2                	cmp    %eax,%edx
f010c435:	76 1d                	jbe    f010c454 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c437:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c43a:	8b 50 04             	mov    0x4(%eax),%edx
f010c43d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c440:	01 c2                	add    %eax,%edx
f010c442:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c445:	39 c2                	cmp    %eax,%edx
f010c447:	77 bd                	ja     f010c406 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c449:	eb 09                	jmp    f010c454 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c44b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c44e:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c451:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c454:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c457:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c45a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c45d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c462:	89 c2                	mov    %eax,%edx
f010c464:	8b 45 10             	mov    0x10(%ebp),%eax
f010c467:	8b 00                	mov    (%eax),%eax
f010c469:	c1 e0 0c             	shl    $0xc,%eax
f010c46c:	01 c2                	add    %eax,%edx
f010c46e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c471:	39 c2                	cmp    %eax,%edx
f010c473:	77 d6                	ja     f010c44b <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c475:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c47a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c47d:	c9                   	leave  
f010c47e:	c3                   	ret    

f010c47f <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c47f:	55                   	push   %ebp
f010c480:	89 e5                	mov    %esp,%ebp
f010c482:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c485:	83 ec 0c             	sub    $0xc,%esp
f010c488:	68 00 10 00 00       	push   $0x1000
f010c48d:	e8 7c d0 ff ff       	call   f010950e <kmalloc>
f010c492:	83 c4 10             	add    $0x10,%esp
f010c495:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c498:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c49c:	75 17                	jne    f010c4b5 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c49e:	83 ec 04             	sub    $0x4,%esp
f010c4a1:	68 b7 64 12 f0       	push   $0xf01264b7
f010c4a6:	68 57 03 00 00       	push   $0x357
f010c4ab:	68 5b 62 12 f0       	push   $0xf012625b
f010c4b0:	e8 84 3e ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c4b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c4b8:	c9                   	leave  
f010c4b9:	c3                   	ret    

f010c4ba <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c4ba:	55                   	push   %ebp
f010c4bb:	89 e5                	mov    %esp,%ebp
f010c4bd:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c4c0:	83 ec 0c             	sub    $0xc,%esp
f010c4c3:	68 00 80 00 00       	push   $0x8000
f010c4c8:	e8 41 d0 ff ff       	call   f010950e <kmalloc>
f010c4cd:	83 c4 10             	add    $0x10,%esp
f010c4d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c4d3:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c4da:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4dd:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c4e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c4e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4e8:	ba 00 00 00 00       	mov    $0x0,%edx
f010c4ed:	f7 75 ec             	divl   -0x14(%ebp)
f010c4f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4f3:	29 d0                	sub    %edx,%eax
f010c4f5:	85 c0                	test   %eax,%eax
f010c4f7:	79 05                	jns    f010c4fe <create_user_kern_stack+0x44>
f010c4f9:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c4fe:	c1 f8 0c             	sar    $0xc,%eax
f010c501:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c504:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c50b:	eb 72                	jmp    f010c57f <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c50d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c517:	c1 e0 0c             	shl    $0xc,%eax
f010c51a:	89 c2                	mov    %eax,%edx
f010c51c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c51f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c522:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010c527:	83 ec 04             	sub    $0x4,%esp
f010c52a:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c52d:	52                   	push   %edx
f010c52e:	51                   	push   %ecx
f010c52f:	50                   	push   %eax
f010c530:	e8 34 c2 ff ff       	call   f0108769 <get_frame_info>
f010c535:	83 c4 10             	add    $0x10,%esp
f010c538:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c53b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c53e:	c1 e0 0c             	shl    $0xc,%eax
f010c541:	89 c2                	mov    %eax,%edx
f010c543:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c546:	01 d0                	add    %edx,%eax
f010c548:	6a 01                	push   $0x1
f010c54a:	50                   	push   %eax
f010c54b:	ff 75 e0             	pushl  -0x20(%ebp)
f010c54e:	ff 75 08             	pushl  0x8(%ebp)
f010c551:	e8 29 c1 ff ff       	call   f010867f <map_frame>
f010c556:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c559:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c55d:	75 1d                	jne    f010c57c <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c55f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c562:	c1 e0 0c             	shl    $0xc,%eax
f010c565:	89 c2                	mov    %eax,%edx
f010c567:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c56a:	01 d0                	add    %edx,%eax
f010c56c:	6a 01                	push   $0x1
f010c56e:	6a 00                	push   $0x0
f010c570:	50                   	push   %eax
f010c571:	ff 75 08             	pushl  0x8(%ebp)
f010c574:	e8 0d d7 ff ff       	call   f0109c86 <pt_set_page_permissions>
f010c579:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c57c:	ff 45 f4             	incl   -0xc(%ebp)
f010c57f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c582:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c585:	72 86                	jb     f010c50d <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c587:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c58a:	c9                   	leave  
f010c58b:	c3                   	ret    

f010c58c <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c58c:	55                   	push   %ebp
f010c58d:	89 e5                	mov    %esp,%ebp
f010c58f:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c592:	83 ec 04             	sub    $0x4,%esp
f010c595:	68 d4 64 12 f0       	push   $0xf01264d4
f010c59a:	68 8e 03 00 00       	push   $0x38e
f010c59f:	68 5b 62 12 f0       	push   $0xf012625b
f010c5a4:	e8 90 3d ff ff       	call   f0100339 <_panic>

f010c5a9 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c5a9:	55                   	push   %ebp
f010c5aa:	89 e5                	mov    %esp,%ebp
f010c5ac:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c5af:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b2:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c5b5:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c5b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5bb:	8b 55 10             	mov    0x10(%ebp),%edx
f010c5be:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c4:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c5c7:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c5ca:	83 ec 08             	sub    $0x8,%esp
f010c5cd:	6a 00                	push   $0x0
f010c5cf:	ff 75 0c             	pushl  0xc(%ebp)
f010c5d2:	e8 7a 42 01 00       	call   f0120851 <initialize_dynamic_allocator>
f010c5d7:	83 c4 10             	add    $0x10,%esp
}
f010c5da:	90                   	nop
f010c5db:	c9                   	leave  
f010c5dc:	c3                   	ret    

f010c5dd <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c5dd:	55                   	push   %ebp
f010c5de:	89 e5                	mov    %esp,%ebp
f010c5e0:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c5e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5e6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c5e9:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c5ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ef:	8b 55 10             	mov    0x10(%ebp),%edx
f010c5f2:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c5f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c5fc:	eb 17                	jmp    f010c615 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c5fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c601:	8b 40 64             	mov    0x64(%eax),%eax
f010c604:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c607:	c1 e2 02             	shl    $0x2,%edx
f010c60a:	01 d0                	add    %edx,%eax
f010c60c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c612:	ff 45 f4             	incl   -0xc(%ebp)
f010c615:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c618:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c61d:	76 df                	jbe    f010c5fe <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c61f:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c626:	eb 22                	jmp    f010c64a <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c628:	8b 45 08             	mov    0x8(%ebp),%eax
f010c62b:	8b 40 64             	mov    0x64(%eax),%eax
f010c62e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c631:	c1 e2 02             	shl    $0x2,%edx
f010c634:	01 c2                	add    %eax,%edx
f010c636:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010c63b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c63e:	c1 e1 02             	shl    $0x2,%ecx
f010c641:	01 c8                	add    %ecx,%eax
f010c643:	8b 00                	mov    (%eax),%eax
f010c645:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c647:	ff 45 f4             	incl   -0xc(%ebp)
f010c64a:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c651:	7e d5                	jle    f010c628 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c653:	8b 45 08             	mov    0x8(%ebp),%eax
f010c656:	8b 40 64             	mov    0x64(%eax),%eax
f010c659:	83 ec 0c             	sub    $0xc,%esp
f010c65c:	50                   	push   %eax
f010c65d:	e8 58 fe ff ff       	call   f010c4ba <create_user_kern_stack>
f010c662:	83 c4 10             	add    $0x10,%esp
f010c665:	89 c2                	mov    %eax,%edx
f010c667:	8b 45 08             	mov    0x8(%ebp),%eax
f010c66a:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c66d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c670:	8b 40 70             	mov    0x70(%eax),%eax
f010c673:	05 00 80 00 00       	add    $0x8000,%eax
f010c678:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c67b:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c67f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c682:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c685:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c687:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c68b:	ba ca e6 10 f0       	mov    $0xf010e6ca,%edx
f010c690:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c693:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c695:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c699:	8b 45 08             	mov    0x8(%ebp),%eax
f010c69c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c69f:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c6a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6a5:	8b 40 04             	mov    0x4(%eax),%eax
f010c6a8:	83 ec 04             	sub    $0x4,%esp
f010c6ab:	6a 20                	push   $0x20
f010c6ad:	6a 00                	push   $0x0
f010c6af:	50                   	push   %eax
f010c6b0:	e8 bb 37 01 00       	call   f011fe70 <memset>
f010c6b5:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c6b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6bb:	8b 40 04             	mov    0x4(%eax),%eax
f010c6be:	ba ac b9 10 f0       	mov    $0xf010b9ac,%edx
f010c6c3:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c6c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c9:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c6d0:	00 00 00 
f010c6d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d6:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c6dd:	00 00 00 
f010c6e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6e3:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c6ea:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c6ed:	83 ec 0c             	sub    $0xc,%esp
f010c6f0:	6a 02                	push   $0x2
f010c6f2:	e8 8a 2f 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010c6f7:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c6fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c701:	eb 54                	jmp    f010c757 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c703:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c706:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c709:	89 d0                	mov    %edx,%eax
f010c70b:	01 c0                	add    %eax,%eax
f010c70d:	01 d0                	add    %edx,%eax
f010c70f:	c1 e0 03             	shl    $0x3,%eax
f010c712:	01 c8                	add    %ecx,%eax
f010c714:	05 ac 00 00 00       	add    $0xac,%eax
f010c719:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c71f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c722:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c725:	89 d0                	mov    %edx,%eax
f010c727:	01 c0                	add    %eax,%eax
f010c729:	01 d0                	add    %edx,%eax
f010c72b:	c1 e0 03             	shl    $0x3,%eax
f010c72e:	01 c8                	add    %ecx,%eax
f010c730:	05 b0 00 00 00       	add    $0xb0,%eax
f010c735:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c738:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c73b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c73e:	89 d0                	mov    %edx,%eax
f010c740:	01 c0                	add    %eax,%eax
f010c742:	01 d0                	add    %edx,%eax
f010c744:	c1 e0 03             	shl    $0x3,%eax
f010c747:	01 c8                	add    %ecx,%eax
f010c749:	05 b4 00 00 00       	add    $0xb4,%eax
f010c74e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c754:	ff 45 f4             	incl   -0xc(%ebp)
f010c757:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c75b:	7e a6                	jle    f010c703 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c75d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c760:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c767:	00 00 00 

	e->pageFaultsCounter=0;
f010c76a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c76d:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c774:	00 00 00 
	e->tableFaultsCounter=0;
f010c777:	8b 45 08             	mov    0x8(%ebp),%eax
f010c77a:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c781:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c784:	8b 45 08             	mov    0x8(%ebp),%eax
f010c787:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c78e:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c791:	8b 45 08             	mov    0x8(%ebp),%eax
f010c794:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c79b:	00 00 00 

	e->nModifiedPages=0;
f010c79e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7a1:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c7a8:	00 00 00 
	e->nNotModifiedPages=0;
f010c7ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7ae:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c7b5:	00 00 00 
	e->nClocks = 0;
f010c7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7bb:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c7c2:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c7c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c8:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c7cf:	00 00 00 
	e->nPageOut = 0;
f010c7d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7d5:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c7dc:	00 00 00 
	e->nNewPageAdded = 0;
f010c7df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e2:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c7e9:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c7ec:	83 ec 04             	sub    $0x4,%esp
f010c7ef:	68 00 00 00 82       	push   $0x82000000
f010c7f4:	68 00 00 00 80       	push   $0x80000000
f010c7f9:	ff 75 08             	pushl  0x8(%ebp)
f010c7fc:	e8 a8 fd ff ff       	call   f010c5a9 <initialize_uheap_dynamic_allocator>
f010c801:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c804:	83 ec 0c             	sub    $0xc,%esp
f010c807:	ff 75 08             	pushl  0x8(%ebp)
f010c80a:	e8 06 00 00 00       	call   f010c815 <complete_environment_initialization>
f010c80f:	83 c4 10             	add    $0x10,%esp
}
f010c812:	90                   	nop
f010c813:	c9                   	leave  
f010c814:	c3                   	ret    

f010c815 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c815:	55                   	push   %ebp
f010c816:	89 e5                	mov    %esp,%ebp
f010c818:	53                   	push   %ebx
f010c819:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c81c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c81f:	8b 40 64             	mov    0x64(%eax),%eax
f010c822:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c828:	8b 45 08             	mov    0x8(%ebp),%eax
f010c82b:	8b 40 68             	mov    0x68(%eax),%eax
f010c82e:	83 c8 03             	or     $0x3,%eax
f010c831:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c833:	8b 45 08             	mov    0x8(%ebp),%eax
f010c836:	8b 40 64             	mov    0x64(%eax),%eax
f010c839:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c83f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c842:	8b 40 68             	mov    0x68(%eax),%eax
f010c845:	83 c8 05             	or     $0x5,%eax
f010c848:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c84a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c84d:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c854:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c857:	8b 45 08             	mov    0x8(%ebp),%eax
f010c85a:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c861:	00 00 00 
	e->disk_env_tabledir = 0;
f010c864:	8b 45 08             	mov    0x8(%ebp),%eax
f010c867:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c86e:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c871:	8b 45 08             	mov    0x8(%ebp),%eax
f010c874:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c87b:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c87e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c881:	8b 58 10             	mov    0x10(%eax),%ebx
f010c884:	83 ec 0c             	sub    $0xc,%esp
f010c887:	68 ca 02 00 00       	push   $0x2ca
f010c88c:	e8 84 19 01 00       	call   f011e215 <log2_ceil>
f010c891:	83 c4 10             	add    $0x10,%esp
f010c894:	ba 01 00 00 00       	mov    $0x1,%edx
f010c899:	88 c1                	mov    %al,%cl
f010c89b:	d3 e2                	shl    %cl,%edx
f010c89d:	89 d0                	mov    %edx,%eax
f010c89f:	01 d8                	add    %ebx,%eax
f010c8a1:	89 c3                	mov    %eax,%ebx
f010c8a3:	83 ec 0c             	sub    $0xc,%esp
f010c8a6:	68 ca 02 00 00       	push   $0x2ca
f010c8ab:	e8 30 19 01 00       	call   f011e1e0 <nearest_pow2_ceil>
f010c8b0:	83 c4 10             	add    $0x10,%esp
f010c8b3:	f7 d8                	neg    %eax
f010c8b5:	21 d8                	and    %ebx,%eax
f010c8b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c8ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c8be:	7f 1e                	jg     f010c8de <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c8c0:	83 ec 0c             	sub    $0xc,%esp
f010c8c3:	68 ca 02 00 00       	push   $0x2ca
f010c8c8:	e8 48 19 01 00       	call   f011e215 <log2_ceil>
f010c8cd:	83 c4 10             	add    $0x10,%esp
f010c8d0:	ba 01 00 00 00       	mov    $0x1,%edx
f010c8d5:	88 c1                	mov    %al,%cl
f010c8d7:	d3 e2                	shl    %cl,%edx
f010c8d9:	89 d0                	mov    %edx,%eax
f010c8db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c8de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e1:	8b 15 f0 8a 69 f0    	mov    0xf0698af0,%edx
f010c8e7:	29 d0                	sub    %edx,%eax
f010c8e9:	c1 f8 02             	sar    $0x2,%eax
f010c8ec:	89 c2                	mov    %eax,%edx
f010c8ee:	89 d0                	mov    %edx,%eax
f010c8f0:	c1 e0 03             	shl    $0x3,%eax
f010c8f3:	01 d0                	add    %edx,%eax
f010c8f5:	c1 e0 03             	shl    $0x3,%eax
f010c8f8:	01 d0                	add    %edx,%eax
f010c8fa:	c1 e0 02             	shl    $0x2,%eax
f010c8fd:	01 d0                	add    %edx,%eax
f010c8ff:	01 c0                	add    %eax,%eax
f010c901:	01 d0                	add    %edx,%eax
f010c903:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c90a:	01 c8                	add    %ecx,%eax
f010c90c:	c1 e0 02             	shl    $0x2,%eax
f010c90f:	01 d0                	add    %edx,%eax
f010c911:	c1 e0 03             	shl    $0x3,%eax
f010c914:	01 d0                	add    %edx,%eax
f010c916:	c1 e0 05             	shl    $0x5,%eax
f010c919:	29 d0                	sub    %edx,%eax
f010c91b:	c1 e0 02             	shl    $0x2,%eax
f010c91e:	01 d0                	add    %edx,%eax
f010c920:	01 c0                	add    %eax,%eax
f010c922:	01 d0                	add    %edx,%eax
f010c924:	c1 e0 03             	shl    $0x3,%eax
f010c927:	01 d0                	add    %edx,%eax
f010c929:	c1 e0 04             	shl    $0x4,%eax
f010c92c:	29 d0                	sub    %edx,%eax
f010c92e:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c931:	89 c2                	mov    %eax,%edx
f010c933:	8b 45 08             	mov    0x8(%ebp),%eax
f010c936:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c939:	e8 08 f1 ff ff       	call   f010ba46 <get_cpu_proc>
f010c93e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c941:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c945:	75 0c                	jne    f010c953 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c947:	8b 45 08             	mov    0x8(%ebp),%eax
f010c94a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c951:	eb 0c                	jmp    f010c95f <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c953:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c956:	8b 50 10             	mov    0x10(%eax),%edx
f010c959:	8b 45 08             	mov    0x8(%ebp),%eax
f010c95c:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c95f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c962:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c969:	8b 45 08             	mov    0x8(%ebp),%eax
f010c96c:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c973:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c976:	8b 45 08             	mov    0x8(%ebp),%eax
f010c979:	8b 00                	mov    (%eax),%eax
f010c97b:	83 ec 04             	sub    $0x4,%esp
f010c97e:	6a 44                	push   $0x44
f010c980:	6a 00                	push   $0x0
f010c982:	50                   	push   %eax
f010c983:	e8 e8 34 01 00       	call   f011fe70 <memset>
f010c988:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c98b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c98e:	8b 00                	mov    (%eax),%eax
f010c990:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c996:	8b 45 08             	mov    0x8(%ebp),%eax
f010c999:	8b 00                	mov    (%eax),%eax
f010c99b:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c9a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9a4:	8b 00                	mov    (%eax),%eax
f010c9a6:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c9ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9af:	8b 00                	mov    (%eax),%eax
f010c9b1:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c9b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9bb:	8b 00                	mov    (%eax),%eax
f010c9bd:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c9c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9c6:	8b 00                	mov    (%eax),%eax
f010c9c8:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9cb:	8b 12                	mov    (%edx),%edx
f010c9cd:	8b 52 38             	mov    0x38(%edx),%edx
f010c9d0:	80 ce 02             	or     $0x2,%dh
f010c9d3:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c9d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c9da:	75 17                	jne    f010c9f3 <complete_environment_initialization+0x1de>
f010c9dc:	83 ec 04             	sub    $0x4,%esp
f010c9df:	68 e3 62 12 f0       	push   $0xf01262e3
f010c9e4:	68 67 04 00 00       	push   $0x467
f010c9e9:	68 5b 62 12 f0       	push   $0xf012625b
f010c9ee:	e8 46 39 ff ff       	call   f0100339 <_panic>
f010c9f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9f6:	8b 40 08             	mov    0x8(%eax),%eax
f010c9f9:	85 c0                	test   %eax,%eax
f010c9fb:	74 11                	je     f010ca0e <complete_environment_initialization+0x1f9>
f010c9fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca00:	8b 40 08             	mov    0x8(%eax),%eax
f010ca03:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca06:	8b 52 0c             	mov    0xc(%edx),%edx
f010ca09:	89 50 0c             	mov    %edx,0xc(%eax)
f010ca0c:	eb 0b                	jmp    f010ca19 <complete_environment_initialization+0x204>
f010ca0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca11:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca14:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010ca19:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca1c:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca1f:	85 c0                	test   %eax,%eax
f010ca21:	74 11                	je     f010ca34 <complete_environment_initialization+0x21f>
f010ca23:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca26:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca29:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca2c:	8b 52 08             	mov    0x8(%edx),%edx
f010ca2f:	89 50 08             	mov    %edx,0x8(%eax)
f010ca32:	eb 0b                	jmp    f010ca3f <complete_environment_initialization+0x22a>
f010ca34:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca37:	8b 40 08             	mov    0x8(%eax),%eax
f010ca3a:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010ca3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca42:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010ca49:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca4c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ca53:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010ca58:	48                   	dec    %eax
f010ca59:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
	return ;
f010ca5e:	90                   	nop
}
f010ca5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ca62:	c9                   	leave  
f010ca63:	c3                   	ret    

f010ca64 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010ca64:	55                   	push   %ebp
f010ca65:	89 e5                	mov    %esp,%ebp
f010ca67:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ca70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca73:	8b 00                	mov    (%eax),%eax
f010ca75:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ca7a:	74 17                	je     f010ca93 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010ca7c:	83 ec 04             	sub    $0x4,%esp
f010ca7f:	68 09 65 12 f0       	push   $0xf0126509
f010ca84:	68 73 04 00 00       	push   $0x473
f010ca89:	68 5b 62 12 f0       	push   $0xf012625b
f010ca8e:	e8 a6 38 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010ca93:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca96:	8b 00                	mov    (%eax),%eax
f010ca98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca9b:	8b 52 18             	mov    0x18(%edx),%edx
f010ca9e:	89 50 30             	mov    %edx,0x30(%eax)
}
f010caa1:	90                   	nop
f010caa2:	c9                   	leave  
f010caa3:	c3                   	ret    

f010caa4 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010caa4:	55                   	push   %ebp
f010caa5:	89 e5                	mov    %esp,%ebp
f010caa7:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010caaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010caad:	8b 40 10             	mov    0x10(%eax),%eax
f010cab0:	8d 48 01             	lea    0x1(%eax),%ecx
f010cab3:	8b 55 08             	mov    0x8(%ebp),%edx
f010cab6:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cab9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cabc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cabf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cac5:	8b 00                	mov    (%eax),%eax
f010cac7:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cacc:	74 17                	je     f010cae5 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010cace:	83 ec 04             	sub    $0x4,%esp
f010cad1:	68 09 65 12 f0       	push   $0xf0126509
f010cad6:	68 81 04 00 00       	push   $0x481
f010cadb:	68 5b 62 12 f0       	push   $0xf012625b
f010cae0:	e8 54 38 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cae5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cae8:	8b 50 1c             	mov    0x1c(%eax),%edx
f010caeb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010caee:	01 d0                	add    %edx,%eax
f010caf0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010caf3:	eb 0f                	jmp    f010cb04 <PROGRAM_SEGMENT_NEXT+0x60>
f010caf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010caf8:	8b 40 10             	mov    0x10(%eax),%eax
f010cafb:	8d 50 01             	lea    0x1(%eax),%edx
f010cafe:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb01:	89 50 10             	mov    %edx,0x10(%eax)
f010cb04:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb07:	8b 40 10             	mov    0x10(%eax),%eax
f010cb0a:	c1 e0 05             	shl    $0x5,%eax
f010cb0d:	89 c2                	mov    %eax,%edx
f010cb0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb12:	01 d0                	add    %edx,%eax
f010cb14:	8b 00                	mov    (%eax),%eax
f010cb16:	83 f8 01             	cmp    $0x1,%eax
f010cb19:	74 13                	je     f010cb2e <PROGRAM_SEGMENT_NEXT+0x8a>
f010cb1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb1e:	8b 50 10             	mov    0x10(%eax),%edx
f010cb21:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb24:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb27:	0f b7 c0             	movzwl %ax,%eax
f010cb2a:	39 c2                	cmp    %eax,%edx
f010cb2c:	72 c7                	jb     f010caf5 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cb2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb31:	8b 40 10             	mov    0x10(%eax),%eax
f010cb34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb3a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb3d:	0f b7 c0             	movzwl %ax,%eax
f010cb40:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010cb43:	7e 63                	jle    f010cba8 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb48:	c1 e0 05             	shl    $0x5,%eax
f010cb4b:	89 c2                	mov    %eax,%edx
f010cb4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb50:	01 d0                	add    %edx,%eax
f010cb52:	8b 50 04             	mov    0x4(%eax),%edx
f010cb55:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb58:	01 c2                	add    %eax,%edx
f010cb5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb5d:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010cb5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb62:	c1 e0 05             	shl    $0x5,%eax
f010cb65:	89 c2                	mov    %eax,%edx
f010cb67:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb6a:	01 d0                	add    %edx,%eax
f010cb6c:	8b 50 14             	mov    0x14(%eax),%edx
f010cb6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb72:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010cb75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb78:	c1 e0 05             	shl    $0x5,%eax
f010cb7b:	89 c2                	mov    %eax,%edx
f010cb7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb80:	01 d0                	add    %edx,%eax
f010cb82:	8b 50 10             	mov    0x10(%eax),%edx
f010cb85:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb88:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cb8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb8e:	c1 e0 05             	shl    $0x5,%eax
f010cb91:	89 c2                	mov    %eax,%edx
f010cb93:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb96:	01 d0                	add    %edx,%eax
f010cb98:	8b 40 08             	mov    0x8(%eax),%eax
f010cb9b:	89 c2                	mov    %eax,%edx
f010cb9d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cba0:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cba3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cba6:	eb 05                	jmp    f010cbad <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010cba8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010cbad:	c9                   	leave  
f010cbae:	c3                   	ret    

f010cbaf <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010cbaf:	55                   	push   %ebp
f010cbb0:	89 e5                	mov    %esp,%ebp
f010cbb2:	57                   	push   %edi
f010cbb3:	56                   	push   %esi
f010cbb4:	53                   	push   %ebx
f010cbb5:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cbb8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cbbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cbc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cbc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbc8:	8b 00                	mov    (%eax),%eax
f010cbca:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cbcf:	74 17                	je     f010cbe8 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cbd1:	83 ec 04             	sub    $0x4,%esp
f010cbd4:	68 09 65 12 f0       	push   $0xf0126509
f010cbd9:	68 9d 04 00 00       	push   $0x49d
f010cbde:	68 5b 62 12 f0       	push   $0xf012625b
f010cbe3:	e8 51 37 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cbe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbeb:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cbee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cbf1:	01 d0                	add    %edx,%eax
f010cbf3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cbf6:	eb 07                	jmp    f010cbff <PROGRAM_SEGMENT_FIRST+0x50>
f010cbf8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cbfb:	40                   	inc    %eax
f010cbfc:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cbff:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc02:	c1 e0 05             	shl    $0x5,%eax
f010cc05:	89 c2                	mov    %eax,%edx
f010cc07:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc0a:	01 d0                	add    %edx,%eax
f010cc0c:	8b 00                	mov    (%eax),%eax
f010cc0e:	83 f8 01             	cmp    $0x1,%eax
f010cc11:	74 10                	je     f010cc23 <PROGRAM_SEGMENT_FIRST+0x74>
f010cc13:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cc16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc19:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cc1c:	0f b7 c0             	movzwl %ax,%eax
f010cc1f:	39 c2                	cmp    %eax,%edx
f010cc21:	72 d5                	jb     f010cbf8 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cc23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc26:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cc29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc2c:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cc2f:	0f b7 c0             	movzwl %ax,%eax
f010cc32:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cc35:	7e 68                	jle    f010cc9f <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cc37:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc3a:	c1 e0 05             	shl    $0x5,%eax
f010cc3d:	89 c2                	mov    %eax,%edx
f010cc3f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc42:	01 d0                	add    %edx,%eax
f010cc44:	8b 50 04             	mov    0x4(%eax),%edx
f010cc47:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc4a:	01 d0                	add    %edx,%eax
f010cc4c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cc4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc52:	c1 e0 05             	shl    $0x5,%eax
f010cc55:	89 c2                	mov    %eax,%edx
f010cc57:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc5a:	01 d0                	add    %edx,%eax
f010cc5c:	8b 40 14             	mov    0x14(%eax),%eax
f010cc5f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cc62:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc65:	c1 e0 05             	shl    $0x5,%eax
f010cc68:	89 c2                	mov    %eax,%edx
f010cc6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc6d:	01 d0                	add    %edx,%eax
f010cc6f:	8b 40 10             	mov    0x10(%eax),%eax
f010cc72:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cc75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc78:	c1 e0 05             	shl    $0x5,%eax
f010cc7b:	89 c2                	mov    %eax,%edx
f010cc7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc80:	01 d0                	add    %edx,%eax
f010cc82:	8b 40 08             	mov    0x8(%eax),%eax
f010cc85:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cc88:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc8b:	89 c3                	mov    %eax,%ebx
f010cc8d:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cc90:	ba 05 00 00 00       	mov    $0x5,%edx
f010cc95:	89 df                	mov    %ebx,%edi
f010cc97:	89 c6                	mov    %eax,%esi
f010cc99:	89 d1                	mov    %edx,%ecx
f010cc9b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cc9d:	eb 1c                	jmp    f010ccbb <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cc9f:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cca6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cca9:	89 c3                	mov    %eax,%ebx
f010ccab:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ccae:	ba 05 00 00 00       	mov    $0x5,%edx
f010ccb3:	89 df                	mov    %ebx,%edi
f010ccb5:	89 c6                	mov    %eax,%esi
f010ccb7:	89 d1                	mov    %edx,%ecx
f010ccb9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010ccbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ccc1:	5b                   	pop    %ebx
f010ccc2:	5e                   	pop    %esi
f010ccc3:	5f                   	pop    %edi
f010ccc4:	5d                   	pop    %ebp
f010ccc5:	c2 04 00             	ret    $0x4

f010ccc8 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010ccc8:	55                   	push   %ebp
f010ccc9:	89 e5                	mov    %esp,%ebp
f010cccb:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010ccce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010ccd5:	83 ec 0c             	sub    $0xc,%esp
f010ccd8:	68 a0 16 6c f0       	push   $0xf06c16a0
f010ccdd:	e8 f2 2f 00 00       	call   f010fcd4 <acquire_spinlock>
f010cce2:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cce5:	a1 90 16 6c f0       	mov    0xf06c1690,%eax
f010ccea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cced:	e9 c3 00 00 00       	jmp    f010cdb5 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010ccf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccf5:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccf8:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ccfb:	0f 85 ac 00 00 00    	jne    f010cdad <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cd01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd04:	8b 50 10             	mov    0x10(%eax),%edx
f010cd07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd0a:	8b 40 0c             	mov    0xc(%eax),%eax
f010cd0d:	8b 40 64             	mov    0x64(%eax),%eax
f010cd10:	83 ec 08             	sub    $0x8,%esp
f010cd13:	52                   	push   %edx
f010cd14:	50                   	push   %eax
f010cd15:	e8 79 d0 ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f010cd1a:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cd1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd21:	75 17                	jne    f010cd3a <cleanup_buffers+0x72>
f010cd23:	83 ec 04             	sub    $0x4,%esp
f010cd26:	68 e3 62 12 f0       	push   $0xf01262e3
f010cd2b:	68 c6 04 00 00       	push   $0x4c6
f010cd30:	68 5b 62 12 f0       	push   $0xf012625b
f010cd35:	e8 ff 35 ff ff       	call   f0100339 <_panic>
f010cd3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd3d:	8b 00                	mov    (%eax),%eax
f010cd3f:	85 c0                	test   %eax,%eax
f010cd41:	74 10                	je     f010cd53 <cleanup_buffers+0x8b>
f010cd43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd46:	8b 00                	mov    (%eax),%eax
f010cd48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd4b:	8b 52 04             	mov    0x4(%edx),%edx
f010cd4e:	89 50 04             	mov    %edx,0x4(%eax)
f010cd51:	eb 0b                	jmp    f010cd5e <cleanup_buffers+0x96>
f010cd53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd56:	8b 40 04             	mov    0x4(%eax),%eax
f010cd59:	a3 94 16 6c f0       	mov    %eax,0xf06c1694
f010cd5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd61:	8b 40 04             	mov    0x4(%eax),%eax
f010cd64:	85 c0                	test   %eax,%eax
f010cd66:	74 0f                	je     f010cd77 <cleanup_buffers+0xaf>
f010cd68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd6b:	8b 40 04             	mov    0x4(%eax),%eax
f010cd6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd71:	8b 12                	mov    (%edx),%edx
f010cd73:	89 10                	mov    %edx,(%eax)
f010cd75:	eb 0a                	jmp    f010cd81 <cleanup_buffers+0xb9>
f010cd77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd7a:	8b 00                	mov    (%eax),%eax
f010cd7c:	a3 90 16 6c f0       	mov    %eax,0xf06c1690
f010cd81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cd8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd8d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cd94:	a1 9c 16 6c f0       	mov    0xf06c169c,%eax
f010cd99:	48                   	dec    %eax
f010cd9a:	a3 9c 16 6c f0       	mov    %eax,0xf06c169c

				free_frame(ptr_fi);
f010cd9f:	83 ec 0c             	sub    $0xc,%esp
f010cda2:	ff 75 f4             	pushl  -0xc(%ebp)
f010cda5:	e8 5c b5 ff ff       	call   f0108306 <free_frame>
f010cdaa:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cdad:	a1 98 16 6c f0       	mov    0xf06c1698,%eax
f010cdb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cdb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cdb9:	74 07                	je     f010cdc2 <cleanup_buffers+0xfa>
f010cdbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdbe:	8b 00                	mov    (%eax),%eax
f010cdc0:	eb 05                	jmp    f010cdc7 <cleanup_buffers+0xff>
f010cdc2:	b8 00 00 00 00       	mov    $0x0,%eax
f010cdc7:	a3 98 16 6c f0       	mov    %eax,0xf06c1698
f010cdcc:	a1 98 16 6c f0       	mov    0xf06c1698,%eax
f010cdd1:	85 c0                	test   %eax,%eax
f010cdd3:	0f 85 19 ff ff ff    	jne    f010ccf2 <cleanup_buffers+0x2a>
f010cdd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cddd:	0f 85 0f ff ff ff    	jne    f010ccf2 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010cde3:	83 ec 0c             	sub    $0xc,%esp
f010cde6:	68 a0 16 6c f0       	push   $0xf06c16a0
f010cdeb:	e8 6b 2f 00 00       	call   f010fd5b <release_spinlock>
f010cdf0:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010cdf3:	90                   	nop
f010cdf4:	c9                   	leave  
f010cdf5:	c3                   	ret    

f010cdf6 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010cdf6:	55                   	push   %ebp
f010cdf7:	89 e5                	mov    %esp,%ebp
f010cdf9:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010cdfc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010ce00:	7e 06                	jle    f010ce08 <set_program_priority+0x12>
f010ce02:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ce06:	7e 14                	jle    f010ce1c <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010ce08:	83 ec 04             	sub    $0x4,%esp
f010ce0b:	68 20 65 12 f0       	push   $0xf0126520
f010ce10:	6a 10                	push   $0x10
f010ce12:	68 44 65 12 f0       	push   $0xf0126544
f010ce17:	e8 1d 35 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010ce1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ce20:	74 78                	je     f010ce9a <set_program_priority+0xa4>
		return;
	switch(priority)
f010ce22:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ce26:	77 56                	ja     f010ce7e <set_program_priority+0x88>
f010ce28:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce2b:	c1 e0 02             	shl    $0x2,%eax
f010ce2e:	05 80 65 12 f0       	add    $0xf0126580,%eax
f010ce33:	8b 00                	mov    (%eax),%eax
f010ce35:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010ce37:	83 ec 08             	sub    $0x8,%esp
f010ce3a:	6a 01                	push   $0x1
f010ce3c:	ff 75 08             	pushl  0x8(%ebp)
f010ce3f:	e8 a6 dc ff ff       	call   f010aaea <half_WS_Size>
f010ce44:	83 c4 10             	add    $0x10,%esp
			break;
f010ce47:	eb 35                	jmp    f010ce7e <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010ce49:	83 ec 08             	sub    $0x8,%esp
f010ce4c:	6a 00                	push   $0x0
f010ce4e:	ff 75 08             	pushl  0x8(%ebp)
f010ce51:	e8 94 dc ff ff       	call   f010aaea <half_WS_Size>
f010ce56:	83 c4 10             	add    $0x10,%esp
			break;
f010ce59:	eb 23                	jmp    f010ce7e <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010ce5b:	83 ec 08             	sub    $0x8,%esp
f010ce5e:	6a 01                	push   $0x1
f010ce60:	ff 75 08             	pushl  0x8(%ebp)
f010ce63:	e8 65 dc ff ff       	call   f010aacd <double_WS_Size>
f010ce68:	83 c4 10             	add    $0x10,%esp
			break;
f010ce6b:	eb 11                	jmp    f010ce7e <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010ce6d:	83 ec 08             	sub    $0x8,%esp
f010ce70:	6a 00                	push   $0x0
f010ce72:	ff 75 08             	pushl  0x8(%ebp)
f010ce75:	e8 53 dc ff ff       	call   f010aacd <double_WS_Size>
f010ce7a:	83 c4 10             	add    $0x10,%esp
			break;
f010ce7d:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010ce7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce81:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ce87:	83 ec 08             	sub    $0x8,%esp
f010ce8a:	50                   	push   %eax
f010ce8b:	68 61 65 12 f0       	push   $0xf0126561
f010ce90:	e8 f6 40 ff ff       	call   f0100f8b <cprintf>
f010ce95:	83 c4 10             	add    $0x10,%esp
f010ce98:	eb 01                	jmp    f010ce9b <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010ce9a:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010ce9b:	c9                   	leave  
f010ce9c:	c3                   	ret    

f010ce9d <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010ce9d:	55                   	push   %ebp
f010ce9e:	89 e5                	mov    %esp,%ebp
f010cea0:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cea3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ceaa:	eb 29                	jmp    f010ced5 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010ceac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ceaf:	89 d0                	mov    %edx,%eax
f010ceb1:	01 c0                	add    %eax,%eax
f010ceb3:	01 d0                	add    %edx,%eax
f010ceb5:	c1 e0 02             	shl    $0x2,%eax
f010ceb8:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010cebd:	8b 00                	mov    (%eax),%eax
f010cebf:	83 ec 08             	sub    $0x8,%esp
f010cec2:	50                   	push   %eax
f010cec3:	ff 75 08             	pushl  0x8(%ebp)
f010cec6:	e8 c3 2e 01 00       	call   f011fd8e <strcmp>
f010cecb:	83 c4 10             	add    $0x10,%esp
f010cece:	85 c0                	test   %eax,%eax
f010ced0:	74 0f                	je     f010cee1 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ced2:	ff 45 f4             	incl   -0xc(%ebp)
f010ced5:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ceda:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cedd:	7c cd                	jl     f010ceac <get_user_program_info+0xf>
f010cedf:	eb 01                	jmp    f010cee2 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010cee1:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cee2:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cee7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ceea:	75 1a                	jne    f010cf06 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010ceec:	83 ec 08             	sub    $0x8,%esp
f010ceef:	ff 75 08             	pushl  0x8(%ebp)
f010cef2:	68 e5 72 12 f0       	push   $0xf01272e5
f010cef7:	e8 8f 40 ff ff       	call   f0100f8b <cprintf>
f010cefc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ceff:	b8 00 00 00 00       	mov    $0x0,%eax
f010cf04:	eb 11                	jmp    f010cf17 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cf06:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf09:	89 d0                	mov    %edx,%eax
f010cf0b:	01 c0                	add    %eax,%eax
f010cf0d:	01 d0                	add    %edx,%eax
f010cf0f:	c1 e0 02             	shl    $0x2,%eax
f010cf12:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010cf17:	c9                   	leave  
f010cf18:	c3                   	ret    

f010cf19 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010cf19:	55                   	push   %ebp
f010cf1a:	89 e5                	mov    %esp,%ebp
f010cf1c:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cf26:	eb 2d                	jmp    f010cf55 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010cf28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf2b:	89 d0                	mov    %edx,%eax
f010cf2d:	01 c0                	add    %eax,%eax
f010cf2f:	01 d0                	add    %edx,%eax
f010cf31:	c1 e0 02             	shl    $0x2,%eax
f010cf34:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010cf39:	8b 00                	mov    (%eax),%eax
f010cf3b:	8b 55 08             	mov    0x8(%ebp),%edx
f010cf3e:	83 c2 20             	add    $0x20,%edx
f010cf41:	83 ec 08             	sub    $0x8,%esp
f010cf44:	50                   	push   %eax
f010cf45:	52                   	push   %edx
f010cf46:	e8 43 2e 01 00       	call   f011fd8e <strcmp>
f010cf4b:	83 c4 10             	add    $0x10,%esp
f010cf4e:	85 c0                	test   %eax,%eax
f010cf50:	74 0f                	je     f010cf61 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf52:	ff 45 f4             	incl   -0xc(%ebp)
f010cf55:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cf5a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf5d:	7c c9                	jl     f010cf28 <get_user_program_info_by_env+0xf>
f010cf5f:	eb 01                	jmp    f010cf62 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010cf61:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cf62:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cf67:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf6a:	75 17                	jne    f010cf83 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010cf6c:	83 ec 0c             	sub    $0xc,%esp
f010cf6f:	68 00 73 12 f0       	push   $0xf0127300
f010cf74:	e8 12 40 ff ff       	call   f0100f8b <cprintf>
f010cf79:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cf7c:	b8 00 00 00 00       	mov    $0x0,%eax
f010cf81:	eb 11                	jmp    f010cf94 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010cf83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf86:	89 d0                	mov    %edx,%eax
f010cf88:	01 c0                	add    %eax,%eax
f010cf8a:	01 d0                	add    %edx,%eax
f010cf8c:	c1 e0 02             	shl    $0x2,%eax
f010cf8f:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010cf94:	c9                   	leave  
f010cf95:	c3                   	ret    

f010cf96 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010cf96:	55                   	push   %ebp
f010cf97:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010cf99:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf9c:	83 f8 13             	cmp    $0x13,%eax
f010cf9f:	77 0c                	ja     f010cfad <trapname+0x17>
		return excnames[trapno];
f010cfa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfa4:	8b 04 85 e0 76 12 f0 	mov    -0xfed8920(,%eax,4),%eax
f010cfab:	eb 2c                	jmp    f010cfd9 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010cfad:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010cfb1:	75 07                	jne    f010cfba <trapname+0x24>
		return "System call";
f010cfb3:	b8 20 73 12 f0       	mov    $0xf0127320,%eax
f010cfb8:	eb 1f                	jmp    f010cfd9 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010cfba:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010cfbe:	75 07                	jne    f010cfc7 <trapname+0x31>
		return "Clock Interrupt";
f010cfc0:	b8 2c 73 12 f0       	mov    $0xf012732c,%eax
f010cfc5:	eb 12                	jmp    f010cfd9 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010cfc7:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010cfcb:	75 07                	jne    f010cfd4 <trapname+0x3e>
		return "Keyboard Interrupt";
f010cfcd:	b8 3c 73 12 f0       	mov    $0xf012733c,%eax
f010cfd2:	eb 05                	jmp    f010cfd9 <trapname+0x43>
	return "(unknown trap)";
f010cfd4:	b8 4f 73 12 f0       	mov    $0xf012734f,%eax
}
f010cfd9:	5d                   	pop    %ebp
f010cfda:	c3                   	ret    

f010cfdb <ts_init>:


void ts_init(void)
{
f010cfdb:	55                   	push   %ebp
f010cfdc:	89 e5                	mov    %esp,%ebp
f010cfde:	53                   	push   %ebx
f010cfdf:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cfe2:	e8 e8 a1 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010cfe7:	e8 20 a1 ff ff       	call   f010710c <mycpu>
f010cfec:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010cfef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cff2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010cff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cffc:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d002:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d005:	83 c0 0c             	add    $0xc,%eax
f010d008:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d00b:	83 c2 0c             	add    $0xc,%edx
f010d00e:	c1 ea 10             	shr    $0x10,%edx
f010d011:	88 d3                	mov    %dl,%bl
f010d013:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d016:	83 c2 0c             	add    $0xc,%edx
f010d019:	c1 ea 18             	shr    $0x18,%edx
f010d01c:	88 d1                	mov    %dl,%cl
f010d01e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d021:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d028:	68 00 
f010d02a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d02d:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d034:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d037:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d040:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d046:	83 e2 f0             	and    $0xfffffff0,%edx
f010d049:	83 ca 09             	or     $0x9,%edx
f010d04c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d052:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d055:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d05b:	83 ca 10             	or     $0x10,%edx
f010d05e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d064:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d067:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d06d:	83 e2 9f             	and    $0xffffff9f,%edx
f010d070:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d076:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d079:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d07f:	83 ca 80             	or     $0xffffff80,%edx
f010d082:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d08b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d091:	83 e2 f0             	and    $0xfffffff0,%edx
f010d094:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d09a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d09d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0a3:	83 e2 ef             	and    $0xffffffef,%edx
f010d0a6:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0af:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0b5:	83 e2 df             	and    $0xffffffdf,%edx
f010d0b8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0c1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0c7:	83 ca 40             	or     $0x40,%edx
f010d0ca:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0d3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0d9:	83 e2 7f             	and    $0x7f,%edx
f010d0dc:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0e5:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d0eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0ee:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d0f4:	83 e2 ef             	and    $0xffffffef,%edx
f010d0f7:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d0fd:	e8 1f a1 ff ff       	call   f0107221 <popcli>
f010d102:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d108:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d10c:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d10f:	90                   	nop
f010d110:	83 c4 14             	add    $0x14,%esp
f010d113:	5b                   	pop    %ebx
f010d114:	5d                   	pop    %ebp
f010d115:	c3                   	ret    

f010d116 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d116:	55                   	push   %ebp
f010d117:	89 e5                	mov    %esp,%ebp
f010d119:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d11c:	b8 c4 e5 10 f0       	mov    $0xf010e5c4,%eax
f010d121:	66 a3 60 8b 69 f0    	mov    %ax,0xf0698b60
f010d127:	66 c7 05 62 8b 69 f0 	movw   $0x8,0xf0698b62
f010d12e:	08 00 
f010d130:	a0 64 8b 69 f0       	mov    0xf0698b64,%al
f010d135:	83 e0 e0             	and    $0xffffffe0,%eax
f010d138:	a2 64 8b 69 f0       	mov    %al,0xf0698b64
f010d13d:	a0 64 8b 69 f0       	mov    0xf0698b64,%al
f010d142:	83 e0 1f             	and    $0x1f,%eax
f010d145:	a2 64 8b 69 f0       	mov    %al,0xf0698b64
f010d14a:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d14f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d152:	83 c8 0e             	or     $0xe,%eax
f010d155:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d15a:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d15f:	83 e0 ef             	and    $0xffffffef,%eax
f010d162:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d167:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d16c:	83 e0 9f             	and    $0xffffff9f,%eax
f010d16f:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d174:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d179:	83 c8 80             	or     $0xffffff80,%eax
f010d17c:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d181:	b8 c4 e5 10 f0       	mov    $0xf010e5c4,%eax
f010d186:	c1 e8 10             	shr    $0x10,%eax
f010d189:	66 a3 66 8b 69 f0    	mov    %ax,0xf0698b66
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d18f:	b8 cc e5 10 f0       	mov    $0xf010e5cc,%eax
f010d194:	66 a3 90 8b 69 f0    	mov    %ax,0xf0698b90
f010d19a:	66 c7 05 92 8b 69 f0 	movw   $0x8,0xf0698b92
f010d1a1:	08 00 
f010d1a3:	a0 94 8b 69 f0       	mov    0xf0698b94,%al
f010d1a8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1ab:	a2 94 8b 69 f0       	mov    %al,0xf0698b94
f010d1b0:	a0 94 8b 69 f0       	mov    0xf0698b94,%al
f010d1b5:	83 e0 1f             	and    $0x1f,%eax
f010d1b8:	a2 94 8b 69 f0       	mov    %al,0xf0698b94
f010d1bd:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d1c2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1c5:	83 c8 0e             	or     $0xe,%eax
f010d1c8:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d1cd:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d1d2:	83 e0 ef             	and    $0xffffffef,%eax
f010d1d5:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d1da:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d1df:	83 e0 9f             	and    $0xffffff9f,%eax
f010d1e2:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d1e7:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d1ec:	83 c8 80             	or     $0xffffff80,%eax
f010d1ef:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d1f4:	b8 cc e5 10 f0       	mov    $0xf010e5cc,%eax
f010d1f9:	c1 e8 10             	shr    $0x10,%eax
f010d1fc:	66 a3 96 8b 69 f0    	mov    %ax,0xf0698b96
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d202:	b8 d4 e5 10 f0       	mov    $0xf010e5d4,%eax
f010d207:	66 a3 20 8c 69 f0    	mov    %ax,0xf0698c20
f010d20d:	66 c7 05 22 8c 69 f0 	movw   $0x8,0xf0698c22
f010d214:	08 00 
f010d216:	a0 24 8c 69 f0       	mov    0xf0698c24,%al
f010d21b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d21e:	a2 24 8c 69 f0       	mov    %al,0xf0698c24
f010d223:	a0 24 8c 69 f0       	mov    0xf0698c24,%al
f010d228:	83 e0 1f             	and    $0x1f,%eax
f010d22b:	a2 24 8c 69 f0       	mov    %al,0xf0698c24
f010d230:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d235:	83 e0 f0             	and    $0xfffffff0,%eax
f010d238:	83 c8 0e             	or     $0xe,%eax
f010d23b:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d240:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d245:	83 e0 ef             	and    $0xffffffef,%eax
f010d248:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d24d:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d252:	83 c8 60             	or     $0x60,%eax
f010d255:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d25a:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d25f:	83 c8 80             	or     $0xffffff80,%eax
f010d262:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d267:	b8 d4 e5 10 f0       	mov    $0xf010e5d4,%eax
f010d26c:	c1 e8 10             	shr    $0x10,%eax
f010d26f:	66 a3 26 8c 69 f0    	mov    %ax,0xf0698c26
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d275:	b8 de e5 10 f0       	mov    $0xf010e5de,%eax
f010d27a:	66 a3 28 8c 69 f0    	mov    %ax,0xf0698c28
f010d280:	66 c7 05 2a 8c 69 f0 	movw   $0x8,0xf0698c2a
f010d287:	08 00 
f010d289:	a0 2c 8c 69 f0       	mov    0xf0698c2c,%al
f010d28e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d291:	a2 2c 8c 69 f0       	mov    %al,0xf0698c2c
f010d296:	a0 2c 8c 69 f0       	mov    0xf0698c2c,%al
f010d29b:	83 e0 1f             	and    $0x1f,%eax
f010d29e:	a2 2c 8c 69 f0       	mov    %al,0xf0698c2c
f010d2a3:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d2a8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2ab:	83 c8 0e             	or     $0xe,%eax
f010d2ae:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d2b3:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d2b8:	83 e0 ef             	and    $0xffffffef,%eax
f010d2bb:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d2c0:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d2c5:	83 c8 60             	or     $0x60,%eax
f010d2c8:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d2cd:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d2d2:	83 c8 80             	or     $0xffffff80,%eax
f010d2d5:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d2da:	b8 de e5 10 f0       	mov    $0xf010e5de,%eax
f010d2df:	c1 e8 10             	shr    $0x10,%eax
f010d2e2:	66 a3 2e 8c 69 f0    	mov    %ax,0xf0698c2e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d2e8:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d2ed:	66 a3 a0 8c 69 f0    	mov    %ax,0xf0698ca0
f010d2f3:	66 c7 05 a2 8c 69 f0 	movw   $0x8,0xf0698ca2
f010d2fa:	08 00 
f010d2fc:	a0 a4 8c 69 f0       	mov    0xf0698ca4,%al
f010d301:	83 e0 e0             	and    $0xffffffe0,%eax
f010d304:	a2 a4 8c 69 f0       	mov    %al,0xf0698ca4
f010d309:	a0 a4 8c 69 f0       	mov    0xf0698ca4,%al
f010d30e:	83 e0 1f             	and    $0x1f,%eax
f010d311:	a2 a4 8c 69 f0       	mov    %al,0xf0698ca4
f010d316:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d31b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d31e:	83 c8 0e             	or     $0xe,%eax
f010d321:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d326:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d32b:	83 e0 ef             	and    $0xffffffef,%eax
f010d32e:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d333:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d338:	83 c8 60             	or     $0x60,%eax
f010d33b:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d340:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d345:	83 c8 80             	or     $0xffffff80,%eax
f010d348:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d34d:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d352:	c1 e8 10             	shr    $0x10,%eax
f010d355:	66 a3 a6 8c 69 f0    	mov    %ax,0xf0698ca6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d35b:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d360:	66 a3 20 8b 69 f0    	mov    %ax,0xf0698b20
f010d366:	66 c7 05 22 8b 69 f0 	movw   $0x8,0xf0698b22
f010d36d:	08 00 
f010d36f:	a0 24 8b 69 f0       	mov    0xf0698b24,%al
f010d374:	83 e0 e0             	and    $0xffffffe0,%eax
f010d377:	a2 24 8b 69 f0       	mov    %al,0xf0698b24
f010d37c:	a0 24 8b 69 f0       	mov    0xf0698b24,%al
f010d381:	83 e0 1f             	and    $0x1f,%eax
f010d384:	a2 24 8b 69 f0       	mov    %al,0xf0698b24
f010d389:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d38e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d391:	83 c8 0e             	or     $0xe,%eax
f010d394:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d399:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d39e:	83 e0 ef             	and    $0xffffffef,%eax
f010d3a1:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d3a6:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d3ab:	83 c8 60             	or     $0x60,%eax
f010d3ae:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d3b3:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d3b8:	83 c8 80             	or     $0xffffff80,%eax
f010d3bb:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d3c0:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d3c5:	c1 e8 10             	shr    $0x10,%eax
f010d3c8:	66 a3 26 8b 69 f0    	mov    %ax,0xf0698b26
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d3ce:	b8 fc e5 10 f0       	mov    $0xf010e5fc,%eax
f010d3d3:	66 a3 28 8b 69 f0    	mov    %ax,0xf0698b28
f010d3d9:	66 c7 05 2a 8b 69 f0 	movw   $0x8,0xf0698b2a
f010d3e0:	08 00 
f010d3e2:	a0 2c 8b 69 f0       	mov    0xf0698b2c,%al
f010d3e7:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3ea:	a2 2c 8b 69 f0       	mov    %al,0xf0698b2c
f010d3ef:	a0 2c 8b 69 f0       	mov    0xf0698b2c,%al
f010d3f4:	83 e0 1f             	and    $0x1f,%eax
f010d3f7:	a2 2c 8b 69 f0       	mov    %al,0xf0698b2c
f010d3fc:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d401:	83 c8 0f             	or     $0xf,%eax
f010d404:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d409:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d40e:	83 e0 ef             	and    $0xffffffef,%eax
f010d411:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d416:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d41b:	83 c8 60             	or     $0x60,%eax
f010d41e:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d423:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d428:	83 c8 80             	or     $0xffffff80,%eax
f010d42b:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d430:	b8 fc e5 10 f0       	mov    $0xf010e5fc,%eax
f010d435:	c1 e8 10             	shr    $0x10,%eax
f010d438:	66 a3 2e 8b 69 f0    	mov    %ax,0xf0698b2e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d43e:	b8 06 e6 10 f0       	mov    $0xf010e606,%eax
f010d443:	66 a3 30 8b 69 f0    	mov    %ax,0xf0698b30
f010d449:	66 c7 05 32 8b 69 f0 	movw   $0x8,0xf0698b32
f010d450:	08 00 
f010d452:	a0 34 8b 69 f0       	mov    0xf0698b34,%al
f010d457:	83 e0 e0             	and    $0xffffffe0,%eax
f010d45a:	a2 34 8b 69 f0       	mov    %al,0xf0698b34
f010d45f:	a0 34 8b 69 f0       	mov    0xf0698b34,%al
f010d464:	83 e0 1f             	and    $0x1f,%eax
f010d467:	a2 34 8b 69 f0       	mov    %al,0xf0698b34
f010d46c:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d471:	83 e0 f0             	and    $0xfffffff0,%eax
f010d474:	83 c8 0e             	or     $0xe,%eax
f010d477:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d47c:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d481:	83 e0 ef             	and    $0xffffffef,%eax
f010d484:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d489:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d48e:	83 c8 60             	or     $0x60,%eax
f010d491:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d496:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d49b:	83 c8 80             	or     $0xffffff80,%eax
f010d49e:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d4a3:	b8 06 e6 10 f0       	mov    $0xf010e606,%eax
f010d4a8:	c1 e8 10             	shr    $0x10,%eax
f010d4ab:	66 a3 36 8b 69 f0    	mov    %ax,0xf0698b36
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d4b1:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010d4b6:	66 a3 38 8b 69 f0    	mov    %ax,0xf0698b38
f010d4bc:	66 c7 05 3a 8b 69 f0 	movw   $0x8,0xf0698b3a
f010d4c3:	08 00 
f010d4c5:	a0 3c 8b 69 f0       	mov    0xf0698b3c,%al
f010d4ca:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4cd:	a2 3c 8b 69 f0       	mov    %al,0xf0698b3c
f010d4d2:	a0 3c 8b 69 f0       	mov    0xf0698b3c,%al
f010d4d7:	83 e0 1f             	and    $0x1f,%eax
f010d4da:	a2 3c 8b 69 f0       	mov    %al,0xf0698b3c
f010d4df:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d4e4:	83 c8 0f             	or     $0xf,%eax
f010d4e7:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d4ec:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d4f1:	83 e0 ef             	and    $0xffffffef,%eax
f010d4f4:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d4f9:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d4fe:	83 c8 60             	or     $0x60,%eax
f010d501:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d506:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d50b:	83 c8 80             	or     $0xffffff80,%eax
f010d50e:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d513:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010d518:	c1 e8 10             	shr    $0x10,%eax
f010d51b:	66 a3 3e 8b 69 f0    	mov    %ax,0xf0698b3e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d521:	b8 1a e6 10 f0       	mov    $0xf010e61a,%eax
f010d526:	66 a3 40 8b 69 f0    	mov    %ax,0xf0698b40
f010d52c:	66 c7 05 42 8b 69 f0 	movw   $0x8,0xf0698b42
f010d533:	08 00 
f010d535:	a0 44 8b 69 f0       	mov    0xf0698b44,%al
f010d53a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d53d:	a2 44 8b 69 f0       	mov    %al,0xf0698b44
f010d542:	a0 44 8b 69 f0       	mov    0xf0698b44,%al
f010d547:	83 e0 1f             	and    $0x1f,%eax
f010d54a:	a2 44 8b 69 f0       	mov    %al,0xf0698b44
f010d54f:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d554:	83 c8 0f             	or     $0xf,%eax
f010d557:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d55c:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d561:	83 e0 ef             	and    $0xffffffef,%eax
f010d564:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d569:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d56e:	83 c8 60             	or     $0x60,%eax
f010d571:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d576:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d57b:	83 c8 80             	or     $0xffffff80,%eax
f010d57e:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d583:	b8 1a e6 10 f0       	mov    $0xf010e61a,%eax
f010d588:	c1 e8 10             	shr    $0x10,%eax
f010d58b:	66 a3 46 8b 69 f0    	mov    %ax,0xf0698b46
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d591:	b8 24 e6 10 f0       	mov    $0xf010e624,%eax
f010d596:	66 a3 48 8b 69 f0    	mov    %ax,0xf0698b48
f010d59c:	66 c7 05 4a 8b 69 f0 	movw   $0x8,0xf0698b4a
f010d5a3:	08 00 
f010d5a5:	a0 4c 8b 69 f0       	mov    0xf0698b4c,%al
f010d5aa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5ad:	a2 4c 8b 69 f0       	mov    %al,0xf0698b4c
f010d5b2:	a0 4c 8b 69 f0       	mov    0xf0698b4c,%al
f010d5b7:	83 e0 1f             	and    $0x1f,%eax
f010d5ba:	a2 4c 8b 69 f0       	mov    %al,0xf0698b4c
f010d5bf:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d5c4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5c7:	83 c8 0e             	or     $0xe,%eax
f010d5ca:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d5cf:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d5d4:	83 e0 ef             	and    $0xffffffef,%eax
f010d5d7:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d5dc:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d5e1:	83 c8 60             	or     $0x60,%eax
f010d5e4:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d5e9:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d5ee:	83 c8 80             	or     $0xffffff80,%eax
f010d5f1:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d5f6:	b8 24 e6 10 f0       	mov    $0xf010e624,%eax
f010d5fb:	c1 e8 10             	shr    $0x10,%eax
f010d5fe:	66 a3 4e 8b 69 f0    	mov    %ax,0xf0698b4e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d604:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010d609:	66 a3 50 8b 69 f0    	mov    %ax,0xf0698b50
f010d60f:	66 c7 05 52 8b 69 f0 	movw   $0x8,0xf0698b52
f010d616:	08 00 
f010d618:	a0 54 8b 69 f0       	mov    0xf0698b54,%al
f010d61d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d620:	a2 54 8b 69 f0       	mov    %al,0xf0698b54
f010d625:	a0 54 8b 69 f0       	mov    0xf0698b54,%al
f010d62a:	83 e0 1f             	and    $0x1f,%eax
f010d62d:	a2 54 8b 69 f0       	mov    %al,0xf0698b54
f010d632:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d637:	83 e0 f0             	and    $0xfffffff0,%eax
f010d63a:	83 c8 0e             	or     $0xe,%eax
f010d63d:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d642:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d647:	83 e0 ef             	and    $0xffffffef,%eax
f010d64a:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d64f:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d654:	83 c8 60             	or     $0x60,%eax
f010d657:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d65c:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d661:	83 c8 80             	or     $0xffffff80,%eax
f010d664:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d669:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010d66e:	c1 e8 10             	shr    $0x10,%eax
f010d671:	66 a3 56 8b 69 f0    	mov    %ax,0xf0698b56
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d677:	b8 38 e6 10 f0       	mov    $0xf010e638,%eax
f010d67c:	66 a3 58 8b 69 f0    	mov    %ax,0xf0698b58
f010d682:	66 c7 05 5a 8b 69 f0 	movw   $0x8,0xf0698b5a
f010d689:	08 00 
f010d68b:	a0 5c 8b 69 f0       	mov    0xf0698b5c,%al
f010d690:	83 e0 e0             	and    $0xffffffe0,%eax
f010d693:	a2 5c 8b 69 f0       	mov    %al,0xf0698b5c
f010d698:	a0 5c 8b 69 f0       	mov    0xf0698b5c,%al
f010d69d:	83 e0 1f             	and    $0x1f,%eax
f010d6a0:	a2 5c 8b 69 f0       	mov    %al,0xf0698b5c
f010d6a5:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d6aa:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6ad:	83 c8 0e             	or     $0xe,%eax
f010d6b0:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d6b5:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d6ba:	83 e0 ef             	and    $0xffffffef,%eax
f010d6bd:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d6c2:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d6c7:	83 c8 60             	or     $0x60,%eax
f010d6ca:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d6cf:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d6d4:	83 c8 80             	or     $0xffffff80,%eax
f010d6d7:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d6dc:	b8 38 e6 10 f0       	mov    $0xf010e638,%eax
f010d6e1:	c1 e8 10             	shr    $0x10,%eax
f010d6e4:	66 a3 5e 8b 69 f0    	mov    %ax,0xf0698b5e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d6ea:	b8 3e e6 10 f0       	mov    $0xf010e63e,%eax
f010d6ef:	66 a3 70 8b 69 f0    	mov    %ax,0xf0698b70
f010d6f5:	66 c7 05 72 8b 69 f0 	movw   $0x8,0xf0698b72
f010d6fc:	08 00 
f010d6fe:	a0 74 8b 69 f0       	mov    0xf0698b74,%al
f010d703:	83 e0 e0             	and    $0xffffffe0,%eax
f010d706:	a2 74 8b 69 f0       	mov    %al,0xf0698b74
f010d70b:	a0 74 8b 69 f0       	mov    0xf0698b74,%al
f010d710:	83 e0 1f             	and    $0x1f,%eax
f010d713:	a2 74 8b 69 f0       	mov    %al,0xf0698b74
f010d718:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d71d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d720:	83 c8 0e             	or     $0xe,%eax
f010d723:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d728:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d72d:	83 e0 ef             	and    $0xffffffef,%eax
f010d730:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d735:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d73a:	83 c8 60             	or     $0x60,%eax
f010d73d:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d742:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d747:	83 c8 80             	or     $0xffffff80,%eax
f010d74a:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d74f:	b8 3e e6 10 f0       	mov    $0xf010e63e,%eax
f010d754:	c1 e8 10             	shr    $0x10,%eax
f010d757:	66 a3 76 8b 69 f0    	mov    %ax,0xf0698b76
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d75d:	b8 42 e6 10 f0       	mov    $0xf010e642,%eax
f010d762:	66 a3 78 8b 69 f0    	mov    %ax,0xf0698b78
f010d768:	66 c7 05 7a 8b 69 f0 	movw   $0x8,0xf0698b7a
f010d76f:	08 00 
f010d771:	a0 7c 8b 69 f0       	mov    0xf0698b7c,%al
f010d776:	83 e0 e0             	and    $0xffffffe0,%eax
f010d779:	a2 7c 8b 69 f0       	mov    %al,0xf0698b7c
f010d77e:	a0 7c 8b 69 f0       	mov    0xf0698b7c,%al
f010d783:	83 e0 1f             	and    $0x1f,%eax
f010d786:	a2 7c 8b 69 f0       	mov    %al,0xf0698b7c
f010d78b:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d790:	83 e0 f0             	and    $0xfffffff0,%eax
f010d793:	83 c8 0e             	or     $0xe,%eax
f010d796:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d79b:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d7a0:	83 e0 ef             	and    $0xffffffef,%eax
f010d7a3:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d7a8:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d7ad:	83 c8 60             	or     $0x60,%eax
f010d7b0:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d7b5:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d7ba:	83 c8 80             	or     $0xffffff80,%eax
f010d7bd:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d7c2:	b8 42 e6 10 f0       	mov    $0xf010e642,%eax
f010d7c7:	c1 e8 10             	shr    $0x10,%eax
f010d7ca:	66 a3 7e 8b 69 f0    	mov    %ax,0xf0698b7e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d7d0:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010d7d5:	66 a3 80 8b 69 f0    	mov    %ax,0xf0698b80
f010d7db:	66 c7 05 82 8b 69 f0 	movw   $0x8,0xf0698b82
f010d7e2:	08 00 
f010d7e4:	a0 84 8b 69 f0       	mov    0xf0698b84,%al
f010d7e9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7ec:	a2 84 8b 69 f0       	mov    %al,0xf0698b84
f010d7f1:	a0 84 8b 69 f0       	mov    0xf0698b84,%al
f010d7f6:	83 e0 1f             	and    $0x1f,%eax
f010d7f9:	a2 84 8b 69 f0       	mov    %al,0xf0698b84
f010d7fe:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d803:	83 e0 f0             	and    $0xfffffff0,%eax
f010d806:	83 c8 0e             	or     $0xe,%eax
f010d809:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d80e:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d813:	83 e0 ef             	and    $0xffffffef,%eax
f010d816:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d81b:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d820:	83 c8 60             	or     $0x60,%eax
f010d823:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d828:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d82d:	83 c8 80             	or     $0xffffff80,%eax
f010d830:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d835:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010d83a:	c1 e8 10             	shr    $0x10,%eax
f010d83d:	66 a3 86 8b 69 f0    	mov    %ax,0xf0698b86
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d843:	b8 4a e6 10 f0       	mov    $0xf010e64a,%eax
f010d848:	66 a3 88 8b 69 f0    	mov    %ax,0xf0698b88
f010d84e:	66 c7 05 8a 8b 69 f0 	movw   $0x8,0xf0698b8a
f010d855:	08 00 
f010d857:	a0 8c 8b 69 f0       	mov    0xf0698b8c,%al
f010d85c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d85f:	a2 8c 8b 69 f0       	mov    %al,0xf0698b8c
f010d864:	a0 8c 8b 69 f0       	mov    0xf0698b8c,%al
f010d869:	83 e0 1f             	and    $0x1f,%eax
f010d86c:	a2 8c 8b 69 f0       	mov    %al,0xf0698b8c
f010d871:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d876:	83 e0 f0             	and    $0xfffffff0,%eax
f010d879:	83 c8 0e             	or     $0xe,%eax
f010d87c:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d881:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d886:	83 e0 ef             	and    $0xffffffef,%eax
f010d889:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d88e:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d893:	83 c8 60             	or     $0x60,%eax
f010d896:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d89b:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d8a0:	83 c8 80             	or     $0xffffff80,%eax
f010d8a3:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d8a8:	b8 4a e6 10 f0       	mov    $0xf010e64a,%eax
f010d8ad:	c1 e8 10             	shr    $0x10,%eax
f010d8b0:	66 a3 8e 8b 69 f0    	mov    %ax,0xf0698b8e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d8b6:	b8 4e e6 10 f0       	mov    $0xf010e64e,%eax
f010d8bb:	66 a3 a0 8b 69 f0    	mov    %ax,0xf0698ba0
f010d8c1:	66 c7 05 a2 8b 69 f0 	movw   $0x8,0xf0698ba2
f010d8c8:	08 00 
f010d8ca:	a0 a4 8b 69 f0       	mov    0xf0698ba4,%al
f010d8cf:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8d2:	a2 a4 8b 69 f0       	mov    %al,0xf0698ba4
f010d8d7:	a0 a4 8b 69 f0       	mov    0xf0698ba4,%al
f010d8dc:	83 e0 1f             	and    $0x1f,%eax
f010d8df:	a2 a4 8b 69 f0       	mov    %al,0xf0698ba4
f010d8e4:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d8e9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8ec:	83 c8 0e             	or     $0xe,%eax
f010d8ef:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d8f4:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d8f9:	83 e0 ef             	and    $0xffffffef,%eax
f010d8fc:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d901:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d906:	83 c8 60             	or     $0x60,%eax
f010d909:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d90e:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d913:	83 c8 80             	or     $0xffffff80,%eax
f010d916:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d91b:	b8 4e e6 10 f0       	mov    $0xf010e64e,%eax
f010d920:	c1 e8 10             	shr    $0x10,%eax
f010d923:	66 a3 a6 8b 69 f0    	mov    %ax,0xf0698ba6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d929:	b8 54 e6 10 f0       	mov    $0xf010e654,%eax
f010d92e:	66 a3 a8 8b 69 f0    	mov    %ax,0xf0698ba8
f010d934:	66 c7 05 aa 8b 69 f0 	movw   $0x8,0xf0698baa
f010d93b:	08 00 
f010d93d:	a0 ac 8b 69 f0       	mov    0xf0698bac,%al
f010d942:	83 e0 e0             	and    $0xffffffe0,%eax
f010d945:	a2 ac 8b 69 f0       	mov    %al,0xf0698bac
f010d94a:	a0 ac 8b 69 f0       	mov    0xf0698bac,%al
f010d94f:	83 e0 1f             	and    $0x1f,%eax
f010d952:	a2 ac 8b 69 f0       	mov    %al,0xf0698bac
f010d957:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d95c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d95f:	83 c8 0e             	or     $0xe,%eax
f010d962:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d967:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d96c:	83 e0 ef             	and    $0xffffffef,%eax
f010d96f:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d974:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d979:	83 c8 60             	or     $0x60,%eax
f010d97c:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d981:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d986:	83 c8 80             	or     $0xffffff80,%eax
f010d989:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d98e:	b8 54 e6 10 f0       	mov    $0xf010e654,%eax
f010d993:	c1 e8 10             	shr    $0x10,%eax
f010d996:	66 a3 ae 8b 69 f0    	mov    %ax,0xf0698bae
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d99c:	b8 58 e6 10 f0       	mov    $0xf010e658,%eax
f010d9a1:	66 a3 b0 8b 69 f0    	mov    %ax,0xf0698bb0
f010d9a7:	66 c7 05 b2 8b 69 f0 	movw   $0x8,0xf0698bb2
f010d9ae:	08 00 
f010d9b0:	a0 b4 8b 69 f0       	mov    0xf0698bb4,%al
f010d9b5:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9b8:	a2 b4 8b 69 f0       	mov    %al,0xf0698bb4
f010d9bd:	a0 b4 8b 69 f0       	mov    0xf0698bb4,%al
f010d9c2:	83 e0 1f             	and    $0x1f,%eax
f010d9c5:	a2 b4 8b 69 f0       	mov    %al,0xf0698bb4
f010d9ca:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010d9cf:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9d2:	83 c8 0e             	or     $0xe,%eax
f010d9d5:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010d9da:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010d9df:	83 e0 ef             	and    $0xffffffef,%eax
f010d9e2:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010d9e7:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010d9ec:	83 c8 60             	or     $0x60,%eax
f010d9ef:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010d9f4:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010d9f9:	83 c8 80             	or     $0xffffff80,%eax
f010d9fc:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010da01:	b8 58 e6 10 f0       	mov    $0xf010e658,%eax
f010da06:	c1 e8 10             	shr    $0x10,%eax
f010da09:	66 a3 b6 8b 69 f0    	mov    %ax,0xf0698bb6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010da0f:	b8 5e e6 10 f0       	mov    $0xf010e65e,%eax
f010da14:	66 a3 b8 8b 69 f0    	mov    %ax,0xf0698bb8
f010da1a:	66 c7 05 ba 8b 69 f0 	movw   $0x8,0xf0698bba
f010da21:	08 00 
f010da23:	a0 bc 8b 69 f0       	mov    0xf0698bbc,%al
f010da28:	83 e0 e0             	and    $0xffffffe0,%eax
f010da2b:	a2 bc 8b 69 f0       	mov    %al,0xf0698bbc
f010da30:	a0 bc 8b 69 f0       	mov    0xf0698bbc,%al
f010da35:	83 e0 1f             	and    $0x1f,%eax
f010da38:	a2 bc 8b 69 f0       	mov    %al,0xf0698bbc
f010da3d:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010da42:	83 e0 f0             	and    $0xfffffff0,%eax
f010da45:	83 c8 0e             	or     $0xe,%eax
f010da48:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010da4d:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010da52:	83 e0 ef             	and    $0xffffffef,%eax
f010da55:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010da5a:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010da5f:	83 c8 60             	or     $0x60,%eax
f010da62:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010da67:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010da6c:	83 c8 80             	or     $0xffffff80,%eax
f010da6f:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010da74:	b8 5e e6 10 f0       	mov    $0xf010e65e,%eax
f010da79:	c1 e8 10             	shr    $0x10,%eax
f010da7c:	66 a3 be 8b 69 f0    	mov    %ax,0xf0698bbe

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010da82:	b8 64 e6 10 f0       	mov    $0xf010e664,%eax
f010da87:	66 a3 30 8c 69 f0    	mov    %ax,0xf0698c30
f010da8d:	66 c7 05 32 8c 69 f0 	movw   $0x8,0xf0698c32
f010da94:	08 00 
f010da96:	a0 34 8c 69 f0       	mov    0xf0698c34,%al
f010da9b:	83 e0 e0             	and    $0xffffffe0,%eax
f010da9e:	a2 34 8c 69 f0       	mov    %al,0xf0698c34
f010daa3:	a0 34 8c 69 f0       	mov    0xf0698c34,%al
f010daa8:	83 e0 1f             	and    $0x1f,%eax
f010daab:	a2 34 8c 69 f0       	mov    %al,0xf0698c34
f010dab0:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010dab5:	83 e0 f0             	and    $0xfffffff0,%eax
f010dab8:	83 c8 0e             	or     $0xe,%eax
f010dabb:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010dac0:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010dac5:	83 e0 ef             	and    $0xffffffef,%eax
f010dac8:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010dacd:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010dad2:	83 c8 60             	or     $0x60,%eax
f010dad5:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010dada:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010dadf:	83 c8 80             	or     $0xffffff80,%eax
f010dae2:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010dae7:	b8 64 e6 10 f0       	mov    $0xf010e664,%eax
f010daec:	c1 e8 10             	shr    $0x10,%eax
f010daef:	66 a3 36 8c 69 f0    	mov    %ax,0xf0698c36
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010daf5:	b8 6a e6 10 f0       	mov    $0xf010e66a,%eax
f010dafa:	66 a3 38 8c 69 f0    	mov    %ax,0xf0698c38
f010db00:	66 c7 05 3a 8c 69 f0 	movw   $0x8,0xf0698c3a
f010db07:	08 00 
f010db09:	a0 3c 8c 69 f0       	mov    0xf0698c3c,%al
f010db0e:	83 e0 e0             	and    $0xffffffe0,%eax
f010db11:	a2 3c 8c 69 f0       	mov    %al,0xf0698c3c
f010db16:	a0 3c 8c 69 f0       	mov    0xf0698c3c,%al
f010db1b:	83 e0 1f             	and    $0x1f,%eax
f010db1e:	a2 3c 8c 69 f0       	mov    %al,0xf0698c3c
f010db23:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db28:	83 e0 f0             	and    $0xfffffff0,%eax
f010db2b:	83 c8 0e             	or     $0xe,%eax
f010db2e:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db33:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db38:	83 e0 ef             	and    $0xffffffef,%eax
f010db3b:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db40:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db45:	83 c8 60             	or     $0x60,%eax
f010db48:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db4d:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db52:	83 c8 80             	or     $0xffffff80,%eax
f010db55:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db5a:	b8 6a e6 10 f0       	mov    $0xf010e66a,%eax
f010db5f:	c1 e8 10             	shr    $0x10,%eax
f010db62:	66 a3 3e 8c 69 f0    	mov    %ax,0xf0698c3e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010db68:	b8 70 e6 10 f0       	mov    $0xf010e670,%eax
f010db6d:	66 a3 40 8c 69 f0    	mov    %ax,0xf0698c40
f010db73:	66 c7 05 42 8c 69 f0 	movw   $0x8,0xf0698c42
f010db7a:	08 00 
f010db7c:	a0 44 8c 69 f0       	mov    0xf0698c44,%al
f010db81:	83 e0 e0             	and    $0xffffffe0,%eax
f010db84:	a2 44 8c 69 f0       	mov    %al,0xf0698c44
f010db89:	a0 44 8c 69 f0       	mov    0xf0698c44,%al
f010db8e:	83 e0 1f             	and    $0x1f,%eax
f010db91:	a2 44 8c 69 f0       	mov    %al,0xf0698c44
f010db96:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010db9b:	83 e0 f0             	and    $0xfffffff0,%eax
f010db9e:	83 c8 0e             	or     $0xe,%eax
f010dba1:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dba6:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dbab:	83 e0 ef             	and    $0xffffffef,%eax
f010dbae:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dbb3:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dbb8:	83 c8 60             	or     $0x60,%eax
f010dbbb:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dbc0:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dbc5:	83 c8 80             	or     $0xffffff80,%eax
f010dbc8:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dbcd:	b8 70 e6 10 f0       	mov    $0xf010e670,%eax
f010dbd2:	c1 e8 10             	shr    $0x10,%eax
f010dbd5:	66 a3 46 8c 69 f0    	mov    %ax,0xf0698c46
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010dbdb:	b8 76 e6 10 f0       	mov    $0xf010e676,%eax
f010dbe0:	66 a3 48 8c 69 f0    	mov    %ax,0xf0698c48
f010dbe6:	66 c7 05 4a 8c 69 f0 	movw   $0x8,0xf0698c4a
f010dbed:	08 00 
f010dbef:	a0 4c 8c 69 f0       	mov    0xf0698c4c,%al
f010dbf4:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbf7:	a2 4c 8c 69 f0       	mov    %al,0xf0698c4c
f010dbfc:	a0 4c 8c 69 f0       	mov    0xf0698c4c,%al
f010dc01:	83 e0 1f             	and    $0x1f,%eax
f010dc04:	a2 4c 8c 69 f0       	mov    %al,0xf0698c4c
f010dc09:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc0e:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc11:	83 c8 0e             	or     $0xe,%eax
f010dc14:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc19:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc1e:	83 e0 ef             	and    $0xffffffef,%eax
f010dc21:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc26:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc2b:	83 c8 60             	or     $0x60,%eax
f010dc2e:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc33:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc38:	83 c8 80             	or     $0xffffff80,%eax
f010dc3b:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc40:	b8 76 e6 10 f0       	mov    $0xf010e676,%eax
f010dc45:	c1 e8 10             	shr    $0x10,%eax
f010dc48:	66 a3 4e 8c 69 f0    	mov    %ax,0xf0698c4e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010dc4e:	b8 7c e6 10 f0       	mov    $0xf010e67c,%eax
f010dc53:	66 a3 50 8c 69 f0    	mov    %ax,0xf0698c50
f010dc59:	66 c7 05 52 8c 69 f0 	movw   $0x8,0xf0698c52
f010dc60:	08 00 
f010dc62:	a0 54 8c 69 f0       	mov    0xf0698c54,%al
f010dc67:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc6a:	a2 54 8c 69 f0       	mov    %al,0xf0698c54
f010dc6f:	a0 54 8c 69 f0       	mov    0xf0698c54,%al
f010dc74:	83 e0 1f             	and    $0x1f,%eax
f010dc77:	a2 54 8c 69 f0       	mov    %al,0xf0698c54
f010dc7c:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dc81:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc84:	83 c8 0e             	or     $0xe,%eax
f010dc87:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dc8c:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dc91:	83 e0 ef             	and    $0xffffffef,%eax
f010dc94:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dc99:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dc9e:	83 c8 60             	or     $0x60,%eax
f010dca1:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dca6:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dcab:	83 c8 80             	or     $0xffffff80,%eax
f010dcae:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dcb3:	b8 7c e6 10 f0       	mov    $0xf010e67c,%eax
f010dcb8:	c1 e8 10             	shr    $0x10,%eax
f010dcbb:	66 a3 56 8c 69 f0    	mov    %ax,0xf0698c56
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dcc1:	b8 82 e6 10 f0       	mov    $0xf010e682,%eax
f010dcc6:	66 a3 58 8c 69 f0    	mov    %ax,0xf0698c58
f010dccc:	66 c7 05 5a 8c 69 f0 	movw   $0x8,0xf0698c5a
f010dcd3:	08 00 
f010dcd5:	a0 5c 8c 69 f0       	mov    0xf0698c5c,%al
f010dcda:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcdd:	a2 5c 8c 69 f0       	mov    %al,0xf0698c5c
f010dce2:	a0 5c 8c 69 f0       	mov    0xf0698c5c,%al
f010dce7:	83 e0 1f             	and    $0x1f,%eax
f010dcea:	a2 5c 8c 69 f0       	mov    %al,0xf0698c5c
f010dcef:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dcf4:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcf7:	83 c8 0e             	or     $0xe,%eax
f010dcfa:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dcff:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd04:	83 e0 ef             	and    $0xffffffef,%eax
f010dd07:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd0c:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd11:	83 c8 60             	or     $0x60,%eax
f010dd14:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd19:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd1e:	83 c8 80             	or     $0xffffff80,%eax
f010dd21:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd26:	b8 82 e6 10 f0       	mov    $0xf010e682,%eax
f010dd2b:	c1 e8 10             	shr    $0x10,%eax
f010dd2e:	66 a3 5e 8c 69 f0    	mov    %ax,0xf0698c5e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dd34:	b8 88 e6 10 f0       	mov    $0xf010e688,%eax
f010dd39:	66 a3 60 8c 69 f0    	mov    %ax,0xf0698c60
f010dd3f:	66 c7 05 62 8c 69 f0 	movw   $0x8,0xf0698c62
f010dd46:	08 00 
f010dd48:	a0 64 8c 69 f0       	mov    0xf0698c64,%al
f010dd4d:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd50:	a2 64 8c 69 f0       	mov    %al,0xf0698c64
f010dd55:	a0 64 8c 69 f0       	mov    0xf0698c64,%al
f010dd5a:	83 e0 1f             	and    $0x1f,%eax
f010dd5d:	a2 64 8c 69 f0       	mov    %al,0xf0698c64
f010dd62:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010dd67:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd6a:	83 c8 0e             	or     $0xe,%eax
f010dd6d:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010dd72:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010dd77:	83 e0 ef             	and    $0xffffffef,%eax
f010dd7a:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010dd7f:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010dd84:	83 c8 60             	or     $0x60,%eax
f010dd87:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010dd8c:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010dd91:	83 c8 80             	or     $0xffffff80,%eax
f010dd94:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010dd99:	b8 88 e6 10 f0       	mov    $0xf010e688,%eax
f010dd9e:	c1 e8 10             	shr    $0x10,%eax
f010dda1:	66 a3 66 8c 69 f0    	mov    %ax,0xf0698c66
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dda7:	b8 8e e6 10 f0       	mov    $0xf010e68e,%eax
f010ddac:	66 a3 68 8c 69 f0    	mov    %ax,0xf0698c68
f010ddb2:	66 c7 05 6a 8c 69 f0 	movw   $0x8,0xf0698c6a
f010ddb9:	08 00 
f010ddbb:	a0 6c 8c 69 f0       	mov    0xf0698c6c,%al
f010ddc0:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddc3:	a2 6c 8c 69 f0       	mov    %al,0xf0698c6c
f010ddc8:	a0 6c 8c 69 f0       	mov    0xf0698c6c,%al
f010ddcd:	83 e0 1f             	and    $0x1f,%eax
f010ddd0:	a2 6c 8c 69 f0       	mov    %al,0xf0698c6c
f010ddd5:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010ddda:	83 e0 f0             	and    $0xfffffff0,%eax
f010dddd:	83 c8 0e             	or     $0xe,%eax
f010dde0:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010dde5:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010ddea:	83 e0 ef             	and    $0xffffffef,%eax
f010dded:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010ddf2:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010ddf7:	83 c8 60             	or     $0x60,%eax
f010ddfa:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010ddff:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010de04:	83 c8 80             	or     $0xffffff80,%eax
f010de07:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010de0c:	b8 8e e6 10 f0       	mov    $0xf010e68e,%eax
f010de11:	c1 e8 10             	shr    $0x10,%eax
f010de14:	66 a3 6e 8c 69 f0    	mov    %ax,0xf0698c6e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010de1a:	b8 94 e6 10 f0       	mov    $0xf010e694,%eax
f010de1f:	66 a3 70 8c 69 f0    	mov    %ax,0xf0698c70
f010de25:	66 c7 05 72 8c 69 f0 	movw   $0x8,0xf0698c72
f010de2c:	08 00 
f010de2e:	a0 74 8c 69 f0       	mov    0xf0698c74,%al
f010de33:	83 e0 e0             	and    $0xffffffe0,%eax
f010de36:	a2 74 8c 69 f0       	mov    %al,0xf0698c74
f010de3b:	a0 74 8c 69 f0       	mov    0xf0698c74,%al
f010de40:	83 e0 1f             	and    $0x1f,%eax
f010de43:	a2 74 8c 69 f0       	mov    %al,0xf0698c74
f010de48:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010de4d:	83 e0 f0             	and    $0xfffffff0,%eax
f010de50:	83 c8 0e             	or     $0xe,%eax
f010de53:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010de58:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010de5d:	83 e0 ef             	and    $0xffffffef,%eax
f010de60:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010de65:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010de6a:	83 c8 60             	or     $0x60,%eax
f010de6d:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010de72:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010de77:	83 c8 80             	or     $0xffffff80,%eax
f010de7a:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010de7f:	b8 94 e6 10 f0       	mov    $0xf010e694,%eax
f010de84:	c1 e8 10             	shr    $0x10,%eax
f010de87:	66 a3 76 8c 69 f0    	mov    %ax,0xf0698c76
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010de8d:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010de92:	66 a3 78 8c 69 f0    	mov    %ax,0xf0698c78
f010de98:	66 c7 05 7a 8c 69 f0 	movw   $0x8,0xf0698c7a
f010de9f:	08 00 
f010dea1:	a0 7c 8c 69 f0       	mov    0xf0698c7c,%al
f010dea6:	83 e0 e0             	and    $0xffffffe0,%eax
f010dea9:	a2 7c 8c 69 f0       	mov    %al,0xf0698c7c
f010deae:	a0 7c 8c 69 f0       	mov    0xf0698c7c,%al
f010deb3:	83 e0 1f             	and    $0x1f,%eax
f010deb6:	a2 7c 8c 69 f0       	mov    %al,0xf0698c7c
f010debb:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010dec0:	83 e0 f0             	and    $0xfffffff0,%eax
f010dec3:	83 c8 0e             	or     $0xe,%eax
f010dec6:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010decb:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010ded0:	83 e0 ef             	and    $0xffffffef,%eax
f010ded3:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010ded8:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010dedd:	83 c8 60             	or     $0x60,%eax
f010dee0:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010dee5:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010deea:	83 c8 80             	or     $0xffffff80,%eax
f010deed:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010def2:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010def7:	c1 e8 10             	shr    $0x10,%eax
f010defa:	66 a3 7e 8c 69 f0    	mov    %ax,0xf0698c7e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010df00:	b8 a0 e6 10 f0       	mov    $0xf010e6a0,%eax
f010df05:	66 a3 80 8c 69 f0    	mov    %ax,0xf0698c80
f010df0b:	66 c7 05 82 8c 69 f0 	movw   $0x8,0xf0698c82
f010df12:	08 00 
f010df14:	a0 84 8c 69 f0       	mov    0xf0698c84,%al
f010df19:	83 e0 e0             	and    $0xffffffe0,%eax
f010df1c:	a2 84 8c 69 f0       	mov    %al,0xf0698c84
f010df21:	a0 84 8c 69 f0       	mov    0xf0698c84,%al
f010df26:	83 e0 1f             	and    $0x1f,%eax
f010df29:	a2 84 8c 69 f0       	mov    %al,0xf0698c84
f010df2e:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df33:	83 e0 f0             	and    $0xfffffff0,%eax
f010df36:	83 c8 0e             	or     $0xe,%eax
f010df39:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df3e:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df43:	83 e0 ef             	and    $0xffffffef,%eax
f010df46:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df4b:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df50:	83 c8 60             	or     $0x60,%eax
f010df53:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df58:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df5d:	83 c8 80             	or     $0xffffff80,%eax
f010df60:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df65:	b8 a0 e6 10 f0       	mov    $0xf010e6a0,%eax
f010df6a:	c1 e8 10             	shr    $0x10,%eax
f010df6d:	66 a3 86 8c 69 f0    	mov    %ax,0xf0698c86
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010df73:	b8 a6 e6 10 f0       	mov    $0xf010e6a6,%eax
f010df78:	66 a3 88 8c 69 f0    	mov    %ax,0xf0698c88
f010df7e:	66 c7 05 8a 8c 69 f0 	movw   $0x8,0xf0698c8a
f010df85:	08 00 
f010df87:	a0 8c 8c 69 f0       	mov    0xf0698c8c,%al
f010df8c:	83 e0 e0             	and    $0xffffffe0,%eax
f010df8f:	a2 8c 8c 69 f0       	mov    %al,0xf0698c8c
f010df94:	a0 8c 8c 69 f0       	mov    0xf0698c8c,%al
f010df99:	83 e0 1f             	and    $0x1f,%eax
f010df9c:	a2 8c 8c 69 f0       	mov    %al,0xf0698c8c
f010dfa1:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010dfa6:	83 e0 f0             	and    $0xfffffff0,%eax
f010dfa9:	83 c8 0e             	or     $0xe,%eax
f010dfac:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010dfb1:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010dfb6:	83 e0 ef             	and    $0xffffffef,%eax
f010dfb9:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010dfbe:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010dfc3:	83 c8 60             	or     $0x60,%eax
f010dfc6:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010dfcb:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010dfd0:	83 c8 80             	or     $0xffffff80,%eax
f010dfd3:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010dfd8:	b8 a6 e6 10 f0       	mov    $0xf010e6a6,%eax
f010dfdd:	c1 e8 10             	shr    $0x10,%eax
f010dfe0:	66 a3 8e 8c 69 f0    	mov    %ax,0xf0698c8e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010dfe6:	b8 ac e6 10 f0       	mov    $0xf010e6ac,%eax
f010dfeb:	66 a3 90 8c 69 f0    	mov    %ax,0xf0698c90
f010dff1:	66 c7 05 92 8c 69 f0 	movw   $0x8,0xf0698c92
f010dff8:	08 00 
f010dffa:	a0 94 8c 69 f0       	mov    0xf0698c94,%al
f010dfff:	83 e0 e0             	and    $0xffffffe0,%eax
f010e002:	a2 94 8c 69 f0       	mov    %al,0xf0698c94
f010e007:	a0 94 8c 69 f0       	mov    0xf0698c94,%al
f010e00c:	83 e0 1f             	and    $0x1f,%eax
f010e00f:	a2 94 8c 69 f0       	mov    %al,0xf0698c94
f010e014:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e019:	83 e0 f0             	and    $0xfffffff0,%eax
f010e01c:	83 c8 0e             	or     $0xe,%eax
f010e01f:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e024:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e029:	83 e0 ef             	and    $0xffffffef,%eax
f010e02c:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e031:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e036:	83 c8 60             	or     $0x60,%eax
f010e039:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e03e:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e043:	83 c8 80             	or     $0xffffff80,%eax
f010e046:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e04b:	b8 ac e6 10 f0       	mov    $0xf010e6ac,%eax
f010e050:	c1 e8 10             	shr    $0x10,%eax
f010e053:	66 a3 96 8c 69 f0    	mov    %ax,0xf0698c96
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e059:	b8 b2 e6 10 f0       	mov    $0xf010e6b2,%eax
f010e05e:	66 a3 98 8c 69 f0    	mov    %ax,0xf0698c98
f010e064:	66 c7 05 9a 8c 69 f0 	movw   $0x8,0xf0698c9a
f010e06b:	08 00 
f010e06d:	a0 9c 8c 69 f0       	mov    0xf0698c9c,%al
f010e072:	83 e0 e0             	and    $0xffffffe0,%eax
f010e075:	a2 9c 8c 69 f0       	mov    %al,0xf0698c9c
f010e07a:	a0 9c 8c 69 f0       	mov    0xf0698c9c,%al
f010e07f:	83 e0 1f             	and    $0x1f,%eax
f010e082:	a2 9c 8c 69 f0       	mov    %al,0xf0698c9c
f010e087:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e08c:	83 e0 f0             	and    $0xfffffff0,%eax
f010e08f:	83 c8 0e             	or     $0xe,%eax
f010e092:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e097:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e09c:	83 e0 ef             	and    $0xffffffef,%eax
f010e09f:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e0a4:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e0a9:	83 c8 60             	or     $0x60,%eax
f010e0ac:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e0b1:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e0b6:	83 c8 80             	or     $0xffffff80,%eax
f010e0b9:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e0be:	b8 b2 e6 10 f0       	mov    $0xf010e6b2,%eax
f010e0c3:	c1 e8 10             	shr    $0x10,%eax
f010e0c6:	66 a3 9e 8c 69 f0    	mov    %ax,0xf0698c9e
f010e0cc:	c7 45 fc 20 8b 69 f0 	movl   $0xf0698b20,-0x4(%ebp)
f010e0d3:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e0da:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e0dd:	48                   	dec    %eax
f010e0de:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e0e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e0e5:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e0e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e0ec:	c1 e8 10             	shr    $0x10,%eax
f010e0ef:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e0f3:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e0f6:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e0f9:	90                   	nop
f010e0fa:	c9                   	leave  
f010e0fb:	c3                   	ret    

f010e0fc <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e0fc:	55                   	push   %ebp
f010e0fd:	89 e5                	mov    %esp,%ebp
f010e0ff:	53                   	push   %ebx
f010e100:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e103:	83 ec 08             	sub    $0x8,%esp
f010e106:	ff 75 08             	pushl  0x8(%ebp)
f010e109:	68 5e 73 12 f0       	push   $0xf012735e
f010e10e:	e8 78 2e ff ff       	call   f0100f8b <cprintf>
f010e113:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e116:	8b 45 08             	mov    0x8(%ebp),%eax
f010e119:	83 ec 0c             	sub    $0xc,%esp
f010e11c:	50                   	push   %eax
f010e11d:	e8 fd 00 00 00       	call   f010e21f <print_regs>
f010e122:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e125:	8b 45 08             	mov    0x8(%ebp),%eax
f010e128:	8b 40 20             	mov    0x20(%eax),%eax
f010e12b:	0f b7 c0             	movzwl %ax,%eax
f010e12e:	83 ec 08             	sub    $0x8,%esp
f010e131:	50                   	push   %eax
f010e132:	68 70 73 12 f0       	push   $0xf0127370
f010e137:	e8 4f 2e ff ff       	call   f0100f8b <cprintf>
f010e13c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e13f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e142:	8b 40 24             	mov    0x24(%eax),%eax
f010e145:	0f b7 c0             	movzwl %ax,%eax
f010e148:	83 ec 08             	sub    $0x8,%esp
f010e14b:	50                   	push   %eax
f010e14c:	68 83 73 12 f0       	push   $0xf0127383
f010e151:	e8 35 2e ff ff       	call   f0100f8b <cprintf>
f010e156:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e159:	8b 45 08             	mov    0x8(%ebp),%eax
f010e15c:	8b 58 28             	mov    0x28(%eax),%ebx
f010e15f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e162:	8b 40 28             	mov    0x28(%eax),%eax
f010e165:	83 ec 0c             	sub    $0xc,%esp
f010e168:	50                   	push   %eax
f010e169:	e8 28 ee ff ff       	call   f010cf96 <trapname>
f010e16e:	83 c4 10             	add    $0x10,%esp
f010e171:	89 c2                	mov    %eax,%edx
f010e173:	8b 45 08             	mov    0x8(%ebp),%eax
f010e176:	8b 40 28             	mov    0x28(%eax),%eax
f010e179:	53                   	push   %ebx
f010e17a:	52                   	push   %edx
f010e17b:	50                   	push   %eax
f010e17c:	68 96 73 12 f0       	push   $0xf0127396
f010e181:	e8 05 2e ff ff       	call   f0100f8b <cprintf>
f010e186:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e189:	8b 45 08             	mov    0x8(%ebp),%eax
f010e18c:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e18f:	83 ec 08             	sub    $0x8,%esp
f010e192:	50                   	push   %eax
f010e193:	68 ad 73 12 f0       	push   $0xf01273ad
f010e198:	e8 ee 2d ff ff       	call   f0100f8b <cprintf>
f010e19d:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e1a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1a3:	8b 40 30             	mov    0x30(%eax),%eax
f010e1a6:	83 ec 08             	sub    $0x8,%esp
f010e1a9:	50                   	push   %eax
f010e1aa:	68 bc 73 12 f0       	push   $0xf01273bc
f010e1af:	e8 d7 2d ff ff       	call   f0100f8b <cprintf>
f010e1b4:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e1b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1ba:	8b 40 34             	mov    0x34(%eax),%eax
f010e1bd:	0f b7 c0             	movzwl %ax,%eax
f010e1c0:	83 ec 08             	sub    $0x8,%esp
f010e1c3:	50                   	push   %eax
f010e1c4:	68 cb 73 12 f0       	push   $0xf01273cb
f010e1c9:	e8 bd 2d ff ff       	call   f0100f8b <cprintf>
f010e1ce:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e1d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1d4:	8b 40 38             	mov    0x38(%eax),%eax
f010e1d7:	83 ec 08             	sub    $0x8,%esp
f010e1da:	50                   	push   %eax
f010e1db:	68 de 73 12 f0       	push   $0xf01273de
f010e1e0:	e8 a6 2d ff ff       	call   f0100f8b <cprintf>
f010e1e5:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e1e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1eb:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e1ee:	83 ec 08             	sub    $0x8,%esp
f010e1f1:	50                   	push   %eax
f010e1f2:	68 ed 73 12 f0       	push   $0xf01273ed
f010e1f7:	e8 8f 2d ff ff       	call   f0100f8b <cprintf>
f010e1fc:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e1ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010e202:	8b 40 40             	mov    0x40(%eax),%eax
f010e205:	0f b7 c0             	movzwl %ax,%eax
f010e208:	83 ec 08             	sub    $0x8,%esp
f010e20b:	50                   	push   %eax
f010e20c:	68 fc 73 12 f0       	push   $0xf01273fc
f010e211:	e8 75 2d ff ff       	call   f0100f8b <cprintf>
f010e216:	83 c4 10             	add    $0x10,%esp
}
f010e219:	90                   	nop
f010e21a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e21d:	c9                   	leave  
f010e21e:	c3                   	ret    

f010e21f <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e21f:	55                   	push   %ebp
f010e220:	89 e5                	mov    %esp,%ebp
f010e222:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e225:	8b 45 08             	mov    0x8(%ebp),%eax
f010e228:	8b 00                	mov    (%eax),%eax
f010e22a:	83 ec 08             	sub    $0x8,%esp
f010e22d:	50                   	push   %eax
f010e22e:	68 0f 74 12 f0       	push   $0xf012740f
f010e233:	e8 53 2d ff ff       	call   f0100f8b <cprintf>
f010e238:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e23e:	8b 40 04             	mov    0x4(%eax),%eax
f010e241:	83 ec 08             	sub    $0x8,%esp
f010e244:	50                   	push   %eax
f010e245:	68 1e 74 12 f0       	push   $0xf012741e
f010e24a:	e8 3c 2d ff ff       	call   f0100f8b <cprintf>
f010e24f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e252:	8b 45 08             	mov    0x8(%ebp),%eax
f010e255:	8b 40 08             	mov    0x8(%eax),%eax
f010e258:	83 ec 08             	sub    $0x8,%esp
f010e25b:	50                   	push   %eax
f010e25c:	68 2d 74 12 f0       	push   $0xf012742d
f010e261:	e8 25 2d ff ff       	call   f0100f8b <cprintf>
f010e266:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e269:	8b 45 08             	mov    0x8(%ebp),%eax
f010e26c:	8b 40 0c             	mov    0xc(%eax),%eax
f010e26f:	83 ec 08             	sub    $0x8,%esp
f010e272:	50                   	push   %eax
f010e273:	68 3c 74 12 f0       	push   $0xf012743c
f010e278:	e8 0e 2d ff ff       	call   f0100f8b <cprintf>
f010e27d:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e280:	8b 45 08             	mov    0x8(%ebp),%eax
f010e283:	8b 40 10             	mov    0x10(%eax),%eax
f010e286:	83 ec 08             	sub    $0x8,%esp
f010e289:	50                   	push   %eax
f010e28a:	68 4b 74 12 f0       	push   $0xf012744b
f010e28f:	e8 f7 2c ff ff       	call   f0100f8b <cprintf>
f010e294:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e297:	8b 45 08             	mov    0x8(%ebp),%eax
f010e29a:	8b 40 14             	mov    0x14(%eax),%eax
f010e29d:	83 ec 08             	sub    $0x8,%esp
f010e2a0:	50                   	push   %eax
f010e2a1:	68 5a 74 12 f0       	push   $0xf012745a
f010e2a6:	e8 e0 2c ff ff       	call   f0100f8b <cprintf>
f010e2ab:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e2ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2b1:	8b 40 18             	mov    0x18(%eax),%eax
f010e2b4:	83 ec 08             	sub    $0x8,%esp
f010e2b7:	50                   	push   %eax
f010e2b8:	68 69 74 12 f0       	push   $0xf0127469
f010e2bd:	e8 c9 2c ff ff       	call   f0100f8b <cprintf>
f010e2c2:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e2c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c8:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e2cb:	83 ec 08             	sub    $0x8,%esp
f010e2ce:	50                   	push   %eax
f010e2cf:	68 78 74 12 f0       	push   $0xf0127478
f010e2d4:	e8 b2 2c ff ff       	call   f0100f8b <cprintf>
f010e2d9:	83 c4 10             	add    $0x10,%esp
}
f010e2dc:	90                   	nop
f010e2dd:	c9                   	leave  
f010e2de:	c3                   	ret    

f010e2df <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e2df:	55                   	push   %ebp
f010e2e0:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e2e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2e5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e2e8:	89 14 85 20 93 69 f0 	mov    %edx,-0xf966ce0(,%eax,4)
}
f010e2ef:	90                   	nop
f010e2f0:	5d                   	pop    %ebp
f010e2f1:	c3                   	ret    

f010e2f2 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e2f2:	55                   	push   %ebp
f010e2f3:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e2f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f8:	c7 04 85 20 93 69 f0 	movl   $0x0,-0xf966ce0(,%eax,4)
f010e2ff:	00 00 00 00 
}
f010e303:	90                   	nop
f010e304:	5d                   	pop    %ebp
f010e305:	c3                   	ret    

f010e306 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e306:	55                   	push   %ebp
f010e307:	89 e5                	mov    %esp,%ebp
f010e309:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e30c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e30f:	8b 40 28             	mov    0x28(%eax),%eax
f010e312:	83 e8 20             	sub    $0x20,%eax
f010e315:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e318:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e31b:	8b 04 85 20 93 69 f0 	mov    -0xf966ce0(,%eax,4),%eax
f010e322:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e325:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e329:	74 0e                	je     f010e339 <irq_dispatch+0x33>
	{
		handler(tf);
f010e32b:	83 ec 0c             	sub    $0xc,%esp
f010e32e:	ff 75 08             	pushl  0x8(%ebp)
f010e331:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e334:	ff d0                	call   *%eax
f010e336:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e339:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e33c:	0f b6 c0             	movzbl %al,%eax
f010e33f:	83 ec 0c             	sub    $0xc,%esp
f010e342:	50                   	push   %eax
f010e343:	e8 8b 8d ff ff       	call   f01070d3 <pic_sendEOI>
f010e348:	83 c4 10             	add    $0x10,%esp
}
f010e34b:	90                   	nop
f010e34c:	c9                   	leave  
f010e34d:	c3                   	ret    

f010e34e <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e34e:	55                   	push   %ebp
f010e34f:	89 e5                	mov    %esp,%ebp
f010e351:	57                   	push   %edi
f010e352:	56                   	push   %esi
f010e353:	53                   	push   %ebx
f010e354:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e357:	8b 45 08             	mov    0x8(%ebp),%eax
f010e35a:	8b 40 28             	mov    0x28(%eax),%eax
f010e35d:	83 f8 0e             	cmp    $0xe,%eax
f010e360:	75 51                	jne    f010e3b3 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e362:	a0 60 93 69 f0       	mov    0xf0699360,%al
f010e367:	84 c0                	test   %al,%al
f010e369:	74 1f                	je     f010e38a <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e36b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e36e:	8b 40 30             	mov    0x30(%eax),%eax
f010e371:	89 c2                	mov    %eax,%edx
f010e373:	a0 60 93 69 f0       	mov    0xf0699360,%al
f010e378:	0f b6 c0             	movzbl %al,%eax
f010e37b:	01 d0                	add    %edx,%eax
f010e37d:	89 c2                	mov    %eax,%edx
f010e37f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e382:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e385:	e9 0c 01 00 00       	jmp    f010e496 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e38a:	83 ec 0c             	sub    $0xc,%esp
f010e38d:	6a 01                	push   $0x1
f010e38f:	e8 ed 12 00 00       	call   f010f681 <isPageReplacmentAlgorithmLRU>
f010e394:	83 c4 10             	add    $0x10,%esp
f010e397:	85 c0                	test   %eax,%eax
f010e399:	74 05                	je     f010e3a0 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e39b:	e8 a2 88 ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e3a0:	83 ec 0c             	sub    $0xc,%esp
f010e3a3:	ff 75 08             	pushl  0x8(%ebp)
f010e3a6:	e8 bb 13 00 00       	call   f010f766 <fault_handler>
f010e3ab:	83 c4 10             	add    $0x10,%esp
f010e3ae:	e9 e3 00 00 00       	jmp    f010e496 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e3b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3b6:	8b 40 28             	mov    0x28(%eax),%eax
f010e3b9:	83 f8 30             	cmp    $0x30,%eax
f010e3bc:	75 6e                	jne    f010e42c <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e3be:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3c1:	8b 40 38             	mov    0x38(%eax),%eax
f010e3c4:	25 00 02 00 00       	and    $0x200,%eax
f010e3c9:	85 c0                	test   %eax,%eax
f010e3cb:	74 06                	je     f010e3d3 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e3cd:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e3ce:	e8 0f 69 ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e3d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d6:	8b 78 04             	mov    0x4(%eax),%edi
f010e3d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3dc:	8b 30                	mov    (%eax),%esi
f010e3de:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3e1:	8b 58 10             	mov    0x10(%eax),%ebx
f010e3e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3e7:	8b 48 18             	mov    0x18(%eax),%ecx
f010e3ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3ed:	8b 50 14             	mov    0x14(%eax),%edx
f010e3f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f3:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e3f6:	83 ec 08             	sub    $0x8,%esp
f010e3f9:	57                   	push   %edi
f010e3fa:	56                   	push   %esi
f010e3fb:	53                   	push   %ebx
f010e3fc:	51                   	push   %ecx
f010e3fd:	52                   	push   %edx
f010e3fe:	50                   	push   %eax
f010e3ff:	e8 a4 09 00 00       	call   f010eda8 <syscall>
f010e404:	83 c4 20             	add    $0x20,%esp
f010e407:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e40a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e40d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e410:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e413:	9c                   	pushf  
f010e414:	58                   	pop    %eax
f010e415:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e418:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e41b:	25 00 02 00 00       	and    $0x200,%eax
f010e420:	85 c0                	test   %eax,%eax
f010e422:	74 72                	je     f010e496 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e424:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e425:	e8 90 68 ff ff       	call   f0104cba <kclock_stop>
f010e42a:	eb 6a                	jmp    f010e496 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e42c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e42f:	8b 40 28             	mov    0x28(%eax),%eax
f010e432:	83 f8 08             	cmp    $0x8,%eax
f010e435:	75 17                	jne    f010e44e <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e437:	83 ec 04             	sub    $0x4,%esp
f010e43a:	68 87 74 12 f0       	push   $0xf0127487
f010e43f:	68 22 01 00 00       	push   $0x122
f010e444:	68 96 74 12 f0       	push   $0xf0127496
f010e449:	e8 eb 1e ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e44e:	83 ec 0c             	sub    $0xc,%esp
f010e451:	ff 75 08             	pushl  0x8(%ebp)
f010e454:	e8 a3 fc ff ff       	call   f010e0fc <print_trapframe>
f010e459:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e45c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e45f:	8b 40 34             	mov    0x34(%eax),%eax
f010e462:	66 83 f8 08          	cmp    $0x8,%ax
f010e466:	75 17                	jne    f010e47f <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e468:	83 ec 04             	sub    $0x4,%esp
f010e46b:	68 a7 74 12 f0       	push   $0xf01274a7
f010e470:	68 2a 01 00 00       	push   $0x12a
f010e475:	68 96 74 12 f0       	push   $0xf0127496
f010e47a:	e8 ba 1e ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e47f:	83 ec 04             	sub    $0x4,%esp
f010e482:	68 c0 74 12 f0       	push   $0xf01274c0
f010e487:	68 2f 01 00 00       	push   $0x12f
f010e48c:	68 96 74 12 f0       	push   $0xf0127496
f010e491:	e8 a3 1e ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e496:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e499:	5b                   	pop    %ebx
f010e49a:	5e                   	pop    %esi
f010e49b:	5f                   	pop    %edi
f010e49c:	5d                   	pop    %ebp
f010e49d:	c3                   	ret    

f010e49e <trap>:

void trap(struct Trapframe *tf)
{
f010e49e:	55                   	push   %ebp
f010e49f:	89 e5                	mov    %esp,%ebp
f010e4a1:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e4a4:	e8 11 68 ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e4a9:	9c                   	pushf  
f010e4aa:	58                   	pop    %eax
f010e4ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e4ae:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e4b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e4b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e4b7:	25 00 02 00 00       	and    $0x200,%eax
f010e4bc:	85 c0                	test   %eax,%eax
f010e4be:	74 25                	je     f010e4e5 <trap+0x47>
	{
		print_trapframe(tf);
f010e4c0:	83 ec 0c             	sub    $0xc,%esp
f010e4c3:	ff 75 08             	pushl  0x8(%ebp)
f010e4c6:	e8 31 fc ff ff       	call   f010e0fc <print_trapframe>
f010e4cb:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e4ce:	83 ec 04             	sub    $0x4,%esp
f010e4d1:	68 e0 74 12 f0       	push   $0xf01274e0
f010e4d6:	68 45 01 00 00       	push   $0x145
f010e4db:	68 96 74 12 f0       	push   $0xf0127496
f010e4e0:	e8 54 1e ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e4e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e4ec:	e8 55 d5 ff ff       	call   f010ba46 <get_cpu_proc>
f010e4f1:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e4f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4f7:	8b 40 34             	mov    0x34(%eax),%eax
f010e4fa:	0f b7 c0             	movzwl %ax,%eax
f010e4fd:	83 e0 03             	and    $0x3,%eax
f010e500:	83 f8 03             	cmp    $0x3,%eax
f010e503:	75 54                	jne    f010e559 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e505:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e509:	74 0b                	je     f010e516 <trap+0x78>
f010e50b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e50e:	8b 40 18             	mov    0x18(%eax),%eax
f010e511:	83 f8 02             	cmp    $0x2,%eax
f010e514:	74 19                	je     f010e52f <trap+0x91>
f010e516:	68 24 75 12 f0       	push   $0xf0127524
f010e51b:	68 52 75 12 f0       	push   $0xf0127552
f010e520:	68 4d 01 00 00       	push   $0x14d
f010e525:	68 96 74 12 f0       	push   $0xf0127496
f010e52a:	e8 0a 1e ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e52f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e532:	8b 00                	mov    (%eax),%eax
f010e534:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e537:	74 19                	je     f010e552 <trap+0xb4>
f010e539:	68 67 75 12 f0       	push   $0xf0127567
f010e53e:	68 52 75 12 f0       	push   $0xf0127552
f010e543:	68 4f 01 00 00       	push   $0x14f
f010e548:	68 96 74 12 f0       	push   $0xf0127496
f010e54d:	e8 e7 1d ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e552:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e559:	8b 45 08             	mov    0x8(%ebp),%eax
f010e55c:	8b 40 28             	mov    0x28(%eax),%eax
f010e55f:	83 f8 1f             	cmp    $0x1f,%eax
f010e562:	76 1b                	jbe    f010e57f <trap+0xe1>
f010e564:	8b 45 08             	mov    0x8(%ebp),%eax
f010e567:	8b 40 28             	mov    0x28(%eax),%eax
f010e56a:	83 f8 2f             	cmp    $0x2f,%eax
f010e56d:	77 10                	ja     f010e57f <trap+0xe1>
	{
		irq_dispatch(tf);
f010e56f:	83 ec 0c             	sub    $0xc,%esp
f010e572:	ff 75 08             	pushl  0x8(%ebp)
f010e575:	e8 8c fd ff ff       	call   f010e306 <irq_dispatch>
f010e57a:	83 c4 10             	add    $0x10,%esp
f010e57d:	eb 0e                	jmp    f010e58d <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e57f:	83 ec 0c             	sub    $0xc,%esp
f010e582:	ff 75 08             	pushl  0x8(%ebp)
f010e585:	e8 c4 fd ff ff       	call   f010e34e <trap_dispatch>
f010e58a:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e58d:	9c                   	pushf  
f010e58e:	58                   	pop    %eax
f010e58f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e592:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e595:	25 00 02 00 00       	and    $0x200,%eax
f010e59a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e59d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e5a1:	74 19                	je     f010e5bc <trap+0x11e>
f010e5a3:	68 7d 75 12 f0       	push   $0xf012757d
f010e5a8:	68 52 75 12 f0       	push   $0xf0127552
f010e5ad:	68 66 01 00 00       	push   $0x166
f010e5b2:	68 96 74 12 f0       	push   $0xf0127496
f010e5b7:	e8 7d 1d ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e5bc:	e8 21 67 ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e5c1:	90                   	nop
f010e5c2:	c9                   	leave  
f010e5c3:	c3                   	ret    

f010e5c4 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e5c4:	6a 08                	push   $0x8
f010e5c6:	e9 ed 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5cb:	90                   	nop

f010e5cc <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e5cc:	6a 0e                	push   $0xe
f010e5ce:	e9 e5 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5d3:	90                   	nop

f010e5d4 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e5d4:	6a 00                	push   $0x0
f010e5d6:	6a 20                	push   $0x20
f010e5d8:	e9 db 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5dd:	90                   	nop

f010e5de <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e5de:	6a 00                	push   $0x0
f010e5e0:	6a 21                	push   $0x21
f010e5e2:	e9 d1 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5e7:	90                   	nop

f010e5e8 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e5e8:	6a 00                	push   $0x0
f010e5ea:	6a 30                	push   $0x30
f010e5ec:	e9 c7 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5f1:	90                   	nop

f010e5f2 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e5f2:	6a 00                	push   $0x0
f010e5f4:	6a 00                	push   $0x0
f010e5f6:	e9 bd 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e5fb:	90                   	nop

f010e5fc <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e5fc:	6a 00                	push   $0x0
f010e5fe:	6a 01                	push   $0x1
f010e600:	e9 b3 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e605:	90                   	nop

f010e606 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e606:	6a 00                	push   $0x0
f010e608:	6a 02                	push   $0x2
f010e60a:	e9 a9 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e60f:	90                   	nop

f010e610 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e610:	6a 00                	push   $0x0
f010e612:	6a 03                	push   $0x3
f010e614:	e9 9f 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e619:	90                   	nop

f010e61a <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e61a:	6a 00                	push   $0x0
f010e61c:	6a 04                	push   $0x4
f010e61e:	e9 95 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e623:	90                   	nop

f010e624 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e624:	6a 00                	push   $0x0
f010e626:	6a 05                	push   $0x5
f010e628:	e9 8b 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e62d:	90                   	nop

f010e62e <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e62e:	6a 00                	push   $0x0
f010e630:	6a 06                	push   $0x6
f010e632:	e9 81 00 00 00       	jmp    f010e6b8 <_alltraps>
f010e637:	90                   	nop

f010e638 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e638:	6a 00                	push   $0x0
f010e63a:	6a 07                	push   $0x7
f010e63c:	eb 7a                	jmp    f010e6b8 <_alltraps>

f010e63e <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e63e:	6a 0a                	push   $0xa
f010e640:	eb 76                	jmp    f010e6b8 <_alltraps>

f010e642 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e642:	6a 0b                	push   $0xb
f010e644:	eb 72                	jmp    f010e6b8 <_alltraps>

f010e646 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e646:	6a 0c                	push   $0xc
f010e648:	eb 6e                	jmp    f010e6b8 <_alltraps>

f010e64a <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e64a:	6a 0d                	push   $0xd
f010e64c:	eb 6a                	jmp    f010e6b8 <_alltraps>

f010e64e <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e64e:	6a 00                	push   $0x0
f010e650:	6a 10                	push   $0x10
f010e652:	eb 64                	jmp    f010e6b8 <_alltraps>

f010e654 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e654:	6a 11                	push   $0x11
f010e656:	eb 60                	jmp    f010e6b8 <_alltraps>

f010e658 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e658:	6a 00                	push   $0x0
f010e65a:	6a 12                	push   $0x12
f010e65c:	eb 5a                	jmp    f010e6b8 <_alltraps>

f010e65e <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e65e:	6a 00                	push   $0x0
f010e660:	6a 13                	push   $0x13
f010e662:	eb 54                	jmp    f010e6b8 <_alltraps>

f010e664 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e664:	6a 00                	push   $0x0
f010e666:	6a 22                	push   $0x22
f010e668:	eb 4e                	jmp    f010e6b8 <_alltraps>

f010e66a <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e66a:	6a 00                	push   $0x0
f010e66c:	6a 23                	push   $0x23
f010e66e:	eb 48                	jmp    f010e6b8 <_alltraps>

f010e670 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e670:	6a 00                	push   $0x0
f010e672:	6a 24                	push   $0x24
f010e674:	eb 42                	jmp    f010e6b8 <_alltraps>

f010e676 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e676:	6a 00                	push   $0x0
f010e678:	6a 25                	push   $0x25
f010e67a:	eb 3c                	jmp    f010e6b8 <_alltraps>

f010e67c <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e67c:	6a 00                	push   $0x0
f010e67e:	6a 26                	push   $0x26
f010e680:	eb 36                	jmp    f010e6b8 <_alltraps>

f010e682 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e682:	6a 00                	push   $0x0
f010e684:	6a 27                	push   $0x27
f010e686:	eb 30                	jmp    f010e6b8 <_alltraps>

f010e688 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e688:	6a 00                	push   $0x0
f010e68a:	6a 28                	push   $0x28
f010e68c:	eb 2a                	jmp    f010e6b8 <_alltraps>

f010e68e <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e68e:	6a 00                	push   $0x0
f010e690:	6a 29                	push   $0x29
f010e692:	eb 24                	jmp    f010e6b8 <_alltraps>

f010e694 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e694:	6a 00                	push   $0x0
f010e696:	6a 2a                	push   $0x2a
f010e698:	eb 1e                	jmp    f010e6b8 <_alltraps>

f010e69a <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e69a:	6a 00                	push   $0x0
f010e69c:	6a 2b                	push   $0x2b
f010e69e:	eb 18                	jmp    f010e6b8 <_alltraps>

f010e6a0 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e6a0:	6a 00                	push   $0x0
f010e6a2:	6a 2c                	push   $0x2c
f010e6a4:	eb 12                	jmp    f010e6b8 <_alltraps>

f010e6a6 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e6a6:	6a 00                	push   $0x0
f010e6a8:	6a 2d                	push   $0x2d
f010e6aa:	eb 0c                	jmp    f010e6b8 <_alltraps>

f010e6ac <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e6ac:	6a 00                	push   $0x0
f010e6ae:	6a 2e                	push   $0x2e
f010e6b0:	eb 06                	jmp    f010e6b8 <_alltraps>

f010e6b2 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e6b2:	6a 00                	push   $0x0
f010e6b4:	6a 2f                	push   $0x2f
f010e6b6:	eb 00                	jmp    f010e6b8 <_alltraps>

f010e6b8 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e6b8:	1e                   	push   %ds
push 	%es
f010e6b9:	06                   	push   %es
pushal
f010e6ba:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e6bb:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e6bf:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e6c1:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e6c3:	54                   	push   %esp
call 	trap
f010e6c4:	e8 d5 fd ff ff       	call   f010e49e <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e6c9:	59                   	pop    %ecx

f010e6ca <trapret>:
.globl trapret
trapret:
popal
f010e6ca:	61                   	popa   
pop 	%es
f010e6cb:	07                   	pop    %es
pop 	%ds
f010e6cc:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e6cd:	83 c4 08             	add    $0x8,%esp
iret
f010e6d0:	cf                   	iret   

f010e6d1 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e6d1:	55                   	push   %ebp
f010e6d2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e6d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d7:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f010e6dd:	29 d0                	sub    %edx,%eax
f010e6df:	c1 f8 03             	sar    $0x3,%eax
f010e6e2:	89 c2                	mov    %eax,%edx
f010e6e4:	89 d0                	mov    %edx,%eax
f010e6e6:	c1 e0 02             	shl    $0x2,%eax
f010e6e9:	01 d0                	add    %edx,%eax
f010e6eb:	c1 e0 02             	shl    $0x2,%eax
f010e6ee:	01 d0                	add    %edx,%eax
f010e6f0:	c1 e0 02             	shl    $0x2,%eax
f010e6f3:	01 d0                	add    %edx,%eax
f010e6f5:	89 c1                	mov    %eax,%ecx
f010e6f7:	c1 e1 08             	shl    $0x8,%ecx
f010e6fa:	01 c8                	add    %ecx,%eax
f010e6fc:	89 c1                	mov    %eax,%ecx
f010e6fe:	c1 e1 10             	shl    $0x10,%ecx
f010e701:	01 c8                	add    %ecx,%eax
f010e703:	01 c0                	add    %eax,%eax
f010e705:	01 d0                	add    %edx,%eax
}
f010e707:	5d                   	pop    %ebp
f010e708:	c3                   	ret    

f010e709 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e709:	55                   	push   %ebp
f010e70a:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e70c:	ff 75 08             	pushl  0x8(%ebp)
f010e70f:	e8 bd ff ff ff       	call   f010e6d1 <to_frame_number>
f010e714:	83 c4 04             	add    $0x4,%esp
f010e717:	c1 e0 0c             	shl    $0xc,%eax
}
f010e71a:	c9                   	leave  
f010e71b:	c3                   	ret    

f010e71c <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e71c:	55                   	push   %ebp
f010e71d:	89 e5                	mov    %esp,%ebp
f010e71f:	83 ec 18             	sub    $0x18,%esp
f010e722:	8b 45 10             	mov    0x10(%ebp),%eax
f010e725:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e728:	e8 a2 8a ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e72d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e731:	74 23                	je     f010e756 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e733:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e738:	8b 40 10             	mov    0x10(%eax),%eax
f010e73b:	8b 15 e0 92 b0 f0    	mov    0xf0b092e0,%edx
f010e741:	83 c2 20             	add    $0x20,%edx
f010e744:	83 ec 04             	sub    $0x4,%esp
f010e747:	50                   	push   %eax
f010e748:	52                   	push   %edx
f010e749:	68 30 77 12 f0       	push   $0xf0127730
f010e74e:	e8 38 28 ff ff       	call   f0100f8b <cprintf>
f010e753:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e756:	83 ec 04             	sub    $0x4,%esp
f010e759:	ff 75 08             	pushl  0x8(%ebp)
f010e75c:	ff 75 0c             	pushl  0xc(%ebp)
f010e75f:	68 39 77 12 f0       	push   $0xf0127739
f010e764:	e8 22 28 ff ff       	call   f0100f8b <cprintf>
f010e769:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e76c:	e8 b0 8a ff ff       	call   f0107221 <popcli>
}
f010e771:	90                   	nop
f010e772:	c9                   	leave  
f010e773:	c3                   	ret    

f010e774 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e774:	55                   	push   %ebp
f010e775:	89 e5                	mov    %esp,%ebp
f010e777:	83 ec 18             	sub    $0x18,%esp
f010e77a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e77d:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e780:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e784:	83 ec 08             	sub    $0x8,%esp
f010e787:	50                   	push   %eax
f010e788:	68 3e 77 12 f0       	push   $0xf012773e
f010e78d:	e8 f9 27 ff ff       	call   f0100f8b <cprintf>
f010e792:	83 c4 10             	add    $0x10,%esp
}
f010e795:	90                   	nop
f010e796:	c9                   	leave  
f010e797:	c3                   	ret    

f010e798 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e798:	55                   	push   %ebp
f010e799:	89 e5                	mov    %esp,%ebp
f010e79b:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e79e:	9c                   	pushf  
f010e79f:	58                   	pop    %eax
f010e7a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e7a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e7a6:	25 00 02 00 00       	and    $0x200,%eax
f010e7ab:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e7ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e7b2:	74 10                	je     f010e7c4 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e7b4:	e8 0b 26 ff ff       	call   f0100dc4 <cons_getc2>
f010e7b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e7bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e7c0:	74 f2                	je     f010e7b4 <sys_cgetc+0x1c>
f010e7c2:	eb 0e                	jmp    f010e7d2 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e7c4:	e8 a0 25 ff ff       	call   f0100d69 <cons_getc>
f010e7c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e7cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e7d0:	74 f2                	je     f010e7c4 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e7d5:	c9                   	leave  
f010e7d6:	c3                   	ret    

f010e7d7 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e7d7:	55                   	push   %ebp
f010e7d8:	89 e5                	mov    %esp,%ebp
f010e7da:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e7dd:	e8 ce 26 ff ff       	call   f0100eb0 <cons_lock>
}
f010e7e2:	90                   	nop
f010e7e3:	c9                   	leave  
f010e7e4:	c3                   	ret    

f010e7e5 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e7e5:	55                   	push   %ebp
f010e7e6:	89 e5                	mov    %esp,%ebp
f010e7e8:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e7eb:	e8 07 27 ff ff       	call   f0100ef7 <cons_unlock>
}
f010e7f0:	90                   	nop
f010e7f1:	c9                   	leave  
f010e7f2:	c3                   	ret    

f010e7f3 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e7f3:	55                   	push   %ebp
f010e7f4:	89 e5                	mov    %esp,%ebp
f010e7f6:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e7f9:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e7fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e801:	83 ec 0c             	sub    $0xc,%esp
f010e804:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e807:	50                   	push   %eax
f010e808:	e8 a5 99 ff ff       	call   f01081b2 <allocate_frame>
f010e80d:	83 c4 10             	add    $0x10,%esp
f010e810:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e813:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e817:	75 08                	jne    f010e821 <__sys_allocate_page+0x2e>
		return r ;
f010e819:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e81c:	e9 e9 00 00 00       	jmp    f010e90a <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e821:	8b 45 08             	mov    0x8(%ebp),%eax
f010e824:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e829:	77 0c                	ja     f010e837 <__sys_allocate_page+0x44>
f010e82b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e82e:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e833:	85 c0                	test   %eax,%eax
f010e835:	74 0a                	je     f010e841 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e837:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e83c:	e9 c9 00 00 00       	jmp    f010e90a <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e841:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e844:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e849:	83 f8 04             	cmp    $0x4,%eax
f010e84c:	74 0a                	je     f010e858 <__sys_allocate_page+0x65>
		return E_INVAL;
f010e84e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e853:	e9 b2 00 00 00       	jmp    f010e90a <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e858:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e85b:	83 ec 0c             	sub    $0xc,%esp
f010e85e:	50                   	push   %eax
f010e85f:	e8 a5 fe ff ff       	call   f010e709 <to_physical_address>
f010e864:	83 c4 10             	add    $0x10,%esp
f010e867:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e86a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e86d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e870:	8b 40 64             	mov    0x64(%eax),%eax
f010e873:	6a 02                	push   $0x2
f010e875:	68 00 00 80 ef       	push   $0xef800000
f010e87a:	52                   	push   %edx
f010e87b:	50                   	push   %eax
f010e87c:	e8 fe 9d ff ff       	call   f010867f <map_frame>
f010e881:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e884:	83 ec 04             	sub    $0x4,%esp
f010e887:	68 00 10 00 00       	push   $0x1000
f010e88c:	6a 00                	push   $0x0
f010e88e:	68 00 00 80 ef       	push   $0xef800000
f010e893:	e8 d8 15 01 00       	call   f011fe70 <memset>
f010e898:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e89b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e89e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8a1:	8b 40 08             	mov    0x8(%eax),%eax
f010e8a4:	40                   	inc    %eax
f010e8a5:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e8a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8ac:	8b 40 64             	mov    0x64(%eax),%eax
f010e8af:	83 ec 08             	sub    $0x8,%esp
f010e8b2:	68 00 00 80 ef       	push   $0xef800000
f010e8b7:	50                   	push   %eax
f010e8b8:	e8 22 9f ff ff       	call   f01087df <unmap_frame>
f010e8bd:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e8c0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e8c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8c6:	8b 40 08             	mov    0x8(%eax),%eax
f010e8c9:	48                   	dec    %eax
f010e8ca:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e8ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e8d1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e8d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8d7:	8b 40 64             	mov    0x64(%eax),%eax
f010e8da:	ff 75 0c             	pushl  0xc(%ebp)
f010e8dd:	51                   	push   %ecx
f010e8de:	52                   	push   %edx
f010e8df:	50                   	push   %eax
f010e8e0:	e8 9a 9d ff ff       	call   f010867f <map_frame>
f010e8e5:	83 c4 10             	add    $0x10,%esp
f010e8e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e8eb:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e8ef:	75 14                	jne    f010e905 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e8f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8f4:	83 ec 0c             	sub    $0xc,%esp
f010e8f7:	50                   	push   %eax
f010e8f8:	e8 c2 9a ff ff       	call   f01083bf <decrement_references>
f010e8fd:	83 c4 10             	add    $0x10,%esp
		return r;
f010e900:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e903:	eb 05                	jmp    f010e90a <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e90a:	c9                   	leave  
f010e90b:	c3                   	ret    

f010e90c <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e90c:	55                   	push   %ebp
f010e90d:	89 e5                	mov    %esp,%ebp
f010e90f:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e912:	83 ec 04             	sub    $0x4,%esp
f010e915:	68 41 77 12 f0       	push   $0xf0127741
f010e91a:	68 dc 00 00 00       	push   $0xdc
f010e91f:	68 5f 77 12 f0       	push   $0xf012775f
f010e924:	e8 10 1a ff ff       	call   f0100339 <_panic>

f010e929 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e929:	55                   	push   %ebp
f010e92a:	89 e5                	mov    %esp,%ebp
f010e92c:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e92f:	83 ec 04             	sub    $0x4,%esp
f010e932:	68 74 77 12 f0       	push   $0xf0127774
f010e937:	68 ed 00 00 00       	push   $0xed
f010e93c:	68 5f 77 12 f0       	push   $0xf012775f
f010e941:	e8 f3 19 ff ff       	call   f0100339 <_panic>

f010e946 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e946:	55                   	push   %ebp
f010e947:	89 e5                	mov    %esp,%ebp
f010e949:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e94c:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e951:	8b 40 64             	mov    0x64(%eax),%eax
f010e954:	83 ec 04             	sub    $0x4,%esp
f010e957:	ff 75 0c             	pushl  0xc(%ebp)
f010e95a:	ff 75 08             	pushl  0x8(%ebp)
f010e95d:	50                   	push   %eax
f010e95e:	e8 26 c2 ff ff       	call   f010ab89 <calculate_required_frames>
f010e963:	83 c4 10             	add    $0x10,%esp
}
f010e966:	c9                   	leave  
f010e967:	c3                   	ret    

f010e968 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e968:	55                   	push   %ebp
f010e969:	89 e5                	mov    %esp,%ebp
f010e96b:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e96e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e971:	83 ec 0c             	sub    $0xc,%esp
f010e974:	50                   	push   %eax
f010e975:	e8 e7 9f ff ff       	call   f0108961 <calculate_available_frames>
f010e97a:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e97d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e980:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e983:	01 d0                	add    %edx,%eax
}
f010e985:	c9                   	leave  
f010e986:	c3                   	ret    

f010e987 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e987:	55                   	push   %ebp
f010e988:	89 e5                	mov    %esp,%ebp
f010e98a:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e98d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e990:	83 ec 0c             	sub    $0xc,%esp
f010e993:	50                   	push   %eax
f010e994:	e8 c8 9f ff ff       	call   f0108961 <calculate_available_frames>
f010e999:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e99c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e99f:	c9                   	leave  
f010e9a0:	c3                   	ret    

f010e9a1 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e9a1:	55                   	push   %ebp
f010e9a2:	89 e5                	mov    %esp,%ebp
f010e9a4:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9a7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9aa:	83 ec 0c             	sub    $0xc,%esp
f010e9ad:	50                   	push   %eax
f010e9ae:	e8 ae 9f ff ff       	call   f0108961 <calculate_available_frames>
f010e9b3:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e9b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e9b9:	c9                   	leave  
f010e9ba:	c3                   	ret    

f010e9bb <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e9bb:	55                   	push   %ebp
f010e9bc:	89 e5                	mov    %esp,%ebp
f010e9be:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e9c1:	83 ec 0c             	sub    $0xc,%esp
f010e9c4:	ff 75 08             	pushl  0x8(%ebp)
f010e9c7:	e8 4d 00 01 00       	call   f011ea19 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e9cc:	83 c4 10             	add    $0x10,%esp
}
f010e9cf:	c9                   	leave  
f010e9d0:	c3                   	ret    

f010e9d1 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e9d1:	55                   	push   %ebp
f010e9d2:	89 e5                	mov    %esp,%ebp
f010e9d4:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e9d7:	e8 68 ff 00 00       	call   f011e944 <scarce_memory>
}
f010e9dc:	90                   	nop
f010e9dd:	c9                   	leave  
f010e9de:	c3                   	ret    

f010e9df <sys_clearFFL>:

void sys_clearFFL()
{
f010e9df:	55                   	push   %ebp
f010e9e0:	89 e5                	mov    %esp,%ebp
f010e9e2:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e9e5:	83 ec 0c             	sub    $0xc,%esp
f010e9e8:	68 a0 16 6c f0       	push   $0xf06c16a0
f010e9ed:	e8 e2 12 00 00       	call   f010fcd4 <acquire_spinlock>
f010e9f2:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e9f5:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f010e9fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e9fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ea04:	eb 12                	jmp    f010ea18 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ea06:	83 ec 0c             	sub    $0xc,%esp
f010ea09:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ea0c:	50                   	push   %eax
f010ea0d:	e8 a0 97 ff ff       	call   f01081b2 <allocate_frame>
f010ea12:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ea15:	ff 45 f4             	incl   -0xc(%ebp)
f010ea18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea1b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ea1e:	7c e6                	jl     f010ea06 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ea20:	83 ec 0c             	sub    $0xc,%esp
f010ea23:	68 a0 16 6c f0       	push   $0xf06c16a0
f010ea28:	e8 2e 13 00 00       	call   f010fd5b <release_spinlock>
f010ea2d:	83 c4 10             	add    $0x10,%esp
}
f010ea30:	90                   	nop
f010ea31:	c9                   	leave  
f010ea32:	c3                   	ret    

f010ea33 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ea33:	55                   	push   %ebp
f010ea34:	89 e5                	mov    %esp,%ebp
f010ea36:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ea39:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ea3e:	83 ec 0c             	sub    $0xc,%esp
f010ea41:	50                   	push   %eax
f010ea42:	e8 b8 5d ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010ea47:	83 c4 10             	add    $0x10,%esp
}
f010ea4a:	c9                   	leave  
f010ea4b:	c3                   	ret    

f010ea4c <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010ea4c:	55                   	push   %ebp
f010ea4d:	89 e5                	mov    %esp,%ebp
f010ea4f:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010ea52:	e8 ed 0c 00 00       	call   f010f744 <isBufferingEnabled>
f010ea57:	84 c0                	test   %al,%al
f010ea59:	74 19                	je     f010ea74 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ea5b:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ea60:	83 ec 04             	sub    $0x4,%esp
f010ea63:	ff 75 0c             	pushl  0xc(%ebp)
f010ea66:	ff 75 08             	pushl  0x8(%ebp)
f010ea69:	50                   	push   %eax
f010ea6a:	e8 49 c3 ff ff       	call   f010adb8 <__free_user_mem_with_buffering>
f010ea6f:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ea72:	eb 18                	jmp    f010ea8c <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ea74:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ea79:	83 ec 04             	sub    $0x4,%esp
f010ea7c:	ff 75 0c             	pushl  0xc(%ebp)
f010ea7f:	ff 75 08             	pushl  0x8(%ebp)
f010ea82:	50                   	push   %eax
f010ea83:	e8 60 c2 ff ff       	call   f010ace8 <free_user_mem>
f010ea88:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ea8b:	90                   	nop
}
f010ea8c:	c9                   	leave  
f010ea8d:	c3                   	ret    

f010ea8e <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010ea8e:	55                   	push   %ebp
f010ea8f:	89 e5                	mov    %esp,%ebp
f010ea91:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010ea94:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ea98:	75 07                	jne    f010eaa1 <check_Param+0x13>
	{
		env_exit();
f010ea9a:	e8 65 cf ff ff       	call   f010ba04 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ea9f:	eb 25                	jmp    f010eac6 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010eaa1:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010eaa8:	77 07                	ja     f010eab1 <check_Param+0x23>
f010eaaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaad:	85 c0                	test   %eax,%eax
f010eaaf:	78 07                	js     f010eab8 <check_Param+0x2a>
	{
		env_exit();
f010eab1:	e8 4e cf ff ff       	call   f010ba04 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010eab6:	eb 0e                	jmp    f010eac6 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010eab8:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010eabf:	76 05                	jbe    f010eac6 <check_Param+0x38>
	{
		env_exit();
f010eac1:	e8 3e cf ff ff       	call   f010ba04 <env_exit>
	}
}
f010eac6:	90                   	nop
f010eac7:	c9                   	leave  
f010eac8:	c3                   	ret    

f010eac9 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010eac9:	55                   	push   %ebp
f010eaca:	89 e5                	mov    %esp,%ebp
f010eacc:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eacf:	83 ec 0c             	sub    $0xc,%esp
f010ead2:	ff 75 08             	pushl  0x8(%ebp)
f010ead5:	e8 b4 ff ff ff       	call   f010ea8e <check_Param>
f010eada:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010eadd:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eae2:	83 ec 04             	sub    $0x4,%esp
f010eae5:	ff 75 0c             	pushl  0xc(%ebp)
f010eae8:	ff 75 08             	pushl  0x8(%ebp)
f010eaeb:	50                   	push   %eax
f010eaec:	e8 3c c1 ff ff       	call   f010ac2d <allocate_user_mem>
f010eaf1:	83 c4 10             	add    $0x10,%esp
	return;
f010eaf4:	90                   	nop
}
f010eaf5:	c9                   	leave  
f010eaf6:	c3                   	ret    

f010eaf7 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010eaf7:	55                   	push   %ebp
f010eaf8:	89 e5                	mov    %esp,%ebp
f010eafa:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eafd:	83 ec 0c             	sub    $0xc,%esp
f010eb00:	ff 75 08             	pushl  0x8(%ebp)
f010eb03:	e8 86 ff ff ff       	call   f010ea8e <check_Param>
f010eb08:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010eb0b:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb10:	8b 40 64             	mov    0x64(%eax),%eax
f010eb13:	ff 75 10             	pushl  0x10(%ebp)
f010eb16:	ff 75 0c             	pushl  0xc(%ebp)
f010eb19:	ff 75 08             	pushl  0x8(%ebp)
f010eb1c:	50                   	push   %eax
f010eb1d:	e8 33 c0 ff ff       	call   f010ab55 <allocate_chunk>
f010eb22:	83 c4 10             	add    $0x10,%esp
	return;
f010eb25:	90                   	nop
}
f010eb26:	c9                   	leave  
f010eb27:	c3                   	ret    

f010eb28 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010eb28:	55                   	push   %ebp
f010eb29:	89 e5                	mov    %esp,%ebp
f010eb2b:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010eb2e:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb33:	ff 75 10             	pushl  0x10(%ebp)
f010eb36:	ff 75 0c             	pushl  0xc(%ebp)
f010eb39:	ff 75 08             	pushl  0x8(%ebp)
f010eb3c:	50                   	push   %eax
f010eb3d:	e8 93 c2 ff ff       	call   f010add5 <move_user_mem>
f010eb42:	83 c4 10             	add    $0x10,%esp
	return;
f010eb45:	90                   	nop
}
f010eb46:	c9                   	leave  
f010eb47:	c3                   	ret    

f010eb48 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010eb48:	55                   	push   %ebp
f010eb49:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010eb4b:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
}
f010eb50:	5d                   	pop    %ebp
f010eb51:	c3                   	ret    

f010eb52 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010eb52:	55                   	push   %ebp
f010eb53:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010eb55:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb58:	a3 c4 1a 6c f0       	mov    %eax,0xf06c1ac4
}
f010eb5d:	90                   	nop
f010eb5e:	5d                   	pop    %ebp
f010eb5f:	c3                   	ret    

f010eb60 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eb60:	55                   	push   %ebp
f010eb61:	89 e5                	mov    %esp,%ebp
f010eb63:	83 ec 18             	sub    $0x18,%esp
f010eb66:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb69:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010eb6c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010eb70:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb75:	8b 40 10             	mov    0x10(%eax),%eax
f010eb78:	83 ec 0c             	sub    $0xc,%esp
f010eb7b:	ff 75 14             	pushl  0x14(%ebp)
f010eb7e:	52                   	push   %edx
f010eb7f:	ff 75 0c             	pushl  0xc(%ebp)
f010eb82:	ff 75 08             	pushl  0x8(%ebp)
f010eb85:	50                   	push   %eax
f010eb86:	e8 fa a0 ff ff       	call   f0108c85 <createSharedObject>
f010eb8b:	83 c4 20             	add    $0x20,%esp
}
f010eb8e:	c9                   	leave  
f010eb8f:	c3                   	ret    

f010eb90 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010eb90:	55                   	push   %ebp
f010eb91:	89 e5                	mov    %esp,%ebp
f010eb93:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010eb96:	83 ec 08             	sub    $0x8,%esp
f010eb99:	ff 75 0c             	pushl  0xc(%ebp)
f010eb9c:	ff 75 08             	pushl  0x8(%ebp)
f010eb9f:	e8 dc 9e ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010eba4:	83 c4 10             	add    $0x10,%esp
}
f010eba7:	c9                   	leave  
f010eba8:	c3                   	ret    

f010eba9 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010eba9:	55                   	push   %ebp
f010ebaa:	89 e5                	mov    %esp,%ebp
f010ebac:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010ebaf:	83 ec 04             	sub    $0x4,%esp
f010ebb2:	ff 75 10             	pushl  0x10(%ebp)
f010ebb5:	ff 75 0c             	pushl  0xc(%ebp)
f010ebb8:	ff 75 08             	pushl  0x8(%ebp)
f010ebbb:	e8 7e a2 ff ff       	call   f0108e3e <getSharedObject>
f010ebc0:	83 c4 10             	add    $0x10,%esp
}
f010ebc3:	c9                   	leave  
f010ebc4:	c3                   	ret    

f010ebc5 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010ebc5:	55                   	push   %ebp
f010ebc6:	89 e5                	mov    %esp,%ebp
f010ebc8:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010ebcb:	83 ec 08             	sub    $0x8,%esp
f010ebce:	ff 75 0c             	pushl  0xc(%ebp)
f010ebd1:	ff 75 08             	pushl  0x8(%ebp)
f010ebd4:	e8 dc a4 ff ff       	call   f01090b5 <freeSharedObject>
f010ebd9:	83 c4 10             	add    $0x10,%esp
}
f010ebdc:	c9                   	leave  
f010ebdd:	c3                   	ret    

f010ebde <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ebde:	55                   	push   %ebp
f010ebdf:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010ebe1:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ebe6:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ebe9:	5d                   	pop    %ebp
f010ebea:	c3                   	ret    

f010ebeb <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ebeb:	55                   	push   %ebp
f010ebec:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ebee:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ebf3:	89 c2                	mov    %eax,%edx
f010ebf5:	a1 f0 8a 69 f0       	mov    0xf0698af0,%eax
f010ebfa:	29 c2                	sub    %eax,%edx
f010ebfc:	89 d0                	mov    %edx,%eax
f010ebfe:	c1 f8 02             	sar    $0x2,%eax
f010ec01:	89 c2                	mov    %eax,%edx
f010ec03:	89 d0                	mov    %edx,%eax
f010ec05:	c1 e0 03             	shl    $0x3,%eax
f010ec08:	01 d0                	add    %edx,%eax
f010ec0a:	c1 e0 03             	shl    $0x3,%eax
f010ec0d:	01 d0                	add    %edx,%eax
f010ec0f:	c1 e0 02             	shl    $0x2,%eax
f010ec12:	01 d0                	add    %edx,%eax
f010ec14:	01 c0                	add    %eax,%eax
f010ec16:	01 d0                	add    %edx,%eax
f010ec18:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ec1f:	01 c8                	add    %ecx,%eax
f010ec21:	c1 e0 02             	shl    $0x2,%eax
f010ec24:	01 d0                	add    %edx,%eax
f010ec26:	c1 e0 03             	shl    $0x3,%eax
f010ec29:	01 d0                	add    %edx,%eax
f010ec2b:	c1 e0 05             	shl    $0x5,%eax
f010ec2e:	29 d0                	sub    %edx,%eax
f010ec30:	c1 e0 02             	shl    $0x2,%eax
f010ec33:	01 d0                	add    %edx,%eax
f010ec35:	01 c0                	add    %eax,%eax
f010ec37:	01 d0                	add    %edx,%eax
f010ec39:	c1 e0 03             	shl    $0x3,%eax
f010ec3c:	01 d0                	add    %edx,%eax
f010ec3e:	c1 e0 04             	shl    $0x4,%eax
f010ec41:	29 d0                	sub    %edx,%eax
}
f010ec43:	5d                   	pop    %ebp
f010ec44:	c3                   	ret    

f010ec45 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ec45:	55                   	push   %ebp
f010ec46:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ec48:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec4d:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ec50:	5d                   	pop    %ebp
f010ec51:	c3                   	ret    

f010ec52 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ec52:	55                   	push   %ebp
f010ec53:	89 e5                	mov    %esp,%ebp
f010ec55:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010ec58:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ec5c:	75 0a                	jne    f010ec68 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010ec5e:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec63:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ec66:	eb 22                	jmp    f010ec8a <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ec68:	83 ec 04             	sub    $0x4,%esp
f010ec6b:	6a 00                	push   $0x0
f010ec6d:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ec70:	50                   	push   %eax
f010ec71:	ff 75 08             	pushl  0x8(%ebp)
f010ec74:	e8 1d ce ff ff       	call   f010ba96 <envid2env>
f010ec79:	83 c4 10             	add    $0x10,%esp
f010ec7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ec7f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec83:	79 05                	jns    f010ec8a <sys_destroy_env+0x38>
	{
		return r;
f010ec85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec88:	eb 5e                	jmp    f010ece8 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010ec8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec8d:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec92:	39 c2                	cmp    %eax,%edx
f010ec94:	75 1b                	jne    f010ecb1 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ec96:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec9b:	8b 40 10             	mov    0x10(%eax),%eax
f010ec9e:	83 ec 08             	sub    $0x8,%esp
f010eca1:	50                   	push   %eax
f010eca2:	68 93 77 12 f0       	push   $0xf0127793
f010eca7:	e8 df 22 ff ff       	call   f0100f8b <cprintf>
f010ecac:	83 c4 10             	add    $0x10,%esp
f010ecaf:	eb 20                	jmp    f010ecd1 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ecb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecb4:	8b 50 10             	mov    0x10(%eax),%edx
f010ecb7:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ecbc:	8b 40 10             	mov    0x10(%eax),%eax
f010ecbf:	83 ec 04             	sub    $0x4,%esp
f010ecc2:	52                   	push   %edx
f010ecc3:	50                   	push   %eax
f010ecc4:	68 ae 77 12 f0       	push   $0xf01277ae
f010ecc9:	e8 bd 22 ff ff       	call   f0100f8b <cprintf>
f010ecce:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010ecd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecd4:	8b 40 10             	mov    0x10(%eax),%eax
f010ecd7:	83 ec 0c             	sub    $0xc,%esp
f010ecda:	50                   	push   %eax
f010ecdb:	e8 d8 6d ff ff       	call   f0105ab8 <sched_kill_env>
f010ece0:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ece3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ece8:	c9                   	leave  
f010ece9:	c3                   	ret    

f010ecea <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ecea:	55                   	push   %ebp
f010eceb:	89 e5                	mov    %esp,%ebp
f010eced:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ecf0:	e8 0f cd ff ff       	call   f010ba04 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ecf5:	90                   	nop
f010ecf6:	c9                   	leave  
f010ecf7:	c3                   	ret    

f010ecf8 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ecf8:	55                   	push   %ebp
f010ecf9:	89 e5                	mov    %esp,%ebp
f010ecfb:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ecfe:	ff 75 14             	pushl  0x14(%ebp)
f010ed01:	ff 75 10             	pushl  0x10(%ebp)
f010ed04:	ff 75 0c             	pushl  0xc(%ebp)
f010ed07:	ff 75 08             	pushl  0x8(%ebp)
f010ed0a:	e8 b9 c2 ff ff       	call   f010afc8 <env_create>
f010ed0f:	83 c4 10             	add    $0x10,%esp
f010ed12:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ed15:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed19:	75 07                	jne    f010ed22 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ed1b:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ed20:	eb 14                	jmp    f010ed36 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ed22:	83 ec 0c             	sub    $0xc,%esp
f010ed25:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed28:	e8 ef 69 ff ff       	call   f010571c <sched_new_env>
f010ed2d:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ed30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed33:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ed36:	c9                   	leave  
f010ed37:	c3                   	ret    

f010ed38 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ed38:	55                   	push   %ebp
f010ed39:	89 e5                	mov    %esp,%ebp
f010ed3b:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ed3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed41:	83 ec 0c             	sub    $0xc,%esp
f010ed44:	50                   	push   %eax
f010ed45:	e8 28 6a ff ff       	call   f0105772 <sched_run_env>
f010ed4a:	83 c4 10             	add    $0x10,%esp
}
f010ed4d:	90                   	nop
f010ed4e:	c9                   	leave  
f010ed4f:	c3                   	ret    

f010ed50 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ed50:	55                   	push   %ebp
f010ed51:	89 e5                	mov    %esp,%ebp
f010ed53:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ed56:	0f 31                	rdtsc  
f010ed58:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ed5b:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ed5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed61:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ed64:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ed67:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ed6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ed6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ed70:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ed73:	89 01                	mov    %eax,(%ecx)
f010ed75:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010ed78:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed7b:	c9                   	leave  
f010ed7c:	c2 04 00             	ret    $0x4

f010ed7f <sys_rcr2>:

uint32 sys_rcr2()
{
f010ed7f:	55                   	push   %ebp
f010ed80:	89 e5                	mov    %esp,%ebp
f010ed82:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010ed85:	0f 20 d0             	mov    %cr2,%eax
f010ed88:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ed8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ed8e:	90                   	nop
}
f010ed8f:	c9                   	leave  
f010ed90:	c3                   	ret    

f010ed91 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ed91:	55                   	push   %ebp
f010ed92:	89 e5                	mov    %esp,%ebp
f010ed94:	83 ec 04             	sub    $0x4,%esp
f010ed97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed9a:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010ed9d:	8a 45 fc             	mov    -0x4(%ebp),%al
f010eda0:	a2 60 93 69 f0       	mov    %al,0xf0699360
}
f010eda5:	90                   	nop
f010eda6:	c9                   	leave  
f010eda7:	c3                   	ret    

f010eda8 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010eda8:	55                   	push   %ebp
f010eda9:	89 e5                	mov    %esp,%ebp
f010edab:	56                   	push   %esi
f010edac:	53                   	push   %ebx
f010edad:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010edb0:	e8 91 cc ff ff       	call   f010ba46 <get_cpu_proc>
f010edb5:	a3 e0 92 b0 f0       	mov    %eax,0xf0b092e0
	assert(cur_env != NULL);
f010edba:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010edbf:	85 c0                	test   %eax,%eax
f010edc1:	75 19                	jne    f010eddc <syscall+0x34>
f010edc3:	68 c6 77 12 f0       	push   $0xf01277c6
f010edc8:	68 d6 77 12 f0       	push   $0xf01277d6
f010edcd:	68 05 02 00 00       	push   $0x205
f010edd2:	68 5f 77 12 f0       	push   $0xf012775f
f010edd7:	e8 5d 15 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010eddc:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010ede0:	0f 87 06 04 00 00    	ja     f010f1ec <syscall+0x444>
f010ede6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ede9:	c1 e0 02             	shl    $0x2,%eax
f010edec:	05 ec 77 12 f0       	add    $0xf01277ec,%eax
f010edf1:	8b 00                	mov    (%eax),%eax
f010edf3:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010edf5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010edf8:	83 ec 0c             	sub    $0xc,%esp
f010edfb:	50                   	push   %eax
f010edfc:	e8 a2 bd ff ff       	call   f010aba3 <sys_sbrk>
f010ee01:	83 c4 10             	add    $0x10,%esp
f010ee04:	e9 e8 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010ee09:	83 ec 08             	sub    $0x8,%esp
f010ee0c:	ff 75 10             	pushl  0x10(%ebp)
f010ee0f:	ff 75 0c             	pushl  0xc(%ebp)
f010ee12:	e8 35 fc ff ff       	call   f010ea4c <sys_free_user_mem>
f010ee17:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee1a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee1f:	e9 cd 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010ee24:	83 ec 08             	sub    $0x8,%esp
f010ee27:	ff 75 10             	pushl  0x10(%ebp)
f010ee2a:	ff 75 0c             	pushl  0xc(%ebp)
f010ee2d:	e8 97 fc ff ff       	call   f010eac9 <sys_allocate_user_mem>
f010ee32:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee35:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee3a:	e9 b2 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010ee3f:	8b 45 14             	mov    0x14(%ebp),%eax
f010ee42:	0f b6 d0             	movzbl %al,%edx
f010ee45:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee48:	83 ec 04             	sub    $0x4,%esp
f010ee4b:	52                   	push   %edx
f010ee4c:	ff 75 10             	pushl  0x10(%ebp)
f010ee4f:	50                   	push   %eax
f010ee50:	e8 c7 f8 ff ff       	call   f010e71c <sys_cputs>
f010ee55:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee58:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee5d:	e9 8f 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010ee62:	e8 31 f9 ff ff       	call   f010e798 <sys_cgetc>
f010ee67:	e9 85 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010ee6c:	e8 66 f9 ff ff       	call   f010e7d7 <sys_lock_cons>
		return 0;
f010ee71:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee76:	e9 76 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010ee7b:	e8 65 f9 ff ff       	call   f010e7e5 <sys_unlock_cons>
		return 0;
f010ee80:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee85:	e9 67 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010ee8a:	83 ec 08             	sub    $0x8,%esp
f010ee8d:	ff 75 10             	pushl  0x10(%ebp)
f010ee90:	ff 75 0c             	pushl  0xc(%ebp)
f010ee93:	e8 ae fa ff ff       	call   f010e946 <sys_calculate_required_frames>
f010ee98:	83 c4 10             	add    $0x10,%esp
f010ee9b:	e9 51 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010eea0:	e8 c3 fa ff ff       	call   f010e968 <sys_calculate_free_frames>
f010eea5:	e9 47 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010eeaa:	e8 d8 fa ff ff       	call   f010e987 <sys_calculate_modified_frames>
f010eeaf:	e9 3d 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010eeb4:	e8 e8 fa ff ff       	call   f010e9a1 <sys_calculate_notmod_frames>
f010eeb9:	e9 33 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010eebe:	e8 70 fb ff ff       	call   f010ea33 <sys_pf_calculate_allocated_pages>
f010eec3:	e9 29 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010eec8:	83 ec 0c             	sub    $0xc,%esp
f010eecb:	ff 75 0c             	pushl  0xc(%ebp)
f010eece:	e8 e8 fa ff ff       	call   f010e9bb <sys_calculate_pages_tobe_removed_ready_exit>
f010eed3:	83 c4 10             	add    $0x10,%esp
f010eed6:	e9 16 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010eedb:	e8 f1 fa ff ff       	call   f010e9d1 <sys_scarce_memory>
		return 0;
f010eee0:	b8 00 00 00 00       	mov    $0x0,%eax
f010eee5:	e9 07 03 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010eeea:	83 ec 04             	sub    $0x4,%esp
f010eeed:	ff 75 14             	pushl  0x14(%ebp)
f010eef0:	ff 75 10             	pushl  0x10(%ebp)
f010eef3:	ff 75 0c             	pushl  0xc(%ebp)
f010eef6:	e8 fc fb ff ff       	call   f010eaf7 <sys_allocate_chunk>
f010eefb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eefe:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef03:	e9 e9 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010ef08:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef0e:	83 ec 08             	sub    $0x8,%esp
f010ef11:	52                   	push   %edx
f010ef12:	50                   	push   %eax
f010ef13:	e8 db f8 ff ff       	call   f010e7f3 <__sys_allocate_page>
f010ef18:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef1b:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef20:	e9 cc 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010ef25:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010ef28:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010ef2b:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010ef2e:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef31:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef34:	83 ec 0c             	sub    $0xc,%esp
f010ef37:	56                   	push   %esi
f010ef38:	53                   	push   %ebx
f010ef39:	51                   	push   %ecx
f010ef3a:	52                   	push   %edx
f010ef3b:	50                   	push   %eax
f010ef3c:	e8 cb f9 ff ff       	call   f010e90c <__sys_map_frame>
f010ef41:	83 c4 20             	add    $0x20,%esp
		return 0;
f010ef44:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef49:	e9 a3 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010ef4e:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef54:	83 ec 08             	sub    $0x8,%esp
f010ef57:	52                   	push   %edx
f010ef58:	50                   	push   %eax
f010ef59:	e8 cb f9 ff ff       	call   f010e929 <__sys_unmap_frame>
f010ef5e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef61:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef66:	e9 86 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010ef6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef6e:	0f be c0             	movsbl %al,%eax
f010ef71:	83 ec 0c             	sub    $0xc,%esp
f010ef74:	50                   	push   %eax
f010ef75:	e8 fa f7 ff ff       	call   f010e774 <sys_cputc>
f010ef7a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef7d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef82:	e9 6a 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010ef87:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef8a:	0f be c0             	movsbl %al,%eax
f010ef8d:	83 ec 0c             	sub    $0xc,%esp
f010ef90:	50                   	push   %eax
f010ef91:	e8 49 fa ff ff       	call   f010e9df <sys_clearFFL>
f010ef96:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef99:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef9e:	e9 4e 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010efa3:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010efa6:	8b 45 14             	mov    0x14(%ebp),%eax
f010efa9:	0f b6 d0             	movzbl %al,%edx
f010efac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efaf:	51                   	push   %ecx
f010efb0:	52                   	push   %edx
f010efb1:	ff 75 10             	pushl  0x10(%ebp)
f010efb4:	50                   	push   %eax
f010efb5:	e8 a6 fb ff ff       	call   f010eb60 <sys_createSharedObject>
f010efba:	83 c4 10             	add    $0x10,%esp
f010efbd:	e9 2f 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010efc2:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010efc5:	8b 55 10             	mov    0x10(%ebp),%edx
f010efc8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efcb:	83 ec 04             	sub    $0x4,%esp
f010efce:	51                   	push   %ecx
f010efcf:	52                   	push   %edx
f010efd0:	50                   	push   %eax
f010efd1:	e8 d3 fb ff ff       	call   f010eba9 <sys_getSharedObject>
f010efd6:	83 c4 10             	add    $0x10,%esp
f010efd9:	e9 13 02 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010efde:	8b 55 10             	mov    0x10(%ebp),%edx
f010efe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efe4:	83 ec 08             	sub    $0x8,%esp
f010efe7:	52                   	push   %edx
f010efe8:	50                   	push   %eax
f010efe9:	e8 d7 fb ff ff       	call   f010ebc5 <sys_freeSharedObject>
f010efee:	83 c4 10             	add    $0x10,%esp
f010eff1:	e9 fb 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010eff6:	8b 55 10             	mov    0x10(%ebp),%edx
f010eff9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010effc:	83 ec 08             	sub    $0x8,%esp
f010efff:	52                   	push   %edx
f010f000:	50                   	push   %eax
f010f001:	e8 8a fb ff ff       	call   f010eb90 <sys_getSizeOfSharedObject>
f010f006:	83 c4 10             	add    $0x10,%esp
f010f009:	e9 e3 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f00e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f011:	ff 75 18             	pushl  0x18(%ebp)
f010f014:	ff 75 14             	pushl  0x14(%ebp)
f010f017:	ff 75 10             	pushl  0x10(%ebp)
f010f01a:	50                   	push   %eax
f010f01b:	e8 d8 fc ff ff       	call   f010ecf8 <sys_create_env>
f010f020:	83 c4 10             	add    $0x10,%esp
f010f023:	e9 c9 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f028:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f02b:	83 ec 0c             	sub    $0xc,%esp
f010f02e:	50                   	push   %eax
f010f02f:	e8 04 fd ff ff       	call   f010ed38 <sys_run_env>
f010f034:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f037:	b8 00 00 00 00       	mov    $0x0,%eax
f010f03c:	e9 b0 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f041:	e8 a5 fb ff ff       	call   f010ebeb <sys_getenvindex>
f010f046:	e9 a6 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f04b:	e8 8e fb ff ff       	call   f010ebde <sys_getenvid>
f010f050:	e9 9c 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f055:	e8 eb fb ff ff       	call   f010ec45 <sys_getparentenvid>
f010f05a:	e9 92 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f05f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f062:	83 ec 0c             	sub    $0xc,%esp
f010f065:	50                   	push   %eax
f010f066:	e8 e7 fb ff ff       	call   f010ec52 <sys_destroy_env>
f010f06b:	83 c4 10             	add    $0x10,%esp
f010f06e:	e9 7e 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f073:	e8 72 fc ff ff       	call   f010ecea <sys_exit_env>
		return 0;
f010f078:	b8 00 00 00 00       	mov    $0x0,%eax
f010f07d:	e9 6f 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f082:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f085:	83 ec 0c             	sub    $0xc,%esp
f010f088:	50                   	push   %eax
f010f089:	e8 c2 fc ff ff       	call   f010ed50 <sys_get_virtual_time>
f010f08e:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f091:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f094:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f097:	8b 45 10             	mov    0x10(%ebp),%eax
f010f09a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f09d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f0a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f0a3:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f0a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f0a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f0ab:	89 10                	mov    %edx,(%eax)
		return 0;
f010f0ad:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0b2:	e9 3a 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f0b7:	83 ec 04             	sub    $0x4,%esp
f010f0ba:	ff 75 14             	pushl  0x14(%ebp)
f010f0bd:	ff 75 10             	pushl  0x10(%ebp)
f010f0c0:	ff 75 0c             	pushl  0xc(%ebp)
f010f0c3:	e8 60 fa ff ff       	call   f010eb28 <sys_move_user_mem>
f010f0c8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0cb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0d0:	e9 1c 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f0d5:	e8 a5 fc ff ff       	call   f010ed7f <sys_rcr2>
f010f0da:	e9 12 01 00 00       	jmp    f010f1f1 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f0df:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0e2:	0f b6 c0             	movzbl %al,%eax
f010f0e5:	83 ec 0c             	sub    $0xc,%esp
f010f0e8:	50                   	push   %eax
f010f0e9:	e8 a3 fc ff ff       	call   f010ed91 <sys_bypassPageFault>
f010f0ee:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0f6:	e9 f6 00 00 00       	jmp    f010f1f1 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f0fb:	e8 f8 ee 00 00       	call   f011dff8 <rsttst>
		return 0;
f010f100:	b8 00 00 00 00       	mov    $0x0,%eax
f010f105:	e9 e7 00 00 00       	jmp    f010f1f1 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f10a:	e8 31 ef 00 00       	call   f011e040 <inctst>
		return 0;
f010f10f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f114:	e9 d8 00 00 00       	jmp    f010f1f1 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f119:	83 ec 0c             	sub    $0xc,%esp
f010f11c:	ff 75 0c             	pushl  0xc(%ebp)
f010f11f:	e8 5e f0 00 00       	call   f011e182 <chktst>
f010f124:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f127:	b8 00 00 00 00       	mov    $0x0,%eax
f010f12c:	e9 c0 00 00 00       	jmp    f010f1f1 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f131:	e8 3e ef 00 00       	call   f011e074 <gettst>
f010f136:	e9 b6 00 00 00       	jmp    f010f1f1 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f13b:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f13e:	8b 45 18             	mov    0x18(%ebp),%eax
f010f141:	0f be c0             	movsbl %al,%eax
f010f144:	83 ec 0c             	sub    $0xc,%esp
f010f147:	52                   	push   %edx
f010f148:	50                   	push   %eax
f010f149:	ff 75 14             	pushl  0x14(%ebp)
f010f14c:	ff 75 10             	pushl  0x10(%ebp)
f010f14f:	ff 75 0c             	pushl  0xc(%ebp)
f010f152:	e8 27 ef 00 00       	call   f011e07e <tst>
f010f157:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f15a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f15f:	e9 8d 00 00 00       	jmp    f010f1f1 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f164:	e8 df f9 ff ff       	call   f010eb48 <sys_get_heap_strategy>
f010f169:	e9 83 00 00 00       	jmp    f010f1f1 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f16e:	83 ec 0c             	sub    $0xc,%esp
f010f171:	ff 75 0c             	pushl  0xc(%ebp)
f010f174:	e8 d9 f9 ff ff       	call   f010eb52 <sys_set_uheap_strategy>
f010f179:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f17c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f181:	eb 6e                	jmp    f010f1f1 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f183:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f186:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f189:	8b 55 10             	mov    0x10(%ebp),%edx
f010f18c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f18f:	53                   	push   %ebx
f010f190:	51                   	push   %ecx
f010f191:	52                   	push   %edx
f010f192:	50                   	push   %eax
f010f193:	e8 b3 1d 00 00       	call   f0110f4b <sys_check_LRU_lists>
f010f198:	83 c4 10             	add    $0x10,%esp
f010f19b:	eb 54                	jmp    f010f1f1 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f19d:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1a3:	83 ec 08             	sub    $0x8,%esp
f010f1a6:	52                   	push   %edx
f010f1a7:	50                   	push   %eax
f010f1a8:	e8 60 1f 00 00       	call   f011110d <sys_check_LRU_lists_free>
f010f1ad:	83 c4 10             	add    $0x10,%esp
f010f1b0:	eb 3f                	jmp    f010f1f1 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f1b2:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f1b5:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1bb:	51                   	push   %ecx
f010f1bc:	ff 75 14             	pushl  0x14(%ebp)
f010f1bf:	52                   	push   %edx
f010f1c0:	50                   	push   %eax
f010f1c1:	e8 d4 20 00 00       	call   f011129a <sys_check_WS_list>
f010f1c6:	83 c4 10             	add    $0x10,%esp
f010f1c9:	eb 26                	jmp    f010f1f1 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f1cb:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1d1:	83 ec 08             	sub    $0x8,%esp
f010f1d4:	52                   	push   %edx
f010f1d5:	50                   	push   %eax
f010f1d6:	e8 a8 f1 00 00       	call   f011e383 <sys_utilities>
f010f1db:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1de:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1e3:	eb 0c                	jmp    f010f1f1 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f1e5:	b8 03 00 00 00       	mov    $0x3,%eax
f010f1ea:	eb 05                	jmp    f010f1f1 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f1ec:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f1f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f1f4:	5b                   	pop    %ebx
f010f1f5:	5e                   	pop    %esi
f010f1f6:	5d                   	pop    %ebp
f010f1f7:	c3                   	ret    

f010f1f8 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f1f8:	55                   	push   %ebp
f010f1f9:	89 e5                	mov    %esp,%ebp
f010f1fb:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f1fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f201:	8b 00                	mov    (%eax),%eax
f010f203:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f206:	8b 45 10             	mov    0x10(%ebp),%eax
f010f209:	8b 00                	mov    (%eax),%eax
f010f20b:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f20e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f215:	e9 ca 00 00 00       	jmp    f010f2e4 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f21a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f21d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f220:	01 d0                	add    %edx,%eax
f010f222:	89 c2                	mov    %eax,%edx
f010f224:	c1 ea 1f             	shr    $0x1f,%edx
f010f227:	01 d0                	add    %edx,%eax
f010f229:	d1 f8                	sar    %eax
f010f22b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f22e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f231:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f234:	eb 03                	jmp    f010f239 <stab_binsearch+0x41>
			m--;
f010f236:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f239:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f23c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f23f:	7c 1e                	jl     f010f25f <stab_binsearch+0x67>
f010f241:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f244:	89 d0                	mov    %edx,%eax
f010f246:	01 c0                	add    %eax,%eax
f010f248:	01 d0                	add    %edx,%eax
f010f24a:	c1 e0 02             	shl    $0x2,%eax
f010f24d:	89 c2                	mov    %eax,%edx
f010f24f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f252:	01 d0                	add    %edx,%eax
f010f254:	8a 40 04             	mov    0x4(%eax),%al
f010f257:	0f b6 c0             	movzbl %al,%eax
f010f25a:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f25d:	75 d7                	jne    f010f236 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f25f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f262:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f265:	7d 09                	jge    f010f270 <stab_binsearch+0x78>
			l = true_m + 1;
f010f267:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f26a:	40                   	inc    %eax
f010f26b:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f26e:	eb 74                	jmp    f010f2e4 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f270:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f277:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f27a:	89 d0                	mov    %edx,%eax
f010f27c:	01 c0                	add    %eax,%eax
f010f27e:	01 d0                	add    %edx,%eax
f010f280:	c1 e0 02             	shl    $0x2,%eax
f010f283:	89 c2                	mov    %eax,%edx
f010f285:	8b 45 08             	mov    0x8(%ebp),%eax
f010f288:	01 d0                	add    %edx,%eax
f010f28a:	8b 40 08             	mov    0x8(%eax),%eax
f010f28d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f290:	73 11                	jae    f010f2a3 <stab_binsearch+0xab>
			*region_left = m;
f010f292:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f295:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f298:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f29a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f29d:	40                   	inc    %eax
f010f29e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f2a1:	eb 41                	jmp    f010f2e4 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f2a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f2a6:	89 d0                	mov    %edx,%eax
f010f2a8:	01 c0                	add    %eax,%eax
f010f2aa:	01 d0                	add    %edx,%eax
f010f2ac:	c1 e0 02             	shl    $0x2,%eax
f010f2af:	89 c2                	mov    %eax,%edx
f010f2b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2b4:	01 d0                	add    %edx,%eax
f010f2b6:	8b 40 08             	mov    0x8(%eax),%eax
f010f2b9:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f2bc:	76 14                	jbe    f010f2d2 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f2be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2c1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f2c4:	8b 45 10             	mov    0x10(%ebp),%eax
f010f2c7:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f2c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2cc:	48                   	dec    %eax
f010f2cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f2d0:	eb 12                	jmp    f010f2e4 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f2d8:	89 10                	mov    %edx,(%eax)
			l = m;
f010f2da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f2e0:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f2e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f2e7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f2ea:	0f 8e 2a ff ff ff    	jle    f010f21a <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f2f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f2f4:	75 0f                	jne    f010f305 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f2f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f9:	8b 00                	mov    (%eax),%eax
f010f2fb:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f2fe:	8b 45 10             	mov    0x10(%ebp),%eax
f010f301:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f303:	eb 3d                	jmp    f010f342 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f305:	8b 45 10             	mov    0x10(%ebp),%eax
f010f308:	8b 00                	mov    (%eax),%eax
f010f30a:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f30d:	eb 03                	jmp    f010f312 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f30f:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f312:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f315:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f317:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f31a:	7d 1e                	jge    f010f33a <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f31c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f31f:	89 d0                	mov    %edx,%eax
f010f321:	01 c0                	add    %eax,%eax
f010f323:	01 d0                	add    %edx,%eax
f010f325:	c1 e0 02             	shl    $0x2,%eax
f010f328:	89 c2                	mov    %eax,%edx
f010f32a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f32d:	01 d0                	add    %edx,%eax
f010f32f:	8a 40 04             	mov    0x4(%eax),%al
f010f332:	0f b6 c0             	movzbl %al,%eax
f010f335:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f338:	75 d5                	jne    f010f30f <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f33a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f33d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f340:	89 10                	mov    %edx,(%eax)
	}
}
f010f342:	90                   	nop
f010f343:	c9                   	leave  
f010f344:	c3                   	ret    

f010f345 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f345:	55                   	push   %ebp
f010f346:	89 e5                	mov    %esp,%ebp
f010f348:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f34b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f34e:	c7 00 a8 78 12 f0    	movl   $0xf01278a8,(%eax)
	info->eip_line = 0;
f010f354:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f357:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f35e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f361:	c7 40 08 a8 78 12 f0 	movl   $0xf01278a8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f368:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f36b:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f372:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f375:	8b 55 08             	mov    0x8(%ebp),%edx
f010f378:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f37b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f37e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f385:	8b 45 08             	mov    0x8(%ebp),%eax
f010f388:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f38d:	76 1e                	jbe    f010f3ad <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f38f:	c7 45 f4 3c 16 13 f0 	movl   $0xf013163c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f396:	c7 45 f0 b4 4f 16 f0 	movl   $0xf0164fb4,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f39d:	c7 45 ec b5 4f 16 f0 	movl   $0xf0164fb5,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f3a4:	c7 45 e8 c3 6b 17 f0 	movl   $0xf0176bc3,-0x18(%ebp)
f010f3ab:	eb 2a                	jmp    f010f3d7 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f3ad:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f3b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3b7:	8b 00                	mov    (%eax),%eax
f010f3b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f3bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3bf:	8b 40 04             	mov    0x4(%eax),%eax
f010f3c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f3c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3c8:	8b 40 08             	mov    0x8(%eax),%eax
f010f3cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f3ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3d1:	8b 40 0c             	mov    0xc(%eax),%eax
f010f3d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f3d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f3da:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f3dd:	76 0a                	jbe    f010f3e9 <debuginfo_eip+0xa4>
f010f3df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f3e2:	48                   	dec    %eax
f010f3e3:	8a 00                	mov    (%eax),%al
f010f3e5:	84 c0                	test   %al,%al
f010f3e7:	74 0a                	je     f010f3f3 <debuginfo_eip+0xae>
		return -1;
f010f3e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f3ee:	e9 01 02 00 00       	jmp    f010f5f4 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f3f3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f3fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f3fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f400:	29 c2                	sub    %eax,%edx
f010f402:	89 d0                	mov    %edx,%eax
f010f404:	c1 f8 02             	sar    $0x2,%eax
f010f407:	89 c2                	mov    %eax,%edx
f010f409:	89 d0                	mov    %edx,%eax
f010f40b:	c1 e0 02             	shl    $0x2,%eax
f010f40e:	01 d0                	add    %edx,%eax
f010f410:	c1 e0 02             	shl    $0x2,%eax
f010f413:	01 d0                	add    %edx,%eax
f010f415:	c1 e0 02             	shl    $0x2,%eax
f010f418:	01 d0                	add    %edx,%eax
f010f41a:	89 c1                	mov    %eax,%ecx
f010f41c:	c1 e1 08             	shl    $0x8,%ecx
f010f41f:	01 c8                	add    %ecx,%eax
f010f421:	89 c1                	mov    %eax,%ecx
f010f423:	c1 e1 10             	shl    $0x10,%ecx
f010f426:	01 c8                	add    %ecx,%eax
f010f428:	01 c0                	add    %eax,%eax
f010f42a:	01 d0                	add    %edx,%eax
f010f42c:	48                   	dec    %eax
f010f42d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f430:	ff 75 08             	pushl  0x8(%ebp)
f010f433:	6a 64                	push   $0x64
f010f435:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f438:	50                   	push   %eax
f010f439:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f43c:	50                   	push   %eax
f010f43d:	ff 75 f4             	pushl  -0xc(%ebp)
f010f440:	e8 b3 fd ff ff       	call   f010f1f8 <stab_binsearch>
f010f445:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f448:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f44b:	85 c0                	test   %eax,%eax
f010f44d:	75 0a                	jne    f010f459 <debuginfo_eip+0x114>
		return -1;
f010f44f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f454:	e9 9b 01 00 00       	jmp    f010f5f4 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f459:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f45c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f45f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f462:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f465:	ff 75 08             	pushl  0x8(%ebp)
f010f468:	6a 24                	push   $0x24
f010f46a:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f46d:	50                   	push   %eax
f010f46e:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f471:	50                   	push   %eax
f010f472:	ff 75 f4             	pushl  -0xc(%ebp)
f010f475:	e8 7e fd ff ff       	call   f010f1f8 <stab_binsearch>
f010f47a:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f47d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f480:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f483:	39 c2                	cmp    %eax,%edx
f010f485:	0f 8f 86 00 00 00    	jg     f010f511 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f48b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f48e:	89 c2                	mov    %eax,%edx
f010f490:	89 d0                	mov    %edx,%eax
f010f492:	01 c0                	add    %eax,%eax
f010f494:	01 d0                	add    %edx,%eax
f010f496:	c1 e0 02             	shl    $0x2,%eax
f010f499:	89 c2                	mov    %eax,%edx
f010f49b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f49e:	01 d0                	add    %edx,%eax
f010f4a0:	8b 00                	mov    (%eax),%eax
f010f4a2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f4a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f4a8:	29 d1                	sub    %edx,%ecx
f010f4aa:	89 ca                	mov    %ecx,%edx
f010f4ac:	39 d0                	cmp    %edx,%eax
f010f4ae:	73 22                	jae    f010f4d2 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f4b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f4b3:	89 c2                	mov    %eax,%edx
f010f4b5:	89 d0                	mov    %edx,%eax
f010f4b7:	01 c0                	add    %eax,%eax
f010f4b9:	01 d0                	add    %edx,%eax
f010f4bb:	c1 e0 02             	shl    $0x2,%eax
f010f4be:	89 c2                	mov    %eax,%edx
f010f4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4c3:	01 d0                	add    %edx,%eax
f010f4c5:	8b 10                	mov    (%eax),%edx
f010f4c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f4ca:	01 c2                	add    %eax,%edx
f010f4cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4cf:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f4d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f4d5:	89 c2                	mov    %eax,%edx
f010f4d7:	89 d0                	mov    %edx,%eax
f010f4d9:	01 c0                	add    %eax,%eax
f010f4db:	01 d0                	add    %edx,%eax
f010f4dd:	c1 e0 02             	shl    $0x2,%eax
f010f4e0:	89 c2                	mov    %eax,%edx
f010f4e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4e5:	01 d0                	add    %edx,%eax
f010f4e7:	8b 50 08             	mov    0x8(%eax),%edx
f010f4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ed:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f4f0:	8b 55 08             	mov    0x8(%ebp),%edx
f010f4f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f6:	8b 40 10             	mov    0x10(%eax),%eax
f010f4f9:	29 c2                	sub    %eax,%edx
f010f4fb:	89 d0                	mov    %edx,%eax
f010f4fd:	c1 f8 02             	sar    $0x2,%eax
f010f500:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f503:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f506:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f509:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f50c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f50f:	eb 15                	jmp    f010f526 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f511:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f514:	8b 55 08             	mov    0x8(%ebp),%edx
f010f517:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f51a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f51d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f520:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f523:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f526:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f529:	8b 40 08             	mov    0x8(%eax),%eax
f010f52c:	83 ec 08             	sub    $0x8,%esp
f010f52f:	6a 3a                	push   $0x3a
f010f531:	50                   	push   %eax
f010f532:	e8 0d 09 01 00       	call   f011fe44 <strfind>
f010f537:	83 c4 10             	add    $0x10,%esp
f010f53a:	89 c2                	mov    %eax,%edx
f010f53c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f53f:	8b 40 08             	mov    0x8(%eax),%eax
f010f542:	29 c2                	sub    %eax,%edx
f010f544:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f547:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f54a:	eb 03                	jmp    f010f54f <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f54c:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f54f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f552:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f555:	7c 4e                	jl     f010f5a5 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f557:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f55a:	89 d0                	mov    %edx,%eax
f010f55c:	01 c0                	add    %eax,%eax
f010f55e:	01 d0                	add    %edx,%eax
f010f560:	c1 e0 02             	shl    $0x2,%eax
f010f563:	89 c2                	mov    %eax,%edx
f010f565:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f568:	01 d0                	add    %edx,%eax
f010f56a:	8a 40 04             	mov    0x4(%eax),%al
f010f56d:	3c 84                	cmp    $0x84,%al
f010f56f:	74 34                	je     f010f5a5 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f571:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f574:	89 d0                	mov    %edx,%eax
f010f576:	01 c0                	add    %eax,%eax
f010f578:	01 d0                	add    %edx,%eax
f010f57a:	c1 e0 02             	shl    $0x2,%eax
f010f57d:	89 c2                	mov    %eax,%edx
f010f57f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f582:	01 d0                	add    %edx,%eax
f010f584:	8a 40 04             	mov    0x4(%eax),%al
f010f587:	3c 64                	cmp    $0x64,%al
f010f589:	75 c1                	jne    f010f54c <debuginfo_eip+0x207>
f010f58b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f58e:	89 d0                	mov    %edx,%eax
f010f590:	01 c0                	add    %eax,%eax
f010f592:	01 d0                	add    %edx,%eax
f010f594:	c1 e0 02             	shl    $0x2,%eax
f010f597:	89 c2                	mov    %eax,%edx
f010f599:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f59c:	01 d0                	add    %edx,%eax
f010f59e:	8b 40 08             	mov    0x8(%eax),%eax
f010f5a1:	85 c0                	test   %eax,%eax
f010f5a3:	74 a7                	je     f010f54c <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f5a5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5a8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f5ab:	7c 42                	jl     f010f5ef <debuginfo_eip+0x2aa>
f010f5ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f5b0:	89 d0                	mov    %edx,%eax
f010f5b2:	01 c0                	add    %eax,%eax
f010f5b4:	01 d0                	add    %edx,%eax
f010f5b6:	c1 e0 02             	shl    $0x2,%eax
f010f5b9:	89 c2                	mov    %eax,%edx
f010f5bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5be:	01 d0                	add    %edx,%eax
f010f5c0:	8b 00                	mov    (%eax),%eax
f010f5c2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f5c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f5c8:	29 d1                	sub    %edx,%ecx
f010f5ca:	89 ca                	mov    %ecx,%edx
f010f5cc:	39 d0                	cmp    %edx,%eax
f010f5ce:	73 1f                	jae    f010f5ef <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f5d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f5d3:	89 d0                	mov    %edx,%eax
f010f5d5:	01 c0                	add    %eax,%eax
f010f5d7:	01 d0                	add    %edx,%eax
f010f5d9:	c1 e0 02             	shl    $0x2,%eax
f010f5dc:	89 c2                	mov    %eax,%edx
f010f5de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5e1:	01 d0                	add    %edx,%eax
f010f5e3:	8b 10                	mov    (%eax),%edx
f010f5e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f5e8:	01 c2                	add    %eax,%edx
f010f5ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5ed:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f5ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f5f4:	c9                   	leave  
f010f5f5:	c3                   	ret    

f010f5f6 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f5f6:	55                   	push   %ebp
f010f5f7:	89 e5                	mov    %esp,%ebp
f010f5f9:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f5fc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f600:	74 1c                	je     f010f61e <setPageReplacmentAlgorithmLRU+0x28>
f010f602:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f606:	74 16                	je     f010f61e <setPageReplacmentAlgorithmLRU+0x28>
f010f608:	68 b4 78 12 f0       	push   $0xf01278b4
f010f60d:	68 fe 78 12 f0       	push   $0xf01278fe
f010f612:	6a 1a                	push   $0x1a
f010f614:	68 13 79 12 f0       	push   $0xf0127913
f010f619:	e8 1b 0d ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f61e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f621:	a3 50 2d 6c f0       	mov    %eax,0xf06c2d50
}
f010f626:	90                   	nop
f010f627:	c9                   	leave  
f010f628:	c3                   	ret    

f010f629 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f629:	55                   	push   %ebp
f010f62a:	89 e5                	mov    %esp,%ebp
f010f62c:	c7 05 50 2d 6c f0 03 	movl   $0x3,0xf06c2d50
f010f633:	00 00 00 
f010f636:	90                   	nop
f010f637:	5d                   	pop    %ebp
f010f638:	c3                   	ret    

f010f639 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f639:	55                   	push   %ebp
f010f63a:	89 e5                	mov    %esp,%ebp
f010f63c:	c7 05 50 2d 6c f0 04 	movl   $0x4,0xf06c2d50
f010f643:	00 00 00 
f010f646:	90                   	nop
f010f647:	5d                   	pop    %ebp
f010f648:	c3                   	ret    

f010f649 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f649:	55                   	push   %ebp
f010f64a:	89 e5                	mov    %esp,%ebp
f010f64c:	c7 05 50 2d 6c f0 05 	movl   $0x5,0xf06c2d50
f010f653:	00 00 00 
f010f656:	90                   	nop
f010f657:	5d                   	pop    %ebp
f010f658:	c3                   	ret    

f010f659 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f659:	55                   	push   %ebp
f010f65a:	89 e5                	mov    %esp,%ebp
f010f65c:	c7 05 50 2d 6c f0 07 	movl   $0x7,0xf06c2d50
f010f663:	00 00 00 
f010f666:	90                   	nop
f010f667:	5d                   	pop    %ebp
f010f668:	c3                   	ret    

f010f669 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f669:	55                   	push   %ebp
f010f66a:	89 e5                	mov    %esp,%ebp
f010f66c:	c7 05 50 2d 6c f0 06 	movl   $0x6,0xf06c2d50
f010f673:	00 00 00 
f010f676:	8b 45 08             	mov    0x8(%ebp),%eax
f010f679:	a3 74 16 6c f0       	mov    %eax,0xf06c1674
f010f67e:	90                   	nop
f010f67f:	5d                   	pop    %ebp
f010f680:	c3                   	ret    

f010f681 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f681:	55                   	push   %ebp
f010f682:	89 e5                	mov    %esp,%ebp
f010f684:	8b 15 50 2d 6c f0    	mov    0xf06c2d50,%edx
f010f68a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f68d:	39 c2                	cmp    %eax,%edx
f010f68f:	0f 94 c0             	sete   %al
f010f692:	0f b6 c0             	movzbl %al,%eax
f010f695:	5d                   	pop    %ebp
f010f696:	c3                   	ret    

f010f697 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f697:	55                   	push   %ebp
f010f698:	89 e5                	mov    %esp,%ebp
f010f69a:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f69f:	83 f8 03             	cmp    $0x3,%eax
f010f6a2:	75 07                	jne    f010f6ab <isPageReplacmentAlgorithmCLOCK+0x14>
f010f6a4:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6a9:	eb 05                	jmp    f010f6b0 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f6ab:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6b0:	5d                   	pop    %ebp
f010f6b1:	c3                   	ret    

f010f6b2 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f6b2:	55                   	push   %ebp
f010f6b3:	89 e5                	mov    %esp,%ebp
f010f6b5:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f6ba:	83 f8 04             	cmp    $0x4,%eax
f010f6bd:	75 07                	jne    f010f6c6 <isPageReplacmentAlgorithmFIFO+0x14>
f010f6bf:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6c4:	eb 05                	jmp    f010f6cb <isPageReplacmentAlgorithmFIFO+0x19>
f010f6c6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6cb:	5d                   	pop    %ebp
f010f6cc:	c3                   	ret    

f010f6cd <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f6cd:	55                   	push   %ebp
f010f6ce:	89 e5                	mov    %esp,%ebp
f010f6d0:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f6d5:	83 f8 05             	cmp    $0x5,%eax
f010f6d8:	75 07                	jne    f010f6e1 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f6da:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6df:	eb 05                	jmp    f010f6e6 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f6e1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6e6:	5d                   	pop    %ebp
f010f6e7:	c3                   	ret    

f010f6e8 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f6e8:	55                   	push   %ebp
f010f6e9:	89 e5                	mov    %esp,%ebp
f010f6eb:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f6f0:	83 f8 07             	cmp    $0x7,%eax
f010f6f3:	75 07                	jne    f010f6fc <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f6f5:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6fa:	eb 05                	jmp    f010f701 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f6fc:	b8 00 00 00 00       	mov    $0x0,%eax
f010f701:	5d                   	pop    %ebp
f010f702:	c3                   	ret    

f010f703 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f703:	55                   	push   %ebp
f010f704:	89 e5                	mov    %esp,%ebp
f010f706:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f70b:	83 f8 06             	cmp    $0x6,%eax
f010f70e:	75 07                	jne    f010f717 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f710:	b8 01 00 00 00       	mov    $0x1,%eax
f010f715:	eb 05                	jmp    f010f71c <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f717:	b8 00 00 00 00       	mov    $0x0,%eax
f010f71c:	5d                   	pop    %ebp
f010f71d:	c3                   	ret    

f010f71e <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f71e:	55                   	push   %ebp
f010f71f:	89 e5                	mov    %esp,%ebp
f010f721:	8b 45 08             	mov    0x8(%ebp),%eax
f010f724:	a3 d8 1a 6c f0       	mov    %eax,0xf06c1ad8
f010f729:	90                   	nop
f010f72a:	5d                   	pop    %ebp
f010f72b:	c3                   	ret    

f010f72c <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f72c:	55                   	push   %ebp
f010f72d:	89 e5                	mov    %esp,%ebp
f010f72f:	a1 d8 1a 6c f0       	mov    0xf06c1ad8,%eax
f010f734:	5d                   	pop    %ebp
f010f735:	c3                   	ret    

f010f736 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f736:	55                   	push   %ebp
f010f737:	89 e5                	mov    %esp,%ebp
f010f739:	8b 45 08             	mov    0x8(%ebp),%eax
f010f73c:	a3 d4 2d 6c f0       	mov    %eax,0xf06c2dd4
f010f741:	90                   	nop
f010f742:	5d                   	pop    %ebp
f010f743:	c3                   	ret    

f010f744 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f744:	55                   	push   %ebp
f010f745:	89 e5                	mov    %esp,%ebp
f010f747:	a1 d4 2d 6c f0       	mov    0xf06c2dd4,%eax
f010f74c:	5d                   	pop    %ebp
f010f74d:	c3                   	ret    

f010f74e <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f74e:	55                   	push   %ebp
f010f74f:	89 e5                	mov    %esp,%ebp
f010f751:	8b 45 08             	mov    0x8(%ebp),%eax
f010f754:	a3 70 2e 6c f0       	mov    %eax,0xf06c2e70
f010f759:	90                   	nop
f010f75a:	5d                   	pop    %ebp
f010f75b:	c3                   	ret    

f010f75c <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f75c:	55                   	push   %ebp
f010f75d:	89 e5                	mov    %esp,%ebp
f010f75f:	a1 70 2e 6c f0       	mov    0xf06c2e70,%eax
f010f764:	5d                   	pop    %ebp
f010f765:	c3                   	ret    

f010f766 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f766:	55                   	push   %ebp
f010f767:	89 e5                	mov    %esp,%ebp
f010f769:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f76c:	0f 20 d0             	mov    %cr2,%eax
f010f76f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f772:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f775:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f778:	e8 c9 c2 ff ff       	call   f010ba46 <get_cpu_proc>
f010f77d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f780:	a1 6c 93 69 f0       	mov    0xf069936c,%eax
f010f785:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f788:	75 50                	jne    f010f7da <fault_handler+0x74>
f010f78a:	a1 78 93 69 f0       	mov    0xf0699378,%eax
f010f78f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f792:	75 46                	jne    f010f7da <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f794:	a0 74 93 69 f0       	mov    0xf0699374,%al
f010f799:	40                   	inc    %eax
f010f79a:	a2 74 93 69 f0       	mov    %al,0xf0699374
		if (num_repeated_fault == 3)
f010f79f:	a0 74 93 69 f0       	mov    0xf0699374,%al
f010f7a4:	3c 03                	cmp    $0x3,%al
f010f7a6:	75 4d                	jne    f010f7f5 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f7a8:	83 ec 0c             	sub    $0xc,%esp
f010f7ab:	ff 75 08             	pushl  0x8(%ebp)
f010f7ae:	e8 49 e9 ff ff       	call   f010e0fc <print_trapframe>
f010f7b3:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f7b6:	8b 15 68 93 69 f0    	mov    0xf0699368,%edx
f010f7bc:	a1 70 93 69 f0       	mov    0xf0699370,%eax
f010f7c1:	83 ec 08             	sub    $0x8,%esp
f010f7c4:	ff 75 ec             	pushl  -0x14(%ebp)
f010f7c7:	52                   	push   %edx
f010f7c8:	50                   	push   %eax
f010f7c9:	68 30 79 12 f0       	push   $0xf0127930
f010f7ce:	6a 58                	push   $0x58
f010f7d0:	68 13 79 12 f0       	push   $0xf0127913
f010f7d5:	e8 5f 0b ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f7da:	a1 6c 93 69 f0       	mov    0xf069936c,%eax
f010f7df:	a3 70 93 69 f0       	mov    %eax,0xf0699370
		before_last_eip = last_eip;
f010f7e4:	a1 64 93 69 f0       	mov    0xf0699364,%eax
f010f7e9:	a3 68 93 69 f0       	mov    %eax,0xf0699368
		num_repeated_fault = 0;
f010f7ee:	c6 05 74 93 69 f0 00 	movb   $0x0,0xf0699374
	}
	last_eip = (uint32)tf->tf_eip;
f010f7f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7f8:	8b 40 30             	mov    0x30(%eax),%eax
f010f7fb:	a3 64 93 69 f0       	mov    %eax,0xf0699364
	last_fault_va = fault_va ;
f010f800:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f803:	a3 6c 93 69 f0       	mov    %eax,0xf069936c
	last_faulted_env = cur_env;
f010f808:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f80b:	a3 78 93 69 f0       	mov    %eax,0xf0699378
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f810:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f817:	8b 45 08             	mov    0x8(%ebp),%eax
f010f81a:	8b 40 34             	mov    0x34(%eax),%eax
f010f81d:	0f b7 c0             	movzwl %ax,%eax
f010f820:	83 e0 03             	and    $0x3,%eax
f010f823:	83 f8 03             	cmp    $0x3,%eax
f010f826:	75 07                	jne    f010f82f <fault_handler+0xc9>
		userTrap = 1;
f010f828:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f82f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f833:	0f 85 c2 00 00 00    	jne    f010f8fb <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f839:	e8 ce 78 ff ff       	call   f010710c <mycpu>
f010f83e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f841:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f845:	74 2f                	je     f010f876 <fault_handler+0x110>
f010f847:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f84a:	8b 40 70             	mov    0x70(%eax),%eax
f010f84d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f850:	77 24                	ja     f010f876 <fault_handler+0x110>
f010f852:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f855:	8b 40 70             	mov    0x70(%eax),%eax
f010f858:	05 00 10 00 00       	add    $0x1000,%eax
f010f85d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f860:	76 14                	jbe    f010f876 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f862:	83 ec 04             	sub    $0x4,%esp
f010f865:	68 a0 79 12 f0       	push   $0xf01279a0
f010f86a:	6a 6f                	push   $0x6f
f010f86c:	68 13 79 12 f0       	push   $0xf0127913
f010f871:	e8 c3 0a ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f876:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f879:	8b 40 08             	mov    0x8(%eax),%eax
f010f87c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f87f:	77 5d                	ja     f010f8de <fault_handler+0x178>
f010f881:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f884:	8b 40 08             	mov    0x8(%eax),%eax
f010f887:	05 00 10 00 00       	add    $0x1000,%eax
f010f88c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f88f:	76 4d                	jbe    f010f8de <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f891:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f894:	ba c0 17 6c f0       	mov    $0xf06c17c0,%edx
f010f899:	29 d0                	sub    %edx,%eax
f010f89b:	c1 f8 03             	sar    $0x3,%eax
f010f89e:	89 c2                	mov    %eax,%edx
f010f8a0:	89 d0                	mov    %edx,%eax
f010f8a2:	c1 e0 02             	shl    $0x2,%eax
f010f8a5:	01 d0                	add    %edx,%eax
f010f8a7:	01 c0                	add    %eax,%eax
f010f8a9:	01 d0                	add    %edx,%eax
f010f8ab:	c1 e0 03             	shl    $0x3,%eax
f010f8ae:	01 d0                	add    %edx,%eax
f010f8b0:	89 c1                	mov    %eax,%ecx
f010f8b2:	c1 e1 0b             	shl    $0xb,%ecx
f010f8b5:	01 c8                	add    %ecx,%eax
f010f8b7:	c1 e0 05             	shl    $0x5,%eax
f010f8ba:	01 d0                	add    %edx,%eax
f010f8bc:	c1 e0 02             	shl    $0x2,%eax
f010f8bf:	01 d0                	add    %edx,%eax
f010f8c1:	01 c0                	add    %eax,%eax
f010f8c3:	01 d0                	add    %edx,%eax
f010f8c5:	c1 e0 03             	shl    $0x3,%eax
f010f8c8:	01 d0                	add    %edx,%eax
f010f8ca:	f7 d8                	neg    %eax
f010f8cc:	50                   	push   %eax
f010f8cd:	68 c8 79 12 f0       	push   $0xf01279c8
f010f8d2:	6a 71                	push   $0x71
f010f8d4:	68 13 79 12 f0       	push   $0xf0127913
f010f8d9:	e8 5b 0a ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f8de:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f8e5:	76 3a                	jbe    f010f921 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f8e7:	83 ec 04             	sub    $0x4,%esp
f010f8ea:	68 fc 79 12 f0       	push   $0xf01279fc
f010f8ef:	6a 74                	push   $0x74
f010f8f1:	68 13 79 12 f0       	push   $0xf0127913
f010f8f6:	e8 3e 0a ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f8fb:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f902:	76 1d                	jbe    f010f921 <fault_handler+0x1bb>
f010f904:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f90b:	77 14                	ja     f010f921 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f90d:	83 ec 04             	sub    $0x4,%esp
f010f910:	68 20 7a 12 f0       	push   $0xf0127a20
f010f915:	6a 7c                	push   $0x7c
f010f917:	68 13 79 12 f0       	push   $0xf0127913
f010f91c:	e8 18 0a ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f921:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f924:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f927:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f92b:	75 25                	jne    f010f952 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f92d:	83 ec 0c             	sub    $0xc,%esp
f010f930:	ff 75 08             	pushl  0x8(%ebp)
f010f933:	e8 c4 e7 ff ff       	call   f010e0fc <print_trapframe>
f010f938:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f93b:	83 ec 04             	sub    $0x4,%esp
f010f93e:	68 41 7a 12 f0       	push   $0xf0127a41
f010f943:	68 85 00 00 00       	push   $0x85
f010f948:	68 13 79 12 f0       	push   $0xf0127913
f010f94d:	e8 e7 09 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f952:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f955:	8b 40 64             	mov    0x64(%eax),%eax
f010f958:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f95b:	c1 ea 16             	shr    $0x16,%edx
f010f95e:	c1 e2 02             	shl    $0x2,%edx
f010f961:	01 d0                	add    %edx,%eax
f010f963:	8b 00                	mov    (%eax),%eax
f010f965:	83 e0 01             	and    $0x1,%eax
f010f968:	85 c0                	test   %eax,%eax
f010f96a:	75 2b                	jne    f010f997 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f96c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f96f:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f975:	8d 50 01             	lea    0x1(%eax),%edx
f010f978:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f97b:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f981:	83 ec 08             	sub    $0x8,%esp
f010f984:	ff 75 ec             	pushl  -0x14(%ebp)
f010f987:	ff 75 e0             	pushl  -0x20(%ebp)
f010f98a:	e8 1e 01 00 00       	call   f010faad <table_fault_handler>
f010f98f:	83 c4 10             	add    $0x10,%esp
f010f992:	e9 07 01 00 00       	jmp    f010fa9e <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f997:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f99b:	0f 84 82 00 00 00    	je     f010fa23 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f9a1:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f9a8:	76 07                	jbe    f010f9b1 <fault_handler+0x24b>
			{
				env_exit();
f010f9aa:	e8 55 c0 ff ff       	call   f010ba04 <env_exit>
f010f9af:	eb 72                	jmp    f010fa23 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f9b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9b4:	8b 40 64             	mov    0x64(%eax),%eax
f010f9b7:	83 ec 08             	sub    $0x8,%esp
f010f9ba:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9bd:	50                   	push   %eax
f010f9be:	e8 87 a3 ff ff       	call   f0109d4a <pt_get_page_permissions>
f010f9c3:	83 c4 10             	add    $0x10,%esp
f010f9c6:	25 00 02 00 00       	and    $0x200,%eax
f010f9cb:	85 c0                	test   %eax,%eax
f010f9cd:	75 17                	jne    f010f9e6 <fault_handler+0x280>
f010f9cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f9d2:	85 c0                	test   %eax,%eax
f010f9d4:	79 10                	jns    f010f9e6 <fault_handler+0x280>
f010f9d6:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f9dd:	77 07                	ja     f010f9e6 <fault_handler+0x280>
			{
				env_exit();
f010f9df:	e8 20 c0 ff ff       	call   f010ba04 <env_exit>
f010f9e4:	eb 3d                	jmp    f010fa23 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010f9e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9e9:	8b 40 64             	mov    0x64(%eax),%eax
f010f9ec:	83 ec 08             	sub    $0x8,%esp
f010f9ef:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9f2:	50                   	push   %eax
f010f9f3:	e8 52 a3 ff ff       	call   f0109d4a <pt_get_page_permissions>
f010f9f8:	83 c4 10             	add    $0x10,%esp
f010f9fb:	83 e0 01             	and    $0x1,%eax
f010f9fe:	85 c0                	test   %eax,%eax
f010fa00:	74 21                	je     f010fa23 <fault_handler+0x2bd>
f010fa02:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa05:	8b 40 64             	mov    0x64(%eax),%eax
f010fa08:	83 ec 08             	sub    $0x8,%esp
f010fa0b:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa0e:	50                   	push   %eax
f010fa0f:	e8 36 a3 ff ff       	call   f0109d4a <pt_get_page_permissions>
f010fa14:	83 c4 10             	add    $0x10,%esp
f010fa17:	83 e0 02             	and    $0x2,%eax
f010fa1a:	85 c0                	test   %eax,%eax
f010fa1c:	75 05                	jne    f010fa23 <fault_handler+0x2bd>
			{
				env_exit();
f010fa1e:	e8 e1 bf ff ff       	call   f010ba04 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fa23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa26:	8b 40 64             	mov    0x64(%eax),%eax
f010fa29:	83 ec 08             	sub    $0x8,%esp
f010fa2c:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa2f:	50                   	push   %eax
f010fa30:	e8 15 a3 ff ff       	call   f0109d4a <pt_get_page_permissions>
f010fa35:	83 c4 10             	add    $0x10,%esp
f010fa38:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fa3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fa3e:	83 e0 01             	and    $0x1,%eax
f010fa41:	85 c0                	test   %eax,%eax
f010fa43:	74 17                	je     f010fa5c <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fa45:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa48:	68 58 7a 12 f0       	push   $0xf0127a58
f010fa4d:	68 ad 00 00 00       	push   $0xad
f010fa52:	68 13 79 12 f0       	push   $0xf0127913
f010fa57:	e8 dd 08 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fa5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa5f:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010fa65:	8d 50 01             	lea    0x1(%eax),%edx
f010fa68:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa6b:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fa71:	e8 ce fc ff ff       	call   f010f744 <isBufferingEnabled>
f010fa76:	84 c0                	test   %al,%al
f010fa78:	74 13                	je     f010fa8d <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fa7a:	83 ec 08             	sub    $0x8,%esp
f010fa7d:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa80:	ff 75 e0             	pushl  -0x20(%ebp)
f010fa83:	e8 fe 01 00 00       	call   f010fc86 <__page_fault_handler_with_buffering>
f010fa88:	83 c4 10             	add    $0x10,%esp
f010fa8b:	eb 11                	jmp    f010fa9e <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fa8d:	83 ec 08             	sub    $0x8,%esp
f010fa90:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa93:	ff 75 e0             	pushl  -0x20(%ebp)
f010fa96:	e8 33 00 00 00       	call   f010face <page_fault_handler>
f010fa9b:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fa9e:	0f 20 d8             	mov    %cr3,%eax
f010faa1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010faa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010faa7:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010faaa:	90                   	nop
f010faab:	c9                   	leave  
f010faac:	c3                   	ret    

f010faad <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010faad:	55                   	push   %ebp
f010faae:	89 e5                	mov    %esp,%ebp
f010fab0:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fab3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fab6:	8b 40 64             	mov    0x64(%eax),%eax
f010fab9:	83 ec 08             	sub    $0x8,%esp
f010fabc:	ff 75 0c             	pushl  0xc(%ebp)
f010fabf:	50                   	push   %eax
f010fac0:	e8 80 8a ff ff       	call   f0108545 <create_page_table>
f010fac5:	83 c4 10             	add    $0x10,%esp
f010fac8:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010facb:	90                   	nop
f010facc:	c9                   	leave  
f010facd:	c3                   	ret    

f010face <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010face:	55                   	push   %ebp
f010facf:	89 e5                	mov    %esp,%ebp
f010fad1:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fad4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fadb:	8b 45 08             	mov    0x8(%ebp),%eax
f010fade:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fae4:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fae7:	8b 45 08             	mov    0x8(%ebp),%eax
f010faea:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010faf0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010faf3:	0f 86 74 01 00 00    	jbe    f010fc6d <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010faf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fafc:	83 ec 08             	sub    $0x8,%esp
f010faff:	50                   	push   %eax
f010fb00:	ff 75 08             	pushl  0x8(%ebp)
f010fb03:	e8 d9 49 ff ff       	call   f01044e1 <pf_read_env_page>
f010fb08:	83 c4 10             	add    $0x10,%esp
f010fb0b:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fb0e:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fb12:	75 45                	jne    f010fb59 <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fb14:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb17:	85 c0                	test   %eax,%eax
f010fb19:	79 09                	jns    f010fb24 <page_fault_handler+0x56>
f010fb1b:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fb22:	76 35                	jbe    f010fb59 <page_fault_handler+0x8b>
f010fb24:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fb2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb2e:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fb33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fb36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb39:	ba 00 00 00 00       	mov    $0x0,%edx
f010fb3e:	f7 75 e8             	divl   -0x18(%ebp)
f010fb41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb44:	29 d0                	sub    %edx,%eax
f010fb46:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fb49:	77 09                	ja     f010fb54 <page_fault_handler+0x86>
f010fb4b:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010fb52:	76 05                	jbe    f010fb59 <page_fault_handler+0x8b>
			{
				env_exit();
f010fb54:	e8 ab be ff ff       	call   f010ba04 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010fb59:	83 ec 0c             	sub    $0xc,%esp
f010fb5c:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010fb5f:	50                   	push   %eax
f010fb60:	e8 4d 86 ff ff       	call   f01081b2 <allocate_frame>
f010fb65:	83 c4 10             	add    $0x10,%esp
f010fb68:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fb6b:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fb6f:	74 34                	je     f010fba5 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fb71:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010fb74:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb77:	8b 40 64             	mov    0x64(%eax),%eax
f010fb7a:	6a 06                	push   $0x6
f010fb7c:	ff 75 0c             	pushl  0xc(%ebp)
f010fb7f:	52                   	push   %edx
f010fb80:	50                   	push   %eax
f010fb81:	e8 f9 8a ff ff       	call   f010867f <map_frame>
f010fb86:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010fb89:	83 ec 08             	sub    $0x8,%esp
f010fb8c:	ff 75 0c             	pushl  0xc(%ebp)
f010fb8f:	ff 75 08             	pushl  0x8(%ebp)
f010fb92:	e8 25 a3 ff ff       	call   f0109ebc <env_page_ws_list_create_element>
f010fb97:	83 c4 10             	add    $0x10,%esp
f010fb9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fb9d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fba1:	75 30                	jne    f010fbd3 <page_fault_handler+0x105>
f010fba3:	eb 17                	jmp    f010fbbc <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010fba5:	83 ec 04             	sub    $0x4,%esp
f010fba8:	68 9c 7a 12 f0       	push   $0xf0127a9c
f010fbad:	68 03 01 00 00       	push   $0x103
f010fbb2:	68 13 79 12 f0       	push   $0xf0127913
f010fbb7:	e8 7d 07 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fbbc:	83 ec 04             	sub    $0x4,%esp
f010fbbf:	68 b4 7a 12 f0       	push   $0xf0127ab4
f010fbc4:	68 05 01 00 00       	push   $0x105
f010fbc9:	68 13 79 12 f0       	push   $0xf0127913
f010fbce:	e8 66 07 ff ff       	call   f0100339 <_panic>
f010fbd3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbd6:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010fbdc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbdf:	89 50 14             	mov    %edx,0x14(%eax)
f010fbe2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbe5:	8b 40 14             	mov    0x14(%eax),%eax
f010fbe8:	85 c0                	test   %eax,%eax
f010fbea:	74 11                	je     f010fbfd <page_fault_handler+0x12f>
f010fbec:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbef:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fbf5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fbf8:	89 50 10             	mov    %edx,0x10(%eax)
f010fbfb:	eb 0c                	jmp    f010fc09 <page_fault_handler+0x13b>
f010fbfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc00:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc03:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fc09:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc0c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc0f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fc15:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc18:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010fc1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc22:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fc28:	8d 50 01             	lea    0x1(%eax),%edx
f010fc2b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc2e:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010fc34:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc37:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010fc3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc40:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fc46:	39 c2                	cmp    %eax,%edx
f010fc48:	75 14                	jne    f010fc5e <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fc4a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc4d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fc53:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc56:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fc5c:	eb 26                	jmp    f010fc84 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010fc5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc61:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010fc68:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fc6b:	eb 17                	jmp    f010fc84 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010fc6d:	83 ec 04             	sub    $0x4,%esp
f010fc70:	68 d8 7a 12 f0       	push   $0xf0127ad8
f010fc75:	68 15 01 00 00       	push   $0x115
f010fc7a:	68 13 79 12 f0       	push   $0xf0127913
f010fc7f:	e8 b5 06 ff ff       	call   f0100339 <_panic>
	}
}
f010fc84:	c9                   	leave  
f010fc85:	c3                   	ret    

f010fc86 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fc86:	55                   	push   %ebp
f010fc87:	89 e5                	mov    %esp,%ebp
f010fc89:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010fc8c:	83 ec 04             	sub    $0x4,%esp
f010fc8f:	68 18 7b 12 f0       	push   $0xf0127b18
f010fc94:	68 1d 01 00 00       	push   $0x11d
f010fc99:	68 13 79 12 f0       	push   $0xf0127913
f010fc9e:	e8 96 06 ff ff       	call   f0100339 <_panic>

f010fca3 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010fca3:	55                   	push   %ebp
f010fca4:	89 e5                	mov    %esp,%ebp
f010fca6:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fca9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcac:	83 c0 04             	add    $0x4,%eax
f010fcaf:	83 ec 08             	sub    $0x8,%esp
f010fcb2:	ff 75 0c             	pushl  0xc(%ebp)
f010fcb5:	50                   	push   %eax
f010fcb6:	e8 16 00 01 00       	call   f011fcd1 <strcpy>
f010fcbb:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fcbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcc1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fcc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcca:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fcd1:	90                   	nop
f010fcd2:	c9                   	leave  
f010fcd3:	c3                   	ret    

f010fcd4 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010fcd4:	55                   	push   %ebp
f010fcd5:	89 e5                	mov    %esp,%ebp
f010fcd7:	53                   	push   %ebx
f010fcd8:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010fcdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcde:	83 ec 0c             	sub    $0xc,%esp
f010fce1:	50                   	push   %eax
f010fce2:	e8 06 02 00 00       	call   f010feed <holding_spinlock>
f010fce7:	83 c4 10             	add    $0x10,%esp
f010fcea:	85 c0                	test   %eax,%eax
f010fcec:	74 18                	je     f010fd06 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fcee:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcf1:	83 c0 04             	add    $0x4,%eax
f010fcf4:	50                   	push   %eax
f010fcf5:	68 5c 7b 12 f0       	push   $0xf0127b5c
f010fcfa:	6a 1f                	push   $0x1f
f010fcfc:	68 99 7b 12 f0       	push   $0xf0127b99
f010fd01:	e8 33 06 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010fd06:	e8 c4 74 ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fd0b:	90                   	nop
f010fd0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010fd12:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fd19:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fd1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd1f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010fd22:	f0 87 02             	lock xchg %eax,(%edx)
f010fd25:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fd28:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fd2b:	85 c0                	test   %eax,%eax
f010fd2d:	75 dd                	jne    f010fd0c <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fd2f:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fd34:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fd37:	e8 d0 73 ff ff       	call   f010710c <mycpu>
f010fd3c:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fd3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd42:	83 c0 48             	add    $0x48,%eax
f010fd45:	83 ec 08             	sub    $0x8,%esp
f010fd48:	50                   	push   %eax
f010fd49:	8d 45 08             	lea    0x8(%ebp),%eax
f010fd4c:	50                   	push   %eax
f010fd4d:	e8 74 00 00 00       	call   f010fdc6 <getcallerpcs>
f010fd52:	83 c4 10             	add    $0x10,%esp

}
f010fd55:	90                   	nop
f010fd56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fd59:	c9                   	leave  
f010fd5a:	c3                   	ret    

f010fd5b <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010fd5b:	55                   	push   %ebp
f010fd5c:	89 e5                	mov    %esp,%ebp
f010fd5e:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010fd61:	83 ec 0c             	sub    $0xc,%esp
f010fd64:	ff 75 08             	pushl  0x8(%ebp)
f010fd67:	e8 81 01 00 00       	call   f010feed <holding_spinlock>
f010fd6c:	83 c4 10             	add    $0x10,%esp
f010fd6f:	85 c0                	test   %eax,%eax
f010fd71:	75 26                	jne    f010fd99 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010fd73:	83 ec 0c             	sub    $0xc,%esp
f010fd76:	ff 75 08             	pushl  0x8(%ebp)
f010fd79:	e8 08 01 00 00       	call   f010fe86 <printcallstack>
f010fd7e:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fd81:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd84:	83 c0 04             	add    $0x4,%eax
f010fd87:	50                   	push   %eax
f010fd88:	68 b0 7b 12 f0       	push   $0xf0127bb0
f010fd8d:	6a 3c                	push   $0x3c
f010fd8f:	68 99 7b 12 f0       	push   $0xf0127b99
f010fd94:	e8 a0 05 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010fd99:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd9c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fda3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fda6:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fdad:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fdb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdb5:	8b 55 08             	mov    0x8(%ebp),%edx
f010fdb8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010fdbe:	e8 5e 74 ff ff       	call   f0107221 <popcli>
}
f010fdc3:	90                   	nop
f010fdc4:	c9                   	leave  
f010fdc5:	c3                   	ret    

f010fdc6 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fdc6:	55                   	push   %ebp
f010fdc7:	89 e5                	mov    %esp,%ebp
f010fdc9:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010fdcc:	e8 75 bc ff ff       	call   f010ba46 <get_cpu_proc>
f010fdd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010fdd4:	e8 33 73 ff ff       	call   f010710c <mycpu>
f010fdd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010fddc:	8b 45 08             	mov    0x8(%ebp),%eax
f010fddf:	83 e8 08             	sub    $0x8,%eax
f010fde2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010fde5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fdec:	eb 67                	jmp    f010fe55 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fdee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fdf2:	74 67                	je     f010fe5b <getcallerpcs+0x95>
f010fdf4:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fdfb:	76 5e                	jbe    f010fe5b <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fdfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe00:	8b 40 08             	mov    0x8(%eax),%eax
f010fe03:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fe08:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe0b:	77 10                	ja     f010fe1d <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fe0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe10:	8b 40 08             	mov    0x8(%eax),%eax
f010fe13:	05 00 90 00 00       	add    $0x9000,%eax
f010fe18:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe1b:	77 3e                	ja     f010fe5b <getcallerpcs+0x95>
f010fe1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fe21:	74 10                	je     f010fe33 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010fe23:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fe26:	8b 40 70             	mov    0x70(%eax),%eax
f010fe29:	05 00 80 00 00       	add    $0x8000,%eax
f010fe2e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe31:	76 28                	jbe    f010fe5b <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010fe33:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fe3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe40:	01 c2                	add    %eax,%edx
f010fe42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe45:	8b 40 04             	mov    0x4(%eax),%eax
f010fe48:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010fe4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe4d:	8b 00                	mov    (%eax),%eax
f010fe4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010fe52:	ff 45 f0             	incl   -0x10(%ebp)
f010fe55:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fe59:	7e 93                	jle    f010fdee <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010fe5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010fe61:	eb 18                	jmp    f010fe7b <getcallerpcs+0xb5>
		pcs[i] = 0;
f010fe63:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe66:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fe6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe70:	01 d0                	add    %edx,%eax
f010fe72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010fe78:	ff 45 f0             	incl   -0x10(%ebp)
f010fe7b:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fe7f:	7e e2                	jle    f010fe63 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010fe81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010fe84:	c9                   	leave  
f010fe85:	c3                   	ret    

f010fe86 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010fe86:	55                   	push   %ebp
f010fe87:	89 e5                	mov    %esp,%ebp
f010fe89:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010fe8c:	83 ec 0c             	sub    $0xc,%esp
f010fe8f:	68 ee 7b 12 f0       	push   $0xf0127bee
f010fe94:	e8 f2 10 ff ff       	call   f0100f8b <cprintf>
f010fe99:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010fe9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe9f:	83 c0 48             	add    $0x48,%eax
f010fea2:	83 ec 08             	sub    $0x8,%esp
f010fea5:	50                   	push   %eax
f010fea6:	8d 45 08             	lea    0x8(%ebp),%eax
f010fea9:	50                   	push   %eax
f010feaa:	e8 17 ff ff ff       	call   f010fdc6 <getcallerpcs>
f010feaf:	83 c4 10             	add    $0x10,%esp
f010feb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010feb5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010febc:	eb 24                	jmp    f010fee2 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010febe:	8b 45 08             	mov    0x8(%ebp),%eax
f010fec1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fec4:	83 c2 10             	add    $0x10,%edx
f010fec7:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010fecb:	83 ec 04             	sub    $0x4,%esp
f010fece:	50                   	push   %eax
f010fecf:	ff 75 f4             	pushl  -0xc(%ebp)
f010fed2:	68 fe 7b 12 f0       	push   $0xf0127bfe
f010fed7:	e8 af 10 ff ff       	call   f0100f8b <cprintf>
f010fedc:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010fedf:	ff 45 f4             	incl   -0xc(%ebp)
f010fee2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fee5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fee8:	7c d4                	jl     f010febe <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010feea:	90                   	nop
f010feeb:	c9                   	leave  
f010feec:	c3                   	ret    

f010feed <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010feed:	55                   	push   %ebp
f010feee:	89 e5                	mov    %esp,%ebp
f010fef0:	53                   	push   %ebx
f010fef1:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010fef4:	e8 d6 72 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010fef9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fefc:	8b 00                	mov    (%eax),%eax
f010fefe:	85 c0                	test   %eax,%eax
f010ff00:	74 16                	je     f010ff18 <holding_spinlock+0x2b>
f010ff02:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff05:	8b 58 44             	mov    0x44(%eax),%ebx
f010ff08:	e8 ff 71 ff ff       	call   f010710c <mycpu>
f010ff0d:	39 c3                	cmp    %eax,%ebx
f010ff0f:	75 07                	jne    f010ff18 <holding_spinlock+0x2b>
f010ff11:	b8 01 00 00 00       	mov    $0x1,%eax
f010ff16:	eb 05                	jmp    f010ff1d <holding_spinlock+0x30>
f010ff18:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010ff20:	e8 fc 72 ff ff       	call   f0107221 <popcli>
	return r;
f010ff25:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ff28:	83 c4 14             	add    $0x14,%esp
f010ff2b:	5b                   	pop    %ebx
f010ff2c:	5d                   	pop    %ebp
f010ff2d:	c3                   	ret    

f010ff2e <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ff2e:	55                   	push   %ebp
f010ff2f:	89 e5                	mov    %esp,%ebp
f010ff31:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010ff34:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff37:	83 c0 74             	add    $0x74,%eax
f010ff3a:	83 ec 08             	sub    $0x8,%esp
f010ff3d:	68 0d 7c 12 f0       	push   $0xf0127c0d
f010ff42:	50                   	push   %eax
f010ff43:	e8 4c 01 00 00       	call   f0110094 <init_channel>
f010ff48:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ff4b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff4e:	83 c0 04             	add    $0x4,%eax
f010ff51:	83 ec 08             	sub    $0x8,%esp
f010ff54:	68 20 7c 12 f0       	push   $0xf0127c20
f010ff59:	50                   	push   %eax
f010ff5a:	e8 44 fd ff ff       	call   f010fca3 <init_spinlock>
f010ff5f:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ff62:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff65:	05 c4 00 00 00       	add    $0xc4,%eax
f010ff6a:	83 ec 08             	sub    $0x8,%esp
f010ff6d:	ff 75 0c             	pushl  0xc(%ebp)
f010ff70:	50                   	push   %eax
f010ff71:	e8 5b fd 00 00       	call   f011fcd1 <strcpy>
f010ff76:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ff79:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ff82:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff85:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ff8c:	00 00 00 
}
f010ff8f:	90                   	nop
f010ff90:	c9                   	leave  
f010ff91:	c3                   	ret    

f010ff92 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010ff92:	55                   	push   %ebp
f010ff93:	89 e5                	mov    %esp,%ebp
f010ff95:	53                   	push   %ebx
f010ff96:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ff99:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff9c:	83 c0 04             	add    $0x4,%eax
f010ff9f:	83 ec 0c             	sub    $0xc,%esp
f010ffa2:	50                   	push   %eax
f010ffa3:	e8 2c fd ff ff       	call   f010fcd4 <acquire_spinlock>
f010ffa8:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ffab:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffae:	8b 00                	mov    (%eax),%eax
f010ffb0:	85 c0                	test   %eax,%eax
f010ffb2:	74 1c                	je     f010ffd0 <holding_sleeplock+0x3e>
f010ffb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffb7:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ffbd:	e8 84 ba ff ff       	call   f010ba46 <get_cpu_proc>
f010ffc2:	8b 40 10             	mov    0x10(%eax),%eax
f010ffc5:	39 c3                	cmp    %eax,%ebx
f010ffc7:	75 07                	jne    f010ffd0 <holding_sleeplock+0x3e>
f010ffc9:	b8 01 00 00 00       	mov    $0x1,%eax
f010ffce:	eb 05                	jmp    f010ffd5 <holding_sleeplock+0x43>
f010ffd0:	b8 00 00 00 00       	mov    $0x0,%eax
f010ffd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ffd8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffdb:	83 c0 04             	add    $0x4,%eax
f010ffde:	83 ec 0c             	sub    $0xc,%esp
f010ffe1:	50                   	push   %eax
f010ffe2:	e8 74 fd ff ff       	call   f010fd5b <release_spinlock>
f010ffe7:	83 c4 10             	add    $0x10,%esp
	return r;
f010ffea:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ffed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fff0:	c9                   	leave  
f010fff1:	c3                   	ret    

f010fff2 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010fff2:	55                   	push   %ebp
f010fff3:	89 e5                	mov    %esp,%ebp
f010fff5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010fff8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fffb:	83 c0 04             	add    $0x4,%eax
f010fffe:	83 ec 0c             	sub    $0xc,%esp
f0110001:	50                   	push   %eax
f0110002:	e8 cd fc ff ff       	call   f010fcd4 <acquire_spinlock>
f0110007:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f011000a:	eb 19                	jmp    f0110025 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f011000c:	8b 45 08             	mov    0x8(%ebp),%eax
f011000f:	8d 50 04             	lea    0x4(%eax),%edx
f0110012:	8b 45 08             	mov    0x8(%ebp),%eax
f0110015:	83 c0 74             	add    $0x74,%eax
f0110018:	83 ec 08             	sub    $0x8,%esp
f011001b:	52                   	push   %edx
f011001c:	50                   	push   %eax
f011001d:	e8 9f 00 00 00       	call   f01100c1 <sleep>
f0110022:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f0110025:	8b 45 08             	mov    0x8(%ebp),%eax
f0110028:	8b 00                	mov    (%eax),%eax
f011002a:	85 c0                	test   %eax,%eax
f011002c:	75 de                	jne    f011000c <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f011002e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110031:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f0110037:	8b 45 08             	mov    0x8(%ebp),%eax
f011003a:	83 c0 04             	add    $0x4,%eax
f011003d:	83 ec 0c             	sub    $0xc,%esp
f0110040:	50                   	push   %eax
f0110041:	e8 15 fd ff ff       	call   f010fd5b <release_spinlock>
f0110046:	83 c4 10             	add    $0x10,%esp

}
f0110049:	90                   	nop
f011004a:	c9                   	leave  
f011004b:	c3                   	ret    

f011004c <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f011004c:	55                   	push   %ebp
f011004d:	89 e5                	mov    %esp,%ebp
f011004f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f0110052:	8b 45 08             	mov    0x8(%ebp),%eax
f0110055:	83 c0 04             	add    $0x4,%eax
f0110058:	83 ec 0c             	sub    $0xc,%esp
f011005b:	50                   	push   %eax
f011005c:	e8 73 fc ff ff       	call   f010fcd4 <acquire_spinlock>
f0110061:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f0110064:	8b 45 08             	mov    0x8(%ebp),%eax
f0110067:	83 c0 74             	add    $0x74,%eax
f011006a:	83 ec 0c             	sub    $0xc,%esp
f011006d:	50                   	push   %eax
f011006e:	e8 3f 01 00 00       	call   f01101b2 <wakeup_all>
f0110073:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f0110076:	8b 45 08             	mov    0x8(%ebp),%eax
f0110079:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f011007f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110082:	83 c0 04             	add    $0x4,%eax
f0110085:	83 ec 0c             	sub    $0xc,%esp
f0110088:	50                   	push   %eax
f0110089:	e8 cd fc ff ff       	call   f010fd5b <release_spinlock>
f011008e:	83 c4 10             	add    $0x10,%esp
}
f0110091:	90                   	nop
f0110092:	c9                   	leave  
f0110093:	c3                   	ret    

f0110094 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110094:	55                   	push   %ebp
f0110095:	89 e5                	mov    %esp,%ebp
f0110097:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f011009a:	8b 45 08             	mov    0x8(%ebp),%eax
f011009d:	83 c0 10             	add    $0x10,%eax
f01100a0:	83 ec 08             	sub    $0x8,%esp
f01100a3:	ff 75 0c             	pushl  0xc(%ebp)
f01100a6:	50                   	push   %eax
f01100a7:	e8 25 fc 00 00       	call   f011fcd1 <strcpy>
f01100ac:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f01100af:	8b 45 08             	mov    0x8(%ebp),%eax
f01100b2:	83 ec 0c             	sub    $0xc,%esp
f01100b5:	50                   	push   %eax
f01100b6:	e8 ae 4e ff ff       	call   f0104f69 <init_queue>
f01100bb:	83 c4 10             	add    $0x10,%esp
}
f01100be:	90                   	nop
f01100bf:	c9                   	leave  
f01100c0:	c3                   	ret    

f01100c1 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f01100c1:	55                   	push   %ebp
f01100c2:	89 e5                	mov    %esp,%ebp
f01100c4:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f01100c7:	83 ec 0c             	sub    $0xc,%esp
f01100ca:	68 e0 15 6c f0       	push   $0xf06c15e0
f01100cf:	e8 00 fc ff ff       	call   f010fcd4 <acquire_spinlock>
f01100d4:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f01100d7:	e8 6a b9 ff ff       	call   f010ba46 <get_cpu_proc>
f01100dc:	89 c2                	mov    %eax,%edx
f01100de:	8b 45 08             	mov    0x8(%ebp),%eax
f01100e1:	83 ec 08             	sub    $0x8,%esp
f01100e4:	52                   	push   %edx
f01100e5:	50                   	push   %eax
f01100e6:	e8 bf 4e ff ff       	call   f0104faa <enqueue>
f01100eb:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f01100ee:	e8 53 b9 ff ff       	call   f010ba46 <get_cpu_proc>
f01100f3:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f01100fa:	83 ec 0c             	sub    $0xc,%esp
f01100fd:	ff 75 0c             	pushl  0xc(%ebp)
f0110100:	e8 56 fc ff ff       	call   f010fd5b <release_spinlock>
f0110105:	83 c4 10             	add    $0x10,%esp
	sched();
f0110108:	e8 ba ba ff ff       	call   f010bbc7 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f011010d:	83 ec 0c             	sub    $0xc,%esp
f0110110:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110115:	e8 41 fc ff ff       	call   f010fd5b <release_spinlock>
f011011a:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f011011d:	83 ec 0c             	sub    $0xc,%esp
f0110120:	ff 75 0c             	pushl  0xc(%ebp)
f0110123:	e8 ac fb ff ff       	call   f010fcd4 <acquire_spinlock>
f0110128:	83 c4 10             	add    $0x10,%esp
}
f011012b:	90                   	nop
f011012c:	c9                   	leave  
f011012d:	c3                   	ret    

f011012e <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f011012e:	55                   	push   %ebp
f011012f:	89 e5                	mov    %esp,%ebp
f0110131:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f0110134:	8b 45 08             	mov    0x8(%ebp),%eax
f0110137:	83 ec 0c             	sub    $0xc,%esp
f011013a:	50                   	push   %eax
f011013b:	e8 52 4e ff ff       	call   f0104f92 <queue_size>
f0110140:	83 c4 10             	add    $0x10,%esp
f0110143:	85 c0                	test   %eax,%eax
f0110145:	74 68                	je     f01101af <wakeup_one+0x81>
		bool locked_by_me = 0;
f0110147:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f011014e:	83 ec 0c             	sub    $0xc,%esp
f0110151:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110156:	e8 92 fd ff ff       	call   f010feed <holding_spinlock>
f011015b:	83 c4 10             	add    $0x10,%esp
f011015e:	85 c0                	test   %eax,%eax
f0110160:	75 17                	jne    f0110179 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f0110162:	83 ec 0c             	sub    $0xc,%esp
f0110165:	68 e0 15 6c f0       	push   $0xf06c15e0
f011016a:	e8 65 fb ff ff       	call   f010fcd4 <acquire_spinlock>
f011016f:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f0110172:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f0110179:	8b 45 08             	mov    0x8(%ebp),%eax
f011017c:	83 ec 0c             	sub    $0xc,%esp
f011017f:	50                   	push   %eax
f0110180:	e8 b6 4e ff ff       	call   f010503b <dequeue>
f0110185:	83 c4 10             	add    $0x10,%esp
f0110188:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f011018b:	83 ec 0c             	sub    $0xc,%esp
f011018e:	ff 75 f0             	pushl  -0x10(%ebp)
f0110191:	e8 e0 50 ff ff       	call   f0105276 <sched_insert_ready0>
f0110196:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f0110199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011019d:	74 10                	je     f01101af <wakeup_one+0x81>
f011019f:	83 ec 0c             	sub    $0xc,%esp
f01101a2:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101a7:	e8 af fb ff ff       	call   f010fd5b <release_spinlock>
f01101ac:	83 c4 10             	add    $0x10,%esp
	}
}
f01101af:	90                   	nop
f01101b0:	c9                   	leave  
f01101b1:	c3                   	ret    

f01101b2 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01101b2:	55                   	push   %ebp
f01101b3:	89 e5                	mov    %esp,%ebp
f01101b5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f01101b8:	83 ec 0c             	sub    $0xc,%esp
f01101bb:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101c0:	e8 0f fb ff ff       	call   f010fcd4 <acquire_spinlock>
f01101c5:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f01101c8:	eb 0e                	jmp    f01101d8 <wakeup_all+0x26>
		wakeup_one(chan);
f01101ca:	83 ec 0c             	sub    $0xc,%esp
f01101cd:	ff 75 08             	pushl  0x8(%ebp)
f01101d0:	e8 59 ff ff ff       	call   f011012e <wakeup_one>
f01101d5:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f01101d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01101db:	83 ec 0c             	sub    $0xc,%esp
f01101de:	50                   	push   %eax
f01101df:	e8 ae 4d ff ff       	call   f0104f92 <queue_size>
f01101e4:	83 c4 10             	add    $0x10,%esp
f01101e7:	85 c0                	test   %eax,%eax
f01101e9:	75 df                	jne    f01101ca <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f01101eb:	83 ec 0c             	sub    $0xc,%esp
f01101ee:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101f3:	e8 63 fb ff ff       	call   f010fd5b <release_spinlock>
f01101f8:	83 c4 10             	add    $0x10,%esp
}
f01101fb:	90                   	nop
f01101fc:	c9                   	leave  
f01101fd:	c3                   	ret    

f01101fe <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f01101fe:	55                   	push   %ebp
f01101ff:	89 e5                	mov    %esp,%ebp
f0110201:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f0110204:	83 ec 04             	sub    $0x4,%esp
f0110207:	68 34 7c 12 f0       	push   $0xf0127c34
f011020c:	6a 13                	push   $0x13
f011020e:	68 5b 7c 12 f0       	push   $0xf0127c5b
f0110213:	e8 21 01 ff ff       	call   f0100339 <_panic>

f0110218 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110218:	55                   	push   %ebp
f0110219:	89 e5                	mov    %esp,%ebp
f011021b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f011021e:	83 ec 04             	sub    $0x4,%esp
f0110221:	68 74 7c 12 f0       	push   $0xf0127c74
f0110226:	6a 1b                	push   $0x1b
f0110228:	68 5b 7c 12 f0       	push   $0xf0127c5b
f011022d:	e8 07 01 ff ff       	call   f0100339 <_panic>

f0110232 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110232:	55                   	push   %ebp
f0110233:	89 e5                	mov    %esp,%ebp
f0110235:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f0110238:	83 ec 04             	sub    $0x4,%esp
f011023b:	68 9c 7c 12 f0       	push   $0xf0127c9c
f0110240:	6a 24                	push   $0x24
f0110242:	68 5b 7c 12 f0       	push   $0xf0127c5b
f0110247:	e8 ed 00 ff ff       	call   f0100339 <_panic>

f011024c <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f011024c:	55                   	push   %ebp
f011024d:	89 e5                	mov    %esp,%ebp
f011024f:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f0110256:	00 00 00 
f0110259:	90                   	nop
f011025a:	5d                   	pop    %ebp
f011025b:	c3                   	ret    

f011025c <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f011025c:	55                   	push   %ebp
f011025d:	89 e5                	mov    %esp,%ebp
f011025f:	c7 05 78 1b 6c f0 02 	movl   $0x2,0xf06c1b78
f0110266:	00 00 00 
f0110269:	90                   	nop
f011026a:	5d                   	pop    %ebp
f011026b:	c3                   	ret    

f011026c <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f011026c:	55                   	push   %ebp
f011026d:	89 e5                	mov    %esp,%ebp
f011026f:	c7 05 78 1b 6c f0 03 	movl   $0x3,0xf06c1b78
f0110276:	00 00 00 
f0110279:	90                   	nop
f011027a:	5d                   	pop    %ebp
f011027b:	c3                   	ret    

f011027c <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f011027c:	55                   	push   %ebp
f011027d:	89 e5                	mov    %esp,%ebp
f011027f:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0110284:	83 f8 01             	cmp    $0x1,%eax
f0110287:	75 04                	jne    f011028d <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0110289:	b0 01                	mov    $0x1,%al
f011028b:	eb 02                	jmp    f011028f <isKHeapPlacementStrategyFIRSTFIT+0x13>
f011028d:	b0 00                	mov    $0x0,%al
f011028f:	5d                   	pop    %ebp
f0110290:	c3                   	ret    

f0110291 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0110291:	55                   	push   %ebp
f0110292:	89 e5                	mov    %esp,%ebp
f0110294:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0110299:	83 f8 02             	cmp    $0x2,%eax
f011029c:	75 04                	jne    f01102a2 <isKHeapPlacementStrategyBESTFIT+0x11>
f011029e:	b0 01                	mov    $0x1,%al
f01102a0:	eb 02                	jmp    f01102a4 <isKHeapPlacementStrategyBESTFIT+0x13>
f01102a2:	b0 00                	mov    $0x0,%al
f01102a4:	5d                   	pop    %ebp
f01102a5:	c3                   	ret    

f01102a6 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01102a6:	55                   	push   %ebp
f01102a7:	89 e5                	mov    %esp,%ebp
f01102a9:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01102ae:	83 f8 03             	cmp    $0x3,%eax
f01102b1:	75 04                	jne    f01102b7 <isKHeapPlacementStrategyNEXTFIT+0x11>
f01102b3:	b0 01                	mov    $0x1,%al
f01102b5:	eb 02                	jmp    f01102b9 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01102b7:	b0 00                	mov    $0x0,%al
f01102b9:	5d                   	pop    %ebp
f01102ba:	c3                   	ret    

f01102bb <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f01102bb:	55                   	push   %ebp
f01102bc:	89 e5                	mov    %esp,%ebp
f01102be:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f01102c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01102c8:	eb 26                	jmp    f01102f0 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f01102ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01102cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01102d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102d7:	01 c2                	add    %eax,%edx
f01102d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01102dc:	40                   	inc    %eax
f01102dd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01102e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102e7:	01 c8                	add    %ecx,%eax
f01102e9:	8b 00                	mov    (%eax),%eax
f01102eb:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f01102ed:	ff 45 f4             	incl   -0xc(%ebp)
f01102f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01102f3:	48                   	dec    %eax
f01102f4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01102f7:	7f d1                	jg     f01102ca <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f01102f9:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f01102fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110303:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011030a:	eb 35                	jmp    f0110341 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f011030c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011030f:	89 d0                	mov    %edx,%eax
f0110311:	01 c0                	add    %eax,%eax
f0110313:	01 d0                	add    %edx,%eax
f0110315:	c1 e0 02             	shl    $0x2,%eax
f0110318:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f011031d:	8b 10                	mov    (%eax),%edx
f011031f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110322:	8b 00                	mov    (%eax),%eax
f0110324:	83 ec 08             	sub    $0x8,%esp
f0110327:	52                   	push   %edx
f0110328:	50                   	push   %eax
f0110329:	e8 60 fa 00 00       	call   f011fd8e <strcmp>
f011032e:	83 c4 10             	add    $0x10,%esp
f0110331:	85 c0                	test   %eax,%eax
f0110333:	75 09                	jne    f011033e <tst_handler+0x83>
		{
			test_found = 1;
f0110335:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f011033c:	eb 0f                	jmp    f011034d <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f011033e:	ff 45 ec             	incl   -0x14(%ebp)
f0110341:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110344:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f0110349:	39 c2                	cmp    %eax,%edx
f011034b:	72 bf                	jb     f011030c <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f011034d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110351:	74 29                	je     f011037c <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0110353:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110356:	89 d0                	mov    %edx,%eax
f0110358:	01 c0                	add    %eax,%eax
f011035a:	01 d0                	add    %edx,%eax
f011035c:	c1 e0 02             	shl    $0x2,%eax
f011035f:	05 08 fd 17 f0       	add    $0xf017fd08,%eax
f0110364:	8b 00                	mov    (%eax),%eax
f0110366:	83 ec 08             	sub    $0x8,%esp
f0110369:	ff 75 0c             	pushl  0xc(%ebp)
f011036c:	ff 75 08             	pushl  0x8(%ebp)
f011036f:	ff d0                	call   *%eax
f0110371:	83 c4 10             	add    $0x10,%esp
f0110374:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110377:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011037a:	eb 1b                	jmp    f0110397 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f011037c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011037f:	8b 00                	mov    (%eax),%eax
f0110381:	83 ec 08             	sub    $0x8,%esp
f0110384:	50                   	push   %eax
f0110385:	68 dc 7f 12 f0       	push   $0xf0127fdc
f011038a:	e8 fc 0b ff ff       	call   f0100f8b <cprintf>
f011038f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110392:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110397:	c9                   	leave  
f0110398:	c3                   	ret    

f0110399 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110399:	55                   	push   %ebp
f011039a:	89 e5                	mov    %esp,%ebp
f011039c:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f011039f:	e8 69 d0 00 00       	call   f011d40d <test_three_creation_functions>
	return 0;
f01103a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103a9:	c9                   	leave  
f01103aa:	c3                   	ret    

f01103ab <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f01103ab:	55                   	push   %ebp
f01103ac:	89 e5                	mov    %esp,%ebp
f01103ae:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f01103b1:	e8 03 69 00 00       	call   f0116cb9 <test_priority_normal_and_higher>
	return 0;
f01103b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103bb:	c9                   	leave  
f01103bc:	c3                   	ret    

f01103bd <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f01103bd:	55                   	push   %ebp
f01103be:	89 e5                	mov    %esp,%ebp
f01103c0:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f01103c3:	e8 0b 69 00 00       	call   f0116cd3 <test_priority_normal_and_lower>
	return 0;
f01103c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103cd:	c9                   	leave  
f01103ce:	c3                   	ret    

f01103cf <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f01103cf:	55                   	push   %ebp
f01103d0:	89 e5                	mov    %esp,%ebp
f01103d2:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f01103d5:	e8 e6 d1 00 00       	call   f011d5c0 <test_kfreeall>
	return 0;
f01103da:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103df:	c9                   	leave  
f01103e0:	c3                   	ret    

f01103e1 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f01103e1:	55                   	push   %ebp
f01103e2:	89 e5                	mov    %esp,%ebp
f01103e4:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f01103e7:	e8 f1 d1 00 00       	call   f011d5dd <test_kexpand>
	return 0;
f01103ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103f1:	c9                   	leave  
f01103f2:	c3                   	ret    

f01103f3 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f01103f3:	55                   	push   %ebp
f01103f4:	89 e5                	mov    %esp,%ebp
f01103f6:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f01103f9:	e8 fc d1 00 00       	call   f011d5fa <test_kshrink>
	return 0;
f01103fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110403:	c9                   	leave  
f0110404:	c3                   	ret    

f0110405 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f0110405:	55                   	push   %ebp
f0110406:	89 e5                	mov    %esp,%ebp
f0110408:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f011040b:	e8 07 d2 00 00       	call   f011d617 <test_kfreelast>
	return 0;
f0110410:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110415:	c9                   	leave  
f0110416:	c3                   	ret    

f0110417 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f0110417:	55                   	push   %ebp
f0110418:	89 e5                	mov    %esp,%ebp
f011041a:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f011041d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110420:	83 c0 04             	add    $0x4,%eax
f0110423:	8b 00                	mov    (%eax),%eax
f0110425:	83 ec 04             	sub    $0x4,%esp
f0110428:	6a 0a                	push   $0xa
f011042a:	6a 00                	push   $0x0
f011042c:	50                   	push   %eax
f011042d:	e8 b0 fb 00 00       	call   f011ffe2 <strtol>
f0110432:	83 c4 10             	add    $0x10,%esp
f0110435:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f0110438:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f011043f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f0110446:	83 ec 0c             	sub    $0xc,%esp
f0110449:	68 e0 15 6c f0       	push   $0xf06c15e0
f011044e:	e8 81 f8 ff ff       	call   f010fcd4 <acquire_spinlock>
f0110453:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110456:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f011045b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011045e:	eb 3b                	jmp    f011049b <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f0110460:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110463:	83 c0 20             	add    $0x20,%eax
f0110466:	83 ec 08             	sub    $0x8,%esp
f0110469:	68 ef 7f 12 f0       	push   $0xf0127fef
f011046e:	50                   	push   %eax
f011046f:	e8 1a f9 00 00       	call   f011fd8e <strcmp>
f0110474:	83 c4 10             	add    $0x10,%esp
f0110477:	85 c0                	test   %eax,%eax
f0110479:	75 12                	jne    f011048d <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f011047b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011047f:	74 07                	je     f0110488 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f0110481:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110488:	ff 45 f4             	incl   -0xc(%ebp)
f011048b:	eb 06                	jmp    f0110493 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f011048d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110491:	74 31                	je     f01104c4 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110493:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0110498:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011049b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011049f:	74 08                	je     f01104a9 <tst_sc_MLFQ+0x92>
f01104a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01104a4:	8b 40 08             	mov    0x8(%eax),%eax
f01104a7:	eb 05                	jmp    f01104ae <tst_sc_MLFQ+0x97>
f01104a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01104ae:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f01104b3:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f01104b8:	85 c0                	test   %eax,%eax
f01104ba:	75 a4                	jne    f0110460 <tst_sc_MLFQ+0x49>
f01104bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01104c0:	75 9e                	jne    f0110460 <tst_sc_MLFQ+0x49>
f01104c2:	eb 01                	jmp    f01104c5 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f01104c4:	90                   	nop
			}
		if(cnt == numOfSlave2)
f01104c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01104cb:	75 12                	jne    f01104df <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f01104cd:	83 ec 0c             	sub    $0xc,%esp
f01104d0:	68 f8 7f 12 f0       	push   $0xf0127ff8
f01104d5:	e8 b1 0a ff ff       	call   f0100f8b <cprintf>
f01104da:	83 c4 10             	add    $0x10,%esp
f01104dd:	eb 17                	jmp    f01104f6 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f01104df:	83 ec 04             	sub    $0x4,%esp
f01104e2:	68 31 80 12 f0       	push   $0xf0128031
f01104e7:	68 9b 00 00 00       	push   $0x9b
f01104ec:	68 47 80 12 f0       	push   $0xf0128047
f01104f1:	e8 43 fe fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f01104f6:	83 ec 0c             	sub    $0xc,%esp
f01104f9:	68 e0 15 6c f0       	push   $0xf06c15e0
f01104fe:	e8 58 f8 ff ff       	call   f010fd5b <release_spinlock>
f0110503:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110506:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011050b:	c9                   	leave  
f011050c:	c3                   	ret    

f011050d <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f011050d:	55                   	push   %ebp
f011050e:	89 e5                	mov    %esp,%ebp
f0110510:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0110513:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110517:	74 17                	je     f0110530 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f0110519:	83 ec 0c             	sub    $0xc,%esp
f011051c:	68 60 80 12 f0       	push   $0xf0128060
f0110521:	e8 65 0a ff ff       	call   f0100f8b <cprintf>
f0110526:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110529:	b8 00 00 00 00       	mov    $0x0,%eax
f011052e:	eb 45                	jmp    f0110575 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110530:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110533:	83 c0 04             	add    $0x4,%eax
f0110536:	8b 00                	mov    (%eax),%eax
f0110538:	83 ec 04             	sub    $0x4,%esp
f011053b:	6a 0a                	push   $0xa
f011053d:	6a 00                	push   $0x0
f011053f:	50                   	push   %eax
f0110540:	e8 9d fa 00 00       	call   f011ffe2 <strtol>
f0110545:	83 c4 10             	add    $0x10,%esp
f0110548:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f011054b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011054e:	83 f8 01             	cmp    $0x1,%eax
f0110551:	74 10                	je     f0110563 <tst_bsd_nice+0x56>
f0110553:	83 f8 02             	cmp    $0x2,%eax
f0110556:	74 12                	je     f011056a <tst_bsd_nice+0x5d>
f0110558:	85 c0                	test   %eax,%eax
f011055a:	75 14                	jne    f0110570 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f011055c:	e8 b9 d2 00 00       	call   f011d81a <test_bsd_nice_0>
		break;
f0110561:	eb 0d                	jmp    f0110570 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f0110563:	e8 3c d5 00 00       	call   f011daa4 <test_bsd_nice_1>
		break;
f0110568:	eb 06                	jmp    f0110570 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f011056a:	e8 49 d7 00 00       	call   f011dcb8 <test_bsd_nice_2>
		break;
f011056f:	90                   	nop
	}
	return 0;
f0110570:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110575:	c9                   	leave  
f0110576:	c3                   	ret    

f0110577 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f0110577:	55                   	push   %ebp
f0110578:	89 e5                	mov    %esp,%ebp
f011057a:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f011057d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0110581:	74 17                	je     f011059a <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f0110583:	83 ec 0c             	sub    $0xc,%esp
f0110586:	68 a0 80 12 f0       	push   $0xf01280a0
f011058b:	e8 fb 09 ff ff       	call   f0100f8b <cprintf>
f0110590:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110593:	b8 00 00 00 00       	mov    $0x0,%eax
f0110598:	eb 0a                	jmp    f01105a4 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f011059a:	e8 3f 15 00 00       	call   f0111ade <test_str2lower_function>
	return 0;
f011059f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105a4:	c9                   	leave  
f01105a5:	c3                   	ret    

f01105a6 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01105a6:	55                   	push   %ebp
f01105a7:	89 e5                	mov    %esp,%ebp
f01105a9:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01105ac:	e8 63 11 00 00       	call   f0111714 <TestAutoCompleteCommand>
f01105b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01105b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105b9:	c9                   	leave  
f01105ba:	c3                   	ret    

f01105bb <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01105bb:	55                   	push   %ebp
f01105bc:	89 e5                	mov    %esp,%ebp
f01105be:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01105c1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01105c5:	74 1a                	je     f01105e1 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01105c7:	83 ec 0c             	sub    $0xc,%esp
f01105ca:	68 d4 80 12 f0       	push   $0xf01280d4
f01105cf:	e8 b7 09 ff ff       	call   f0100f8b <cprintf>
f01105d4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105d7:	b8 00 00 00 00       	mov    $0x0,%eax
f01105dc:	e9 2f 01 00 00       	jmp    f0110710 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f01105e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105e4:	83 c0 04             	add    $0x4,%eax
f01105e7:	8b 00                	mov    (%eax),%eax
f01105e9:	83 ec 08             	sub    $0x8,%esp
f01105ec:	68 11 81 12 f0       	push   $0xf0128111
f01105f1:	50                   	push   %eax
f01105f2:	e8 97 f7 00 00       	call   f011fd8e <strcmp>
f01105f7:	83 c4 10             	add    $0x10,%esp
f01105fa:	85 c0                	test   %eax,%eax
f01105fc:	75 0a                	jne    f0110608 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f01105fe:	e8 40 08 00 00       	call   f0110e43 <test_initialize_dynamic_allocator>
f0110603:	e9 03 01 00 00       	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f0110608:	8b 45 0c             	mov    0xc(%ebp),%eax
f011060b:	83 c0 04             	add    $0x4,%eax
f011060e:	8b 00                	mov    (%eax),%eax
f0110610:	83 ec 08             	sub    $0x8,%esp
f0110613:	68 16 81 12 f0       	push   $0xf0128116
f0110618:	50                   	push   %eax
f0110619:	e8 70 f7 00 00       	call   f011fd8e <strcmp>
f011061e:	83 c4 10             	add    $0x10,%esp
f0110621:	85 c0                	test   %eax,%eax
f0110623:	75 0a                	jne    f011062f <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f0110625:	e8 4d 08 00 00       	call   f0110e77 <test_alloc_block_FF>
f011062a:	e9 dc 00 00 00       	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f011062f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110632:	83 c0 04             	add    $0x4,%eax
f0110635:	8b 00                	mov    (%eax),%eax
f0110637:	83 ec 08             	sub    $0x8,%esp
f011063a:	68 1e 81 12 f0       	push   $0xf012811e
f011063f:	50                   	push   %eax
f0110640:	e8 49 f7 00 00       	call   f011fd8e <strcmp>
f0110645:	83 c4 10             	add    $0x10,%esp
f0110648:	85 c0                	test   %eax,%eax
f011064a:	75 0a                	jne    f0110656 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f011064c:	e8 43 08 00 00       	call   f0110e94 <test_alloc_block_BF>
f0110651:	e9 b5 00 00 00       	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f0110656:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110659:	83 c0 04             	add    $0x4,%eax
f011065c:	8b 00                	mov    (%eax),%eax
f011065e:	83 ec 08             	sub    $0x8,%esp
f0110661:	68 26 81 12 f0       	push   $0xf0128126
f0110666:	50                   	push   %eax
f0110667:	e8 22 f7 00 00       	call   f011fd8e <strcmp>
f011066c:	83 c4 10             	add    $0x10,%esp
f011066f:	85 c0                	test   %eax,%eax
f0110671:	75 0a                	jne    f011067d <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f0110673:	e8 3c 08 00 00       	call   f0110eb4 <test_alloc_block_NF>
f0110678:	e9 8e 00 00 00       	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f011067d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110680:	83 c0 04             	add    $0x4,%eax
f0110683:	8b 00                	mov    (%eax),%eax
f0110685:	83 ec 08             	sub    $0x8,%esp
f0110688:	68 2e 81 12 f0       	push   $0xf012812e
f011068d:	50                   	push   %eax
f011068e:	e8 fb f6 00 00       	call   f011fd8e <strcmp>
f0110693:	83 c4 10             	add    $0x10,%esp
f0110696:	85 c0                	test   %eax,%eax
f0110698:	75 07                	jne    f01106a1 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f011069a:	e8 1b 08 00 00       	call   f0110eba <test_free_block_FF>
f011069f:	eb 6a                	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f01106a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106a4:	83 c0 04             	add    $0x4,%eax
f01106a7:	8b 00                	mov    (%eax),%eax
f01106a9:	83 ec 08             	sub    $0x8,%esp
f01106ac:	68 35 81 12 f0       	push   $0xf0128135
f01106b1:	50                   	push   %eax
f01106b2:	e8 d7 f6 00 00       	call   f011fd8e <strcmp>
f01106b7:	83 c4 10             	add    $0x10,%esp
f01106ba:	85 c0                	test   %eax,%eax
f01106bc:	75 07                	jne    f01106c5 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f01106be:	e8 14 08 00 00       	call   f0110ed7 <test_free_block_BF>
f01106c3:	eb 46                	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f01106c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106c8:	83 c0 04             	add    $0x4,%eax
f01106cb:	8b 00                	mov    (%eax),%eax
f01106cd:	83 ec 08             	sub    $0x8,%esp
f01106d0:	68 3c 81 12 f0       	push   $0xf012813c
f01106d5:	50                   	push   %eax
f01106d6:	e8 b3 f6 00 00       	call   f011fd8e <strcmp>
f01106db:	83 c4 10             	add    $0x10,%esp
f01106de:	85 c0                	test   %eax,%eax
f01106e0:	75 07                	jne    f01106e9 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f01106e2:	e8 0d 08 00 00       	call   f0110ef4 <test_free_block_NF>
f01106e7:	eb 22                	jmp    f011070b <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f01106e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106ec:	83 c0 04             	add    $0x4,%eax
f01106ef:	8b 00                	mov    (%eax),%eax
f01106f1:	83 ec 08             	sub    $0x8,%esp
f01106f4:	68 43 81 12 f0       	push   $0xf0128143
f01106f9:	50                   	push   %eax
f01106fa:	e8 8f f6 00 00       	call   f011fd8e <strcmp>
f01106ff:	83 c4 10             	add    $0x10,%esp
f0110702:	85 c0                	test   %eax,%eax
f0110704:	75 05                	jne    f011070b <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0110706:	e8 06 08 00 00       	call   f0110f11 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f011070b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110710:	c9                   	leave  
f0110711:	c3                   	ret    

f0110712 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110712:	55                   	push   %ebp
f0110713:	89 e5                	mov    %esp,%ebp
f0110715:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110718:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011071c:	74 1a                	je     f0110738 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f011071e:	83 ec 0c             	sub    $0xc,%esp
f0110721:	68 50 81 12 f0       	push   $0xf0128150
f0110726:	e8 60 08 ff ff       	call   f0100f8b <cprintf>
f011072b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011072e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110733:	e9 e1 00 00 00       	jmp    f0110819 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f0110738:	8b 45 0c             	mov    0xc(%ebp),%eax
f011073b:	83 c0 04             	add    $0x4,%eax
f011073e:	8b 00                	mov    (%eax),%eax
f0110740:	83 ec 08             	sub    $0x8,%esp
f0110743:	68 89 81 12 f0       	push   $0xf0128189
f0110748:	50                   	push   %eax
f0110749:	e8 40 f6 00 00       	call   f011fd8e <strcmp>
f011074e:	83 c4 10             	add    $0x10,%esp
f0110751:	85 c0                	test   %eax,%eax
f0110753:	75 0a                	jne    f011075f <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f0110755:	e8 97 1c 00 00       	call   f01123f1 <test_cut_paste_pages>
f011075a:	e9 b5 00 00 00       	jmp    f0110814 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f011075f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110762:	83 c0 04             	add    $0x4,%eax
f0110765:	8b 00                	mov    (%eax),%eax
f0110767:	83 ec 08             	sub    $0x8,%esp
f011076a:	68 92 81 12 f0       	push   $0xf0128192
f011076f:	50                   	push   %eax
f0110770:	e8 19 f6 00 00       	call   f011fd8e <strcmp>
f0110775:	83 c4 10             	add    $0x10,%esp
f0110778:	85 c0                	test   %eax,%eax
f011077a:	75 0a                	jne    f0110786 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f011077c:	e8 bb 26 00 00       	call   f0112e3c <test_copy_paste_chunk>
f0110781:	e9 8e 00 00 00       	jmp    f0110814 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f0110786:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110789:	83 c0 04             	add    $0x4,%eax
f011078c:	8b 00                	mov    (%eax),%eax
f011078e:	83 ec 08             	sub    $0x8,%esp
f0110791:	68 9c 81 12 f0       	push   $0xf012819c
f0110796:	50                   	push   %eax
f0110797:	e8 f2 f5 00 00       	call   f011fd8e <strcmp>
f011079c:	83 c4 10             	add    $0x10,%esp
f011079f:	85 c0                	test   %eax,%eax
f01107a1:	75 07                	jne    f01107aa <tst_chunks+0x98>
	{
		test_share_chunk();
f01107a3:	e8 92 37 00 00       	call   f0113f3a <test_share_chunk>
f01107a8:	eb 6a                	jmp    f0110814 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01107aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107ad:	83 c0 04             	add    $0x4,%eax
f01107b0:	8b 00                	mov    (%eax),%eax
f01107b2:	83 ec 08             	sub    $0x8,%esp
f01107b5:	68 a2 81 12 f0       	push   $0xf01281a2
f01107ba:	50                   	push   %eax
f01107bb:	e8 ce f5 00 00       	call   f011fd8e <strcmp>
f01107c0:	83 c4 10             	add    $0x10,%esp
f01107c3:	85 c0                	test   %eax,%eax
f01107c5:	75 07                	jne    f01107ce <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f01107c7:	e8 96 41 00 00       	call   f0114962 <test_allocate_chunk>
f01107cc:	eb 46                	jmp    f0110814 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f01107ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107d1:	83 c0 04             	add    $0x4,%eax
f01107d4:	8b 00                	mov    (%eax),%eax
f01107d6:	83 ec 08             	sub    $0x8,%esp
f01107d9:	68 ab 81 12 f0       	push   $0xf01281ab
f01107de:	50                   	push   %eax
f01107df:	e8 aa f5 00 00       	call   f011fd8e <strcmp>
f01107e4:	83 c4 10             	add    $0x10,%esp
f01107e7:	85 c0                	test   %eax,%eax
f01107e9:	75 07                	jne    f01107f2 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f01107eb:	e8 79 4a 00 00       	call   f0115269 <test_calculate_required_frames>
f01107f0:	eb 22                	jmp    f0110814 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f01107f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107f5:	83 c0 04             	add    $0x4,%eax
f01107f8:	8b 00                	mov    (%eax),%eax
f01107fa:	83 ec 08             	sub    $0x8,%esp
f01107fd:	68 ba 81 12 f0       	push   $0xf01281ba
f0110802:	50                   	push   %eax
f0110803:	e8 86 f5 00 00       	call   f011fd8e <strcmp>
f0110808:	83 c4 10             	add    $0x10,%esp
f011080b:	85 c0                	test   %eax,%eax
f011080d:	75 05                	jne    f0110814 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f011080f:	e8 c9 52 00 00       	call   f0115add <test_calculate_allocated_space>
	}
	return 0;
f0110814:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110819:	c9                   	leave  
f011081a:	c3                   	ret    

f011081b <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011081b:	55                   	push   %ebp
f011081c:	89 e5                	mov    %esp,%ebp
f011081e:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110821:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110825:	74 1a                	je     f0110841 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110827:	83 ec 0c             	sub    $0xc,%esp
f011082a:	68 cc 81 12 f0       	push   $0xf01281cc
f011082f:	e8 57 07 ff ff       	call   f0100f8b <cprintf>
f0110834:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110837:	b8 00 00 00 00       	mov    $0x0,%eax
f011083c:	e9 ba 00 00 00       	jmp    f01108fb <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110841:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110844:	83 c0 04             	add    $0x4,%eax
f0110847:	8b 00                	mov    (%eax),%eax
f0110849:	83 ec 08             	sub    $0x8,%esp
f011084c:	68 02 82 12 f0       	push   $0xf0128202
f0110851:	50                   	push   %eax
f0110852:	e8 37 f5 00 00       	call   f011fd8e <strcmp>
f0110857:	83 c4 10             	add    $0x10,%esp
f011085a:	85 c0                	test   %eax,%eax
f011085c:	75 0a                	jne    f0110868 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f011085e:	e8 01 16 00 00       	call   f0111e64 <test_pt_set_page_permissions>
f0110863:	e9 8e 00 00 00       	jmp    f01108f6 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f0110868:	8b 45 0c             	mov    0xc(%ebp),%eax
f011086b:	83 c0 04             	add    $0x4,%eax
f011086e:	8b 00                	mov    (%eax),%eax
f0110870:	83 ec 08             	sub    $0x8,%esp
f0110873:	68 0a 82 12 f0       	push   $0xf012820a
f0110878:	50                   	push   %eax
f0110879:	e8 10 f5 00 00       	call   f011fd8e <strcmp>
f011087e:	83 c4 10             	add    $0x10,%esp
f0110881:	85 c0                	test   %eax,%eax
f0110883:	75 07                	jne    f011088c <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f0110885:	e8 49 18 00 00       	call   f01120d3 <test_pt_set_page_permissions_invalid_va>
f011088a:	eb 6a                	jmp    f01108f6 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f011088c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011088f:	83 c0 04             	add    $0x4,%eax
f0110892:	8b 00                	mov    (%eax),%eax
f0110894:	83 ec 08             	sub    $0x8,%esp
f0110897:	68 12 82 12 f0       	push   $0xf0128212
f011089c:	50                   	push   %eax
f011089d:	e8 ec f4 00 00       	call   f011fd8e <strcmp>
f01108a2:	83 c4 10             	add    $0x10,%esp
f01108a5:	85 c0                	test   %eax,%eax
f01108a7:	75 07                	jne    f01108b0 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01108a9:	e8 6e 18 00 00       	call   f011211c <test_pt_get_page_permissions>
f01108ae:	eb 46                	jmp    f01108f6 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01108b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108b3:	83 c0 04             	add    $0x4,%eax
f01108b6:	8b 00                	mov    (%eax),%eax
f01108b8:	83 ec 08             	sub    $0x8,%esp
f01108bb:	68 1a 82 12 f0       	push   $0xf012821a
f01108c0:	50                   	push   %eax
f01108c1:	e8 c8 f4 00 00       	call   f011fd8e <strcmp>
f01108c6:	83 c4 10             	add    $0x10,%esp
f01108c9:	85 c0                	test   %eax,%eax
f01108cb:	75 07                	jne    f01108d4 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f01108cd:	e8 8e 19 00 00       	call   f0112260 <test_pt_clear_page_table_entry>
f01108d2:	eb 22                	jmp    f01108f6 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f01108d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108d7:	83 c0 04             	add    $0x4,%eax
f01108da:	8b 00                	mov    (%eax),%eax
f01108dc:	83 ec 08             	sub    $0x8,%esp
f01108df:	68 21 82 12 f0       	push   $0xf0128221
f01108e4:	50                   	push   %eax
f01108e5:	e8 a4 f4 00 00       	call   f011fd8e <strcmp>
f01108ea:	83 c4 10             	add    $0x10,%esp
f01108ed:	85 c0                	test   %eax,%eax
f01108ef:	75 05                	jne    f01108f6 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f01108f1:	e8 c3 1a 00 00       	call   f01123b9 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f01108f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01108fb:	c9                   	leave  
f01108fc:	c3                   	ret    

f01108fd <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f01108fd:	55                   	push   %ebp
f01108fe:	89 e5                	mov    %esp,%ebp
f0110900:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110903:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110906:	83 c0 08             	add    $0x8,%eax
f0110909:	8b 00                	mov    (%eax),%eax
f011090b:	83 ec 08             	sub    $0x8,%esp
f011090e:	68 28 82 12 f0       	push   $0xf0128228
f0110913:	50                   	push   %eax
f0110914:	e8 75 f4 00 00       	call   f011fd8e <strcmp>
f0110919:	83 c4 10             	add    $0x10,%esp
f011091c:	85 c0                	test   %eax,%eax
f011091e:	75 20                	jne    f0110940 <tst_kheap+0x43>
f0110920:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110924:	74 1a                	je     f0110940 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110926:	83 ec 0c             	sub    $0xc,%esp
f0110929:	68 30 82 12 f0       	push   $0xf0128230
f011092e:	e8 58 06 ff ff       	call   f0100f8b <cprintf>
f0110933:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110936:	b8 00 00 00 00       	mov    $0x0,%eax
f011093b:	e9 42 04 00 00       	jmp    f0110d82 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110940:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110943:	83 c0 08             	add    $0x8,%eax
f0110946:	8b 00                	mov    (%eax),%eax
f0110948:	83 ec 08             	sub    $0x8,%esp
f011094b:	68 28 82 12 f0       	push   $0xf0128228
f0110950:	50                   	push   %eax
f0110951:	e8 38 f4 00 00       	call   f011fd8e <strcmp>
f0110956:	83 c4 10             	add    $0x10,%esp
f0110959:	85 c0                	test   %eax,%eax
f011095b:	74 43                	je     f01109a0 <tst_kheap+0xa3>
f011095d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110961:	74 3d                	je     f01109a0 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f0110963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110966:	83 c0 08             	add    $0x8,%eax
f0110969:	8b 00                	mov    (%eax),%eax
f011096b:	83 ec 08             	sub    $0x8,%esp
f011096e:	68 80 82 12 f0       	push   $0xf0128280
f0110973:	50                   	push   %eax
f0110974:	e8 15 f4 00 00       	call   f011fd8e <strcmp>
f0110979:	83 c4 10             	add    $0x10,%esp
f011097c:	85 c0                	test   %eax,%eax
f011097e:	74 20                	je     f01109a0 <tst_kheap+0xa3>
f0110980:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f0110984:	74 1a                	je     f01109a0 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f0110986:	83 ec 0c             	sub    $0xc,%esp
f0110989:	68 8c 82 12 f0       	push   $0xf012828c
f011098e:	e8 f8 05 ff ff       	call   f0100f8b <cprintf>
f0110993:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110996:	b8 00 00 00 00       	mov    $0x0,%eax
f011099b:	e9 e2 03 00 00       	jmp    f0110d82 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01109a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109a3:	83 c0 04             	add    $0x4,%eax
f01109a6:	8b 00                	mov    (%eax),%eax
f01109a8:	83 ec 08             	sub    $0x8,%esp
f01109ab:	68 d1 82 12 f0       	push   $0xf01282d1
f01109b0:	50                   	push   %eax
f01109b1:	e8 d8 f3 00 00       	call   f011fd8e <strcmp>
f01109b6:	83 c4 10             	add    $0x10,%esp
f01109b9:	85 c0                	test   %eax,%eax
f01109bb:	74 1d                	je     f01109da <tst_kheap+0xdd>
f01109bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109c0:	83 c0 04             	add    $0x4,%eax
f01109c3:	8b 00                	mov    (%eax),%eax
f01109c5:	83 ec 08             	sub    $0x8,%esp
f01109c8:	68 d4 82 12 f0       	push   $0xf01282d4
f01109cd:	50                   	push   %eax
f01109ce:	e8 bb f3 00 00       	call   f011fd8e <strcmp>
f01109d3:	83 c4 10             	add    $0x10,%esp
f01109d6:	85 c0                	test   %eax,%eax
f01109d8:	75 1a                	jne    f01109f4 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f01109da:	e8 6d f8 ff ff       	call   f011024c <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01109df:	83 ec 0c             	sub    $0xc,%esp
f01109e2:	68 d8 82 12 f0       	push   $0xf01282d8
f01109e7:	e8 9f 05 ff ff       	call   f0100f8b <cprintf>
f01109ec:	83 c4 10             	add    $0x10,%esp
f01109ef:	e9 a0 00 00 00       	jmp    f0110a94 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f01109f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109f7:	83 c0 04             	add    $0x4,%eax
f01109fa:	8b 00                	mov    (%eax),%eax
f01109fc:	83 ec 08             	sub    $0x8,%esp
f01109ff:	68 05 83 12 f0       	push   $0xf0128305
f0110a04:	50                   	push   %eax
f0110a05:	e8 84 f3 00 00       	call   f011fd8e <strcmp>
f0110a0a:	83 c4 10             	add    $0x10,%esp
f0110a0d:	85 c0                	test   %eax,%eax
f0110a0f:	74 1d                	je     f0110a2e <tst_kheap+0x131>
f0110a11:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a14:	83 c0 04             	add    $0x4,%eax
f0110a17:	8b 00                	mov    (%eax),%eax
f0110a19:	83 ec 08             	sub    $0x8,%esp
f0110a1c:	68 08 83 12 f0       	push   $0xf0128308
f0110a21:	50                   	push   %eax
f0110a22:	e8 67 f3 00 00       	call   f011fd8e <strcmp>
f0110a27:	83 c4 10             	add    $0x10,%esp
f0110a2a:	85 c0                	test   %eax,%eax
f0110a2c:	75 17                	jne    f0110a45 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110a2e:	e8 29 f8 ff ff       	call   f011025c <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110a33:	83 ec 0c             	sub    $0xc,%esp
f0110a36:	68 0c 83 12 f0       	push   $0xf012830c
f0110a3b:	e8 4b 05 ff ff       	call   f0100f8b <cprintf>
f0110a40:	83 c4 10             	add    $0x10,%esp
f0110a43:	eb 4f                	jmp    f0110a94 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110a45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a48:	83 c0 04             	add    $0x4,%eax
f0110a4b:	8b 00                	mov    (%eax),%eax
f0110a4d:	83 ec 08             	sub    $0x8,%esp
f0110a50:	68 38 83 12 f0       	push   $0xf0128338
f0110a55:	50                   	push   %eax
f0110a56:	e8 33 f3 00 00       	call   f011fd8e <strcmp>
f0110a5b:	83 c4 10             	add    $0x10,%esp
f0110a5e:	85 c0                	test   %eax,%eax
f0110a60:	74 1d                	je     f0110a7f <tst_kheap+0x182>
f0110a62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a65:	83 c0 04             	add    $0x4,%eax
f0110a68:	8b 00                	mov    (%eax),%eax
f0110a6a:	83 ec 08             	sub    $0x8,%esp
f0110a6d:	68 3b 83 12 f0       	push   $0xf012833b
f0110a72:	50                   	push   %eax
f0110a73:	e8 16 f3 00 00       	call   f011fd8e <strcmp>
f0110a78:	83 c4 10             	add    $0x10,%esp
f0110a7b:	85 c0                	test   %eax,%eax
f0110a7d:	75 15                	jne    f0110a94 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110a7f:	e8 e8 f7 ff ff       	call   f011026c <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110a84:	83 ec 0c             	sub    $0xc,%esp
f0110a87:	68 40 83 12 f0       	push   $0xf0128340
f0110a8c:	e8 fa 04 ff ff       	call   f0100f8b <cprintf>
f0110a91:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110a94:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a97:	83 c0 08             	add    $0x8,%eax
f0110a9a:	8b 00                	mov    (%eax),%eax
f0110a9c:	83 ec 08             	sub    $0x8,%esp
f0110a9f:	68 28 82 12 f0       	push   $0xf0128228
f0110aa4:	50                   	push   %eax
f0110aa5:	e8 e4 f2 00 00       	call   f011fd8e <strcmp>
f0110aaa:	83 c4 10             	add    $0x10,%esp
f0110aad:	85 c0                	test   %eax,%eax
f0110aaf:	0f 85 13 01 00 00    	jne    f0110bc8 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110ab5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab8:	83 c0 0c             	add    $0xc,%eax
f0110abb:	8b 00                	mov    (%eax),%eax
f0110abd:	83 ec 04             	sub    $0x4,%esp
f0110ac0:	6a 0a                	push   $0xa
f0110ac2:	6a 00                	push   $0x0
f0110ac4:	50                   	push   %eax
f0110ac5:	e8 18 f5 00 00       	call   f011ffe2 <strtol>
f0110aca:	83 c4 10             	add    $0x10,%esp
f0110acd:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110ad0:	e8 a7 f7 ff ff       	call   f011027c <isKHeapPlacementStrategyFIRSTFIT>
f0110ad5:	84 c0                	test   %al,%al
f0110ad7:	74 54                	je     f0110b2d <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110ad9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110add:	75 1a                	jne    f0110af9 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110adf:	83 ec 0c             	sub    $0xc,%esp
f0110ae2:	68 6c 83 12 f0       	push   $0xf012836c
f0110ae7:	e8 9f 04 ff ff       	call   f0100f8b <cprintf>
f0110aec:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110aef:	b8 00 00 00 00       	mov    $0x0,%eax
f0110af4:	e9 89 02 00 00       	jmp    f0110d82 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110af9:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110afd:	75 0a                	jne    f0110b09 <tst_kheap+0x20c>
				test_kmalloc();
f0110aff:	e8 ec 61 00 00       	call   f0116cf0 <test_kmalloc>
f0110b04:	e9 b5 00 00 00       	jmp    f0110bbe <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110b09:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110b0d:	75 0a                	jne    f0110b19 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110b0f:	e8 68 6d 00 00       	call   f011787c <test_kmalloc_firstfit1>
f0110b14:	e9 a5 00 00 00       	jmp    f0110bbe <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110b19:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110b1d:	0f 85 9b 00 00 00    	jne    f0110bbe <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110b23:	e8 38 78 00 00       	call   f0118360 <test_kmalloc_firstfit2>
f0110b28:	e9 91 00 00 00       	jmp    f0110bbe <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110b2d:	e8 5f f7 ff ff       	call   f0110291 <isKHeapPlacementStrategyBESTFIT>
f0110b32:	84 c0                	test   %al,%al
f0110b34:	74 47                	je     f0110b7d <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110b36:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b3a:	75 1a                	jne    f0110b56 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110b3c:	83 ec 0c             	sub    $0xc,%esp
f0110b3f:	68 bc 83 12 f0       	push   $0xf01283bc
f0110b44:	e8 42 04 ff ff       	call   f0100f8b <cprintf>
f0110b49:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110b4c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b51:	e9 2c 02 00 00       	jmp    f0110d82 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110b56:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110b5a:	75 07                	jne    f0110b63 <tst_kheap+0x266>
				test_kmalloc();
f0110b5c:	e8 8f 61 00 00       	call   f0116cf0 <test_kmalloc>
f0110b61:	eb 5b                	jmp    f0110bbe <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110b63:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110b67:	75 07                	jne    f0110b70 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110b69:	e8 2b c8 00 00       	call   f011d399 <test_kmalloc_bestfit1>
f0110b6e:	eb 4e                	jmp    f0110bbe <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110b70:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110b74:	75 48                	jne    f0110bbe <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110b76:	e8 3b c8 00 00       	call   f011d3b6 <test_kmalloc_bestfit2>
f0110b7b:	eb 41                	jmp    f0110bbe <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110b7d:	e8 24 f7 ff ff       	call   f01102a6 <isKHeapPlacementStrategyNEXTFIT>
f0110b82:	84 c0                	test   %al,%al
f0110b84:	74 38                	je     f0110bbe <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110b86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b8a:	75 1a                	jne    f0110ba6 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110b8c:	83 ec 0c             	sub    $0xc,%esp
f0110b8f:	68 0c 84 12 f0       	push   $0xf012840c
f0110b94:	e8 f2 03 ff ff       	call   f0100f8b <cprintf>
f0110b99:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110b9c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ba1:	e9 dc 01 00 00       	jmp    f0110d82 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110ba6:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110baa:	75 07                	jne    f0110bb3 <tst_kheap+0x2b6>
				test_kmalloc();
f0110bac:	e8 3f 61 00 00       	call   f0116cf0 <test_kmalloc>
f0110bb1:	eb 0b                	jmp    f0110bbe <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110bb3:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110bb7:	75 05                	jne    f0110bbe <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110bb9:	e8 be c7 00 00       	call   f011d37c <test_kmalloc_nextfit>
		}
		return 0;
f0110bbe:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bc3:	e9 ba 01 00 00       	jmp    f0110d82 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bcb:	83 c0 08             	add    $0x8,%eax
f0110bce:	8b 00                	mov    (%eax),%eax
f0110bd0:	83 ec 08             	sub    $0x8,%esp
f0110bd3:	68 5a 84 12 f0       	push   $0xf012845a
f0110bd8:	50                   	push   %eax
f0110bd9:	e8 b0 f1 00 00       	call   f011fd8e <strcmp>
f0110bde:	83 c4 10             	add    $0x10,%esp
f0110be1:	85 c0                	test   %eax,%eax
f0110be3:	75 2f                	jne    f0110c14 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110be5:	e8 92 f6 ff ff       	call   f011027c <isKHeapPlacementStrategyFIRSTFIT>
f0110bea:	84 c0                	test   %al,%al
f0110bec:	74 0f                	je     f0110bfd <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110bee:	e8 74 82 00 00       	call   f0118e67 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110bf3:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bf8:	e9 85 01 00 00       	jmp    f0110d82 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110bfd:	83 ec 04             	sub    $0x4,%esp
f0110c00:	68 60 84 12 f0       	push   $0xf0128460
f0110c05:	68 ac 01 00 00       	push   $0x1ac
f0110c0a:	68 47 80 12 f0       	push   $0xf0128047
f0110c0f:	e8 25 f7 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110c14:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c17:	83 c0 08             	add    $0x8,%eax
f0110c1a:	8b 00                	mov    (%eax),%eax
f0110c1c:	83 ec 08             	sub    $0x8,%esp
f0110c1f:	68 a1 84 12 f0       	push   $0xf01284a1
f0110c24:	50                   	push   %eax
f0110c25:	e8 64 f1 00 00       	call   f011fd8e <strcmp>
f0110c2a:	83 c4 10             	add    $0x10,%esp
f0110c2d:	85 c0                	test   %eax,%eax
f0110c2f:	75 28                	jne    f0110c59 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110c31:	e8 5b f6 ff ff       	call   f0110291 <isKHeapPlacementStrategyBESTFIT>
f0110c36:	84 c0                	test   %al,%al
f0110c38:	75 09                	jne    f0110c43 <tst_kheap+0x346>
f0110c3a:	e8 3d f6 ff ff       	call   f011027c <isKHeapPlacementStrategyFIRSTFIT>
f0110c3f:	84 c0                	test   %al,%al
f0110c41:	74 07                	je     f0110c4a <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110c43:	e8 ee 8a 00 00       	call   f0119736 <test_kfree_bestfirstfit>
f0110c48:	eb 05                	jmp    f0110c4f <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110c4a:	e8 a1 c7 00 00       	call   f011d3f0 <test_kfree>
		}
		return 0;
f0110c4f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c54:	e9 29 01 00 00       	jmp    f0110d82 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110c59:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c5c:	83 c0 08             	add    $0x8,%eax
f0110c5f:	8b 00                	mov    (%eax),%eax
f0110c61:	83 ec 08             	sub    $0x8,%esp
f0110c64:	68 a7 84 12 f0       	push   $0xf01284a7
f0110c69:	50                   	push   %eax
f0110c6a:	e8 1f f1 00 00       	call   f011fd8e <strcmp>
f0110c6f:	83 c4 10             	add    $0x10,%esp
f0110c72:	85 c0                	test   %eax,%eax
f0110c74:	75 0f                	jne    f0110c85 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110c76:	e8 17 a1 00 00       	call   f011ad92 <test_kheap_phys_addr>
		return 0;
f0110c7b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c80:	e9 fd 00 00 00       	jmp    f0110d82 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110c85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c88:	83 c0 08             	add    $0x8,%eax
f0110c8b:	8b 00                	mov    (%eax),%eax
f0110c8d:	83 ec 08             	sub    $0x8,%esp
f0110c90:	68 b1 84 12 f0       	push   $0xf01284b1
f0110c95:	50                   	push   %eax
f0110c96:	e8 f3 f0 00 00       	call   f011fd8e <strcmp>
f0110c9b:	83 c4 10             	add    $0x10,%esp
f0110c9e:	85 c0                	test   %eax,%eax
f0110ca0:	75 0f                	jne    f0110cb1 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110ca2:	e8 ce ae 00 00       	call   f011bb75 <test_kheap_virt_addr>
		return 0;
f0110ca7:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cac:	e9 d1 00 00 00       	jmp    f0110d82 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110cb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cb4:	83 c0 08             	add    $0x8,%eax
f0110cb7:	8b 00                	mov    (%eax),%eax
f0110cb9:	83 ec 08             	sub    $0x8,%esp
f0110cbc:	68 80 82 12 f0       	push   $0xf0128280
f0110cc1:	50                   	push   %eax
f0110cc2:	e8 c7 f0 00 00       	call   f011fd8e <strcmp>
f0110cc7:	83 c4 10             	add    $0x10,%esp
f0110cca:	85 c0                	test   %eax,%eax
f0110ccc:	0f 85 89 00 00 00    	jne    f0110d5b <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cd5:	83 c0 0c             	add    $0xc,%eax
f0110cd8:	8b 00                	mov    (%eax),%eax
f0110cda:	83 ec 04             	sub    $0x4,%esp
f0110cdd:	6a 0a                	push   $0xa
f0110cdf:	6a 00                	push   $0x0
f0110ce1:	50                   	push   %eax
f0110ce2:	e8 fb f2 00 00       	call   f011ffe2 <strtol>
f0110ce7:	83 c4 10             	add    $0x10,%esp
f0110cea:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110ced:	e8 8a f5 ff ff       	call   f011027c <isKHeapPlacementStrategyFIRSTFIT>
f0110cf2:	84 c0                	test   %al,%al
f0110cf4:	74 42                	je     f0110d38 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110cf6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110cfa:	75 17                	jne    f0110d13 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110cfc:	83 ec 0c             	sub    $0xc,%esp
f0110cff:	68 6c 83 12 f0       	push   $0xf012836c
f0110d04:	e8 82 02 ff ff       	call   f0100f8b <cprintf>
f0110d09:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110d0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d11:	eb 6f                	jmp    f0110d82 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110d13:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110d17:	75 07                	jne    f0110d20 <tst_kheap+0x423>
				test_krealloc_FF1();
f0110d19:	e8 50 c9 00 00       	call   f011d66e <test_krealloc_FF1>
f0110d1e:	eb 18                	jmp    f0110d38 <tst_kheap+0x43b>
			else if (testNum==2)
f0110d20:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110d24:	75 07                	jne    f0110d2d <tst_kheap+0x430>
				test_krealloc_FF2();
f0110d26:	e8 60 c9 00 00       	call   f011d68b <test_krealloc_FF2>
f0110d2b:	eb 0b                	jmp    f0110d38 <tst_kheap+0x43b>
			else if (testNum==3)
f0110d2d:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110d31:	75 05                	jne    f0110d38 <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110d33:	e8 70 c9 00 00       	call   f011d6a8 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0110d38:	e8 69 f5 ff ff       	call   f01102a6 <isKHeapPlacementStrategyNEXTFIT>
f0110d3d:	84 c0                	test   %al,%al
f0110d3f:	74 05                	je     f0110d46 <tst_kheap+0x449>
		{
			test_krealloc();
f0110d41:	e8 ee c8 00 00       	call   f011d634 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110d46:	e8 46 f5 ff ff       	call   f0110291 <isKHeapPlacementStrategyBESTFIT>
f0110d4b:	84 c0                	test   %al,%al
f0110d4d:	74 05                	je     f0110d54 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110d4f:	e8 fd c8 00 00       	call   f011d651 <test_krealloc_BF>
		}
		return 0;
f0110d54:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d59:	eb 27                	jmp    f0110d82 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f0110d5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d5e:	83 c0 08             	add    $0x8,%eax
f0110d61:	8b 00                	mov    (%eax),%eax
f0110d63:	83 ec 08             	sub    $0x8,%esp
f0110d66:	68 bb 84 12 f0       	push   $0xf01284bb
f0110d6b:	50                   	push   %eax
f0110d6c:	e8 1d f0 00 00       	call   f011fd8e <strcmp>
f0110d71:	83 c4 10             	add    $0x10,%esp
f0110d74:	85 c0                	test   %eax,%eax
f0110d76:	75 05                	jne    f0110d7d <tst_kheap+0x480>
	{
		test_ksbrk();
f0110d78:	e8 1d bb 00 00       	call   f011c89a <test_ksbrk>
	}
	return 0;
f0110d7d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d82:	c9                   	leave  
f0110d83:	c3                   	ret    

f0110d84 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0110d84:	55                   	push   %ebp
f0110d85:	89 e5                	mov    %esp,%ebp
f0110d87:	83 ec 28             	sub    $0x28,%esp
f0110d8a:	8b 45 14             	mov    0x14(%ebp),%eax
f0110d8d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110d90:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d93:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110d96:	74 1d                	je     f0110db5 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110d98:	83 ec 04             	sub    $0x4,%esp
f0110d9b:	ff 75 08             	pushl  0x8(%ebp)
f0110d9e:	ff 75 0c             	pushl  0xc(%ebp)
f0110da1:	68 c0 84 12 f0       	push   $0xf01284c0
f0110da6:	e8 e0 01 ff ff       	call   f0100f8b <cprintf>
f0110dab:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110dae:	b8 00 00 00 00       	mov    $0x0,%eax
f0110db3:	eb 55                	jmp    f0110e0a <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0110db8:	8b 40 fc             	mov    -0x4(%eax),%eax
f0110dbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110dbe:	8b 45 10             	mov    0x10(%ebp),%eax
f0110dc1:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110dc4:	8b 45 08             	mov    0x8(%ebp),%eax
f0110dc7:	01 d0                	add    %edx,%eax
f0110dc9:	8b 00                	mov    (%eax),%eax
f0110dcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110dce:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110dd2:	0b 45 10             	or     0x10(%ebp),%eax
f0110dd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0110dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ddb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110dde:	75 08                	jne    f0110de8 <check_block+0x64>
f0110de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110de3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110de6:	74 1d                	je     f0110e05 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0110de8:	ff 75 f0             	pushl  -0x10(%ebp)
f0110deb:	ff 75 f4             	pushl  -0xc(%ebp)
f0110dee:	ff 75 ec             	pushl  -0x14(%ebp)
f0110df1:	68 f0 84 12 f0       	push   $0xf01284f0
f0110df6:	e8 90 01 ff ff       	call   f0100f8b <cprintf>
f0110dfb:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110dfe:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e03:	eb 05                	jmp    f0110e0a <check_block+0x86>
	}
	return 1;
f0110e05:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110e0a:	c9                   	leave  
f0110e0b:	c3                   	ret    

f0110e0c <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110e0c:	55                   	push   %ebp
f0110e0d:	89 e5                	mov    %esp,%ebp
f0110e0f:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110e12:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0110e17:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110e1a:	74 20                	je     f0110e3c <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0110e1c:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0110e21:	83 ec 04             	sub    $0x4,%esp
f0110e24:	50                   	push   %eax
f0110e25:	ff 75 08             	pushl  0x8(%ebp)
f0110e28:	68 2c 85 12 f0       	push   $0xf012852c
f0110e2d:	e8 59 01 ff ff       	call   f0100f8b <cprintf>
f0110e32:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e35:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e3a:	eb 05                	jmp    f0110e41 <check_list_size+0x35>
	}
	return 1;
f0110e3c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110e41:	c9                   	leave  
f0110e42:	c3                   	ret    

f0110e43 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110e43:	55                   	push   %ebp
f0110e44:	89 e5                	mov    %esp,%ebp
f0110e46:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0110e49:	83 ec 04             	sub    $0x4,%esp
f0110e4c:	68 60 85 12 f0       	push   $0xf0128560
f0110e51:	6a 3f                	push   $0x3f
f0110e53:	68 c0 85 12 f0       	push   $0xf01285c0
f0110e58:	e8 dc f4 fe ff       	call   f0100339 <_panic>

f0110e5d <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f0110e5d:	55                   	push   %ebp
f0110e5e:	89 e5                	mov    %esp,%ebp
f0110e60:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e63:	83 ec 04             	sub    $0x4,%esp
f0110e66:	68 e4 85 12 f0       	push   $0xf01285e4
f0110e6b:	6a 61                	push   $0x61
f0110e6d:	68 c0 85 12 f0       	push   $0xf01285c0
f0110e72:	e8 c2 f4 fe ff       	call   f0100339 <_panic>

f0110e77 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0110e77:	55                   	push   %ebp
f0110e78:	89 e5                	mov    %esp,%ebp
f0110e7a:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e7d:	83 ec 04             	sub    $0x4,%esp
f0110e80:	68 34 86 12 f0       	push   $0xf0128634
f0110e85:	68 e7 00 00 00       	push   $0xe7
f0110e8a:	68 c0 85 12 f0       	push   $0xf01285c0
f0110e8f:	e8 a5 f4 fe ff       	call   f0100339 <_panic>

f0110e94 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0110e94:	55                   	push   %ebp
f0110e95:	89 e5                	mov    %esp,%ebp
f0110e97:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e9d:	83 ec 04             	sub    $0x4,%esp
f0110ea0:	68 88 86 12 f0       	push   $0xf0128688
f0110ea5:	68 88 01 00 00       	push   $0x188
f0110eaa:	68 c0 85 12 f0       	push   $0xf01285c0
f0110eaf:	e8 85 f4 fe ff       	call   f0100339 <_panic>

f0110eb4 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0110eb4:	55                   	push   %ebp
f0110eb5:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110eb7:	90                   	nop
f0110eb8:	5d                   	pop    %ebp
f0110eb9:	c3                   	ret    

f0110eba <test_free_block_FF>:

void test_free_block_FF()
{
f0110eba:	55                   	push   %ebp
f0110ebb:	89 e5                	mov    %esp,%ebp
f0110ebd:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110ec0:	83 ec 04             	sub    $0x4,%esp
f0110ec3:	68 dc 86 12 f0       	push   $0xf01286dc
f0110ec8:	68 4e 02 00 00       	push   $0x24e
f0110ecd:	68 c0 85 12 f0       	push   $0xf01285c0
f0110ed2:	e8 62 f4 fe ff       	call   f0100339 <_panic>

f0110ed7 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110ed7:	55                   	push   %ebp
f0110ed8:	89 e5                	mov    %esp,%ebp
f0110eda:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110edd:	83 ec 04             	sub    $0x4,%esp
f0110ee0:	68 dc 86 12 f0       	push   $0xf01286dc
f0110ee5:	68 9a 03 00 00       	push   $0x39a
f0110eea:	68 c0 85 12 f0       	push   $0xf01285c0
f0110eef:	e8 45 f4 fe ff       	call   f0100339 <_panic>

f0110ef4 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110ef4:	55                   	push   %ebp
f0110ef5:	89 e5                	mov    %esp,%ebp
f0110ef7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110efa:	83 ec 04             	sub    $0x4,%esp
f0110efd:	68 29 87 12 f0       	push   $0xf0128729
f0110f02:	68 ba 04 00 00       	push   $0x4ba
f0110f07:	68 c0 85 12 f0       	push   $0xf01285c0
f0110f0c:	e8 28 f4 fe ff       	call   f0100339 <_panic>

f0110f11 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110f11:	55                   	push   %ebp
f0110f12:	89 e5                	mov    %esp,%ebp
f0110f14:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f17:	83 ec 04             	sub    $0x4,%esp
f0110f1a:	68 dc 86 12 f0       	push   $0xf01286dc
f0110f1f:	68 c0 04 00 00       	push   $0x4c0
f0110f24:	68 c0 85 12 f0       	push   $0xf01285c0
f0110f29:	e8 0b f4 fe ff       	call   f0100339 <_panic>

f0110f2e <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110f2e:	55                   	push   %ebp
f0110f2f:	89 e5                	mov    %esp,%ebp
f0110f31:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f34:	83 ec 04             	sub    $0x4,%esp
f0110f37:	68 dc 86 12 f0       	push   $0xf01286dc
f0110f3c:	68 e7 05 00 00       	push   $0x5e7
f0110f41:	68 c0 85 12 f0       	push   $0xf01285c0
f0110f46:	e8 ee f3 fe ff       	call   f0100339 <_panic>

f0110f4b <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0110f4b:	55                   	push   %ebp
f0110f4c:	89 e5                	mov    %esp,%ebp
f0110f4e:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110f51:	e8 f0 aa ff ff       	call   f010ba46 <get_cpu_proc>
f0110f56:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0110f59:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110f5d:	75 16                	jne    f0110f75 <sys_check_LRU_lists+0x2a>
f0110f5f:	68 3c 87 12 f0       	push   $0xf012873c
f0110f64:	68 4c 87 12 f0       	push   $0xf012874c
f0110f69:	6a 10                	push   $0x10
f0110f6b:	68 61 87 12 f0       	push   $0xf0128761
f0110f70:	e8 c4 f3 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0110f75:	83 ec 0c             	sub    $0xc,%esp
f0110f78:	68 80 87 12 f0       	push   $0xf0128780
f0110f7d:	e8 09 00 ff ff       	call   f0100f8b <cprintf>
f0110f82:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0110f85:	83 ec 0c             	sub    $0xc,%esp
f0110f88:	ff 75 e0             	pushl  -0x20(%ebp)
f0110f8b:	e8 f4 94 ff ff       	call   f010a484 <env_page_ws_print>
f0110f90:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0110f93:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110f96:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0110f99:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0110fa0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0110fa7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110fab:	0f 84 a5 00 00 00    	je     f0111056 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0110fb1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110fb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110fbb:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110fc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110fc4:	eb 4a                	jmp    f0111010 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0110fc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110fc9:	8b 00                	mov    (%eax),%eax
f0110fcb:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110fce:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110fd1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110fd6:	89 c2                	mov    %eax,%edx
f0110fd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110fdb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110fe2:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fe5:	01 c8                	add    %ecx,%eax
f0110fe7:	8b 00                	mov    (%eax),%eax
f0110fe9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110fec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110fef:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110ff4:	39 c2                	cmp    %eax,%edx
f0110ff6:	74 09                	je     f0111001 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0110ff8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110fff:	eb 3e                	jmp    f011103f <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0111001:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111004:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111007:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011100d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111010:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111014:	74 08                	je     f011101e <sys_check_LRU_lists+0xd3>
f0111016:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111019:	8b 40 10             	mov    0x10(%eax),%eax
f011101c:	eb 05                	jmp    f0111023 <sys_check_LRU_lists+0xd8>
f011101e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111023:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111026:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011102c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011102f:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111035:	85 c0                	test   %eax,%eax
f0111037:	75 8d                	jne    f0110fc6 <sys_check_LRU_lists+0x7b>
f0111039:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011103d:	75 87                	jne    f0110fc6 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011103f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111042:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f0111048:	8b 45 10             	mov    0x10(%ebp),%eax
f011104b:	39 c2                	cmp    %eax,%edx
f011104d:	74 07                	je     f0111056 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011104f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111056:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011105a:	0f 84 a5 00 00 00    	je     f0111105 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0111060:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111067:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011106a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111070:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111073:	eb 4a                	jmp    f01110bf <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0111075:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111078:	8b 00                	mov    (%eax),%eax
f011107a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011107d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111080:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111085:	89 c2                	mov    %eax,%edx
f0111087:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011108a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111091:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111094:	01 c8                	add    %ecx,%eax
f0111096:	8b 00                	mov    (%eax),%eax
f0111098:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011109b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011109e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110a3:	39 c2                	cmp    %eax,%edx
f01110a5:	74 09                	je     f01110b0 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01110a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01110ae:	eb 3e                	jmp    f01110ee <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01110b0:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01110b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110b6:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01110bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110bf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01110c3:	74 08                	je     f01110cd <sys_check_LRU_lists+0x182>
f01110c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110c8:	8b 40 10             	mov    0x10(%eax),%eax
f01110cb:	eb 05                	jmp    f01110d2 <sys_check_LRU_lists+0x187>
f01110cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01110d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01110d5:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f01110db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110de:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01110e4:	85 c0                	test   %eax,%eax
f01110e6:	75 8d                	jne    f0111075 <sys_check_LRU_lists+0x12a>
f01110e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01110ec:	75 87                	jne    f0111075 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f01110ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110f1:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f01110f7:	8b 45 14             	mov    0x14(%ebp),%eax
f01110fa:	39 c2                	cmp    %eax,%edx
f01110fc:	74 07                	je     f0111105 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f01110fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111105:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111108:	23 45 f0             	and    -0x10(%ebp),%eax
}
f011110b:	c9                   	leave  
f011110c:	c3                   	ret    

f011110d <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f011110d:	55                   	push   %ebp
f011110e:	89 e5                	mov    %esp,%ebp
f0111110:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111113:	e8 2e a9 ff ff       	call   f010ba46 <get_cpu_proc>
f0111118:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f011111b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011111f:	75 16                	jne    f0111137 <sys_check_LRU_lists_free+0x2a>
f0111121:	68 3c 87 12 f0       	push   $0xf012873c
f0111126:	68 4c 87 12 f0       	push   $0xf012874c
f011112b:	6a 45                	push   $0x45
f011112d:	68 61 87 12 f0       	push   $0xf0128761
f0111132:	e8 02 f2 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111137:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011113a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f011113d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111144:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111147:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f011114d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111150:	eb 65                	jmp    f01111b7 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111152:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111159:	eb 3a                	jmp    f0111195 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011115b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011115e:	8b 00                	mov    (%eax),%eax
f0111160:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111163:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111166:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011116b:	89 c2                	mov    %eax,%edx
f011116d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111170:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111177:	8b 45 08             	mov    0x8(%ebp),%eax
f011117a:	01 c8                	add    %ecx,%eax
f011117c:	8b 00                	mov    (%eax),%eax
f011117e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111181:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111184:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111189:	39 c2                	cmp    %eax,%edx
f011118b:	75 05                	jne    f0111192 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f011118d:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111190:	eb 0b                	jmp    f011119d <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0111192:	ff 45 ec             	incl   -0x14(%ebp)
f0111195:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111198:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011119b:	7c be                	jl     f011115b <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011119d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01111a1:	7e 08                	jle    f01111ab <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01111a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01111a6:	e9 ed 00 00 00       	jmp    f0111298 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01111ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111ae:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01111b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111bb:	74 08                	je     f01111c5 <sys_check_LRU_lists_free+0xb8>
f01111bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01111c0:	8b 40 10             	mov    0x10(%eax),%eax
f01111c3:	eb 05                	jmp    f01111ca <sys_check_LRU_lists_free+0xbd>
f01111c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01111ca:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01111cd:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f01111d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111d6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01111dc:	85 c0                	test   %eax,%eax
f01111de:	0f 85 6e ff ff ff    	jne    f0111152 <sys_check_LRU_lists_free+0x45>
f01111e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111e8:	0f 85 64 ff ff ff    	jne    f0111152 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01111ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111f1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01111f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111fa:	eb 62                	jmp    f011125e <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01111fc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111203:	eb 3a                	jmp    f011123f <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111205:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111208:	8b 00                	mov    (%eax),%eax
f011120a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011120d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111210:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111215:	89 c2                	mov    %eax,%edx
f0111217:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011121a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111221:	8b 45 08             	mov    0x8(%ebp),%eax
f0111224:	01 c8                	add    %ecx,%eax
f0111226:	8b 00                	mov    (%eax),%eax
f0111228:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011122b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011122e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111233:	39 c2                	cmp    %eax,%edx
f0111235:	75 05                	jne    f011123c <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111237:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011123a:	eb 0b                	jmp    f0111247 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f011123c:	ff 45 e8             	incl   -0x18(%ebp)
f011123f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111242:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111245:	7c be                	jl     f0111205 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111247:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011124b:	7e 05                	jle    f0111252 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f011124d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111250:	eb 46                	jmp    f0111298 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111252:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111255:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011125b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011125e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111262:	74 08                	je     f011126c <sys_check_LRU_lists_free+0x15f>
f0111264:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111267:	8b 40 10             	mov    0x10(%eax),%eax
f011126a:	eb 05                	jmp    f0111271 <sys_check_LRU_lists_free+0x164>
f011126c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111271:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111274:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f011127a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011127d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111283:	85 c0                	test   %eax,%eax
f0111285:	0f 85 71 ff ff ff    	jne    f01111fc <sys_check_LRU_lists_free+0xef>
f011128b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011128f:	0f 85 67 ff ff ff    	jne    f01111fc <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0111295:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111298:	c9                   	leave  
f0111299:	c3                   	ret    

f011129a <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f011129a:	55                   	push   %ebp
f011129b:	89 e5                	mov    %esp,%ebp
f011129d:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f01112a0:	e8 a1 a7 ff ff       	call   f010ba46 <get_cpu_proc>
f01112a5:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01112a8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01112ac:	75 16                	jne    f01112c4 <sys_check_WS_list+0x2a>
f01112ae:	68 3c 87 12 f0       	push   $0xf012873c
f01112b3:	68 4c 87 12 f0       	push   $0xf012874c
f01112b8:	6a 79                	push   $0x79
f01112ba:	68 61 87 12 f0       	push   $0xf0128761
f01112bf:	e8 75 f0 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01112c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01112c7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01112ca:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01112d1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01112d5:	74 06                	je     f01112dd <sys_check_WS_list+0x43>
f01112d7:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01112db:	75 1f                	jne    f01112fc <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f01112dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01112e0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f01112e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112e9:	39 c2                	cmp    %eax,%edx
f01112eb:	74 0f                	je     f01112fc <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f01112ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01112f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112f7:	e9 15 03 00 00       	jmp    f0111611 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f01112fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111300:	74 39                	je     f011133b <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111302:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111305:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011130b:	8b 00                	mov    (%eax),%eax
f011130d:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0111310:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111313:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111318:	89 c2                	mov    %eax,%edx
f011131a:	8b 45 10             	mov    0x10(%ebp),%eax
f011131d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0111320:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111323:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111328:	39 c2                	cmp    %eax,%edx
f011132a:	74 0f                	je     f011133b <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f011132c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111336:	e9 d6 02 00 00       	jmp    f0111611 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f011133b:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011133f:	0f 85 3c 01 00 00    	jne    f0111481 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111345:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f011134c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111350:	74 4c                	je     f011139e <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111352:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111359:	eb 3b                	jmp    f0111396 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011135b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011135e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111365:	8b 45 08             	mov    0x8(%ebp),%eax
f0111368:	01 d0                	add    %edx,%eax
f011136a:	8b 00                	mov    (%eax),%eax
f011136c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011136f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111372:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111377:	89 c2                	mov    %eax,%edx
f0111379:	8b 45 10             	mov    0x10(%ebp),%eax
f011137c:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011137f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111382:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111387:	39 c2                	cmp    %eax,%edx
f0111389:	75 08                	jne    f0111393 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f011138b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011138e:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0111391:	eb 0b                	jmp    f011139e <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111393:	ff 45 e8             	incl   -0x18(%ebp)
f0111396:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111399:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011139c:	7c bd                	jl     f011135b <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f011139e:	83 ec 08             	sub    $0x8,%esp
f01113a1:	ff 75 ec             	pushl  -0x14(%ebp)
f01113a4:	68 a8 87 12 f0       	push   $0xf01287a8
f01113a9:	e8 dd fb fe ff       	call   f0100f8b <cprintf>
f01113ae:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01113b1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113b4:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01113ba:	85 c0                	test   %eax,%eax
f01113bc:	74 0e                	je     f01113cc <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f01113be:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113c1:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01113c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01113ca:	eb 0c                	jmp    f01113d8 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01113cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113cf:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01113d5:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f01113d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113db:	8b 00                	mov    (%eax),%eax
f01113dd:	83 ec 08             	sub    $0x8,%esp
f01113e0:	50                   	push   %eax
f01113e1:	68 c7 87 12 f0       	push   $0xf01287c7
f01113e6:	e8 a0 fb fe ff       	call   f0100f8b <cprintf>
f01113eb:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f01113ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01113f5:	eb 79                	jmp    f0111470 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01113f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113fa:	8b 00                	mov    (%eax),%eax
f01113fc:	89 45 b8             	mov    %eax,-0x48(%ebp)
f01113ff:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111402:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111407:	89 c2                	mov    %eax,%edx
f0111409:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011140c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111413:	8b 45 08             	mov    0x8(%ebp),%eax
f0111416:	01 c8                	add    %ecx,%eax
f0111418:	8b 00                	mov    (%eax),%eax
f011141a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f011141d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111420:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111425:	39 c2                	cmp    %eax,%edx
f0111427:	74 0c                	je     f0111435 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0111429:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111430:	e9 d9 01 00 00       	jmp    f011160e <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111435:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111438:	40                   	inc    %eax
f0111439:	89 c2                	mov    %eax,%edx
f011143b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011143e:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0111444:	89 d0                	mov    %edx,%eax
f0111446:	ba 00 00 00 00       	mov    $0x0,%edx
f011144b:	f7 f1                	div    %ecx
f011144d:	89 d0                	mov    %edx,%eax
f011144f:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111452:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111455:	8b 40 10             	mov    0x10(%eax),%eax
f0111458:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f011145b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011145f:	75 0c                	jne    f011146d <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111461:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111464:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011146a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f011146d:	ff 45 e4             	incl   -0x1c(%ebp)
f0111470:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111473:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111476:	0f 8c 7b ff ff ff    	jl     f01113f7 <sys_check_WS_list+0x15d>
f011147c:	e9 8d 01 00 00       	jmp    f011160e <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111481:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111485:	74 0a                	je     f0111491 <sys_check_WS_list+0x1f7>
f0111487:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f011148b:	0f 85 be 00 00 00    	jne    f011154f <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111491:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111498:	e9 a1 00 00 00       	jmp    f011153e <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f011149d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01114a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114a7:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01114ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114b0:	eb 47                	jmp    f01114f9 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01114b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114b5:	8b 00                	mov    (%eax),%eax
f01114b7:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01114ba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01114bd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114c2:	89 c2                	mov    %eax,%edx
f01114c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114c7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01114ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01114d1:	01 c8                	add    %ecx,%eax
f01114d3:	8b 00                	mov    (%eax),%eax
f01114d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01114d8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01114db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114e0:	39 c2                	cmp    %eax,%edx
f01114e2:	75 09                	jne    f01114ed <sys_check_WS_list+0x253>
				{
					found = 1;
f01114e4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01114eb:	eb 3b                	jmp    f0111528 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01114ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114f0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01114f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114fd:	74 08                	je     f0111507 <sys_check_WS_list+0x26d>
f01114ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111502:	8b 40 10             	mov    0x10(%eax),%eax
f0111505:	eb 05                	jmp    f011150c <sys_check_WS_list+0x272>
f0111507:	b8 00 00 00 00       	mov    $0x0,%eax
f011150c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011150f:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111515:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111518:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011151e:	85 c0                	test   %eax,%eax
f0111520:	75 90                	jne    f01114b2 <sys_check_WS_list+0x218>
f0111522:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111526:	75 8a                	jne    f01114b2 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0111528:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011152c:	75 0d                	jne    f011153b <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f011152e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111535:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111536:	e9 d3 00 00 00       	jmp    f011160e <sys_check_WS_list+0x374>
f011153b:	ff 45 e0             	incl   -0x20(%ebp)
f011153e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111541:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111544:	0f 8c 53 ff ff ff    	jl     f011149d <sys_check_WS_list+0x203>
f011154a:	e9 bf 00 00 00       	jmp    f011160e <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f011154f:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111553:	0f 85 b5 00 00 00    	jne    f011160e <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111559:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111560:	e9 9d 00 00 00       	jmp    f0111602 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0111565:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011156c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011156f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111575:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111578:	eb 47                	jmp    f01115c1 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011157a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011157d:	8b 00                	mov    (%eax),%eax
f011157f:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111582:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111585:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011158a:	89 c2                	mov    %eax,%edx
f011158c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011158f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111596:	8b 45 08             	mov    0x8(%ebp),%eax
f0111599:	01 c8                	add    %ecx,%eax
f011159b:	8b 00                	mov    (%eax),%eax
f011159d:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01115a0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01115a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115a8:	39 c2                	cmp    %eax,%edx
f01115aa:	75 09                	jne    f01115b5 <sys_check_WS_list+0x31b>
				{
					found = 1;
f01115ac:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01115b3:	eb 3b                	jmp    f01115f0 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115b8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01115be:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01115c5:	74 08                	je     f01115cf <sys_check_WS_list+0x335>
f01115c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115ca:	8b 40 10             	mov    0x10(%eax),%eax
f01115cd:	eb 05                	jmp    f01115d4 <sys_check_WS_list+0x33a>
f01115cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01115d4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01115d7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01115dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115e0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01115e6:	85 c0                	test   %eax,%eax
f01115e8:	75 90                	jne    f011157a <sys_check_WS_list+0x2e0>
f01115ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01115ee:	75 8a                	jne    f011157a <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01115f0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01115f4:	74 09                	je     f01115ff <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f01115f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01115fd:	eb 0f                	jmp    f011160e <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01115ff:	ff 45 d8             	incl   -0x28(%ebp)
f0111602:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111605:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111608:	0f 8c 57 ff ff ff    	jl     f0111565 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f011160e:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111611:	c9                   	leave  
f0111612:	c3                   	ret    

f0111613 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111613:	55                   	push   %ebp
f0111614:	89 e5                	mov    %esp,%ebp
f0111616:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0111619:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111620:	8b 15 64 2d 6c f0    	mov    0xf06c2d64,%edx
f0111626:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111629:	39 c2                	cmp    %eax,%edx
f011162b:	74 0a                	je     f0111637 <hasExpectedCommands+0x24>
		return 0;
f011162d:	b8 00 00 00 00       	mov    $0x0,%eax
f0111632:	e9 8b 00 00 00       	jmp    f01116c2 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0111637:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f011163c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011163f:	eb 55                	jmp    f0111696 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111641:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0111648:	eb 2a                	jmp    f0111674 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011164a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011164d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111654:	8b 45 08             	mov    0x8(%ebp),%eax
f0111657:	01 d0                	add    %edx,%eax
f0111659:	8b 10                	mov    (%eax),%edx
f011165b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011165e:	8b 00                	mov    (%eax),%eax
f0111660:	83 ec 08             	sub    $0x8,%esp
f0111663:	52                   	push   %edx
f0111664:	50                   	push   %eax
f0111665:	e8 24 e7 00 00       	call   f011fd8e <strcmp>
f011166a:	83 c4 10             	add    $0x10,%esp
f011166d:	85 c0                	test   %eax,%eax
f011166f:	74 0d                	je     f011167e <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111671:	ff 45 f0             	incl   -0x10(%ebp)
f0111674:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111677:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011167a:	7c ce                	jl     f011164a <hasExpectedCommands+0x37>
f011167c:	eb 01                	jmp    f011167f <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f011167e:	90                   	nop
		if (i == commandsCount)
f011167f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111682:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111685:	75 07                	jne    f011168e <hasExpectedCommands+0x7b>
			return 0;
f0111687:	b8 00 00 00 00       	mov    $0x0,%eax
f011168c:	eb 34                	jmp    f01116c2 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f011168e:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0111693:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111696:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011169a:	74 08                	je     f01116a4 <hasExpectedCommands+0x91>
f011169c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011169f:	8b 40 10             	mov    0x10(%eax),%eax
f01116a2:	eb 05                	jmp    f01116a9 <hasExpectedCommands+0x96>
f01116a4:	b8 00 00 00 00       	mov    $0x0,%eax
f01116a9:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f01116ae:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f01116b3:	85 c0                	test   %eax,%eax
f01116b5:	75 8a                	jne    f0111641 <hasExpectedCommands+0x2e>
f01116b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01116bb:	75 84                	jne    f0111641 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01116bd:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01116c2:	c9                   	leave  
f01116c3:	c3                   	ret    

f01116c4 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01116c4:	55                   	push   %ebp
f01116c5:	89 e5                	mov    %esp,%ebp
f01116c7:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01116ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01116d1:	eb 2e                	jmp    f0111701 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01116d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01116d6:	89 d0                	mov    %edx,%eax
f01116d8:	01 c0                	add    %eax,%eax
f01116da:	01 d0                	add    %edx,%eax
f01116dc:	c1 e0 03             	shl    $0x3,%eax
f01116df:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01116e4:	8b 00                	mov    (%eax),%eax
f01116e6:	83 ec 08             	sub    $0x8,%esp
f01116e9:	ff 75 08             	pushl  0x8(%ebp)
f01116ec:	50                   	push   %eax
f01116ed:	e8 9c e6 00 00       	call   f011fd8e <strcmp>
f01116f2:	83 c4 10             	add    $0x10,%esp
f01116f5:	85 c0                	test   %eax,%eax
f01116f7:	75 05                	jne    f01116fe <getIndexOfCommand+0x3a>
			return i;
f01116f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01116fc:	eb 14                	jmp    f0111712 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01116fe:	ff 45 f4             	incl   -0xc(%ebp)
f0111701:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111704:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f0111709:	39 c2                	cmp    %eax,%edx
f011170b:	72 c6                	jb     f01116d3 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011170d:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111712:	c9                   	leave  
f0111713:	c3                   	ret    

f0111714 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111714:	55                   	push   %ebp
f0111715:	89 e5                	mov    %esp,%ebp
f0111717:	57                   	push   %edi
f0111718:	56                   	push   %esi
f0111719:	53                   	push   %ebx
f011171a:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111720:	83 ec 0c             	sub    $0xc,%esp
f0111723:	68 00 88 12 f0       	push   $0xf0128800
f0111728:	e8 5e f8 fe ff       	call   f0100f8b <cprintf>
f011172d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111730:	83 ec 0c             	sub    $0xc,%esp
f0111733:	68 24 88 12 f0       	push   $0xf0128824
f0111738:	e8 4e f8 fe ff       	call   f0100f8b <cprintf>
f011173d:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111740:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111747:	c7 45 8c 3f 88 12 f0 	movl   $0xf012883f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f011174e:	83 ec 08             	sub    $0x8,%esp
f0111751:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111754:	50                   	push   %eax
f0111755:	6a 01                	push   $0x1
f0111757:	e8 74 0a ff ff       	call   f01021d0 <process_command>
f011175c:	83 c4 10             	add    $0x10,%esp
f011175f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111762:	83 ec 0c             	sub    $0xc,%esp
f0111765:	68 4c 88 12 f0       	push   $0xf012884c
f011176a:	e8 1c f8 fe ff       	call   f0100f8b <cprintf>
f011176f:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111772:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111775:	83 ec 0c             	sub    $0xc,%esp
f0111778:	50                   	push   %eax
f0111779:	e8 46 ff ff ff       	call   f01116c4 <getIndexOfCommand>
f011177e:	83 c4 10             	add    $0x10,%esp
f0111781:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111784:	75 0f                	jne    f0111795 <TestAutoCompleteCommand+0x81>
f0111786:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f011178b:	85 c0                	test   %eax,%eax
f011178d:	75 06                	jne    f0111795 <TestAutoCompleteCommand+0x81>
		eval += 15;
f011178f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111793:	eb 10                	jmp    f01117a5 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111795:	83 ec 0c             	sub    $0xc,%esp
f0111798:	68 7c 88 12 f0       	push   $0xf012887c
f011179d:	e8 e9 f7 fe ff       	call   f0100f8b <cprintf>
f01117a2:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01117a5:	83 ec 0c             	sub    $0xc,%esp
f01117a8:	68 cc 88 12 f0       	push   $0xf01288cc
f01117ad:	e8 d9 f7 fe ff       	call   f0100f8b <cprintf>
f01117b2:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01117b5:	c7 45 88 f2 88 12 f0 	movl   $0xf01288f2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01117bc:	83 ec 08             	sub    $0x8,%esp
f01117bf:	8d 45 88             	lea    -0x78(%ebp),%eax
f01117c2:	50                   	push   %eax
f01117c3:	6a 01                	push   $0x1
f01117c5:	e8 06 0a ff ff       	call   f01021d0 <process_command>
f01117ca:	83 c4 10             	add    $0x10,%esp
f01117cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01117d0:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01117d4:	75 30                	jne    f0111806 <TestAutoCompleteCommand+0xf2>
f01117d6:	8d 45 90             	lea    -0x70(%ebp),%eax
f01117d9:	bb d0 8c 12 f0       	mov    $0xf0128cd0,%ebx
f01117de:	ba 03 00 00 00       	mov    $0x3,%edx
f01117e3:	89 c7                	mov    %eax,%edi
f01117e5:	89 de                	mov    %ebx,%esi
f01117e7:	89 d1                	mov    %edx,%ecx
f01117e9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01117eb:	83 ec 08             	sub    $0x8,%esp
f01117ee:	6a 03                	push   $0x3
f01117f0:	8d 45 90             	lea    -0x70(%ebp),%eax
f01117f3:	50                   	push   %eax
f01117f4:	e8 1a fe ff ff       	call   f0111613 <hasExpectedCommands>
f01117f9:	83 c4 10             	add    $0x10,%esp
f01117fc:	85 c0                	test   %eax,%eax
f01117fe:	74 06                	je     f0111806 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111800:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111804:	eb 10                	jmp    f0111816 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111806:	83 ec 0c             	sub    $0xc,%esp
f0111809:	68 f8 88 12 f0       	push   $0xf01288f8
f011180e:	e8 78 f7 fe ff       	call   f0100f8b <cprintf>
f0111813:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111816:	83 ec 0c             	sub    $0xc,%esp
f0111819:	68 48 89 12 f0       	push   $0xf0128948
f011181e:	e8 68 f7 fe ff       	call   f0100f8b <cprintf>
f0111823:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111826:	c7 45 84 6d 89 12 f0 	movl   $0xf012896d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011182d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111830:	83 ec 04             	sub    $0x4,%esp
f0111833:	50                   	push   %eax
f0111834:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111837:	50                   	push   %eax
f0111838:	68 70 89 12 f0       	push   $0xf0128970
f011183d:	e8 49 f7 fe ff       	call   f0100f8b <cprintf>
f0111842:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111845:	83 ec 08             	sub    $0x8,%esp
f0111848:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011184b:	50                   	push   %eax
f011184c:	6a 01                	push   $0x1
f011184e:	e8 7d 09 ff ff       	call   f01021d0 <process_command>
f0111853:	83 c4 10             	add    $0x10,%esp
f0111856:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0111859:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f011185d:	75 1b                	jne    f011187a <TestAutoCompleteCommand+0x166>
f011185f:	83 ec 08             	sub    $0x8,%esp
f0111862:	6a 01                	push   $0x1
f0111864:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111867:	50                   	push   %eax
f0111868:	e8 a6 fd ff ff       	call   f0111613 <hasExpectedCommands>
f011186d:	83 c4 10             	add    $0x10,%esp
f0111870:	85 c0                	test   %eax,%eax
f0111872:	74 06                	je     f011187a <TestAutoCompleteCommand+0x166>
		eval += 15;
f0111874:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111878:	eb 10                	jmp    f011188a <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f011187a:	83 ec 0c             	sub    $0xc,%esp
f011187d:	68 90 89 12 f0       	push   $0xf0128990
f0111882:	e8 04 f7 fe ff       	call   f0100f8b <cprintf>
f0111887:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f011188a:	83 ec 0c             	sub    $0xc,%esp
f011188d:	68 e8 89 12 f0       	push   $0xf01289e8
f0111892:	e8 f4 f6 fe ff       	call   f0100f8b <cprintf>
f0111897:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f011189a:	c7 45 80 0e 8a 12 f0 	movl   $0xf0128a0e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01118a1:	83 ec 08             	sub    $0x8,%esp
f01118a4:	8d 45 80             	lea    -0x80(%ebp),%eax
f01118a7:	50                   	push   %eax
f01118a8:	6a 01                	push   $0x1
f01118aa:	e8 21 09 ff ff       	call   f01021d0 <process_command>
f01118af:	83 c4 10             	add    $0x10,%esp
f01118b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01118b5:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01118b9:	75 0f                	jne    f01118ca <TestAutoCompleteCommand+0x1b6>
f01118bb:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f01118c0:	85 c0                	test   %eax,%eax
f01118c2:	75 06                	jne    f01118ca <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f01118c4:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01118c8:	eb 10                	jmp    f01118da <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01118ca:	83 ec 0c             	sub    $0xc,%esp
f01118cd:	68 14 8a 12 f0       	push   $0xf0128a14
f01118d2:	e8 b4 f6 fe ff       	call   f0100f8b <cprintf>
f01118d7:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f01118da:	83 ec 0c             	sub    $0xc,%esp
f01118dd:	68 64 8a 12 f0       	push   $0xf0128a64
f01118e2:	e8 a4 f6 fe ff       	call   f0100f8b <cprintf>
f01118e7:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f01118ea:	c7 85 7c ff ff ff 89 	movl   $0xf0128a89,-0x84(%ebp)
f01118f1:	8a 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f01118f4:	83 ec 08             	sub    $0x8,%esp
f01118f7:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f01118fd:	50                   	push   %eax
f01118fe:	6a 01                	push   $0x1
f0111900:	e8 cb 08 ff ff       	call   f01021d0 <process_command>
f0111905:	83 c4 10             	add    $0x10,%esp
f0111908:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011190b:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011190f:	75 30                	jne    f0111941 <TestAutoCompleteCommand+0x22d>
f0111911:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111914:	bb 60 8d 12 f0       	mov    $0xf0128d60,%ebx
f0111919:	ba 0c 00 00 00       	mov    $0xc,%edx
f011191e:	89 c7                	mov    %eax,%edi
f0111920:	89 de                	mov    %ebx,%esi
f0111922:	89 d1                	mov    %edx,%ecx
f0111924:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111926:	83 ec 08             	sub    $0x8,%esp
f0111929:	6a 0c                	push   $0xc
f011192b:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011192e:	50                   	push   %eax
f011192f:	e8 df fc ff ff       	call   f0111613 <hasExpectedCommands>
f0111934:	83 c4 10             	add    $0x10,%esp
f0111937:	85 c0                	test   %eax,%eax
f0111939:	74 06                	je     f0111941 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011193b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011193f:	eb 10                	jmp    f0111951 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111941:	83 ec 0c             	sub    $0xc,%esp
f0111944:	68 8c 8a 12 f0       	push   $0xf0128a8c
f0111949:	e8 3d f6 fe ff       	call   f0100f8b <cprintf>
f011194e:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111951:	83 ec 0c             	sub    $0xc,%esp
f0111954:	68 e4 8a 12 f0       	push   $0xf0128ae4
f0111959:	e8 2d f6 fe ff       	call   f0100f8b <cprintf>
f011195e:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111961:	c7 85 78 ff ff ff 09 	movl   $0xf0128b09,-0x88(%ebp)
f0111968:	8b 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f011196b:	83 ec 08             	sub    $0x8,%esp
f011196e:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111974:	50                   	push   %eax
f0111975:	6a 01                	push   $0x1
f0111977:	e8 54 08 ff ff       	call   f01021d0 <process_command>
f011197c:	83 c4 10             	add    $0x10,%esp
f011197f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111982:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111986:	75 30                	jne    f01119b8 <TestAutoCompleteCommand+0x2a4>
f0111988:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011198b:	bb a8 8d 12 f0       	mov    $0xf0128da8,%ebx
f0111990:	ba 05 00 00 00       	mov    $0x5,%edx
f0111995:	89 c7                	mov    %eax,%edi
f0111997:	89 de                	mov    %ebx,%esi
f0111999:	89 d1                	mov    %edx,%ecx
f011199b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011199d:	83 ec 08             	sub    $0x8,%esp
f01119a0:	6a 05                	push   $0x5
f01119a2:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01119a5:	50                   	push   %eax
f01119a6:	e8 68 fc ff ff       	call   f0111613 <hasExpectedCommands>
f01119ab:	83 c4 10             	add    $0x10,%esp
f01119ae:	85 c0                	test   %eax,%eax
f01119b0:	74 06                	je     f01119b8 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f01119b2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01119b6:	eb 10                	jmp    f01119c8 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01119b8:	83 ec 0c             	sub    $0xc,%esp
f01119bb:	68 0c 8b 12 f0       	push   $0xf0128b0c
f01119c0:	e8 c6 f5 fe ff       	call   f0100f8b <cprintf>
f01119c5:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f01119c8:	83 ec 0c             	sub    $0xc,%esp
f01119cb:	68 64 8b 12 f0       	push   $0xf0128b64
f01119d0:	e8 b6 f5 fe ff       	call   f0100f8b <cprintf>
f01119d5:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f01119d8:	c7 85 70 ff ff ff 90 	movl   $0xf0128b90,-0x90(%ebp)
f01119df:	8b 12 f0 
f01119e2:	c7 85 74 ff ff ff 95 	movl   $0xf0128b95,-0x8c(%ebp)
f01119e9:	8b 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f01119ec:	83 ec 08             	sub    $0x8,%esp
f01119ef:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01119f5:	50                   	push   %eax
f01119f6:	6a 02                	push   $0x2
f01119f8:	e8 d3 07 ff ff       	call   f01021d0 <process_command>
f01119fd:	83 c4 10             	add    $0x10,%esp
f0111a00:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111a03:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111a09:	83 ec 0c             	sub    $0xc,%esp
f0111a0c:	50                   	push   %eax
f0111a0d:	e8 b2 fc ff ff       	call   f01116c4 <getIndexOfCommand>
f0111a12:	83 c4 10             	add    $0x10,%esp
f0111a15:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111a18:	75 0f                	jne    f0111a29 <TestAutoCompleteCommand+0x315>
f0111a1a:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0111a1f:	85 c0                	test   %eax,%eax
f0111a21:	75 06                	jne    f0111a29 <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111a23:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a27:	eb 10                	jmp    f0111a39 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a29:	83 ec 0c             	sub    $0xc,%esp
f0111a2c:	68 9c 8b 12 f0       	push   $0xf0128b9c
f0111a31:	e8 55 f5 fe ff       	call   f0100f8b <cprintf>
f0111a36:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111a39:	83 ec 0c             	sub    $0xc,%esp
f0111a3c:	68 ec 8b 12 f0       	push   $0xf0128bec
f0111a41:	e8 45 f5 fe ff       	call   f0100f8b <cprintf>
f0111a46:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111a49:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111a4f:	bb d0 8d 12 f0       	mov    $0xf0128dd0,%ebx
f0111a54:	ba 03 00 00 00       	mov    $0x3,%edx
f0111a59:	89 c7                	mov    %eax,%edi
f0111a5b:	89 de                	mov    %ebx,%esi
f0111a5d:	89 d1                	mov    %edx,%ecx
f0111a5f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111a61:	83 ec 08             	sub    $0x8,%esp
f0111a64:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111a6a:	50                   	push   %eax
f0111a6b:	6a 03                	push   $0x3
f0111a6d:	e8 5e 07 ff ff       	call   f01021d0 <process_command>
f0111a72:	83 c4 10             	add    $0x10,%esp
f0111a75:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111a78:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111a7e:	83 ec 0c             	sub    $0xc,%esp
f0111a81:	50                   	push   %eax
f0111a82:	e8 3d fc ff ff       	call   f01116c4 <getIndexOfCommand>
f0111a87:	83 c4 10             	add    $0x10,%esp
f0111a8a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111a8d:	75 0f                	jne    f0111a9e <TestAutoCompleteCommand+0x38a>
f0111a8f:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0111a94:	85 c0                	test   %eax,%eax
f0111a96:	75 06                	jne    f0111a9e <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111a98:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a9c:	eb 10                	jmp    f0111aae <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a9e:	83 ec 0c             	sub    $0xc,%esp
f0111aa1:	68 20 8c 12 f0       	push   $0xf0128c20
f0111aa6:	e8 e0 f4 fe ff       	call   f0100f8b <cprintf>
f0111aab:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111aae:	83 ec 08             	sub    $0x8,%esp
f0111ab1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111ab4:	68 70 8c 12 f0       	push   $0xf0128c70
f0111ab9:	e8 cd f4 fe ff       	call   f0100f8b <cprintf>
f0111abe:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111ac1:	83 ec 0c             	sub    $0xc,%esp
f0111ac4:	68 a0 8c 12 f0       	push   $0xf0128ca0
f0111ac9:	e8 bd f4 fe ff       	call   f0100f8b <cprintf>
f0111ace:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111ad1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111ad6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111ad9:	5b                   	pop    %ebx
f0111ada:	5e                   	pop    %esi
f0111adb:	5f                   	pop    %edi
f0111adc:	5d                   	pop    %ebp
f0111add:	c3                   	ret    

f0111ade <test_str2lower_function>:

int test_str2lower_function()
{
f0111ade:	55                   	push   %ebp
f0111adf:	89 e5                	mov    %esp,%ebp
f0111ae1:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111ae7:	83 ec 0c             	sub    $0xc,%esp
f0111aea:	68 dc 8d 12 f0       	push   $0xf0128ddc
f0111aef:	e8 97 f4 fe ff       	call   f0100f8b <cprintf>
f0111af4:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111af7:	83 ec 0c             	sub    $0xc,%esp
f0111afa:	68 fd 8d 12 f0       	push   $0xf0128dfd
f0111aff:	e8 87 f4 fe ff       	call   f0100f8b <cprintf>
f0111b04:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111b07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111b0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111b15:	c7 45 ec 17 8e 12 f0 	movl   $0xf0128e17,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111b1c:	83 ec 08             	sub    $0x8,%esp
f0111b1f:	ff 75 ec             	pushl  -0x14(%ebp)
f0111b22:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111b28:	50                   	push   %eax
f0111b29:	e8 3d e8 00 00       	call   f012036b <str2lower>
f0111b2e:	83 c4 10             	add    $0x10,%esp
f0111b31:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111b34:	83 ec 0c             	sub    $0xc,%esp
f0111b37:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b3a:	e8 43 e1 00 00       	call   f011fc82 <strlen>
f0111b3f:	83 c4 10             	add    $0x10,%esp
f0111b42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111b45:	83 ec 08             	sub    $0x8,%esp
f0111b48:	68 22 8e 12 f0       	push   $0xf0128e22
f0111b4d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b50:	e8 39 e2 00 00       	call   f011fd8e <strcmp>
f0111b55:	83 c4 10             	add    $0x10,%esp
f0111b58:	85 c0                	test   %eax,%eax
f0111b5a:	75 13                	jne    f0111b6f <test_str2lower_function+0x91>
f0111b5c:	83 ec 0c             	sub    $0xc,%esp
f0111b5f:	ff 75 ec             	pushl  -0x14(%ebp)
f0111b62:	e8 1b e1 00 00       	call   f011fc82 <strlen>
f0111b67:	83 c4 10             	add    $0x10,%esp
f0111b6a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b6d:	74 15                	je     f0111b84 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111b6f:	83 ec 08             	sub    $0x8,%esp
f0111b72:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b75:	68 30 8e 12 f0       	push   $0xf0128e30
f0111b7a:	e8 0c f4 fe ff       	call   f0100f8b <cprintf>
f0111b7f:	83 c4 10             	add    $0x10,%esp
f0111b82:	eb 04                	jmp    f0111b88 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111b84:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111b88:	c7 45 e0 92 8e 12 f0 	movl   $0xf0128e92,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111b8f:	83 ec 08             	sub    $0x8,%esp
f0111b92:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b95:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111b9b:	50                   	push   %eax
f0111b9c:	e8 ca e7 00 00       	call   f012036b <str2lower>
f0111ba1:	83 c4 10             	add    $0x10,%esp
f0111ba4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ba7:	83 ec 0c             	sub    $0xc,%esp
f0111baa:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bad:	e8 d0 e0 00 00       	call   f011fc82 <strlen>
f0111bb2:	83 c4 10             	add    $0x10,%esp
f0111bb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111bb8:	83 ec 08             	sub    $0x8,%esp
f0111bbb:	68 92 8e 12 f0       	push   $0xf0128e92
f0111bc0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bc3:	e8 c6 e1 00 00       	call   f011fd8e <strcmp>
f0111bc8:	83 c4 10             	add    $0x10,%esp
f0111bcb:	85 c0                	test   %eax,%eax
f0111bcd:	75 13                	jne    f0111be2 <test_str2lower_function+0x104>
f0111bcf:	83 ec 0c             	sub    $0xc,%esp
f0111bd2:	ff 75 e0             	pushl  -0x20(%ebp)
f0111bd5:	e8 a8 e0 00 00       	call   f011fc82 <strlen>
f0111bda:	83 c4 10             	add    $0x10,%esp
f0111bdd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111be0:	74 15                	je     f0111bf7 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111be2:	83 ec 08             	sub    $0x8,%esp
f0111be5:	ff 75 e8             	pushl  -0x18(%ebp)
f0111be8:	68 94 8e 12 f0       	push   $0xf0128e94
f0111bed:	e8 99 f3 fe ff       	call   f0100f8b <cprintf>
f0111bf2:	83 c4 10             	add    $0x10,%esp
f0111bf5:	eb 04                	jmp    f0111bfb <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111bf7:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111bfb:	c7 45 dc ec 8e 12 f0 	movl   $0xf0128eec,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111c02:	83 ec 08             	sub    $0x8,%esp
f0111c05:	ff 75 dc             	pushl  -0x24(%ebp)
f0111c08:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111c0e:	50                   	push   %eax
f0111c0f:	e8 57 e7 00 00       	call   f012036b <str2lower>
f0111c14:	83 c4 10             	add    $0x10,%esp
f0111c17:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c1a:	83 ec 0c             	sub    $0xc,%esp
f0111c1d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c20:	e8 5d e0 00 00       	call   f011fc82 <strlen>
f0111c25:	83 c4 10             	add    $0x10,%esp
f0111c28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111c2b:	83 ec 08             	sub    $0x8,%esp
f0111c2e:	68 ec 8e 12 f0       	push   $0xf0128eec
f0111c33:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c36:	e8 53 e1 00 00       	call   f011fd8e <strcmp>
f0111c3b:	83 c4 10             	add    $0x10,%esp
f0111c3e:	85 c0                	test   %eax,%eax
f0111c40:	75 13                	jne    f0111c55 <test_str2lower_function+0x177>
f0111c42:	83 ec 0c             	sub    $0xc,%esp
f0111c45:	ff 75 dc             	pushl  -0x24(%ebp)
f0111c48:	e8 35 e0 00 00       	call   f011fc82 <strlen>
f0111c4d:	83 c4 10             	add    $0x10,%esp
f0111c50:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111c53:	74 15                	je     f0111c6a <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111c55:	83 ec 08             	sub    $0x8,%esp
f0111c58:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c5b:	68 f8 8e 12 f0       	push   $0xf0128ef8
f0111c60:	e8 26 f3 fe ff       	call   f0100f8b <cprintf>
f0111c65:	83 c4 10             	add    $0x10,%esp
f0111c68:	eb 04                	jmp    f0111c6e <test_str2lower_function+0x190>
	else
		eval += 15;
f0111c6a:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111c6e:	c7 45 d8 5b 8f 12 f0 	movl   $0xf0128f5b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111c75:	83 ec 08             	sub    $0x8,%esp
f0111c78:	ff 75 d8             	pushl  -0x28(%ebp)
f0111c7b:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111c81:	50                   	push   %eax
f0111c82:	e8 e4 e6 00 00       	call   f012036b <str2lower>
f0111c87:	83 c4 10             	add    $0x10,%esp
f0111c8a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c8d:	83 ec 0c             	sub    $0xc,%esp
f0111c90:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c93:	e8 ea df 00 00       	call   f011fc82 <strlen>
f0111c98:	83 c4 10             	add    $0x10,%esp
f0111c9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111c9e:	83 ec 08             	sub    $0x8,%esp
f0111ca1:	68 5b 8f 12 f0       	push   $0xf0128f5b
f0111ca6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ca9:	e8 e0 e0 00 00       	call   f011fd8e <strcmp>
f0111cae:	83 c4 10             	add    $0x10,%esp
f0111cb1:	85 c0                	test   %eax,%eax
f0111cb3:	75 13                	jne    f0111cc8 <test_str2lower_function+0x1ea>
f0111cb5:	83 ec 0c             	sub    $0xc,%esp
f0111cb8:	ff 75 d8             	pushl  -0x28(%ebp)
f0111cbb:	e8 c2 df 00 00       	call   f011fc82 <strlen>
f0111cc0:	83 c4 10             	add    $0x10,%esp
f0111cc3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111cc6:	74 15                	je     f0111cdd <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111cc8:	83 ec 08             	sub    $0x8,%esp
f0111ccb:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cce:	68 68 8f 12 f0       	push   $0xf0128f68
f0111cd3:	e8 b3 f2 fe ff       	call   f0100f8b <cprintf>
f0111cd8:	83 c4 10             	add    $0x10,%esp
f0111cdb:	eb 04                	jmp    f0111ce1 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111cdd:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111ce1:	c7 45 d4 ca 8f 12 f0 	movl   $0xf0128fca,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111ce8:	83 ec 08             	sub    $0x8,%esp
f0111ceb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111cee:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111cf4:	50                   	push   %eax
f0111cf5:	e8 71 e6 00 00       	call   f012036b <str2lower>
f0111cfa:	83 c4 10             	add    $0x10,%esp
f0111cfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d00:	83 ec 0c             	sub    $0xc,%esp
f0111d03:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d06:	e8 77 df 00 00       	call   f011fc82 <strlen>
f0111d0b:	83 c4 10             	add    $0x10,%esp
f0111d0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111d11:	83 ec 08             	sub    $0x8,%esp
f0111d14:	68 e0 8f 12 f0       	push   $0xf0128fe0
f0111d19:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d1c:	e8 6d e0 00 00       	call   f011fd8e <strcmp>
f0111d21:	83 c4 10             	add    $0x10,%esp
f0111d24:	85 c0                	test   %eax,%eax
f0111d26:	75 13                	jne    f0111d3b <test_str2lower_function+0x25d>
f0111d28:	83 ec 0c             	sub    $0xc,%esp
f0111d2b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111d2e:	e8 4f df 00 00       	call   f011fc82 <strlen>
f0111d33:	83 c4 10             	add    $0x10,%esp
f0111d36:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d39:	74 15                	je     f0111d50 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111d3b:	83 ec 08             	sub    $0x8,%esp
f0111d3e:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d41:	68 f8 8f 12 f0       	push   $0xf0128ff8
f0111d46:	e8 40 f2 fe ff       	call   f0100f8b <cprintf>
f0111d4b:	83 c4 10             	add    $0x10,%esp
f0111d4e:	eb 04                	jmp    f0111d54 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111d50:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111d54:	c7 45 d0 65 90 12 f0 	movl   $0xf0129065,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111d5b:	83 ec 08             	sub    $0x8,%esp
f0111d5e:	ff 75 d0             	pushl  -0x30(%ebp)
f0111d61:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111d67:	50                   	push   %eax
f0111d68:	e8 fe e5 00 00       	call   f012036b <str2lower>
f0111d6d:	83 c4 10             	add    $0x10,%esp
f0111d70:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d73:	83 ec 0c             	sub    $0xc,%esp
f0111d76:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d79:	e8 04 df 00 00       	call   f011fc82 <strlen>
f0111d7e:	83 c4 10             	add    $0x10,%esp
f0111d81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111d84:	83 ec 08             	sub    $0x8,%esp
f0111d87:	68 71 90 12 f0       	push   $0xf0129071
f0111d8c:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d8f:	e8 fa df 00 00       	call   f011fd8e <strcmp>
f0111d94:	83 c4 10             	add    $0x10,%esp
f0111d97:	85 c0                	test   %eax,%eax
f0111d99:	75 13                	jne    f0111dae <test_str2lower_function+0x2d0>
f0111d9b:	83 ec 0c             	sub    $0xc,%esp
f0111d9e:	ff 75 d0             	pushl  -0x30(%ebp)
f0111da1:	e8 dc de 00 00       	call   f011fc82 <strlen>
f0111da6:	83 c4 10             	add    $0x10,%esp
f0111da9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111dac:	74 15                	je     f0111dc3 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111dae:	83 ec 08             	sub    $0x8,%esp
f0111db1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111db4:	68 80 90 12 f0       	push   $0xf0129080
f0111db9:	e8 cd f1 fe ff       	call   f0100f8b <cprintf>
f0111dbe:	83 c4 10             	add    $0x10,%esp
f0111dc1:	eb 04                	jmp    f0111dc7 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111dc3:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111dc7:	c7 45 cc e3 90 12 f0 	movl   $0xf01290e3,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111dce:	83 ec 08             	sub    $0x8,%esp
f0111dd1:	ff 75 cc             	pushl  -0x34(%ebp)
f0111dd4:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111dda:	50                   	push   %eax
f0111ddb:	e8 8b e5 00 00       	call   f012036b <str2lower>
f0111de0:	83 c4 10             	add    $0x10,%esp
f0111de3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111de6:	83 ec 0c             	sub    $0xc,%esp
f0111de9:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dec:	e8 91 de 00 00       	call   f011fc82 <strlen>
f0111df1:	83 c4 10             	add    $0x10,%esp
f0111df4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111df7:	83 ec 08             	sub    $0x8,%esp
f0111dfa:	68 fe 90 12 f0       	push   $0xf01290fe
f0111dff:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e02:	e8 87 df 00 00       	call   f011fd8e <strcmp>
f0111e07:	83 c4 10             	add    $0x10,%esp
f0111e0a:	85 c0                	test   %eax,%eax
f0111e0c:	75 13                	jne    f0111e21 <test_str2lower_function+0x343>
f0111e0e:	83 ec 0c             	sub    $0xc,%esp
f0111e11:	ff 75 cc             	pushl  -0x34(%ebp)
f0111e14:	e8 69 de 00 00       	call   f011fc82 <strlen>
f0111e19:	83 c4 10             	add    $0x10,%esp
f0111e1c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e1f:	74 15                	je     f0111e36 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111e21:	83 ec 08             	sub    $0x8,%esp
f0111e24:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e27:	68 1c 91 12 f0       	push   $0xf012911c
f0111e2c:	e8 5a f1 fe ff       	call   f0100f8b <cprintf>
f0111e31:	83 c4 10             	add    $0x10,%esp
f0111e34:	eb 04                	jmp    f0111e3a <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111e36:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111e3a:	83 ec 08             	sub    $0x8,%esp
f0111e3d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e40:	68 90 91 12 f0       	push   $0xf0129190
f0111e45:	e8 41 f1 fe ff       	call   f0100f8b <cprintf>
f0111e4a:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111e4d:	83 ec 0c             	sub    $0xc,%esp
f0111e50:	68 a0 8c 12 f0       	push   $0xf0128ca0
f0111e55:	e8 31 f1 fe ff       	call   f0100f8b <cprintf>
f0111e5a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111e5d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111e62:	c9                   	leave  
f0111e63:	c3                   	ret    

f0111e64 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111e64:	55                   	push   %ebp
f0111e65:	89 e5                	mov    %esp,%ebp
f0111e67:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111e6a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111e71:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111e78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e7f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111e84:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e87:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e8a:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e8d:	50                   	push   %eax
f0111e8e:	e8 f3 7d ff ff       	call   f0109c86 <pt_set_page_permissions>
f0111e93:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e96:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111e9b:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e9e:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ea1:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ea4:	50                   	push   %eax
f0111ea5:	e8 74 4b 00 00       	call   f0116a1e <CP>
f0111eaa:	83 c4 10             	add    $0x10,%esp
f0111ead:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111eb0:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111eb4:	74 17                	je     f0111ecd <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111eb6:	83 ec 04             	sub    $0x4,%esp
f0111eb9:	68 c0 91 12 f0       	push   $0xf01291c0
f0111ebe:	68 23 01 00 00       	push   $0x123
f0111ec3:	68 e2 91 12 f0       	push   $0xf01291e2
f0111ec8:	e8 6c e4 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111ecd:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111ed4:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111edb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ee2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111ee7:	ff 75 ec             	pushl  -0x14(%ebp)
f0111eea:	ff 75 f0             	pushl  -0x10(%ebp)
f0111eed:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ef0:	50                   	push   %eax
f0111ef1:	e8 90 7d ff ff       	call   f0109c86 <pt_set_page_permissions>
f0111ef6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ef9:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111efe:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f01:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f04:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f07:	50                   	push   %eax
f0111f08:	e8 11 4b 00 00       	call   f0116a1e <CP>
f0111f0d:	83 c4 10             	add    $0x10,%esp
f0111f10:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f13:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f17:	74 17                	je     f0111f30 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111f19:	83 ec 04             	sub    $0x4,%esp
f0111f1c:	68 00 92 12 f0       	push   $0xf0129200
f0111f21:	68 2f 01 00 00       	push   $0x12f
f0111f26:	68 e2 91 12 f0       	push   $0xf01291e2
f0111f2b:	e8 09 e4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111f30:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111f37:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111f3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f45:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111f4a:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f4d:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f50:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f53:	50                   	push   %eax
f0111f54:	e8 2d 7d ff ff       	call   f0109c86 <pt_set_page_permissions>
f0111f59:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f5c:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111f61:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f64:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f67:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f6a:	50                   	push   %eax
f0111f6b:	e8 ae 4a 00 00       	call   f0116a1e <CP>
f0111f70:	83 c4 10             	add    $0x10,%esp
f0111f73:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f76:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f7a:	74 17                	je     f0111f93 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111f7c:	83 ec 04             	sub    $0x4,%esp
f0111f7f:	68 24 92 12 f0       	push   $0xf0129224
f0111f84:	68 3a 01 00 00       	push   $0x13a
f0111f89:	68 e2 91 12 f0       	push   $0xf01291e2
f0111f8e:	e8 a6 e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111f93:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111f9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111fa1:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fa8:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111fad:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fb0:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fb3:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fb6:	50                   	push   %eax
f0111fb7:	e8 ca 7c ff ff       	call   f0109c86 <pt_set_page_permissions>
f0111fbc:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fbf:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111fc4:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fc7:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fca:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fcd:	50                   	push   %eax
f0111fce:	e8 4b 4a 00 00       	call   f0116a1e <CP>
f0111fd3:	83 c4 10             	add    $0x10,%esp
f0111fd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111fd9:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111fdd:	74 17                	je     f0111ff6 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111fdf:	83 ec 04             	sub    $0x4,%esp
f0111fe2:	68 48 92 12 f0       	push   $0xf0129248
f0111fe7:	68 46 01 00 00       	push   $0x146
f0111fec:	68 e2 91 12 f0       	push   $0xf01291e2
f0111ff1:	e8 43 e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111ff6:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111ffd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0112004:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011200b:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112010:	ff 75 ec             	pushl  -0x14(%ebp)
f0112013:	ff 75 f0             	pushl  -0x10(%ebp)
f0112016:	ff 75 f4             	pushl  -0xc(%ebp)
f0112019:	50                   	push   %eax
f011201a:	e8 67 7c ff ff       	call   f0109c86 <pt_set_page_permissions>
f011201f:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112022:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112027:	ff 75 ec             	pushl  -0x14(%ebp)
f011202a:	ff 75 f0             	pushl  -0x10(%ebp)
f011202d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112030:	50                   	push   %eax
f0112031:	e8 e8 49 00 00       	call   f0116a1e <CP>
f0112036:	83 c4 10             	add    $0x10,%esp
f0112039:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011203c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112040:	74 17                	je     f0112059 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112042:	83 ec 04             	sub    $0x4,%esp
f0112045:	68 6c 92 12 f0       	push   $0xf012926c
f011204a:	68 52 01 00 00       	push   $0x152
f011204f:	68 e2 91 12 f0       	push   $0xf01291e2
f0112054:	e8 e0 e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0112059:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0112060:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112067:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011206e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112073:	ff 75 ec             	pushl  -0x14(%ebp)
f0112076:	ff 75 f0             	pushl  -0x10(%ebp)
f0112079:	ff 75 f4             	pushl  -0xc(%ebp)
f011207c:	50                   	push   %eax
f011207d:	e8 04 7c ff ff       	call   f0109c86 <pt_set_page_permissions>
f0112082:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112085:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011208a:	ff 75 ec             	pushl  -0x14(%ebp)
f011208d:	ff 75 f0             	pushl  -0x10(%ebp)
f0112090:	ff 75 f4             	pushl  -0xc(%ebp)
f0112093:	50                   	push   %eax
f0112094:	e8 85 49 00 00       	call   f0116a1e <CP>
f0112099:	83 c4 10             	add    $0x10,%esp
f011209c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011209f:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01120a3:	74 17                	je     f01120bc <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01120a5:	83 ec 04             	sub    $0x4,%esp
f01120a8:	68 90 92 12 f0       	push   $0xf0129290
f01120ad:	68 5e 01 00 00       	push   $0x15e
f01120b2:	68 e2 91 12 f0       	push   $0xf01291e2
f01120b7:	e8 7d e2 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f01120bc:	83 ec 0c             	sub    $0xc,%esp
f01120bf:	68 bc 92 12 f0       	push   $0xf01292bc
f01120c4:	e8 c2 ee fe ff       	call   f0100f8b <cprintf>
f01120c9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01120cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01120d1:	c9                   	leave  
f01120d2:	c3                   	ret    

f01120d3 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f01120d3:	55                   	push   %ebp
f01120d4:	89 e5                	mov    %esp,%ebp
f01120d6:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f01120d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01120e0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01120e7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120ee:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01120f3:	ff 75 ec             	pushl  -0x14(%ebp)
f01120f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01120f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01120fc:	50                   	push   %eax
f01120fd:	e8 84 7b ff ff       	call   f0109c86 <pt_set_page_permissions>
f0112102:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0112105:	83 ec 04             	sub    $0x4,%esp
f0112108:	68 0c 93 12 f0       	push   $0xf012930c
f011210d:	68 6b 01 00 00       	push   $0x16b
f0112112:	68 e2 91 12 f0       	push   $0xf01291e2
f0112117:	e8 1d e2 fe ff       	call   f0100339 <_panic>

f011211c <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f011211c:	55                   	push   %ebp
f011211d:	89 e5                	mov    %esp,%ebp
f011211f:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112122:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0112129:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011212e:	83 ec 08             	sub    $0x8,%esp
f0112131:	ff 75 f4             	pushl  -0xc(%ebp)
f0112134:	50                   	push   %eax
f0112135:	e8 10 7c ff ff       	call   f0109d4a <pt_get_page_permissions>
f011213a:	83 c4 10             	add    $0x10,%esp
f011213d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112140:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112144:	74 17                	je     f011215d <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0112146:	83 ec 04             	sub    $0x4,%esp
f0112149:	68 a8 93 12 f0       	push   $0xf01293a8
f011214e:	68 79 01 00 00       	push   $0x179
f0112153:	68 e2 91 12 f0       	push   $0xf01291e2
f0112158:	e8 dc e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f011215d:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112164:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112169:	83 ec 08             	sub    $0x8,%esp
f011216c:	ff 75 f4             	pushl  -0xc(%ebp)
f011216f:	50                   	push   %eax
f0112170:	e8 d5 7b ff ff       	call   f0109d4a <pt_get_page_permissions>
f0112175:	83 c4 10             	add    $0x10,%esp
f0112178:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f011217b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011217f:	74 17                	je     f0112198 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0112181:	83 ec 04             	sub    $0x4,%esp
f0112184:	68 cc 93 12 f0       	push   $0xf01293cc
f0112189:	68 81 01 00 00       	push   $0x181
f011218e:	68 e2 91 12 f0       	push   $0xf01291e2
f0112193:	e8 a1 e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0112198:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011219f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01121a4:	83 ec 08             	sub    $0x8,%esp
f01121a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01121aa:	50                   	push   %eax
f01121ab:	e8 9a 7b ff ff       	call   f0109d4a <pt_get_page_permissions>
f01121b0:	83 c4 10             	add    $0x10,%esp
f01121b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01121b6:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01121ba:	74 17                	je     f01121d3 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f01121bc:	83 ec 04             	sub    $0x4,%esp
f01121bf:	68 f0 93 12 f0       	push   $0xf01293f0
f01121c4:	68 89 01 00 00       	push   $0x189
f01121c9:	68 e2 91 12 f0       	push   $0xf01291e2
f01121ce:	e8 66 e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f01121d3:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01121da:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01121df:	83 ec 08             	sub    $0x8,%esp
f01121e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01121e5:	50                   	push   %eax
f01121e6:	e8 5f 7b ff ff       	call   f0109d4a <pt_get_page_permissions>
f01121eb:	83 c4 10             	add    $0x10,%esp
f01121ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01121f1:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01121f5:	74 17                	je     f011220e <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f01121f7:	83 ec 04             	sub    $0x4,%esp
f01121fa:	68 14 94 12 f0       	push   $0xf0129414
f01121ff:	68 90 01 00 00       	push   $0x190
f0112204:	68 e2 91 12 f0       	push   $0xf01291e2
f0112209:	e8 2b e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f011220e:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112215:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011221a:	83 ec 08             	sub    $0x8,%esp
f011221d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112220:	50                   	push   %eax
f0112221:	e8 24 7b ff ff       	call   f0109d4a <pt_get_page_permissions>
f0112226:	83 c4 10             	add    $0x10,%esp
f0112229:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f011222c:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112230:	74 17                	je     f0112249 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112232:	83 ec 04             	sub    $0x4,%esp
f0112235:	68 38 94 12 f0       	push   $0xf0129438
f011223a:	68 97 01 00 00       	push   $0x197
f011223f:	68 e2 91 12 f0       	push   $0xf01291e2
f0112244:	e8 f0 e0 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0112249:	83 ec 0c             	sub    $0xc,%esp
f011224c:	68 5c 94 12 f0       	push   $0xf012945c
f0112251:	e8 35 ed fe ff       	call   f0100f8b <cprintf>
f0112256:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112259:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011225e:	c9                   	leave  
f011225f:	c3                   	ret    

f0112260 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0112260:	55                   	push   %ebp
f0112261:	89 e5                	mov    %esp,%ebp
f0112263:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112266:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011226d:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112272:	83 ec 08             	sub    $0x8,%esp
f0112275:	ff 75 f4             	pushl  -0xc(%ebp)
f0112278:	50                   	push   %eax
f0112279:	e8 15 7b ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f011227e:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0112281:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112286:	83 ec 08             	sub    $0x8,%esp
f0112289:	ff 75 f4             	pushl  -0xc(%ebp)
f011228c:	50                   	push   %eax
f011228d:	e8 e8 46 00 00       	call   f011697a <CE>
f0112292:	83 c4 10             	add    $0x10,%esp
f0112295:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112298:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011229c:	74 17                	je     f01122b5 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f011229e:	83 ec 04             	sub    $0x4,%esp
f01122a1:	68 a4 94 12 f0       	push   $0xf01294a4
f01122a6:	68 a7 01 00 00       	push   $0x1a7
f01122ab:	68 e2 91 12 f0       	push   $0xf01291e2
f01122b0:	e8 84 e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01122b5:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01122bc:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01122c1:	83 ec 08             	sub    $0x8,%esp
f01122c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01122c7:	50                   	push   %eax
f01122c8:	e8 c6 7a ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f01122cd:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01122d0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01122d5:	83 ec 08             	sub    $0x8,%esp
f01122d8:	ff 75 f4             	pushl  -0xc(%ebp)
f01122db:	50                   	push   %eax
f01122dc:	e8 99 46 00 00       	call   f011697a <CE>
f01122e1:	83 c4 10             	add    $0x10,%esp
f01122e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01122e7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01122eb:	74 17                	je     f0112304 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f01122ed:	83 ec 04             	sub    $0x4,%esp
f01122f0:	68 d0 94 12 f0       	push   $0xf01294d0
f01122f5:	68 af 01 00 00       	push   $0x1af
f01122fa:	68 e2 91 12 f0       	push   $0xf01291e2
f01122ff:	e8 35 e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0112304:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011230b:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112310:	83 ec 08             	sub    $0x8,%esp
f0112313:	ff 75 f4             	pushl  -0xc(%ebp)
f0112316:	50                   	push   %eax
f0112317:	e8 77 7a ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f011231c:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011231f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112324:	83 ec 08             	sub    $0x8,%esp
f0112327:	ff 75 f4             	pushl  -0xc(%ebp)
f011232a:	50                   	push   %eax
f011232b:	e8 4a 46 00 00       	call   f011697a <CE>
f0112330:	83 c4 10             	add    $0x10,%esp
f0112333:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112336:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011233a:	74 17                	je     f0112353 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f011233c:	83 ec 04             	sub    $0x4,%esp
f011233f:	68 fc 94 12 f0       	push   $0xf01294fc
f0112344:	68 b7 01 00 00       	push   $0x1b7
f0112349:	68 e2 91 12 f0       	push   $0xf01291e2
f011234e:	e8 e6 df fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0112353:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011235a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011235f:	83 ec 08             	sub    $0x8,%esp
f0112362:	ff 75 f4             	pushl  -0xc(%ebp)
f0112365:	50                   	push   %eax
f0112366:	e8 28 7a ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f011236b:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011236e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112373:	83 ec 08             	sub    $0x8,%esp
f0112376:	ff 75 f4             	pushl  -0xc(%ebp)
f0112379:	50                   	push   %eax
f011237a:	e8 fb 45 00 00       	call   f011697a <CE>
f011237f:	83 c4 10             	add    $0x10,%esp
f0112382:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112385:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112389:	74 17                	je     f01123a2 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f011238b:	83 ec 04             	sub    $0x4,%esp
f011238e:	68 28 95 12 f0       	push   $0xf0129528
f0112393:	68 bf 01 00 00       	push   $0x1bf
f0112398:	68 e2 91 12 f0       	push   $0xf01291e2
f011239d:	e8 97 df fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01123a2:	83 ec 0c             	sub    $0xc,%esp
f01123a5:	68 54 95 12 f0       	push   $0xf0129554
f01123aa:	e8 dc eb fe ff       	call   f0100f8b <cprintf>
f01123af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01123b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01123b7:	c9                   	leave  
f01123b8:	c3                   	ret    

f01123b9 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f01123b9:	55                   	push   %ebp
f01123ba:	89 e5                	mov    %esp,%ebp
f01123bc:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f01123bf:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01123c6:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01123cb:	83 ec 08             	sub    $0x8,%esp
f01123ce:	ff 75 f4             	pushl  -0xc(%ebp)
f01123d1:	50                   	push   %eax
f01123d2:	e8 bc 79 ff ff       	call   f0109d93 <pt_clear_page_table_entry>
f01123d7:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f01123da:	83 ec 04             	sub    $0x4,%esp
f01123dd:	68 a0 95 12 f0       	push   $0xf01295a0
f01123e2:	68 ca 01 00 00       	push   $0x1ca
f01123e7:	68 e2 91 12 f0       	push   $0xf01291e2
f01123ec:	e8 48 df fe ff       	call   f0100339 <_panic>

f01123f1 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01123f1:	55                   	push   %ebp
f01123f2:	89 e5                	mov    %esp,%ebp
f01123f4:	57                   	push   %edi
f01123f5:	56                   	push   %esi
f01123f6:	53                   	push   %ebx
f01123f7:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01123fd:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112403:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f0112408:	ba 0f 00 00 00       	mov    $0xf,%edx
f011240d:	89 c7                	mov    %eax,%edi
f011240f:	89 de                	mov    %ebx,%esi
f0112411:	89 d1                	mov    %edx,%ecx
f0112413:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112415:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011241b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112420:	b0 00                	mov    $0x0,%al
f0112422:	89 d7                	mov    %edx,%edi
f0112424:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112426:	6a 00                	push   $0x0
f0112428:	6a 0a                	push   $0xa
f011242a:	6a 14                	push   $0x14
f011242c:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112432:	50                   	push   %eax
f0112433:	e8 90 8b ff ff       	call   f010afc8 <env_create>
f0112438:	83 c4 10             	add    $0x10,%esp
f011243b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011243e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112441:	8b 40 64             	mov    0x64(%eax),%eax
f0112444:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112447:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011244a:	8b 40 68             	mov    0x68(%eax),%eax
f011244d:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112450:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112453:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112456:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f011245d:	75 70 20 
f0112460:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112467:	00 00 00 
f011246a:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112470:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112475:	b8 00 00 00 00       	mov    $0x0,%eax
f011247a:	89 d7                	mov    %edx,%edi
f011247c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011247e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112481:	8b 40 10             	mov    0x10(%eax),%eax
f0112484:	83 ec 08             	sub    $0x8,%esp
f0112487:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011248d:	52                   	push   %edx
f011248e:	50                   	push   %eax
f011248f:	e8 94 dc 00 00       	call   f0120128 <ltostr>
f0112494:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112497:	83 ec 04             	sub    $0x4,%esp
f011249a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01124a0:	50                   	push   %eax
f01124a1:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f01124a7:	50                   	push   %eax
f01124a8:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f01124ae:	50                   	push   %eax
f01124af:	e8 4d dd 00 00       	call   f0120201 <strcconcat>
f01124b4:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f01124b7:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f01124be:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01124c5:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01124cc:	83 ec 0c             	sub    $0xc,%esp
f01124cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124d2:	e8 85 45 00 00       	call   f0116a5c <ClearUserSpace>
f01124d7:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f01124da:	83 ec 04             	sub    $0x4,%esp
f01124dd:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01124e3:	50                   	push   %eax
f01124e4:	68 36 96 12 f0       	push   $0xf0129636
f01124e9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01124ef:	50                   	push   %eax
f01124f0:	e8 0c dd 00 00       	call   f0120201 <strcconcat>
f01124f5:	83 c4 10             	add    $0x10,%esp
f01124f8:	83 ec 0c             	sub    $0xc,%esp
f01124fb:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112501:	50                   	push   %eax
f0112502:	e8 f4 f9 fe ff       	call   f0101efb <execute_command>
f0112507:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f011250a:	83 ec 04             	sub    $0x4,%esp
f011250d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112513:	50                   	push   %eax
f0112514:	68 41 96 12 f0       	push   $0xf0129641
f0112519:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011251f:	50                   	push   %eax
f0112520:	e8 dc dc 00 00       	call   f0120201 <strcconcat>
f0112525:	83 c4 10             	add    $0x10,%esp
f0112528:	83 ec 0c             	sub    $0xc,%esp
f011252b:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112531:	50                   	push   %eax
f0112532:	e8 c4 f9 fe ff       	call   f0101efb <execute_command>
f0112537:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f011253a:	83 ec 04             	sub    $0x4,%esp
f011253d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112543:	50                   	push   %eax
f0112544:	68 4c 96 12 f0       	push   $0xf012964c
f0112549:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011254f:	50                   	push   %eax
f0112550:	e8 ac dc 00 00       	call   f0120201 <strcconcat>
f0112555:	83 c4 10             	add    $0x10,%esp
f0112558:	83 ec 0c             	sub    $0xc,%esp
f011255b:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112561:	50                   	push   %eax
f0112562:	e8 94 f9 fe ff       	call   f0101efb <execute_command>
f0112567:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f011256a:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0112571:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112574:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112577:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f011257e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112581:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0112584:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f011258b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011258e:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112591:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112594:	83 ec 08             	sub    $0x8,%esp
f0112597:	50                   	push   %eax
f0112598:	ff 75 d4             	pushl  -0x2c(%ebp)
f011259b:	e8 9d 44 00 00       	call   f0116a3d <GP>
f01125a0:	83 c4 10             	add    $0x10,%esp
f01125a3:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01125a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f01125ad:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f01125b4:	e8 af c3 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01125b9:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f01125bc:	83 ec 0c             	sub    $0xc,%esp
f01125bf:	68 58 96 12 f0       	push   $0xf0129658
f01125c4:	e8 c2 e9 fe ff       	call   f0100f8b <cprintf>
f01125c9:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01125cc:	6a 03                	push   $0x3
f01125ce:	68 00 00 90 02       	push   $0x2900000
f01125d3:	68 00 00 80 02       	push   $0x2800000
f01125d8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125db:	e8 27 85 ff ff       	call   f010ab07 <cut_paste_pages>
f01125e0:	83 c4 10             	add    $0x10,%esp
f01125e3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f01125e6:	e8 7d c3 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01125eb:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01125ee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01125f5:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01125f9:	75 08                	jne    f0112603 <test_cut_paste_pages+0x212>
f01125fb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01125fe:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112601:	74 2b                	je     f011262e <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112603:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112606:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112609:	83 ec 0c             	sub    $0xc,%esp
f011260c:	50                   	push   %eax
f011260d:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112610:	68 88 96 12 f0       	push   $0xf0129688
f0112615:	68 04 02 00 00       	push   $0x204
f011261a:	68 e2 91 12 f0       	push   $0xf01291e2
f011261f:	e8 b2 de fe ff       	call   f01004d6 <_warn>
f0112624:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112627:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f011262e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112632:	74 04                	je     f0112638 <test_cut_paste_pages+0x247>
f0112634:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112638:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011263f:	83 ec 08             	sub    $0x8,%esp
f0112642:	6a 00                	push   $0x0
f0112644:	6a 01                	push   $0x1
f0112646:	6a 00                	push   $0x0
f0112648:	68 ff 0f 00 00       	push   $0xfff
f011264d:	ff 75 bc             	pushl  -0x44(%ebp)
f0112650:	6a 01                	push   $0x1
f0112652:	68 00 30 00 00       	push   $0x3000
f0112657:	68 00 00 90 02       	push   $0x2900000
f011265c:	68 00 00 80 02       	push   $0x2800000
f0112661:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112664:	e8 27 44 00 00       	call   f0116a90 <CCP>
f0112669:	83 c4 30             	add    $0x30,%esp
f011266c:	83 f8 01             	cmp    $0x1,%eax
f011266f:	74 21                	je     f0112692 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112671:	83 ec 04             	sub    $0x4,%esp
f0112674:	68 dc 96 12 f0       	push   $0xf01296dc
f0112679:	68 0c 02 00 00       	push   $0x20c
f011267e:	68 e2 91 12 f0       	push   $0xf01291e2
f0112683:	e8 4e de fe ff       	call   f01004d6 <_warn>
f0112688:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011268b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112692:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112696:	74 04                	je     f011269c <test_cut_paste_pages+0x2ab>
f0112698:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f011269c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01126a3:	83 ec 04             	sub    $0x4,%esp
f01126a6:	6a 00                	push   $0x0
f01126a8:	68 00 00 90 02       	push   $0x2900000
f01126ad:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126b0:	e8 b7 41 00 00       	call   f011686c <CB>
f01126b5:	83 c4 10             	add    $0x10,%esp
f01126b8:	85 c0                	test   %eax,%eax
f01126ba:	0f 84 f6 00 00 00    	je     f01127b6 <test_cut_paste_pages+0x3c5>
f01126c0:	83 ec 04             	sub    $0x4,%esp
f01126c3:	6a 00                	push   $0x0
f01126c5:	68 00 10 90 02       	push   $0x2901000
f01126ca:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126cd:	e8 9a 41 00 00       	call   f011686c <CB>
f01126d2:	83 c4 10             	add    $0x10,%esp
f01126d5:	85 c0                	test   %eax,%eax
f01126d7:	0f 84 d9 00 00 00    	je     f01127b6 <test_cut_paste_pages+0x3c5>
f01126dd:	83 ec 04             	sub    $0x4,%esp
f01126e0:	6a 00                	push   $0x0
f01126e2:	68 00 20 90 02       	push   $0x2902000
f01126e7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126ea:	e8 7d 41 00 00       	call   f011686c <CB>
f01126ef:	83 c4 10             	add    $0x10,%esp
f01126f2:	85 c0                	test   %eax,%eax
f01126f4:	0f 84 bc 00 00 00    	je     f01127b6 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01126fa:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112701:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112708:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f011270f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112712:	8a 00                	mov    (%eax),%al
f0112714:	3c 61                	cmp    $0x61,%al
f0112716:	75 12                	jne    f011272a <test_cut_paste_pages+0x339>
f0112718:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011271b:	8a 00                	mov    (%eax),%al
f011271d:	3c 62                	cmp    $0x62,%al
f011271f:	75 09                	jne    f011272a <test_cut_paste_pages+0x339>
f0112721:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112724:	8a 00                	mov    (%eax),%al
f0112726:	3c 63                	cmp    $0x63,%al
f0112728:	74 21                	je     f011274b <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011272a:	83 ec 04             	sub    $0x4,%esp
f011272d:	68 28 97 12 f0       	push   $0xf0129728
f0112732:	68 19 02 00 00       	push   $0x219
f0112737:	68 e2 91 12 f0       	push   $0xf01291e2
f011273c:	e8 95 dd fe ff       	call   f01004d6 <_warn>
f0112741:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112744:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011274b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011274f:	74 04                	je     f0112755 <test_cut_paste_pages+0x364>
f0112751:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112755:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f011275c:	83 ec 04             	sub    $0x4,%esp
f011275f:	6a 01                	push   $0x1
f0112761:	68 00 10 90 02       	push   $0x2901000
f0112766:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112769:	e8 fe 40 00 00       	call   f011686c <CB>
f011276e:	83 c4 10             	add    $0x10,%esp
f0112771:	85 c0                	test   %eax,%eax
f0112773:	74 41                	je     f01127b6 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112775:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112778:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f011277b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011277e:	8a 00                	mov    (%eax),%al
f0112780:	3c 79                	cmp    $0x79,%al
f0112782:	74 21                	je     f01127a5 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112784:	83 ec 04             	sub    $0x4,%esp
f0112787:	68 28 97 12 f0       	push   $0xf0129728
f011278c:	68 24 02 00 00       	push   $0x224
f0112791:	68 e2 91 12 f0       	push   $0xf01291e2
f0112796:	e8 3b dd fe ff       	call   f01004d6 <_warn>
f011279b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011279e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01127a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127a9:	74 04                	je     f01127af <test_cut_paste_pages+0x3be>
f01127ab:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01127af:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01127b6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01127b9:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01127bc:	6a 02                	push   $0x2
f01127be:	68 00 f0 bf 02       	push   $0x2bff000
f01127c3:	68 00 10 90 02       	push   $0x2901000
f01127c8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127cb:	e8 37 83 ff ff       	call   f010ab07 <cut_paste_pages>
f01127d0:	83 c4 10             	add    $0x10,%esp
f01127d3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01127d6:	e8 8d c1 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01127db:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f01127de:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01127e2:	75 0b                	jne    f01127ef <test_cut_paste_pages+0x3fe>
f01127e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01127e7:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01127ea:	83 f8 01             	cmp    $0x1,%eax
f01127ed:	74 2b                	je     f011281a <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01127ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01127f2:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01127f5:	83 ec 0c             	sub    $0xc,%esp
f01127f8:	50                   	push   %eax
f01127f9:	ff 75 b4             	pushl  -0x4c(%ebp)
f01127fc:	68 88 96 12 f0       	push   $0xf0129688
f0112801:	68 35 02 00 00       	push   $0x235
f0112806:	68 e2 91 12 f0       	push   $0xf01291e2
f011280b:	e8 c6 dc fe ff       	call   f01004d6 <_warn>
f0112810:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112813:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011281a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011281e:	74 04                	je     f0112824 <test_cut_paste_pages+0x433>
f0112820:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112824:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011282b:	83 ec 08             	sub    $0x8,%esp
f011282e:	6a 00                	push   $0x0
f0112830:	6a 01                	push   $0x1
f0112832:	6a 00                	push   $0x0
f0112834:	68 ff 0f 00 00       	push   $0xfff
f0112839:	ff 75 bc             	pushl  -0x44(%ebp)
f011283c:	6a 01                	push   $0x1
f011283e:	68 00 20 00 00       	push   $0x2000
f0112843:	68 00 f0 bf 02       	push   $0x2bff000
f0112848:	68 00 10 90 02       	push   $0x2901000
f011284d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112850:	e8 3b 42 00 00       	call   f0116a90 <CCP>
f0112855:	83 c4 30             	add    $0x30,%esp
f0112858:	83 f8 01             	cmp    $0x1,%eax
f011285b:	74 21                	je     f011287e <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011285d:	83 ec 04             	sub    $0x4,%esp
f0112860:	68 dc 96 12 f0       	push   $0xf01296dc
f0112865:	68 3d 02 00 00       	push   $0x23d
f011286a:	68 e2 91 12 f0       	push   $0xf01291e2
f011286f:	e8 62 dc fe ff       	call   f01004d6 <_warn>
f0112874:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112877:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011287e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112882:	74 04                	je     f0112888 <test_cut_paste_pages+0x497>
f0112884:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112888:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f011288f:	83 ec 04             	sub    $0x4,%esp
f0112892:	6a 00                	push   $0x0
f0112894:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112899:	ff 75 d4             	pushl  -0x2c(%ebp)
f011289c:	e8 cb 3f 00 00       	call   f011686c <CB>
f01128a1:	83 c4 10             	add    $0x10,%esp
f01128a4:	85 c0                	test   %eax,%eax
f01128a6:	74 6b                	je     f0112913 <test_cut_paste_pages+0x522>
f01128a8:	83 ec 04             	sub    $0x4,%esp
f01128ab:	6a 00                	push   $0x0
f01128ad:	68 ff 0f c0 02       	push   $0x2c00fff
f01128b2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128b5:	e8 b2 3f 00 00       	call   f011686c <CB>
f01128ba:	83 c4 10             	add    $0x10,%esp
f01128bd:	85 c0                	test   %eax,%eax
f01128bf:	74 52                	je     f0112913 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f01128c1:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f01128c8:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f01128cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01128d2:	8a 00                	mov    (%eax),%al
f01128d4:	3c 79                	cmp    $0x79,%al
f01128d6:	75 09                	jne    f01128e1 <test_cut_paste_pages+0x4f0>
f01128d8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01128db:	8a 00                	mov    (%eax),%al
f01128dd:	3c 63                	cmp    $0x63,%al
f01128df:	74 21                	je     f0112902 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01128e1:	83 ec 04             	sub    $0x4,%esp
f01128e4:	68 28 97 12 f0       	push   $0xf0129728
f01128e9:	68 49 02 00 00       	push   $0x249
f01128ee:	68 e2 91 12 f0       	push   $0xf01291e2
f01128f3:	e8 de db fe ff       	call   f01004d6 <_warn>
f01128f8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01128fb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112902:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112906:	74 04                	je     f011290c <test_cut_paste_pages+0x51b>
f0112908:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011290c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112913:	83 ec 0c             	sub    $0xc,%esp
f0112916:	68 61 97 12 f0       	push   $0xf0129761
f011291b:	e8 6b e6 fe ff       	call   f0100f8b <cprintf>
f0112920:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112923:	83 ec 0c             	sub    $0xc,%esp
f0112926:	68 70 97 12 f0       	push   $0xf0129770
f011292b:	e8 5b e6 fe ff       	call   f0100f8b <cprintf>
f0112930:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112933:	83 ec 04             	sub    $0x4,%esp
f0112936:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011293c:	50                   	push   %eax
f011293d:	68 99 97 12 f0       	push   $0xf0129799
f0112942:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112948:	50                   	push   %eax
f0112949:	e8 b3 d8 00 00       	call   f0120201 <strcconcat>
f011294e:	83 c4 10             	add    $0x10,%esp
f0112951:	83 ec 0c             	sub    $0xc,%esp
f0112954:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011295a:	50                   	push   %eax
f011295b:	e8 9b f5 fe ff       	call   f0101efb <execute_command>
f0112960:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112963:	83 ec 04             	sub    $0x4,%esp
f0112966:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f011296c:	50                   	push   %eax
f011296d:	68 a4 97 12 f0       	push   $0xf01297a4
f0112972:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112978:	50                   	push   %eax
f0112979:	e8 83 d8 00 00       	call   f0120201 <strcconcat>
f011297e:	83 c4 10             	add    $0x10,%esp
f0112981:	83 ec 0c             	sub    $0xc,%esp
f0112984:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f011298a:	50                   	push   %eax
f011298b:	e8 6b f5 fe ff       	call   f0101efb <execute_command>
f0112990:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112993:	83 ec 04             	sub    $0x4,%esp
f0112996:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011299c:	50                   	push   %eax
f011299d:	68 af 97 12 f0       	push   $0xf01297af
f01129a2:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129a8:	50                   	push   %eax
f01129a9:	e8 53 d8 00 00       	call   f0120201 <strcconcat>
f01129ae:	83 c4 10             	add    $0x10,%esp
f01129b1:	83 ec 0c             	sub    $0xc,%esp
f01129b4:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01129ba:	50                   	push   %eax
f01129bb:	e8 3b f5 fe ff       	call   f0101efb <execute_command>
f01129c0:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f01129c3:	83 ec 04             	sub    $0x4,%esp
f01129c6:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01129cc:	50                   	push   %eax
f01129cd:	68 ba 97 12 f0       	push   $0xf01297ba
f01129d2:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129d8:	50                   	push   %eax
f01129d9:	e8 23 d8 00 00       	call   f0120201 <strcconcat>
f01129de:	83 c4 10             	add    $0x10,%esp
f01129e1:	83 ec 0c             	sub    $0xc,%esp
f01129e4:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01129ea:	50                   	push   %eax
f01129eb:	e8 0b f5 fe ff       	call   f0101efb <execute_command>
f01129f0:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01129f3:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01129fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129fd:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112a00:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112a07:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a0a:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112a0d:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112a14:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a17:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112a1a:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112a21:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a24:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112a27:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112a2e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a31:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112a34:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112a3b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a3e:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112a41:	83 ec 08             	sub    $0x8,%esp
f0112a44:	68 00 00 c0 01       	push   $0x1c00000
f0112a49:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a4c:	e8 ec 3f 00 00       	call   f0116a3d <GP>
f0112a51:	83 c4 10             	add    $0x10,%esp
f0112a54:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112a57:	83 ec 08             	sub    $0x8,%esp
f0112a5a:	68 00 00 40 01       	push   $0x1400000
f0112a5f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a62:	e8 d6 3f 00 00       	call   f0116a3d <GP>
f0112a67:	83 c4 10             	add    $0x10,%esp
f0112a6a:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112a6d:	e8 f6 be ff ff       	call   f010e968 <sys_calculate_free_frames>
f0112a72:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112a75:	6a 01                	push   $0x1
f0112a77:	68 00 00 40 01       	push   $0x1400000
f0112a7c:	68 00 00 c0 01       	push   $0x1c00000
f0112a81:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a84:	e8 7e 80 ff ff       	call   f010ab07 <cut_paste_pages>
f0112a89:	83 c4 10             	add    $0x10,%esp
f0112a8c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112a8f:	e8 d4 be ff ff       	call   f010e968 <sys_calculate_free_frames>
f0112a94:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112a97:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112a9b:	75 08                	jne    f0112aa5 <test_cut_paste_pages+0x6b4>
f0112a9d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112aa0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112aa3:	74 2b                	je     f0112ad0 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112aa5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112aa8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112aab:	83 ec 0c             	sub    $0xc,%esp
f0112aae:	50                   	push   %eax
f0112aaf:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112ab2:	68 c8 97 12 f0       	push   $0xf01297c8
f0112ab7:	68 6c 02 00 00       	push   $0x26c
f0112abc:	68 e2 91 12 f0       	push   $0xf01291e2
f0112ac1:	e8 10 da fe ff       	call   f01004d6 <_warn>
f0112ac6:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112ac9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112ad0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ad4:	74 04                	je     f0112ada <test_cut_paste_pages+0x6e9>
f0112ad6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112ada:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112ae1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112ae8:	83 ec 08             	sub    $0x8,%esp
f0112aeb:	6a 00                	push   $0x0
f0112aed:	68 ff 0f 00 00       	push   $0xfff
f0112af2:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112af5:	68 ff 0f 00 00       	push   $0xfff
f0112afa:	ff 75 a0             	pushl  -0x60(%ebp)
f0112afd:	6a 01                	push   $0x1
f0112aff:	68 00 10 00 00       	push   $0x1000
f0112b04:	68 00 00 40 01       	push   $0x1400000
f0112b09:	68 00 00 c0 01       	push   $0x1c00000
f0112b0e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b11:	e8 7a 3f 00 00       	call   f0116a90 <CCP>
f0112b16:	83 c4 30             	add    $0x30,%esp
f0112b19:	83 f8 01             	cmp    $0x1,%eax
f0112b1c:	74 28                	je     f0112b46 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112b1e:	83 ec 04             	sub    $0x4,%esp
f0112b21:	68 dc 96 12 f0       	push   $0xf01296dc
f0112b26:	68 75 02 00 00       	push   $0x275
f0112b2b:	68 e2 91 12 f0       	push   $0xf01291e2
f0112b30:	e8 a1 d9 fe ff       	call   f01004d6 <_warn>
f0112b35:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112b38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112b3f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112b46:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b4a:	74 04                	je     f0112b50 <test_cut_paste_pages+0x75f>
f0112b4c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112b50:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112b57:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112b5b:	0f 84 92 00 00 00    	je     f0112bf3 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112b61:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112b68:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112b6f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112b76:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112b7d:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112b84:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112b8b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b8e:	8a 00                	mov    (%eax),%al
f0112b90:	3c 61                	cmp    $0x61,%al
f0112b92:	75 2d                	jne    f0112bc1 <test_cut_paste_pages+0x7d0>
f0112b94:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b97:	8a 00                	mov    (%eax),%al
f0112b99:	3c 78                	cmp    $0x78,%al
f0112b9b:	75 24                	jne    f0112bc1 <test_cut_paste_pages+0x7d0>
f0112b9d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112ba0:	8a 00                	mov    (%eax),%al
f0112ba2:	3c 62                	cmp    $0x62,%al
f0112ba4:	75 1b                	jne    f0112bc1 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112ba6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112ba9:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112bab:	3c 79                	cmp    $0x79,%al
f0112bad:	75 12                	jne    f0112bc1 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112baf:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bb2:	8a 00                	mov    (%eax),%al
f0112bb4:	3c 63                	cmp    $0x63,%al
f0112bb6:	75 09                	jne    f0112bc1 <test_cut_paste_pages+0x7d0>
f0112bb8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112bbb:	8a 00                	mov    (%eax),%al
f0112bbd:	3c 7a                	cmp    $0x7a,%al
f0112bbf:	74 21                	je     f0112be2 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112bc1:	83 ec 04             	sub    $0x4,%esp
f0112bc4:	68 28 97 12 f0       	push   $0xf0129728
f0112bc9:	68 87 02 00 00       	push   $0x287
f0112bce:	68 e2 91 12 f0       	push   $0xf01291e2
f0112bd3:	e8 fe d8 fe ff       	call   f01004d6 <_warn>
f0112bd8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112bdb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112be2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112be6:	74 04                	je     f0112bec <test_cut_paste_pages+0x7fb>
f0112be8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112bec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112bf3:	e8 70 bd ff ff       	call   f010e968 <sys_calculate_free_frames>
f0112bf8:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112bfb:	6a 03                	push   $0x3
f0112bfd:	68 00 f0 bf 01       	push   $0x1bff000
f0112c02:	68 00 00 40 01       	push   $0x1400000
f0112c07:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c0a:	e8 f8 7e ff ff       	call   f010ab07 <cut_paste_pages>
f0112c0f:	83 c4 10             	add    $0x10,%esp
f0112c12:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112c15:	e8 4e bd ff ff       	call   f010e968 <sys_calculate_free_frames>
f0112c1a:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112c1d:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112c21:	75 08                	jne    f0112c2b <test_cut_paste_pages+0x83a>
f0112c23:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c26:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112c29:	74 2b                	je     f0112c56 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112c2b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c2e:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112c31:	83 ec 0c             	sub    $0xc,%esp
f0112c34:	50                   	push   %eax
f0112c35:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112c38:	68 c8 97 12 f0       	push   $0xf01297c8
f0112c3d:	68 96 02 00 00       	push   $0x296
f0112c42:	68 e2 91 12 f0       	push   $0xf01291e2
f0112c47:	e8 8a d8 fe ff       	call   f01004d6 <_warn>
f0112c4c:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112c4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112c56:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c5a:	74 04                	je     f0112c60 <test_cut_paste_pages+0x86f>
f0112c5c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112c60:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112c67:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112c6e:	83 ec 04             	sub    $0x4,%esp
f0112c71:	6a 00                	push   $0x0
f0112c73:	68 00 00 40 01       	push   $0x1400000
f0112c78:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c7b:	e8 ec 3b 00 00       	call   f011686c <CB>
f0112c80:	83 c4 10             	add    $0x10,%esp
f0112c83:	83 f8 01             	cmp    $0x1,%eax
f0112c86:	0f 85 80 00 00 00    	jne    f0112d0c <test_cut_paste_pages+0x91b>
f0112c8c:	83 ec 04             	sub    $0x4,%esp
f0112c8f:	6a 00                	push   $0x0
f0112c91:	68 00 10 40 01       	push   $0x1401000
f0112c96:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c99:	e8 ce 3b 00 00       	call   f011686c <CB>
f0112c9e:	83 c4 10             	add    $0x10,%esp
f0112ca1:	83 f8 01             	cmp    $0x1,%eax
f0112ca4:	75 66                	jne    f0112d0c <test_cut_paste_pages+0x91b>
f0112ca6:	83 ec 04             	sub    $0x4,%esp
f0112ca9:	6a 00                	push   $0x0
f0112cab:	68 00 20 40 01       	push   $0x1402000
f0112cb0:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112cb3:	e8 b4 3b 00 00       	call   f011686c <CB>
f0112cb8:	83 c4 10             	add    $0x10,%esp
f0112cbb:	83 f8 01             	cmp    $0x1,%eax
f0112cbe:	75 4c                	jne    f0112d0c <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112cc0:	83 ec 04             	sub    $0x4,%esp
f0112cc3:	6a 00                	push   $0x0
f0112cc5:	68 00 f0 bf 01       	push   $0x1bff000
f0112cca:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ccd:	e8 9a 3b 00 00       	call   f011686c <CB>
f0112cd2:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112cd5:	85 c0                	test   %eax,%eax
f0112cd7:	75 33                	jne    f0112d0c <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112cd9:	83 ec 04             	sub    $0x4,%esp
f0112cdc:	6a 00                	push   $0x0
f0112cde:	68 00 00 c0 01       	push   $0x1c00000
f0112ce3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ce6:	e8 81 3b 00 00       	call   f011686c <CB>
f0112ceb:	83 c4 10             	add    $0x10,%esp
f0112cee:	83 f8 01             	cmp    $0x1,%eax
f0112cf1:	75 19                	jne    f0112d0c <test_cut_paste_pages+0x91b>
f0112cf3:	83 ec 04             	sub    $0x4,%esp
f0112cf6:	6a 00                	push   $0x0
f0112cf8:	68 00 10 c0 01       	push   $0x1c01000
f0112cfd:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d00:	e8 67 3b 00 00       	call   f011686c <CB>
f0112d05:	83 c4 10             	add    $0x10,%esp
f0112d08:	85 c0                	test   %eax,%eax
f0112d0a:	74 28                	je     f0112d34 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112d0c:	83 ec 04             	sub    $0x4,%esp
f0112d0f:	68 28 98 12 f0       	push   $0xf0129828
f0112d14:	68 9f 02 00 00       	push   $0x29f
f0112d19:	68 e2 91 12 f0       	push   $0xf01291e2
f0112d1e:	e8 b3 d7 fe ff       	call   f01004d6 <_warn>
f0112d23:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112d26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112d2d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112d34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d38:	74 04                	je     f0112d3e <test_cut_paste_pages+0x94d>
f0112d3a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112d3e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112d45:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112d49:	0f 84 99 00 00 00    	je     f0112de8 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112d4f:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112d56:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112d5d:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112d64:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112d6b:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112d72:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112d79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d7c:	8a 00                	mov    (%eax),%al
f0112d7e:	3c 61                	cmp    $0x61,%al
f0112d80:	75 2d                	jne    f0112daf <test_cut_paste_pages+0x9be>
f0112d82:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112d85:	8a 00                	mov    (%eax),%al
f0112d87:	3c 78                	cmp    $0x78,%al
f0112d89:	75 24                	jne    f0112daf <test_cut_paste_pages+0x9be>
f0112d8b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112d8e:	8a 00                	mov    (%eax),%al
f0112d90:	3c 62                	cmp    $0x62,%al
f0112d92:	75 1b                	jne    f0112daf <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112d94:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112d97:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112d99:	3c 79                	cmp    $0x79,%al
f0112d9b:	75 12                	jne    f0112daf <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112d9d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112da0:	8a 00                	mov    (%eax),%al
f0112da2:	3c 63                	cmp    $0x63,%al
f0112da4:	75 09                	jne    f0112daf <test_cut_paste_pages+0x9be>
f0112da6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112da9:	8a 00                	mov    (%eax),%al
f0112dab:	3c 7a                	cmp    $0x7a,%al
f0112dad:	74 28                	je     f0112dd7 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112daf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112db6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112dbd:	83 ec 04             	sub    $0x4,%esp
f0112dc0:	68 28 97 12 f0       	push   $0xf0129728
f0112dc5:	68 b3 02 00 00       	push   $0x2b3
f0112dca:	68 e2 91 12 f0       	push   $0xf01291e2
f0112dcf:	e8 02 d7 fe ff       	call   f01004d6 <_warn>
f0112dd4:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112dd7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ddb:	74 04                	je     f0112de1 <test_cut_paste_pages+0x9f0>
f0112ddd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112de1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112de8:	83 ec 0c             	sub    $0xc,%esp
f0112deb:	68 61 98 12 f0       	push   $0xf0129861
f0112df0:	e8 96 e1 fe ff       	call   f0100f8b <cprintf>
f0112df5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112df8:	83 ec 08             	sub    $0x8,%esp
f0112dfb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112dfe:	68 70 98 12 f0       	push   $0xf0129870
f0112e03:	e8 83 e1 fe ff       	call   f0100f8b <cprintf>
f0112e08:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112e0b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112e0f:	75 10                	jne    f0112e21 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112e11:	83 ec 0c             	sub    $0xc,%esp
f0112e14:	68 a4 98 12 f0       	push   $0xf01298a4
f0112e19:	e8 6d e1 fe ff       	call   f0100f8b <cprintf>
f0112e1e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112e21:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0112e26:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112e29:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e2c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112e2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112e34:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112e37:	5b                   	pop    %ebx
f0112e38:	5e                   	pop    %esi
f0112e39:	5f                   	pop    %edi
f0112e3a:	5d                   	pop    %ebp
f0112e3b:	c3                   	ret    

f0112e3c <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112e3c:	55                   	push   %ebp
f0112e3d:	89 e5                	mov    %esp,%ebp
f0112e3f:	57                   	push   %edi
f0112e40:	56                   	push   %esi
f0112e41:	53                   	push   %ebx
f0112e42:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112e48:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112e4e:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f0112e53:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e58:	89 c7                	mov    %eax,%edi
f0112e5a:	89 de                	mov    %ebx,%esi
f0112e5c:	89 d1                	mov    %edx,%ecx
f0112e5e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e60:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112e66:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112e6b:	b0 00                	mov    $0x0,%al
f0112e6d:	89 d7                	mov    %edx,%edi
f0112e6f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112e71:	6a 00                	push   $0x0
f0112e73:	6a 0a                	push   $0xa
f0112e75:	6a 14                	push   $0x14
f0112e77:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112e7d:	50                   	push   %eax
f0112e7e:	e8 45 81 ff ff       	call   f010afc8 <env_create>
f0112e83:	83 c4 10             	add    $0x10,%esp
f0112e86:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112e89:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e8c:	8b 40 64             	mov    0x64(%eax),%eax
f0112e8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112e92:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e95:	8b 40 68             	mov    0x68(%eax),%eax
f0112e98:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112e9e:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112ea4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112ea7:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112eae:	75 70 20 
f0112eb1:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112eb8:	00 00 00 
f0112ebb:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112ec1:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112ec6:	b8 00 00 00 00       	mov    $0x0,%eax
f0112ecb:	89 d7                	mov    %edx,%edi
f0112ecd:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112ecf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112ed2:	8b 40 10             	mov    0x10(%eax),%eax
f0112ed5:	83 ec 08             	sub    $0x8,%esp
f0112ed8:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112ede:	52                   	push   %edx
f0112edf:	50                   	push   %eax
f0112ee0:	e8 43 d2 00 00       	call   f0120128 <ltostr>
f0112ee5:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112ee8:	83 ec 04             	sub    $0x4,%esp
f0112eeb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112ef1:	50                   	push   %eax
f0112ef2:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112ef8:	50                   	push   %eax
f0112ef9:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112eff:	50                   	push   %eax
f0112f00:	e8 fc d2 00 00       	call   f0120201 <strcconcat>
f0112f05:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112f08:	83 ec 0c             	sub    $0xc,%esp
f0112f0b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f0e:	e8 49 3b 00 00       	call   f0116a5c <ClearUserSpace>
f0112f13:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112f16:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112f1d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112f24:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112f2b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112f32:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112f39:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112f40:	83 ec 0c             	sub    $0xc,%esp
f0112f43:	68 18 99 12 f0       	push   $0xf0129918
f0112f48:	e8 3e e0 fe ff       	call   f0100f8b <cprintf>
f0112f4d:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112f50:	83 ec 04             	sub    $0x4,%esp
f0112f53:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f59:	50                   	push   %eax
f0112f5a:	68 4e 99 12 f0       	push   $0xf012994e
f0112f5f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f65:	50                   	push   %eax
f0112f66:	e8 96 d2 00 00       	call   f0120201 <strcconcat>
f0112f6b:	83 c4 10             	add    $0x10,%esp
f0112f6e:	83 ec 0c             	sub    $0xc,%esp
f0112f71:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f77:	50                   	push   %eax
f0112f78:	e8 7e ef fe ff       	call   f0101efb <execute_command>
f0112f7d:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112f80:	83 ec 04             	sub    $0x4,%esp
f0112f83:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112f89:	50                   	push   %eax
f0112f8a:	68 53 99 12 f0       	push   $0xf0129953
f0112f8f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f95:	50                   	push   %eax
f0112f96:	e8 66 d2 00 00       	call   f0120201 <strcconcat>
f0112f9b:	83 c4 10             	add    $0x10,%esp
f0112f9e:	83 ec 0c             	sub    $0xc,%esp
f0112fa1:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112fa7:	50                   	push   %eax
f0112fa8:	e8 4e ef fe ff       	call   f0101efb <execute_command>
f0112fad:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112fb0:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112fb6:	bb 59 9c 12 f0       	mov    $0xf0129c59,%ebx
f0112fbb:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112fc0:	89 c7                	mov    %eax,%edi
f0112fc2:	89 de                	mov    %ebx,%esi
f0112fc4:	89 d1                	mov    %edx,%ecx
f0112fc6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fc8:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112fce:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fd3:	b0 00                	mov    $0x0,%al
f0112fd5:	89 d7                	mov    %edx,%edi
f0112fd7:	f3 aa                	rep stos %al,%es:(%edi)
f0112fd9:	83 ec 0c             	sub    $0xc,%esp
f0112fdc:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112fe2:	50                   	push   %eax
f0112fe3:	e8 13 ef fe ff       	call   f0101efb <execute_command>
f0112fe8:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0112feb:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112ff1:	bb bd 9c 12 f0       	mov    $0xf0129cbd,%ebx
f0112ff6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ffb:	89 c7                	mov    %eax,%edi
f0112ffd:	89 de                	mov    %ebx,%esi
f0112fff:	89 d1                	mov    %edx,%ecx
f0113001:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113003:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113009:	b9 55 00 00 00       	mov    $0x55,%ecx
f011300e:	b0 00                	mov    $0x0,%al
f0113010:	89 d7                	mov    %edx,%edi
f0113012:	f3 aa                	rep stos %al,%es:(%edi)
f0113014:	83 ec 0c             	sub    $0xc,%esp
f0113017:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011301d:	50                   	push   %eax
f011301e:	e8 d8 ee fe ff       	call   f0101efb <execute_command>
f0113023:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113026:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011302c:	bb 21 9d 12 f0       	mov    $0xf0129d21,%ebx
f0113031:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113036:	89 c7                	mov    %eax,%edi
f0113038:	89 de                	mov    %ebx,%esi
f011303a:	89 d1                	mov    %edx,%ecx
f011303c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011303e:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113044:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113049:	b0 00                	mov    $0x0,%al
f011304b:	89 d7                	mov    %edx,%edi
f011304d:	f3 aa                	rep stos %al,%es:(%edi)
f011304f:	83 ec 0c             	sub    $0xc,%esp
f0113052:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113058:	50                   	push   %eax
f0113059:	e8 9d ee fe ff       	call   f0101efb <execute_command>
f011305e:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113061:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113067:	bb 85 9d 12 f0       	mov    $0xf0129d85,%ebx
f011306c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113071:	89 c7                	mov    %eax,%edi
f0113073:	89 de                	mov    %ebx,%esi
f0113075:	89 d1                	mov    %edx,%ecx
f0113077:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113079:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011307f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113084:	b0 00                	mov    $0x0,%al
f0113086:	89 d7                	mov    %edx,%edi
f0113088:	f3 aa                	rep stos %al,%es:(%edi)
f011308a:	83 ec 0c             	sub    $0xc,%esp
f011308d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113093:	50                   	push   %eax
f0113094:	e8 62 ee fe ff       	call   f0101efb <execute_command>
f0113099:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f011309c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01130a2:	bb e9 9d 12 f0       	mov    $0xf0129de9,%ebx
f01130a7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01130ac:	89 c7                	mov    %eax,%edi
f01130ae:	89 de                	mov    %ebx,%esi
f01130b0:	89 d1                	mov    %edx,%ecx
f01130b2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01130b4:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01130ba:	b9 55 00 00 00       	mov    $0x55,%ecx
f01130bf:	b0 00                	mov    $0x0,%al
f01130c1:	89 d7                	mov    %edx,%edi
f01130c3:	f3 aa                	rep stos %al,%es:(%edi)
f01130c5:	83 ec 0c             	sub    $0xc,%esp
f01130c8:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01130ce:	50                   	push   %eax
f01130cf:	e8 27 ee fe ff       	call   f0101efb <execute_command>
f01130d4:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f01130d7:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01130dd:	bb 4d 9e 12 f0       	mov    $0xf0129e4d,%ebx
f01130e2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01130e7:	89 c7                	mov    %eax,%edi
f01130e9:	89 de                	mov    %ebx,%esi
f01130eb:	89 d1                	mov    %edx,%ecx
f01130ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01130ef:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01130f5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01130fa:	b0 00                	mov    $0x0,%al
f01130fc:	89 d7                	mov    %edx,%edi
f01130fe:	f3 aa                	rep stos %al,%es:(%edi)
f0113100:	83 ec 0c             	sub    $0xc,%esp
f0113103:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113109:	50                   	push   %eax
f011310a:	e8 ec ed fe ff       	call   f0101efb <execute_command>
f011310f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0113112:	83 ec 04             	sub    $0x4,%esp
f0113115:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011311b:	50                   	push   %eax
f011311c:	68 5b 99 12 f0       	push   $0xf012995b
f0113121:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113127:	50                   	push   %eax
f0113128:	e8 d4 d0 00 00       	call   f0120201 <strcconcat>
f011312d:	83 c4 10             	add    $0x10,%esp
f0113130:	83 ec 0c             	sub    $0xc,%esp
f0113133:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113139:	50                   	push   %eax
f011313a:	e8 bc ed fe ff       	call   f0101efb <execute_command>
f011313f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113142:	83 ec 04             	sub    $0x4,%esp
f0113145:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011314b:	50                   	push   %eax
f011314c:	68 65 99 12 f0       	push   $0xf0129965
f0113151:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113157:	50                   	push   %eax
f0113158:	e8 a4 d0 00 00       	call   f0120201 <strcconcat>
f011315d:	83 c4 10             	add    $0x10,%esp
f0113160:	83 ec 0c             	sub    $0xc,%esp
f0113163:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113169:	50                   	push   %eax
f011316a:	e8 8c ed fe ff       	call   f0101efb <execute_command>
f011316f:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113172:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113178:	bb b1 9e 12 f0       	mov    $0xf0129eb1,%ebx
f011317d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113182:	89 c7                	mov    %eax,%edi
f0113184:	89 de                	mov    %ebx,%esi
f0113186:	89 d1                	mov    %edx,%ecx
f0113188:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011318a:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113190:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113195:	b0 00                	mov    $0x0,%al
f0113197:	89 d7                	mov    %edx,%edi
f0113199:	f3 aa                	rep stos %al,%es:(%edi)
f011319b:	83 ec 0c             	sub    $0xc,%esp
f011319e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01131a4:	50                   	push   %eax
f01131a5:	e8 51 ed fe ff       	call   f0101efb <execute_command>
f01131aa:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f01131ad:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01131b3:	bb 15 9f 12 f0       	mov    $0xf0129f15,%ebx
f01131b8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131bd:	89 c7                	mov    %eax,%edi
f01131bf:	89 de                	mov    %ebx,%esi
f01131c1:	89 d1                	mov    %edx,%ecx
f01131c3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131c5:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01131cb:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131d0:	b0 00                	mov    $0x0,%al
f01131d2:	89 d7                	mov    %edx,%edi
f01131d4:	f3 aa                	rep stos %al,%es:(%edi)
f01131d6:	83 ec 0c             	sub    $0xc,%esp
f01131d9:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01131df:	50                   	push   %eax
f01131e0:	e8 16 ed fe ff       	call   f0101efb <execute_command>
f01131e5:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01131e8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01131ee:	bb 79 9f 12 f0       	mov    $0xf0129f79,%ebx
f01131f3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131f8:	89 c7                	mov    %eax,%edi
f01131fa:	89 de                	mov    %ebx,%esi
f01131fc:	89 d1                	mov    %edx,%ecx
f01131fe:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113200:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113206:	b9 55 00 00 00       	mov    $0x55,%ecx
f011320b:	b0 00                	mov    $0x0,%al
f011320d:	89 d7                	mov    %edx,%edi
f011320f:	f3 aa                	rep stos %al,%es:(%edi)
f0113211:	83 ec 0c             	sub    $0xc,%esp
f0113214:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011321a:	50                   	push   %eax
f011321b:	e8 db ec fe ff       	call   f0101efb <execute_command>
f0113220:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113223:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011322a:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113231:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0113238:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f011323f:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113246:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f011324d:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113254:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f011325b:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113262:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113269:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113270:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113277:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011327a:	8a 00                	mov    (%eax),%al
f011327c:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113282:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113285:	8a 00                	mov    (%eax),%al
f0113287:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f011328d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113290:	8a 00                	mov    (%eax),%al
f0113292:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113298:	e8 cb b6 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011329d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f01132a0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01132a3:	89 d0                	mov    %edx,%eax
f01132a5:	01 c0                	add    %eax,%eax
f01132a7:	01 d0                	add    %edx,%eax
f01132a9:	01 c0                	add    %eax,%eax
f01132ab:	50                   	push   %eax
f01132ac:	68 00 00 10 00       	push   $0x100000
f01132b1:	6a 00                	push   $0x0
f01132b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132b6:	e8 66 78 ff ff       	call   f010ab21 <copy_paste_chunk>
f01132bb:	83 c4 10             	add    $0x10,%esp
f01132be:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01132c1:	e8 a2 b6 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01132c6:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01132c9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01132d0:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01132d4:	75 08                	jne    f01132de <test_copy_paste_chunk+0x4a2>
f01132d6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01132d9:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01132dc:	74 2b                	je     f0113309 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01132de:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01132e1:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01132e4:	83 ec 0c             	sub    $0xc,%esp
f01132e7:	50                   	push   %eax
f01132e8:	ff 75 88             	pushl  -0x78(%ebp)
f01132eb:	68 74 99 12 f0       	push   $0xf0129974
f01132f0:	68 06 03 00 00       	push   $0x306
f01132f5:	68 e2 91 12 f0       	push   $0xf01291e2
f01132fa:	e8 d7 d1 fe ff       	call   f01004d6 <_warn>
f01132ff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113302:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113309:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011330d:	74 04                	je     f0113313 <test_copy_paste_chunk+0x4d7>
f011330f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113313:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f011331a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011331d:	8a 00                	mov    (%eax),%al
f011331f:	3c 61                	cmp    $0x61,%al
f0113321:	75 75                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113323:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113326:	8a 00                	mov    (%eax),%al
f0113328:	3c 78                	cmp    $0x78,%al
f011332a:	75 6c                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f011332c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011332f:	8a 00                	mov    (%eax),%al
f0113331:	3c 62                	cmp    $0x62,%al
f0113333:	75 63                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113335:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113338:	8a 00                	mov    (%eax),%al
f011333a:	3c 79                	cmp    $0x79,%al
f011333c:	75 5a                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f011333e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113341:	8a 00                	mov    (%eax),%al
f0113343:	3c 63                	cmp    $0x63,%al
f0113345:	75 51                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113347:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011334a:	8a 00                	mov    (%eax),%al
f011334c:	3c 7a                	cmp    $0x7a,%al
f011334e:	75 48                	jne    f0113398 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113350:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113353:	8a 00                	mov    (%eax),%al
f0113355:	3c 64                	cmp    $0x64,%al
f0113357:	75 3f                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113359:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011335c:	8a 10                	mov    (%eax),%dl
f011335e:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113364:	38 c2                	cmp    %al,%dl
f0113366:	75 30                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113368:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011336b:	8a 00                	mov    (%eax),%al
f011336d:	3c 65                	cmp    $0x65,%al
f011336f:	75 27                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113371:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113374:	8a 10                	mov    (%eax),%dl
f0113376:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f011337c:	38 c2                	cmp    %al,%dl
f011337e:	75 18                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113380:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113383:	8a 00                	mov    (%eax),%al
f0113385:	3c 66                	cmp    $0x66,%al
f0113387:	75 0f                	jne    f0113398 <test_copy_paste_chunk+0x55c>
f0113389:	8b 45 90             	mov    -0x70(%ebp),%eax
f011338c:	8a 10                	mov    (%eax),%dl
f011338e:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113394:	38 c2                	cmp    %al,%dl
f0113396:	74 21                	je     f01133b9 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113398:	83 ec 04             	sub    $0x4,%esp
f011339b:	68 d8 99 12 f0       	push   $0xf01299d8
f01133a0:	68 0f 03 00 00       	push   $0x30f
f01133a5:	68 e2 91 12 f0       	push   $0xf01291e2
f01133aa:	e8 27 d1 fe ff       	call   f01004d6 <_warn>
f01133af:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01133b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01133b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01133bd:	74 04                	je     f01133c3 <test_copy_paste_chunk+0x587>
f01133bf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01133c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01133ca:	83 ec 0c             	sub    $0xc,%esp
f01133cd:	68 12 9a 12 f0       	push   $0xf0129a12
f01133d2:	e8 b4 db fe ff       	call   f0100f8b <cprintf>
f01133d7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01133da:	83 ec 0c             	sub    $0xc,%esp
f01133dd:	68 24 9a 12 f0       	push   $0xf0129a24
f01133e2:	e8 a4 db fe ff       	call   f0100f8b <cprintf>
f01133e7:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01133ea:	83 ec 04             	sub    $0x4,%esp
f01133ed:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01133f3:	50                   	push   %eax
f01133f4:	68 5a 9a 12 f0       	push   $0xf0129a5a
f01133f9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133ff:	50                   	push   %eax
f0113400:	e8 fc cd 00 00       	call   f0120201 <strcconcat>
f0113405:	83 c4 10             	add    $0x10,%esp
f0113408:	83 ec 0c             	sub    $0xc,%esp
f011340b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113411:	50                   	push   %eax
f0113412:	e8 e4 ea fe ff       	call   f0101efb <execute_command>
f0113417:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f011341a:	83 ec 04             	sub    $0x4,%esp
f011341d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113423:	50                   	push   %eax
f0113424:	68 64 9a 12 f0       	push   $0xf0129a64
f0113429:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011342f:	50                   	push   %eax
f0113430:	e8 cc cd 00 00       	call   f0120201 <strcconcat>
f0113435:	83 c4 10             	add    $0x10,%esp
f0113438:	83 ec 0c             	sub    $0xc,%esp
f011343b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113441:	50                   	push   %eax
f0113442:	e8 b4 ea fe ff       	call   f0101efb <execute_command>
f0113447:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011344a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113450:	bb dd 9f 12 f0       	mov    $0xf0129fdd,%ebx
f0113455:	ba 0f 00 00 00       	mov    $0xf,%edx
f011345a:	89 c7                	mov    %eax,%edi
f011345c:	89 de                	mov    %ebx,%esi
f011345e:	89 d1                	mov    %edx,%ecx
f0113460:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113462:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113468:	b9 55 00 00 00       	mov    $0x55,%ecx
f011346d:	b0 00                	mov    $0x0,%al
f011346f:	89 d7                	mov    %edx,%edi
f0113471:	f3 aa                	rep stos %al,%es:(%edi)
f0113473:	83 ec 0c             	sub    $0xc,%esp
f0113476:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011347c:	50                   	push   %eax
f011347d:	e8 79 ea fe ff       	call   f0101efb <execute_command>
f0113482:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113485:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011348b:	bb 41 a0 12 f0       	mov    $0xf012a041,%ebx
f0113490:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113495:	89 c7                	mov    %eax,%edi
f0113497:	89 de                	mov    %ebx,%esi
f0113499:	89 d1                	mov    %edx,%ecx
f011349b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011349d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01134a3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134a8:	b0 00                	mov    $0x0,%al
f01134aa:	89 d7                	mov    %edx,%edi
f01134ac:	f3 aa                	rep stos %al,%es:(%edi)
f01134ae:	83 ec 0c             	sub    $0xc,%esp
f01134b1:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01134b7:	50                   	push   %eax
f01134b8:	e8 3e ea fe ff       	call   f0101efb <execute_command>
f01134bd:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01134c0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01134c6:	bb a5 a0 12 f0       	mov    $0xf012a0a5,%ebx
f01134cb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134d0:	89 c7                	mov    %eax,%edi
f01134d2:	89 de                	mov    %ebx,%esi
f01134d4:	89 d1                	mov    %edx,%ecx
f01134d6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134d8:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01134de:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134e3:	b0 00                	mov    $0x0,%al
f01134e5:	89 d7                	mov    %edx,%edi
f01134e7:	f3 aa                	rep stos %al,%es:(%edi)
f01134e9:	83 ec 0c             	sub    $0xc,%esp
f01134ec:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01134f2:	50                   	push   %eax
f01134f3:	e8 03 ea fe ff       	call   f0101efb <execute_command>
f01134f8:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01134fb:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113501:	bb 09 a1 12 f0       	mov    $0xf012a109,%ebx
f0113506:	ba 0f 00 00 00       	mov    $0xf,%edx
f011350b:	89 c7                	mov    %eax,%edi
f011350d:	89 de                	mov    %ebx,%esi
f011350f:	89 d1                	mov    %edx,%ecx
f0113511:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113513:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113519:	b9 55 00 00 00       	mov    $0x55,%ecx
f011351e:	b0 00                	mov    $0x0,%al
f0113520:	89 d7                	mov    %edx,%edi
f0113522:	f3 aa                	rep stos %al,%es:(%edi)
f0113524:	83 ec 0c             	sub    $0xc,%esp
f0113527:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011352d:	50                   	push   %eax
f011352e:	e8 c8 e9 fe ff       	call   f0101efb <execute_command>
f0113533:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113536:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011353c:	bb 6d a1 12 f0       	mov    $0xf012a16d,%ebx
f0113541:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113546:	89 c7                	mov    %eax,%edi
f0113548:	89 de                	mov    %ebx,%esi
f011354a:	89 d1                	mov    %edx,%ecx
f011354c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011354e:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113554:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113559:	b0 00                	mov    $0x0,%al
f011355b:	89 d7                	mov    %edx,%edi
f011355d:	f3 aa                	rep stos %al,%es:(%edi)
f011355f:	83 ec 0c             	sub    $0xc,%esp
f0113562:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113568:	50                   	push   %eax
f0113569:	e8 8d e9 fe ff       	call   f0101efb <execute_command>
f011356e:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0113571:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113577:	bb d1 a1 12 f0       	mov    $0xf012a1d1,%ebx
f011357c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113581:	89 c7                	mov    %eax,%edi
f0113583:	89 de                	mov    %ebx,%esi
f0113585:	89 d1                	mov    %edx,%ecx
f0113587:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113589:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011358f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113594:	b0 00                	mov    $0x0,%al
f0113596:	89 d7                	mov    %edx,%edi
f0113598:	f3 aa                	rep stos %al,%es:(%edi)
f011359a:	83 ec 0c             	sub    $0xc,%esp
f011359d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135a3:	50                   	push   %eax
f01135a4:	e8 52 e9 fe ff       	call   f0101efb <execute_command>
f01135a9:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f01135ac:	83 ec 04             	sub    $0x4,%esp
f01135af:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01135b5:	50                   	push   %eax
f01135b6:	68 6e 9a 12 f0       	push   $0xf0129a6e
f01135bb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01135c1:	50                   	push   %eax
f01135c2:	e8 3a cc 00 00       	call   f0120201 <strcconcat>
f01135c7:	83 c4 10             	add    $0x10,%esp
f01135ca:	83 ec 0c             	sub    $0xc,%esp
f01135cd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01135d3:	50                   	push   %eax
f01135d4:	e8 22 e9 fe ff       	call   f0101efb <execute_command>
f01135d9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f01135dc:	83 ec 04             	sub    $0x4,%esp
f01135df:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01135e5:	50                   	push   %eax
f01135e6:	68 78 9a 12 f0       	push   $0xf0129a78
f01135eb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01135f1:	50                   	push   %eax
f01135f2:	e8 0a cc 00 00       	call   f0120201 <strcconcat>
f01135f7:	83 c4 10             	add    $0x10,%esp
f01135fa:	83 ec 0c             	sub    $0xc,%esp
f01135fd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113603:	50                   	push   %eax
f0113604:	e8 f2 e8 fe ff       	call   f0101efb <execute_command>
f0113609:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f011360c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113612:	bb 35 a2 12 f0       	mov    $0xf012a235,%ebx
f0113617:	ba 0f 00 00 00       	mov    $0xf,%edx
f011361c:	89 c7                	mov    %eax,%edi
f011361e:	89 de                	mov    %ebx,%esi
f0113620:	89 d1                	mov    %edx,%ecx
f0113622:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113624:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011362a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011362f:	b0 00                	mov    $0x0,%al
f0113631:	89 d7                	mov    %edx,%edi
f0113633:	f3 aa                	rep stos %al,%es:(%edi)
f0113635:	83 ec 0c             	sub    $0xc,%esp
f0113638:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011363e:	50                   	push   %eax
f011363f:	e8 b7 e8 fe ff       	call   f0101efb <execute_command>
f0113644:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113647:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011364d:	bb 99 a2 12 f0       	mov    $0xf012a299,%ebx
f0113652:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113657:	89 c7                	mov    %eax,%edi
f0113659:	89 de                	mov    %ebx,%esi
f011365b:	89 d1                	mov    %edx,%ecx
f011365d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011365f:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113665:	b9 55 00 00 00       	mov    $0x55,%ecx
f011366a:	b0 00                	mov    $0x0,%al
f011366c:	89 d7                	mov    %edx,%edi
f011366e:	f3 aa                	rep stos %al,%es:(%edi)
f0113670:	83 ec 0c             	sub    $0xc,%esp
f0113673:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113679:	50                   	push   %eax
f011367a:	e8 7c e8 fe ff       	call   f0101efb <execute_command>
f011367f:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113682:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113688:	bb fd a2 12 f0       	mov    $0xf012a2fd,%ebx
f011368d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113692:	89 c7                	mov    %eax,%edi
f0113694:	89 de                	mov    %ebx,%esi
f0113696:	89 d1                	mov    %edx,%ecx
f0113698:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011369a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01136a0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136a5:	b0 00                	mov    $0x0,%al
f01136a7:	89 d7                	mov    %edx,%edi
f01136a9:	f3 aa                	rep stos %al,%es:(%edi)
f01136ab:	83 ec 0c             	sub    $0xc,%esp
f01136ae:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136b4:	50                   	push   %eax
f01136b5:	e8 41 e8 fe ff       	call   f0101efb <execute_command>
f01136ba:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f01136bd:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01136c4:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01136cb:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01136d2:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f01136d9:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f01136e0:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f01136e7:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01136ee:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01136f5:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01136fc:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113703:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011370a:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113711:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113714:	8a 00                	mov    (%eax),%al
f0113716:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011371c:	e8 47 b2 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113721:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113724:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113727:	89 d0                	mov    %edx,%eax
f0113729:	01 c0                	add    %eax,%eax
f011372b:	01 d0                	add    %edx,%eax
f011372d:	01 c0                	add    %eax,%eax
f011372f:	50                   	push   %eax
f0113730:	68 00 00 40 00       	push   $0x400000
f0113735:	68 00 00 20 00       	push   $0x200000
f011373a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011373d:	e8 df 73 ff ff       	call   f010ab21 <copy_paste_chunk>
f0113742:	83 c4 10             	add    $0x10,%esp
f0113745:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113748:	e8 1b b2 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011374d:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113750:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113757:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011375b:	75 08                	jne    f0113765 <test_copy_paste_chunk+0x929>
f011375d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113760:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113763:	74 2b                	je     f0113790 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113765:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113768:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011376b:	83 ec 0c             	sub    $0xc,%esp
f011376e:	50                   	push   %eax
f011376f:	ff 75 80             	pushl  -0x80(%ebp)
f0113772:	68 84 9a 12 f0       	push   $0xf0129a84
f0113777:	68 3f 03 00 00       	push   $0x33f
f011377c:	68 e2 91 12 f0       	push   $0xf01291e2
f0113781:	e8 50 cd fe ff       	call   f01004d6 <_warn>
f0113786:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113789:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113790:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113794:	74 04                	je     f011379a <test_copy_paste_chunk+0x95e>
f0113796:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011379a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01137a1:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01137a8:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01137ab:	83 ec 08             	sub    $0x8,%esp
f01137ae:	6a 01                	push   $0x1
f01137b0:	6a 07                	push   $0x7
f01137b2:	6a 07                	push   $0x7
f01137b4:	6a 07                	push   $0x7
f01137b6:	6a 07                	push   $0x7
f01137b8:	6a 01                	push   $0x1
f01137ba:	68 00 20 00 00       	push   $0x2000
f01137bf:	68 00 00 40 00       	push   $0x400000
f01137c4:	68 00 00 20 00       	push   $0x200000
f01137c9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01137cc:	e8 bf 32 00 00       	call   f0116a90 <CCP>
f01137d1:	83 c4 30             	add    $0x30,%esp
f01137d4:	83 f8 01             	cmp    $0x1,%eax
f01137d7:	74 2b                	je     f0113804 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f01137d9:	83 ec 04             	sub    $0x4,%esp
f01137dc:	68 d8 9a 12 f0       	push   $0xf0129ad8
f01137e1:	68 48 03 00 00       	push   $0x348
f01137e6:	68 e2 91 12 f0       	push   $0xf01291e2
f01137eb:	e8 e6 cc fe ff       	call   f01004d6 <_warn>
f01137f0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01137f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01137fa:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113801:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113804:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113808:	74 04                	je     f011380e <test_copy_paste_chunk+0x9d2>
f011380a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011380e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113815:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113818:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011381b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011381e:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113821:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113824:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113827:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011382a:	8a 00                	mov    (%eax),%al
f011382c:	3c 61                	cmp    $0x61,%al
f011382e:	75 69                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113830:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113833:	8a 00                	mov    (%eax),%al
f0113835:	3c 61                	cmp    $0x61,%al
f0113837:	75 60                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113839:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011383c:	8a 00                	mov    (%eax),%al
f011383e:	3c 79                	cmp    $0x79,%al
f0113840:	75 57                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113842:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113845:	8a 00                	mov    (%eax),%al
f0113847:	3c 62                	cmp    $0x62,%al
f0113849:	75 4e                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f011384b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011384e:	8a 00                	mov    (%eax),%al
f0113850:	3c 63                	cmp    $0x63,%al
f0113852:	75 45                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113854:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113857:	8a 00                	mov    (%eax),%al
f0113859:	3c 7a                	cmp    $0x7a,%al
f011385b:	75 3c                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f011385d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113860:	8a 00                	mov    (%eax),%al
f0113862:	3c 77                	cmp    $0x77,%al
f0113864:	75 33                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113866:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113869:	8a 00                	mov    (%eax),%al
f011386b:	3c 64                	cmp    $0x64,%al
f011386d:	75 2a                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f011386f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113872:	8a 00                	mov    (%eax),%al
f0113874:	3c 65                	cmp    $0x65,%al
f0113876:	75 21                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113878:	8b 45 98             	mov    -0x68(%ebp),%eax
f011387b:	8a 00                	mov    (%eax),%al
f011387d:	3c 65                	cmp    $0x65,%al
f011387f:	75 18                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f0113881:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113884:	8a 00                	mov    (%eax),%al
f0113886:	3c 66                	cmp    $0x66,%al
f0113888:	75 0f                	jne    f0113899 <test_copy_paste_chunk+0xa5d>
f011388a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011388d:	8a 10                	mov    (%eax),%dl
f011388f:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113895:	38 c2                	cmp    %al,%dl
f0113897:	74 21                	je     f01138ba <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113899:	83 ec 04             	sub    $0x4,%esp
f011389c:	68 d8 99 12 f0       	push   $0xf01299d8
f01138a1:	68 56 03 00 00       	push   $0x356
f01138a6:	68 e2 91 12 f0       	push   $0xf01291e2
f01138ab:	e8 26 cc fe ff       	call   f01004d6 <_warn>
f01138b0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01138b3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01138ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138be:	74 04                	je     f01138c4 <test_copy_paste_chunk+0xa88>
f01138c0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01138c4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f01138cb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01138ce:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01138d1:	e8 92 b0 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01138d6:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f01138d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01138dc:	89 c2                	mov    %eax,%edx
f01138de:	01 d2                	add    %edx,%edx
f01138e0:	01 d0                	add    %edx,%eax
f01138e2:	50                   	push   %eax
f01138e3:	68 00 08 20 00       	push   $0x200800
f01138e8:	68 00 08 40 00       	push   $0x400800
f01138ed:	ff 75 d4             	pushl  -0x2c(%ebp)
f01138f0:	e8 2c 72 ff ff       	call   f010ab21 <copy_paste_chunk>
f01138f5:	83 c4 10             	add    $0x10,%esp
f01138f8:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01138fb:	e8 68 b0 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113900:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113903:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113907:	75 08                	jne    f0113911 <test_copy_paste_chunk+0xad5>
f0113909:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011390c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011390f:	74 2b                	je     f011393c <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113911:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113914:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113917:	83 ec 0c             	sub    $0xc,%esp
f011391a:	50                   	push   %eax
f011391b:	ff 75 80             	pushl  -0x80(%ebp)
f011391e:	68 84 9a 12 f0       	push   $0xf0129a84
f0113923:	68 66 03 00 00       	push   $0x366
f0113928:	68 e2 91 12 f0       	push   $0xf01291e2
f011392d:	e8 a4 cb fe ff       	call   f01004d6 <_warn>
f0113932:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113935:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011393c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113940:	74 04                	je     f0113946 <test_copy_paste_chunk+0xb0a>
f0113942:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113946:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011394d:	83 ec 08             	sub    $0x8,%esp
f0113950:	6a 01                	push   $0x1
f0113952:	6a 07                	push   $0x7
f0113954:	6a 07                	push   $0x7
f0113956:	6a 07                	push   $0x7
f0113958:	6a 07                	push   $0x7
f011395a:	6a 01                	push   $0x1
f011395c:	68 00 20 00 00       	push   $0x2000
f0113961:	68 00 00 20 00       	push   $0x200000
f0113966:	68 00 00 40 00       	push   $0x400000
f011396b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011396e:	e8 1d 31 00 00       	call   f0116a90 <CCP>
f0113973:	83 c4 30             	add    $0x30,%esp
f0113976:	83 f8 01             	cmp    $0x1,%eax
f0113979:	74 21                	je     f011399c <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f011397b:	83 ec 04             	sub    $0x4,%esp
f011397e:	68 24 9b 12 f0       	push   $0xf0129b24
f0113983:	68 6e 03 00 00       	push   $0x36e
f0113988:	68 e2 91 12 f0       	push   $0xf01291e2
f011398d:	e8 44 cb fe ff       	call   f01004d6 <_warn>
f0113992:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113995:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011399c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139a0:	74 04                	je     f01139a6 <test_copy_paste_chunk+0xb6a>
f01139a2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139a6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01139ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01139b0:	8a 00                	mov    (%eax),%al
f01139b2:	3c 61                	cmp    $0x61,%al
f01139b4:	75 69                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139b6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01139b9:	8a 00                	mov    (%eax),%al
f01139bb:	3c 61                	cmp    $0x61,%al
f01139bd:	75 60                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139bf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139c2:	8a 00                	mov    (%eax),%al
f01139c4:	3c 79                	cmp    $0x79,%al
f01139c6:	75 57                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139c8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01139cb:	8a 00                	mov    (%eax),%al
f01139cd:	3c 62                	cmp    $0x62,%al
f01139cf:	75 4e                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139d1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01139d4:	8a 00                	mov    (%eax),%al
f01139d6:	3c 7a                	cmp    $0x7a,%al
f01139d8:	75 45                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139da:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01139dd:	8a 00                	mov    (%eax),%al
f01139df:	3c 7a                	cmp    $0x7a,%al
f01139e1:	75 3c                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01139e3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01139e6:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01139e8:	3c 64                	cmp    $0x64,%al
f01139ea:	75 33                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01139ec:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01139ef:	8a 00                	mov    (%eax),%al
f01139f1:	3c 64                	cmp    $0x64,%al
f01139f3:	75 2a                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139f5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01139f8:	8a 00                	mov    (%eax),%al
f01139fa:	3c 65                	cmp    $0x65,%al
f01139fc:	75 21                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f01139fe:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113a01:	8a 00                	mov    (%eax),%al
f0113a03:	3c 78                	cmp    $0x78,%al
f0113a05:	75 18                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f0113a07:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113a0a:	8a 00                	mov    (%eax),%al
f0113a0c:	3c 66                	cmp    $0x66,%al
f0113a0e:	75 0f                	jne    f0113a1f <test_copy_paste_chunk+0xbe3>
f0113a10:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113a13:	8a 10                	mov    (%eax),%dl
f0113a15:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113a1b:	38 c2                	cmp    %al,%dl
f0113a1d:	74 21                	je     f0113a40 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113a1f:	83 ec 04             	sub    $0x4,%esp
f0113a22:	68 d8 99 12 f0       	push   $0xf01299d8
f0113a27:	68 77 03 00 00       	push   $0x377
f0113a2c:	68 e2 91 12 f0       	push   $0xf01291e2
f0113a31:	e8 a0 ca fe ff       	call   f01004d6 <_warn>
f0113a36:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a39:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113a40:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a44:	74 04                	je     f0113a4a <test_copy_paste_chunk+0xc0e>
f0113a46:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113a4a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113a51:	83 ec 0c             	sub    $0xc,%esp
f0113a54:	68 6f 9b 12 f0       	push   $0xf0129b6f
f0113a59:	e8 2d d5 fe ff       	call   f0100f8b <cprintf>
f0113a5e:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113a61:	83 ec 0c             	sub    $0xc,%esp
f0113a64:	68 80 9b 12 f0       	push   $0xf0129b80
f0113a69:	e8 1d d5 fe ff       	call   f0100f8b <cprintf>
f0113a6e:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113a71:	83 ec 04             	sub    $0x4,%esp
f0113a74:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a7a:	50                   	push   %eax
f0113a7b:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0113a80:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a86:	50                   	push   %eax
f0113a87:	e8 75 c7 00 00       	call   f0120201 <strcconcat>
f0113a8c:	83 c4 10             	add    $0x10,%esp
f0113a8f:	83 ec 0c             	sub    $0xc,%esp
f0113a92:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a98:	50                   	push   %eax
f0113a99:	e8 5d e4 fe ff       	call   f0101efb <execute_command>
f0113a9e:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113aa1:	83 ec 04             	sub    $0x4,%esp
f0113aa4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113aaa:	50                   	push   %eax
f0113aab:	68 be 9b 12 f0       	push   $0xf0129bbe
f0113ab0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ab6:	50                   	push   %eax
f0113ab7:	e8 45 c7 00 00       	call   f0120201 <strcconcat>
f0113abc:	83 c4 10             	add    $0x10,%esp
f0113abf:	83 ec 0c             	sub    $0xc,%esp
f0113ac2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ac8:	50                   	push   %eax
f0113ac9:	e8 2d e4 fe ff       	call   f0101efb <execute_command>
f0113ace:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113ad1:	83 ec 04             	sub    $0x4,%esp
f0113ad4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ada:	50                   	push   %eax
f0113adb:	68 c8 9b 12 f0       	push   $0xf0129bc8
f0113ae0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ae6:	50                   	push   %eax
f0113ae7:	e8 15 c7 00 00       	call   f0120201 <strcconcat>
f0113aec:	83 c4 10             	add    $0x10,%esp
f0113aef:	83 ec 0c             	sub    $0xc,%esp
f0113af2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113af8:	50                   	push   %eax
f0113af9:	e8 fd e3 fe ff       	call   f0101efb <execute_command>
f0113afe:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113b01:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b07:	bb 61 a3 12 f0       	mov    $0xf012a361,%ebx
f0113b0c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b11:	89 c7                	mov    %eax,%edi
f0113b13:	89 de                	mov    %ebx,%esi
f0113b15:	89 d1                	mov    %edx,%ecx
f0113b17:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b19:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113b1f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b24:	b0 00                	mov    $0x0,%al
f0113b26:	89 d7                	mov    %edx,%edi
f0113b28:	f3 aa                	rep stos %al,%es:(%edi)
f0113b2a:	83 ec 0c             	sub    $0xc,%esp
f0113b2d:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b33:	50                   	push   %eax
f0113b34:	e8 c2 e3 fe ff       	call   f0101efb <execute_command>
f0113b39:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113b3c:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b42:	bb c5 a3 12 f0       	mov    $0xf012a3c5,%ebx
f0113b47:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b4c:	89 c7                	mov    %eax,%edi
f0113b4e:	89 de                	mov    %ebx,%esi
f0113b50:	89 d1                	mov    %edx,%ecx
f0113b52:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b54:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113b5a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b5f:	b0 00                	mov    $0x0,%al
f0113b61:	89 d7                	mov    %edx,%edi
f0113b63:	f3 aa                	rep stos %al,%es:(%edi)
f0113b65:	83 ec 0c             	sub    $0xc,%esp
f0113b68:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b6e:	50                   	push   %eax
f0113b6f:	e8 87 e3 fe ff       	call   f0101efb <execute_command>
f0113b74:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113b77:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b7d:	bb 29 a4 12 f0       	mov    $0xf012a429,%ebx
f0113b82:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b87:	89 c7                	mov    %eax,%edi
f0113b89:	89 de                	mov    %ebx,%esi
f0113b8b:	89 d1                	mov    %edx,%ecx
f0113b8d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b8f:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113b95:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b9a:	b0 00                	mov    $0x0,%al
f0113b9c:	89 d7                	mov    %edx,%edi
f0113b9e:	f3 aa                	rep stos %al,%es:(%edi)
f0113ba0:	83 ec 0c             	sub    $0xc,%esp
f0113ba3:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113ba9:	50                   	push   %eax
f0113baa:	e8 4c e3 fe ff       	call   f0101efb <execute_command>
f0113baf:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113bb2:	e8 b1 ad ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113bb7:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113bba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113bbd:	89 d0                	mov    %edx,%eax
f0113bbf:	01 c0                	add    %eax,%eax
f0113bc1:	01 d0                	add    %edx,%eax
f0113bc3:	c1 e0 02             	shl    $0x2,%eax
f0113bc6:	50                   	push   %eax
f0113bc7:	68 00 00 90 00       	push   $0x900000
f0113bcc:	68 00 00 80 00       	push   $0x800000
f0113bd1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113bd4:	e8 48 6f ff ff       	call   f010ab21 <copy_paste_chunk>
f0113bd9:	83 c4 10             	add    $0x10,%esp
f0113bdc:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113be2:	e8 81 ad ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113be7:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113bea:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113bf1:	75 0b                	jne    f0113bfe <test_copy_paste_chunk+0xdc2>
f0113bf3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113bf6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113bf9:	83 f8 03             	cmp    $0x3,%eax
f0113bfc:	74 2e                	je     f0113c2c <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113bfe:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c01:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113c04:	83 ec 0c             	sub    $0xc,%esp
f0113c07:	50                   	push   %eax
f0113c08:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113c0e:	68 84 9a 12 f0       	push   $0xf0129a84
f0113c13:	68 95 03 00 00       	push   $0x395
f0113c18:	68 e2 91 12 f0       	push   $0xf01291e2
f0113c1d:	e8 b4 c8 fe ff       	call   f01004d6 <_warn>
f0113c22:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113c25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c2c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c30:	74 04                	je     f0113c36 <test_copy_paste_chunk+0xdfa>
f0113c32:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c36:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113c3d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113c44:	83 ec 08             	sub    $0x8,%esp
f0113c47:	6a 01                	push   $0x1
f0113c49:	6a 07                	push   $0x7
f0113c4b:	6a 07                	push   $0x7
f0113c4d:	6a 07                	push   $0x7
f0113c4f:	6a 07                	push   $0x7
f0113c51:	6a 01                	push   $0x1
f0113c53:	68 00 30 00 00       	push   $0x3000
f0113c58:	68 00 00 90 00       	push   $0x900000
f0113c5d:	68 00 00 80 00       	push   $0x800000
f0113c62:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c65:	e8 26 2e 00 00       	call   f0116a90 <CCP>
f0113c6a:	83 c4 30             	add    $0x30,%esp
f0113c6d:	83 f8 01             	cmp    $0x1,%eax
f0113c70:	74 28                	je     f0113c9a <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113c72:	83 ec 04             	sub    $0x4,%esp
f0113c75:	68 24 9b 12 f0       	push   $0xf0129b24
f0113c7a:	68 9e 03 00 00       	push   $0x39e
f0113c7f:	68 e2 91 12 f0       	push   $0xf01291e2
f0113c84:	e8 4d c8 fe ff       	call   f01004d6 <_warn>
f0113c89:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113c93:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113c9a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c9e:	74 04                	je     f0113ca4 <test_copy_paste_chunk+0xe68>
f0113ca0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ca4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113cab:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113caf:	0f 84 9e 00 00 00    	je     f0113d53 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113cb5:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113cbc:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113cc3:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113cca:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113cd1:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113cd8:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113cdf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ce2:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113ce5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113ce8:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113ceb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cee:	8a 00                	mov    (%eax),%al
f0113cf0:	3c 61                	cmp    $0x61,%al
f0113cf2:	75 2d                	jne    f0113d21 <test_copy_paste_chunk+0xee5>
f0113cf4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113cf7:	8a 00                	mov    (%eax),%al
f0113cf9:	3c 61                	cmp    $0x61,%al
f0113cfb:	75 24                	jne    f0113d21 <test_copy_paste_chunk+0xee5>
f0113cfd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d00:	8a 00                	mov    (%eax),%al
f0113d02:	3c 79                	cmp    $0x79,%al
f0113d04:	75 1b                	jne    f0113d21 <test_copy_paste_chunk+0xee5>
f0113d06:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113d09:	8a 00                	mov    (%eax),%al
f0113d0b:	3c 62                	cmp    $0x62,%al
f0113d0d:	75 12                	jne    f0113d21 <test_copy_paste_chunk+0xee5>
f0113d0f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113d12:	8a 00                	mov    (%eax),%al
f0113d14:	3c 63                	cmp    $0x63,%al
f0113d16:	75 09                	jne    f0113d21 <test_copy_paste_chunk+0xee5>
f0113d18:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d1b:	8a 00                	mov    (%eax),%al
f0113d1d:	3c 7a                	cmp    $0x7a,%al
f0113d1f:	74 21                	je     f0113d42 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113d21:	83 ec 04             	sub    $0x4,%esp
f0113d24:	68 d8 99 12 f0       	push   $0xf01299d8
f0113d29:	68 b0 03 00 00       	push   $0x3b0
f0113d2e:	68 e2 91 12 f0       	push   $0xf01291e2
f0113d33:	e8 9e c7 fe ff       	call   f01004d6 <_warn>
f0113d38:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113d3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113d42:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d46:	74 04                	je     f0113d4c <test_copy_paste_chunk+0xf10>
f0113d48:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113d4c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113d53:	e8 10 ac ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113d58:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113d5b:	6a 00                	push   $0x0
f0113d5d:	6a 02                	push   $0x2
f0113d5f:	68 00 10 90 00       	push   $0x901000
f0113d64:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d67:	e8 b1 2b 00 00       	call   f011691d <SB>
f0113d6c:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113d6f:	6a 00                	push   $0x0
f0113d71:	6a 02                	push   $0x2
f0113d73:	68 00 20 90 00       	push   $0x902000
f0113d78:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d7b:	e8 9d 2b 00 00       	call   f011691d <SB>
f0113d80:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113d83:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113d86:	c1 e0 03             	shl    $0x3,%eax
f0113d89:	50                   	push   %eax
f0113d8a:	68 00 f0 bf 00       	push   $0xbff000
f0113d8f:	68 00 10 90 00       	push   $0x901000
f0113d94:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d97:	e8 85 6d ff ff       	call   f010ab21 <copy_paste_chunk>
f0113d9c:	83 c4 10             	add    $0x10,%esp
f0113d9f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113da5:	e8 be ab ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113daa:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113dad:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113db4:	75 0b                	jne    f0113dc1 <test_copy_paste_chunk+0xf85>
f0113db6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113db9:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113dbc:	83 f8 03             	cmp    $0x3,%eax
f0113dbf:	74 2e                	je     f0113def <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113dc1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113dc4:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113dc7:	83 ec 0c             	sub    $0xc,%esp
f0113dca:	50                   	push   %eax
f0113dcb:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113dd1:	68 84 9a 12 f0       	push   $0xf0129a84
f0113dd6:	68 c0 03 00 00       	push   $0x3c0
f0113ddb:	68 e2 91 12 f0       	push   $0xf01291e2
f0113de0:	e8 f1 c6 fe ff       	call   f01004d6 <_warn>
f0113de5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113de8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113def:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113df3:	74 04                	je     f0113df9 <test_copy_paste_chunk+0xfbd>
f0113df5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113df9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113e00:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113e07:	83 ec 08             	sub    $0x8,%esp
f0113e0a:	6a 01                	push   $0x1
f0113e0c:	6a 07                	push   $0x7
f0113e0e:	6a 03                	push   $0x3
f0113e10:	6a 07                	push   $0x7
f0113e12:	6a 03                	push   $0x3
f0113e14:	6a 01                	push   $0x1
f0113e16:	68 00 20 00 00       	push   $0x2000
f0113e1b:	68 00 f0 bf 00       	push   $0xbff000
f0113e20:	68 00 10 90 00       	push   $0x901000
f0113e25:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113e28:	e8 63 2c 00 00       	call   f0116a90 <CCP>
f0113e2d:	83 c4 30             	add    $0x30,%esp
f0113e30:	83 f8 01             	cmp    $0x1,%eax
f0113e33:	74 28                	je     f0113e5d <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113e35:	83 ec 04             	sub    $0x4,%esp
f0113e38:	68 24 9b 12 f0       	push   $0xf0129b24
f0113e3d:	68 c9 03 00 00       	push   $0x3c9
f0113e42:	68 e2 91 12 f0       	push   $0xf01291e2
f0113e47:	e8 8a c6 fe ff       	call   f01004d6 <_warn>
f0113e4c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113e56:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113e5d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e61:	74 04                	je     f0113e67 <test_copy_paste_chunk+0x102b>
f0113e63:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113e67:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113e6e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113e72:	74 72                	je     f0113ee6 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113e74:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113e7b:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113e82:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113e89:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113e90:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e93:	8a 00                	mov    (%eax),%al
f0113e95:	3c 62                	cmp    $0x62,%al
f0113e97:	75 1b                	jne    f0113eb4 <test_copy_paste_chunk+0x1078>
f0113e99:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e9c:	8a 00                	mov    (%eax),%al
f0113e9e:	3c 62                	cmp    $0x62,%al
f0113ea0:	75 12                	jne    f0113eb4 <test_copy_paste_chunk+0x1078>
f0113ea2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ea5:	8a 00                	mov    (%eax),%al
f0113ea7:	3c 7a                	cmp    $0x7a,%al
f0113ea9:	75 09                	jne    f0113eb4 <test_copy_paste_chunk+0x1078>
f0113eab:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113eae:	8a 00                	mov    (%eax),%al
f0113eb0:	3c 7a                	cmp    $0x7a,%al
f0113eb2:	74 21                	je     f0113ed5 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113eb4:	83 ec 04             	sub    $0x4,%esp
f0113eb7:	68 d8 99 12 f0       	push   $0xf01299d8
f0113ebc:	68 d5 03 00 00       	push   $0x3d5
f0113ec1:	68 e2 91 12 f0       	push   $0xf01291e2
f0113ec6:	e8 0b c6 fe ff       	call   f01004d6 <_warn>
f0113ecb:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113ece:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113ed5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ed9:	74 04                	je     f0113edf <test_copy_paste_chunk+0x10a3>
f0113edb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113edf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113ee6:	83 ec 0c             	sub    $0xc,%esp
f0113ee9:	68 d2 9b 12 f0       	push   $0xf0129bd2
f0113eee:	e8 98 d0 fe ff       	call   f0100f8b <cprintf>
f0113ef3:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113ef6:	83 ec 08             	sub    $0x8,%esp
f0113ef9:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113efc:	68 e4 9b 12 f0       	push   $0xf0129be4
f0113f01:	e8 85 d0 fe ff       	call   f0100f8b <cprintf>
f0113f06:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113f09:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113f0d:	75 10                	jne    f0113f1f <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113f0f:	83 ec 0c             	sub    $0xc,%esp
f0113f12:	68 18 9c 12 f0       	push   $0xf0129c18
f0113f17:	e8 6f d0 fe ff       	call   f0100f8b <cprintf>
f0113f1c:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113f1f:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0113f24:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113f27:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f2a:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113f2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113f35:	5b                   	pop    %ebx
f0113f36:	5e                   	pop    %esi
f0113f37:	5f                   	pop    %edi
f0113f38:	5d                   	pop    %ebp
f0113f39:	c3                   	ret    

f0113f3a <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113f3a:	55                   	push   %ebp
f0113f3b:	89 e5                	mov    %esp,%ebp
f0113f3d:	57                   	push   %edi
f0113f3e:	56                   	push   %esi
f0113f3f:	53                   	push   %ebx
f0113f40:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113f46:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113f4c:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f0113f51:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113f56:	89 c7                	mov    %eax,%edi
f0113f58:	89 de                	mov    %ebx,%esi
f0113f5a:	89 d1                	mov    %edx,%ecx
f0113f5c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113f5e:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113f64:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113f69:	b0 00                	mov    $0x0,%al
f0113f6b:	89 d7                	mov    %edx,%edi
f0113f6d:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113f6f:	6a 00                	push   $0x0
f0113f71:	6a 0a                	push   $0xa
f0113f73:	6a 14                	push   $0x14
f0113f75:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113f7b:	50                   	push   %eax
f0113f7c:	e8 47 70 ff ff       	call   f010afc8 <env_create>
f0113f81:	83 c4 10             	add    $0x10,%esp
f0113f84:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113f87:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f8a:	8b 40 64             	mov    0x64(%eax),%eax
f0113f8d:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113f90:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f93:	8b 40 68             	mov    0x68(%eax),%eax
f0113f96:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113f99:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113f9c:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113f9f:	83 ec 0c             	sub    $0xc,%esp
f0113fa2:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fa5:	e8 b2 2a 00 00       	call   f0116a5c <ClearUserSpace>
f0113faa:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113fad:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113fb4:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113fbb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113fc2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113fc6:	83 ec 0c             	sub    $0xc,%esp
f0113fc9:	68 90 a4 12 f0       	push   $0xf012a490
f0113fce:	e8 b8 cf fe ff       	call   f0100f8b <cprintf>
f0113fd3:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113fd6:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113fdd:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113fe4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113fe7:	8a 00                	mov    (%eax),%al
f0113fe9:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113fef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113ff2:	8a 00                	mov    (%eax),%al
f0113ff4:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ffa:	e8 69 a9 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0113fff:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0114002:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114005:	89 d0                	mov    %edx,%eax
f0114007:	01 c0                	add    %eax,%eax
f0114009:	01 d0                	add    %edx,%eax
f011400b:	01 c0                	add    %eax,%eax
f011400d:	83 ec 0c             	sub    $0xc,%esp
f0114010:	6a 02                	push   $0x2
f0114012:	50                   	push   %eax
f0114013:	68 00 40 10 f0       	push   $0xf0104000
f0114018:	68 00 00 10 f0       	push   $0xf0100000
f011401d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114020:	e8 16 6b ff ff       	call   f010ab3b <share_chunk>
f0114025:	83 c4 20             	add    $0x20,%esp
f0114028:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011402b:	e8 38 a9 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114030:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114033:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114037:	75 08                	jne    f0114041 <test_share_chunk+0x107>
f0114039:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011403c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011403f:	74 28                	je     f0114069 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114041:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114044:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114047:	83 ec 0c             	sub    $0xc,%esp
f011404a:	50                   	push   %eax
f011404b:	ff 75 b0             	pushl  -0x50(%ebp)
f011404e:	68 bc a4 12 f0       	push   $0xf012a4bc
f0114053:	68 11 04 00 00       	push   $0x411
f0114058:	68 e2 91 12 f0       	push   $0xf01291e2
f011405d:	e8 74 c4 fe ff       	call   f01004d6 <_warn>
f0114062:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114065:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114069:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011406d:	74 04                	je     f0114073 <test_share_chunk+0x139>
f011406f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114073:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114077:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011407a:	c1 e0 03             	shl    $0x3,%eax
f011407d:	83 ec 08             	sub    $0x8,%esp
f0114080:	68 fd 00 00 00       	push   $0xfd
f0114085:	6a 07                	push   $0x7
f0114087:	6a 03                	push   $0x3
f0114089:	6a 07                	push   $0x7
f011408b:	6a 03                	push   $0x3
f011408d:	6a 01                	push   $0x1
f011408f:	50                   	push   %eax
f0114090:	68 00 40 10 f0       	push   $0xf0104000
f0114095:	68 00 00 10 f0       	push   $0xf0100000
f011409a:	ff 75 cc             	pushl  -0x34(%ebp)
f011409d:	e8 ee 29 00 00       	call   f0116a90 <CCP>
f01140a2:	83 c4 30             	add    $0x30,%esp
f01140a5:	85 c0                	test   %eax,%eax
f01140a7:	75 1e                	jne    f01140c7 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01140a9:	83 ec 04             	sub    $0x4,%esp
f01140ac:	68 18 a5 12 f0       	push   $0xf012a518
f01140b1:	68 19 04 00 00       	push   $0x419
f01140b6:	68 e2 91 12 f0       	push   $0xf01291e2
f01140bb:	e8 16 c4 fe ff       	call   f01004d6 <_warn>
f01140c0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01140c7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140cb:	74 04                	je     f01140d1 <test_share_chunk+0x197>
f01140cd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01140d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140d4:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f01140d7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140da:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f01140dd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140e0:	8a 00                	mov    (%eax),%al
f01140e2:	3c 41                	cmp    $0x41,%al
f01140e4:	75 09                	jne    f01140ef <test_share_chunk+0x1b5>
f01140e6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140e9:	8a 00                	mov    (%eax),%al
f01140eb:	3c 42                	cmp    $0x42,%al
f01140ed:	74 1e                	je     f011410d <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01140ef:	83 ec 04             	sub    $0x4,%esp
f01140f2:	68 60 a5 12 f0       	push   $0xf012a560
f01140f7:	68 23 04 00 00       	push   $0x423
f01140fc:	68 e2 91 12 f0       	push   $0xf01291e2
f0114101:	e8 d0 c3 fe ff       	call   f01004d6 <_warn>
f0114106:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114109:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011410d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114111:	74 04                	je     f0114117 <test_share_chunk+0x1dd>
f0114113:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114117:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f011411b:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114121:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114124:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114126:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f011412c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011412f:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114131:	83 ec 0c             	sub    $0xc,%esp
f0114134:	68 95 a5 12 f0       	push   $0xf012a595
f0114139:	e8 4d ce fe ff       	call   f0100f8b <cprintf>
f011413e:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114141:	83 ec 0c             	sub    $0xc,%esp
f0114144:	68 a4 a5 12 f0       	push   $0xf012a5a4
f0114149:	e8 3d ce fe ff       	call   f0100f8b <cprintf>
f011414e:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114151:	e8 12 a8 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114156:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114159:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011415c:	c1 e0 05             	shl    $0x5,%eax
f011415f:	83 ec 0c             	sub    $0xc,%esp
f0114162:	68 02 0e 00 00       	push   $0xe02
f0114167:	50                   	push   %eax
f0114168:	68 00 00 00 40       	push   $0x40000000
f011416d:	68 00 00 00 f0       	push   $0xf0000000
f0114172:	ff 75 cc             	pushl  -0x34(%ebp)
f0114175:	e8 c1 69 ff ff       	call   f010ab3b <share_chunk>
f011417a:	83 c4 20             	add    $0x20,%esp
f011417d:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114180:	e8 e3 a7 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114185:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0114188:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011418c:	75 1f                	jne    f01141ad <test_share_chunk+0x273>
f011418e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114191:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114194:	89 c1                	mov    %eax,%ecx
f0114196:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114199:	c1 e0 05             	shl    $0x5,%eax
f011419c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011419f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01141a6:	99                   	cltd   
f01141a7:	f7 fb                	idiv   %ebx
f01141a9:	39 c1                	cmp    %eax,%ecx
f01141ab:	74 28                	je     f01141d5 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01141ad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141b0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01141b3:	83 ec 0c             	sub    $0xc,%esp
f01141b6:	50                   	push   %eax
f01141b7:	ff 75 a8             	pushl  -0x58(%ebp)
f01141ba:	68 e0 a5 12 f0       	push   $0xf012a5e0
f01141bf:	68 3b 04 00 00       	push   $0x43b
f01141c4:	68 e2 91 12 f0       	push   $0xf01291e2
f01141c9:	e8 08 c3 fe ff       	call   f01004d6 <_warn>
f01141ce:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01141d1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01141d5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141d9:	74 04                	je     f01141df <test_share_chunk+0x2a5>
f01141db:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01141df:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01141e3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01141ea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01141ed:	c1 e0 05             	shl    $0x5,%eax
f01141f0:	83 ec 08             	sub    $0x8,%esp
f01141f3:	6a 02                	push   $0x2
f01141f5:	6a 07                	push   $0x7
f01141f7:	6a 03                	push   $0x3
f01141f9:	68 07 0e 00 00       	push   $0xe07
f01141fe:	68 03 0e 00 00       	push   $0xe03
f0114203:	6a ff                	push   $0xffffffff
f0114205:	50                   	push   %eax
f0114206:	68 00 00 00 40       	push   $0x40000000
f011420b:	68 00 00 00 f0       	push   $0xf0000000
f0114210:	ff 75 cc             	pushl  -0x34(%ebp)
f0114213:	e8 78 28 00 00       	call   f0116a90 <CCP>
f0114218:	83 c4 30             	add    $0x30,%esp
f011421b:	85 c0                	test   %eax,%eax
f011421d:	75 25                	jne    f0114244 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011421f:	83 ec 04             	sub    $0x4,%esp
f0114222:	68 18 a5 12 f0       	push   $0xf012a518
f0114227:	68 44 04 00 00       	push   $0x444
f011422c:	68 e2 91 12 f0       	push   $0xf01291e2
f0114231:	e8 a0 c2 fe ff       	call   f01004d6 <_warn>
f0114236:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114239:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011423d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114244:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114247:	89 d0                	mov    %edx,%eax
f0114249:	01 c0                	add    %eax,%eax
f011424b:	01 d0                	add    %edx,%eax
f011424d:	c1 e0 02             	shl    $0x2,%eax
f0114250:	83 ec 08             	sub    $0x8,%esp
f0114253:	6a 02                	push   $0x2
f0114255:	6a 07                	push   $0x7
f0114257:	6a 03                	push   $0x3
f0114259:	68 07 0e 00 00       	push   $0xe07
f011425e:	68 03 0e 00 00       	push   $0xe03
f0114263:	6a 02                	push   $0x2
f0114265:	50                   	push   %eax
f0114266:	68 00 00 00 40       	push   $0x40000000
f011426b:	68 00 00 00 f0       	push   $0xf0000000
f0114270:	ff 75 cc             	pushl  -0x34(%ebp)
f0114273:	e8 18 28 00 00       	call   f0116a90 <CCP>
f0114278:	83 c4 30             	add    $0x30,%esp
f011427b:	85 c0                	test   %eax,%eax
f011427d:	75 1e                	jne    f011429d <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011427f:	83 ec 04             	sub    $0x4,%esp
f0114282:	68 18 a5 12 f0       	push   $0xf012a518
f0114287:	68 4b 04 00 00       	push   $0x44b
f011428c:	68 e2 91 12 f0       	push   $0xf01291e2
f0114291:	e8 40 c2 fe ff       	call   f01004d6 <_warn>
f0114296:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114299:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011429d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142a1:	74 04                	je     f01142a7 <test_share_chunk+0x36d>
f01142a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f01142ab:	b8 d0 d7 b0 f0       	mov    $0xf0b0d7d0,%eax
f01142b0:	05 00 00 00 10       	add    $0x10000000,%eax
f01142b5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01142b8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01142bb:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01142c0:	83 ec 08             	sub    $0x8,%esp
f01142c3:	6a 02                	push   $0x2
f01142c5:	6a 07                	push   $0x7
f01142c7:	6a 03                	push   $0x3
f01142c9:	68 07 0e 00 00       	push   $0xe07
f01142ce:	68 03 0e 00 00       	push   $0xe03
f01142d3:	6a 02                	push   $0x2
f01142d5:	50                   	push   %eax
f01142d6:	68 00 00 0a 40       	push   $0x400a0000
f01142db:	68 00 00 0a f0       	push   $0xf00a0000
f01142e0:	ff 75 cc             	pushl  -0x34(%ebp)
f01142e3:	e8 a8 27 00 00       	call   f0116a90 <CCP>
f01142e8:	83 c4 30             	add    $0x30,%esp
f01142eb:	85 c0                	test   %eax,%eax
f01142ed:	75 1e                	jne    f011430d <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01142ef:	83 ec 04             	sub    $0x4,%esp
f01142f2:	68 18 a5 12 f0       	push   $0xf012a518
f01142f7:	68 55 04 00 00       	push   $0x455
f01142fc:	68 e2 91 12 f0       	push   $0xf01291e2
f0114301:	e8 d0 c1 fe ff       	call   f01004d6 <_warn>
f0114306:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114309:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011430d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114311:	74 04                	je     f0114317 <test_share_chunk+0x3dd>
f0114313:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114317:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011431b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011431f:	0f 84 a4 00 00 00    	je     f01143c9 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114325:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011432c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011432f:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114332:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0114339:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011433c:	8a 00                	mov    (%eax),%al
f011433e:	3c 41                	cmp    $0x41,%al
f0114340:	75 09                	jne    f011434b <test_share_chunk+0x411>
f0114342:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114345:	8a 00                	mov    (%eax),%al
f0114347:	3c 41                	cmp    $0x41,%al
f0114349:	74 1e                	je     f0114369 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011434b:	83 ec 04             	sub    $0x4,%esp
f011434e:	68 60 a5 12 f0       	push   $0xf012a560
f0114353:	68 62 04 00 00       	push   $0x462
f0114358:	68 e2 91 12 f0       	push   $0xf01291e2
f011435d:	e8 74 c1 fe ff       	call   f01004d6 <_warn>
f0114362:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114365:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114369:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011436d:	74 04                	je     f0114373 <test_share_chunk+0x439>
f011436f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114373:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114377:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f011437e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114381:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114384:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f011438b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011438e:	8a 00                	mov    (%eax),%al
f0114390:	3c 43                	cmp    $0x43,%al
f0114392:	75 09                	jne    f011439d <test_share_chunk+0x463>
f0114394:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114397:	8a 00                	mov    (%eax),%al
f0114399:	3c 43                	cmp    $0x43,%al
f011439b:	74 1e                	je     f01143bb <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011439d:	83 ec 04             	sub    $0x4,%esp
f01143a0:	68 60 a5 12 f0       	push   $0xf012a560
f01143a5:	68 6d 04 00 00       	push   $0x46d
f01143aa:	68 e2 91 12 f0       	push   $0xf01291e2
f01143af:	e8 22 c1 fe ff       	call   f01004d6 <_warn>
f01143b4:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143b7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01143bb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143bf:	74 04                	je     f01143c5 <test_share_chunk+0x48b>
f01143c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143c5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01143c9:	83 ec 0c             	sub    $0xc,%esp
f01143cc:	68 6f 9b 12 f0       	push   $0xf0129b6f
f01143d1:	e8 b5 cb fe ff       	call   f0100f8b <cprintf>
f01143d6:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01143d9:	83 ec 0c             	sub    $0xc,%esp
f01143dc:	68 30 a6 12 f0       	push   $0xf012a630
f01143e1:	e8 a5 cb fe ff       	call   f0100f8b <cprintf>
f01143e6:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01143e9:	e8 7a a5 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01143ee:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01143f1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01143f4:	89 d0                	mov    %edx,%eax
f01143f6:	c1 e0 03             	shl    $0x3,%eax
f01143f9:	01 d0                	add    %edx,%eax
f01143fb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114402:	01 d0                	add    %edx,%eax
f0114404:	c1 e0 03             	shl    $0x3,%eax
f0114407:	83 ec 0c             	sub    $0xc,%esp
f011440a:	6a 06                	push   $0x6
f011440c:	50                   	push   %eax
f011440d:	6a 00                	push   $0x0
f011440f:	68 00 00 00 40       	push   $0x40000000
f0114414:	ff 75 cc             	pushl  -0x34(%ebp)
f0114417:	e8 1f 67 ff ff       	call   f010ab3b <share_chunk>
f011441c:	83 c4 20             	add    $0x20,%esp
f011441f:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114422:	e8 41 a5 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114427:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011442a:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f011442e:	75 0b                	jne    f011443b <test_share_chunk+0x501>
f0114430:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114433:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114436:	83 f8 01             	cmp    $0x1,%eax
f0114439:	74 28                	je     f0114463 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011443b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011443e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114441:	83 ec 0c             	sub    $0xc,%esp
f0114444:	50                   	push   %eax
f0114445:	ff 75 a0             	pushl  -0x60(%ebp)
f0114448:	68 e0 a5 12 f0       	push   $0xf012a5e0
f011444d:	68 83 04 00 00       	push   $0x483
f0114452:	68 e2 91 12 f0       	push   $0xf01291e2
f0114457:	e8 7a c0 fe ff       	call   f01004d6 <_warn>
f011445c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011445f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114463:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114467:	74 04                	je     f011446d <test_share_chunk+0x533>
f0114469:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011446d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114471:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114478:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011447b:	05 00 80 02 00       	add    $0x28000,%eax
f0114480:	c1 e0 02             	shl    $0x2,%eax
f0114483:	83 ec 08             	sub    $0x8,%esp
f0114486:	6a 02                	push   $0x2
f0114488:	6a 07                	push   $0x7
f011448a:	6a 03                	push   $0x3
f011448c:	6a 07                	push   $0x7
f011448e:	6a 07                	push   $0x7
f0114490:	6a ff                	push   $0xffffffff
f0114492:	50                   	push   %eax
f0114493:	6a 00                	push   $0x0
f0114495:	68 00 00 00 40       	push   $0x40000000
f011449a:	ff 75 cc             	pushl  -0x34(%ebp)
f011449d:	e8 ee 25 00 00       	call   f0116a90 <CCP>
f01144a2:	83 c4 30             	add    $0x30,%esp
f01144a5:	85 c0                	test   %eax,%eax
f01144a7:	75 25                	jne    f01144ce <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144a9:	83 ec 04             	sub    $0x4,%esp
f01144ac:	68 18 a5 12 f0       	push   $0xf012a518
f01144b1:	68 8c 04 00 00       	push   $0x48c
f01144b6:	68 e2 91 12 f0       	push   $0xf01291e2
f01144bb:	e8 16 c0 fe ff       	call   f01004d6 <_warn>
f01144c0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01144c7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01144ce:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144d1:	89 d0                	mov    %edx,%eax
f01144d3:	01 c0                	add    %eax,%eax
f01144d5:	01 d0                	add    %edx,%eax
f01144d7:	c1 e0 02             	shl    $0x2,%eax
f01144da:	83 ec 08             	sub    $0x8,%esp
f01144dd:	6a 02                	push   $0x2
f01144df:	6a 07                	push   $0x7
f01144e1:	6a 03                	push   $0x3
f01144e3:	6a 07                	push   $0x7
f01144e5:	6a 07                	push   $0x7
f01144e7:	6a 03                	push   $0x3
f01144e9:	50                   	push   %eax
f01144ea:	6a 00                	push   $0x0
f01144ec:	68 00 00 00 40       	push   $0x40000000
f01144f1:	ff 75 cc             	pushl  -0x34(%ebp)
f01144f4:	e8 97 25 00 00       	call   f0116a90 <CCP>
f01144f9:	83 c4 30             	add    $0x30,%esp
f01144fc:	85 c0                	test   %eax,%eax
f01144fe:	75 1e                	jne    f011451e <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114500:	83 ec 04             	sub    $0x4,%esp
f0114503:	68 18 a5 12 f0       	push   $0xf012a518
f0114508:	68 93 04 00 00       	push   $0x493
f011450d:	68 e2 91 12 f0       	push   $0xf01291e2
f0114512:	e8 bf bf fe ff       	call   f01004d6 <_warn>
f0114517:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011451a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011451e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114522:	74 04                	je     f0114528 <test_share_chunk+0x5ee>
f0114524:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114528:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011452c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011452f:	89 d0                	mov    %edx,%eax
f0114531:	01 c0                	add    %eax,%eax
f0114533:	01 d0                	add    %edx,%eax
f0114535:	c1 e0 02             	shl    $0x2,%eax
f0114538:	f7 d8                	neg    %eax
f011453a:	05 00 00 0a 00       	add    $0xa0000,%eax
f011453f:	83 ec 08             	sub    $0x8,%esp
f0114542:	6a 02                	push   $0x2
f0114544:	6a 07                	push   $0x7
f0114546:	6a 03                	push   $0x3
f0114548:	6a 07                	push   $0x7
f011454a:	6a 07                	push   $0x7
f011454c:	6a 02                	push   $0x2
f011454e:	50                   	push   %eax
f011454f:	68 00 30 00 00       	push   $0x3000
f0114554:	68 00 30 00 40       	push   $0x40003000
f0114559:	ff 75 cc             	pushl  -0x34(%ebp)
f011455c:	e8 2f 25 00 00       	call   f0116a90 <CCP>
f0114561:	83 c4 30             	add    $0x30,%esp
f0114564:	85 c0                	test   %eax,%eax
f0114566:	75 1e                	jne    f0114586 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114568:	83 ec 04             	sub    $0x4,%esp
f011456b:	68 18 a5 12 f0       	push   $0xf012a518
f0114570:	68 9b 04 00 00       	push   $0x49b
f0114575:	68 e2 91 12 f0       	push   $0xf01291e2
f011457a:	e8 57 bf fe ff       	call   f01004d6 <_warn>
f011457f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114582:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114586:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011458a:	74 04                	je     f0114590 <test_share_chunk+0x656>
f011458c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114590:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114594:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114597:	c1 e0 02             	shl    $0x2,%eax
f011459a:	83 ec 08             	sub    $0x8,%esp
f011459d:	6a 02                	push   $0x2
f011459f:	6a 07                	push   $0x7
f01145a1:	6a 03                	push   $0x3
f01145a3:	6a 07                	push   $0x7
f01145a5:	6a 07                	push   $0x7
f01145a7:	6a 03                	push   $0x3
f01145a9:	50                   	push   %eax
f01145aa:	68 00 00 0a 00       	push   $0xa0000
f01145af:	68 00 00 0a 40       	push   $0x400a0000
f01145b4:	ff 75 cc             	pushl  -0x34(%ebp)
f01145b7:	e8 d4 24 00 00       	call   f0116a90 <CCP>
f01145bc:	83 c4 30             	add    $0x30,%esp
f01145bf:	85 c0                	test   %eax,%eax
f01145c1:	75 1e                	jne    f01145e1 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01145c3:	83 ec 04             	sub    $0x4,%esp
f01145c6:	68 18 a5 12 f0       	push   $0xf012a518
f01145cb:	68 a3 04 00 00       	push   $0x4a3
f01145d0:	68 e2 91 12 f0       	push   $0xf01291e2
f01145d5:	e8 fc be fe ff       	call   f01004d6 <_warn>
f01145da:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145dd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145e1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145e5:	74 04                	je     f01145eb <test_share_chunk+0x6b1>
f01145e7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145eb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01145ef:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01145f3:	0f 84 92 00 00 00    	je     f011468b <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01145f9:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114600:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114607:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f011460e:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114615:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114618:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f011461b:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114622:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114629:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011462c:	8a 00                	mov    (%eax),%al
f011462e:	3c 41                	cmp    $0x41,%al
f0114630:	75 2d                	jne    f011465f <test_share_chunk+0x725>
f0114632:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114635:	8a 00                	mov    (%eax),%al
f0114637:	3c 41                	cmp    $0x41,%al
f0114639:	75 24                	jne    f011465f <test_share_chunk+0x725>
f011463b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011463e:	8a 00                	mov    (%eax),%al
f0114640:	3c 41                	cmp    $0x41,%al
f0114642:	75 1b                	jne    f011465f <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114644:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114647:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114649:	3c 44                	cmp    $0x44,%al
f011464b:	75 12                	jne    f011465f <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011464d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114650:	8a 00                	mov    (%eax),%al
f0114652:	3c 44                	cmp    $0x44,%al
f0114654:	75 09                	jne    f011465f <test_share_chunk+0x725>
f0114656:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114659:	8a 00                	mov    (%eax),%al
f011465b:	3c 44                	cmp    $0x44,%al
f011465d:	74 1e                	je     f011467d <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011465f:	83 ec 04             	sub    $0x4,%esp
f0114662:	68 60 a5 12 f0       	push   $0xf012a560
f0114667:	68 b5 04 00 00       	push   $0x4b5
f011466c:	68 e2 91 12 f0       	push   $0xf01291e2
f0114671:	e8 60 be fe ff       	call   f01004d6 <_warn>
f0114676:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114679:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011467d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114681:	74 04                	je     f0114687 <test_share_chunk+0x74d>
f0114683:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114687:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f011468b:	83 ec 0c             	sub    $0xc,%esp
f011468e:	68 d2 9b 12 f0       	push   $0xf0129bd2
f0114693:	e8 f3 c8 fe ff       	call   f0100f8b <cprintf>
f0114698:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f011469b:	83 ec 0c             	sub    $0xc,%esp
f011469e:	68 6c a6 12 f0       	push   $0xf012a66c
f01146a3:	e8 e3 c8 fe ff       	call   f0100f8b <cprintf>
f01146a8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01146ab:	e8 b8 a2 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01146b0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f01146b3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146b6:	89 d0                	mov    %edx,%eax
f01146b8:	01 c0                	add    %eax,%eax
f01146ba:	01 d0                	add    %edx,%eax
f01146bc:	01 c0                	add    %eax,%eax
f01146be:	01 d0                	add    %edx,%eax
f01146c0:	83 ec 0c             	sub    $0xc,%esp
f01146c3:	6a 04                	push   $0x4
f01146c5:	50                   	push   %eax
f01146c6:	68 00 fc 3f 00       	push   $0x3ffc00
f01146cb:	68 00 fc 09 00       	push   $0x9fc00
f01146d0:	ff 75 cc             	pushl  -0x34(%ebp)
f01146d3:	e8 63 64 ff ff       	call   f010ab3b <share_chunk>
f01146d8:	83 c4 20             	add    $0x20,%esp
f01146db:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01146de:	e8 85 a2 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01146e3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01146e6:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f01146ea:	75 0b                	jne    f01146f7 <test_share_chunk+0x7bd>
f01146ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01146ef:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01146f2:	83 f8 01             	cmp    $0x1,%eax
f01146f5:	74 28                	je     f011471f <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01146f7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01146fa:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01146fd:	83 ec 0c             	sub    $0xc,%esp
f0114700:	50                   	push   %eax
f0114701:	ff 75 8c             	pushl  -0x74(%ebp)
f0114704:	68 e0 a5 12 f0       	push   $0xf012a5e0
f0114709:	68 cb 04 00 00       	push   $0x4cb
f011470e:	68 e2 91 12 f0       	push   $0xf01291e2
f0114713:	e8 be bd fe ff       	call   f01004d6 <_warn>
f0114718:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011471b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011471f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114723:	74 04                	je     f0114729 <test_share_chunk+0x7ef>
f0114725:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114729:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011472d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114734:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114737:	89 d0                	mov    %edx,%eax
f0114739:	01 c0                	add    %eax,%eax
f011473b:	01 d0                	add    %edx,%eax
f011473d:	c1 e0 02             	shl    $0x2,%eax
f0114740:	83 ec 08             	sub    $0x8,%esp
f0114743:	6a 02                	push   $0x2
f0114745:	6a 07                	push   $0x7
f0114747:	6a 07                	push   $0x7
f0114749:	6a 07                	push   $0x7
f011474b:	6a 05                	push   $0x5
f011474d:	6a ff                	push   $0xffffffff
f011474f:	50                   	push   %eax
f0114750:	68 00 f0 3f 00       	push   $0x3ff000
f0114755:	68 00 f0 09 00       	push   $0x9f000
f011475a:	ff 75 cc             	pushl  -0x34(%ebp)
f011475d:	e8 2e 23 00 00       	call   f0116a90 <CCP>
f0114762:	83 c4 30             	add    $0x30,%esp
f0114765:	85 c0                	test   %eax,%eax
f0114767:	75 25                	jne    f011478e <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114769:	83 ec 04             	sub    $0x4,%esp
f011476c:	68 18 a5 12 f0       	push   $0xf012a518
f0114771:	68 d4 04 00 00       	push   $0x4d4
f0114776:	68 e2 91 12 f0       	push   $0xf01291e2
f011477b:	e8 56 bd fe ff       	call   f01004d6 <_warn>
f0114780:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114783:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114787:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f011478e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114792:	74 04                	je     f0114798 <test_share_chunk+0x85e>
f0114794:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114798:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011479c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011479f:	c1 e0 02             	shl    $0x2,%eax
f01147a2:	83 ec 08             	sub    $0x8,%esp
f01147a5:	6a 02                	push   $0x2
f01147a7:	6a 07                	push   $0x7
f01147a9:	6a 07                	push   $0x7
f01147ab:	6a 07                	push   $0x7
f01147ad:	6a 05                	push   $0x5
f01147af:	6a 03                	push   $0x3
f01147b1:	50                   	push   %eax
f01147b2:	68 00 f0 3f 00       	push   $0x3ff000
f01147b7:	68 00 f0 09 00       	push   $0x9f000
f01147bc:	ff 75 cc             	pushl  -0x34(%ebp)
f01147bf:	e8 cc 22 00 00       	call   f0116a90 <CCP>
f01147c4:	83 c4 30             	add    $0x30,%esp
f01147c7:	85 c0                	test   %eax,%eax
f01147c9:	75 1e                	jne    f01147e9 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147cb:	83 ec 04             	sub    $0x4,%esp
f01147ce:	68 18 a5 12 f0       	push   $0xf012a518
f01147d3:	68 dd 04 00 00       	push   $0x4dd
f01147d8:	68 e2 91 12 f0       	push   $0xf01291e2
f01147dd:	e8 f4 bc fe ff       	call   f01004d6 <_warn>
f01147e2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147e5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147e9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147ed:	74 04                	je     f01147f3 <test_share_chunk+0x8b9>
f01147ef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147f3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01147f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01147fa:	c1 e0 03             	shl    $0x3,%eax
f01147fd:	83 ec 08             	sub    $0x8,%esp
f0114800:	6a 02                	push   $0x2
f0114802:	6a 07                	push   $0x7
f0114804:	6a 07                	push   $0x7
f0114806:	6a 07                	push   $0x7
f0114808:	6a 05                	push   $0x5
f011480a:	6a 04                	push   $0x4
f011480c:	50                   	push   %eax
f011480d:	68 00 00 40 00       	push   $0x400000
f0114812:	68 00 00 0a 00       	push   $0xa0000
f0114817:	ff 75 cc             	pushl  -0x34(%ebp)
f011481a:	e8 71 22 00 00       	call   f0116a90 <CCP>
f011481f:	83 c4 30             	add    $0x30,%esp
f0114822:	85 c0                	test   %eax,%eax
f0114824:	75 1e                	jne    f0114844 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114826:	83 ec 04             	sub    $0x4,%esp
f0114829:	68 18 a5 12 f0       	push   $0xf012a518
f011482e:	68 e5 04 00 00       	push   $0x4e5
f0114833:	68 e2 91 12 f0       	push   $0xf01291e2
f0114838:	e8 99 bc fe ff       	call   f01004d6 <_warn>
f011483d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114840:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114844:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114848:	74 04                	je     f011484e <test_share_chunk+0x914>
f011484a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011484e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114852:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114856:	0f 84 b2 00 00 00    	je     f011490e <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f011485c:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114863:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f011486a:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114871:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114878:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f011487f:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114886:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f011488d:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114894:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114897:	8a 00                	mov    (%eax),%al
f0114899:	3c 44                	cmp    $0x44,%al
f011489b:	75 45                	jne    f01148e2 <test_share_chunk+0x9a8>
f011489d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01148a0:	8a 00                	mov    (%eax),%al
f01148a2:	3c 44                	cmp    $0x44,%al
f01148a4:	75 3c                	jne    f01148e2 <test_share_chunk+0x9a8>
f01148a6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01148a9:	8a 00                	mov    (%eax),%al
f01148ab:	3c 44                	cmp    $0x44,%al
f01148ad:	75 33                	jne    f01148e2 <test_share_chunk+0x9a8>
f01148af:	8b 45 98             	mov    -0x68(%ebp),%eax
f01148b2:	8a 00                	mov    (%eax),%al
f01148b4:	3c 44                	cmp    $0x44,%al
f01148b6:	75 2a                	jne    f01148e2 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01148b8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01148bb:	8a 10                	mov    (%eax),%dl
f01148bd:	8b 45 90             	mov    -0x70(%ebp),%eax
f01148c0:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01148c2:	38 c2                	cmp    %al,%dl
f01148c4:	75 1c                	jne    f01148e2 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01148c6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01148c9:	8a 10                	mov    (%eax),%dl
f01148cb:	8b 45 88             	mov    -0x78(%ebp),%eax
f01148ce:	8a 00                	mov    (%eax),%al
f01148d0:	38 c2                	cmp    %al,%dl
f01148d2:	75 0e                	jne    f01148e2 <test_share_chunk+0x9a8>
f01148d4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01148d7:	8a 10                	mov    (%eax),%dl
f01148d9:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01148dc:	8a 00                	mov    (%eax),%al
f01148de:	38 c2                	cmp    %al,%dl
f01148e0:	74 1e                	je     f0114900 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01148e2:	83 ec 04             	sub    $0x4,%esp
f01148e5:	68 60 a5 12 f0       	push   $0xf012a560
f01148ea:	68 fa 04 00 00       	push   $0x4fa
f01148ef:	68 e2 91 12 f0       	push   $0xf01291e2
f01148f4:	e8 dd bb fe ff       	call   f01004d6 <_warn>
f01148f9:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01148fc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114900:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114904:	74 04                	je     f011490a <test_share_chunk+0x9d0>
f0114906:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011490a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f011490e:	83 ec 0c             	sub    $0xc,%esp
f0114911:	68 a4 a6 12 f0       	push   $0xf012a6a4
f0114916:	e8 70 c6 fe ff       	call   f0100f8b <cprintf>
f011491b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f011491e:	83 ec 08             	sub    $0x8,%esp
f0114921:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114924:	68 b4 a6 12 f0       	push   $0xf012a6b4
f0114929:	e8 5d c6 fe ff       	call   f0100f8b <cprintf>
f011492e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114931:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114935:	75 10                	jne    f0114947 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114937:	83 ec 0c             	sub    $0xc,%esp
f011493a:	68 e4 a6 12 f0       	push   $0xf012a6e4
f011493f:	e8 47 c6 fe ff       	call   f0100f8b <cprintf>
f0114944:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114947:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f011494c:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011494f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114952:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114955:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011495a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011495d:	5b                   	pop    %ebx
f011495e:	5e                   	pop    %esi
f011495f:	5f                   	pop    %edi
f0114960:	5d                   	pop    %ebp
f0114961:	c3                   	ret    

f0114962 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114962:	55                   	push   %ebp
f0114963:	89 e5                	mov    %esp,%ebp
f0114965:	57                   	push   %edi
f0114966:	56                   	push   %esi
f0114967:	53                   	push   %ebx
f0114968:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011496e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114974:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f0114979:	ba 0f 00 00 00       	mov    $0xf,%edx
f011497e:	89 c7                	mov    %eax,%edi
f0114980:	89 de                	mov    %ebx,%esi
f0114982:	89 d1                	mov    %edx,%ecx
f0114984:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114986:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011498c:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114991:	b0 00                	mov    $0x0,%al
f0114993:	89 d7                	mov    %edx,%edi
f0114995:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114997:	6a 00                	push   $0x0
f0114999:	6a 0a                	push   $0xa
f011499b:	6a 14                	push   $0x14
f011499d:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01149a3:	50                   	push   %eax
f01149a4:	e8 1f 66 ff ff       	call   f010afc8 <env_create>
f01149a9:	83 c4 10             	add    $0x10,%esp
f01149ac:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01149af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01149b2:	8b 40 64             	mov    0x64(%eax),%eax
f01149b5:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01149b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01149bb:	8b 40 68             	mov    0x68(%eax),%eax
f01149be:	89 45 90             	mov    %eax,-0x70(%ebp)
f01149c1:	8b 45 90             	mov    -0x70(%ebp),%eax
f01149c4:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01149c7:	83 ec 0c             	sub    $0xc,%esp
f01149ca:	ff 75 cc             	pushl  -0x34(%ebp)
f01149cd:	e8 8a 20 00 00       	call   f0116a5c <ClearUserSpace>
f01149d2:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01149d5:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01149dc:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01149e3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f01149ea:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f01149ee:	83 ec 0c             	sub    $0xc,%esp
f01149f1:	68 20 a7 12 f0       	push   $0xf012a720
f01149f6:	e8 90 c5 fe ff       	call   f0100f8b <cprintf>
f01149fb:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01149fe:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114a05:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114a0c:	eb 03                	jmp    f0114a11 <test_allocate_chunk+0xaf>
f0114a0e:	ff 4d e4             	decl   -0x1c(%ebp)
f0114a11:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114a18:	76 09                	jbe    f0114a23 <test_allocate_chunk+0xc1>
f0114a1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a1d:	8a 00                	mov    (%eax),%al
f0114a1f:	84 c0                	test   %al,%al
f0114a21:	74 eb                	je     f0114a0e <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114a23:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114a2a:	75 06                	jne    f0114a32 <test_allocate_chunk+0xd0>
f0114a2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a2f:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114a32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a35:	8a 00                	mov    (%eax),%al
f0114a37:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114a3d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a40:	8a 00                	mov    (%eax),%al
f0114a42:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114a48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a4b:	8a 00                	mov    (%eax),%al
f0114a4d:	0f be c0             	movsbl %al,%eax
f0114a50:	83 ec 08             	sub    $0x8,%esp
f0114a53:	50                   	push   %eax
f0114a54:	68 4a a7 12 f0       	push   $0xf012a74a
f0114a59:	e8 2d c5 fe ff       	call   f0100f8b <cprintf>
f0114a5e:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114a61:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a64:	8a 00                	mov    (%eax),%al
f0114a66:	0f be c0             	movsbl %al,%eax
f0114a69:	83 ec 08             	sub    $0x8,%esp
f0114a6c:	50                   	push   %eax
f0114a6d:	68 56 a7 12 f0       	push   $0xf012a756
f0114a72:	e8 14 c5 fe ff       	call   f0100f8b <cprintf>
f0114a77:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114a7a:	83 ec 08             	sub    $0x8,%esp
f0114a7d:	68 00 f0 bf ef       	push   $0xefbff000
f0114a82:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a85:	e8 b3 1f 00 00       	call   f0116a3d <GP>
f0114a8a:	83 c4 10             	add    $0x10,%esp
f0114a8d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a90:	e8 d3 9e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114a95:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114a98:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a9b:	c1 e0 02             	shl    $0x2,%eax
f0114a9e:	6a 02                	push   $0x2
f0114aa0:	50                   	push   %eax
f0114aa1:	68 00 f0 bf ef       	push   $0xefbff000
f0114aa6:	ff 75 cc             	pushl  -0x34(%ebp)
f0114aa9:	e8 a7 60 ff ff       	call   f010ab55 <allocate_chunk>
f0114aae:	83 c4 10             	add    $0x10,%esp
f0114ab1:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ab4:	e8 af 9e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114ab9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114abc:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114ac0:	75 08                	jne    f0114aca <test_allocate_chunk+0x168>
f0114ac2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ac5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114ac8:	74 2a                	je     f0114af4 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114aca:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114acd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ad0:	83 ec 08             	sub    $0x8,%esp
f0114ad3:	6a 00                	push   $0x0
f0114ad5:	50                   	push   %eax
f0114ad6:	ff 75 b0             	pushl  -0x50(%ebp)
f0114ad9:	68 64 a7 12 f0       	push   $0xf012a764
f0114ade:	68 3a 05 00 00       	push   $0x53a
f0114ae3:	68 e2 91 12 f0       	push   $0xf01291e2
f0114ae8:	e8 e9 b9 fe ff       	call   f01004d6 <_warn>
f0114aed:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114af0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114af4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114af8:	74 04                	je     f0114afe <test_allocate_chunk+0x19c>
f0114afa:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114afe:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b02:	e8 61 9e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114b07:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114b0a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b0d:	01 c0                	add    %eax,%eax
f0114b0f:	89 c1                	mov    %eax,%ecx
f0114b11:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b14:	89 d0                	mov    %edx,%eax
f0114b16:	c1 e0 02             	shl    $0x2,%eax
f0114b19:	01 d0                	add    %edx,%eax
f0114b1b:	f7 d8                	neg    %eax
f0114b1d:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114b22:	6a 02                	push   $0x2
f0114b24:	51                   	push   %ecx
f0114b25:	50                   	push   %eax
f0114b26:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b29:	e8 27 60 ff ff       	call   f010ab55 <allocate_chunk>
f0114b2e:	83 c4 10             	add    $0x10,%esp
f0114b31:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b34:	e8 2f 9e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114b39:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114b3c:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114b40:	75 08                	jne    f0114b4a <test_allocate_chunk+0x1e8>
f0114b42:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b45:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114b48:	74 2a                	je     f0114b74 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114b4a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b4d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114b50:	83 ec 08             	sub    $0x8,%esp
f0114b53:	6a 00                	push   $0x0
f0114b55:	50                   	push   %eax
f0114b56:	ff 75 b0             	pushl  -0x50(%ebp)
f0114b59:	68 64 a7 12 f0       	push   $0xf012a764
f0114b5e:	68 48 05 00 00       	push   $0x548
f0114b63:	68 e2 91 12 f0       	push   $0xf01291e2
f0114b68:	e8 69 b9 fe ff       	call   f01004d6 <_warn>
f0114b6d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b70:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114b74:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b78:	74 04                	je     f0114b7e <test_allocate_chunk+0x21c>
f0114b7a:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114b7e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114b82:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b85:	c1 e0 02             	shl    $0x2,%eax
f0114b88:	83 ec 08             	sub    $0x8,%esp
f0114b8b:	6a 03                	push   $0x3
f0114b8d:	6a 00                	push   $0x0
f0114b8f:	6a 00                	push   $0x0
f0114b91:	68 ff 0f 00 00       	push   $0xfff
f0114b96:	ff 75 b8             	pushl  -0x48(%ebp)
f0114b99:	6a 01                	push   $0x1
f0114b9b:	50                   	push   %eax
f0114b9c:	68 00 f0 bf ef       	push   $0xefbff000
f0114ba1:	6a 00                	push   $0x0
f0114ba3:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ba6:	e8 e5 1e 00 00       	call   f0116a90 <CCP>
f0114bab:	83 c4 30             	add    $0x30,%esp
f0114bae:	85 c0                	test   %eax,%eax
f0114bb0:	75 1e                	jne    f0114bd0 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114bb2:	83 ec 04             	sub    $0x4,%esp
f0114bb5:	68 cc a7 12 f0       	push   $0xf012a7cc
f0114bba:	68 50 05 00 00       	push   $0x550
f0114bbf:	68 e2 91 12 f0       	push   $0xf01291e2
f0114bc4:	e8 0d b9 fe ff       	call   f01004d6 <_warn>
f0114bc9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114bcc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114bd0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114bd4:	74 04                	je     f0114bda <test_allocate_chunk+0x278>
f0114bd6:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114bda:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114bde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114be1:	8a 10                	mov    (%eax),%dl
f0114be3:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114be9:	38 c2                	cmp    %al,%dl
f0114beb:	75 0f                	jne    f0114bfc <test_allocate_chunk+0x29a>
f0114bed:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114bf0:	8a 10                	mov    (%eax),%dl
f0114bf2:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114bf8:	38 c2                	cmp    %al,%dl
f0114bfa:	74 1e                	je     f0114c1a <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114bfc:	83 ec 04             	sub    $0x4,%esp
f0114bff:	68 18 a8 12 f0       	push   $0xf012a818
f0114c04:	68 58 05 00 00       	push   $0x558
f0114c09:	68 e2 91 12 f0       	push   $0xf01291e2
f0114c0e:	e8 c3 b8 fe ff       	call   f01004d6 <_warn>
f0114c13:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c16:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114c1a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c1e:	74 04                	je     f0114c24 <test_allocate_chunk+0x2c2>
f0114c20:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114c24:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114c28:	83 ec 0c             	sub    $0xc,%esp
f0114c2b:	68 95 a5 12 f0       	push   $0xf012a595
f0114c30:	e8 56 c3 fe ff       	call   f0100f8b <cprintf>
f0114c35:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114c38:	83 ec 0c             	sub    $0xc,%esp
f0114c3b:	68 50 a8 12 f0       	push   $0xf012a850
f0114c40:	e8 46 c3 fe ff       	call   f0100f8b <cprintf>
f0114c45:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114c48:	e8 1b 9d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114c4d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114c50:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c53:	c1 e0 05             	shl    $0x5,%eax
f0114c56:	68 02 0e 00 00       	push   $0xe02
f0114c5b:	50                   	push   %eax
f0114c5c:	6a 00                	push   $0x0
f0114c5e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c61:	e8 ef 5e ff ff       	call   f010ab55 <allocate_chunk>
f0114c66:	83 c4 10             	add    $0x10,%esp
f0114c69:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114c6c:	e8 f7 9c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114c71:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114c74:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114c78:	75 36                	jne    f0114cb0 <test_allocate_chunk+0x34e>
f0114c7a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114c7d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114c80:	89 c1                	mov    %eax,%ecx
f0114c82:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c85:	c1 e0 05             	shl    $0x5,%eax
f0114c88:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114c8b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c92:	99                   	cltd   
f0114c93:	f7 fe                	idiv   %esi
f0114c95:	89 c3                	mov    %eax,%ebx
f0114c97:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c9a:	c1 e0 05             	shl    $0x5,%eax
f0114c9d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ca0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114ca7:	99                   	cltd   
f0114ca8:	f7 fe                	idiv   %esi
f0114caa:	01 d8                	add    %ebx,%eax
f0114cac:	39 c1                	cmp    %eax,%ecx
f0114cae:	74 54                	je     f0114d04 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114cb0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cb3:	c1 e0 05             	shl    $0x5,%eax
f0114cb6:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114cb9:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114cc0:	99                   	cltd   
f0114cc1:	f7 ff                	idiv   %edi
f0114cc3:	89 c1                	mov    %eax,%ecx
f0114cc5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cc8:	c1 e0 05             	shl    $0x5,%eax
f0114ccb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114cce:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114cd5:	99                   	cltd   
f0114cd6:	f7 fe                	idiv   %esi
f0114cd8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114cdb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cde:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ce1:	83 ec 08             	sub    $0x8,%esp
f0114ce4:	52                   	push   %edx
f0114ce5:	50                   	push   %eax
f0114ce6:	ff 75 a8             	pushl  -0x58(%ebp)
f0114ce9:	68 90 a8 12 f0       	push   $0xf012a890
f0114cee:	68 6d 05 00 00       	push   $0x56d
f0114cf3:	68 e2 91 12 f0       	push   $0xf01291e2
f0114cf8:	e8 d9 b7 fe ff       	call   f01004d6 <_warn>
f0114cfd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d00:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114d04:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d08:	74 04                	je     f0114d0e <test_allocate_chunk+0x3ac>
f0114d0a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114d0e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114d12:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114d19:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d1c:	c1 e0 05             	shl    $0x5,%eax
f0114d1f:	83 ec 08             	sub    $0x8,%esp
f0114d22:	6a 03                	push   $0x3
f0114d24:	6a 00                	push   $0x0
f0114d26:	6a 00                	push   $0x0
f0114d28:	68 07 0e 00 00       	push   $0xe07
f0114d2d:	68 03 0e 00 00       	push   $0xe03
f0114d32:	6a 01                	push   $0x1
f0114d34:	50                   	push   %eax
f0114d35:	6a 00                	push   $0x0
f0114d37:	6a 00                	push   $0x0
f0114d39:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d3c:	e8 4f 1d 00 00       	call   f0116a90 <CCP>
f0114d41:	83 c4 30             	add    $0x30,%esp
f0114d44:	85 c0                	test   %eax,%eax
f0114d46:	75 25                	jne    f0114d6d <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114d48:	83 ec 04             	sub    $0x4,%esp
f0114d4b:	68 cc a7 12 f0       	push   $0xf012a7cc
f0114d50:	68 76 05 00 00       	push   $0x576
f0114d55:	68 e2 91 12 f0       	push   $0xf01291e2
f0114d5a:	e8 77 b7 fe ff       	call   f01004d6 <_warn>
f0114d5f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114d62:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114d66:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114d6d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d71:	74 04                	je     f0114d77 <test_allocate_chunk+0x415>
f0114d73:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114d77:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114d7b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114d7f:	74 5a                	je     f0114ddb <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114d81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114d84:	01 c0                	add    %eax,%eax
f0114d86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114d89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d8c:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114d8f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d92:	01 c0                	add    %eax,%eax
f0114d94:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114d97:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d9a:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114d9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114da0:	8a 00                	mov    (%eax),%al
f0114da2:	3c 4b                	cmp    $0x4b,%al
f0114da4:	75 09                	jne    f0114daf <test_allocate_chunk+0x44d>
f0114da6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114da9:	8a 00                	mov    (%eax),%al
f0114dab:	3c 4d                	cmp    $0x4d,%al
f0114dad:	74 1e                	je     f0114dcd <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114daf:	83 ec 04             	sub    $0x4,%esp
f0114db2:	68 18 a8 12 f0       	push   $0xf012a818
f0114db7:	68 84 05 00 00       	push   $0x584
f0114dbc:	68 e2 91 12 f0       	push   $0xf01291e2
f0114dc1:	e8 10 b7 fe ff       	call   f01004d6 <_warn>
f0114dc6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114dc9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114dcd:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114dd1:	74 04                	je     f0114dd7 <test_allocate_chunk+0x475>
f0114dd3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114dd7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114ddb:	83 ec 0c             	sub    $0xc,%esp
f0114dde:	68 6f 9b 12 f0       	push   $0xf0129b6f
f0114de3:	e8 a3 c1 fe ff       	call   f0100f8b <cprintf>
f0114de8:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114deb:	83 ec 0c             	sub    $0xc,%esp
f0114dee:	68 f0 a8 12 f0       	push   $0xf012a8f0
f0114df3:	e8 93 c1 fe ff       	call   f0100f8b <cprintf>
f0114df8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114dfb:	e8 68 9b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114e00:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114e03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e06:	c1 e0 06             	shl    $0x6,%eax
f0114e09:	89 c2                	mov    %eax,%edx
f0114e0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e0e:	c1 e0 05             	shl    $0x5,%eax
f0114e11:	6a 00                	push   $0x0
f0114e13:	52                   	push   %edx
f0114e14:	50                   	push   %eax
f0114e15:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e18:	e8 38 5d ff ff       	call   f010ab55 <allocate_chunk>
f0114e1d:	83 c4 10             	add    $0x10,%esp
f0114e20:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114e23:	e8 40 9b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114e28:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114e2b:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114e2f:	75 36                	jne    f0114e67 <test_allocate_chunk+0x505>
f0114e31:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e34:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e37:	89 c1                	mov    %eax,%ecx
f0114e39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e3c:	c1 e0 06             	shl    $0x6,%eax
f0114e3f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114e42:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114e49:	99                   	cltd   
f0114e4a:	f7 ff                	idiv   %edi
f0114e4c:	89 c3                	mov    %eax,%ebx
f0114e4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e51:	c1 e0 06             	shl    $0x6,%eax
f0114e54:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114e57:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114e5e:	99                   	cltd   
f0114e5f:	f7 fe                	idiv   %esi
f0114e61:	01 d8                	add    %ebx,%eax
f0114e63:	39 c1                	cmp    %eax,%ecx
f0114e65:	74 54                	je     f0114ebb <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114e67:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e6a:	c1 e0 06             	shl    $0x6,%eax
f0114e6d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114e70:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114e77:	99                   	cltd   
f0114e78:	f7 fb                	idiv   %ebx
f0114e7a:	89 c1                	mov    %eax,%ecx
f0114e7c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e7f:	c1 e0 06             	shl    $0x6,%eax
f0114e82:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114e85:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114e8c:	99                   	cltd   
f0114e8d:	f7 ff                	idiv   %edi
f0114e8f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114e92:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e95:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e98:	83 ec 08             	sub    $0x8,%esp
f0114e9b:	52                   	push   %edx
f0114e9c:	50                   	push   %eax
f0114e9d:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114ea0:	68 90 a8 12 f0       	push   $0xf012a890
f0114ea5:	68 9a 05 00 00       	push   $0x59a
f0114eaa:	68 e2 91 12 f0       	push   $0xf01291e2
f0114eaf:	e8 22 b6 fe ff       	call   f01004d6 <_warn>
f0114eb4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114eb7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114ebb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ebf:	74 04                	je     f0114ec5 <test_allocate_chunk+0x563>
f0114ec1:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114ec5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114ec9:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114ed0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ed3:	c1 e0 06             	shl    $0x6,%eax
f0114ed6:	89 c2                	mov    %eax,%edx
f0114ed8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114edb:	c1 e0 05             	shl    $0x5,%eax
f0114ede:	83 ec 08             	sub    $0x8,%esp
f0114ee1:	6a 03                	push   $0x3
f0114ee3:	6a 00                	push   $0x0
f0114ee5:	6a 00                	push   $0x0
f0114ee7:	68 07 0e 00 00       	push   $0xe07
f0114eec:	6a 01                	push   $0x1
f0114eee:	6a 01                	push   $0x1
f0114ef0:	52                   	push   %edx
f0114ef1:	50                   	push   %eax
f0114ef2:	6a 00                	push   $0x0
f0114ef4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ef7:	e8 94 1b 00 00       	call   f0116a90 <CCP>
f0114efc:	83 c4 30             	add    $0x30,%esp
f0114eff:	85 c0                	test   %eax,%eax
f0114f01:	75 25                	jne    f0114f28 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f03:	83 ec 04             	sub    $0x4,%esp
f0114f06:	68 cc a7 12 f0       	push   $0xf012a7cc
f0114f0b:	68 a3 05 00 00       	push   $0x5a3
f0114f10:	68 e2 91 12 f0       	push   $0xf01291e2
f0114f15:	e8 bc b5 fe ff       	call   f01004d6 <_warn>
f0114f1a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f1d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114f21:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114f28:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f2c:	74 04                	je     f0114f32 <test_allocate_chunk+0x5d0>
f0114f2e:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114f32:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114f36:	83 ec 0c             	sub    $0xc,%esp
f0114f39:	68 d2 9b 12 f0       	push   $0xf0129bd2
f0114f3e:	e8 48 c0 fe ff       	call   f0100f8b <cprintf>
f0114f43:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114f46:	83 ec 0c             	sub    $0xc,%esp
f0114f49:	68 30 a9 12 f0       	push   $0xf012a930
f0114f4e:	e8 38 c0 fe ff       	call   f0100f8b <cprintf>
f0114f53:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f56:	e8 0d 9a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114f5b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114f5e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f61:	c1 e0 06             	shl    $0x6,%eax
f0114f64:	68 06 0e 00 00       	push   $0xe06
f0114f69:	50                   	push   %eax
f0114f6a:	68 00 00 00 80       	push   $0x80000000
f0114f6f:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f72:	e8 de 5b ff ff       	call   f010ab55 <allocate_chunk>
f0114f77:	83 c4 10             	add    $0x10,%esp
f0114f7a:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f7d:	e8 e6 99 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0114f82:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114f85:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114f89:	75 36                	jne    f0114fc1 <test_allocate_chunk+0x65f>
f0114f8b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f8e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f91:	89 c1                	mov    %eax,%ecx
f0114f93:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f96:	c1 e0 06             	shl    $0x6,%eax
f0114f99:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f9c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114fa3:	99                   	cltd   
f0114fa4:	f7 fb                	idiv   %ebx
f0114fa6:	89 c3                	mov    %eax,%ebx
f0114fa8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fab:	c1 e0 06             	shl    $0x6,%eax
f0114fae:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114fb1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114fb8:	99                   	cltd   
f0114fb9:	f7 fe                	idiv   %esi
f0114fbb:	01 d8                	add    %ebx,%eax
f0114fbd:	39 c1                	cmp    %eax,%ecx
f0114fbf:	74 54                	je     f0115015 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114fc1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fc4:	c1 e0 06             	shl    $0x6,%eax
f0114fc7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114fca:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114fd1:	99                   	cltd   
f0114fd2:	f7 ff                	idiv   %edi
f0114fd4:	89 c1                	mov    %eax,%ecx
f0114fd6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fd9:	c1 e0 06             	shl    $0x6,%eax
f0114fdc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114fdf:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114fe6:	99                   	cltd   
f0114fe7:	f7 fb                	idiv   %ebx
f0114fe9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114fec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fef:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ff2:	83 ec 08             	sub    $0x8,%esp
f0114ff5:	52                   	push   %edx
f0114ff6:	50                   	push   %eax
f0114ff7:	ff 75 9c             	pushl  -0x64(%ebp)
f0114ffa:	68 90 a8 12 f0       	push   $0xf012a890
f0114fff:	68 b9 05 00 00       	push   $0x5b9
f0115004:	68 e2 91 12 f0       	push   $0xf01291e2
f0115009:	e8 c8 b4 fe ff       	call   f01004d6 <_warn>
f011500e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115011:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115015:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115019:	74 04                	je     f011501f <test_allocate_chunk+0x6bd>
f011501b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011501f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115023:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011502a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011502d:	c1 e0 06             	shl    $0x6,%eax
f0115030:	83 ec 08             	sub    $0x8,%esp
f0115033:	6a 03                	push   $0x3
f0115035:	6a 00                	push   $0x0
f0115037:	6a 00                	push   $0x0
f0115039:	68 07 0e 00 00       	push   $0xe07
f011503e:	68 07 0e 00 00       	push   $0xe07
f0115043:	6a 01                	push   $0x1
f0115045:	50                   	push   %eax
f0115046:	68 00 00 00 80       	push   $0x80000000
f011504b:	6a 00                	push   $0x0
f011504d:	ff 75 cc             	pushl  -0x34(%ebp)
f0115050:	e8 3b 1a 00 00       	call   f0116a90 <CCP>
f0115055:	83 c4 30             	add    $0x30,%esp
f0115058:	85 c0                	test   %eax,%eax
f011505a:	75 25                	jne    f0115081 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011505c:	83 ec 04             	sub    $0x4,%esp
f011505f:	68 cc a7 12 f0       	push   $0xf012a7cc
f0115064:	68 c2 05 00 00       	push   $0x5c2
f0115069:	68 e2 91 12 f0       	push   $0xf01291e2
f011506e:	e8 63 b4 fe ff       	call   f01004d6 <_warn>
f0115073:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115076:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011507a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115081:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115085:	74 04                	je     f011508b <test_allocate_chunk+0x729>
f0115087:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011508b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011508f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115093:	74 6f                	je     f0115104 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115095:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115098:	01 c0                	add    %eax,%eax
f011509a:	05 00 00 00 80       	add    $0x80000000,%eax
f011509f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01150a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01150a5:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f01150a8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01150ab:	89 d0                	mov    %edx,%eax
f01150ad:	c1 e0 02             	shl    $0x2,%eax
f01150b0:	01 d0                	add    %edx,%eax
f01150b2:	01 c0                	add    %eax,%eax
f01150b4:	01 d0                	add    %edx,%eax
f01150b6:	01 c0                	add    %eax,%eax
f01150b8:	05 00 00 00 80       	add    $0x80000000,%eax
f01150bd:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01150c0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01150c3:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01150c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01150c9:	8a 00                	mov    (%eax),%al
f01150cb:	3c 4b                	cmp    $0x4b,%al
f01150cd:	75 09                	jne    f01150d8 <test_allocate_chunk+0x776>
f01150cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01150d2:	8a 00                	mov    (%eax),%al
f01150d4:	3c 4d                	cmp    $0x4d,%al
f01150d6:	74 1e                	je     f01150f6 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01150d8:	83 ec 04             	sub    $0x4,%esp
f01150db:	68 18 a8 12 f0       	push   $0xf012a818
f01150e0:	68 d0 05 00 00       	push   $0x5d0
f01150e5:	68 e2 91 12 f0       	push   $0xf01291e2
f01150ea:	e8 e7 b3 fe ff       	call   f01004d6 <_warn>
f01150ef:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01150f2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01150f6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150fa:	74 04                	je     f0115100 <test_allocate_chunk+0x79e>
f01150fc:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115100:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0115104:	83 ec 0c             	sub    $0xc,%esp
f0115107:	68 a4 a6 12 f0       	push   $0xf012a6a4
f011510c:	e8 7a be fe ff       	call   f0100f8b <cprintf>
f0115111:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0115114:	83 ec 0c             	sub    $0xc,%esp
f0115117:	68 6c a9 12 f0       	push   $0xf012a96c
f011511c:	e8 6a be fe ff       	call   f0100f8b <cprintf>
f0115121:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115124:	e8 3f 98 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0115129:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f011512c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011512f:	89 d0                	mov    %edx,%eax
f0115131:	01 c0                	add    %eax,%eax
f0115133:	01 d0                	add    %edx,%eax
f0115135:	01 c0                	add    %eax,%eax
f0115137:	01 d0                	add    %edx,%eax
f0115139:	68 04 0e 00 00       	push   $0xe04
f011513e:	50                   	push   %eax
f011513f:	68 00 fc 3f 40       	push   $0x403ffc00
f0115144:	ff 75 cc             	pushl  -0x34(%ebp)
f0115147:	e8 09 5a ff ff       	call   f010ab55 <allocate_chunk>
f011514c:	83 c4 10             	add    $0x10,%esp
f011514f:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115152:	e8 11 98 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0115157:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011515a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f011515e:	75 0b                	jne    f011516b <test_allocate_chunk+0x809>
f0115160:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115163:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115166:	83 f8 05             	cmp    $0x5,%eax
f0115169:	74 2a                	je     f0115195 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f011516b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011516e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115171:	83 ec 08             	sub    $0x8,%esp
f0115174:	6a 05                	push   $0x5
f0115176:	50                   	push   %eax
f0115177:	ff 75 98             	pushl  -0x68(%ebp)
f011517a:	68 90 a8 12 f0       	push   $0xf012a890
f011517f:	68 e7 05 00 00       	push   $0x5e7
f0115184:	68 e2 91 12 f0       	push   $0xf01291e2
f0115189:	e8 48 b3 fe ff       	call   f01004d6 <_warn>
f011518e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115191:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115195:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115199:	74 04                	je     f011519f <test_allocate_chunk+0x83d>
f011519b:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011519f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01151a3:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01151aa:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151ad:	89 d0                	mov    %edx,%eax
f01151af:	01 c0                	add    %eax,%eax
f01151b1:	01 d0                	add    %edx,%eax
f01151b3:	c1 e0 02             	shl    $0x2,%eax
f01151b6:	83 ec 08             	sub    $0x8,%esp
f01151b9:	6a 03                	push   $0x3
f01151bb:	6a 00                	push   $0x0
f01151bd:	6a 00                	push   $0x0
f01151bf:	68 07 0e 00 00       	push   $0xe07
f01151c4:	68 05 0e 00 00       	push   $0xe05
f01151c9:	6a 01                	push   $0x1
f01151cb:	50                   	push   %eax
f01151cc:	68 00 f0 3f 40       	push   $0x403ff000
f01151d1:	6a 00                	push   $0x0
f01151d3:	ff 75 cc             	pushl  -0x34(%ebp)
f01151d6:	e8 b5 18 00 00       	call   f0116a90 <CCP>
f01151db:	83 c4 30             	add    $0x30,%esp
f01151de:	85 c0                	test   %eax,%eax
f01151e0:	75 25                	jne    f0115207 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01151e2:	83 ec 04             	sub    $0x4,%esp
f01151e5:	68 cc a7 12 f0       	push   $0xf012a7cc
f01151ea:	68 f0 05 00 00       	push   $0x5f0
f01151ef:	68 e2 91 12 f0       	push   $0xf01291e2
f01151f4:	e8 dd b2 fe ff       	call   f01004d6 <_warn>
f01151f9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01151fc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115200:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0115207:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011520b:	74 04                	je     f0115211 <test_allocate_chunk+0x8af>
f011520d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115211:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0115215:	83 ec 0c             	sub    $0xc,%esp
f0115218:	68 a3 a9 12 f0       	push   $0xf012a9a3
f011521d:	e8 69 bd fe ff       	call   f0100f8b <cprintf>
f0115222:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115225:	83 ec 08             	sub    $0x8,%esp
f0115228:	ff 75 e0             	pushl  -0x20(%ebp)
f011522b:	68 b4 a9 12 f0       	push   $0xf012a9b4
f0115230:	e8 56 bd fe ff       	call   f0100f8b <cprintf>
f0115235:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115238:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f011523c:	75 10                	jne    f011524e <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f011523e:	83 ec 0c             	sub    $0xc,%esp
f0115241:	68 e8 a9 12 f0       	push   $0xf012a9e8
f0115246:	e8 40 bd fe ff       	call   f0100f8b <cprintf>
f011524b:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011524e:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0115253:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115256:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115259:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011525c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115261:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115264:	5b                   	pop    %ebx
f0115265:	5e                   	pop    %esi
f0115266:	5f                   	pop    %edi
f0115267:	5d                   	pop    %ebp
f0115268:	c3                   	ret    

f0115269 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115269:	55                   	push   %ebp
f011526a:	89 e5                	mov    %esp,%ebp
f011526c:	57                   	push   %edi
f011526d:	56                   	push   %esi
f011526e:	53                   	push   %ebx
f011526f:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115275:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115278:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f011527d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115282:	89 c7                	mov    %eax,%edi
f0115284:	89 de                	mov    %ebx,%esi
f0115286:	89 d1                	mov    %edx,%ecx
f0115288:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011528a:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011528d:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115292:	b0 00                	mov    $0x0,%al
f0115294:	89 d7                	mov    %edx,%edi
f0115296:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115298:	6a 00                	push   $0x0
f011529a:	6a 0a                	push   $0xa
f011529c:	6a 14                	push   $0x14
f011529e:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01152a1:	50                   	push   %eax
f01152a2:	e8 21 5d ff ff       	call   f010afc8 <env_create>
f01152a7:	83 c4 10             	add    $0x10,%esp
f01152aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01152ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01152b0:	8b 40 64             	mov    0x64(%eax),%eax
f01152b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01152b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01152b9:	8b 40 68             	mov    0x68(%eax),%eax
f01152bc:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01152bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152c2:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01152c5:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01152cc:	75 70 20 
f01152cf:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01152d6:	00 00 00 
f01152d9:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01152dc:	b9 03 00 00 00       	mov    $0x3,%ecx
f01152e1:	b8 00 00 00 00       	mov    $0x0,%eax
f01152e6:	89 d7                	mov    %edx,%edi
f01152e8:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01152ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01152ed:	8b 40 10             	mov    0x10(%eax),%eax
f01152f0:	83 ec 08             	sub    $0x8,%esp
f01152f3:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01152f9:	52                   	push   %edx
f01152fa:	50                   	push   %eax
f01152fb:	e8 28 ae 00 00       	call   f0120128 <ltostr>
f0115300:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115303:	83 ec 04             	sub    $0x4,%esp
f0115306:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011530c:	50                   	push   %eax
f011530d:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115313:	50                   	push   %eax
f0115314:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011531a:	50                   	push   %eax
f011531b:	e8 e1 ae 00 00       	call   f0120201 <strcconcat>
f0115320:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115323:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011532a:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115331:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0115338:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f011533f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115343:	83 ec 0c             	sub    $0xc,%esp
f0115346:	ff 75 d8             	pushl  -0x28(%ebp)
f0115349:	e8 0e 17 00 00       	call   f0116a5c <ClearUserSpace>
f011534e:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115351:	83 ec 0c             	sub    $0xc,%esp
f0115354:	68 28 aa 12 f0       	push   $0xf012aa28
f0115359:	e8 2d bc fe ff       	call   f0100f8b <cprintf>
f011535e:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115361:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115364:	c1 e0 03             	shl    $0x3,%eax
f0115367:	83 ec 04             	sub    $0x4,%esp
f011536a:	50                   	push   %eax
f011536b:	6a 00                	push   $0x0
f011536d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115370:	e8 14 58 ff ff       	call   f010ab89 <calculate_required_frames>
f0115375:	83 c4 10             	add    $0x10,%esp
f0115378:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011537b:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011537f:	74 23                	je     f01153a4 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115381:	83 ec 0c             	sub    $0xc,%esp
f0115384:	6a 03                	push   $0x3
f0115386:	ff 75 c8             	pushl  -0x38(%ebp)
f0115389:	68 5c aa 12 f0       	push   $0xf012aa5c
f011538e:	68 29 06 00 00       	push   $0x629
f0115393:	68 e2 91 12 f0       	push   $0xf01291e2
f0115398:	e8 39 b1 fe ff       	call   f01004d6 <_warn>
f011539d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153a0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01153a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153a8:	74 04                	je     f01153ae <test_calculate_required_frames+0x145>
f01153aa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01153ae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f01153b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153b5:	c1 e0 02             	shl    $0x2,%eax
f01153b8:	83 ec 04             	sub    $0x4,%esp
f01153bb:	50                   	push   %eax
f01153bc:	6a 00                	push   $0x0
f01153be:	ff 75 d8             	pushl  -0x28(%ebp)
f01153c1:	e8 c3 57 ff ff       	call   f010ab89 <calculate_required_frames>
f01153c6:	83 c4 10             	add    $0x10,%esp
f01153c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01153cc:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01153d3:	74 26                	je     f01153fb <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01153d5:	83 ec 0c             	sub    $0xc,%esp
f01153d8:	68 01 04 00 00       	push   $0x401
f01153dd:	ff 75 c8             	pushl  -0x38(%ebp)
f01153e0:	68 5c aa 12 f0       	push   $0xf012aa5c
f01153e5:	68 33 06 00 00       	push   $0x633
f01153ea:	68 e2 91 12 f0       	push   $0xf01291e2
f01153ef:	e8 e2 b0 fe ff       	call   f01004d6 <_warn>
f01153f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01153fb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153ff:	74 04                	je     f0115405 <test_calculate_required_frames+0x19c>
f0115401:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115405:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115409:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011540c:	c1 e0 0a             	shl    $0xa,%eax
f011540f:	83 ec 04             	sub    $0x4,%esp
f0115412:	50                   	push   %eax
f0115413:	6a 00                	push   $0x0
f0115415:	ff 75 d8             	pushl  -0x28(%ebp)
f0115418:	e8 6c 57 ff ff       	call   f010ab89 <calculate_required_frames>
f011541d:	83 c4 10             	add    $0x10,%esp
f0115420:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115423:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115426:	c1 e0 0a             	shl    $0xa,%eax
f0115429:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011542c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115433:	99                   	cltd   
f0115434:	f7 fb                	idiv   %ebx
f0115436:	89 c1                	mov    %eax,%ecx
f0115438:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011543b:	c1 e0 0a             	shl    $0xa,%eax
f011543e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115441:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115448:	99                   	cltd   
f0115449:	f7 fe                	idiv   %esi
f011544b:	01 c8                	add    %ecx,%eax
f011544d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115450:	74 4c                	je     f011549e <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115452:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115455:	c1 e0 0a             	shl    $0xa,%eax
f0115458:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011545b:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115462:	99                   	cltd   
f0115463:	f7 fb                	idiv   %ebx
f0115465:	89 c1                	mov    %eax,%ecx
f0115467:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011546a:	c1 e0 0a             	shl    $0xa,%eax
f011546d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115470:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115477:	99                   	cltd   
f0115478:	f7 fe                	idiv   %esi
f011547a:	01 c8                	add    %ecx,%eax
f011547c:	83 ec 0c             	sub    $0xc,%esp
f011547f:	50                   	push   %eax
f0115480:	ff 75 c8             	pushl  -0x38(%ebp)
f0115483:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115488:	68 3d 06 00 00       	push   $0x63d
f011548d:	68 e2 91 12 f0       	push   $0xf01291e2
f0115492:	e8 3f b0 fe ff       	call   f01004d6 <_warn>
f0115497:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011549a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011549e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154a2:	74 04                	je     f01154a8 <test_calculate_required_frames+0x23f>
f01154a4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154a8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f01154ac:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01154af:	89 d0                	mov    %edx,%eax
f01154b1:	01 c0                	add    %eax,%eax
f01154b3:	01 d0                	add    %edx,%eax
f01154b5:	01 c0                	add    %eax,%eax
f01154b7:	83 ec 04             	sub    $0x4,%esp
f01154ba:	50                   	push   %eax
f01154bb:	68 00 10 00 00       	push   $0x1000
f01154c0:	ff 75 d8             	pushl  -0x28(%ebp)
f01154c3:	e8 c1 56 ff ff       	call   f010ab89 <calculate_required_frames>
f01154c8:	83 c4 10             	add    $0x10,%esp
f01154cb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01154ce:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01154d2:	74 23                	je     f01154f7 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01154d4:	83 ec 0c             	sub    $0xc,%esp
f01154d7:	6a 03                	push   $0x3
f01154d9:	ff 75 c8             	pushl  -0x38(%ebp)
f01154dc:	68 5c aa 12 f0       	push   $0xf012aa5c
f01154e1:	68 49 06 00 00       	push   $0x649
f01154e6:	68 e2 91 12 f0       	push   $0xf01291e2
f01154eb:	e8 e6 af fe ff       	call   f01004d6 <_warn>
f01154f0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154f3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154f7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154fb:	74 04                	je     f0115501 <test_calculate_required_frames+0x298>
f01154fd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115501:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115505:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115508:	89 c2                	mov    %eax,%edx
f011550a:	01 d2                	add    %edx,%edx
f011550c:	01 d0                	add    %edx,%eax
f011550e:	83 ec 04             	sub    $0x4,%esp
f0115511:	50                   	push   %eax
f0115512:	68 00 18 00 00       	push   $0x1800
f0115517:	ff 75 d8             	pushl  -0x28(%ebp)
f011551a:	e8 6a 56 ff ff       	call   f010ab89 <calculate_required_frames>
f011551f:	83 c4 10             	add    $0x10,%esp
f0115522:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115525:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115529:	74 23                	je     f011554e <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011552b:	83 ec 0c             	sub    $0xc,%esp
f011552e:	6a 03                	push   $0x3
f0115530:	ff 75 c8             	pushl  -0x38(%ebp)
f0115533:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115538:	68 53 06 00 00       	push   $0x653
f011553d:	68 e2 91 12 f0       	push   $0xf01291e2
f0115542:	e8 8f af fe ff       	call   f01004d6 <_warn>
f0115547:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011554a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011554e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115552:	74 04                	je     f0115558 <test_calculate_required_frames+0x2ef>
f0115554:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115558:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f011555c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011555f:	89 d0                	mov    %edx,%eax
f0115561:	c1 e0 02             	shl    $0x2,%eax
f0115564:	01 d0                	add    %edx,%eax
f0115566:	01 c0                	add    %eax,%eax
f0115568:	83 ec 04             	sub    $0x4,%esp
f011556b:	50                   	push   %eax
f011556c:	68 00 00 40 00       	push   $0x400000
f0115571:	ff 75 d8             	pushl  -0x28(%ebp)
f0115574:	e8 10 56 ff ff       	call   f010ab89 <calculate_required_frames>
f0115579:	83 c4 10             	add    $0x10,%esp
f011557c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f011557f:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115586:	74 26                	je     f01155ae <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115588:	83 ec 0c             	sub    $0xc,%esp
f011558b:	68 03 0a 00 00       	push   $0xa03
f0115590:	ff 75 c8             	pushl  -0x38(%ebp)
f0115593:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115598:	68 5d 06 00 00       	push   $0x65d
f011559d:	68 e2 91 12 f0       	push   $0xf01291e2
f01155a2:	e8 2f af fe ff       	call   f01004d6 <_warn>
f01155a7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155aa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01155ae:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155b2:	74 04                	je     f01155b8 <test_calculate_required_frames+0x34f>
f01155b4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155b8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01155bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01155bf:	01 c0                	add    %eax,%eax
f01155c1:	83 ec 04             	sub    $0x4,%esp
f01155c4:	50                   	push   %eax
f01155c5:	68 00 00 70 00       	push   $0x700000
f01155ca:	ff 75 d8             	pushl  -0x28(%ebp)
f01155cd:	e8 b7 55 ff ff       	call   f010ab89 <calculate_required_frames>
f01155d2:	83 c4 10             	add    $0x10,%esp
f01155d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f01155d8:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f01155df:	74 26                	je     f0115607 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f01155e1:	83 ec 0c             	sub    $0xc,%esp
f01155e4:	68 02 02 00 00       	push   $0x202
f01155e9:	ff 75 c8             	pushl  -0x38(%ebp)
f01155ec:	68 5c aa 12 f0       	push   $0xf012aa5c
f01155f1:	68 69 06 00 00       	push   $0x669
f01155f6:	68 e2 91 12 f0       	push   $0xf01291e2
f01155fb:	e8 d6 ae fe ff       	call   f01004d6 <_warn>
f0115600:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115603:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115607:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011560b:	74 04                	je     f0115611 <test_calculate_required_frames+0x3a8>
f011560d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115611:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115615:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115618:	83 ec 04             	sub    $0x4,%esp
f011561b:	50                   	push   %eax
f011561c:	68 ff ff 3f 00       	push   $0x3fffff
f0115621:	ff 75 d8             	pushl  -0x28(%ebp)
f0115624:	e8 60 55 ff ff       	call   f010ab89 <calculate_required_frames>
f0115629:	83 c4 10             	add    $0x10,%esp
f011562c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f011562f:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115633:	74 23                	je     f0115658 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115635:	83 ec 0c             	sub    $0xc,%esp
f0115638:	6a 04                	push   $0x4
f011563a:	ff 75 c8             	pushl  -0x38(%ebp)
f011563d:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115642:	68 73 06 00 00       	push   $0x673
f0115647:	68 e2 91 12 f0       	push   $0xf01291e2
f011564c:	e8 85 ae fe ff       	call   f01004d6 <_warn>
f0115651:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115654:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115658:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011565c:	74 04                	je     f0115662 <test_calculate_required_frames+0x3f9>
f011565e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115662:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115666:	83 ec 0c             	sub    $0xc,%esp
f0115669:	68 95 a5 12 f0       	push   $0xf012a595
f011566e:	e8 18 b9 fe ff       	call   f0100f8b <cprintf>
f0115673:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115676:	83 ec 0c             	sub    $0xc,%esp
f0115679:	68 b4 aa 12 f0       	push   $0xf012aab4
f011567e:	e8 08 b9 fe ff       	call   f0100f8b <cprintf>
f0115683:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115686:	83 ec 04             	sub    $0x4,%esp
f0115689:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011568f:	50                   	push   %eax
f0115690:	68 4e 99 12 f0       	push   $0xf012994e
f0115695:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011569b:	50                   	push   %eax
f011569c:	e8 60 ab 00 00       	call   f0120201 <strcconcat>
f01156a1:	83 c4 10             	add    $0x10,%esp
f01156a4:	83 ec 0c             	sub    $0xc,%esp
f01156a7:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01156ad:	50                   	push   %eax
f01156ae:	e8 48 c8 fe ff       	call   f0101efb <execute_command>
f01156b3:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01156b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01156b9:	c1 e0 03             	shl    $0x3,%eax
f01156bc:	83 ec 04             	sub    $0x4,%esp
f01156bf:	50                   	push   %eax
f01156c0:	6a 00                	push   $0x0
f01156c2:	ff 75 d8             	pushl  -0x28(%ebp)
f01156c5:	e8 bf 54 ff ff       	call   f010ab89 <calculate_required_frames>
f01156ca:	83 c4 10             	add    $0x10,%esp
f01156cd:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01156d0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01156d7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01156da:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01156dd:	74 24                	je     f0115703 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01156df:	83 ec 0c             	sub    $0xc,%esp
f01156e2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01156e5:	ff 75 c8             	pushl  -0x38(%ebp)
f01156e8:	68 5c aa 12 f0       	push   $0xf012aa5c
f01156ed:	68 87 06 00 00       	push   $0x687
f01156f2:	68 e2 91 12 f0       	push   $0xf01291e2
f01156f7:	e8 da ad fe ff       	call   f01004d6 <_warn>
f01156fc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115703:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115707:	74 04                	je     f011570d <test_calculate_required_frames+0x4a4>
f0115709:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011570d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115711:	83 ec 04             	sub    $0x4,%esp
f0115714:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011571a:	50                   	push   %eax
f011571b:	68 5b 99 12 f0       	push   $0xf012995b
f0115720:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115726:	50                   	push   %eax
f0115727:	e8 d5 aa 00 00       	call   f0120201 <strcconcat>
f011572c:	83 c4 10             	add    $0x10,%esp
f011572f:	83 ec 0c             	sub    $0xc,%esp
f0115732:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115738:	50                   	push   %eax
f0115739:	e8 bd c7 fe ff       	call   f0101efb <execute_command>
f011573e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115741:	83 ec 04             	sub    $0x4,%esp
f0115744:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011574a:	50                   	push   %eax
f011574b:	68 e8 aa 12 f0       	push   $0xf012aae8
f0115750:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115756:	50                   	push   %eax
f0115757:	e8 a5 aa 00 00       	call   f0120201 <strcconcat>
f011575c:	83 c4 10             	add    $0x10,%esp
f011575f:	83 ec 0c             	sub    $0xc,%esp
f0115762:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115768:	50                   	push   %eax
f0115769:	e8 8d c7 fe ff       	call   f0101efb <execute_command>
f011576e:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115771:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115774:	c1 e0 03             	shl    $0x3,%eax
f0115777:	83 ec 04             	sub    $0x4,%esp
f011577a:	50                   	push   %eax
f011577b:	6a 00                	push   $0x0
f011577d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115780:	e8 04 54 ff ff       	call   f010ab89 <calculate_required_frames>
f0115785:	83 c4 10             	add    $0x10,%esp
f0115788:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f011578b:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115792:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115795:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115798:	74 24                	je     f01157be <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011579a:	83 ec 0c             	sub    $0xc,%esp
f011579d:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157a0:	ff 75 c8             	pushl  -0x38(%ebp)
f01157a3:	68 5c aa 12 f0       	push   $0xf012aa5c
f01157a8:	68 95 06 00 00       	push   $0x695
f01157ad:	68 e2 91 12 f0       	push   $0xf01291e2
f01157b2:	e8 1f ad fe ff       	call   f01004d6 <_warn>
f01157b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01157be:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157c2:	74 04                	je     f01157c8 <test_calculate_required_frames+0x55f>
f01157c4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01157c8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01157cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157cf:	c1 e0 0a             	shl    $0xa,%eax
f01157d2:	83 ec 04             	sub    $0x4,%esp
f01157d5:	50                   	push   %eax
f01157d6:	6a 00                	push   $0x0
f01157d8:	ff 75 d8             	pushl  -0x28(%ebp)
f01157db:	e8 a9 53 ff ff       	call   f010ab89 <calculate_required_frames>
f01157e0:	83 c4 10             	add    $0x10,%esp
f01157e3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f01157e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157e9:	c1 e0 0a             	shl    $0xa,%eax
f01157ec:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01157ef:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01157f6:	99                   	cltd   
f01157f7:	f7 fb                	idiv   %ebx
f01157f9:	89 c1                	mov    %eax,%ecx
f01157fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157fe:	c1 e0 0a             	shl    $0xa,%eax
f0115801:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115804:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011580b:	99                   	cltd   
f011580c:	f7 fe                	idiv   %esi
f011580e:	01 c8                	add    %ecx,%eax
f0115810:	83 e8 05             	sub    $0x5,%eax
f0115813:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115816:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115819:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011581c:	74 24                	je     f0115842 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011581e:	83 ec 0c             	sub    $0xc,%esp
f0115821:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115824:	ff 75 c8             	pushl  -0x38(%ebp)
f0115827:	68 5c aa 12 f0       	push   $0xf012aa5c
f011582c:	68 a0 06 00 00       	push   $0x6a0
f0115831:	68 e2 91 12 f0       	push   $0xf01291e2
f0115836:	e8 9b ac fe ff       	call   f01004d6 <_warn>
f011583b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011583e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115842:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115846:	74 04                	je     f011584c <test_calculate_required_frames+0x5e3>
f0115848:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011584c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115850:	83 ec 04             	sub    $0x4,%esp
f0115853:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115859:	50                   	push   %eax
f011585a:	68 f4 aa 12 f0       	push   $0xf012aaf4
f011585f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115865:	50                   	push   %eax
f0115866:	e8 96 a9 00 00       	call   f0120201 <strcconcat>
f011586b:	83 c4 10             	add    $0x10,%esp
f011586e:	83 ec 0c             	sub    $0xc,%esp
f0115871:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115877:	50                   	push   %eax
f0115878:	e8 7e c6 fe ff       	call   f0101efb <execute_command>
f011587d:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115880:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115883:	89 c2                	mov    %eax,%edx
f0115885:	01 d2                	add    %edx,%edx
f0115887:	01 d0                	add    %edx,%eax
f0115889:	83 ec 04             	sub    $0x4,%esp
f011588c:	50                   	push   %eax
f011588d:	68 00 18 00 00       	push   $0x1800
f0115892:	ff 75 d8             	pushl  -0x28(%ebp)
f0115895:	e8 ef 52 ff ff       	call   f010ab89 <calculate_required_frames>
f011589a:	83 c4 10             	add    $0x10,%esp
f011589d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01158a0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01158a7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01158aa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01158ad:	74 24                	je     f01158d3 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01158af:	83 ec 0c             	sub    $0xc,%esp
f01158b2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01158b5:	ff 75 c8             	pushl  -0x38(%ebp)
f01158b8:	68 5c aa 12 f0       	push   $0xf012aa5c
f01158bd:	68 af 06 00 00       	push   $0x6af
f01158c2:	68 e2 91 12 f0       	push   $0xf01291e2
f01158c7:	e8 0a ac fe ff       	call   f01004d6 <_warn>
f01158cc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158cf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158d3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158d7:	74 04                	je     f01158dd <test_calculate_required_frames+0x674>
f01158d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158dd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01158e1:	83 ec 04             	sub    $0x4,%esp
f01158e4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01158ea:	50                   	push   %eax
f01158eb:	68 b4 9b 12 f0       	push   $0xf0129bb4
f01158f0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158f6:	50                   	push   %eax
f01158f7:	e8 05 a9 00 00       	call   f0120201 <strcconcat>
f01158fc:	83 c4 10             	add    $0x10,%esp
f01158ff:	83 ec 0c             	sub    $0xc,%esp
f0115902:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115908:	50                   	push   %eax
f0115909:	e8 ed c5 fe ff       	call   f0101efb <execute_command>
f011590e:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115911:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115914:	89 d0                	mov    %edx,%eax
f0115916:	c1 e0 02             	shl    $0x2,%eax
f0115919:	01 d0                	add    %edx,%eax
f011591b:	01 c0                	add    %eax,%eax
f011591d:	83 ec 04             	sub    $0x4,%esp
f0115920:	50                   	push   %eax
f0115921:	68 00 00 40 00       	push   $0x400000
f0115926:	ff 75 d8             	pushl  -0x28(%ebp)
f0115929:	e8 5b 52 ff ff       	call   f010ab89 <calculate_required_frames>
f011592e:	83 c4 10             	add    $0x10,%esp
f0115931:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115934:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011593b:	74 26                	je     f0115963 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011593d:	83 ec 0c             	sub    $0xc,%esp
f0115940:	68 03 0a 00 00       	push   $0xa03
f0115945:	ff 75 c8             	pushl  -0x38(%ebp)
f0115948:	68 5c aa 12 f0       	push   $0xf012aa5c
f011594d:	68 bb 06 00 00       	push   $0x6bb
f0115952:	68 e2 91 12 f0       	push   $0xf01291e2
f0115957:	e8 7a ab fe ff       	call   f01004d6 <_warn>
f011595c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011595f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115963:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115967:	74 04                	je     f011596d <test_calculate_required_frames+0x704>
f0115969:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011596d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115971:	83 ec 04             	sub    $0x4,%esp
f0115974:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011597a:	50                   	push   %eax
f011597b:	68 be 9b 12 f0       	push   $0xf0129bbe
f0115980:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115986:	50                   	push   %eax
f0115987:	e8 75 a8 00 00       	call   f0120201 <strcconcat>
f011598c:	83 c4 10             	add    $0x10,%esp
f011598f:	83 ec 0c             	sub    $0xc,%esp
f0115992:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115998:	50                   	push   %eax
f0115999:	e8 5d c5 fe ff       	call   f0101efb <execute_command>
f011599e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01159a1:	83 ec 04             	sub    $0x4,%esp
f01159a4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01159aa:	50                   	push   %eax
f01159ab:	68 fc aa 12 f0       	push   $0xf012aafc
f01159b0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01159b6:	50                   	push   %eax
f01159b7:	e8 45 a8 00 00       	call   f0120201 <strcconcat>
f01159bc:	83 c4 10             	add    $0x10,%esp
f01159bf:	83 ec 0c             	sub    $0xc,%esp
f01159c2:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01159c8:	50                   	push   %eax
f01159c9:	e8 2d c5 fe ff       	call   f0101efb <execute_command>
f01159ce:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01159d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01159d4:	01 c0                	add    %eax,%eax
f01159d6:	83 ec 04             	sub    $0x4,%esp
f01159d9:	50                   	push   %eax
f01159da:	68 00 00 70 00       	push   $0x700000
f01159df:	ff 75 d8             	pushl  -0x28(%ebp)
f01159e2:	e8 a2 51 ff ff       	call   f010ab89 <calculate_required_frames>
f01159e7:	83 c4 10             	add    $0x10,%esp
f01159ea:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f01159ed:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01159f4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01159f7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01159fa:	74 24                	je     f0115a20 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01159fc:	83 ec 0c             	sub    $0xc,%esp
f01159ff:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a02:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a05:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115a0a:	68 cb 06 00 00       	push   $0x6cb
f0115a0f:	68 e2 91 12 f0       	push   $0xf01291e2
f0115a14:	e8 bd aa fe ff       	call   f01004d6 <_warn>
f0115a19:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a1c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a20:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a24:	74 04                	je     f0115a2a <test_calculate_required_frames+0x7c1>
f0115a26:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a2a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115a2e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a31:	83 ec 04             	sub    $0x4,%esp
f0115a34:	50                   	push   %eax
f0115a35:	68 ff ff 3f 00       	push   $0x3fffff
f0115a3a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a3d:	e8 47 51 ff ff       	call   f010ab89 <calculate_required_frames>
f0115a42:	83 c4 10             	add    $0x10,%esp
f0115a45:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115a48:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115a4f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115a52:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a55:	74 24                	je     f0115a7b <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115a57:	83 ec 0c             	sub    $0xc,%esp
f0115a5a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a5d:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a60:	68 5c aa 12 f0       	push   $0xf012aa5c
f0115a65:	68 d6 06 00 00       	push   $0x6d6
f0115a6a:	68 e2 91 12 f0       	push   $0xf01291e2
f0115a6f:	e8 62 aa fe ff       	call   f01004d6 <_warn>
f0115a74:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a77:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a7b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a7f:	74 04                	je     f0115a85 <test_calculate_required_frames+0x81c>
f0115a81:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a85:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115a89:	83 ec 0c             	sub    $0xc,%esp
f0115a8c:	68 6f 9b 12 f0       	push   $0xf0129b6f
f0115a91:	e8 f5 b4 fe ff       	call   f0100f8b <cprintf>
f0115a96:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115a99:	83 ec 08             	sub    $0x8,%esp
f0115a9c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115a9f:	68 08 ab 12 f0       	push   $0xf012ab08
f0115aa4:	e8 e2 b4 fe ff       	call   f0100f8b <cprintf>
f0115aa9:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115aac:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115ab0:	75 10                	jne    f0115ac2 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115ab2:	83 ec 0c             	sub    $0xc,%esp
f0115ab5:	68 48 ab 12 f0       	push   $0xf012ab48
f0115aba:	e8 cc b4 fe ff       	call   f0100f8b <cprintf>
f0115abf:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115ac2:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0115ac7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115aca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115acd:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115ad0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115ad5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115ad8:	5b                   	pop    %ebx
f0115ad9:	5e                   	pop    %esi
f0115ada:	5f                   	pop    %edi
f0115adb:	5d                   	pop    %ebp
f0115adc:	c3                   	ret    

f0115add <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115add:	55                   	push   %ebp
f0115ade:	89 e5                	mov    %esp,%ebp
f0115ae0:	57                   	push   %edi
f0115ae1:	56                   	push   %esi
f0115ae2:	53                   	push   %ebx
f0115ae3:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115ae9:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115aec:	bb e4 98 12 f0       	mov    $0xf01298e4,%ebx
f0115af1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115af6:	89 c7                	mov    %eax,%edi
f0115af8:	89 de                	mov    %ebx,%esi
f0115afa:	89 d1                	mov    %edx,%ecx
f0115afc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115afe:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115b01:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115b06:	b0 00                	mov    $0x0,%al
f0115b08:	89 d7                	mov    %edx,%edi
f0115b0a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115b0c:	6a 00                	push   $0x0
f0115b0e:	6a 0a                	push   $0xa
f0115b10:	6a 14                	push   $0x14
f0115b12:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115b15:	50                   	push   %eax
f0115b16:	e8 ad 54 ff ff       	call   f010afc8 <env_create>
f0115b1b:	83 c4 10             	add    $0x10,%esp
f0115b1e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115b21:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115b24:	8b 40 64             	mov    0x64(%eax),%eax
f0115b27:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115b2d:	8b 40 68             	mov    0x68(%eax),%eax
f0115b30:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115b33:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115b36:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115b39:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115b40:	75 70 20 
f0115b43:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115b4a:	00 00 00 
f0115b4d:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115b50:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115b55:	b8 00 00 00 00       	mov    $0x0,%eax
f0115b5a:	89 d7                	mov    %edx,%edi
f0115b5c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115b5e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115b61:	8b 40 10             	mov    0x10(%eax),%eax
f0115b64:	83 ec 08             	sub    $0x8,%esp
f0115b67:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115b6d:	52                   	push   %edx
f0115b6e:	50                   	push   %eax
f0115b6f:	e8 b4 a5 00 00       	call   f0120128 <ltostr>
f0115b74:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115b77:	83 ec 04             	sub    $0x4,%esp
f0115b7a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b80:	50                   	push   %eax
f0115b81:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115b87:	50                   	push   %eax
f0115b88:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115b8e:	50                   	push   %eax
f0115b8f:	e8 6d a6 00 00       	call   f0120201 <strcconcat>
f0115b94:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115b97:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115b9e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115ba5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115bac:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115bb0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115bb7:	00 00 00 
	uint32 num_tables = 0;
f0115bba:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115bc1:	00 00 00 
	ClearUserSpace(proc_directory);
f0115bc4:	83 ec 0c             	sub    $0xc,%esp
f0115bc7:	ff 75 d8             	pushl  -0x28(%ebp)
f0115bca:	e8 8d 0e 00 00       	call   f0116a5c <ClearUserSpace>
f0115bcf:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115bd2:	83 ec 0c             	sub    $0xc,%esp
f0115bd5:	68 28 aa 12 f0       	push   $0xf012aa28
f0115bda:	e8 ac b3 fe ff       	call   f0100f8b <cprintf>
f0115bdf:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115be2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115be5:	c1 e0 03             	shl    $0x3,%eax
f0115be8:	89 c2                	mov    %eax,%edx
f0115bea:	83 ec 0c             	sub    $0xc,%esp
f0115bed:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115bf3:	50                   	push   %eax
f0115bf4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115bfa:	50                   	push   %eax
f0115bfb:	52                   	push   %edx
f0115bfc:	6a 00                	push   $0x0
f0115bfe:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c01:	e8 69 4f ff ff       	call   f010ab6f <calculate_allocated_space>
f0115c06:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115c09:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c0f:	85 c0                	test   %eax,%eax
f0115c11:	74 27                	je     f0115c3a <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c13:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c19:	83 ec 0c             	sub    $0xc,%esp
f0115c1c:	6a 00                	push   $0x0
f0115c1e:	50                   	push   %eax
f0115c1f:	68 94 ab 12 f0       	push   $0xf012ab94
f0115c24:	68 0b 07 00 00       	push   $0x70b
f0115c29:	68 e2 91 12 f0       	push   $0xf01291e2
f0115c2e:	e8 a3 a8 fe ff       	call   f01004d6 <_warn>
f0115c33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c36:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c3a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c40:	85 c0                	test   %eax,%eax
f0115c42:	74 27                	je     f0115c6b <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c44:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c4a:	83 ec 0c             	sub    $0xc,%esp
f0115c4d:	6a 00                	push   $0x0
f0115c4f:	50                   	push   %eax
f0115c50:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115c55:	68 10 07 00 00       	push   $0x710
f0115c5a:	68 e2 91 12 f0       	push   $0xf01291e2
f0115c5f:	e8 72 a8 fe ff       	call   f01004d6 <_warn>
f0115c64:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c67:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c6b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c6f:	74 04                	je     f0115c75 <test_calculate_allocated_space+0x198>
f0115c71:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c75:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115c79:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c80:	00 00 00 
		num_pages = 0;
f0115c83:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c8a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115c8d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c90:	c1 e0 02             	shl    $0x2,%eax
f0115c93:	89 c2                	mov    %eax,%edx
f0115c95:	83 ec 0c             	sub    $0xc,%esp
f0115c98:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c9e:	50                   	push   %eax
f0115c9f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ca5:	50                   	push   %eax
f0115ca6:	52                   	push   %edx
f0115ca7:	6a 00                	push   $0x0
f0115ca9:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cac:	e8 be 4e ff ff       	call   f010ab6f <calculate_allocated_space>
f0115cb1:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115cb4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cba:	85 c0                	test   %eax,%eax
f0115cbc:	74 27                	je     f0115ce5 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115cbe:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cc4:	83 ec 0c             	sub    $0xc,%esp
f0115cc7:	6a 00                	push   $0x0
f0115cc9:	50                   	push   %eax
f0115cca:	68 94 ab 12 f0       	push   $0xf012ab94
f0115ccf:	68 1c 07 00 00       	push   $0x71c
f0115cd4:	68 e2 91 12 f0       	push   $0xf01291e2
f0115cd9:	e8 f8 a7 fe ff       	call   f01004d6 <_warn>
f0115cde:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ce1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115ce5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ceb:	85 c0                	test   %eax,%eax
f0115ced:	74 27                	je     f0115d16 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115cef:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115cf5:	83 ec 0c             	sub    $0xc,%esp
f0115cf8:	6a 00                	push   $0x0
f0115cfa:	50                   	push   %eax
f0115cfb:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115d00:	68 21 07 00 00       	push   $0x721
f0115d05:	68 e2 91 12 f0       	push   $0xf01291e2
f0115d0a:	e8 c7 a7 fe ff       	call   f01004d6 <_warn>
f0115d0f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d12:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d16:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d1a:	74 04                	je     f0115d20 <test_calculate_allocated_space+0x243>
f0115d1c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d20:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115d24:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d2b:	00 00 00 
		num_pages = 0;
f0115d2e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d35:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115d38:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d3b:	c1 e0 0a             	shl    $0xa,%eax
f0115d3e:	89 c2                	mov    %eax,%edx
f0115d40:	83 ec 0c             	sub    $0xc,%esp
f0115d43:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d49:	50                   	push   %eax
f0115d4a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d50:	50                   	push   %eax
f0115d51:	52                   	push   %edx
f0115d52:	6a 00                	push   $0x0
f0115d54:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d57:	e8 13 4e ff ff       	call   f010ab6f <calculate_allocated_space>
f0115d5c:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115d5f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d65:	85 c0                	test   %eax,%eax
f0115d67:	74 27                	je     f0115d90 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d69:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d6f:	83 ec 0c             	sub    $0xc,%esp
f0115d72:	6a 00                	push   $0x0
f0115d74:	50                   	push   %eax
f0115d75:	68 94 ab 12 f0       	push   $0xf012ab94
f0115d7a:	68 2d 07 00 00       	push   $0x72d
f0115d7f:	68 e2 91 12 f0       	push   $0xf01291e2
f0115d84:	e8 4d a7 fe ff       	call   f01004d6 <_warn>
f0115d89:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d8c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d90:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d96:	85 c0                	test   %eax,%eax
f0115d98:	74 27                	je     f0115dc1 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d9a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115da0:	83 ec 0c             	sub    $0xc,%esp
f0115da3:	6a 00                	push   $0x0
f0115da5:	50                   	push   %eax
f0115da6:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115dab:	68 32 07 00 00       	push   $0x732
f0115db0:	68 e2 91 12 f0       	push   $0xf01291e2
f0115db5:	e8 1c a7 fe ff       	call   f01004d6 <_warn>
f0115dba:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115dbd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115dc1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dc5:	74 04                	je     f0115dcb <test_calculate_allocated_space+0x2ee>
f0115dc7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115dcb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115dcf:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115dd6:	00 00 00 
		num_pages = 0;
f0115dd9:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115de0:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115de3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115de6:	89 d0                	mov    %edx,%eax
f0115de8:	01 c0                	add    %eax,%eax
f0115dea:	01 d0                	add    %edx,%eax
f0115dec:	01 c0                	add    %eax,%eax
f0115dee:	05 00 10 00 00       	add    $0x1000,%eax
f0115df3:	89 c2                	mov    %eax,%edx
f0115df5:	83 ec 0c             	sub    $0xc,%esp
f0115df8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115dfe:	50                   	push   %eax
f0115dff:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e05:	50                   	push   %eax
f0115e06:	52                   	push   %edx
f0115e07:	68 00 10 00 00       	push   $0x1000
f0115e0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e0f:	e8 5b 4d ff ff       	call   f010ab6f <calculate_allocated_space>
f0115e14:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e17:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e1d:	85 c0                	test   %eax,%eax
f0115e1f:	74 27                	je     f0115e48 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e21:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e27:	83 ec 0c             	sub    $0xc,%esp
f0115e2a:	6a 00                	push   $0x0
f0115e2c:	50                   	push   %eax
f0115e2d:	68 94 ab 12 f0       	push   $0xf012ab94
f0115e32:	68 3f 07 00 00       	push   $0x73f
f0115e37:	68 e2 91 12 f0       	push   $0xf01291e2
f0115e3c:	e8 95 a6 fe ff       	call   f01004d6 <_warn>
f0115e41:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e44:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e48:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e4e:	85 c0                	test   %eax,%eax
f0115e50:	74 27                	je     f0115e79 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115e52:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e58:	83 ec 0c             	sub    $0xc,%esp
f0115e5b:	6a 00                	push   $0x0
f0115e5d:	50                   	push   %eax
f0115e5e:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115e63:	68 44 07 00 00       	push   $0x744
f0115e68:	68 e2 91 12 f0       	push   $0xf01291e2
f0115e6d:	e8 64 a6 fe ff       	call   f01004d6 <_warn>
f0115e72:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e75:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e79:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e7d:	74 04                	je     f0115e83 <test_calculate_allocated_space+0x3a6>
f0115e7f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e83:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115e87:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e8e:	00 00 00 
		num_pages = 0;
f0115e91:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e98:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115e9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e9e:	89 c2                	mov    %eax,%edx
f0115ea0:	01 d2                	add    %edx,%edx
f0115ea2:	01 d0                	add    %edx,%eax
f0115ea4:	05 00 18 00 00       	add    $0x1800,%eax
f0115ea9:	89 c2                	mov    %eax,%edx
f0115eab:	83 ec 0c             	sub    $0xc,%esp
f0115eae:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115eb4:	50                   	push   %eax
f0115eb5:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ebb:	50                   	push   %eax
f0115ebc:	52                   	push   %edx
f0115ebd:	68 00 18 00 00       	push   $0x1800
f0115ec2:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ec5:	e8 a5 4c ff ff       	call   f010ab6f <calculate_allocated_space>
f0115eca:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ecd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ed3:	85 c0                	test   %eax,%eax
f0115ed5:	74 27                	je     f0115efe <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ed7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115edd:	83 ec 0c             	sub    $0xc,%esp
f0115ee0:	6a 00                	push   $0x0
f0115ee2:	50                   	push   %eax
f0115ee3:	68 94 ab 12 f0       	push   $0xf012ab94
f0115ee8:	68 50 07 00 00       	push   $0x750
f0115eed:	68 e2 91 12 f0       	push   $0xf01291e2
f0115ef2:	e8 df a5 fe ff       	call   f01004d6 <_warn>
f0115ef7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115efa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115efe:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f04:	85 c0                	test   %eax,%eax
f0115f06:	74 27                	je     f0115f2f <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f08:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f0e:	83 ec 0c             	sub    $0xc,%esp
f0115f11:	6a 00                	push   $0x0
f0115f13:	50                   	push   %eax
f0115f14:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115f19:	68 55 07 00 00       	push   $0x755
f0115f1e:	68 e2 91 12 f0       	push   $0xf01291e2
f0115f23:	e8 ae a5 fe ff       	call   f01004d6 <_warn>
f0115f28:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f2b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f2f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f33:	74 04                	je     f0115f39 <test_calculate_allocated_space+0x45c>
f0115f35:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f39:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115f3d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f44:	00 00 00 
		num_pages = 0;
f0115f47:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f4e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115f51:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115f54:	89 d0                	mov    %edx,%eax
f0115f56:	c1 e0 02             	shl    $0x2,%eax
f0115f59:	01 d0                	add    %edx,%eax
f0115f5b:	01 c0                	add    %eax,%eax
f0115f5d:	05 00 00 40 00       	add    $0x400000,%eax
f0115f62:	89 c2                	mov    %eax,%edx
f0115f64:	83 ec 0c             	sub    $0xc,%esp
f0115f67:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f6d:	50                   	push   %eax
f0115f6e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f74:	50                   	push   %eax
f0115f75:	52                   	push   %edx
f0115f76:	68 00 00 40 00       	push   $0x400000
f0115f7b:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f7e:	e8 ec 4b ff ff       	call   f010ab6f <calculate_allocated_space>
f0115f83:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f86:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f8c:	85 c0                	test   %eax,%eax
f0115f8e:	74 27                	je     f0115fb7 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f90:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f96:	83 ec 0c             	sub    $0xc,%esp
f0115f99:	6a 00                	push   $0x0
f0115f9b:	50                   	push   %eax
f0115f9c:	68 94 ab 12 f0       	push   $0xf012ab94
f0115fa1:	68 61 07 00 00       	push   $0x761
f0115fa6:	68 e2 91 12 f0       	push   $0xf01291e2
f0115fab:	e8 26 a5 fe ff       	call   f01004d6 <_warn>
f0115fb0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fb3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115fb7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fbd:	85 c0                	test   %eax,%eax
f0115fbf:	74 27                	je     f0115fe8 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115fc1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fc7:	83 ec 0c             	sub    $0xc,%esp
f0115fca:	6a 00                	push   $0x0
f0115fcc:	50                   	push   %eax
f0115fcd:	68 f4 ab 12 f0       	push   $0xf012abf4
f0115fd2:	68 66 07 00 00       	push   $0x766
f0115fd7:	68 e2 91 12 f0       	push   $0xf01291e2
f0115fdc:	e8 f5 a4 fe ff       	call   f01004d6 <_warn>
f0115fe1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fe4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115fe8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fec:	74 04                	je     f0115ff2 <test_calculate_allocated_space+0x515>
f0115fee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ff2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115ff6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ffd:	00 00 00 
		num_pages = 0;
f0116000:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116007:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011600a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011600d:	05 00 00 38 00       	add    $0x380000,%eax
f0116012:	01 c0                	add    %eax,%eax
f0116014:	89 c2                	mov    %eax,%edx
f0116016:	83 ec 0c             	sub    $0xc,%esp
f0116019:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011601f:	50                   	push   %eax
f0116020:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116026:	50                   	push   %eax
f0116027:	52                   	push   %edx
f0116028:	68 00 00 70 00       	push   $0x700000
f011602d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116030:	e8 3a 4b ff ff       	call   f010ab6f <calculate_allocated_space>
f0116035:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116038:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011603e:	85 c0                	test   %eax,%eax
f0116040:	74 27                	je     f0116069 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116042:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116048:	83 ec 0c             	sub    $0xc,%esp
f011604b:	6a 00                	push   $0x0
f011604d:	50                   	push   %eax
f011604e:	68 94 ab 12 f0       	push   $0xf012ab94
f0116053:	68 73 07 00 00       	push   $0x773
f0116058:	68 e2 91 12 f0       	push   $0xf01291e2
f011605d:	e8 74 a4 fe ff       	call   f01004d6 <_warn>
f0116062:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116065:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116069:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011606f:	85 c0                	test   %eax,%eax
f0116071:	74 27                	je     f011609a <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116073:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116079:	83 ec 0c             	sub    $0xc,%esp
f011607c:	6a 00                	push   $0x0
f011607e:	50                   	push   %eax
f011607f:	68 f4 ab 12 f0       	push   $0xf012abf4
f0116084:	68 78 07 00 00       	push   $0x778
f0116089:	68 e2 91 12 f0       	push   $0xf01291e2
f011608e:	e8 43 a4 fe ff       	call   f01004d6 <_warn>
f0116093:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116096:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011609a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011609e:	74 04                	je     f01160a4 <test_calculate_allocated_space+0x5c7>
f01160a0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01160a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f01160a8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160af:	00 00 00 
		num_pages = 0;
f01160b2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160b9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01160bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160bf:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01160c4:	89 c2                	mov    %eax,%edx
f01160c6:	83 ec 0c             	sub    $0xc,%esp
f01160c9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160cf:	50                   	push   %eax
f01160d0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160d6:	50                   	push   %eax
f01160d7:	52                   	push   %edx
f01160d8:	68 ff ff 3f 00       	push   $0x3fffff
f01160dd:	ff 75 d8             	pushl  -0x28(%ebp)
f01160e0:	e8 8a 4a ff ff       	call   f010ab6f <calculate_allocated_space>
f01160e5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160e8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160ee:	85 c0                	test   %eax,%eax
f01160f0:	74 27                	je     f0116119 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01160f2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160f8:	83 ec 0c             	sub    $0xc,%esp
f01160fb:	6a 00                	push   $0x0
f01160fd:	50                   	push   %eax
f01160fe:	68 94 ab 12 f0       	push   $0xf012ab94
f0116103:	68 84 07 00 00       	push   $0x784
f0116108:	68 e2 91 12 f0       	push   $0xf01291e2
f011610d:	e8 c4 a3 fe ff       	call   f01004d6 <_warn>
f0116112:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116115:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116119:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011611f:	85 c0                	test   %eax,%eax
f0116121:	74 27                	je     f011614a <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116123:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116129:	83 ec 0c             	sub    $0xc,%esp
f011612c:	6a 00                	push   $0x0
f011612e:	50                   	push   %eax
f011612f:	68 f4 ab 12 f0       	push   $0xf012abf4
f0116134:	68 89 07 00 00       	push   $0x789
f0116139:	68 e2 91 12 f0       	push   $0xf01291e2
f011613e:	e8 93 a3 fe ff       	call   f01004d6 <_warn>
f0116143:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116146:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011614a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011614e:	74 04                	je     f0116154 <test_calculate_allocated_space+0x677>
f0116150:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116154:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116158:	83 ec 0c             	sub    $0xc,%esp
f011615b:	68 95 a5 12 f0       	push   $0xf012a595
f0116160:	e8 26 ae fe ff       	call   f0100f8b <cprintf>
f0116165:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116168:	83 ec 0c             	sub    $0xc,%esp
f011616b:	68 b4 aa 12 f0       	push   $0xf012aab4
f0116170:	e8 16 ae fe ff       	call   f0100f8b <cprintf>
f0116175:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116178:	83 ec 04             	sub    $0x4,%esp
f011617b:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116181:	50                   	push   %eax
f0116182:	68 4e 99 12 f0       	push   $0xf012994e
f0116187:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011618d:	50                   	push   %eax
f011618e:	e8 6e a0 00 00       	call   f0120201 <strcconcat>
f0116193:	83 c4 10             	add    $0x10,%esp
f0116196:	83 ec 0c             	sub    $0xc,%esp
f0116199:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011619f:	50                   	push   %eax
f01161a0:	e8 56 bd fe ff       	call   f0101efb <execute_command>
f01161a5:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f01161a8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01161af:	00 00 00 
		num_pages = 0;
f01161b2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01161b9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01161bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01161bf:	c1 e0 03             	shl    $0x3,%eax
f01161c2:	89 c2                	mov    %eax,%edx
f01161c4:	83 ec 0c             	sub    $0xc,%esp
f01161c7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01161cd:	50                   	push   %eax
f01161ce:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01161d4:	50                   	push   %eax
f01161d5:	52                   	push   %edx
f01161d6:	6a 00                	push   $0x0
f01161d8:	ff 75 d8             	pushl  -0x28(%ebp)
f01161db:	e8 8f 49 ff ff       	call   f010ab6f <calculate_allocated_space>
f01161e0:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01161e3:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01161ea:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01161f1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161f7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01161fa:	74 28                	je     f0116224 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01161fc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116202:	83 ec 0c             	sub    $0xc,%esp
f0116205:	ff 75 c8             	pushl  -0x38(%ebp)
f0116208:	50                   	push   %eax
f0116209:	68 94 ab 12 f0       	push   $0xf012ab94
f011620e:	68 a0 07 00 00       	push   $0x7a0
f0116213:	68 e2 91 12 f0       	push   $0xf01291e2
f0116218:	e8 b9 a2 fe ff       	call   f01004d6 <_warn>
f011621d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116220:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116224:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011622a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011622d:	74 28                	je     f0116257 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011622f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116235:	83 ec 0c             	sub    $0xc,%esp
f0116238:	ff 75 c4             	pushl  -0x3c(%ebp)
f011623b:	50                   	push   %eax
f011623c:	68 f4 ab 12 f0       	push   $0xf012abf4
f0116241:	68 a5 07 00 00       	push   $0x7a5
f0116246:	68 e2 91 12 f0       	push   $0xf01291e2
f011624b:	e8 86 a2 fe ff       	call   f01004d6 <_warn>
f0116250:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116253:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116257:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011625b:	74 04                	je     f0116261 <test_calculate_allocated_space+0x784>
f011625d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116261:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116265:	83 ec 04             	sub    $0x4,%esp
f0116268:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011626e:	50                   	push   %eax
f011626f:	68 5b 99 12 f0       	push   $0xf012995b
f0116274:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011627a:	50                   	push   %eax
f011627b:	e8 81 9f 00 00       	call   f0120201 <strcconcat>
f0116280:	83 c4 10             	add    $0x10,%esp
f0116283:	83 ec 0c             	sub    $0xc,%esp
f0116286:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011628c:	50                   	push   %eax
f011628d:	e8 69 bc fe ff       	call   f0101efb <execute_command>
f0116292:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116295:	83 ec 04             	sub    $0x4,%esp
f0116298:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011629e:	50                   	push   %eax
f011629f:	68 e8 aa 12 f0       	push   $0xf012aae8
f01162a4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01162aa:	50                   	push   %eax
f01162ab:	e8 51 9f 00 00       	call   f0120201 <strcconcat>
f01162b0:	83 c4 10             	add    $0x10,%esp
f01162b3:	83 ec 0c             	sub    $0xc,%esp
f01162b6:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01162bc:	50                   	push   %eax
f01162bd:	e8 39 bc fe ff       	call   f0101efb <execute_command>
f01162c2:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01162c5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162cc:	00 00 00 
		num_pages = 0;
f01162cf:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162d6:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01162d9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01162dc:	c1 e0 03             	shl    $0x3,%eax
f01162df:	89 c2                	mov    %eax,%edx
f01162e1:	83 ec 0c             	sub    $0xc,%esp
f01162e4:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162ea:	50                   	push   %eax
f01162eb:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01162f1:	50                   	push   %eax
f01162f2:	52                   	push   %edx
f01162f3:	6a 00                	push   $0x0
f01162f5:	ff 75 d8             	pushl  -0x28(%ebp)
f01162f8:	e8 72 48 ff ff       	call   f010ab6f <calculate_allocated_space>
f01162fd:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116300:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0116307:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011630e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116314:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116317:	74 28                	je     f0116341 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116319:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011631f:	83 ec 0c             	sub    $0xc,%esp
f0116322:	ff 75 c8             	pushl  -0x38(%ebp)
f0116325:	50                   	push   %eax
f0116326:	68 94 ab 12 f0       	push   $0xf012ab94
f011632b:	68 b6 07 00 00       	push   $0x7b6
f0116330:	68 e2 91 12 f0       	push   $0xf01291e2
f0116335:	e8 9c a1 fe ff       	call   f01004d6 <_warn>
f011633a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011633d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116341:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116347:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011634a:	74 28                	je     f0116374 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011634c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116352:	83 ec 0c             	sub    $0xc,%esp
f0116355:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116358:	50                   	push   %eax
f0116359:	68 f4 ab 12 f0       	push   $0xf012abf4
f011635e:	68 bb 07 00 00       	push   $0x7bb
f0116363:	68 e2 91 12 f0       	push   $0xf01291e2
f0116368:	e8 69 a1 fe ff       	call   f01004d6 <_warn>
f011636d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116370:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116374:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116378:	74 04                	je     f011637e <test_calculate_allocated_space+0x8a1>
f011637a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011637e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116382:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116389:	00 00 00 
		num_pages = 0;
f011638c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116393:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116396:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116399:	c1 e0 0a             	shl    $0xa,%eax
f011639c:	89 c2                	mov    %eax,%edx
f011639e:	83 ec 0c             	sub    $0xc,%esp
f01163a1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163a7:	50                   	push   %eax
f01163a8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163ae:	50                   	push   %eax
f01163af:	52                   	push   %edx
f01163b0:	6a 00                	push   $0x0
f01163b2:	ff 75 d8             	pushl  -0x28(%ebp)
f01163b5:	e8 b5 47 ff ff       	call   f010ab6f <calculate_allocated_space>
f01163ba:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f01163bd:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01163c4:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01163cb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163d1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01163d4:	74 28                	je     f01163fe <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01163d6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163dc:	83 ec 0c             	sub    $0xc,%esp
f01163df:	ff 75 c8             	pushl  -0x38(%ebp)
f01163e2:	50                   	push   %eax
f01163e3:	68 94 ab 12 f0       	push   $0xf012ab94
f01163e8:	68 c9 07 00 00       	push   $0x7c9
f01163ed:	68 e2 91 12 f0       	push   $0xf01291e2
f01163f2:	e8 df a0 fe ff       	call   f01004d6 <_warn>
f01163f7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163fa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01163fe:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116404:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116407:	74 28                	je     f0116431 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116409:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011640f:	83 ec 0c             	sub    $0xc,%esp
f0116412:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116415:	50                   	push   %eax
f0116416:	68 f4 ab 12 f0       	push   $0xf012abf4
f011641b:	68 ce 07 00 00       	push   $0x7ce
f0116420:	68 e2 91 12 f0       	push   $0xf01291e2
f0116425:	e8 ac a0 fe ff       	call   f01004d6 <_warn>
f011642a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011642d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116431:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116435:	74 04                	je     f011643b <test_calculate_allocated_space+0x95e>
f0116437:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011643b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f011643f:	83 ec 04             	sub    $0x4,%esp
f0116442:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116448:	50                   	push   %eax
f0116449:	68 f4 aa 12 f0       	push   $0xf012aaf4
f011644e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116454:	50                   	push   %eax
f0116455:	e8 a7 9d 00 00       	call   f0120201 <strcconcat>
f011645a:	83 c4 10             	add    $0x10,%esp
f011645d:	83 ec 0c             	sub    $0xc,%esp
f0116460:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116466:	50                   	push   %eax
f0116467:	e8 8f ba fe ff       	call   f0101efb <execute_command>
f011646c:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f011646f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116476:	00 00 00 
		num_pages = 0;
f0116479:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116480:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116483:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116486:	89 c2                	mov    %eax,%edx
f0116488:	01 d2                	add    %edx,%edx
f011648a:	01 d0                	add    %edx,%eax
f011648c:	05 00 18 00 00       	add    $0x1800,%eax
f0116491:	89 c2                	mov    %eax,%edx
f0116493:	83 ec 0c             	sub    $0xc,%esp
f0116496:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011649c:	50                   	push   %eax
f011649d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164a3:	50                   	push   %eax
f01164a4:	52                   	push   %edx
f01164a5:	68 00 18 00 00       	push   $0x1800
f01164aa:	ff 75 d8             	pushl  -0x28(%ebp)
f01164ad:	e8 bd 46 ff ff       	call   f010ab6f <calculate_allocated_space>
f01164b2:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01164b5:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01164bc:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01164c3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164c9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01164cc:	74 28                	je     f01164f6 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01164ce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164d4:	83 ec 0c             	sub    $0xc,%esp
f01164d7:	ff 75 c8             	pushl  -0x38(%ebp)
f01164da:	50                   	push   %eax
f01164db:	68 94 ab 12 f0       	push   $0xf012ab94
f01164e0:	68 df 07 00 00       	push   $0x7df
f01164e5:	68 e2 91 12 f0       	push   $0xf01291e2
f01164ea:	e8 e7 9f fe ff       	call   f01004d6 <_warn>
f01164ef:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164f2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01164f6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164fc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01164ff:	74 28                	je     f0116529 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116501:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116507:	83 ec 0c             	sub    $0xc,%esp
f011650a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011650d:	50                   	push   %eax
f011650e:	68 f4 ab 12 f0       	push   $0xf012abf4
f0116513:	68 e4 07 00 00       	push   $0x7e4
f0116518:	68 e2 91 12 f0       	push   $0xf01291e2
f011651d:	e8 b4 9f fe ff       	call   f01004d6 <_warn>
f0116522:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116525:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116529:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011652d:	74 04                	je     f0116533 <test_calculate_allocated_space+0xa56>
f011652f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116533:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116537:	83 ec 04             	sub    $0x4,%esp
f011653a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116540:	50                   	push   %eax
f0116541:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0116546:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011654c:	50                   	push   %eax
f011654d:	e8 af 9c 00 00       	call   f0120201 <strcconcat>
f0116552:	83 c4 10             	add    $0x10,%esp
f0116555:	83 ec 0c             	sub    $0xc,%esp
f0116558:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011655e:	50                   	push   %eax
f011655f:	e8 97 b9 fe ff       	call   f0101efb <execute_command>
f0116564:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116567:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011656e:	00 00 00 
		num_pages = 0;
f0116571:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116578:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f011657b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011657e:	89 d0                	mov    %edx,%eax
f0116580:	c1 e0 02             	shl    $0x2,%eax
f0116583:	01 d0                	add    %edx,%eax
f0116585:	01 c0                	add    %eax,%eax
f0116587:	05 00 00 40 00       	add    $0x400000,%eax
f011658c:	89 c2                	mov    %eax,%edx
f011658e:	83 ec 0c             	sub    $0xc,%esp
f0116591:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116597:	50                   	push   %eax
f0116598:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011659e:	50                   	push   %eax
f011659f:	52                   	push   %edx
f01165a0:	68 00 00 40 00       	push   $0x400000
f01165a5:	ff 75 d8             	pushl  -0x28(%ebp)
f01165a8:	e8 c2 45 ff ff       	call   f010ab6f <calculate_allocated_space>
f01165ad:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01165b0:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01165b7:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01165be:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165c4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01165c7:	74 28                	je     f01165f1 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01165c9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165cf:	83 ec 0c             	sub    $0xc,%esp
f01165d2:	ff 75 c8             	pushl  -0x38(%ebp)
f01165d5:	50                   	push   %eax
f01165d6:	68 94 ab 12 f0       	push   $0xf012ab94
f01165db:	68 f4 07 00 00       	push   $0x7f4
f01165e0:	68 e2 91 12 f0       	push   $0xf01291e2
f01165e5:	e8 ec 9e fe ff       	call   f01004d6 <_warn>
f01165ea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01165f1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01165f7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01165fa:	74 28                	je     f0116624 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01165fc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116602:	83 ec 0c             	sub    $0xc,%esp
f0116605:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116608:	50                   	push   %eax
f0116609:	68 f4 ab 12 f0       	push   $0xf012abf4
f011660e:	68 f9 07 00 00       	push   $0x7f9
f0116613:	68 e2 91 12 f0       	push   $0xf01291e2
f0116618:	e8 b9 9e fe ff       	call   f01004d6 <_warn>
f011661d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116620:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116624:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116628:	74 04                	je     f011662e <test_calculate_allocated_space+0xb51>
f011662a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011662e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116632:	83 ec 04             	sub    $0x4,%esp
f0116635:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011663b:	50                   	push   %eax
f011663c:	68 be 9b 12 f0       	push   $0xf0129bbe
f0116641:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116647:	50                   	push   %eax
f0116648:	e8 b4 9b 00 00       	call   f0120201 <strcconcat>
f011664d:	83 c4 10             	add    $0x10,%esp
f0116650:	83 ec 0c             	sub    $0xc,%esp
f0116653:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116659:	50                   	push   %eax
f011665a:	e8 9c b8 fe ff       	call   f0101efb <execute_command>
f011665f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0116662:	83 ec 04             	sub    $0x4,%esp
f0116665:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011666b:	50                   	push   %eax
f011666c:	68 fc aa 12 f0       	push   $0xf012aafc
f0116671:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116677:	50                   	push   %eax
f0116678:	e8 84 9b 00 00       	call   f0120201 <strcconcat>
f011667d:	83 c4 10             	add    $0x10,%esp
f0116680:	83 ec 0c             	sub    $0xc,%esp
f0116683:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116689:	50                   	push   %eax
f011668a:	e8 6c b8 fe ff       	call   f0101efb <execute_command>
f011668f:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116692:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116699:	00 00 00 
		num_pages = 0;
f011669c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01166a3:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01166a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01166a9:	05 00 00 38 00       	add    $0x380000,%eax
f01166ae:	01 c0                	add    %eax,%eax
f01166b0:	89 c2                	mov    %eax,%edx
f01166b2:	83 ec 0c             	sub    $0xc,%esp
f01166b5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166bb:	50                   	push   %eax
f01166bc:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166c2:	50                   	push   %eax
f01166c3:	52                   	push   %edx
f01166c4:	68 00 00 70 00       	push   $0x700000
f01166c9:	ff 75 d8             	pushl  -0x28(%ebp)
f01166cc:	e8 9e 44 ff ff       	call   f010ab6f <calculate_allocated_space>
f01166d1:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01166d4:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f01166db:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166e2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166e8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166eb:	74 28                	je     f0116715 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166ed:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166f3:	83 ec 0c             	sub    $0xc,%esp
f01166f6:	ff 75 c8             	pushl  -0x38(%ebp)
f01166f9:	50                   	push   %eax
f01166fa:	68 94 ab 12 f0       	push   $0xf012ab94
f01166ff:	68 0b 08 00 00       	push   $0x80b
f0116704:	68 e2 91 12 f0       	push   $0xf01291e2
f0116709:	e8 c8 9d fe ff       	call   f01004d6 <_warn>
f011670e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116711:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116715:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011671b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011671e:	74 28                	je     f0116748 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116720:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116726:	83 ec 0c             	sub    $0xc,%esp
f0116729:	ff 75 c4             	pushl  -0x3c(%ebp)
f011672c:	50                   	push   %eax
f011672d:	68 f4 ab 12 f0       	push   $0xf012abf4
f0116732:	68 10 08 00 00       	push   $0x810
f0116737:	68 e2 91 12 f0       	push   $0xf01291e2
f011673c:	e8 95 9d fe ff       	call   f01004d6 <_warn>
f0116741:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116744:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116748:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011674c:	74 04                	je     f0116752 <test_calculate_allocated_space+0xc75>
f011674e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116752:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116756:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011675d:	00 00 00 
		num_pages = 0;
f0116760:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116767:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011676a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011676d:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116772:	89 c2                	mov    %eax,%edx
f0116774:	83 ec 0c             	sub    $0xc,%esp
f0116777:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011677d:	50                   	push   %eax
f011677e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116784:	50                   	push   %eax
f0116785:	52                   	push   %edx
f0116786:	68 ff ff 3f 00       	push   $0x3fffff
f011678b:	ff 75 d8             	pushl  -0x28(%ebp)
f011678e:	e8 dc 43 ff ff       	call   f010ab6f <calculate_allocated_space>
f0116793:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116796:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f011679d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167a4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167aa:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167ad:	74 28                	je     f01167d7 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167b5:	83 ec 0c             	sub    $0xc,%esp
f01167b8:	ff 75 c8             	pushl  -0x38(%ebp)
f01167bb:	50                   	push   %eax
f01167bc:	68 94 ab 12 f0       	push   $0xf012ab94
f01167c1:	68 1e 08 00 00       	push   $0x81e
f01167c6:	68 e2 91 12 f0       	push   $0xf01291e2
f01167cb:	e8 06 9d fe ff       	call   f01004d6 <_warn>
f01167d0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01167d7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01167dd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01167e0:	74 28                	je     f011680a <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01167e2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01167e8:	83 ec 0c             	sub    $0xc,%esp
f01167eb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01167ee:	50                   	push   %eax
f01167ef:	68 f4 ab 12 f0       	push   $0xf012abf4
f01167f4:	68 23 08 00 00       	push   $0x823
f01167f9:	68 e2 91 12 f0       	push   $0xf01291e2
f01167fe:	e8 d3 9c fe ff       	call   f01004d6 <_warn>
f0116803:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116806:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011680a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011680e:	74 04                	je     f0116814 <test_calculate_allocated_space+0xd37>
f0116810:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116814:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116818:	83 ec 0c             	sub    $0xc,%esp
f011681b:	68 6f 9b 12 f0       	push   $0xf0129b6f
f0116820:	e8 66 a7 fe ff       	call   f0100f8b <cprintf>
f0116825:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116828:	83 ec 08             	sub    $0x8,%esp
f011682b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011682e:	68 50 ac 12 f0       	push   $0xf012ac50
f0116833:	e8 53 a7 fe ff       	call   f0100f8b <cprintf>
f0116838:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011683b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011683f:	75 10                	jne    f0116851 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116841:	83 ec 0c             	sub    $0xc,%esp
f0116844:	68 90 ac 12 f0       	push   $0xf012ac90
f0116849:	e8 3d a7 fe ff       	call   f0100f8b <cprintf>
f011684e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116851:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0116856:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116859:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011685c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011685f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116864:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116867:	5b                   	pop    %ebx
f0116868:	5e                   	pop    %esi
f0116869:	5f                   	pop    %edi
f011686a:	5d                   	pop    %ebp
f011686b:	c3                   	ret    

f011686c <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f011686c:	55                   	push   %ebp
f011686d:	89 e5                	mov    %esp,%ebp
f011686f:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116872:	8b 45 10             	mov    0x10(%ebp),%eax
f0116875:	ba 01 00 00 00       	mov    $0x1,%edx
f011687a:	88 c1                	mov    %al,%cl
f011687c:	d3 e2                	shl    %cl,%edx
f011687e:	89 d0                	mov    %edx,%eax
f0116880:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116883:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116886:	c1 e8 16             	shr    $0x16,%eax
f0116889:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116890:	8b 45 08             	mov    0x8(%ebp),%eax
f0116893:	01 d0                	add    %edx,%eax
f0116895:	8b 00                	mov    (%eax),%eax
f0116897:	83 e0 01             	and    $0x1,%eax
f011689a:	85 c0                	test   %eax,%eax
f011689c:	75 07                	jne    f01168a5 <CB+0x39>
f011689e:	b8 00 00 00 00       	mov    $0x0,%eax
f01168a3:	eb 76                	jmp    f011691b <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01168a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168a8:	c1 e8 16             	shr    $0x16,%eax
f01168ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01168b5:	01 d0                	add    %edx,%eax
f01168b7:	8b 00                	mov    (%eax),%eax
f01168b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01168be:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01168c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01168c4:	c1 e8 0c             	shr    $0xc,%eax
f01168c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01168ca:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01168cf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01168d2:	72 17                	jb     f01168eb <CB+0x7f>
f01168d4:	ff 75 f0             	pushl  -0x10(%ebp)
f01168d7:	68 dc ac 12 f0       	push   $0xf012acdc
f01168dc:	68 3e 08 00 00       	push   $0x83e
f01168e1:	68 e2 91 12 f0       	push   $0xf01291e2
f01168e6:	e8 4e 9a fe ff       	call   f0100339 <_panic>
f01168eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01168ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01168f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f01168f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168f9:	c1 e8 0c             	shr    $0xc,%eax
f01168fc:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116901:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116908:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011690b:	01 d0                	add    %edx,%eax
f011690d:	8b 00                	mov    (%eax),%eax
f011690f:	23 45 f4             	and    -0xc(%ebp),%eax
f0116912:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116915:	0f 94 c0             	sete   %al
f0116918:	0f b6 c0             	movzbl %al,%eax
}
f011691b:	c9                   	leave  
f011691c:	c3                   	ret    

f011691d <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011691d:	55                   	push   %ebp
f011691e:	89 e5                	mov    %esp,%ebp
f0116920:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116923:	68 0b ad 12 f0       	push   $0xf012ad0b
f0116928:	68 1a ad 12 f0       	push   $0xf012ad1a
f011692d:	68 43 08 00 00       	push   $0x843
f0116932:	68 e2 91 12 f0       	push   $0xf01291e2
f0116937:	e8 fd 99 fe ff       	call   f0100339 <_panic>

f011693c <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f011693c:	55                   	push   %ebp
f011693d:	89 e5                	mov    %esp,%ebp
f011693f:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116942:	68 0b ad 12 f0       	push   $0xf012ad0b
f0116947:	68 1a ad 12 f0       	push   $0xf012ad1a
f011694c:	68 4d 08 00 00       	push   $0x84d
f0116951:	68 e2 91 12 f0       	push   $0xf01291e2
f0116956:	e8 de 99 fe ff       	call   f0100339 <_panic>

f011695b <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f011695b:	55                   	push   %ebp
f011695c:	89 e5                	mov    %esp,%ebp
f011695e:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116961:	68 0b ad 12 f0       	push   $0xf012ad0b
f0116966:	68 1a ad 12 f0       	push   $0xf012ad1a
f011696b:	68 5c 08 00 00       	push   $0x85c
f0116970:	68 e2 91 12 f0       	push   $0xf01291e2
f0116975:	e8 bf 99 fe ff       	call   f0100339 <_panic>

f011697a <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f011697a:	55                   	push   %ebp
f011697b:	89 e5                	mov    %esp,%ebp
f011697d:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116980:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116983:	c1 e8 16             	shr    $0x16,%eax
f0116986:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011698d:	8b 45 08             	mov    0x8(%ebp),%eax
f0116990:	01 d0                	add    %edx,%eax
f0116992:	8b 00                	mov    (%eax),%eax
f0116994:	83 e0 01             	and    $0x1,%eax
f0116997:	85 c0                	test   %eax,%eax
f0116999:	75 07                	jne    f01169a2 <CE+0x28>
f011699b:	b8 00 00 00 00       	mov    $0x0,%eax
f01169a0:	eb 7a                	jmp    f0116a1c <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01169a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169a5:	c1 e8 16             	shr    $0x16,%eax
f01169a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169af:	8b 45 08             	mov    0x8(%ebp),%eax
f01169b2:	01 d0                	add    %edx,%eax
f01169b4:	8b 00                	mov    (%eax),%eax
f01169b6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01169bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01169be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169c1:	c1 e8 0c             	shr    $0xc,%eax
f01169c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01169c7:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01169cc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01169cf:	72 17                	jb     f01169e8 <CE+0x6e>
f01169d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01169d4:	68 dc ac 12 f0       	push   $0xf012acdc
f01169d9:	68 65 08 00 00       	push   $0x865
f01169de:	68 e2 91 12 f0       	push   $0xf01291e2
f01169e3:	e8 51 99 fe ff       	call   f0100339 <_panic>
f01169e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169eb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01169f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f01169f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169f6:	c1 e8 0c             	shr    $0xc,%eax
f01169f9:	25 ff 03 00 00       	and    $0x3ff,%eax
f01169fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a05:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a08:	01 d0                	add    %edx,%eax
f0116a0a:	8b 00                	mov    (%eax),%eax
f0116a0c:	85 c0                	test   %eax,%eax
f0116a0e:	74 07                	je     f0116a17 <CE+0x9d>
f0116a10:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a15:	eb 05                	jmp    f0116a1c <CE+0xa2>
	return 1;
f0116a17:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116a1c:	c9                   	leave  
f0116a1d:	c3                   	ret    

f0116a1e <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116a1e:	55                   	push   %ebp
f0116a1f:	89 e5                	mov    %esp,%ebp
f0116a21:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116a24:	68 0b ad 12 f0       	push   $0xf012ad0b
f0116a29:	68 1a ad 12 f0       	push   $0xf012ad1a
f0116a2e:	68 6c 08 00 00       	push   $0x86c
f0116a33:	68 e2 91 12 f0       	push   $0xf01291e2
f0116a38:	e8 fc 98 fe ff       	call   f0100339 <_panic>

f0116a3d <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116a3d:	55                   	push   %ebp
f0116a3e:	89 e5                	mov    %esp,%ebp
f0116a40:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116a43:	68 0b ad 12 f0       	push   $0xf012ad0b
f0116a48:	68 1a ad 12 f0       	push   $0xf012ad1a
f0116a4d:	68 7c 08 00 00       	push   $0x87c
f0116a52:	68 e2 91 12 f0       	push   $0xf01291e2
f0116a57:	e8 dd 98 fe ff       	call   f0100339 <_panic>

f0116a5c <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116a5c:	55                   	push   %ebp
f0116a5d:	89 e5                	mov    %esp,%ebp
f0116a5f:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116a62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116a69:	eb 18                	jmp    f0116a83 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116a6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116a6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a75:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a78:	01 d0                	add    %edx,%eax
f0116a7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116a80:	ff 45 fc             	incl   -0x4(%ebp)
f0116a83:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116a86:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116a8b:	76 de                	jbe    f0116a6b <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116a8d:	90                   	nop
f0116a8e:	c9                   	leave  
f0116a8f:	c3                   	ret    

f0116a90 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116a90:	55                   	push   %ebp
f0116a91:	89 e5                	mov    %esp,%ebp
f0116a93:	83 ec 38             	sub    $0x38,%esp
f0116a96:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116a99:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116aa7:	8b 45 10             	mov    0x10(%ebp),%eax
f0116aaa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116ab2:	e9 ea 01 00 00       	jmp    f0116ca1 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116ab7:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116abb:	74 44                	je     f0116b01 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ac0:	83 ec 04             	sub    $0x4,%esp
f0116ac3:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116ac6:	52                   	push   %edx
f0116ac7:	50                   	push   %eax
f0116ac8:	ff 75 08             	pushl  0x8(%ebp)
f0116acb:	e8 99 1c ff ff       	call   f0108769 <get_frame_info>
f0116ad0:	83 c4 10             	add    $0x10,%esp
f0116ad3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116ad6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ad9:	85 c0                	test   %eax,%eax
f0116adb:	75 24                	jne    f0116b01 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116add:	83 ec 04             	sub    $0x4,%esp
f0116ae0:	68 30 ad 12 f0       	push   $0xf012ad30
f0116ae5:	68 99 08 00 00       	push   $0x899
f0116aea:	68 e2 91 12 f0       	push   $0xf01291e2
f0116aef:	e8 e2 99 fe ff       	call   f01004d6 <_warn>
f0116af4:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116af7:	b8 00 00 00 00       	mov    $0x0,%eax
f0116afc:	e9 b6 01 00 00       	jmp    f0116cb7 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116b04:	83 ec 04             	sub    $0x4,%esp
f0116b07:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116b0a:	52                   	push   %edx
f0116b0b:	50                   	push   %eax
f0116b0c:	ff 75 08             	pushl  0x8(%ebp)
f0116b0f:	e8 55 1c ff ff       	call   f0108769 <get_frame_info>
f0116b14:	83 c4 10             	add    $0x10,%esp
f0116b17:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116b1a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116b1d:	85 c0                	test   %eax,%eax
f0116b1f:	75 24                	jne    f0116b45 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116b21:	83 ec 04             	sub    $0x4,%esp
f0116b24:	68 5c ad 12 f0       	push   $0xf012ad5c
f0116b29:	68 a0 08 00 00       	push   $0x8a0
f0116b2e:	68 e2 91 12 f0       	push   $0xf01291e2
f0116b33:	e8 9e 99 fe ff       	call   f01004d6 <_warn>
f0116b38:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b40:	e9 72 01 00 00       	jmp    f0116cb7 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116b45:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116b49:	75 70                	jne    f0116bbb <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116b4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116b4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116b51:	c1 ea 0c             	shr    $0xc,%edx
f0116b54:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116b5a:	c1 e2 02             	shl    $0x2,%edx
f0116b5d:	01 d0                	add    %edx,%eax
f0116b5f:	8b 00                	mov    (%eax),%eax
f0116b61:	c1 e8 0c             	shr    $0xc,%eax
f0116b64:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116b67:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116b6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116b6d:	c1 ea 0c             	shr    $0xc,%edx
f0116b70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116b76:	c1 e2 02             	shl    $0x2,%edx
f0116b79:	01 d0                	add    %edx,%eax
f0116b7b:	8b 00                	mov    (%eax),%eax
f0116b7d:	c1 e8 0c             	shr    $0xc,%eax
f0116b80:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116b86:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116b89:	74 30                	je     f0116bbb <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116b8b:	83 ec 04             	sub    $0x4,%esp
f0116b8e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116b91:	ff 75 e8             	pushl  -0x18(%ebp)
f0116b94:	ff 75 f0             	pushl  -0x10(%ebp)
f0116b97:	ff 75 f4             	pushl  -0xc(%ebp)
f0116b9a:	68 88 ad 12 f0       	push   $0xf012ad88
f0116b9f:	68 aa 08 00 00       	push   $0x8aa
f0116ba4:	68 e2 91 12 f0       	push   $0xf01291e2
f0116ba9:	e8 28 99 fe ff       	call   f01004d6 <_warn>
f0116bae:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116bb1:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bb6:	e9 fc 00 00 00       	jmp    f0116cb7 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116bbb:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116bbf:	74 52                	je     f0116c13 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116bc1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116bc5:	74 0e                	je     f0116bd5 <CCP+0x145>
f0116bc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116bca:	8b 40 08             	mov    0x8(%eax),%eax
f0116bcd:	0f b7 c0             	movzwl %ax,%eax
f0116bd0:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116bd3:	74 3e                	je     f0116c13 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116bd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116bd9:	74 0b                	je     f0116be6 <CCP+0x156>
f0116bdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116bde:	8b 40 08             	mov    0x8(%eax),%eax
f0116be1:	0f b7 c0             	movzwl %ax,%eax
f0116be4:	eb 05                	jmp    f0116beb <CCP+0x15b>
f0116be6:	b8 00 00 00 00       	mov    $0x0,%eax
f0116beb:	83 ec 0c             	sub    $0xc,%esp
f0116bee:	50                   	push   %eax
f0116bef:	ff 75 f0             	pushl  -0x10(%ebp)
f0116bf2:	68 e4 ad 12 f0       	push   $0xf012ade4
f0116bf7:	68 b2 08 00 00       	push   $0x8b2
f0116bfc:	68 e2 91 12 f0       	push   $0xf01291e2
f0116c01:	e8 d0 98 fe ff       	call   f01004d6 <_warn>
f0116c06:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116c09:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c0e:	e9 a4 00 00 00       	jmp    f0116cb7 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116c16:	ff 75 20             	pushl  0x20(%ebp)
f0116c19:	ff 75 1c             	pushl  0x1c(%ebp)
f0116c1c:	50                   	push   %eax
f0116c1d:	ff 75 08             	pushl  0x8(%ebp)
f0116c20:	e8 17 fd ff ff       	call   f011693c <CPs>
f0116c25:	83 c4 10             	add    $0x10,%esp
f0116c28:	85 c0                	test   %eax,%eax
f0116c2a:	7f 21                	jg     f0116c4d <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116c2c:	83 ec 04             	sub    $0x4,%esp
f0116c2f:	68 54 ae 12 f0       	push   $0xf012ae54
f0116c34:	68 b8 08 00 00       	push   $0x8b8
f0116c39:	68 e2 91 12 f0       	push   $0xf01291e2
f0116c3e:	e8 93 98 fe ff       	call   f01004d6 <_warn>
f0116c43:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116c46:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c4b:	eb 6a                	jmp    f0116cb7 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116c4d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116c51:	74 3a                	je     f0116c8d <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116c56:	ff 75 28             	pushl  0x28(%ebp)
f0116c59:	ff 75 24             	pushl  0x24(%ebp)
f0116c5c:	50                   	push   %eax
f0116c5d:	ff 75 08             	pushl  0x8(%ebp)
f0116c60:	e8 d7 fc ff ff       	call   f011693c <CPs>
f0116c65:	83 c4 10             	add    $0x10,%esp
f0116c68:	85 c0                	test   %eax,%eax
f0116c6a:	7f 21                	jg     f0116c8d <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116c6c:	83 ec 04             	sub    $0x4,%esp
f0116c6f:	68 9c ae 12 f0       	push   $0xf012ae9c
f0116c74:	68 bf 08 00 00       	push   $0x8bf
f0116c79:	68 e2 91 12 f0       	push   $0xf01291e2
f0116c7e:	e8 53 98 fe ff       	call   f01004d6 <_warn>
f0116c83:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116c86:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c8b:	eb 2a                	jmp    f0116cb7 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116c8d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116c91:	74 07                	je     f0116c9a <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116c93:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116c9a:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116ca1:	8b 55 10             	mov    0x10(%ebp),%edx
f0116ca4:	8b 45 14             	mov    0x14(%ebp),%eax
f0116ca7:	01 d0                	add    %edx,%eax
f0116ca9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116cac:	0f 87 05 fe ff ff    	ja     f0116ab7 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116cb2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116cb7:	c9                   	leave  
f0116cb8:	c3                   	ret    

f0116cb9 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116cb9:	55                   	push   %ebp
f0116cba:	89 e5                	mov    %esp,%ebp
f0116cbc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116cbf:	83 ec 04             	sub    $0x4,%esp
f0116cc2:	68 dc ae 12 f0       	push   $0xf012aedc
f0116cc7:	6a 0e                	push   $0xe
f0116cc9:	68 ec ae 12 f0       	push   $0xf012aeec
f0116cce:	e8 66 96 fe ff       	call   f0100339 <_panic>

f0116cd3 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116cd3:	55                   	push   %ebp
f0116cd4:	89 e5                	mov    %esp,%ebp
f0116cd6:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116cd9:	83 ec 04             	sub    $0x4,%esp
f0116cdc:	68 dc ae 12 f0       	push   $0xf012aedc
f0116ce1:	68 d7 00 00 00       	push   $0xd7
f0116ce6:	68 ec ae 12 f0       	push   $0xf012aeec
f0116ceb:	e8 49 96 fe ff       	call   f0100339 <_panic>

f0116cf0 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116cf0:	55                   	push   %ebp
f0116cf1:	89 e5                	mov    %esp,%ebp
f0116cf3:	57                   	push   %edi
f0116cf4:	53                   	push   %ebx
f0116cf5:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116cfb:	83 ec 0c             	sub    $0xc,%esp
f0116cfe:	68 08 af 12 f0       	push   $0xf012af08
f0116d03:	e8 83 a2 fe ff       	call   f0100f8b <cprintf>
f0116d08:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116d0b:	83 ec 0c             	sub    $0xc,%esp
f0116d0e:	68 38 af 12 f0       	push   $0xf012af38
f0116d13:	e8 73 a2 fe ff       	call   f0100f8b <cprintf>
f0116d18:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116d1b:	83 ec 0c             	sub    $0xc,%esp
f0116d1e:	68 08 af 12 f0       	push   $0xf012af08
f0116d23:	e8 63 a2 fe ff       	call   f0100f8b <cprintf>
f0116d28:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0116d2b:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116d2f:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116d33:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0116d39:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116d3f:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116d46:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116d4d:	e8 16 7c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116d52:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116d55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116d5c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0116d63:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0116d69:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116d6e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d73:	89 d7                	mov    %edx,%edi
f0116d75:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0116d77:	83 ec 0c             	sub    $0xc,%esp
f0116d7a:	68 91 af 12 f0       	push   $0xf012af91
f0116d7f:	e8 07 a2 fe ff       	call   f0100f8b <cprintf>
f0116d84:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116d87:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d8e:	e8 d5 7b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116d93:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d96:	e8 0a db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116d9b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0116d9e:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116da5:	83 ec 0c             	sub    $0xc,%esp
f0116da8:	ff 75 cc             	pushl  -0x34(%ebp)
f0116dab:	e8 5e 27 ff ff       	call   f010950e <kmalloc>
f0116db0:	83 c4 10             	add    $0x10,%esp
f0116db3:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0116db9:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116dbf:	85 c0                	test   %eax,%eax
f0116dc1:	74 17                	je     f0116dda <test_kmalloc+0xea>
f0116dc3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116dca:	83 ec 0c             	sub    $0xc,%esp
f0116dcd:	68 b0 af 12 f0       	push   $0xf012afb0
f0116dd2:	e8 b4 a1 fe ff       	call   f0100f8b <cprintf>
f0116dd7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116dda:	e8 c6 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116ddf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116de2:	74 17                	je     f0116dfb <test_kmalloc+0x10b>
f0116de4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116deb:	83 ec 0c             	sub    $0xc,%esp
f0116dee:	68 e4 af 12 f0       	push   $0xf012afe4
f0116df3:	e8 93 a1 fe ff       	call   f0100f8b <cprintf>
f0116df8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116dfb:	e8 68 7b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116e00:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116e03:	74 17                	je     f0116e1c <test_kmalloc+0x12c>
f0116e05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e0c:	83 ec 0c             	sub    $0xc,%esp
f0116e0f:	68 50 b0 12 f0       	push   $0xf012b050
f0116e14:	e8 72 a1 fe ff       	call   f0100f8b <cprintf>
f0116e19:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116e1c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116e20:	74 04                	je     f0116e26 <test_kmalloc+0x136>
f0116e22:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116e26:	83 ec 0c             	sub    $0xc,%esp
f0116e29:	68 94 b0 12 f0       	push   $0xf012b094
f0116e2e:	e8 58 a1 fe ff       	call   f0100f8b <cprintf>
f0116e33:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116e36:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e3d:	e8 26 7b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116e42:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e45:	e8 5b da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e4a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116e4d:	83 ec 0c             	sub    $0xc,%esp
f0116e50:	68 00 fc 1f 00       	push   $0x1ffc00
f0116e55:	e8 b4 26 ff ff       	call   f010950e <kmalloc>
f0116e5a:	83 c4 10             	add    $0x10,%esp
f0116e5d:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116e63:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116e69:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116e6e:	74 17                	je     f0116e87 <test_kmalloc+0x197>
f0116e70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e77:	83 ec 0c             	sub    $0xc,%esp
f0116e7a:	68 d8 b0 12 f0       	push   $0xf012b0d8
f0116e7f:	e8 07 a1 fe ff       	call   f0100f8b <cprintf>
f0116e84:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e87:	e8 19 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e8c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116e8f:	74 17                	je     f0116ea8 <test_kmalloc+0x1b8>
f0116e91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e98:	83 ec 0c             	sub    $0xc,%esp
f0116e9b:	68 2c b1 12 f0       	push   $0xf012b12c
f0116ea0:	e8 e6 a0 fe ff       	call   f0100f8b <cprintf>
f0116ea5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116ea8:	e8 bb 7a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116ead:	89 c2                	mov    %eax,%edx
f0116eaf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116eb2:	29 d0                	sub    %edx,%eax
f0116eb4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116eb9:	7f 17                	jg     f0116ed2 <test_kmalloc+0x1e2>
f0116ebb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ec2:	83 ec 0c             	sub    $0xc,%esp
f0116ec5:	68 98 b1 12 f0       	push   $0xf012b198
f0116eca:	e8 bc a0 fe ff       	call   f0100f8b <cprintf>
f0116ecf:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ed2:	e8 91 7a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116ed7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116eda:	e8 c6 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116edf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116ee2:	83 ec 0c             	sub    $0xc,%esp
f0116ee5:	68 00 fc 1f 00       	push   $0x1ffc00
f0116eea:	e8 1f 26 ff ff       	call   f010950e <kmalloc>
f0116eef:	83 c4 10             	add    $0x10,%esp
f0116ef2:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116ef8:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116efe:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116f03:	74 17                	je     f0116f1c <test_kmalloc+0x22c>
f0116f05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f0c:	83 ec 0c             	sub    $0xc,%esp
f0116f0f:	68 dc b1 12 f0       	push   $0xf012b1dc
f0116f14:	e8 72 a0 fe ff       	call   f0100f8b <cprintf>
f0116f19:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f1c:	e8 84 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f21:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116f24:	74 17                	je     f0116f3d <test_kmalloc+0x24d>
f0116f26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f2d:	83 ec 0c             	sub    $0xc,%esp
f0116f30:	68 30 b2 12 f0       	push   $0xf012b230
f0116f35:	e8 51 a0 fe ff       	call   f0100f8b <cprintf>
f0116f3a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116f3d:	e8 26 7a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116f42:	89 c2                	mov    %eax,%edx
f0116f44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116f47:	29 d0                	sub    %edx,%eax
f0116f49:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116f4e:	7f 17                	jg     f0116f67 <test_kmalloc+0x277>
f0116f50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f57:	83 ec 0c             	sub    $0xc,%esp
f0116f5a:	68 9c b2 12 f0       	push   $0xf012b29c
f0116f5f:	e8 27 a0 fe ff       	call   f0100f8b <cprintf>
f0116f64:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0116f67:	e8 fc 79 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0116f6c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f6f:	e8 31 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f74:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0116f77:	83 ec 0c             	sub    $0xc,%esp
f0116f7a:	68 ff 07 00 00       	push   $0x7ff
f0116f7f:	e8 8a 25 ff ff       	call   f010950e <kmalloc>
f0116f84:	83 c4 10             	add    $0x10,%esp
f0116f87:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0116f8d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116f93:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116f98:	76 28                	jbe    f0116fc2 <test_kmalloc+0x2d2>
f0116f9a:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0116fa0:	83 ec 0c             	sub    $0xc,%esp
f0116fa3:	6a 00                	push   $0x0
f0116fa5:	e8 31 24 ff ff       	call   f01093db <sbrk>
f0116faa:	83 c4 10             	add    $0x10,%esp
f0116fad:	39 c3                	cmp    %eax,%ebx
f0116faf:	73 11                	jae    f0116fc2 <test_kmalloc+0x2d2>
f0116fb1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116fb7:	89 c2                	mov    %eax,%edx
f0116fb9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0116fbe:	39 c2                	cmp    %eax,%edx
f0116fc0:	72 17                	jb     f0116fd9 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116fc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fc9:	83 ec 0c             	sub    $0xc,%esp
f0116fcc:	68 e0 b2 12 f0       	push   $0xf012b2e0
f0116fd1:	e8 b5 9f fe ff       	call   f0100f8b <cprintf>
f0116fd6:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116fd9:	e8 c7 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116fde:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116fe1:	74 17                	je     f0116ffa <test_kmalloc+0x30a>
f0116fe3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fea:	83 ec 0c             	sub    $0xc,%esp
f0116fed:	68 6c b3 12 f0       	push   $0xf012b36c
f0116ff2:	e8 94 9f fe ff       	call   f0100f8b <cprintf>
f0116ff7:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ffa:	e8 a6 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116fff:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0117002:	83 ec 0c             	sub    $0xc,%esp
f0117005:	68 ff 07 00 00       	push   $0x7ff
f011700a:	e8 ff 24 ff ff       	call   f010950e <kmalloc>
f011700f:	83 c4 10             	add    $0x10,%esp
f0117012:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0117018:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011701e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117023:	76 28                	jbe    f011704d <test_kmalloc+0x35d>
f0117025:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011702b:	83 ec 0c             	sub    $0xc,%esp
f011702e:	6a 00                	push   $0x0
f0117030:	e8 a6 23 ff ff       	call   f01093db <sbrk>
f0117035:	83 c4 10             	add    $0x10,%esp
f0117038:	39 c3                	cmp    %eax,%ebx
f011703a:	73 11                	jae    f011704d <test_kmalloc+0x35d>
f011703c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117042:	89 c2                	mov    %eax,%edx
f0117044:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0117049:	39 c2                	cmp    %eax,%edx
f011704b:	72 17                	jb     f0117064 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011704d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117054:	83 ec 0c             	sub    $0xc,%esp
f0117057:	68 d8 b3 12 f0       	push   $0xf012b3d8
f011705c:	e8 2a 9f fe ff       	call   f0100f8b <cprintf>
f0117061:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117064:	e8 3c d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117069:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011706c:	74 17                	je     f0117085 <test_kmalloc+0x395>
f011706e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117075:	83 ec 0c             	sub    $0xc,%esp
f0117078:	68 64 b4 12 f0       	push   $0xf012b464
f011707d:	e8 09 9f fe ff       	call   f0100f8b <cprintf>
f0117082:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0117085:	e8 de 78 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011708a:	89 c2                	mov    %eax,%edx
f011708c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011708f:	29 d0                	sub    %edx,%eax
f0117091:	83 f8 01             	cmp    $0x1,%eax
f0117094:	74 17                	je     f01170ad <test_kmalloc+0x3bd>
f0117096:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011709d:	83 ec 0c             	sub    $0xc,%esp
f01170a0:	68 d0 b4 12 f0       	push   $0xf012b4d0
f01170a5:	e8 e1 9e fe ff       	call   f0100f8b <cprintf>
f01170aa:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01170ad:	e8 b6 78 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01170b2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01170b5:	e8 eb d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f01170bd:	83 ec 0c             	sub    $0xc,%esp
f01170c0:	68 00 1c 00 00       	push   $0x1c00
f01170c5:	e8 44 24 ff ff       	call   f010950e <kmalloc>
f01170ca:	83 c4 10             	add    $0x10,%esp
f01170cd:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01170d3:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01170d9:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01170de:	74 17                	je     f01170f7 <test_kmalloc+0x407>
f01170e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170e7:	83 ec 0c             	sub    $0xc,%esp
f01170ea:	68 f0 b4 12 f0       	push   $0xf012b4f0
f01170ef:	e8 97 9e fe ff       	call   f0100f8b <cprintf>
f01170f4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170f7:	e8 a9 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170fc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170ff:	74 17                	je     f0117118 <test_kmalloc+0x428>
f0117101:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117108:	83 ec 0c             	sub    $0xc,%esp
f011710b:	68 44 b5 12 f0       	push   $0xf012b544
f0117110:	e8 76 9e fe ff       	call   f0100f8b <cprintf>
f0117115:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117118:	e8 4b 78 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011711d:	89 c2                	mov    %eax,%edx
f011711f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117122:	29 d0                	sub    %edx,%eax
f0117124:	83 f8 01             	cmp    $0x1,%eax
f0117127:	7f 17                	jg     f0117140 <test_kmalloc+0x450>
f0117129:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117130:	83 ec 0c             	sub    $0xc,%esp
f0117133:	68 b0 b5 12 f0       	push   $0xf012b5b0
f0117138:	e8 4e 9e fe ff       	call   f0100f8b <cprintf>
f011713d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117140:	e8 23 78 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117145:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117148:	e8 58 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011714d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0117150:	83 ec 0c             	sub    $0xc,%esp
f0117153:	68 00 fc 2f 00       	push   $0x2ffc00
f0117158:	e8 b1 23 ff ff       	call   f010950e <kmalloc>
f011715d:	83 c4 10             	add    $0x10,%esp
f0117160:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117166:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011716c:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117171:	74 17                	je     f011718a <test_kmalloc+0x49a>
f0117173:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011717a:	83 ec 0c             	sub    $0xc,%esp
f011717d:	68 f4 b5 12 f0       	push   $0xf012b5f4
f0117182:	e8 04 9e fe ff       	call   f0100f8b <cprintf>
f0117187:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011718a:	e8 16 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011718f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117192:	74 17                	je     f01171ab <test_kmalloc+0x4bb>
f0117194:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011719b:	83 ec 0c             	sub    $0xc,%esp
f011719e:	68 48 b6 12 f0       	push   $0xf012b648
f01171a3:	e8 e3 9d fe ff       	call   f0100f8b <cprintf>
f01171a8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01171ab:	e8 b8 77 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01171b0:	89 c2                	mov    %eax,%edx
f01171b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01171b5:	29 d0                	sub    %edx,%eax
f01171b7:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01171bc:	7f 17                	jg     f01171d5 <test_kmalloc+0x4e5>
f01171be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171c5:	83 ec 0c             	sub    $0xc,%esp
f01171c8:	68 b4 b6 12 f0       	push   $0xf012b6b4
f01171cd:	e8 b9 9d fe ff       	call   f0100f8b <cprintf>
f01171d2:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171d5:	e8 8e 77 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01171da:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171dd:	e8 c3 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01171e5:	83 ec 0c             	sub    $0xc,%esp
f01171e8:	68 00 fc 5f 00       	push   $0x5ffc00
f01171ed:	e8 1c 23 ff ff       	call   f010950e <kmalloc>
f01171f2:	83 c4 10             	add    $0x10,%esp
f01171f5:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01171fb:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117201:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0117206:	74 17                	je     f011721f <test_kmalloc+0x52f>
f0117208:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011720f:	83 ec 0c             	sub    $0xc,%esp
f0117212:	68 f8 b6 12 f0       	push   $0xf012b6f8
f0117217:	e8 6f 9d fe ff       	call   f0100f8b <cprintf>
f011721c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011721f:	e8 81 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117224:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117227:	74 17                	je     f0117240 <test_kmalloc+0x550>
f0117229:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117230:	83 ec 0c             	sub    $0xc,%esp
f0117233:	68 4c b7 12 f0       	push   $0xf012b74c
f0117238:	e8 4e 9d fe ff       	call   f0100f8b <cprintf>
f011723d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117240:	e8 23 77 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117245:	89 c2                	mov    %eax,%edx
f0117247:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011724a:	29 d0                	sub    %edx,%eax
f011724c:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0117251:	7f 17                	jg     f011726a <test_kmalloc+0x57a>
f0117253:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011725a:	83 ec 0c             	sub    $0xc,%esp
f011725d:	68 b8 b7 12 f0       	push   $0xf012b7b8
f0117262:	e8 24 9d fe ff       	call   f0100f8b <cprintf>
f0117267:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011726a:	e8 f9 76 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011726f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117272:	e8 2e d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117277:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f011727a:	83 ec 0c             	sub    $0xc,%esp
f011727d:	68 00 38 00 00       	push   $0x3800
f0117282:	e8 87 22 ff ff       	call   f010950e <kmalloc>
f0117287:	83 c4 10             	add    $0x10,%esp
f011728a:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117290:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117296:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011729b:	74 17                	je     f01172b4 <test_kmalloc+0x5c4>
f011729d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172a4:	83 ec 0c             	sub    $0xc,%esp
f01172a7:	68 fc b7 12 f0       	push   $0xf012b7fc
f01172ac:	e8 da 9c fe ff       	call   f0100f8b <cprintf>
f01172b1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172b4:	e8 ec d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172b9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01172bc:	74 17                	je     f01172d5 <test_kmalloc+0x5e5>
f01172be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172c5:	83 ec 0c             	sub    $0xc,%esp
f01172c8:	68 50 b8 12 f0       	push   $0xf012b850
f01172cd:	e8 b9 9c fe ff       	call   f0100f8b <cprintf>
f01172d2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01172d5:	e8 8e 76 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01172da:	89 c2                	mov    %eax,%edx
f01172dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01172df:	29 d0                	sub    %edx,%eax
f01172e1:	83 f8 03             	cmp    $0x3,%eax
f01172e4:	7f 17                	jg     f01172fd <test_kmalloc+0x60d>
f01172e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ed:	83 ec 0c             	sub    $0xc,%esp
f01172f0:	68 bc b8 12 f0       	push   $0xf012b8bc
f01172f5:	e8 91 9c fe ff       	call   f0100f8b <cprintf>
f01172fa:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01172fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117301:	74 04                	je     f0117307 <test_kmalloc+0x617>
f0117303:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117307:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f011730e:	83 ec 0c             	sub    $0xc,%esp
f0117311:	68 00 b9 12 f0       	push   $0xf012b900
f0117316:	e8 70 9c fe ff       	call   f0100f8b <cprintf>
f011731b:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011731e:	e8 45 76 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117323:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117326:	e8 7a d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011732b:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f011732e:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0117335:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011733b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f011733e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117341:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117344:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0117346:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117349:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011734c:	01 c2                	add    %eax,%edx
f011734e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117351:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0117353:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117359:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f011735c:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0117363:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117366:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117369:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f011736c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011736f:	01 c0                	add    %eax,%eax
f0117371:	89 c2                	mov    %eax,%edx
f0117373:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117376:	01 c2                	add    %eax,%edx
f0117378:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011737c:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011737f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117385:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0117388:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011738f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117392:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117395:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0117397:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011739a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01173a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01173a4:	01 c2                	add    %eax,%edx
f01173a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01173a9:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f01173ab:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01173b1:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f01173b4:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f01173bb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01173be:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01173c1:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f01173c3:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01173c6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01173c9:	01 c2                	add    %eax,%edx
f01173cb:	8a 45 ea             	mov    -0x16(%ebp),%al
f01173ce:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f01173d0:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01173d6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f01173d9:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f01173e0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173e3:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01173e6:	88 10                	mov    %dl,(%eax)
f01173e8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01173eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01173ee:	66 89 42 02          	mov    %ax,0x2(%edx)
f01173f2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01173f8:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01173fb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173fe:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117405:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117408:	01 c2                	add    %eax,%edx
f011740a:	8a 45 ea             	mov    -0x16(%ebp),%al
f011740d:	88 02                	mov    %al,(%edx)
f011740f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117412:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117419:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011741c:	01 c2                	add    %eax,%edx
f011741e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117422:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117426:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117429:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117430:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117433:	01 c2                	add    %eax,%edx
f0117435:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117438:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f011743b:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0117442:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117448:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f011744b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011744e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117451:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0117453:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117456:	89 c2                	mov    %eax,%edx
f0117458:	c1 ea 1f             	shr    $0x1f,%edx
f011745b:	01 d0                	add    %edx,%eax
f011745d:	d1 f8                	sar    %eax
f011745f:	89 c2                	mov    %eax,%edx
f0117461:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117464:	01 c2                	add    %eax,%edx
f0117466:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117469:	88 c1                	mov    %al,%cl
f011746b:	c0 e9 07             	shr    $0x7,%cl
f011746e:	01 c8                	add    %ecx,%eax
f0117470:	d0 f8                	sar    %al
f0117472:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0117474:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117477:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011747a:	01 c2                	add    %eax,%edx
f011747c:	8a 45 ea             	mov    -0x16(%ebp),%al
f011747f:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0117481:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117487:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f011748a:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0117491:	8b 55 98             	mov    -0x68(%ebp),%edx
f0117494:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117497:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f011749a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011749d:	01 c0                	add    %eax,%eax
f011749f:	89 c2                	mov    %eax,%edx
f01174a1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01174a4:	01 c2                	add    %eax,%edx
f01174a6:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01174aa:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f01174ad:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01174b0:	8a 00                	mov    (%eax),%al
f01174b2:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01174b5:	75 0f                	jne    f01174c6 <test_kmalloc+0x7d6>
f01174b7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01174ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01174bd:	01 d0                	add    %edx,%eax
f01174bf:	8a 00                	mov    (%eax),%al
f01174c1:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01174c4:	74 17                	je     f01174dd <test_kmalloc+0x7ed>
f01174c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174cd:	83 ec 0c             	sub    $0xc,%esp
f01174d0:	68 38 b9 12 f0       	push   $0xf012b938
f01174d5:	e8 b1 9a fe ff       	call   f0100f8b <cprintf>
f01174da:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f01174dd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01174e0:	66 8b 00             	mov    (%eax),%ax
f01174e3:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01174e7:	75 15                	jne    f01174fe <test_kmalloc+0x80e>
f01174e9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01174ec:	01 c0                	add    %eax,%eax
f01174ee:	89 c2                	mov    %eax,%edx
f01174f0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01174f3:	01 d0                	add    %edx,%eax
f01174f5:	66 8b 00             	mov    (%eax),%ax
f01174f8:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01174fc:	74 17                	je     f0117515 <test_kmalloc+0x825>
f01174fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117505:	83 ec 0c             	sub    $0xc,%esp
f0117508:	68 70 b9 12 f0       	push   $0xf012b970
f011750d:	e8 79 9a fe ff       	call   f0100f8b <cprintf>
f0117512:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0117515:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117518:	8b 00                	mov    (%eax),%eax
f011751a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011751d:	75 16                	jne    f0117535 <test_kmalloc+0x845>
f011751f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117522:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117529:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011752c:	01 d0                	add    %edx,%eax
f011752e:	8b 00                	mov    (%eax),%eax
f0117530:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117533:	74 17                	je     f011754c <test_kmalloc+0x85c>
f0117535:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011753c:	83 ec 0c             	sub    $0xc,%esp
f011753f:	68 ac b9 12 f0       	push   $0xf012b9ac
f0117544:	e8 42 9a fe ff       	call   f0100f8b <cprintf>
f0117549:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f011754c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011754f:	8a 00                	mov    (%eax),%al
f0117551:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117554:	75 0f                	jne    f0117565 <test_kmalloc+0x875>
f0117556:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117559:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011755c:	01 d0                	add    %edx,%eax
f011755e:	8a 00                	mov    (%eax),%al
f0117560:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117563:	74 17                	je     f011757c <test_kmalloc+0x88c>
f0117565:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011756c:	83 ec 0c             	sub    $0xc,%esp
f011756f:	68 e8 b9 12 f0       	push   $0xf012b9e8
f0117574:	e8 12 9a fe ff       	call   f0100f8b <cprintf>
f0117579:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f011757c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011757f:	8a 00                	mov    (%eax),%al
f0117581:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117584:	75 16                	jne    f011759c <test_kmalloc+0x8ac>
f0117586:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117589:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117590:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117593:	01 d0                	add    %edx,%eax
f0117595:	8a 00                	mov    (%eax),%al
f0117597:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011759a:	74 17                	je     f01175b3 <test_kmalloc+0x8c3>
f011759c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175a3:	83 ec 0c             	sub    $0xc,%esp
f01175a6:	68 24 ba 12 f0       	push   $0xf012ba24
f01175ab:	e8 db 99 fe ff       	call   f0100f8b <cprintf>
f01175b0:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f01175b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175b6:	66 8b 40 02          	mov    0x2(%eax),%ax
f01175ba:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01175be:	75 19                	jne    f01175d9 <test_kmalloc+0x8e9>
f01175c0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01175c3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01175ca:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175cd:	01 d0                	add    %edx,%eax
f01175cf:	66 8b 40 02          	mov    0x2(%eax),%ax
f01175d3:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01175d7:	74 17                	je     f01175f0 <test_kmalloc+0x900>
f01175d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175e0:	83 ec 0c             	sub    $0xc,%esp
f01175e3:	68 60 ba 12 f0       	push   $0xf012ba60
f01175e8:	e8 9e 99 fe ff       	call   f0100f8b <cprintf>
f01175ed:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f01175f0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175f3:	8b 40 04             	mov    0x4(%eax),%eax
f01175f6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01175f9:	75 17                	jne    f0117612 <test_kmalloc+0x922>
f01175fb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01175fe:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117605:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117608:	01 d0                	add    %edx,%eax
f011760a:	8b 40 04             	mov    0x4(%eax),%eax
f011760d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117610:	74 17                	je     f0117629 <test_kmalloc+0x939>
f0117612:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117619:	83 ec 0c             	sub    $0xc,%esp
f011761c:	68 9c ba 12 f0       	push   $0xf012ba9c
f0117621:	e8 65 99 fe ff       	call   f0100f8b <cprintf>
f0117626:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0117629:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011762c:	8a 00                	mov    (%eax),%al
f011762e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117631:	75 34                	jne    f0117667 <test_kmalloc+0x977>
f0117633:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117636:	89 c2                	mov    %eax,%edx
f0117638:	c1 ea 1f             	shr    $0x1f,%edx
f011763b:	01 d0                	add    %edx,%eax
f011763d:	d1 f8                	sar    %eax
f011763f:	89 c2                	mov    %eax,%edx
f0117641:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117644:	01 d0                	add    %edx,%eax
f0117646:	8a 10                	mov    (%eax),%dl
f0117648:	8a 45 ea             	mov    -0x16(%ebp),%al
f011764b:	88 c1                	mov    %al,%cl
f011764d:	c0 e9 07             	shr    $0x7,%cl
f0117650:	01 c8                	add    %ecx,%eax
f0117652:	d0 f8                	sar    %al
f0117654:	38 c2                	cmp    %al,%dl
f0117656:	75 0f                	jne    f0117667 <test_kmalloc+0x977>
f0117658:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011765b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011765e:	01 d0                	add    %edx,%eax
f0117660:	8a 00                	mov    (%eax),%al
f0117662:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117665:	74 17                	je     f011767e <test_kmalloc+0x98e>
f0117667:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011766e:	83 ec 0c             	sub    $0xc,%esp
f0117671:	68 d8 ba 12 f0       	push   $0xf012bad8
f0117676:	e8 10 99 fe ff       	call   f0100f8b <cprintf>
f011767b:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f011767e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117681:	66 8b 00             	mov    (%eax),%ax
f0117684:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117688:	75 15                	jne    f011769f <test_kmalloc+0x9af>
f011768a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011768d:	01 c0                	add    %eax,%eax
f011768f:	89 c2                	mov    %eax,%edx
f0117691:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117694:	01 d0                	add    %edx,%eax
f0117696:	66 8b 00             	mov    (%eax),%ax
f0117699:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011769d:	74 17                	je     f01176b6 <test_kmalloc+0x9c6>
f011769f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176a6:	83 ec 0c             	sub    $0xc,%esp
f01176a9:	68 10 bb 12 f0       	push   $0xf012bb10
f01176ae:	e8 d8 98 fe ff       	call   f0100f8b <cprintf>
f01176b3:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01176b6:	e8 ad 72 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01176bb:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01176be:	74 17                	je     f01176d7 <test_kmalloc+0x9e7>
f01176c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176c7:	83 ec 0c             	sub    $0xc,%esp
f01176ca:	68 4c bb 12 f0       	push   $0xf012bb4c
f01176cf:	e8 b7 98 fe ff       	call   f0100f8b <cprintf>
f01176d4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176d7:	e8 c9 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176dc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01176df:	74 17                	je     f01176f8 <test_kmalloc+0xa08>
f01176e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176e8:	83 ec 0c             	sub    $0xc,%esp
f01176eb:	68 90 bb 12 f0       	push   $0xf012bb90
f01176f0:	e8 96 98 fe ff       	call   f0100f8b <cprintf>
f01176f5:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f01176f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01176fc:	74 04                	je     f0117702 <test_kmalloc+0xa12>
f01176fe:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117702:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0117709:	83 ec 0c             	sub    $0xc,%esp
f011770c:	68 fc bb 12 f0       	push   $0xf012bbfc
f0117711:	e8 75 98 fe ff       	call   f0100f8b <cprintf>
f0117716:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117719:	e8 4a 72 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011771e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117721:	e8 7f d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117726:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f0117729:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117730:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117733:	40                   	inc    %eax
f0117734:	83 ec 0c             	sub    $0xc,%esp
f0117737:	50                   	push   %eax
f0117738:	e8 d1 1d ff ff       	call   f010950e <kmalloc>
f011773d:	83 c4 10             	add    $0x10,%esp
f0117740:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0117746:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011774c:	85 c0                	test   %eax,%eax
f011774e:	74 17                	je     f0117767 <test_kmalloc+0xa77>
f0117750:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117757:	83 ec 0c             	sub    $0xc,%esp
f011775a:	68 20 bc 12 f0       	push   $0xf012bc20
f011775f:	e8 27 98 fe ff       	call   f0100f8b <cprintf>
f0117764:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117767:	e8 39 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011776c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011776f:	74 17                	je     f0117788 <test_kmalloc+0xa98>
f0117771:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117778:	83 ec 0c             	sub    $0xc,%esp
f011777b:	68 58 bc 12 f0       	push   $0xf012bc58
f0117780:	e8 06 98 fe ff       	call   f0100f8b <cprintf>
f0117785:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117788:	e8 db 71 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011778d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117790:	74 17                	je     f01177a9 <test_kmalloc+0xab9>
f0117792:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117799:	83 ec 0c             	sub    $0xc,%esp
f011779c:	68 c4 bc 12 f0       	push   $0xf012bcc4
f01177a1:	e8 e5 97 fe ff       	call   f0100f8b <cprintf>
f01177a6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01177a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01177ad:	74 04                	je     f01177b3 <test_kmalloc+0xac3>
f01177af:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01177b3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f01177ba:	83 ec 0c             	sub    $0xc,%esp
f01177bd:	68 08 bd 12 f0       	push   $0xf012bd08
f01177c2:	e8 c4 97 fe ff       	call   f0100f8b <cprintf>
f01177c7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f01177ca:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01177d0:	05 00 40 00 00       	add    $0x4000,%eax
f01177d5:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01177d8:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f01177df:	eb 6a                	jmp    f011784b <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f01177e1:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01177e6:	83 ec 04             	sub    $0x4,%esp
f01177e9:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f01177ef:	52                   	push   %edx
f01177f0:	ff 75 ec             	pushl  -0x14(%ebp)
f01177f3:	50                   	push   %eax
f01177f4:	e8 f6 0b ff ff       	call   f01083ef <get_page_table>
f01177f9:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f01177fc:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117802:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117805:	c1 ea 0c             	shr    $0xc,%edx
f0117808:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011780e:	c1 e2 02             	shl    $0x2,%edx
f0117811:	01 d0                	add    %edx,%eax
f0117813:	8b 00                	mov    (%eax),%eax
f0117815:	25 ff 0f 00 00       	and    $0xfff,%eax
f011781a:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011781d:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117820:	83 e0 04             	and    $0x4,%eax
f0117823:	85 c0                	test   %eax,%eax
f0117825:	74 1d                	je     f0117844 <test_kmalloc+0xb54>
			{
				if (correct)
f0117827:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011782b:	74 17                	je     f0117844 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011782d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117834:	83 ec 0c             	sub    $0xc,%esp
f0117837:	68 4c bd 12 f0       	push   $0xf012bd4c
f011783c:	e8 4a 97 fe ff       	call   f0100f8b <cprintf>
f0117841:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117844:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011784b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011784e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117851:	72 8e                	jb     f01177e1 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117853:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117857:	74 04                	je     f011785d <test_kmalloc+0xb6d>
f0117859:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011785d:	83 ec 08             	sub    $0x8,%esp
f0117860:	ff 75 f4             	pushl  -0xc(%ebp)
f0117863:	68 9c bd 12 f0       	push   $0xf012bd9c
f0117868:	e8 1e 97 fe ff       	call   f0100f8b <cprintf>
f011786d:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117870:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0117875:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117878:	5b                   	pop    %ebx
f0117879:	5f                   	pop    %edi
f011787a:	5d                   	pop    %ebp
f011787b:	c3                   	ret    

f011787c <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f011787c:	55                   	push   %ebp
f011787d:	89 e5                	mov    %esp,%ebp
f011787f:	57                   	push   %edi
f0117880:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117883:	83 ec 0c             	sub    $0xc,%esp
f0117886:	68 08 af 12 f0       	push   $0xf012af08
f011788b:	e8 fb 96 fe ff       	call   f0100f8b <cprintf>
f0117890:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117893:	83 ec 0c             	sub    $0xc,%esp
f0117896:	68 38 af 12 f0       	push   $0xf012af38
f011789b:	e8 eb 96 fe ff       	call   f0100f8b <cprintf>
f01178a0:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01178a3:	83 ec 0c             	sub    $0xc,%esp
f01178a6:	68 08 af 12 f0       	push   $0xf012af08
f01178ab:	e8 db 96 fe ff       	call   f0100f8b <cprintf>
f01178b0:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01178b3:	8d 55 98             	lea    -0x68(%ebp),%edx
f01178b6:	b9 14 00 00 00       	mov    $0x14,%ecx
f01178bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01178c0:	89 d7                	mov    %edx,%edi
f01178c2:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01178c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01178cb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01178d2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f01178d9:	83 ec 0c             	sub    $0xc,%esp
f01178dc:	68 c8 bd 12 f0       	push   $0xf012bdc8
f01178e1:	e8 a5 96 fe ff       	call   f0100f8b <cprintf>
f01178e6:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01178e9:	e8 7a 70 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01178ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178f1:	e8 af cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f01178f9:	83 ec 0c             	sub    $0xc,%esp
f01178fc:	68 00 fc 0f 00       	push   $0xffc00
f0117901:	e8 08 1c ff ff       	call   f010950e <kmalloc>
f0117906:	83 c4 10             	add    $0x10,%esp
f0117909:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f011790c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011790f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117914:	74 17                	je     f011792d <test_kmalloc_firstfit1+0xb1>
f0117916:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011791d:	83 ec 0c             	sub    $0xc,%esp
f0117920:	68 08 be 12 f0       	push   $0xf012be08
f0117925:	e8 61 96 fe ff       	call   f0100f8b <cprintf>
f011792a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011792d:	e8 73 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117932:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117935:	74 17                	je     f011794e <test_kmalloc_firstfit1+0xd2>
f0117937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011793e:	83 ec 0c             	sub    $0xc,%esp
f0117941:	68 2c b1 12 f0       	push   $0xf012b12c
f0117946:	e8 40 96 fe ff       	call   f0100f8b <cprintf>
f011794b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f011794e:	e8 15 70 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117953:	89 c2                	mov    %eax,%edx
f0117955:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117958:	29 d0                	sub    %edx,%eax
f011795a:	3d ff 00 00 00       	cmp    $0xff,%eax
f011795f:	7f 17                	jg     f0117978 <test_kmalloc_firstfit1+0xfc>
f0117961:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117968:	83 ec 0c             	sub    $0xc,%esp
f011796b:	68 3b be 12 f0       	push   $0xf012be3b
f0117970:	e8 16 96 fe ff       	call   f0100f8b <cprintf>
f0117975:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117978:	e8 eb 6f ff ff       	call   f010e968 <sys_calculate_free_frames>
f011797d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117980:	e8 20 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117985:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0117988:	83 ec 0c             	sub    $0xc,%esp
f011798b:	68 00 fc 0f 00       	push   $0xffc00
f0117990:	e8 79 1b ff ff       	call   f010950e <kmalloc>
f0117995:	83 c4 10             	add    $0x10,%esp
f0117998:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f011799b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011799e:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01179a3:	74 17                	je     f01179bc <test_kmalloc_firstfit1+0x140>
f01179a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179ac:	83 ec 0c             	sub    $0xc,%esp
f01179af:	68 54 be 12 f0       	push   $0xf012be54
f01179b4:	e8 d2 95 fe ff       	call   f0100f8b <cprintf>
f01179b9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179bc:	e8 e4 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179c1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179c4:	74 17                	je     f01179dd <test_kmalloc_firstfit1+0x161>
f01179c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179cd:	83 ec 0c             	sub    $0xc,%esp
f01179d0:	68 30 b2 12 f0       	push   $0xf012b230
f01179d5:	e8 b1 95 fe ff       	call   f0100f8b <cprintf>
f01179da:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01179dd:	e8 86 6f ff ff       	call   f010e968 <sys_calculate_free_frames>
f01179e2:	89 c2                	mov    %eax,%edx
f01179e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179e7:	29 d0                	sub    %edx,%eax
f01179e9:	3d ff 00 00 00       	cmp    $0xff,%eax
f01179ee:	7f 17                	jg     f0117a07 <test_kmalloc_firstfit1+0x18b>
f01179f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179f7:	83 ec 0c             	sub    $0xc,%esp
f01179fa:	68 87 be 12 f0       	push   $0xf012be87
f01179ff:	e8 87 95 fe ff       	call   f0100f8b <cprintf>
f0117a04:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a07:	e8 5c 6f ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117a0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a0f:	e8 91 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a14:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117a17:	83 ec 0c             	sub    $0xc,%esp
f0117a1a:	68 00 fc 0f 00       	push   $0xffc00
f0117a1f:	e8 ea 1a ff ff       	call   f010950e <kmalloc>
f0117a24:	83 c4 10             	add    $0x10,%esp
f0117a27:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117a2a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117a2d:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117a32:	74 17                	je     f0117a4b <test_kmalloc_firstfit1+0x1cf>
f0117a34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a3b:	83 ec 0c             	sub    $0xc,%esp
f0117a3e:	68 a0 be 12 f0       	push   $0xf012bea0
f0117a43:	e8 43 95 fe ff       	call   f0100f8b <cprintf>
f0117a48:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a4b:	e8 55 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a50:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a53:	74 17                	je     f0117a6c <test_kmalloc_firstfit1+0x1f0>
f0117a55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a5c:	83 ec 0c             	sub    $0xc,%esp
f0117a5f:	68 6c b3 12 f0       	push   $0xf012b36c
f0117a64:	e8 22 95 fe ff       	call   f0100f8b <cprintf>
f0117a69:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117a6c:	e8 f7 6e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117a71:	89 c2                	mov    %eax,%edx
f0117a73:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a76:	29 d0                	sub    %edx,%eax
f0117a78:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117a7d:	7f 17                	jg     f0117a96 <test_kmalloc_firstfit1+0x21a>
f0117a7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a86:	83 ec 0c             	sub    $0xc,%esp
f0117a89:	68 d3 be 12 f0       	push   $0xf012bed3
f0117a8e:	e8 f8 94 fe ff       	call   f0100f8b <cprintf>
f0117a93:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a96:	e8 cd 6e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117a9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a9e:	e8 02 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117aa3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117aa6:	83 ec 0c             	sub    $0xc,%esp
f0117aa9:	68 00 fc 0f 00       	push   $0xffc00
f0117aae:	e8 5b 1a ff ff       	call   f010950e <kmalloc>
f0117ab3:	83 c4 10             	add    $0x10,%esp
f0117ab6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117ab9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117abc:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117ac1:	74 17                	je     f0117ada <test_kmalloc_firstfit1+0x25e>
f0117ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aca:	83 ec 0c             	sub    $0xc,%esp
f0117acd:	68 ec be 12 f0       	push   $0xf012beec
f0117ad2:	e8 b4 94 fe ff       	call   f0100f8b <cprintf>
f0117ad7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ada:	e8 c6 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117adf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ae2:	74 17                	je     f0117afb <test_kmalloc_firstfit1+0x27f>
f0117ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aeb:	83 ec 0c             	sub    $0xc,%esp
f0117aee:	68 64 b4 12 f0       	push   $0xf012b464
f0117af3:	e8 93 94 fe ff       	call   f0100f8b <cprintf>
f0117af8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117afb:	e8 68 6e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117b00:	89 c2                	mov    %eax,%edx
f0117b02:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b05:	29 d0                	sub    %edx,%eax
f0117b07:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b0c:	7f 17                	jg     f0117b25 <test_kmalloc_firstfit1+0x2a9>
f0117b0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b15:	83 ec 0c             	sub    $0xc,%esp
f0117b18:	68 1f bf 12 f0       	push   $0xf012bf1f
f0117b1d:	e8 69 94 fe ff       	call   f0100f8b <cprintf>
f0117b22:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b25:	e8 3e 6e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117b2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b2d:	e8 73 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b32:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117b35:	83 ec 0c             	sub    $0xc,%esp
f0117b38:	68 00 fc 1f 00       	push   $0x1ffc00
f0117b3d:	e8 cc 19 ff ff       	call   f010950e <kmalloc>
f0117b42:	83 c4 10             	add    $0x10,%esp
f0117b45:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117b48:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117b4b:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117b50:	74 17                	je     f0117b69 <test_kmalloc_firstfit1+0x2ed>
f0117b52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b59:	83 ec 0c             	sub    $0xc,%esp
f0117b5c:	68 38 bf 12 f0       	push   $0xf012bf38
f0117b61:	e8 25 94 fe ff       	call   f0100f8b <cprintf>
f0117b66:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b69:	e8 37 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b6e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b71:	74 17                	je     f0117b8a <test_kmalloc_firstfit1+0x30e>
f0117b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b7a:	83 ec 0c             	sub    $0xc,%esp
f0117b7d:	68 44 b5 12 f0       	push   $0xf012b544
f0117b82:	e8 04 94 fe ff       	call   f0100f8b <cprintf>
f0117b87:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117b8a:	e8 d9 6d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117b8f:	89 c2                	mov    %eax,%edx
f0117b91:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b94:	29 d0                	sub    %edx,%eax
f0117b96:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117b9b:	7f 17                	jg     f0117bb4 <test_kmalloc_firstfit1+0x338>
f0117b9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ba4:	83 ec 0c             	sub    $0xc,%esp
f0117ba7:	68 6b bf 12 f0       	push   $0xf012bf6b
f0117bac:	e8 da 93 fe ff       	call   f0100f8b <cprintf>
f0117bb1:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bb4:	e8 af 6d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117bb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117bbc:	e8 e4 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117bc4:	83 ec 0c             	sub    $0xc,%esp
f0117bc7:	68 00 fc 1f 00       	push   $0x1ffc00
f0117bcc:	e8 3d 19 ff ff       	call   f010950e <kmalloc>
f0117bd1:	83 c4 10             	add    $0x10,%esp
f0117bd4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117bd7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117bda:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117bdf:	74 17                	je     f0117bf8 <test_kmalloc_firstfit1+0x37c>
f0117be1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117be8:	83 ec 0c             	sub    $0xc,%esp
f0117beb:	68 84 bf 12 f0       	push   $0xf012bf84
f0117bf0:	e8 96 93 fe ff       	call   f0100f8b <cprintf>
f0117bf5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117bf8:	e8 a8 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bfd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c00:	74 17                	je     f0117c19 <test_kmalloc_firstfit1+0x39d>
f0117c02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c09:	83 ec 0c             	sub    $0xc,%esp
f0117c0c:	68 48 b6 12 f0       	push   $0xf012b648
f0117c11:	e8 75 93 fe ff       	call   f0100f8b <cprintf>
f0117c16:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117c19:	e8 4a 6d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117c1e:	89 c2                	mov    %eax,%edx
f0117c20:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c23:	29 d0                	sub    %edx,%eax
f0117c25:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117c2a:	7f 17                	jg     f0117c43 <test_kmalloc_firstfit1+0x3c7>
f0117c2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c33:	83 ec 0c             	sub    $0xc,%esp
f0117c36:	68 b7 bf 12 f0       	push   $0xf012bfb7
f0117c3b:	e8 4b 93 fe ff       	call   f0100f8b <cprintf>
f0117c40:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c43:	e8 20 6d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117c48:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c4b:	e8 55 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c50:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117c53:	83 ec 0c             	sub    $0xc,%esp
f0117c56:	68 00 fc 2f 00       	push   $0x2ffc00
f0117c5b:	e8 ae 18 ff ff       	call   f010950e <kmalloc>
f0117c60:	83 c4 10             	add    $0x10,%esp
f0117c63:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117c66:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117c69:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117c6e:	74 17                	je     f0117c87 <test_kmalloc_firstfit1+0x40b>
f0117c70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c77:	83 ec 0c             	sub    $0xc,%esp
f0117c7a:	68 d0 bf 12 f0       	push   $0xf012bfd0
f0117c7f:	e8 07 93 fe ff       	call   f0100f8b <cprintf>
f0117c84:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c87:	e8 19 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c8c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c8f:	74 17                	je     f0117ca8 <test_kmalloc_firstfit1+0x42c>
f0117c91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c98:	83 ec 0c             	sub    $0xc,%esp
f0117c9b:	68 4c b7 12 f0       	push   $0xf012b74c
f0117ca0:	e8 e6 92 fe ff       	call   f0100f8b <cprintf>
f0117ca5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117ca8:	e8 bb 6c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117cad:	89 c2                	mov    %eax,%edx
f0117caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117cb2:	29 d0                	sub    %edx,%eax
f0117cb4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117cb9:	7f 17                	jg     f0117cd2 <test_kmalloc_firstfit1+0x456>
f0117cbb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cc2:	83 ec 0c             	sub    $0xc,%esp
f0117cc5:	68 03 c0 12 f0       	push   $0xf012c003
f0117cca:	e8 bc 92 fe ff       	call   f0100f8b <cprintf>
f0117ccf:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117cd2:	e8 91 6c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117cd7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117cda:	e8 c6 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117cdf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117ce2:	83 ec 0c             	sub    $0xc,%esp
f0117ce5:	68 00 fc 2f 00       	push   $0x2ffc00
f0117cea:	e8 1f 18 ff ff       	call   f010950e <kmalloc>
f0117cef:	83 c4 10             	add    $0x10,%esp
f0117cf2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117cf5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117cf8:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117cfd:	74 17                	je     f0117d16 <test_kmalloc_firstfit1+0x49a>
f0117cff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d06:	83 ec 0c             	sub    $0xc,%esp
f0117d09:	68 1c c0 12 f0       	push   $0xf012c01c
f0117d0e:	e8 78 92 fe ff       	call   f0100f8b <cprintf>
f0117d13:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d16:	e8 8a cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d1b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d1e:	74 17                	je     f0117d37 <test_kmalloc_firstfit1+0x4bb>
f0117d20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d27:	83 ec 0c             	sub    $0xc,%esp
f0117d2a:	68 50 b8 12 f0       	push   $0xf012b850
f0117d2f:	e8 57 92 fe ff       	call   f0100f8b <cprintf>
f0117d34:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117d37:	e8 2c 6c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117d3c:	89 c2                	mov    %eax,%edx
f0117d3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d41:	29 d0                	sub    %edx,%eax
f0117d43:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117d48:	7f 17                	jg     f0117d61 <test_kmalloc_firstfit1+0x4e5>
f0117d4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d51:	83 ec 0c             	sub    $0xc,%esp
f0117d54:	68 4f c0 12 f0       	push   $0xf012c04f
f0117d59:	e8 2d 92 fe ff       	call   f0100f8b <cprintf>
f0117d5e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117d61:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117d65:	74 04                	je     f0117d6b <test_kmalloc_firstfit1+0x4ef>
f0117d67:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117d6b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0117d72:	83 ec 0c             	sub    $0xc,%esp
f0117d75:	68 68 c0 12 f0       	push   $0xf012c068
f0117d7a:	e8 0c 92 fe ff       	call   f0100f8b <cprintf>
f0117d7f:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d82:	e8 e1 6b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117d87:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d8a:	e8 16 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117d92:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117d95:	83 ec 0c             	sub    $0xc,%esp
f0117d98:	50                   	push   %eax
f0117d99:	e8 ef 19 ff ff       	call   f010978d <kfree>
f0117d9e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117da1:	e8 ff ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117da6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117da9:	74 17                	je     f0117dc2 <test_kmalloc_firstfit1+0x546>
f0117dab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117db2:	83 ec 0c             	sub    $0xc,%esp
f0117db5:	68 90 c0 12 f0       	push   $0xf012c090
f0117dba:	e8 cc 91 fe ff       	call   f0100f8b <cprintf>
f0117dbf:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117dc2:	e8 a1 6b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117dc7:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117dca:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117dcf:	7f 17                	jg     f0117de8 <test_kmalloc_firstfit1+0x56c>
f0117dd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dd8:	83 ec 0c             	sub    $0xc,%esp
f0117ddb:	68 fb c0 12 f0       	push   $0xf012c0fb
f0117de0:	e8 a6 91 fe ff       	call   f0100f8b <cprintf>
f0117de5:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117de8:	e8 7b 6b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117ded:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117df0:	e8 b0 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117df5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0117df8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117dfb:	83 ec 0c             	sub    $0xc,%esp
f0117dfe:	50                   	push   %eax
f0117dff:	e8 89 19 ff ff       	call   f010978d <kfree>
f0117e04:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e07:	e8 99 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e0c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e0f:	74 17                	je     f0117e28 <test_kmalloc_firstfit1+0x5ac>
f0117e11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e18:	83 ec 0c             	sub    $0xc,%esp
f0117e1b:	68 0c c1 12 f0       	push   $0xf012c10c
f0117e20:	e8 66 91 fe ff       	call   f0100f8b <cprintf>
f0117e25:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0117e28:	e8 3b 6b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117e2d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e30:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e35:	7f 17                	jg     f0117e4e <test_kmalloc_firstfit1+0x5d2>
f0117e37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e3e:	83 ec 0c             	sub    $0xc,%esp
f0117e41:	68 78 c1 12 f0       	push   $0xf012c178
f0117e46:	e8 40 91 fe ff       	call   f0100f8b <cprintf>
f0117e4b:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e4e:	e8 15 6b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117e53:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e56:	e8 4a ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0117e5e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117e61:	83 ec 0c             	sub    $0xc,%esp
f0117e64:	50                   	push   %eax
f0117e65:	e8 23 19 ff ff       	call   f010978d <kfree>
f0117e6a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e6d:	e8 33 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e72:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e75:	74 17                	je     f0117e8e <test_kmalloc_firstfit1+0x612>
f0117e77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e7e:	83 ec 0c             	sub    $0xc,%esp
f0117e81:	68 8c c1 12 f0       	push   $0xf012c18c
f0117e86:	e8 00 91 fe ff       	call   f0100f8b <cprintf>
f0117e8b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117e8e:	e8 d5 6a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117e93:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e96:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117e9b:	7f 17                	jg     f0117eb4 <test_kmalloc_firstfit1+0x638>
f0117e9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ea4:	83 ec 0c             	sub    $0xc,%esp
f0117ea7:	68 f8 c1 12 f0       	push   $0xf012c1f8
f0117eac:	e8 da 90 fe ff       	call   f0100f8b <cprintf>
f0117eb1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117eb4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117eb8:	74 04                	je     f0117ebe <test_kmalloc_firstfit1+0x642>
f0117eba:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117ebe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117ec5:	83 ec 0c             	sub    $0xc,%esp
f0117ec8:	68 0c c2 12 f0       	push   $0xf012c20c
f0117ecd:	e8 b9 90 fe ff       	call   f0100f8b <cprintf>
f0117ed2:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ed5:	e8 8e 6a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117eda:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117edd:	e8 c3 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ee2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117ee5:	83 ec 0c             	sub    $0xc,%esp
f0117ee8:	68 00 fc 07 00       	push   $0x7fc00
f0117eed:	e8 1c 16 ff ff       	call   f010950e <kmalloc>
f0117ef2:	83 c4 10             	add    $0x10,%esp
f0117ef5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0117ef8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117efb:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117f00:	74 17                	je     f0117f19 <test_kmalloc_firstfit1+0x69d>
f0117f02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f09:	83 ec 0c             	sub    $0xc,%esp
f0117f0c:	68 38 c2 12 f0       	push   $0xf012c238
f0117f11:	e8 75 90 fe ff       	call   f0100f8b <cprintf>
f0117f16:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f19:	e8 87 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f1e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f21:	74 17                	je     f0117f3a <test_kmalloc_firstfit1+0x6be>
f0117f23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f2a:	83 ec 0c             	sub    $0xc,%esp
f0117f2d:	68 6c c2 12 f0       	push   $0xf012c26c
f0117f32:	e8 54 90 fe ff       	call   f0100f8b <cprintf>
f0117f37:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0117f3a:	e8 29 6a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117f3f:	89 c2                	mov    %eax,%edx
f0117f41:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f44:	29 d0                	sub    %edx,%eax
f0117f46:	83 f8 7f             	cmp    $0x7f,%eax
f0117f49:	7f 17                	jg     f0117f62 <test_kmalloc_firstfit1+0x6e6>
f0117f4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f52:	83 ec 0c             	sub    $0xc,%esp
f0117f55:	68 d8 c2 12 f0       	push   $0xf012c2d8
f0117f5a:	e8 2c 90 fe ff       	call   f0100f8b <cprintf>
f0117f5f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f62:	e8 01 6a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117f67:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f6a:	e8 36 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0117f72:	83 ec 0c             	sub    $0xc,%esp
f0117f75:	68 00 fc 0f 00       	push   $0xffc00
f0117f7a:	e8 8f 15 ff ff       	call   f010950e <kmalloc>
f0117f7f:	83 c4 10             	add    $0x10,%esp
f0117f82:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0117f85:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117f88:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117f8d:	74 17                	je     f0117fa6 <test_kmalloc_firstfit1+0x72a>
f0117f8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f96:	83 ec 0c             	sub    $0xc,%esp
f0117f99:	68 f0 c2 12 f0       	push   $0xf012c2f0
f0117f9e:	e8 e8 8f fe ff       	call   f0100f8b <cprintf>
f0117fa3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117fa6:	e8 fa c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fae:	74 17                	je     f0117fc7 <test_kmalloc_firstfit1+0x74b>
f0117fb0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fb7:	83 ec 0c             	sub    $0xc,%esp
f0117fba:	68 24 c3 12 f0       	push   $0xf012c324
f0117fbf:	e8 c7 8f fe ff       	call   f0100f8b <cprintf>
f0117fc4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0117fc7:	e8 9c 69 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117fcc:	89 c2                	mov    %eax,%edx
f0117fce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fd1:	29 d0                	sub    %edx,%eax
f0117fd3:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117fd8:	7f 17                	jg     f0117ff1 <test_kmalloc_firstfit1+0x775>
f0117fda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fe1:	83 ec 0c             	sub    $0xc,%esp
f0117fe4:	68 90 c3 12 f0       	push   $0xf012c390
f0117fe9:	e8 9d 8f fe ff       	call   f0100f8b <cprintf>
f0117fee:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ff1:	e8 72 69 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0117ff6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117ff9:	e8 a7 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0118001:	83 ec 0c             	sub    $0xc,%esp
f0118004:	68 00 fc 03 00       	push   $0x3fc00
f0118009:	e8 00 15 ff ff       	call   f010950e <kmalloc>
f011800e:	83 c4 10             	add    $0x10,%esp
f0118011:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0118014:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118017:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f011801c:	74 17                	je     f0118035 <test_kmalloc_firstfit1+0x7b9>
f011801e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118025:	83 ec 0c             	sub    $0xc,%esp
f0118028:	68 a8 c3 12 f0       	push   $0xf012c3a8
f011802d:	e8 59 8f fe ff       	call   f0100f8b <cprintf>
f0118032:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118035:	e8 6b c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011803a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011803d:	74 17                	je     f0118056 <test_kmalloc_firstfit1+0x7da>
f011803f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118046:	83 ec 0c             	sub    $0xc,%esp
f0118049:	68 dc c3 12 f0       	push   $0xf012c3dc
f011804e:	e8 38 8f fe ff       	call   f0100f8b <cprintf>
f0118053:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0118056:	e8 0d 69 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011805b:	89 c2                	mov    %eax,%edx
f011805d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118060:	29 d0                	sub    %edx,%eax
f0118062:	83 f8 3f             	cmp    $0x3f,%eax
f0118065:	7f 17                	jg     f011807e <test_kmalloc_firstfit1+0x802>
f0118067:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011806e:	83 ec 0c             	sub    $0xc,%esp
f0118071:	68 48 c4 12 f0       	push   $0xf012c448
f0118076:	e8 10 8f fe ff       	call   f0100f8b <cprintf>
f011807b:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011807e:	e8 e5 68 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118083:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118086:	e8 1a c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011808b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f011808e:	83 ec 0c             	sub    $0xc,%esp
f0118091:	68 00 00 20 00       	push   $0x200000
f0118096:	e8 73 14 ff ff       	call   f010950e <kmalloc>
f011809b:	83 c4 10             	add    $0x10,%esp
f011809e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f01180a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01180a4:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01180a9:	74 17                	je     f01180c2 <test_kmalloc_firstfit1+0x846>
f01180ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180b2:	83 ec 0c             	sub    $0xc,%esp
f01180b5:	68 60 c4 12 f0       	push   $0xf012c460
f01180ba:	e8 cc 8e fe ff       	call   f0100f8b <cprintf>
f01180bf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f01180c2:	e8 a1 68 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01180c7:	89 c2                	mov    %eax,%edx
f01180c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180cc:	29 d0                	sub    %edx,%eax
f01180ce:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01180d3:	7f 17                	jg     f01180ec <test_kmalloc_firstfit1+0x870>
f01180d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180dc:	83 ec 0c             	sub    $0xc,%esp
f01180df:	68 94 c4 12 f0       	push   $0xf012c494
f01180e4:	e8 a2 8e fe ff       	call   f0100f8b <cprintf>
f01180e9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180ec:	e8 b4 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180f1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180f4:	74 17                	je     f011810d <test_kmalloc_firstfit1+0x891>
f01180f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180fd:	83 ec 0c             	sub    $0xc,%esp
f0118100:	68 ac c4 12 f0       	push   $0xf012c4ac
f0118105:	e8 81 8e fe ff       	call   f0100f8b <cprintf>
f011810a:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f011810d:	e8 56 68 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118112:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118115:	e8 8b c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011811a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f011811d:	83 ec 0c             	sub    $0xc,%esp
f0118120:	68 00 fc 3f 00       	push   $0x3ffc00
f0118125:	e8 e4 13 ff ff       	call   f010950e <kmalloc>
f011812a:	83 c4 10             	add    $0x10,%esp
f011812d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0118130:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118133:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0118138:	74 17                	je     f0118151 <test_kmalloc_firstfit1+0x8d5>
f011813a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118141:	83 ec 0c             	sub    $0xc,%esp
f0118144:	68 18 c5 12 f0       	push   $0xf012c518
f0118149:	e8 3d 8e fe ff       	call   f0100f8b <cprintf>
f011814e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118151:	e8 4f c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118156:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118159:	74 17                	je     f0118172 <test_kmalloc_firstfit1+0x8f6>
f011815b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118162:	83 ec 0c             	sub    $0xc,%esp
f0118165:	68 4c c5 12 f0       	push   $0xf012c54c
f011816a:	e8 1c 8e fe ff       	call   f0100f8b <cprintf>
f011816f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0118172:	e8 f1 67 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118177:	89 c2                	mov    %eax,%edx
f0118179:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011817c:	29 d0                	sub    %edx,%eax
f011817e:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0118183:	7f 17                	jg     f011819c <test_kmalloc_firstfit1+0x920>
f0118185:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011818c:	83 ec 0c             	sub    $0xc,%esp
f011818f:	68 b8 c5 12 f0       	push   $0xf012c5b8
f0118194:	e8 f2 8d fe ff       	call   f0100f8b <cprintf>
f0118199:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011819c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01181a0:	74 04                	je     f01181a6 <test_kmalloc_firstfit1+0x92a>
f01181a2:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01181a6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f01181ad:	83 ec 0c             	sub    $0xc,%esp
f01181b0:	68 d0 c5 12 f0       	push   $0xf012c5d0
f01181b5:	e8 d1 8d fe ff       	call   f0100f8b <cprintf>
f01181ba:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01181bd:	e8 a6 67 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01181c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181c5:	e8 db c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f01181cd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01181d0:	83 ec 0c             	sub    $0xc,%esp
f01181d3:	50                   	push   %eax
f01181d4:	e8 b4 15 ff ff       	call   f010978d <kfree>
f01181d9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181dc:	e8 c4 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181e4:	74 17                	je     f01181fd <test_kmalloc_firstfit1+0x981>
f01181e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181ed:	83 ec 0c             	sub    $0xc,%esp
f01181f0:	68 90 bb 12 f0       	push   $0xf012bb90
f01181f5:	e8 91 8d fe ff       	call   f0100f8b <cprintf>
f01181fa:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f01181fd:	e8 66 67 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118202:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118205:	3d ff 00 00 00       	cmp    $0xff,%eax
f011820a:	7f 17                	jg     f0118223 <test_kmalloc_firstfit1+0x9a7>
f011820c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118213:	83 ec 0c             	sub    $0xc,%esp
f0118216:	68 04 c6 12 f0       	push   $0xf012c604
f011821b:	e8 6b 8d fe ff       	call   f0100f8b <cprintf>
f0118220:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0118223:	e8 40 67 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118228:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011822b:	e8 75 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118230:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0118233:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118236:	83 ec 0c             	sub    $0xc,%esp
f0118239:	50                   	push   %eax
f011823a:	e8 4e 15 ff ff       	call   f010978d <kfree>
f011823f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118242:	e8 5e c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118247:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011824a:	74 17                	je     f0118263 <test_kmalloc_firstfit1+0x9e7>
f011824c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118253:	83 ec 0c             	sub    $0xc,%esp
f0118256:	68 58 bc 12 f0       	push   $0xf012bc58
f011825b:	e8 2b 8d fe ff       	call   f0100f8b <cprintf>
f0118260:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0118263:	e8 00 67 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118268:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011826b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118270:	7f 17                	jg     f0118289 <test_kmalloc_firstfit1+0xa0d>
f0118272:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118279:	83 ec 0c             	sub    $0xc,%esp
f011827c:	68 15 c6 12 f0       	push   $0xf012c615
f0118281:	e8 05 8d fe ff       	call   f0100f8b <cprintf>
f0118286:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118289:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011828d:	74 04                	je     f0118293 <test_kmalloc_firstfit1+0xa17>
f011828f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118293:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f011829a:	83 ec 0c             	sub    $0xc,%esp
f011829d:	68 28 c6 12 f0       	push   $0xf012c628
f01182a2:	e8 e4 8c fe ff       	call   f0100f8b <cprintf>
f01182a7:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f01182aa:	e8 b9 66 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01182af:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182b2:	e8 ee c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f01182ba:	83 ec 0c             	sub    $0xc,%esp
f01182bd:	68 00 00 10 00       	push   $0x100000
f01182c2:	e8 47 12 ff ff       	call   f010950e <kmalloc>
f01182c7:	83 c4 10             	add    $0x10,%esp
f01182ca:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f01182cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01182d0:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f01182d5:	74 17                	je     f01182ee <test_kmalloc_firstfit1+0xa72>
f01182d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182de:	83 ec 0c             	sub    $0xc,%esp
f01182e1:	68 68 c6 12 f0       	push   $0xf012c668
f01182e6:	e8 a0 8c fe ff       	call   f0100f8b <cprintf>
f01182eb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182ee:	e8 b2 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182f3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01182f6:	74 17                	je     f011830f <test_kmalloc_firstfit1+0xa93>
f01182f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182ff:	83 ec 0c             	sub    $0xc,%esp
f0118302:	68 9c c6 12 f0       	push   $0xf012c69c
f0118307:	e8 7f 8c fe ff       	call   f0100f8b <cprintf>
f011830c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f011830f:	e8 54 66 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118314:	89 c2                	mov    %eax,%edx
f0118316:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118319:	29 d0                	sub    %edx,%eax
f011831b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118320:	7f 17                	jg     f0118339 <test_kmalloc_firstfit1+0xabd>
f0118322:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118329:	83 ec 0c             	sub    $0xc,%esp
f011832c:	68 08 c7 12 f0       	push   $0xf012c708
f0118331:	e8 55 8c fe ff       	call   f0100f8b <cprintf>
f0118336:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0118339:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011833d:	74 04                	je     f0118343 <test_kmalloc_firstfit1+0xac7>
f011833f:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0118343:	83 ec 08             	sub    $0x8,%esp
f0118346:	ff 75 f4             	pushl  -0xc(%ebp)
f0118349:	68 20 c7 12 f0       	push   $0xf012c720
f011834e:	e8 38 8c fe ff       	call   f0100f8b <cprintf>
f0118353:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118356:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011835b:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011835e:	c9                   	leave  
f011835f:	c3                   	ret    

f0118360 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0118360:	55                   	push   %ebp
f0118361:	89 e5                	mov    %esp,%ebp
f0118363:	57                   	push   %edi
f0118364:	53                   	push   %ebx
f0118365:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118368:	83 ec 0c             	sub    $0xc,%esp
f011836b:	68 08 af 12 f0       	push   $0xf012af08
f0118370:	e8 16 8c fe ff       	call   f0100f8b <cprintf>
f0118375:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118378:	83 ec 0c             	sub    $0xc,%esp
f011837b:	68 38 af 12 f0       	push   $0xf012af38
f0118380:	e8 06 8c fe ff       	call   f0100f8b <cprintf>
f0118385:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118388:	83 ec 0c             	sub    $0xc,%esp
f011838b:	68 08 af 12 f0       	push   $0xf012af08
f0118390:	e8 f6 8b fe ff       	call   f0100f8b <cprintf>
f0118395:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118398:	8d 55 98             	lea    -0x68(%ebp),%edx
f011839b:	b9 14 00 00 00       	mov    $0x14,%ecx
f01183a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01183a5:	89 d7                	mov    %edx,%edi
f01183a7:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01183a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01183b0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01183b7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f01183be:	83 ec 0c             	sub    $0xc,%esp
f01183c1:	68 58 c7 12 f0       	push   $0xf012c758
f01183c6:	e8 c0 8b fe ff       	call   f0100f8b <cprintf>
f01183cb:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f01183ce:	83 ec 0c             	sub    $0xc,%esp
f01183d1:	68 01 e0 ff 07       	push   $0x7ffe001
f01183d6:	e8 33 11 ff ff       	call   f010950e <kmalloc>
f01183db:	83 c4 10             	add    $0x10,%esp
f01183de:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f01183e1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01183e4:	85 c0                	test   %eax,%eax
f01183e6:	74 17                	je     f01183ff <test_kmalloc_firstfit2+0x9f>
f01183e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183ef:	83 ec 0c             	sub    $0xc,%esp
f01183f2:	68 8c c7 12 f0       	push   $0xf012c78c
f01183f7:	e8 8f 8b fe ff       	call   f0100f8b <cprintf>
f01183fc:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01183ff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118403:	74 04                	je     f0118409 <test_kmalloc_firstfit2+0xa9>
f0118405:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118409:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0118410:	83 ec 0c             	sub    $0xc,%esp
f0118413:	68 d4 c7 12 f0       	push   $0xf012c7d4
f0118418:	e8 6e 8b fe ff       	call   f0100f8b <cprintf>
f011841d:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118420:	e8 43 65 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118425:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118428:	e8 78 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011842d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118430:	83 ec 0c             	sub    $0xc,%esp
f0118433:	68 00 fc 1f 00       	push   $0x1ffc00
f0118438:	e8 d1 10 ff ff       	call   f010950e <kmalloc>
f011843d:	83 c4 10             	add    $0x10,%esp
f0118440:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0118443:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118446:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011844b:	74 17                	je     f0118464 <test_kmalloc_firstfit2+0x104>
f011844d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118454:	83 ec 0c             	sub    $0xc,%esp
f0118457:	68 54 be 12 f0       	push   $0xf012be54
f011845c:	e8 2a 8b fe ff       	call   f0100f8b <cprintf>
f0118461:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118464:	e8 3c c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118469:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011846c:	74 17                	je     f0118485 <test_kmalloc_firstfit2+0x125>
f011846e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118475:	83 ec 0c             	sub    $0xc,%esp
f0118478:	68 30 b2 12 f0       	push   $0xf012b230
f011847d:	e8 09 8b fe ff       	call   f0100f8b <cprintf>
f0118482:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0118485:	e8 de 64 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011848a:	89 c2                	mov    %eax,%edx
f011848c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011848f:	29 d0                	sub    %edx,%eax
f0118491:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118496:	7f 17                	jg     f01184af <test_kmalloc_firstfit2+0x14f>
f0118498:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011849f:	83 ec 0c             	sub    $0xc,%esp
f01184a2:	68 87 be 12 f0       	push   $0xf012be87
f01184a7:	e8 df 8a fe ff       	call   f0100f8b <cprintf>
f01184ac:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01184af:	e8 b4 64 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01184b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184b7:	e8 e9 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01184bf:	83 ec 0c             	sub    $0xc,%esp
f01184c2:	68 00 fc 1f 00       	push   $0x1ffc00
f01184c7:	e8 42 10 ff ff       	call   f010950e <kmalloc>
f01184cc:	83 c4 10             	add    $0x10,%esp
f01184cf:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01184d2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01184d5:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01184da:	74 17                	je     f01184f3 <test_kmalloc_firstfit2+0x193>
f01184dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184e3:	83 ec 0c             	sub    $0xc,%esp
f01184e6:	68 a0 be 12 f0       	push   $0xf012bea0
f01184eb:	e8 9b 8a fe ff       	call   f0100f8b <cprintf>
f01184f0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184f3:	e8 ad c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184f8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184fb:	74 17                	je     f0118514 <test_kmalloc_firstfit2+0x1b4>
f01184fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118504:	83 ec 0c             	sub    $0xc,%esp
f0118507:	68 6c b3 12 f0       	push   $0xf012b36c
f011850c:	e8 7a 8a fe ff       	call   f0100f8b <cprintf>
f0118511:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0118514:	e8 4f 64 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118519:	89 c2                	mov    %eax,%edx
f011851b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011851e:	29 d0                	sub    %edx,%eax
f0118520:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118525:	7f 17                	jg     f011853e <test_kmalloc_firstfit2+0x1de>
f0118527:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011852e:	83 ec 0c             	sub    $0xc,%esp
f0118531:	68 d3 be 12 f0       	push   $0xf012bed3
f0118536:	e8 50 8a fe ff       	call   f0100f8b <cprintf>
f011853b:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011853e:	e8 25 64 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118543:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118546:	e8 5a c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011854b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011854e:	83 ec 0c             	sub    $0xc,%esp
f0118551:	68 00 1c 00 00       	push   $0x1c00
f0118556:	e8 b3 0f ff ff       	call   f010950e <kmalloc>
f011855b:	83 c4 10             	add    $0x10,%esp
f011855e:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0118561:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118564:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118569:	74 17                	je     f0118582 <test_kmalloc_firstfit2+0x222>
f011856b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118572:	83 ec 0c             	sub    $0xc,%esp
f0118575:	68 ec be 12 f0       	push   $0xf012beec
f011857a:	e8 0c 8a fe ff       	call   f0100f8b <cprintf>
f011857f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118582:	e8 1e c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118587:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011858a:	74 17                	je     f01185a3 <test_kmalloc_firstfit2+0x243>
f011858c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118593:	83 ec 0c             	sub    $0xc,%esp
f0118596:	68 64 b4 12 f0       	push   $0xf012b464
f011859b:	e8 eb 89 fe ff       	call   f0100f8b <cprintf>
f01185a0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01185a3:	e8 c0 63 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01185a8:	89 c2                	mov    %eax,%edx
f01185aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01185ad:	29 d0                	sub    %edx,%eax
f01185af:	83 f8 01             	cmp    $0x1,%eax
f01185b2:	7f 17                	jg     f01185cb <test_kmalloc_firstfit2+0x26b>
f01185b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185bb:	83 ec 0c             	sub    $0xc,%esp
f01185be:	68 1f bf 12 f0       	push   $0xf012bf1f
f01185c3:	e8 c3 89 fe ff       	call   f0100f8b <cprintf>
f01185c8:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01185cb:	e8 98 63 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01185d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185d3:	e8 cd c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f01185db:	8b 45 98             	mov    -0x68(%ebp),%eax
f01185de:	83 ec 0c             	sub    $0xc,%esp
f01185e1:	50                   	push   %eax
f01185e2:	e8 a6 11 ff ff       	call   f010978d <kfree>
f01185e7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185ea:	e8 b6 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185ef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185f2:	74 17                	je     f011860b <test_kmalloc_firstfit2+0x2ab>
f01185f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185fb:	83 ec 0c             	sub    $0xc,%esp
f01185fe:	68 44 b5 12 f0       	push   $0xf012b544
f0118603:	e8 83 89 fe ff       	call   f0100f8b <cprintf>
f0118608:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f011860b:	e8 58 63 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118610:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118613:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118618:	7f 17                	jg     f0118631 <test_kmalloc_firstfit2+0x2d1>
f011861a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118621:	83 ec 0c             	sub    $0xc,%esp
f0118624:	68 1a c8 12 f0       	push   $0xf012c81a
f0118629:	e8 5d 89 fe ff       	call   f0100f8b <cprintf>
f011862e:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118631:	e8 32 63 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118636:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118639:	e8 67 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011863e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0118641:	83 ec 0c             	sub    $0xc,%esp
f0118644:	68 00 fc 2f 00       	push   $0x2ffc00
f0118649:	e8 c0 0e ff ff       	call   f010950e <kmalloc>
f011864e:	83 c4 10             	add    $0x10,%esp
f0118651:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0118654:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118657:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011865c:	74 17                	je     f0118675 <test_kmalloc_firstfit2+0x315>
f011865e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118665:	83 ec 0c             	sub    $0xc,%esp
f0118668:	68 84 bf 12 f0       	push   $0xf012bf84
f011866d:	e8 19 89 fe ff       	call   f0100f8b <cprintf>
f0118672:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118675:	e8 2b c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011867a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011867d:	74 17                	je     f0118696 <test_kmalloc_firstfit2+0x336>
f011867f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118686:	83 ec 0c             	sub    $0xc,%esp
f0118689:	68 48 b6 12 f0       	push   $0xf012b648
f011868e:	e8 f8 88 fe ff       	call   f0100f8b <cprintf>
f0118693:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0118696:	e8 cd 62 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011869b:	89 c2                	mov    %eax,%edx
f011869d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186a0:	29 d0                	sub    %edx,%eax
f01186a2:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01186a7:	7f 17                	jg     f01186c0 <test_kmalloc_firstfit2+0x360>
f01186a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186b0:	83 ec 0c             	sub    $0xc,%esp
f01186b3:	68 b7 bf 12 f0       	push   $0xf012bfb7
f01186b8:	e8 ce 88 fe ff       	call   f0100f8b <cprintf>
f01186bd:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186c0:	e8 a3 62 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01186c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186c8:	e8 d8 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f01186d0:	83 ec 0c             	sub    $0xc,%esp
f01186d3:	68 00 18 20 00       	push   $0x201800
f01186d8:	e8 31 0e ff ff       	call   f010950e <kmalloc>
f01186dd:	83 c4 10             	add    $0x10,%esp
f01186e0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01186e3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01186e6:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01186eb:	74 17                	je     f0118704 <test_kmalloc_firstfit2+0x3a4>
f01186ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186f4:	83 ec 0c             	sub    $0xc,%esp
f01186f7:	68 d0 bf 12 f0       	push   $0xf012bfd0
f01186fc:	e8 8a 88 fe ff       	call   f0100f8b <cprintf>
f0118701:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118704:	e8 9c c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118709:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011870c:	74 17                	je     f0118725 <test_kmalloc_firstfit2+0x3c5>
f011870e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118715:	83 ec 0c             	sub    $0xc,%esp
f0118718:	68 4c b7 12 f0       	push   $0xf012b74c
f011871d:	e8 69 88 fe ff       	call   f0100f8b <cprintf>
f0118722:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118725:	e8 3e 62 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011872a:	89 c2                	mov    %eax,%edx
f011872c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011872f:	29 d0                	sub    %edx,%eax
f0118731:	3d 01 02 00 00       	cmp    $0x201,%eax
f0118736:	7f 17                	jg     f011874f <test_kmalloc_firstfit2+0x3ef>
f0118738:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011873f:	83 ec 0c             	sub    $0xc,%esp
f0118742:	68 03 c0 12 f0       	push   $0xf012c003
f0118747:	e8 3f 88 fe ff       	call   f0100f8b <cprintf>
f011874c:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011874f:	e8 14 62 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118754:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118757:	e8 49 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011875c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011875f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118762:	83 ec 0c             	sub    $0xc,%esp
f0118765:	50                   	push   %eax
f0118766:	e8 22 10 ff ff       	call   f010978d <kfree>
f011876b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011876e:	e8 32 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118773:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118776:	74 17                	je     f011878f <test_kmalloc_firstfit2+0x42f>
f0118778:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011877f:	83 ec 0c             	sub    $0xc,%esp
f0118782:	68 50 b8 12 f0       	push   $0xf012b850
f0118787:	e8 ff 87 fe ff       	call   f0100f8b <cprintf>
f011878c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f011878f:	e8 d4 61 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118794:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118797:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011879c:	7f 17                	jg     f01187b5 <test_kmalloc_firstfit2+0x455>
f011879e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187a5:	83 ec 0c             	sub    $0xc,%esp
f01187a8:	68 2a c8 12 f0       	push   $0xf012c82a
f01187ad:	e8 d9 87 fe ff       	call   f0100f8b <cprintf>
f01187b2:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01187b5:	e8 ae 61 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01187ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187bd:	e8 e3 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01187c5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01187c8:	83 ec 0c             	sub    $0xc,%esp
f01187cb:	50                   	push   %eax
f01187cc:	e8 bc 0f ff ff       	call   f010978d <kfree>
f01187d1:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f01187d4:	e8 8f 61 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01187d9:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01187dc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01187e1:	7f 17                	jg     f01187fa <test_kmalloc_firstfit2+0x49a>
f01187e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187ea:	83 ec 0c             	sub    $0xc,%esp
f01187ed:	68 fb c0 12 f0       	push   $0xf012c0fb
f01187f2:	e8 94 87 fe ff       	call   f0100f8b <cprintf>
f01187f7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187fa:	e8 a6 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187ff:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118802:	74 17                	je     f011881b <test_kmalloc_firstfit2+0x4bb>
f0118804:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011880b:	83 ec 0c             	sub    $0xc,%esp
f011880e:	68 90 c0 12 f0       	push   $0xf012c090
f0118813:	e8 73 87 fe ff       	call   f0100f8b <cprintf>
f0118818:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011881b:	e8 48 61 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118820:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118823:	e8 7d c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118828:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011882b:	83 ec 0c             	sub    $0xc,%esp
f011882e:	68 00 fc 4f 00       	push   $0x4ffc00
f0118833:	e8 d6 0c ff ff       	call   f010950e <kmalloc>
f0118838:	83 c4 10             	add    $0x10,%esp
f011883b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f011883e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118841:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0118846:	74 17                	je     f011885f <test_kmalloc_firstfit2+0x4ff>
f0118848:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011884f:	83 ec 0c             	sub    $0xc,%esp
f0118852:	68 3c c8 12 f0       	push   $0xf012c83c
f0118857:	e8 2f 87 fe ff       	call   f0100f8b <cprintf>
f011885c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011885f:	e8 41 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118864:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118867:	74 17                	je     f0118880 <test_kmalloc_firstfit2+0x520>
f0118869:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118870:	83 ec 0c             	sub    $0xc,%esp
f0118873:	68 0c c1 12 f0       	push   $0xf012c10c
f0118878:	e8 0e 87 fe ff       	call   f0100f8b <cprintf>
f011887d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f0118880:	e8 e3 60 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118885:	89 c2                	mov    %eax,%edx
f0118887:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011888a:	29 d0                	sub    %edx,%eax
f011888c:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0118891:	7f 17                	jg     f01188aa <test_kmalloc_firstfit2+0x54a>
f0118893:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011889a:	83 ec 0c             	sub    $0xc,%esp
f011889d:	68 70 c8 12 f0       	push   $0xf012c870
f01188a2:	e8 e4 86 fe ff       	call   f0100f8b <cprintf>
f01188a7:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01188aa:	e8 b9 60 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01188af:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188b2:	e8 ee bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f01188ba:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01188bd:	83 ec 0c             	sub    $0xc,%esp
f01188c0:	50                   	push   %eax
f01188c1:	e8 c7 0e ff ff       	call   f010978d <kfree>
f01188c6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188c9:	e8 d7 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188d1:	74 17                	je     f01188ea <test_kmalloc_firstfit2+0x58a>
f01188d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188da:	83 ec 0c             	sub    $0xc,%esp
f01188dd:	68 8c c1 12 f0       	push   $0xf012c18c
f01188e2:	e8 a4 86 fe ff       	call   f0100f8b <cprintf>
f01188e7:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f01188ea:	e8 79 60 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01188ef:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01188f2:	83 f8 01             	cmp    $0x1,%eax
f01188f5:	7f 17                	jg     f011890e <test_kmalloc_firstfit2+0x5ae>
f01188f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188fe:	83 ec 0c             	sub    $0xc,%esp
f0118901:	68 f8 c1 12 f0       	push   $0xf012c1f8
f0118906:	e8 80 86 fe ff       	call   f0100f8b <cprintf>
f011890b:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f011890e:	e8 55 60 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118913:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118916:	e8 8a bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011891b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011891e:	83 ec 0c             	sub    $0xc,%esp
f0118921:	68 00 04 00 00       	push   $0x400
f0118926:	e8 e3 0b ff ff       	call   f010950e <kmalloc>
f011892b:	83 c4 10             	add    $0x10,%esp
f011892e:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118931:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118934:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118939:	76 22                	jbe    f011895d <test_kmalloc_firstfit2+0x5fd>
f011893b:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f011893e:	83 ec 0c             	sub    $0xc,%esp
f0118941:	6a 00                	push   $0x0
f0118943:	e8 93 0a ff ff       	call   f01093db <sbrk>
f0118948:	83 c4 10             	add    $0x10,%esp
f011894b:	39 c3                	cmp    %eax,%ebx
f011894d:	73 0e                	jae    f011895d <test_kmalloc_firstfit2+0x5fd>
f011894f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118952:	89 c2                	mov    %eax,%edx
f0118954:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0118959:	39 c2                	cmp    %eax,%edx
f011895b:	72 17                	jb     f0118974 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011895d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118964:	83 ec 0c             	sub    $0xc,%esp
f0118967:	68 88 c8 12 f0       	push   $0xf012c888
f011896c:	e8 1a 86 fe ff       	call   f0100f8b <cprintf>
f0118971:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118974:	e8 2c bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118979:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011897c:	74 17                	je     f0118995 <test_kmalloc_firstfit2+0x635>
f011897e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118985:	83 ec 0c             	sub    $0xc,%esp
f0118988:	68 6c c2 12 f0       	push   $0xf012c26c
f011898d:	e8 f9 85 fe ff       	call   f0100f8b <cprintf>
f0118992:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118995:	e8 0b bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011899a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011899d:	83 ec 0c             	sub    $0xc,%esp
f01189a0:	68 00 08 00 00       	push   $0x800
f01189a5:	e8 64 0b ff ff       	call   f010950e <kmalloc>
f01189aa:	83 c4 10             	add    $0x10,%esp
f01189ad:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01189b0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01189b3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01189b8:	76 22                	jbe    f01189dc <test_kmalloc_firstfit2+0x67c>
f01189ba:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01189bd:	83 ec 0c             	sub    $0xc,%esp
f01189c0:	6a 00                	push   $0x0
f01189c2:	e8 14 0a ff ff       	call   f01093db <sbrk>
f01189c7:	83 c4 10             	add    $0x10,%esp
f01189ca:	39 c3                	cmp    %eax,%ebx
f01189cc:	73 0e                	jae    f01189dc <test_kmalloc_firstfit2+0x67c>
f01189ce:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01189d1:	89 c2                	mov    %eax,%edx
f01189d3:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f01189d8:	39 c2                	cmp    %eax,%edx
f01189da:	72 17                	jb     f01189f3 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01189dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189e3:	83 ec 0c             	sub    $0xc,%esp
f01189e6:	68 14 c9 12 f0       	push   $0xf012c914
f01189eb:	e8 9b 85 fe ff       	call   f0100f8b <cprintf>
f01189f0:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01189f3:	e8 ad be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189f8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01189fb:	74 17                	je     f0118a14 <test_kmalloc_firstfit2+0x6b4>
f01189fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a04:	83 ec 0c             	sub    $0xc,%esp
f0118a07:	68 24 c3 12 f0       	push   $0xf012c324
f0118a0c:	e8 7a 85 fe ff       	call   f0100f8b <cprintf>
f0118a11:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a14:	e8 8c be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a19:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118a1c:	83 ec 0c             	sub    $0xc,%esp
f0118a1f:	68 00 04 00 00       	push   $0x400
f0118a24:	e8 e5 0a ff ff       	call   f010950e <kmalloc>
f0118a29:	83 c4 10             	add    $0x10,%esp
f0118a2c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118a2f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a32:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118a37:	76 22                	jbe    f0118a5b <test_kmalloc_firstfit2+0x6fb>
f0118a39:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118a3c:	83 ec 0c             	sub    $0xc,%esp
f0118a3f:	6a 00                	push   $0x0
f0118a41:	e8 95 09 ff ff       	call   f01093db <sbrk>
f0118a46:	83 c4 10             	add    $0x10,%esp
f0118a49:	39 c3                	cmp    %eax,%ebx
f0118a4b:	73 0e                	jae    f0118a5b <test_kmalloc_firstfit2+0x6fb>
f0118a4d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a50:	89 c2                	mov    %eax,%edx
f0118a52:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0118a57:	39 c2                	cmp    %eax,%edx
f0118a59:	72 17                	jb     f0118a72 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118a5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a62:	83 ec 0c             	sub    $0xc,%esp
f0118a65:	68 a0 c9 12 f0       	push   $0xf012c9a0
f0118a6a:	e8 1c 85 fe ff       	call   f0100f8b <cprintf>
f0118a6f:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a72:	e8 2e be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a77:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a7a:	74 17                	je     f0118a93 <test_kmalloc_firstfit2+0x733>
f0118a7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a83:	83 ec 0c             	sub    $0xc,%esp
f0118a86:	68 dc c3 12 f0       	push   $0xf012c3dc
f0118a8b:	e8 fb 84 fe ff       	call   f0100f8b <cprintf>
f0118a90:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118a93:	e8 d0 5e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118a98:	89 c2                	mov    %eax,%edx
f0118a9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a9d:	29 d0                	sub    %edx,%eax
f0118a9f:	83 f8 01             	cmp    $0x1,%eax
f0118aa2:	74 17                	je     f0118abb <test_kmalloc_firstfit2+0x75b>
f0118aa4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aab:	83 ec 0c             	sub    $0xc,%esp
f0118aae:	68 2c ca 12 f0       	push   $0xf012ca2c
f0118ab3:	e8 d3 84 fe ff       	call   f0100f8b <cprintf>
f0118ab8:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118abb:	e8 a8 5e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118ac0:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ac3:	e8 dd bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ac8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118acb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118ace:	83 ec 0c             	sub    $0xc,%esp
f0118ad1:	50                   	push   %eax
f0118ad2:	e8 b6 0c ff ff       	call   f010978d <kfree>
f0118ad7:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ada:	e8 c6 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118adf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ae2:	74 17                	je     f0118afb <test_kmalloc_firstfit2+0x79b>
f0118ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aeb:	83 ec 0c             	sub    $0xc,%esp
f0118aee:	68 ac c4 12 f0       	push   $0xf012c4ac
f0118af3:	e8 93 84 fe ff       	call   f0100f8b <cprintf>
f0118af8:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118afb:	e8 68 5e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118b00:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118b03:	74 17                	je     f0118b1c <test_kmalloc_firstfit2+0x7bc>
f0118b05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b0c:	83 ec 0c             	sub    $0xc,%esp
f0118b0f:	68 50 ca 12 f0       	push   $0xf012ca50
f0118b14:	e8 72 84 fe ff       	call   f0100f8b <cprintf>
f0118b19:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118b1c:	e8 47 5e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118b21:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b24:	e8 7c bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b29:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118b2c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118b2f:	83 ec 0c             	sub    $0xc,%esp
f0118b32:	50                   	push   %eax
f0118b33:	e8 55 0c ff ff       	call   f010978d <kfree>
f0118b38:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b3b:	e8 65 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b40:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b43:	74 17                	je     f0118b5c <test_kmalloc_firstfit2+0x7fc>
f0118b45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b4c:	83 ec 0c             	sub    $0xc,%esp
f0118b4f:	68 4c c5 12 f0       	push   $0xf012c54c
f0118b54:	e8 32 84 fe ff       	call   f0100f8b <cprintf>
f0118b59:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118b5c:	e8 07 5e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118b61:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118b64:	74 17                	je     f0118b7d <test_kmalloc_firstfit2+0x81d>
f0118b66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b6d:	83 ec 0c             	sub    $0xc,%esp
f0118b70:	68 b0 ca 12 f0       	push   $0xf012cab0
f0118b75:	e8 11 84 fe ff       	call   f0100f8b <cprintf>
f0118b7a:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118b7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118b81:	74 04                	je     f0118b87 <test_kmalloc_firstfit2+0x827>
f0118b83:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118b87:	83 ec 0c             	sub    $0xc,%esp
f0118b8a:	68 10 cb 12 f0       	push   $0xf012cb10
f0118b8f:	e8 f7 83 fe ff       	call   f0100f8b <cprintf>
f0118b94:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118b97:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b9e:	e8 c5 5d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118ba3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ba6:	e8 fa bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bab:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118bae:	83 ec 0c             	sub    $0xc,%esp
f0118bb1:	68 00 08 00 00       	push   $0x800
f0118bb6:	e8 53 09 ff ff       	call   f010950e <kmalloc>
f0118bbb:	83 c4 10             	add    $0x10,%esp
f0118bbe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118bc1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118bc4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118bc7:	39 c2                	cmp    %eax,%edx
f0118bc9:	74 17                	je     f0118be2 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118bcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bd2:	83 ec 0c             	sub    $0xc,%esp
f0118bd5:	68 48 cb 12 f0       	push   $0xf012cb48
f0118bda:	e8 ac 83 fe ff       	call   f0100f8b <cprintf>
f0118bdf:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118be2:	e8 be bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118be7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118bea:	74 17                	je     f0118c03 <test_kmalloc_firstfit2+0x8a3>
f0118bec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bf3:	83 ec 0c             	sub    $0xc,%esp
f0118bf6:	68 90 bb 12 f0       	push   $0xf012bb90
f0118bfb:	e8 8b 83 fe ff       	call   f0100f8b <cprintf>
f0118c00:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118c03:	e8 60 5d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118c08:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c0b:	74 17                	je     f0118c24 <test_kmalloc_firstfit2+0x8c4>
f0118c0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c14:	83 ec 0c             	sub    $0xc,%esp
f0118c17:	68 7c cb 12 f0       	push   $0xf012cb7c
f0118c1c:	e8 6a 83 fe ff       	call   f0100f8b <cprintf>
f0118c21:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c24:	e8 3f 5d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118c29:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c2c:	e8 74 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c31:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118c34:	83 ec 0c             	sub    $0xc,%esp
f0118c37:	68 00 04 00 00       	push   $0x400
f0118c3c:	e8 cd 08 ff ff       	call   f010950e <kmalloc>
f0118c41:	83 c4 10             	add    $0x10,%esp
f0118c44:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118c47:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118c4a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118c4d:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118c53:	39 d0                	cmp    %edx,%eax
f0118c55:	74 17                	je     f0118c6e <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118c57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c5e:	83 ec 0c             	sub    $0xc,%esp
f0118c61:	68 94 cb 12 f0       	push   $0xf012cb94
f0118c66:	e8 20 83 fe ff       	call   f0100f8b <cprintf>
f0118c6b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c6e:	e8 32 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c73:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c76:	74 17                	je     f0118c8f <test_kmalloc_firstfit2+0x92f>
f0118c78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c7f:	83 ec 0c             	sub    $0xc,%esp
f0118c82:	68 58 bc 12 f0       	push   $0xf012bc58
f0118c87:	e8 ff 82 fe ff       	call   f0100f8b <cprintf>
f0118c8c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118c8f:	e8 d4 5c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118c94:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c97:	74 17                	je     f0118cb0 <test_kmalloc_firstfit2+0x950>
f0118c99:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ca0:	83 ec 0c             	sub    $0xc,%esp
f0118ca3:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0118ca8:	e8 de 82 fe ff       	call   f0100f8b <cprintf>
f0118cad:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118cb0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118cb4:	74 04                	je     f0118cba <test_kmalloc_firstfit2+0x95a>
f0118cb6:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118cba:	83 ec 0c             	sub    $0xc,%esp
f0118cbd:	68 e0 cb 12 f0       	push   $0xf012cbe0
f0118cc2:	e8 c4 82 fe ff       	call   f0100f8b <cprintf>
f0118cc7:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118cca:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118cd1:	e8 92 5c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118cd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118cd9:	e8 c7 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cde:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118ce1:	83 ec 0c             	sub    $0xc,%esp
f0118ce4:	68 00 04 70 00       	push   $0x700400
f0118ce9:	e8 20 08 ff ff       	call   f010950e <kmalloc>
f0118cee:	83 c4 10             	add    $0x10,%esp
f0118cf1:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118cf4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118cf7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118cfc:	74 17                	je     f0118d15 <test_kmalloc_firstfit2+0x9b5>
f0118cfe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d05:	83 ec 0c             	sub    $0xc,%esp
f0118d08:	68 68 c6 12 f0       	push   $0xf012c668
f0118d0d:	e8 79 82 fe ff       	call   f0100f8b <cprintf>
f0118d12:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d15:	e8 8b bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d1a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d1d:	74 17                	je     f0118d36 <test_kmalloc_firstfit2+0x9d6>
f0118d1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d26:	83 ec 0c             	sub    $0xc,%esp
f0118d29:	68 9c c6 12 f0       	push   $0xf012c69c
f0118d2e:	e8 58 82 fe ff       	call   f0100f8b <cprintf>
f0118d33:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118d36:	e8 2d 5c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118d3b:	89 c2                	mov    %eax,%edx
f0118d3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d40:	29 d0                	sub    %edx,%eax
f0118d42:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118d47:	7f 17                	jg     f0118d60 <test_kmalloc_firstfit2+0xa00>
f0118d49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d50:	83 ec 0c             	sub    $0xc,%esp
f0118d53:	68 08 c7 12 f0       	push   $0xf012c708
f0118d58:	e8 2e 82 fe ff       	call   f0100f8b <cprintf>
f0118d5d:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118d60:	e8 03 5c ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118d65:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d68:	e8 38 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0118d70:	83 ec 0c             	sub    $0xc,%esp
f0118d73:	68 00 0c 00 00       	push   $0xc00
f0118d78:	e8 91 07 ff ff       	call   f010950e <kmalloc>
f0118d7d:	83 c4 10             	add    $0x10,%esp
f0118d80:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118d83:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118d86:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0118d8b:	74 17                	je     f0118da4 <test_kmalloc_firstfit2+0xa44>
f0118d8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d94:	83 ec 0c             	sub    $0xc,%esp
f0118d97:	68 14 cc 12 f0       	push   $0xf012cc14
f0118d9c:	e8 ea 81 fe ff       	call   f0100f8b <cprintf>
f0118da1:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118da4:	e8 fc ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118da9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118dac:	74 17                	je     f0118dc5 <test_kmalloc_firstfit2+0xa65>
f0118dae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118db5:	83 ec 0c             	sub    $0xc,%esp
f0118db8:	68 48 cc 12 f0       	push   $0xf012cc48
f0118dbd:	e8 c9 81 fe ff       	call   f0100f8b <cprintf>
f0118dc2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118dc5:	e8 9e 5b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118dca:	89 c2                	mov    %eax,%edx
f0118dcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118dcf:	29 d0                	sub    %edx,%eax
f0118dd1:	85 c0                	test   %eax,%eax
f0118dd3:	7f 17                	jg     f0118dec <test_kmalloc_firstfit2+0xa8c>
f0118dd5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ddc:	83 ec 0c             	sub    $0xc,%esp
f0118ddf:	68 b4 cc 12 f0       	push   $0xf012ccb4
f0118de4:	e8 a2 81 fe ff       	call   f0100f8b <cprintf>
f0118de9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118dec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118df0:	74 04                	je     f0118df6 <test_kmalloc_firstfit2+0xa96>
f0118df2:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0118df6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118dfd:	83 ec 0c             	sub    $0xc,%esp
f0118e00:	68 cc cc 12 f0       	push   $0xf012cccc
f0118e05:	e8 81 81 fe ff       	call   f0100f8b <cprintf>
f0118e0a:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118e0d:	83 ec 0c             	sub    $0xc,%esp
f0118e10:	68 00 e0 1f 07       	push   $0x71fe000
f0118e15:	e8 f4 06 ff ff       	call   f010950e <kmalloc>
f0118e1a:	83 c4 10             	add    $0x10,%esp
f0118e1d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118e20:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118e23:	85 c0                	test   %eax,%eax
f0118e25:	74 17                	je     f0118e3e <test_kmalloc_firstfit2+0xade>
f0118e27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e2e:	83 ec 0c             	sub    $0xc,%esp
f0118e31:	68 20 cd 12 f0       	push   $0xf012cd20
f0118e36:	e8 50 81 fe ff       	call   f0100f8b <cprintf>
f0118e3b:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118e3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118e42:	74 04                	je     f0118e48 <test_kmalloc_firstfit2+0xae8>
f0118e44:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0118e48:	83 ec 08             	sub    $0x8,%esp
f0118e4b:	ff 75 f4             	pushl  -0xc(%ebp)
f0118e4e:	68 88 cd 12 f0       	push   $0xf012cd88
f0118e53:	e8 33 81 fe ff       	call   f0100f8b <cprintf>
f0118e58:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118e5b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118e60:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118e63:	5b                   	pop    %ebx
f0118e64:	5f                   	pop    %edi
f0118e65:	5d                   	pop    %ebp
f0118e66:	c3                   	ret    

f0118e67 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0118e67:	55                   	push   %ebp
f0118e68:	89 e5                	mov    %esp,%ebp
f0118e6a:	53                   	push   %ebx
f0118e6b:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118e6e:	83 ec 0c             	sub    $0xc,%esp
f0118e71:	68 08 af 12 f0       	push   $0xf012af08
f0118e76:	e8 10 81 fe ff       	call   f0100f8b <cprintf>
f0118e7b:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118e7e:	83 ec 0c             	sub    $0xc,%esp
f0118e81:	68 38 af 12 f0       	push   $0xf012af38
f0118e86:	e8 00 81 fe ff       	call   f0100f8b <cprintf>
f0118e8b:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118e8e:	83 ec 0c             	sub    $0xc,%esp
f0118e91:	68 08 af 12 f0       	push   $0xf012af08
f0118e96:	e8 f0 80 fe ff       	call   f0100f8b <cprintf>
f0118e9b:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0118e9e:	e8 c5 5a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118ea3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0118ea6:	e8 fa b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118eab:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118eae:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0118eb5:	83 ec 0c             	sub    $0xc,%esp
f0118eb8:	68 bd cd 12 f0       	push   $0xf012cdbd
f0118ebd:	e8 c9 80 fe ff       	call   f0100f8b <cprintf>
f0118ec2:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118ec5:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118eca:	ba 00 00 00 00       	mov    $0x0,%edx
f0118ecf:	f7 75 e4             	divl   -0x1c(%ebp)
f0118ed2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118ed5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118edc:	eb 1d                	jmp    f0118efb <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118ede:	83 ec 0c             	sub    $0xc,%esp
f0118ee1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118ee4:	e8 25 06 ff ff       	call   f010950e <kmalloc>
f0118ee9:	83 c4 10             	add    $0x10,%esp
f0118eec:	89 c2                	mov    %eax,%edx
f0118eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ef1:	89 14 85 80 93 69 f0 	mov    %edx,-0xf966c80(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0118ef8:	ff 45 f4             	incl   -0xc(%ebp)
f0118efb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118efe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118f01:	7c db                	jl     f0118ede <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118f03:	83 ec 0c             	sub    $0xc,%esp
f0118f06:	68 c1 cd 12 f0       	push   $0xf012cdc1
f0118f0b:	e8 7b 80 fe ff       	call   f0100f8b <cprintf>
f0118f10:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118f13:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118f18:	ba 00 00 00 00       	mov    $0x0,%edx
f0118f1d:	f7 75 e4             	divl   -0x1c(%ebp)
f0118f20:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0118f23:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118f27:	74 1e                	je     f0118f47 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0118f29:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0118f2c:	8d 43 01             	lea    0x1(%ebx),%eax
f0118f2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118f32:	83 ec 0c             	sub    $0xc,%esp
f0118f35:	ff 75 e0             	pushl  -0x20(%ebp)
f0118f38:	e8 d1 05 ff ff       	call   f010950e <kmalloc>
f0118f3d:	83 c4 10             	add    $0x10,%esp
f0118f40:	89 04 9d 80 93 69 f0 	mov    %eax,-0xf966c80(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0118f47:	83 ec 04             	sub    $0x4,%esp
f0118f4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0118f4d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118f50:	68 c8 cd 12 f0       	push   $0xf012cdc8
f0118f55:	e8 31 80 fe ff       	call   f0100f8b <cprintf>
f0118f5a:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118f5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f64:	eb 36                	jmp    f0118f9c <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0118f66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f69:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f0118f70:	89 c2                	mov    %eax,%edx
f0118f72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f75:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118f79:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0118f7e:	39 c2                	cmp    %eax,%edx
f0118f80:	74 17                	je     f0118f99 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0118f82:	83 ec 04             	sub    $0x4,%esp
f0118f85:	68 10 ce 12 f0       	push   $0xf012ce10
f0118f8a:	68 e3 02 00 00       	push   $0x2e3
f0118f8f:	68 53 ce 12 f0       	push   $0xf012ce53
f0118f94:	e8 a0 73 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118f99:	ff 45 f4             	incl   -0xc(%ebp)
f0118f9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f9f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118fa2:	7c c2                	jl     f0118f66 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118fa4:	e8 fc b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118fa9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118fac:	74 17                	je     f0118fc5 <test_fastfirstfit+0x15e>
f0118fae:	83 ec 04             	sub    $0x4,%esp
f0118fb1:	68 6c ce 12 f0       	push   $0xf012ce6c
f0118fb6:	68 e6 02 00 00       	push   $0x2e6
f0118fbb:	68 53 ce 12 f0       	push   $0xf012ce53
f0118fc0:	e8 74 73 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0118fc5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118fc8:	e8 9b 59 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118fcd:	29 c3                	sub    %eax,%ebx
f0118fcf:	89 d8                	mov    %ebx,%eax
f0118fd1:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0118fd6:	77 17                	ja     f0118fef <test_fastfirstfit+0x188>
f0118fd8:	83 ec 04             	sub    $0x4,%esp
f0118fdb:	68 d4 ce 12 f0       	push   $0xf012ced4
f0118fe0:	68 e7 02 00 00       	push   $0x2e7
f0118fe5:	68 53 ce 12 f0       	push   $0xf012ce53
f0118fea:	e8 4a 73 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118fef:	e8 b1 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ff4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0118ff7:	e8 6c 59 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0118ffc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118fff:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0119003:	7f 17                	jg     f011901c <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0119005:	83 ec 04             	sub    $0x4,%esp
f0119008:	68 e8 ce 12 f0       	push   $0xf012cee8
f011900d:	68 ee 02 00 00       	push   $0x2ee
f0119012:	68 53 ce 12 f0       	push   $0xf012ce53
f0119017:	e8 1d 73 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f011901c:	a1 80 93 69 f0       	mov    0xf0699380,%eax
f0119021:	83 ec 0c             	sub    $0xc,%esp
f0119024:	50                   	push   %eax
f0119025:	e8 63 07 ff ff       	call   f010978d <kfree>
f011902a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f011902d:	a1 88 93 69 f0       	mov    0xf0699388,%eax
f0119032:	83 ec 0c             	sub    $0xc,%esp
f0119035:	50                   	push   %eax
f0119036:	e8 52 07 ff ff       	call   f010978d <kfree>
f011903b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f011903e:	a1 8c 93 69 f0       	mov    0xf069938c,%eax
f0119043:	83 ec 0c             	sub    $0xc,%esp
f0119046:	50                   	push   %eax
f0119047:	e8 41 07 ff ff       	call   f010978d <kfree>
f011904c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f011904f:	a1 94 93 69 f0       	mov    0xf0699394,%eax
f0119054:	83 ec 0c             	sub    $0xc,%esp
f0119057:	50                   	push   %eax
f0119058:	e8 30 07 ff ff       	call   f010978d <kfree>
f011905d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0119060:	a1 a8 93 69 f0       	mov    0xf06993a8,%eax
f0119065:	83 ec 0c             	sub    $0xc,%esp
f0119068:	50                   	push   %eax
f0119069:	e8 1f 07 ff ff       	call   f010978d <kfree>
f011906e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0119071:	a1 b0 93 69 f0       	mov    0xf06993b0,%eax
f0119076:	83 ec 0c             	sub    $0xc,%esp
f0119079:	50                   	push   %eax
f011907a:	e8 0e 07 ff ff       	call   f010978d <kfree>
f011907f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0119082:	a1 ac 93 69 f0       	mov    0xf06993ac,%eax
f0119087:	83 ec 0c             	sub    $0xc,%esp
f011908a:	50                   	push   %eax
f011908b:	e8 fd 06 ff ff       	call   f010978d <kfree>
f0119090:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0119093:	a1 d0 93 69 f0       	mov    0xf06993d0,%eax
f0119098:	83 ec 0c             	sub    $0xc,%esp
f011909b:	50                   	push   %eax
f011909c:	e8 ec 06 ff ff       	call   f010978d <kfree>
f01190a1:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f01190a4:	a1 e4 93 69 f0       	mov    0xf06993e4,%eax
f01190a9:	83 ec 0c             	sub    $0xc,%esp
f01190ac:	50                   	push   %eax
f01190ad:	e8 db 06 ff ff       	call   f010978d <kfree>
f01190b2:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f01190b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01190b8:	83 e8 02             	sub    $0x2,%eax
f01190bb:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f01190c2:	83 ec 0c             	sub    $0xc,%esp
f01190c5:	50                   	push   %eax
f01190c6:	e8 c2 06 ff ff       	call   f010978d <kfree>
f01190cb:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f01190ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01190d1:	83 e8 03             	sub    $0x3,%eax
f01190d4:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f01190db:	83 ec 0c             	sub    $0xc,%esp
f01190de:	50                   	push   %eax
f01190df:	e8 a9 06 ff ff       	call   f010978d <kfree>
f01190e4:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01190e7:	e8 b9 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01190ec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01190ef:	74 17                	je     f0119108 <test_fastfirstfit+0x2a1>
f01190f1:	83 ec 04             	sub    $0x4,%esp
f01190f4:	68 6c ce 12 f0       	push   $0xf012ce6c
f01190f9:	68 fb 02 00 00       	push   $0x2fb
f01190fe:	68 53 ce 12 f0       	push   $0xf012ce53
f0119103:	e8 31 72 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0119108:	e8 5b 58 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011910d:	89 c2                	mov    %eax,%edx
f011910f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119112:	89 d1                	mov    %edx,%ecx
f0119114:	29 c1                	sub    %eax,%ecx
f0119116:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119119:	89 d0                	mov    %edx,%eax
f011911b:	c1 e0 02             	shl    $0x2,%eax
f011911e:	01 d0                	add    %edx,%eax
f0119120:	01 c0                	add    %eax,%eax
f0119122:	01 d0                	add    %edx,%eax
f0119124:	c1 e8 0c             	shr    $0xc,%eax
f0119127:	39 c1                	cmp    %eax,%ecx
f0119129:	74 17                	je     f0119142 <test_fastfirstfit+0x2db>
f011912b:	83 ec 04             	sub    $0x4,%esp
f011912e:	68 24 cf 12 f0       	push   $0xf012cf24
f0119133:	68 fc 02 00 00       	push   $0x2fc
f0119138:	68 53 ce 12 f0       	push   $0xf012ce53
f011913d:	e8 f7 71 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0119142:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119145:	01 c0                	add    %eax,%eax
f0119147:	89 c2                	mov    %eax,%edx
f0119149:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011914c:	d1 e8                	shr    %eax
f011914e:	01 d0                	add    %edx,%eax
f0119150:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119153:	e8 4d b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119158:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011915b:	e8 08 58 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119160:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119163:	83 ec 0c             	sub    $0xc,%esp
f0119166:	ff 75 dc             	pushl  -0x24(%ebp)
f0119169:	e8 a0 03 ff ff       	call   f010950e <kmalloc>
f011916e:	83 c4 10             	add    $0x10,%esp
f0119171:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0119174:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119177:	89 d0                	mov    %edx,%eax
f0119179:	c1 e0 02             	shl    $0x2,%eax
f011917c:	01 d0                	add    %edx,%eax
f011917e:	01 c0                	add    %eax,%eax
f0119180:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119186:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119189:	39 c2                	cmp    %eax,%edx
f011918b:	74 17                	je     f01191a4 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f011918d:	83 ec 04             	sub    $0x4,%esp
f0119190:	68 64 cf 12 f0       	push   $0xf012cf64
f0119195:	68 07 03 00 00       	push   $0x307
f011919a:	68 53 ce 12 f0       	push   $0xf012ce53
f011919f:	e8 95 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01191a4:	e8 fc b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191a9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01191ac:	74 17                	je     f01191c5 <test_fastfirstfit+0x35e>
f01191ae:	83 ec 04             	sub    $0x4,%esp
f01191b1:	68 6c ce 12 f0       	push   $0xf012ce6c
f01191b6:	68 08 03 00 00       	push   $0x308
f01191bb:	68 53 ce 12 f0       	push   $0xf012ce53
f01191c0:	e8 74 71 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01191c5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01191c8:	e8 9b 57 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01191cd:	29 c3                	sub    %eax,%ebx
f01191cf:	89 da                	mov    %ebx,%edx
f01191d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01191d4:	c1 e8 0c             	shr    $0xc,%eax
f01191d7:	39 c2                	cmp    %eax,%edx
f01191d9:	73 17                	jae    f01191f2 <test_fastfirstfit+0x38b>
f01191db:	83 ec 04             	sub    $0x4,%esp
f01191de:	68 d4 ce 12 f0       	push   $0xf012ced4
f01191e3:	68 09 03 00 00       	push   $0x309
f01191e8:	68 53 ce 12 f0       	push   $0xf012ce53
f01191ed:	e8 47 71 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f01191f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01191f5:	01 c0                	add    %eax,%eax
f01191f7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01191fa:	e8 a6 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119202:	e8 61 57 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119207:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011920a:	83 ec 0c             	sub    $0xc,%esp
f011920d:	ff 75 dc             	pushl  -0x24(%ebp)
f0119210:	e8 f9 02 ff ff       	call   f010950e <kmalloc>
f0119215:	83 c4 10             	add    $0x10,%esp
f0119218:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f011921b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011921e:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0119223:	01 c0                	add    %eax,%eax
f0119225:	89 c2                	mov    %eax,%edx
f0119227:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011922a:	39 c2                	cmp    %eax,%edx
f011922c:	74 17                	je     f0119245 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f011922e:	83 ec 04             	sub    $0x4,%esp
f0119231:	68 64 cf 12 f0       	push   $0xf012cf64
f0119236:	68 13 03 00 00       	push   $0x313
f011923b:	68 53 ce 12 f0       	push   $0xf012ce53
f0119240:	e8 f4 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119245:	e8 5b b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011924a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011924d:	74 17                	je     f0119266 <test_fastfirstfit+0x3ff>
f011924f:	83 ec 04             	sub    $0x4,%esp
f0119252:	68 6c ce 12 f0       	push   $0xf012ce6c
f0119257:	68 14 03 00 00       	push   $0x314
f011925c:	68 53 ce 12 f0       	push   $0xf012ce53
f0119261:	e8 d3 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119266:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119269:	e8 fa 56 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011926e:	29 c3                	sub    %eax,%ebx
f0119270:	89 da                	mov    %ebx,%edx
f0119272:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119275:	c1 e8 0c             	shr    $0xc,%eax
f0119278:	39 c2                	cmp    %eax,%edx
f011927a:	73 17                	jae    f0119293 <test_fastfirstfit+0x42c>
f011927c:	83 ec 04             	sub    $0x4,%esp
f011927f:	68 d4 ce 12 f0       	push   $0xf012ced4
f0119284:	68 15 03 00 00       	push   $0x315
f0119289:	68 53 ce 12 f0       	push   $0xf012ce53
f011928e:	e8 a6 70 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0119293:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119296:	89 c2                	mov    %eax,%edx
f0119298:	01 d2                	add    %edx,%edx
f011929a:	01 d0                	add    %edx,%eax
f011929c:	d1 e8                	shr    %eax
f011929e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01192a1:	e8 ff b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01192a9:	e8 ba 56 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01192ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01192b1:	83 ec 0c             	sub    $0xc,%esp
f01192b4:	ff 75 dc             	pushl  -0x24(%ebp)
f01192b7:	e8 52 02 ff ff       	call   f010950e <kmalloc>
f01192bc:	83 c4 10             	add    $0x10,%esp
f01192bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f01192c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01192c5:	83 e8 03             	sub    $0x3,%eax
f01192c8:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01192cc:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01192d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01192d5:	39 c2                	cmp    %eax,%edx
f01192d7:	74 17                	je     f01192f0 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f01192d9:	83 ec 04             	sub    $0x4,%esp
f01192dc:	68 64 cf 12 f0       	push   $0xf012cf64
f01192e1:	68 1f 03 00 00       	push   $0x31f
f01192e6:	68 53 ce 12 f0       	push   $0xf012ce53
f01192eb:	e8 49 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01192f0:	e8 b0 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192f5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01192f8:	74 17                	je     f0119311 <test_fastfirstfit+0x4aa>
f01192fa:	83 ec 04             	sub    $0x4,%esp
f01192fd:	68 6c ce 12 f0       	push   $0xf012ce6c
f0119302:	68 20 03 00 00       	push   $0x320
f0119307:	68 53 ce 12 f0       	push   $0xf012ce53
f011930c:	e8 28 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119311:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119314:	e8 4f 56 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119319:	29 c3                	sub    %eax,%ebx
f011931b:	89 da                	mov    %ebx,%edx
f011931d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119320:	c1 e8 0c             	shr    $0xc,%eax
f0119323:	39 c2                	cmp    %eax,%edx
f0119325:	73 17                	jae    f011933e <test_fastfirstfit+0x4d7>
f0119327:	83 ec 04             	sub    $0x4,%esp
f011932a:	68 d4 ce 12 f0       	push   $0xf012ced4
f011932f:	68 21 03 00 00       	push   $0x321
f0119334:	68 53 ce 12 f0       	push   $0xf012ce53
f0119339:	e8 fb 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011933e:	e8 62 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119343:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119346:	e8 1d 56 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011934b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011934e:	83 ec 0c             	sub    $0xc,%esp
f0119351:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119354:	e8 b5 01 ff ff       	call   f010950e <kmalloc>
f0119359:	83 c4 10             	add    $0x10,%esp
f011935c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f011935f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119362:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119367:	74 17                	je     f0119380 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119369:	83 ec 04             	sub    $0x4,%esp
f011936c:	68 64 cf 12 f0       	push   $0xf012cf64
f0119371:	68 2a 03 00 00       	push   $0x32a
f0119376:	68 53 ce 12 f0       	push   $0xf012ce53
f011937b:	e8 b9 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119380:	e8 20 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119385:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119388:	74 17                	je     f01193a1 <test_fastfirstfit+0x53a>
f011938a:	83 ec 04             	sub    $0x4,%esp
f011938d:	68 6c ce 12 f0       	push   $0xf012ce6c
f0119392:	68 2b 03 00 00       	push   $0x32b
f0119397:	68 53 ce 12 f0       	push   $0xf012ce53
f011939c:	e8 98 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01193a1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01193a4:	e8 bf 55 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01193a9:	29 c3                	sub    %eax,%ebx
f01193ab:	89 da                	mov    %ebx,%edx
f01193ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01193b0:	c1 e8 0c             	shr    $0xc,%eax
f01193b3:	39 c2                	cmp    %eax,%edx
f01193b5:	73 17                	jae    f01193ce <test_fastfirstfit+0x567>
f01193b7:	83 ec 04             	sub    $0x4,%esp
f01193ba:	68 d4 ce 12 f0       	push   $0xf012ced4
f01193bf:	68 2c 03 00 00       	push   $0x32c
f01193c4:	68 53 ce 12 f0       	push   $0xf012ce53
f01193c9:	e8 6b 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01193ce:	e8 d2 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01193d6:	e8 8d 55 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01193db:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01193de:	83 ec 0c             	sub    $0xc,%esp
f01193e1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01193e4:	e8 25 01 ff ff       	call   f010950e <kmalloc>
f01193e9:	83 c4 10             	add    $0x10,%esp
f01193ec:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f01193ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01193f2:	89 d0                	mov    %edx,%eax
f01193f4:	c1 e0 02             	shl    $0x2,%eax
f01193f7:	01 d0                	add    %edx,%eax
f01193f9:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01193ff:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119402:	39 c2                	cmp    %eax,%edx
f0119404:	74 17                	je     f011941d <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0119406:	83 ec 04             	sub    $0x4,%esp
f0119409:	68 64 cf 12 f0       	push   $0xf012cf64
f011940e:	68 35 03 00 00       	push   $0x335
f0119413:	68 53 ce 12 f0       	push   $0xf012ce53
f0119418:	e8 1c 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011941d:	e8 83 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119422:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119425:	74 17                	je     f011943e <test_fastfirstfit+0x5d7>
f0119427:	83 ec 04             	sub    $0x4,%esp
f011942a:	68 6c ce 12 f0       	push   $0xf012ce6c
f011942f:	68 36 03 00 00       	push   $0x336
f0119434:	68 53 ce 12 f0       	push   $0xf012ce53
f0119439:	e8 fb 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011943e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119441:	e8 22 55 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119446:	29 c3                	sub    %eax,%ebx
f0119448:	89 da                	mov    %ebx,%edx
f011944a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011944d:	c1 e8 0c             	shr    $0xc,%eax
f0119450:	39 c2                	cmp    %eax,%edx
f0119452:	73 17                	jae    f011946b <test_fastfirstfit+0x604>
f0119454:	83 ec 04             	sub    $0x4,%esp
f0119457:	68 d4 ce 12 f0       	push   $0xf012ced4
f011945c:	68 37 03 00 00       	push   $0x337
f0119461:	68 53 ce 12 f0       	push   $0xf012ce53
f0119466:	e8 ce 6e fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011946b:	e8 35 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119470:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119473:	e8 f0 54 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119478:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011947b:	83 ec 0c             	sub    $0xc,%esp
f011947e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119481:	e8 88 00 ff ff       	call   f010950e <kmalloc>
f0119486:	83 c4 10             	add    $0x10,%esp
f0119489:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f011948c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011948f:	89 d0                	mov    %edx,%eax
f0119491:	c1 e0 02             	shl    $0x2,%eax
f0119494:	01 d0                	add    %edx,%eax
f0119496:	c1 e0 02             	shl    $0x2,%eax
f0119499:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011949f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01194a2:	39 c2                	cmp    %eax,%edx
f01194a4:	74 17                	je     f01194bd <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f01194a6:	83 ec 04             	sub    $0x4,%esp
f01194a9:	68 64 cf 12 f0       	push   $0xf012cf64
f01194ae:	68 40 03 00 00       	push   $0x340
f01194b3:	68 53 ce 12 f0       	push   $0xf012ce53
f01194b8:	e8 7c 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01194bd:	e8 e3 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194c2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01194c5:	74 17                	je     f01194de <test_fastfirstfit+0x677>
f01194c7:	83 ec 04             	sub    $0x4,%esp
f01194ca:	68 6c ce 12 f0       	push   $0xf012ce6c
f01194cf:	68 41 03 00 00       	push   $0x341
f01194d4:	68 53 ce 12 f0       	push   $0xf012ce53
f01194d9:	e8 5b 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01194de:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01194e1:	e8 82 54 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01194e6:	29 c3                	sub    %eax,%ebx
f01194e8:	89 da                	mov    %ebx,%edx
f01194ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194ed:	c1 e8 0c             	shr    $0xc,%eax
f01194f0:	39 c2                	cmp    %eax,%edx
f01194f2:	73 17                	jae    f011950b <test_fastfirstfit+0x6a4>
f01194f4:	83 ec 04             	sub    $0x4,%esp
f01194f7:	68 d4 ce 12 f0       	push   $0xf012ced4
f01194fc:	68 42 03 00 00       	push   $0x342
f0119501:	68 53 ce 12 f0       	push   $0xf012ce53
f0119506:	e8 2e 6e fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011950b:	e8 95 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119510:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119513:	e8 50 54 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119518:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011951b:	83 ec 0c             	sub    $0xc,%esp
f011951e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119521:	e8 e8 ff fe ff       	call   f010950e <kmalloc>
f0119526:	83 c4 10             	add    $0x10,%esp
f0119529:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f011952c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011952f:	89 d0                	mov    %edx,%eax
f0119531:	c1 e0 02             	shl    $0x2,%eax
f0119534:	01 d0                	add    %edx,%eax
f0119536:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011953d:	01 d0                	add    %edx,%eax
f011953f:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119545:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119548:	39 c2                	cmp    %eax,%edx
f011954a:	74 17                	je     f0119563 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f011954c:	83 ec 04             	sub    $0x4,%esp
f011954f:	68 64 cf 12 f0       	push   $0xf012cf64
f0119554:	68 4b 03 00 00       	push   $0x34b
f0119559:	68 53 ce 12 f0       	push   $0xf012ce53
f011955e:	e8 d6 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119563:	e8 3d b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119568:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011956b:	74 17                	je     f0119584 <test_fastfirstfit+0x71d>
f011956d:	83 ec 04             	sub    $0x4,%esp
f0119570:	68 6c ce 12 f0       	push   $0xf012ce6c
f0119575:	68 4c 03 00 00       	push   $0x34c
f011957a:	68 53 ce 12 f0       	push   $0xf012ce53
f011957f:	e8 b5 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119584:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119587:	e8 dc 53 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011958c:	29 c3                	sub    %eax,%ebx
f011958e:	89 da                	mov    %ebx,%edx
f0119590:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119593:	c1 e8 0c             	shr    $0xc,%eax
f0119596:	39 c2                	cmp    %eax,%edx
f0119598:	73 17                	jae    f01195b1 <test_fastfirstfit+0x74a>
f011959a:	83 ec 04             	sub    $0x4,%esp
f011959d:	68 d4 ce 12 f0       	push   $0xf012ced4
f01195a2:	68 4d 03 00 00       	push   $0x34d
f01195a7:	68 53 ce 12 f0       	push   $0xf012ce53
f01195ac:	e8 88 6d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01195b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195b4:	d1 e8                	shr    %eax
f01195b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01195b9:	e8 e7 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195be:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01195c1:	e8 a2 53 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01195c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01195c9:	83 ec 0c             	sub    $0xc,%esp
f01195cc:	ff 75 dc             	pushl  -0x24(%ebp)
f01195cf:	e8 3a ff fe ff       	call   f010950e <kmalloc>
f01195d4:	83 c4 10             	add    $0x10,%esp
f01195d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f01195da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01195dd:	89 d0                	mov    %edx,%eax
f01195df:	c1 e0 02             	shl    $0x2,%eax
f01195e2:	01 d0                	add    %edx,%eax
f01195e4:	01 c0                	add    %eax,%eax
f01195e6:	89 c1                	mov    %eax,%ecx
f01195e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01195eb:	89 d0                	mov    %edx,%eax
f01195ed:	c1 e0 02             	shl    $0x2,%eax
f01195f0:	01 d0                	add    %edx,%eax
f01195f2:	d1 e8                	shr    %eax
f01195f4:	01 c8                	add    %ecx,%eax
f01195f6:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01195fc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01195ff:	39 c2                	cmp    %eax,%edx
f0119601:	74 17                	je     f011961a <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0119603:	83 ec 04             	sub    $0x4,%esp
f0119606:	68 64 cf 12 f0       	push   $0xf012cf64
f011960b:	68 57 03 00 00       	push   $0x357
f0119610:	68 53 ce 12 f0       	push   $0xf012ce53
f0119615:	e8 1f 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011961a:	e8 86 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011961f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119622:	74 17                	je     f011963b <test_fastfirstfit+0x7d4>
f0119624:	83 ec 04             	sub    $0x4,%esp
f0119627:	68 6c ce 12 f0       	push   $0xf012ce6c
f011962c:	68 58 03 00 00       	push   $0x358
f0119631:	68 53 ce 12 f0       	push   $0xf012ce53
f0119636:	e8 fe 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011963b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011963e:	e8 25 53 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119643:	29 c3                	sub    %eax,%ebx
f0119645:	89 da                	mov    %ebx,%edx
f0119647:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011964a:	c1 e8 0c             	shr    $0xc,%eax
f011964d:	39 c2                	cmp    %eax,%edx
f011964f:	73 17                	jae    f0119668 <test_fastfirstfit+0x801>
f0119651:	83 ec 04             	sub    $0x4,%esp
f0119654:	68 d4 ce 12 f0       	push   $0xf012ced4
f0119659:	68 59 03 00 00       	push   $0x359
f011965e:	68 53 ce 12 f0       	push   $0xf012ce53
f0119663:	e8 d1 6c fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011966b:	d1 e8                	shr    %eax
f011966d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119670:	e8 30 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119675:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119678:	e8 eb 52 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011967d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119680:	83 ec 0c             	sub    $0xc,%esp
f0119683:	ff 75 dc             	pushl  -0x24(%ebp)
f0119686:	e8 83 fe fe ff       	call   f010950e <kmalloc>
f011968b:	83 c4 10             	add    $0x10,%esp
f011968e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0119691:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119694:	83 e8 03             	sub    $0x3,%eax
f0119697:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f011969b:	89 c2                	mov    %eax,%edx
f011969d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01196a0:	89 c1                	mov    %eax,%ecx
f01196a2:	01 c9                	add    %ecx,%ecx
f01196a4:	01 c8                	add    %ecx,%eax
f01196a6:	d1 e8                	shr    %eax
f01196a8:	01 d0                	add    %edx,%eax
f01196aa:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01196b0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01196b3:	39 c2                	cmp    %eax,%edx
f01196b5:	74 17                	je     f01196ce <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f01196b7:	83 ec 04             	sub    $0x4,%esp
f01196ba:	68 64 cf 12 f0       	push   $0xf012cf64
f01196bf:	68 63 03 00 00       	push   $0x363
f01196c4:	68 53 ce 12 f0       	push   $0xf012ce53
f01196c9:	e8 6b 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01196ce:	e8 d2 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01196d6:	74 17                	je     f01196ef <test_fastfirstfit+0x888>
f01196d8:	83 ec 04             	sub    $0x4,%esp
f01196db:	68 6c ce 12 f0       	push   $0xf012ce6c
f01196e0:	68 64 03 00 00       	push   $0x364
f01196e5:	68 53 ce 12 f0       	push   $0xf012ce53
f01196ea:	e8 4a 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01196ef:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01196f2:	e8 71 52 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01196f7:	29 c3                	sub    %eax,%ebx
f01196f9:	89 da                	mov    %ebx,%edx
f01196fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01196fe:	c1 e8 0c             	shr    $0xc,%eax
f0119701:	39 c2                	cmp    %eax,%edx
f0119703:	73 17                	jae    f011971c <test_fastfirstfit+0x8b5>
f0119705:	83 ec 04             	sub    $0x4,%esp
f0119708:	68 d4 ce 12 f0       	push   $0xf012ced4
f011970d:	68 65 03 00 00       	push   $0x365
f0119712:	68 53 ce 12 f0       	push   $0xf012ce53
f0119717:	e8 1d 6c fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f011971c:	83 ec 0c             	sub    $0xc,%esp
f011971f:	68 84 cf 12 f0       	push   $0xf012cf84
f0119724:	e8 62 78 fe ff       	call   f0100f8b <cprintf>
f0119729:	83 c4 10             	add    $0x10,%esp
	return 1;
f011972c:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119731:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0119734:	c9                   	leave  
f0119735:	c3                   	ret    

f0119736 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0119736:	55                   	push   %ebp
f0119737:	89 e5                	mov    %esp,%ebp
f0119739:	57                   	push   %edi
f011973a:	53                   	push   %ebx
f011973b:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119741:	83 ec 0c             	sub    $0xc,%esp
f0119744:	68 08 af 12 f0       	push   $0xf012af08
f0119749:	e8 3d 78 fe ff       	call   f0100f8b <cprintf>
f011974e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119751:	83 ec 0c             	sub    $0xc,%esp
f0119754:	68 38 af 12 f0       	push   $0xf012af38
f0119759:	e8 2d 78 fe ff       	call   f0100f8b <cprintf>
f011975e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119761:	83 ec 0c             	sub    $0xc,%esp
f0119764:	68 08 af 12 f0       	push   $0xf012af08
f0119769:	e8 1d 78 fe ff       	call   f0100f8b <cprintf>
f011976e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119771:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0119775:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0119779:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011977f:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0119785:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011978c:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119793:	e8 d0 51 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119798:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011979b:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f01197a1:	b9 14 00 00 00       	mov    $0x14,%ecx
f01197a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01197ab:	89 d7                	mov    %edx,%edi
f01197ad:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01197af:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f01197b5:	b9 14 00 00 00       	mov    $0x14,%ecx
f01197ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01197bf:	89 d7                	mov    %edx,%edi
f01197c1:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f01197c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f01197ca:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f01197d1:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f01197d8:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f01197de:	b9 14 00 00 00       	mov    $0x14,%ecx
f01197e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01197e8:	89 d7                	mov    %edx,%edi
f01197ea:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f01197ec:	83 ec 0c             	sub    $0xc,%esp
f01197ef:	68 c8 cf 12 f0       	push   $0xf012cfc8
f01197f4:	e8 92 77 fe ff       	call   f0100f8b <cprintf>
f01197f9:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01197fc:	e8 67 51 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119801:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119804:	e8 9c b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119809:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011980c:	83 ec 0c             	sub    $0xc,%esp
f011980f:	68 00 fc 1f 00       	push   $0x1ffc00
f0119814:	e8 f5 fc fe ff       	call   f010950e <kmalloc>
f0119819:	83 c4 10             	add    $0x10,%esp
f011981c:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119822:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119828:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011982d:	74 17                	je     f0119846 <test_kfree_bestfirstfit+0x110>
f011982f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119836:	83 ec 0c             	sub    $0xc,%esp
f0119839:	68 00 d0 12 f0       	push   $0xf012d000
f011983e:	e8 48 77 fe ff       	call   f0100f8b <cprintf>
f0119843:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119846:	e8 5a b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011984b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011984e:	74 17                	je     f0119867 <test_kfree_bestfirstfit+0x131>
f0119850:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119857:	83 ec 0c             	sub    $0xc,%esp
f011985a:	68 54 d0 12 f0       	push   $0xf012d054
f011985f:	e8 27 77 fe ff       	call   f0100f8b <cprintf>
f0119864:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119867:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011986a:	e8 f9 50 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011986f:	29 c3                	sub    %eax,%ebx
f0119871:	89 d8                	mov    %ebx,%eax
f0119873:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119878:	77 17                	ja     f0119891 <test_kfree_bestfirstfit+0x15b>
f011987a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119881:	83 ec 0c             	sub    $0xc,%esp
f0119884:	68 c4 d0 12 f0       	push   $0xf012d0c4
f0119889:	e8 fd 76 fe ff       	call   f0100f8b <cprintf>
f011988e:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f0119891:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0119898:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011989b:	e8 c8 50 ff ff       	call   f010e968 <sys_calculate_free_frames>
f01198a0:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01198a3:	e8 fd af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198a8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01198ab:	83 ec 0c             	sub    $0xc,%esp
f01198ae:	68 00 fc 1f 00       	push   $0x1ffc00
f01198b3:	e8 56 fc fe ff       	call   f010950e <kmalloc>
f01198b8:	83 c4 10             	add    $0x10,%esp
f01198bb:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01198c1:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f01198c7:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01198cc:	74 17                	je     f01198e5 <test_kfree_bestfirstfit+0x1af>
f01198ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198d5:	83 ec 0c             	sub    $0xc,%esp
f01198d8:	68 0c d1 12 f0       	push   $0xf012d10c
f01198dd:	e8 a9 76 fe ff       	call   f0100f8b <cprintf>
f01198e2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198e5:	e8 bb af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198ea:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01198ed:	74 17                	je     f0119906 <test_kfree_bestfirstfit+0x1d0>
f01198ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198f6:	83 ec 0c             	sub    $0xc,%esp
f01198f9:	68 60 d1 12 f0       	push   $0xf012d160
f01198fe:	e8 88 76 fe ff       	call   f0100f8b <cprintf>
f0119903:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119906:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119909:	e8 5a 50 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011990e:	29 c3                	sub    %eax,%ebx
f0119910:	89 d8                	mov    %ebx,%eax
f0119912:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119917:	77 17                	ja     f0119930 <test_kfree_bestfirstfit+0x1fa>
f0119919:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119920:	83 ec 0c             	sub    $0xc,%esp
f0119923:	68 d0 d1 12 f0       	push   $0xf012d1d0
f0119928:	e8 5e 76 fe ff       	call   f0100f8b <cprintf>
f011992d:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119930:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0119937:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011993a:	e8 29 50 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011993f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119942:	e8 5e af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119947:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011994a:	83 ec 0c             	sub    $0xc,%esp
f011994d:	68 00 1c 00 00       	push   $0x1c00
f0119952:	e8 b7 fb fe ff       	call   f010950e <kmalloc>
f0119957:	83 c4 10             	add    $0x10,%esp
f011995a:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119960:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119966:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011996b:	74 17                	je     f0119984 <test_kfree_bestfirstfit+0x24e>
f011996d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119974:	83 ec 0c             	sub    $0xc,%esp
f0119977:	68 18 d2 12 f0       	push   $0xf012d218
f011997c:	e8 0a 76 fe ff       	call   f0100f8b <cprintf>
f0119981:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119984:	e8 1c af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119989:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011998c:	74 17                	je     f01199a5 <test_kfree_bestfirstfit+0x26f>
f011998e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119995:	83 ec 0c             	sub    $0xc,%esp
f0119998:	68 6c d2 12 f0       	push   $0xf012d26c
f011999d:	e8 e9 75 fe ff       	call   f0100f8b <cprintf>
f01199a2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01199a5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01199a8:	e8 bb 4f ff ff       	call   f010e968 <sys_calculate_free_frames>
f01199ad:	29 c3                	sub    %eax,%ebx
f01199af:	89 d8                	mov    %ebx,%eax
f01199b1:	83 f8 01             	cmp    $0x1,%eax
f01199b4:	77 17                	ja     f01199cd <test_kfree_bestfirstfit+0x297>
f01199b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199bd:	83 ec 0c             	sub    $0xc,%esp
f01199c0:	68 dc d2 12 f0       	push   $0xf012d2dc
f01199c5:	e8 c1 75 fe ff       	call   f0100f8b <cprintf>
f01199ca:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f01199cd:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f01199d4:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f01199d7:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01199dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f01199e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199e7:	eb 0e                	jmp    f01199f7 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f01199e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01199ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199ef:	01 d0                	add    %edx,%eax
f01199f1:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f01199f4:	ff 45 f4             	incl   -0xc(%ebp)
f01199f7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01199fd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a00:	7f e7                	jg     f01199e9 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119a02:	e8 61 4f ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119a07:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119a0a:	e8 96 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119a12:	83 ec 0c             	sub    $0xc,%esp
f0119a15:	68 00 fc 2f 00       	push   $0x2ffc00
f0119a1a:	e8 ef fa fe ff       	call   f010950e <kmalloc>
f0119a1f:	83 c4 10             	add    $0x10,%esp
f0119a22:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a28:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119a2e:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119a33:	74 17                	je     f0119a4c <test_kfree_bestfirstfit+0x316>
f0119a35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a3c:	83 ec 0c             	sub    $0xc,%esp
f0119a3f:	68 24 d3 12 f0       	push   $0xf012d324
f0119a44:	e8 42 75 fe ff       	call   f0100f8b <cprintf>
f0119a49:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a4c:	e8 54 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a51:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a54:	74 17                	je     f0119a6d <test_kfree_bestfirstfit+0x337>
f0119a56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a5d:	83 ec 0c             	sub    $0xc,%esp
f0119a60:	68 78 d3 12 f0       	push   $0xf012d378
f0119a65:	e8 21 75 fe ff       	call   f0100f8b <cprintf>
f0119a6a:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a6d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119a70:	e8 f3 4e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119a75:	29 c3                	sub    %eax,%ebx
f0119a77:	89 d8                	mov    %ebx,%eax
f0119a79:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119a7e:	77 17                	ja     f0119a97 <test_kfree_bestfirstfit+0x361>
f0119a80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a87:	83 ec 0c             	sub    $0xc,%esp
f0119a8a:	68 e8 d3 12 f0       	push   $0xf012d3e8
f0119a8f:	e8 f7 74 fe ff       	call   f0100f8b <cprintf>
f0119a94:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119a97:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119a9e:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119aa1:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119aa7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119aaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119ab1:	eb 0e                	jmp    f0119ac1 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119ab3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119ab6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ab9:	01 d0                	add    %edx,%eax
f0119abb:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119abe:	ff 45 f4             	incl   -0xc(%ebp)
f0119ac1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119ac7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119aca:	7f e7                	jg     f0119ab3 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119acc:	e8 97 4e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119ad1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ad4:	e8 cc ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ad9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119adc:	83 ec 0c             	sub    $0xc,%esp
f0119adf:	68 00 fc 5f 00       	push   $0x5ffc00
f0119ae4:	e8 25 fa fe ff       	call   f010950e <kmalloc>
f0119ae9:	83 c4 10             	add    $0x10,%esp
f0119aec:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119af2:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119af8:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119afd:	74 17                	je     f0119b16 <test_kfree_bestfirstfit+0x3e0>
f0119aff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b06:	83 ec 0c             	sub    $0xc,%esp
f0119b09:	68 30 d4 12 f0       	push   $0xf012d430
f0119b0e:	e8 78 74 fe ff       	call   f0100f8b <cprintf>
f0119b13:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b16:	e8 8a ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b1b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b1e:	74 17                	je     f0119b37 <test_kfree_bestfirstfit+0x401>
f0119b20:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b27:	83 ec 0c             	sub    $0xc,%esp
f0119b2a:	68 84 d4 12 f0       	push   $0xf012d484
f0119b2f:	e8 57 74 fe ff       	call   f0100f8b <cprintf>
f0119b34:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b37:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b3a:	e8 29 4e ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119b3f:	29 c3                	sub    %eax,%ebx
f0119b41:	89 d8                	mov    %ebx,%eax
f0119b43:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119b48:	77 17                	ja     f0119b61 <test_kfree_bestfirstfit+0x42b>
f0119b4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b51:	83 ec 0c             	sub    $0xc,%esp
f0119b54:	68 f4 d4 12 f0       	push   $0xf012d4f4
f0119b59:	e8 2d 74 fe ff       	call   f0100f8b <cprintf>
f0119b5e:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119b61:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119b68:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119b6b:	e8 f8 4d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119b70:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b73:	e8 2d ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b78:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119b7b:	83 ec 0c             	sub    $0xc,%esp
f0119b7e:	68 00 38 00 00       	push   $0x3800
f0119b83:	e8 86 f9 fe ff       	call   f010950e <kmalloc>
f0119b88:	83 c4 10             	add    $0x10,%esp
f0119b8b:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b91:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119b97:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119b9c:	74 17                	je     f0119bb5 <test_kfree_bestfirstfit+0x47f>
f0119b9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ba5:	83 ec 0c             	sub    $0xc,%esp
f0119ba8:	68 3c d5 12 f0       	push   $0xf012d53c
f0119bad:	e8 d9 73 fe ff       	call   f0100f8b <cprintf>
f0119bb2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bb5:	e8 eb ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bba:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119bbd:	74 17                	je     f0119bd6 <test_kfree_bestfirstfit+0x4a0>
f0119bbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bc6:	83 ec 0c             	sub    $0xc,%esp
f0119bc9:	68 90 d5 12 f0       	push   $0xf012d590
f0119bce:	e8 b8 73 fe ff       	call   f0100f8b <cprintf>
f0119bd3:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119bd6:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119bd9:	e8 8a 4d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119bde:	29 c3                	sub    %eax,%ebx
f0119be0:	89 d8                	mov    %ebx,%eax
f0119be2:	83 f8 03             	cmp    $0x3,%eax
f0119be5:	77 17                	ja     f0119bfe <test_kfree_bestfirstfit+0x4c8>
f0119be7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bee:	83 ec 0c             	sub    $0xc,%esp
f0119bf1:	68 00 d6 12 f0       	push   $0xf012d600
f0119bf6:	e8 90 73 fe ff       	call   f0100f8b <cprintf>
f0119bfb:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119bfe:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119c05:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119c0b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119c0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c15:	eb 0e                	jmp    f0119c25 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119c17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c1a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c1d:	01 d0                	add    %edx,%eax
f0119c1f:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119c22:	ff 45 f4             	incl   -0xc(%ebp)
f0119c25:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119c28:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c2b:	7f ea                	jg     f0119c17 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119c2d:	e8 36 4d ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119c32:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c35:	e8 6b ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c3a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119c3d:	83 ec 0c             	sub    $0xc,%esp
f0119c40:	68 00 08 00 00       	push   $0x800
f0119c45:	e8 c4 f8 fe ff       	call   f010950e <kmalloc>
f0119c4a:	83 c4 10             	add    $0x10,%esp
f0119c4d:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119c53:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119c59:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119c5e:	76 28                	jbe    f0119c88 <test_kfree_bestfirstfit+0x552>
f0119c60:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119c66:	83 ec 0c             	sub    $0xc,%esp
f0119c69:	6a 00                	push   $0x0
f0119c6b:	e8 6b f7 fe ff       	call   f01093db <sbrk>
f0119c70:	83 c4 10             	add    $0x10,%esp
f0119c73:	39 c3                	cmp    %eax,%ebx
f0119c75:	73 11                	jae    f0119c88 <test_kfree_bestfirstfit+0x552>
f0119c77:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119c7d:	89 c2                	mov    %eax,%edx
f0119c7f:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119c84:	39 c2                	cmp    %eax,%edx
f0119c86:	72 17                	jb     f0119c9f <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119c88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c8f:	83 ec 0c             	sub    $0xc,%esp
f0119c92:	68 48 d6 12 f0       	push   $0xf012d648
f0119c97:	e8 ef 72 fe ff       	call   f0100f8b <cprintf>
f0119c9c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c9f:	e8 01 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ca4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119ca7:	74 17                	je     f0119cc0 <test_kfree_bestfirstfit+0x58a>
f0119ca9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cb0:	83 ec 0c             	sub    $0xc,%esp
f0119cb3:	68 d4 d6 12 f0       	push   $0xf012d6d4
f0119cb8:	e8 ce 72 fe ff       	call   f0100f8b <cprintf>
f0119cbd:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119cc0:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119cc7:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119cca:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119cd0:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119cd3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119cda:	eb 0e                	jmp    f0119cea <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119cdc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119cdf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ce2:	01 d0                	add    %edx,%eax
f0119ce4:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119ce7:	ff 45 f4             	incl   -0xc(%ebp)
f0119cea:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119cf0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119cf3:	7f e7                	jg     f0119cdc <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119cf5:	e8 ab ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cfa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119cfd:	83 ec 0c             	sub    $0xc,%esp
f0119d00:	68 00 08 00 00       	push   $0x800
f0119d05:	e8 04 f8 fe ff       	call   f010950e <kmalloc>
f0119d0a:	83 c4 10             	add    $0x10,%esp
f0119d0d:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119d13:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d19:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119d1e:	76 28                	jbe    f0119d48 <test_kfree_bestfirstfit+0x612>
f0119d20:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119d26:	83 ec 0c             	sub    $0xc,%esp
f0119d29:	6a 00                	push   $0x0
f0119d2b:	e8 ab f6 fe ff       	call   f01093db <sbrk>
f0119d30:	83 c4 10             	add    $0x10,%esp
f0119d33:	39 c3                	cmp    %eax,%ebx
f0119d35:	73 11                	jae    f0119d48 <test_kfree_bestfirstfit+0x612>
f0119d37:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d3d:	89 c2                	mov    %eax,%edx
f0119d3f:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119d44:	39 c2                	cmp    %eax,%edx
f0119d46:	72 17                	jb     f0119d5f <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119d48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d4f:	83 ec 0c             	sub    $0xc,%esp
f0119d52:	68 44 d7 12 f0       	push   $0xf012d744
f0119d57:	e8 2f 72 fe ff       	call   f0100f8b <cprintf>
f0119d5c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d5f:	e8 41 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d64:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d67:	74 17                	je     f0119d80 <test_kfree_bestfirstfit+0x64a>
f0119d69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d70:	83 ec 0c             	sub    $0xc,%esp
f0119d73:	68 d0 d7 12 f0       	push   $0xf012d7d0
f0119d78:	e8 0e 72 fe ff       	call   f0100f8b <cprintf>
f0119d7d:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119d80:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0119d87:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0119d8a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d90:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119d93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d9a:	eb 0e                	jmp    f0119daa <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119d9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d9f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119da2:	01 d0                	add    %edx,%eax
f0119da4:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0119da7:	ff 45 f4             	incl   -0xc(%ebp)
f0119daa:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119db0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119db3:	7f e7                	jg     f0119d9c <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119db5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119db8:	e8 ab 4b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119dbd:	29 c3                	sub    %eax,%ebx
f0119dbf:	89 d8                	mov    %ebx,%eax
f0119dc1:	83 f8 01             	cmp    $0x1,%eax
f0119dc4:	74 17                	je     f0119ddd <test_kfree_bestfirstfit+0x6a7>
f0119dc6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dcd:	83 ec 0c             	sub    $0xc,%esp
f0119dd0:	68 40 d8 12 f0       	push   $0xf012d840
f0119dd5:	e8 b1 71 fe ff       	call   f0100f8b <cprintf>
f0119dda:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119ddd:	83 ec 0c             	sub    $0xc,%esp
f0119de0:	68 64 d8 12 f0       	push   $0xf012d864
f0119de5:	e8 a1 71 fe ff       	call   f0100f8b <cprintf>
f0119dea:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119ded:	e8 76 4b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119df2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119df5:	e8 ab aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119dfa:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119dfd:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119e03:	83 ec 0c             	sub    $0xc,%esp
f0119e06:	50                   	push   %eax
f0119e07:	e8 81 f9 fe ff       	call   f010978d <kfree>
f0119e0c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e0f:	e8 91 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e14:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e17:	74 17                	je     f0119e30 <test_kfree_bestfirstfit+0x6fa>
f0119e19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e20:	83 ec 0c             	sub    $0xc,%esp
f0119e23:	68 94 d8 12 f0       	push   $0xf012d894
f0119e28:	e8 5e 71 fe ff       	call   f0100f8b <cprintf>
f0119e2d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e30:	e8 33 4b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119e35:	89 c2                	mov    %eax,%edx
f0119e37:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119e3a:	29 c2                	sub    %eax,%edx
f0119e3c:	89 d0                	mov    %edx,%eax
f0119e3e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e43:	77 17                	ja     f0119e5c <test_kfree_bestfirstfit+0x726>
f0119e45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e4c:	83 ec 0c             	sub    $0xc,%esp
f0119e4f:	68 04 d9 12 f0       	push   $0xf012d904
f0119e54:	e8 32 71 fe ff       	call   f0100f8b <cprintf>
f0119e59:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0119e5c:	e8 07 4b ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119e61:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e64:	e8 3c aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e69:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f0119e6c:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119e72:	83 ec 0c             	sub    $0xc,%esp
f0119e75:	50                   	push   %eax
f0119e76:	e8 12 f9 fe ff       	call   f010978d <kfree>
f0119e7b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e7e:	e8 22 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e83:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e86:	74 17                	je     f0119e9f <test_kfree_bestfirstfit+0x769>
f0119e88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e8f:	83 ec 0c             	sub    $0xc,%esp
f0119e92:	68 40 d9 12 f0       	push   $0xf012d940
f0119e97:	e8 ef 70 fe ff       	call   f0100f8b <cprintf>
f0119e9c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119e9f:	e8 c4 4a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119ea4:	89 c2                	mov    %eax,%edx
f0119ea6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119ea9:	39 c2                	cmp    %eax,%edx
f0119eab:	74 17                	je     f0119ec4 <test_kfree_bestfirstfit+0x78e>
f0119ead:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eb4:	83 ec 0c             	sub    $0xc,%esp
f0119eb7:	68 b0 d9 12 f0       	push   $0xf012d9b0
f0119ebc:	e8 ca 70 fe ff       	call   f0100f8b <cprintf>
f0119ec1:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119ec4:	e8 9f 4a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119ec9:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119ecc:	e8 d4 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ed1:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119ed4:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119eda:	83 ec 0c             	sub    $0xc,%esp
f0119edd:	50                   	push   %eax
f0119ede:	e8 aa f8 fe ff       	call   f010978d <kfree>
f0119ee3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ee6:	e8 ba a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119eeb:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119eee:	74 17                	je     f0119f07 <test_kfree_bestfirstfit+0x7d1>
f0119ef0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ef7:	83 ec 0c             	sub    $0xc,%esp
f0119efa:	68 10 da 12 f0       	push   $0xf012da10
f0119eff:	e8 87 70 fe ff       	call   f0100f8b <cprintf>
f0119f04:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f07:	e8 5c 4a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119f0c:	89 c2                	mov    %eax,%edx
f0119f0e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119f11:	29 c2                	sub    %eax,%edx
f0119f13:	89 d0                	mov    %edx,%eax
f0119f15:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119f1a:	77 17                	ja     f0119f33 <test_kfree_bestfirstfit+0x7fd>
f0119f1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f23:	83 ec 0c             	sub    $0xc,%esp
f0119f26:	68 80 da 12 f0       	push   $0xf012da80
f0119f2b:	e8 5b 70 fe ff       	call   f0100f8b <cprintf>
f0119f30:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119f33:	e8 30 4a ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119f38:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119f3b:	e8 65 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f40:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0119f43:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119f49:	83 ec 0c             	sub    $0xc,%esp
f0119f4c:	50                   	push   %eax
f0119f4d:	e8 3b f8 fe ff       	call   f010978d <kfree>
f0119f52:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f55:	e8 4b a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f5a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119f5d:	74 17                	je     f0119f76 <test_kfree_bestfirstfit+0x840>
f0119f5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f66:	83 ec 0c             	sub    $0xc,%esp
f0119f69:	68 bc da 12 f0       	push   $0xf012dabc
f0119f6e:	e8 18 70 fe ff       	call   f0100f8b <cprintf>
f0119f73:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f76:	e8 ed 49 ff ff       	call   f010e968 <sys_calculate_free_frames>
f0119f7b:	89 c2                	mov    %eax,%edx
f0119f7d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119f80:	29 c2                	sub    %eax,%edx
f0119f82:	89 d0                	mov    %edx,%eax
f0119f84:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119f89:	77 17                	ja     f0119fa2 <test_kfree_bestfirstfit+0x86c>
f0119f8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f92:	83 ec 0c             	sub    $0xc,%esp
f0119f95:	68 2c db 12 f0       	push   $0xf012db2c
f0119f9a:	e8 ec 6f fe ff       	call   f0100f8b <cprintf>
f0119f9f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119fa2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119fa6:	74 04                	je     f0119fac <test_kfree_bestfirstfit+0x876>
f0119fa8:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119fac:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0119fb3:	83 ec 0c             	sub    $0xc,%esp
f0119fb6:	68 68 db 12 f0       	push   $0xf012db68
f0119fbb:	e8 cb 6f fe ff       	call   f0100f8b <cprintf>
f0119fc0:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0119fc3:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119fc9:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0119fcc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119fd3:	eb 1e                	jmp    f0119ff3 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0119fd5:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119fdb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119fde:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fe1:	01 c8                	add    %ecx,%eax
f0119fe3:	8a 00                	mov    (%eax),%al
f0119fe5:	0f be c0             	movsbl %al,%eax
f0119fe8:	01 d0                	add    %edx,%eax
f0119fea:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119ff0:	ff 45 f4             	incl   -0xc(%ebp)
f0119ff3:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119ff9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119ffc:	7f d7                	jg     f0119fd5 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119ffe:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a004:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a00a:	89 c1                	mov    %eax,%ecx
f011a00c:	01 c9                	add    %ecx,%ecx
f011a00e:	01 c8                	add    %ecx,%eax
f011a010:	39 c2                	cmp    %eax,%edx
f011a012:	74 17                	je     f011a02b <test_kfree_bestfirstfit+0x8f5>
f011a014:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a01b:	83 ec 0c             	sub    $0xc,%esp
f011a01e:	68 b0 db 12 f0       	push   $0xf012dbb0
f011a023:	e8 63 6f fe ff       	call   f0100f8b <cprintf>
f011a028:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011a02b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a031:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011a034:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a03b:	eb 1e                	jmp    f011a05b <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011a03d:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011a043:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a046:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a049:	01 c8                	add    %ecx,%eax
f011a04b:	8a 00                	mov    (%eax),%al
f011a04d:	0f be c0             	movsbl %al,%eax
f011a050:	01 d0                	add    %edx,%eax
f011a052:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011a058:	ff 45 f4             	incl   -0xc(%ebp)
f011a05b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a061:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a064:	7f d7                	jg     f011a03d <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a066:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a06c:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a072:	c1 e2 02             	shl    $0x2,%edx
f011a075:	39 d0                	cmp    %edx,%eax
f011a077:	74 17                	je     f011a090 <test_kfree_bestfirstfit+0x95a>
f011a079:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a080:	83 ec 0c             	sub    $0xc,%esp
f011a083:	68 e8 db 12 f0       	push   $0xf012dbe8
f011a088:	e8 fe 6e fe ff       	call   f0100f8b <cprintf>
f011a08d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a090:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a096:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a099:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a0a0:	eb 1e                	jmp    f011a0c0 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a0a2:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a0a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a0ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0ae:	01 c8                	add    %ecx,%eax
f011a0b0:	8a 00                	mov    (%eax),%al
f011a0b2:	0f be c0             	movsbl %al,%eax
f011a0b5:	01 d0                	add    %edx,%eax
f011a0b7:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a0bd:	ff 45 f4             	incl   -0xc(%ebp)
f011a0c0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a0c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a0c9:	7f d7                	jg     f011a0a2 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a0cb:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a0d1:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a0d7:	89 d0                	mov    %edx,%eax
f011a0d9:	c1 e0 02             	shl    $0x2,%eax
f011a0dc:	01 d0                	add    %edx,%eax
f011a0de:	39 c1                	cmp    %eax,%ecx
f011a0e0:	74 17                	je     f011a0f9 <test_kfree_bestfirstfit+0x9c3>
f011a0e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0e9:	83 ec 0c             	sub    $0xc,%esp
f011a0ec:	68 20 dc 12 f0       	push   $0xf012dc20
f011a0f1:	e8 95 6e fe ff       	call   f0100f8b <cprintf>
f011a0f6:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a0f9:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a0ff:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a102:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a109:	eb 1e                	jmp    f011a129 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a10b:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a111:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a114:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a117:	01 c8                	add    %ecx,%eax
f011a119:	8a 00                	mov    (%eax),%al
f011a11b:	0f be c0             	movsbl %al,%eax
f011a11e:	01 d0                	add    %edx,%eax
f011a120:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a126:	ff 45 f4             	incl   -0xc(%ebp)
f011a129:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a12c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a12f:	7f da                	jg     f011a10b <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a131:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a137:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a13a:	89 d0                	mov    %edx,%eax
f011a13c:	01 c0                	add    %eax,%eax
f011a13e:	01 d0                	add    %edx,%eax
f011a140:	01 c0                	add    %eax,%eax
f011a142:	01 d0                	add    %edx,%eax
f011a144:	39 c1                	cmp    %eax,%ecx
f011a146:	74 17                	je     f011a15f <test_kfree_bestfirstfit+0xa29>
f011a148:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a14f:	83 ec 0c             	sub    $0xc,%esp
f011a152:	68 58 dc 12 f0       	push   $0xf012dc58
f011a157:	e8 2f 6e fe ff       	call   f0100f8b <cprintf>
f011a15c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a15f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a163:	74 04                	je     f011a169 <test_kfree_bestfirstfit+0xa33>
f011a165:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a169:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a170:	83 ec 0c             	sub    $0xc,%esp
f011a173:	68 90 dc 12 f0       	push   $0xf012dc90
f011a178:	e8 0e 6e fe ff       	call   f0100f8b <cprintf>
f011a17d:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a180:	e8 e3 47 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a185:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a188:	e8 18 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a18d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a190:	83 ec 0c             	sub    $0xc,%esp
f011a193:	68 00 04 00 00       	push   $0x400
f011a198:	e8 71 f3 fe ff       	call   f010950e <kmalloc>
f011a19d:	83 c4 10             	add    $0x10,%esp
f011a1a0:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a1a6:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a1ac:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a1b2:	39 c2                	cmp    %eax,%edx
f011a1b4:	74 17                	je     f011a1cd <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a1b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1bd:	83 ec 0c             	sub    $0xc,%esp
f011a1c0:	68 b0 dc 12 f0       	push   $0xf012dcb0
f011a1c5:	e8 c1 6d fe ff       	call   f0100f8b <cprintf>
f011a1ca:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1cd:	e8 d3 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a1d2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a1d5:	74 17                	je     f011a1ee <test_kfree_bestfirstfit+0xab8>
f011a1d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1de:	83 ec 0c             	sub    $0xc,%esp
f011a1e1:	68 04 dd 12 f0       	push   $0xf012dd04
f011a1e6:	e8 a0 6d fe ff       	call   f0100f8b <cprintf>
f011a1eb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a1ee:	e8 75 47 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a1f3:	89 c2                	mov    %eax,%edx
f011a1f5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1f8:	39 c2                	cmp    %eax,%edx
f011a1fa:	74 17                	je     f011a213 <test_kfree_bestfirstfit+0xadd>
f011a1fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a203:	83 ec 0c             	sub    $0xc,%esp
f011a206:	68 74 dd 12 f0       	push   $0xf012dd74
f011a20b:	e8 7b 6d fe ff       	call   f0100f8b <cprintf>
f011a210:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a213:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a21a:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a220:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a223:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a22a:	eb 0e                	jmp    f011a23a <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a22c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a22f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a232:	01 d0                	add    %edx,%eax
f011a234:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a237:	ff 45 f4             	incl   -0xc(%ebp)
f011a23a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a23d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a240:	7f ea                	jg     f011a22c <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a242:	e8 21 47 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a247:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a24a:	e8 56 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a24f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a252:	83 ec 0c             	sub    $0xc,%esp
f011a255:	68 00 00 30 00       	push   $0x300000
f011a25a:	e8 af f2 fe ff       	call   f010950e <kmalloc>
f011a25f:	83 c4 10             	add    $0x10,%esp
f011a262:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a268:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a26e:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a273:	74 17                	je     f011a28c <test_kfree_bestfirstfit+0xb56>
f011a275:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a27c:	83 ec 0c             	sub    $0xc,%esp
f011a27f:	68 f0 dd 12 f0       	push   $0xf012ddf0
f011a284:	e8 02 6d fe ff       	call   f0100f8b <cprintf>
f011a289:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a28c:	e8 14 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a291:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a294:	74 17                	je     f011a2ad <test_kfree_bestfirstfit+0xb77>
f011a296:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a29d:	83 ec 0c             	sub    $0xc,%esp
f011a2a0:	68 44 de 12 f0       	push   $0xf012de44
f011a2a5:	e8 e1 6c fe ff       	call   f0100f8b <cprintf>
f011a2aa:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a2ad:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a2b0:	e8 b3 46 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a2b5:	29 c3                	sub    %eax,%ebx
f011a2b7:	89 d8                	mov    %ebx,%eax
f011a2b9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a2be:	77 17                	ja     f011a2d7 <test_kfree_bestfirstfit+0xba1>
f011a2c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2c7:	83 ec 0c             	sub    $0xc,%esp
f011a2ca:	68 b4 de 12 f0       	push   $0xf012deb4
f011a2cf:	e8 b7 6c fe ff       	call   f0100f8b <cprintf>
f011a2d4:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a2d7:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a2de:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a2e4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a2e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2ee:	eb 0e                	jmp    f011a2fe <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a2f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a2f6:	01 d0                	add    %edx,%eax
f011a2f8:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a2fb:	ff 45 f4             	incl   -0xc(%ebp)
f011a2fe:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a301:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a304:	7f ea                	jg     f011a2f0 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a306:	e8 5d 46 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a30b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a30e:	e8 92 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a313:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a316:	83 ec 0c             	sub    $0xc,%esp
f011a319:	68 00 00 10 00       	push   $0x100000
f011a31e:	e8 eb f1 fe ff       	call   f010950e <kmalloc>
f011a323:	83 c4 10             	add    $0x10,%esp
f011a326:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a32c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a332:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a337:	74 17                	je     f011a350 <test_kfree_bestfirstfit+0xc1a>
f011a339:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a340:	83 ec 0c             	sub    $0xc,%esp
f011a343:	68 fc de 12 f0       	push   $0xf012defc
f011a348:	e8 3e 6c fe ff       	call   f0100f8b <cprintf>
f011a34d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a350:	e8 50 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a355:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a358:	74 17                	je     f011a371 <test_kfree_bestfirstfit+0xc3b>
f011a35a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a361:	83 ec 0c             	sub    $0xc,%esp
f011a364:	68 50 df 12 f0       	push   $0xf012df50
f011a369:	e8 1d 6c fe ff       	call   f0100f8b <cprintf>
f011a36e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a371:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a374:	e8 ef 45 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a379:	29 c3                	sub    %eax,%ebx
f011a37b:	89 d8                	mov    %ebx,%eax
f011a37d:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a382:	77 17                	ja     f011a39b <test_kfree_bestfirstfit+0xc65>
f011a384:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a38b:	83 ec 0c             	sub    $0xc,%esp
f011a38e:	68 c0 df 12 f0       	push   $0xf012dfc0
f011a393:	e8 f3 6b fe ff       	call   f0100f8b <cprintf>
f011a398:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a39b:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a3a2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a3a8:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a3ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3b2:	eb 0e                	jmp    f011a3c2 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a3b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3b7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3ba:	01 d0                	add    %edx,%eax
f011a3bc:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a3bf:	ff 45 f4             	incl   -0xc(%ebp)
f011a3c2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a3c5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3c8:	7f ea                	jg     f011a3b4 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a3ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a3ce:	74 04                	je     f011a3d4 <test_kfree_bestfirstfit+0xc9e>
f011a3d0:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a3d4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a3db:	83 ec 0c             	sub    $0xc,%esp
f011a3de:	68 08 e0 12 f0       	push   $0xf012e008
f011a3e3:	e8 a3 6b fe ff       	call   f0100f8b <cprintf>
f011a3e8:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a3eb:	e8 78 45 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a3f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3f3:	e8 ad a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a3fb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a401:	83 ec 0c             	sub    $0xc,%esp
f011a404:	50                   	push   %eax
f011a405:	e8 83 f3 fe ff       	call   f010978d <kfree>
f011a40a:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a40d:	e8 93 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a412:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a415:	74 17                	je     f011a42e <test_kfree_bestfirstfit+0xcf8>
f011a417:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a41e:	83 ec 0c             	sub    $0xc,%esp
f011a421:	68 34 e0 12 f0       	push   $0xf012e034
f011a426:	e8 60 6b fe ff       	call   f0100f8b <cprintf>
f011a42b:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a42e:	e8 35 45 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a433:	89 c2                	mov    %eax,%edx
f011a435:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a438:	29 c2                	sub    %eax,%edx
f011a43a:	89 d0                	mov    %edx,%eax
f011a43c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a441:	77 17                	ja     f011a45a <test_kfree_bestfirstfit+0xd24>
f011a443:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a44a:	83 ec 0c             	sub    $0xc,%esp
f011a44d:	68 a4 e0 12 f0       	push   $0xf012e0a4
f011a452:	e8 34 6b fe ff       	call   f0100f8b <cprintf>
f011a457:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a45a:	e8 09 45 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a45f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a462:	e8 3e a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a467:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a46a:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a470:	83 ec 0c             	sub    $0xc,%esp
f011a473:	50                   	push   %eax
f011a474:	e8 14 f3 fe ff       	call   f010978d <kfree>
f011a479:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a47c:	e8 24 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a481:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a484:	74 17                	je     f011a49d <test_kfree_bestfirstfit+0xd67>
f011a486:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a48d:	83 ec 0c             	sub    $0xc,%esp
f011a490:	68 e0 e0 12 f0       	push   $0xf012e0e0
f011a495:	e8 f1 6a fe ff       	call   f0100f8b <cprintf>
f011a49a:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a49d:	e8 c6 44 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a4a2:	89 c2                	mov    %eax,%edx
f011a4a4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a4a7:	29 c2                	sub    %eax,%edx
f011a4a9:	89 d0                	mov    %edx,%eax
f011a4ab:	83 f8 01             	cmp    $0x1,%eax
f011a4ae:	77 17                	ja     f011a4c7 <test_kfree_bestfirstfit+0xd91>
f011a4b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4b7:	83 ec 0c             	sub    $0xc,%esp
f011a4ba:	68 50 e1 12 f0       	push   $0xf012e150
f011a4bf:	e8 c7 6a fe ff       	call   f0100f8b <cprintf>
f011a4c4:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a4c7:	e8 9c 44 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a4cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4cf:	e8 d1 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a4d7:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a4dd:	83 ec 0c             	sub    $0xc,%esp
f011a4e0:	50                   	push   %eax
f011a4e1:	e8 a7 f2 fe ff       	call   f010978d <kfree>
f011a4e6:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4e9:	e8 b7 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4ee:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4f1:	74 17                	je     f011a50a <test_kfree_bestfirstfit+0xdd4>
f011a4f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4fa:	83 ec 0c             	sub    $0xc,%esp
f011a4fd:	68 8c e1 12 f0       	push   $0xf012e18c
f011a502:	e8 84 6a fe ff       	call   f0100f8b <cprintf>
f011a507:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a50a:	e8 59 44 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a50f:	89 c2                	mov    %eax,%edx
f011a511:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a514:	29 c2                	sub    %eax,%edx
f011a516:	89 d0                	mov    %edx,%eax
f011a518:	83 f8 03             	cmp    $0x3,%eax
f011a51b:	77 17                	ja     f011a534 <test_kfree_bestfirstfit+0xdfe>
f011a51d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a524:	83 ec 0c             	sub    $0xc,%esp
f011a527:	68 fc e1 12 f0       	push   $0xf012e1fc
f011a52c:	e8 5a 6a fe ff       	call   f0100f8b <cprintf>
f011a531:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a534:	e8 2f 44 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a539:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a53c:	e8 64 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a541:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a544:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a54a:	83 ec 0c             	sub    $0xc,%esp
f011a54d:	50                   	push   %eax
f011a54e:	e8 3a f2 fe ff       	call   f010978d <kfree>
f011a553:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a556:	e8 4a a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a55b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a55e:	74 17                	je     f011a577 <test_kfree_bestfirstfit+0xe41>
f011a560:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a567:	83 ec 0c             	sub    $0xc,%esp
f011a56a:	68 38 e2 12 f0       	push   $0xf012e238
f011a56f:	e8 17 6a fe ff       	call   f0100f8b <cprintf>
f011a574:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a577:	e8 ec 43 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a57c:	89 c2                	mov    %eax,%edx
f011a57e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a581:	29 c2                	sub    %eax,%edx
f011a583:	89 d0                	mov    %edx,%eax
f011a585:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a58a:	77 17                	ja     f011a5a3 <test_kfree_bestfirstfit+0xe6d>
f011a58c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a593:	83 ec 0c             	sub    $0xc,%esp
f011a596:	68 a8 e2 12 f0       	push   $0xf012e2a8
f011a59b:	e8 eb 69 fe ff       	call   f0100f8b <cprintf>
f011a5a0:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a5a3:	e8 c0 43 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a5a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a5ab:	e8 f5 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5b0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a5b3:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a5b9:	83 ec 0c             	sub    $0xc,%esp
f011a5bc:	50                   	push   %eax
f011a5bd:	e8 cb f1 fe ff       	call   f010978d <kfree>
f011a5c2:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5c5:	e8 db a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5ca:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5cd:	74 17                	je     f011a5e6 <test_kfree_bestfirstfit+0xeb0>
f011a5cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5d6:	83 ec 0c             	sub    $0xc,%esp
f011a5d9:	68 e4 e2 12 f0       	push   $0xf012e2e4
f011a5de:	e8 a8 69 fe ff       	call   f0100f8b <cprintf>
f011a5e3:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a5e6:	e8 7d 43 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a5eb:	89 c2                	mov    %eax,%edx
f011a5ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a5f0:	29 c2                	sub    %eax,%edx
f011a5f2:	89 d0                	mov    %edx,%eax
f011a5f4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a5f9:	77 17                	ja     f011a612 <test_kfree_bestfirstfit+0xedc>
f011a5fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a602:	83 ec 0c             	sub    $0xc,%esp
f011a605:	68 54 e3 12 f0       	push   $0xf012e354
f011a60a:	e8 7c 69 fe ff       	call   f0100f8b <cprintf>
f011a60f:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a612:	e8 51 43 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a617:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a61a:	e8 86 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a61f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a622:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a628:	83 ec 0c             	sub    $0xc,%esp
f011a62b:	50                   	push   %eax
f011a62c:	e8 5c f1 fe ff       	call   f010978d <kfree>
f011a631:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a634:	e8 6c a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a639:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a63c:	74 17                	je     f011a655 <test_kfree_bestfirstfit+0xf1f>
f011a63e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a645:	83 ec 0c             	sub    $0xc,%esp
f011a648:	68 90 e3 12 f0       	push   $0xf012e390
f011a64d:	e8 39 69 fe ff       	call   f0100f8b <cprintf>
f011a652:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a655:	e8 0e 43 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a65a:	89 c2                	mov    %eax,%edx
f011a65c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a65f:	39 c2                	cmp    %eax,%edx
f011a661:	74 17                	je     f011a67a <test_kfree_bestfirstfit+0xf44>
f011a663:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a66a:	83 ec 0c             	sub    $0xc,%esp
f011a66d:	68 00 e4 12 f0       	push   $0xf012e400
f011a672:	e8 14 69 fe ff       	call   f0100f8b <cprintf>
f011a677:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a67a:	e8 e9 42 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a67f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a682:	e8 1e a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a687:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a68a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a690:	83 ec 0c             	sub    $0xc,%esp
f011a693:	50                   	push   %eax
f011a694:	e8 f4 f0 fe ff       	call   f010978d <kfree>
f011a699:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a69c:	e8 04 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a6a1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6a4:	74 17                	je     f011a6bd <test_kfree_bestfirstfit+0xf87>
f011a6a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6ad:	83 ec 0c             	sub    $0xc,%esp
f011a6b0:	68 3c e4 12 f0       	push   $0xf012e43c
f011a6b5:	e8 d1 68 fe ff       	call   f0100f8b <cprintf>
f011a6ba:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a6bd:	e8 a6 42 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a6c2:	89 c2                	mov    %eax,%edx
f011a6c4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a6c7:	39 c2                	cmp    %eax,%edx
f011a6c9:	74 17                	je     f011a6e2 <test_kfree_bestfirstfit+0xfac>
f011a6cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6d2:	83 ec 0c             	sub    $0xc,%esp
f011a6d5:	68 ac e4 12 f0       	push   $0xf012e4ac
f011a6da:	e8 ac 68 fe ff       	call   f0100f8b <cprintf>
f011a6df:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a6e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6e6:	74 04                	je     f011a6ec <test_kfree_bestfirstfit+0xfb6>
f011a6e8:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a6ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a6f3:	83 ec 0c             	sub    $0xc,%esp
f011a6f6:	68 0c e5 12 f0       	push   $0xf012e50c
f011a6fb:	e8 8b 68 fe ff       	call   f0100f8b <cprintf>
f011a700:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a703:	83 ec 0c             	sub    $0xc,%esp
f011a706:	6a 03                	push   $0x3
f011a708:	e8 84 46 ff ff       	call   f010ed91 <sys_bypassPageFault>
f011a70d:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a710:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a717:	e9 af 00 00 00       	jmp    f011a7cb <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a71c:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a720:	0f 84 a1 00 00 00    	je     f011a7c7 <test_kfree_bestfirstfit+0x1091>
f011a726:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a72a:	0f 84 97 00 00 00    	je     f011a7c7 <test_kfree_bestfirstfit+0x1091>
f011a730:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a734:	0f 84 8d 00 00 00    	je     f011a7c7 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a73a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a73d:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a744:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a747:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a74a:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a74d:	e8 2d 46 ff ff       	call   f010ed7f <sys_rcr2>
f011a752:	89 c2                	mov    %eax,%edx
f011a754:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a757:	39 c2                	cmp    %eax,%edx
f011a759:	74 1d                	je     f011a778 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a75b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a75f:	74 17                	je     f011a778 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a761:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a768:	83 ec 0c             	sub    $0xc,%esp
f011a76b:	68 4c e5 12 f0       	push   $0xf012e54c
f011a770:	e8 16 68 fe ff       	call   f0100f8b <cprintf>
f011a775:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a778:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a77b:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a782:	89 c2                	mov    %eax,%edx
f011a784:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a787:	01 d0                	add    %edx,%eax
f011a789:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a78c:	e8 ee 45 ff ff       	call   f010ed7f <sys_rcr2>
f011a791:	89 c2                	mov    %eax,%edx
f011a793:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a796:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a79d:	89 c1                	mov    %eax,%ecx
f011a79f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7a2:	01 c8                	add    %ecx,%eax
f011a7a4:	39 c2                	cmp    %eax,%edx
f011a7a6:	74 20                	je     f011a7c8 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a7a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a7ac:	74 1a                	je     f011a7c8 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a7ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7b5:	83 ec 0c             	sub    $0xc,%esp
f011a7b8:	68 98 e5 12 f0       	push   $0xf012e598
f011a7bd:	e8 c9 67 fe ff       	call   f0100f8b <cprintf>
f011a7c2:	83 c4 10             	add    $0x10,%esp
f011a7c5:	eb 01                	jmp    f011a7c8 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a7c7:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a7c8:	ff 45 f4             	incl   -0xc(%ebp)
f011a7cb:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a7cf:	0f 8e 47 ff ff ff    	jle    f011a71c <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a7d5:	83 ec 0c             	sub    $0xc,%esp
f011a7d8:	6a 00                	push   $0x0
f011a7da:	e8 b2 45 ff ff       	call   f010ed91 <sys_bypassPageFault>
f011a7df:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a7e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a7e6:	74 04                	je     f011a7ec <test_kfree_bestfirstfit+0x10b6>
f011a7e8:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a7ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a7f3:	83 ec 0c             	sub    $0xc,%esp
f011a7f6:	68 e4 e5 12 f0       	push   $0xf012e5e4
f011a7fb:	e8 8b 67 fe ff       	call   f0100f8b <cprintf>
f011a800:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a803:	e8 60 41 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a808:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a80b:	e8 95 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a810:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a813:	83 ec 0c             	sub    $0xc,%esp
f011a816:	68 00 04 00 00       	push   $0x400
f011a81b:	e8 ee ec fe ff       	call   f010950e <kmalloc>
f011a820:	83 c4 10             	add    $0x10,%esp
f011a823:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a829:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a82f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a835:	39 c2                	cmp    %eax,%edx
f011a837:	74 17                	je     f011a850 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a839:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a840:	83 ec 0c             	sub    $0xc,%esp
f011a843:	68 08 e6 12 f0       	push   $0xf012e608
f011a848:	e8 3e 67 fe ff       	call   f0100f8b <cprintf>
f011a84d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a850:	e8 50 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a855:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a858:	74 17                	je     f011a871 <test_kfree_bestfirstfit+0x113b>
f011a85a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a861:	83 ec 0c             	sub    $0xc,%esp
f011a864:	68 5c e6 12 f0       	push   $0xf012e65c
f011a869:	e8 1d 67 fe ff       	call   f0100f8b <cprintf>
f011a86e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a871:	e8 f2 40 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a876:	89 c2                	mov    %eax,%edx
f011a878:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a87b:	39 c2                	cmp    %eax,%edx
f011a87d:	74 17                	je     f011a896 <test_kfree_bestfirstfit+0x1160>
f011a87f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a886:	83 ec 0c             	sub    $0xc,%esp
f011a889:	68 cc e6 12 f0       	push   $0xf012e6cc
f011a88e:	e8 f8 66 fe ff       	call   f0100f8b <cprintf>
f011a893:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a896:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a89d:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a8a3:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a8a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a8ad:	eb 0e                	jmp    f011a8bd <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a8af:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a8b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a8b5:	01 d0                	add    %edx,%eax
f011a8b7:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a8ba:	ff 45 f4             	incl   -0xc(%ebp)
f011a8bd:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a8c0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a8c3:	7f ea                	jg     f011a8af <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8c5:	e8 9e 40 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a8ca:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8cd:	e8 d3 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8d2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a8d5:	83 ec 0c             	sub    $0xc,%esp
f011a8d8:	68 00 08 00 00       	push   $0x800
f011a8dd:	e8 2c ec fe ff       	call   f010950e <kmalloc>
f011a8e2:	83 c4 10             	add    $0x10,%esp
f011a8e5:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a8eb:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a8f1:	05 08 04 00 00       	add    $0x408,%eax
f011a8f6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a8f9:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a8ff:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a902:	74 35                	je     f011a939 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a904:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a90b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a911:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a917:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a91d:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a923:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a929:	50                   	push   %eax
f011a92a:	51                   	push   %ecx
f011a92b:	52                   	push   %edx
f011a92c:	68 48 e7 12 f0       	push   $0xf012e748
f011a931:	e8 55 66 fe ff       	call   f0100f8b <cprintf>
f011a936:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a939:	e8 67 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a93e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a941:	74 17                	je     f011a95a <test_kfree_bestfirstfit+0x1224>
f011a943:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a94a:	83 ec 0c             	sub    $0xc,%esp
f011a94d:	68 bc e7 12 f0       	push   $0xf012e7bc
f011a952:	e8 34 66 fe ff       	call   f0100f8b <cprintf>
f011a957:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a95a:	e8 09 40 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a95f:	89 c2                	mov    %eax,%edx
f011a961:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a964:	39 c2                	cmp    %eax,%edx
f011a966:	74 17                	je     f011a97f <test_kfree_bestfirstfit+0x1249>
f011a968:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a96f:	83 ec 0c             	sub    $0xc,%esp
f011a972:	68 2c e8 12 f0       	push   $0xf012e82c
f011a977:	e8 0f 66 fe ff       	call   f0100f8b <cprintf>
f011a97c:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a97f:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a986:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a98c:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a98f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a996:	eb 0e                	jmp    f011a9a6 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a998:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a99b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a99e:	01 d0                	add    %edx,%eax
f011a9a0:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a9a3:	ff 45 f4             	incl   -0xc(%ebp)
f011a9a6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a9a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a9ac:	7f ea                	jg     f011a998 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a9ae:	e8 b5 3f ff ff       	call   f010e968 <sys_calculate_free_frames>
f011a9b3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a9b6:	e8 ea 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9bb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a9be:	83 ec 0c             	sub    $0xc,%esp
f011a9c1:	68 00 06 00 00       	push   $0x600
f011a9c6:	e8 43 eb fe ff       	call   f010950e <kmalloc>
f011a9cb:	83 c4 10             	add    $0x10,%esp
f011a9ce:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a9d4:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a9da:	05 10 0c 00 00       	add    $0xc10,%eax
f011a9df:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a9e2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a9e8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a9eb:	74 17                	je     f011aa04 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a9ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9f4:	83 ec 0c             	sub    $0xc,%esp
f011a9f7:	68 a8 e8 12 f0       	push   $0xf012e8a8
f011a9fc:	e8 8a 65 fe ff       	call   f0100f8b <cprintf>
f011aa01:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa04:	e8 9c 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa09:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa0c:	74 17                	je     f011aa25 <test_kfree_bestfirstfit+0x12ef>
f011aa0e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa15:	83 ec 0c             	sub    $0xc,%esp
f011aa18:	68 fc e8 12 f0       	push   $0xf012e8fc
f011aa1d:	e8 69 65 fe ff       	call   f0100f8b <cprintf>
f011aa22:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011aa25:	e8 3e 3f ff ff       	call   f010e968 <sys_calculate_free_frames>
f011aa2a:	89 c2                	mov    %eax,%edx
f011aa2c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011aa2f:	39 c2                	cmp    %eax,%edx
f011aa31:	74 17                	je     f011aa4a <test_kfree_bestfirstfit+0x1314>
f011aa33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa3a:	83 ec 0c             	sub    $0xc,%esp
f011aa3d:	68 6c e9 12 f0       	push   $0xf012e96c
f011aa42:	e8 44 65 fe ff       	call   f0100f8b <cprintf>
f011aa47:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011aa4a:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011aa51:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011aa57:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011aa5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aa61:	eb 0e                	jmp    f011aa71 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011aa63:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa66:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa69:	01 d0                	add    %edx,%eax
f011aa6b:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011aa6e:	ff 45 f4             	incl   -0xc(%ebp)
f011aa71:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aa74:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aa77:	7f ea                	jg     f011aa63 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011aa79:	e8 ea 3e ff ff       	call   f010e968 <sys_calculate_free_frames>
f011aa7e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa81:	e8 1f 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa86:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011aa89:	83 ec 0c             	sub    $0xc,%esp
f011aa8c:	68 00 00 e0 01       	push   $0x1e00000
f011aa91:	e8 78 ea fe ff       	call   f010950e <kmalloc>
f011aa96:	83 c4 10             	add    $0x10,%esp
f011aa99:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa9f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aaa5:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011aaaa:	74 17                	je     f011aac3 <test_kfree_bestfirstfit+0x138d>
f011aaac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aab3:	83 ec 0c             	sub    $0xc,%esp
f011aab6:	68 e8 e9 12 f0       	push   $0xf012e9e8
f011aabb:	e8 cb 64 fe ff       	call   f0100f8b <cprintf>
f011aac0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aac3:	e8 dd 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aac8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aacb:	74 17                	je     f011aae4 <test_kfree_bestfirstfit+0x13ae>
f011aacd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aad4:	83 ec 0c             	sub    $0xc,%esp
f011aad7:	68 3c ea 12 f0       	push   $0xf012ea3c
f011aadc:	e8 aa 64 fe ff       	call   f0100f8b <cprintf>
f011aae1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aae4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011aae7:	e8 7c 3e ff ff       	call   f010e968 <sys_calculate_free_frames>
f011aaec:	29 c3                	sub    %eax,%ebx
f011aaee:	89 d8                	mov    %ebx,%eax
f011aaf0:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011aaf5:	77 17                	ja     f011ab0e <test_kfree_bestfirstfit+0x13d8>
f011aaf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aafe:	83 ec 0c             	sub    $0xc,%esp
f011ab01:	68 ac ea 12 f0       	push   $0xf012eaac
f011ab06:	e8 80 64 fe ff       	call   f0100f8b <cprintf>
f011ab0b:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011ab0e:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011ab15:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ab1b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ab1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab25:	eb 0e                	jmp    f011ab35 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011ab27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ab2a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab2d:	01 d0                	add    %edx,%eax
f011ab2f:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ab32:	ff 45 f4             	incl   -0xc(%ebp)
f011ab35:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ab38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab3b:	7f ea                	jg     f011ab27 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011ab3d:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ab43:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ab46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab4d:	eb 1e                	jmp    f011ab6d <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011ab4f:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011ab55:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab58:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab5b:	01 c8                	add    %ecx,%eax
f011ab5d:	8a 00                	mov    (%eax),%al
f011ab5f:	0f be c0             	movsbl %al,%eax
f011ab62:	01 d0                	add    %edx,%eax
f011ab64:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ab6a:	ff 45 f4             	incl   -0xc(%ebp)
f011ab6d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ab70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab73:	7f da                	jg     f011ab4f <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011ab75:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011ab7b:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011ab7e:	89 d0                	mov    %edx,%eax
f011ab80:	c1 e0 02             	shl    $0x2,%eax
f011ab83:	01 d0                	add    %edx,%eax
f011ab85:	01 c0                	add    %eax,%eax
f011ab87:	39 c1                	cmp    %eax,%ecx
f011ab89:	74 17                	je     f011aba2 <test_kfree_bestfirstfit+0x146c>
f011ab8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab92:	83 ec 0c             	sub    $0xc,%esp
f011ab95:	68 f4 ea 12 f0       	push   $0xf012eaf4
f011ab9a:	e8 ec 63 fe ff       	call   f0100f8b <cprintf>
f011ab9f:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011aba2:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011aba8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011abab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abb2:	eb 1e                	jmp    f011abd2 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011abb4:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011abba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abbd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abc0:	01 c8                	add    %ecx,%eax
f011abc2:	8a 00                	mov    (%eax),%al
f011abc4:	0f be c0             	movsbl %al,%eax
f011abc7:	01 d0                	add    %edx,%eax
f011abc9:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011abcf:	ff 45 f4             	incl   -0xc(%ebp)
f011abd2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011abd5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abd8:	7f da                	jg     f011abb4 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011abda:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011abe0:	8b 55 90             	mov    -0x70(%ebp),%edx
f011abe3:	89 d0                	mov    %edx,%eax
f011abe5:	c1 e0 02             	shl    $0x2,%eax
f011abe8:	01 d0                	add    %edx,%eax
f011abea:	01 c0                	add    %eax,%eax
f011abec:	01 d0                	add    %edx,%eax
f011abee:	39 c1                	cmp    %eax,%ecx
f011abf0:	74 17                	je     f011ac09 <test_kfree_bestfirstfit+0x14d3>
f011abf2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abf9:	83 ec 0c             	sub    $0xc,%esp
f011abfc:	68 24 eb 12 f0       	push   $0xf012eb24
f011ac01:	e8 85 63 fe ff       	call   f0100f8b <cprintf>
f011ac06:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011ac09:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ac0f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ac12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac19:	eb 1e                	jmp    f011ac39 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011ac1b:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011ac21:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac27:	01 c8                	add    %ecx,%eax
f011ac29:	8a 00                	mov    (%eax),%al
f011ac2b:	0f be c0             	movsbl %al,%eax
f011ac2e:	01 d0                	add    %edx,%eax
f011ac30:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ac36:	ff 45 f4             	incl   -0xc(%ebp)
f011ac39:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ac3c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac3f:	7f da                	jg     f011ac1b <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011ac41:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011ac47:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011ac4a:	89 d0                	mov    %edx,%eax
f011ac4c:	01 c0                	add    %eax,%eax
f011ac4e:	01 d0                	add    %edx,%eax
f011ac50:	c1 e0 02             	shl    $0x2,%eax
f011ac53:	39 c1                	cmp    %eax,%ecx
f011ac55:	74 17                	je     f011ac6e <test_kfree_bestfirstfit+0x1538>
f011ac57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac5e:	83 ec 0c             	sub    $0xc,%esp
f011ac61:	68 54 eb 12 f0       	push   $0xf012eb54
f011ac66:	e8 20 63 fe ff       	call   f0100f8b <cprintf>
f011ac6b:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011ac6e:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ac74:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011ac77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac7e:	eb 1e                	jmp    f011ac9e <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011ac80:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011ac86:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac89:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac8c:	01 c8                	add    %ecx,%eax
f011ac8e:	8a 00                	mov    (%eax),%al
f011ac90:	0f be c0             	movsbl %al,%eax
f011ac93:	01 d0                	add    %edx,%eax
f011ac95:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011ac9b:	ff 45 f4             	incl   -0xc(%ebp)
f011ac9e:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aca1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aca4:	7f da                	jg     f011ac80 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011aca6:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011acac:	8b 55 98             	mov    -0x68(%ebp),%edx
f011acaf:	89 d0                	mov    %edx,%eax
f011acb1:	01 c0                	add    %eax,%eax
f011acb3:	01 d0                	add    %edx,%eax
f011acb5:	c1 e0 02             	shl    $0x2,%eax
f011acb8:	01 d0                	add    %edx,%eax
f011acba:	39 c1                	cmp    %eax,%ecx
f011acbc:	74 17                	je     f011acd5 <test_kfree_bestfirstfit+0x159f>
f011acbe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acc5:	83 ec 0c             	sub    $0xc,%esp
f011acc8:	68 84 eb 12 f0       	push   $0xf012eb84
f011accd:	e8 b9 62 fe ff       	call   f0100f8b <cprintf>
f011acd2:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011acd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011acd9:	74 04                	je     f011acdf <test_kfree_bestfirstfit+0x15a9>
f011acdb:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011acdf:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011ace6:	83 ec 0c             	sub    $0xc,%esp
f011ace9:	68 b1 eb 12 f0       	push   $0xf012ebb1
f011acee:	e8 98 62 fe ff       	call   f0100f8b <cprintf>
f011acf3:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011acf6:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011acfd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011ad04:	eb 4e                	jmp    f011ad54 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011ad06:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ad09:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011ad0e:	83 ec 04             	sub    $0x4,%esp
f011ad11:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011ad17:	51                   	push   %ecx
f011ad18:	52                   	push   %edx
f011ad19:	50                   	push   %eax
f011ad1a:	e8 d0 d6 fe ff       	call   f01083ef <get_page_table>
f011ad1f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ad22:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011ad28:	85 c0                	test   %eax,%eax
f011ad2a:	75 1d                	jne    f011ad49 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011ad2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad30:	74 17                	je     f011ad49 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011ad32:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad39:	83 ec 0c             	sub    $0xc,%esp
f011ad3c:	68 d0 eb 12 f0       	push   $0xf012ebd0
f011ad41:	e8 45 62 fe ff       	call   f0100f8b <cprintf>
f011ad46:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ad49:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011ad50:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011ad54:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ad58:	78 ac                	js     f011ad06 <test_kfree_bestfirstfit+0x15d0>
f011ad5a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ad5e:	7f 09                	jg     f011ad69 <test_kfree_bestfirstfit+0x1633>
f011ad60:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011ad67:	76 9d                	jbe    f011ad06 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011ad69:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad6d:	74 04                	je     f011ad73 <test_kfree_bestfirstfit+0x163d>
f011ad6f:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011ad73:	83 ec 08             	sub    $0x8,%esp
f011ad76:	ff 75 f0             	pushl  -0x10(%ebp)
f011ad79:	68 38 ec 12 f0       	push   $0xf012ec38
f011ad7e:	e8 08 62 fe ff       	call   f0100f8b <cprintf>
f011ad83:	83 c4 10             	add    $0x10,%esp

	return 1;
f011ad86:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011ad8b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ad8e:	5b                   	pop    %ebx
f011ad8f:	5f                   	pop    %edi
f011ad90:	5d                   	pop    %ebp
f011ad91:	c3                   	ret    

f011ad92 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011ad92:	55                   	push   %ebp
f011ad93:	89 e5                	mov    %esp,%ebp
f011ad95:	57                   	push   %edi
f011ad96:	53                   	push   %ebx
f011ad97:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011ad9d:	83 ec 0c             	sub    $0xc,%esp
f011ada0:	68 08 af 12 f0       	push   $0xf012af08
f011ada5:	e8 e1 61 fe ff       	call   f0100f8b <cprintf>
f011adaa:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011adad:	83 ec 0c             	sub    $0xc,%esp
f011adb0:	68 38 af 12 f0       	push   $0xf012af38
f011adb5:	e8 d1 61 fe ff       	call   f0100f8b <cprintf>
f011adba:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011adbd:	83 ec 0c             	sub    $0xc,%esp
f011adc0:	68 08 af 12 f0       	push   $0xf012af08
f011adc5:	e8 c1 61 fe ff       	call   f0100f8b <cprintf>
f011adca:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011adcd:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011add1:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011add5:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011addb:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011ade1:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011ade8:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011adef:	e8 74 3b ff ff       	call   f010e968 <sys_calculate_free_frames>
f011adf4:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011adf7:	83 ec 0c             	sub    $0xc,%esp
f011adfa:	68 5c ec 12 f0       	push   $0xf012ec5c
f011adff:	e8 87 61 fe ff       	call   f0100f8b <cprintf>
f011ae04:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011ae07:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011ae0d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae12:	b8 00 00 00 00       	mov    $0x0,%eax
f011ae17:	89 d7                	mov    %edx,%edi
f011ae19:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011ae1b:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011ae21:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae26:	b8 00 00 00 00       	mov    $0x0,%eax
f011ae2b:	89 d7                	mov    %edx,%edi
f011ae2d:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011ae2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011ae36:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011ae3d:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011ae43:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae48:	b8 00 00 00 00       	mov    $0x0,%eax
f011ae4d:	89 d7                	mov    %edx,%edi
f011ae4f:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ae51:	e8 12 3b ff ff       	call   f010e968 <sys_calculate_free_frames>
f011ae56:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae59:	e8 47 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae5e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011ae61:	83 ec 0c             	sub    $0xc,%esp
f011ae64:	68 00 fc 1f 00       	push   $0x1ffc00
f011ae69:	e8 a0 e6 fe ff       	call   f010950e <kmalloc>
f011ae6e:	83 c4 10             	add    $0x10,%esp
f011ae71:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae77:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ae7d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ae82:	74 17                	je     f011ae9b <test_kheap_phys_addr+0x109>
f011ae84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae8b:	83 ec 0c             	sub    $0xc,%esp
f011ae8e:	68 00 d0 12 f0       	push   $0xf012d000
f011ae93:	e8 f3 60 fe ff       	call   f0100f8b <cprintf>
f011ae98:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae9b:	e8 05 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aea0:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aea3:	74 17                	je     f011aebc <test_kheap_phys_addr+0x12a>
f011aea5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aeac:	83 ec 0c             	sub    $0xc,%esp
f011aeaf:	68 54 d0 12 f0       	push   $0xf012d054
f011aeb4:	e8 d2 60 fe ff       	call   f0100f8b <cprintf>
f011aeb9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aebc:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011aebf:	e8 a4 3a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011aec4:	29 c3                	sub    %eax,%ebx
f011aec6:	89 d8                	mov    %ebx,%eax
f011aec8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aecd:	77 17                	ja     f011aee6 <test_kheap_phys_addr+0x154>
f011aecf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aed6:	83 ec 0c             	sub    $0xc,%esp
f011aed9:	68 c4 d0 12 f0       	push   $0xf012d0c4
f011aede:	e8 a8 60 fe ff       	call   f0100f8b <cprintf>
f011aee3:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011aee6:	e8 7d 3a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011aeeb:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aeee:	e8 b2 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aef3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011aef6:	83 ec 0c             	sub    $0xc,%esp
f011aef9:	68 00 fc 1f 00       	push   $0x1ffc00
f011aefe:	e8 0b e6 fe ff       	call   f010950e <kmalloc>
f011af03:	83 c4 10             	add    $0x10,%esp
f011af06:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011af0c:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011af12:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011af17:	74 17                	je     f011af30 <test_kheap_phys_addr+0x19e>
f011af19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af20:	83 ec 0c             	sub    $0xc,%esp
f011af23:	68 0c d1 12 f0       	push   $0xf012d10c
f011af28:	e8 5e 60 fe ff       	call   f0100f8b <cprintf>
f011af2d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af30:	e8 70 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af35:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011af38:	74 17                	je     f011af51 <test_kheap_phys_addr+0x1bf>
f011af3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af41:	83 ec 0c             	sub    $0xc,%esp
f011af44:	68 60 d1 12 f0       	push   $0xf012d160
f011af49:	e8 3d 60 fe ff       	call   f0100f8b <cprintf>
f011af4e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011af51:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011af54:	e8 0f 3a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011af59:	29 c3                	sub    %eax,%ebx
f011af5b:	89 d8                	mov    %ebx,%eax
f011af5d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af62:	77 17                	ja     f011af7b <test_kheap_phys_addr+0x1e9>
f011af64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af6b:	83 ec 0c             	sub    $0xc,%esp
f011af6e:	68 d0 d1 12 f0       	push   $0xf012d1d0
f011af73:	e8 13 60 fe ff       	call   f0100f8b <cprintf>
f011af78:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011af7b:	e8 e8 39 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011af80:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011af83:	e8 1d 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af88:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011af8b:	83 ec 0c             	sub    $0xc,%esp
f011af8e:	68 00 04 00 00       	push   $0x400
f011af93:	e8 76 e5 fe ff       	call   f010950e <kmalloc>
f011af98:	83 c4 10             	add    $0x10,%esp
f011af9b:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011afa1:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011afa7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011afac:	76 28                	jbe    f011afd6 <test_kheap_phys_addr+0x244>
f011afae:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011afb4:	83 ec 0c             	sub    $0xc,%esp
f011afb7:	6a 00                	push   $0x0
f011afb9:	e8 1d e4 fe ff       	call   f01093db <sbrk>
f011afbe:	83 c4 10             	add    $0x10,%esp
f011afc1:	39 c3                	cmp    %eax,%ebx
f011afc3:	73 11                	jae    f011afd6 <test_kheap_phys_addr+0x244>
f011afc5:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011afcb:	89 c2                	mov    %eax,%edx
f011afcd:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011afd2:	39 c2                	cmp    %eax,%edx
f011afd4:	72 17                	jb     f011afed <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011afd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afdd:	83 ec 0c             	sub    $0xc,%esp
f011afe0:	68 8c ec 12 f0       	push   $0xf012ec8c
f011afe5:	e8 a1 5f fe ff       	call   f0100f8b <cprintf>
f011afea:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afed:	e8 b3 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aff2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aff5:	74 17                	je     f011b00e <test_kheap_phys_addr+0x27c>
f011aff7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011affe:	83 ec 0c             	sub    $0xc,%esp
f011b001:	68 6c d2 12 f0       	push   $0xf012d26c
f011b006:	e8 80 5f fe ff       	call   f0100f8b <cprintf>
f011b00b:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b00e:	e8 55 39 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b013:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b016:	e8 8a 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b01b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b01e:	83 ec 0c             	sub    $0xc,%esp
f011b021:	68 00 08 00 00       	push   $0x800
f011b026:	e8 e3 e4 fe ff       	call   f010950e <kmalloc>
f011b02b:	83 c4 10             	add    $0x10,%esp
f011b02e:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b034:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b03a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b03f:	76 28                	jbe    f011b069 <test_kheap_phys_addr+0x2d7>
f011b041:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b047:	83 ec 0c             	sub    $0xc,%esp
f011b04a:	6a 00                	push   $0x0
f011b04c:	e8 8a e3 fe ff       	call   f01093db <sbrk>
f011b051:	83 c4 10             	add    $0x10,%esp
f011b054:	39 c3                	cmp    %eax,%ebx
f011b056:	73 11                	jae    f011b069 <test_kheap_phys_addr+0x2d7>
f011b058:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b05e:	89 c2                	mov    %eax,%edx
f011b060:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b065:	39 c2                	cmp    %eax,%edx
f011b067:	72 17                	jb     f011b080 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b069:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b070:	83 ec 0c             	sub    $0xc,%esp
f011b073:	68 18 ed 12 f0       	push   $0xf012ed18
f011b078:	e8 0e 5f fe ff       	call   f0100f8b <cprintf>
f011b07d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b080:	e8 20 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b085:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b088:	74 17                	je     f011b0a1 <test_kheap_phys_addr+0x30f>
f011b08a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b091:	83 ec 0c             	sub    $0xc,%esp
f011b094:	68 78 d3 12 f0       	push   $0xf012d378
f011b099:	e8 ed 5e fe ff       	call   f0100f8b <cprintf>
f011b09e:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b0a1:	e8 c2 38 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b0a6:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b0a9:	e8 f7 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b0ae:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b0b1:	83 ec 0c             	sub    $0xc,%esp
f011b0b4:	68 00 06 00 00       	push   $0x600
f011b0b9:	e8 50 e4 fe ff       	call   f010950e <kmalloc>
f011b0be:	83 c4 10             	add    $0x10,%esp
f011b0c1:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b0c7:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b0cd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b0d2:	76 28                	jbe    f011b0fc <test_kheap_phys_addr+0x36a>
f011b0d4:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b0da:	83 ec 0c             	sub    $0xc,%esp
f011b0dd:	6a 00                	push   $0x0
f011b0df:	e8 f7 e2 fe ff       	call   f01093db <sbrk>
f011b0e4:	83 c4 10             	add    $0x10,%esp
f011b0e7:	39 c3                	cmp    %eax,%ebx
f011b0e9:	73 11                	jae    f011b0fc <test_kheap_phys_addr+0x36a>
f011b0eb:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b0f1:	89 c2                	mov    %eax,%edx
f011b0f3:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b0f8:	39 c2                	cmp    %eax,%edx
f011b0fa:	72 17                	jb     f011b113 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b0fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b103:	83 ec 0c             	sub    $0xc,%esp
f011b106:	68 a4 ed 12 f0       	push   $0xf012eda4
f011b10b:	e8 7b 5e fe ff       	call   f0100f8b <cprintf>
f011b110:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b113:	e8 8d 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b118:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b11b:	74 17                	je     f011b134 <test_kheap_phys_addr+0x3a2>
f011b11d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b124:	83 ec 0c             	sub    $0xc,%esp
f011b127:	68 84 d4 12 f0       	push   $0xf012d484
f011b12c:	e8 5a 5e fe ff       	call   f0100f8b <cprintf>
f011b131:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b134:	e8 2f 38 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b139:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b13c:	e8 64 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b141:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b144:	83 ec 0c             	sub    $0xc,%esp
f011b147:	68 00 1c 00 00       	push   $0x1c00
f011b14c:	e8 bd e3 fe ff       	call   f010950e <kmalloc>
f011b151:	83 c4 10             	add    $0x10,%esp
f011b154:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b15a:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b160:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b165:	74 17                	je     f011b17e <test_kheap_phys_addr+0x3ec>
f011b167:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b16e:	83 ec 0c             	sub    $0xc,%esp
f011b171:	68 3c d5 12 f0       	push   $0xf012d53c
f011b176:	e8 10 5e fe ff       	call   f0100f8b <cprintf>
f011b17b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b17e:	e8 22 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b183:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b186:	74 17                	je     f011b19f <test_kheap_phys_addr+0x40d>
f011b188:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b18f:	83 ec 0c             	sub    $0xc,%esp
f011b192:	68 90 d5 12 f0       	push   $0xf012d590
f011b197:	e8 ef 5d fe ff       	call   f0100f8b <cprintf>
f011b19c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b19f:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b1a2:	e8 c1 37 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b1a7:	29 c3                	sub    %eax,%ebx
f011b1a9:	89 d8                	mov    %ebx,%eax
f011b1ab:	83 f8 01             	cmp    $0x1,%eax
f011b1ae:	77 17                	ja     f011b1c7 <test_kheap_phys_addr+0x435>
f011b1b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1b7:	83 ec 0c             	sub    $0xc,%esp
f011b1ba:	68 00 d6 12 f0       	push   $0xf012d600
f011b1bf:	e8 c7 5d fe ff       	call   f0100f8b <cprintf>
f011b1c4:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b1c7:	e8 9c 37 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b1cc:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b1cf:	e8 d1 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b1d4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b1d7:	83 ec 0c             	sub    $0xc,%esp
f011b1da:	68 00 fc 2f 00       	push   $0x2ffc00
f011b1df:	e8 2a e3 fe ff       	call   f010950e <kmalloc>
f011b1e4:	83 c4 10             	add    $0x10,%esp
f011b1e7:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b1ed:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b1f3:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b1f8:	74 17                	je     f011b211 <test_kheap_phys_addr+0x47f>
f011b1fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b201:	83 ec 0c             	sub    $0xc,%esp
f011b204:	68 30 ee 12 f0       	push   $0xf012ee30
f011b209:	e8 7d 5d fe ff       	call   f0100f8b <cprintf>
f011b20e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b211:	e8 8f 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b216:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b219:	74 17                	je     f011b232 <test_kheap_phys_addr+0x4a0>
f011b21b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b222:	83 ec 0c             	sub    $0xc,%esp
f011b225:	68 d4 d6 12 f0       	push   $0xf012d6d4
f011b22a:	e8 5c 5d fe ff       	call   f0100f8b <cprintf>
f011b22f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b232:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b235:	e8 2e 37 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b23a:	29 c3                	sub    %eax,%ebx
f011b23c:	89 d8                	mov    %ebx,%eax
f011b23e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b243:	77 17                	ja     f011b25c <test_kheap_phys_addr+0x4ca>
f011b245:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b24c:	83 ec 0c             	sub    $0xc,%esp
f011b24f:	68 84 ee 12 f0       	push   $0xf012ee84
f011b254:	e8 32 5d fe ff       	call   f0100f8b <cprintf>
f011b259:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b25c:	e8 07 37 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b261:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b264:	e8 3c 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b269:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b26c:	83 ec 0c             	sub    $0xc,%esp
f011b26f:	68 00 fc 5f 00       	push   $0x5ffc00
f011b274:	e8 95 e2 fe ff       	call   f010950e <kmalloc>
f011b279:	83 c4 10             	add    $0x10,%esp
f011b27c:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b282:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b288:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b28d:	74 17                	je     f011b2a6 <test_kheap_phys_addr+0x514>
f011b28f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b296:	83 ec 0c             	sub    $0xc,%esp
f011b299:	68 cc ee 12 f0       	push   $0xf012eecc
f011b29e:	e8 e8 5c fe ff       	call   f0100f8b <cprintf>
f011b2a3:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2a6:	e8 fa 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b2ab:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b2ae:	74 17                	je     f011b2c7 <test_kheap_phys_addr+0x535>
f011b2b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2b7:	83 ec 0c             	sub    $0xc,%esp
f011b2ba:	68 d0 d7 12 f0       	push   $0xf012d7d0
f011b2bf:	e8 c7 5c fe ff       	call   f0100f8b <cprintf>
f011b2c4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b2c7:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b2ca:	e8 99 36 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b2cf:	29 c3                	sub    %eax,%ebx
f011b2d1:	89 d8                	mov    %ebx,%eax
f011b2d3:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b2d8:	77 17                	ja     f011b2f1 <test_kheap_phys_addr+0x55f>
f011b2da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2e1:	83 ec 0c             	sub    $0xc,%esp
f011b2e4:	68 20 ef 12 f0       	push   $0xf012ef20
f011b2e9:	e8 9d 5c fe ff       	call   f0100f8b <cprintf>
f011b2ee:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b2f1:	e8 72 36 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b2f6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b2f9:	e8 a7 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b2fe:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b301:	83 ec 0c             	sub    $0xc,%esp
f011b304:	68 00 38 00 00       	push   $0x3800
f011b309:	e8 00 e2 fe ff       	call   f010950e <kmalloc>
f011b30e:	83 c4 10             	add    $0x10,%esp
f011b311:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b317:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b31d:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b322:	74 17                	je     f011b33b <test_kheap_phys_addr+0x5a9>
f011b324:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b32b:	83 ec 0c             	sub    $0xc,%esp
f011b32e:	68 68 ef 12 f0       	push   $0xf012ef68
f011b333:	e8 53 5c fe ff       	call   f0100f8b <cprintf>
f011b338:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b33b:	e8 65 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b340:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b343:	74 17                	je     f011b35c <test_kheap_phys_addr+0x5ca>
f011b345:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b34c:	83 ec 0c             	sub    $0xc,%esp
f011b34f:	68 bc ef 12 f0       	push   $0xf012efbc
f011b354:	e8 32 5c fe ff       	call   f0100f8b <cprintf>
f011b359:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b35c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b35f:	e8 04 36 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b364:	29 c3                	sub    %eax,%ebx
f011b366:	89 d8                	mov    %ebx,%eax
f011b368:	83 f8 03             	cmp    $0x3,%eax
f011b36b:	77 17                	ja     f011b384 <test_kheap_phys_addr+0x5f2>
f011b36d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b374:	83 ec 0c             	sub    $0xc,%esp
f011b377:	68 2c f0 12 f0       	push   $0xf012f02c
f011b37c:	e8 0a 5c fe ff       	call   f0100f8b <cprintf>
f011b381:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b384:	83 ec 0c             	sub    $0xc,%esp
f011b387:	68 74 f0 12 f0       	push   $0xf012f074
f011b38c:	e8 fa 5b fe ff       	call   f0100f8b <cprintf>
f011b391:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b394:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b39b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b3a2:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b3a9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b3ae:	05 00 10 00 00       	add    $0x1000,%eax
f011b3b3:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b3b6:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b3b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b3bc:	eb 2e                	jmp    f011b3ec <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b3be:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b3c1:	8d 43 01             	lea    0x1(%ebx),%eax
f011b3c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b3c7:	83 ec 0c             	sub    $0xc,%esp
f011b3ca:	ff 75 e8             	pushl  -0x18(%ebp)
f011b3cd:	e8 c0 e4 fe ff       	call   f0109892 <kheap_physical_address>
f011b3d2:	83 c4 10             	add    $0x10,%esp
f011b3d5:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b3dc:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b3df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b3e2:	01 d0                	add    %edx,%eax
f011b3e4:	05 00 10 00 00       	add    $0x1000,%eax
f011b3e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b3ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b3ef:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b3f2:	72 ca                	jb     f011b3be <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b3f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3f7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b3fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b401:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b404:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b407:	e9 ce 00 00 00       	jmp    f011b4da <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b40c:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b411:	83 ec 04             	sub    $0x4,%esp
f011b414:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b41a:	52                   	push   %edx
f011b41b:	ff 75 e8             	pushl  -0x18(%ebp)
f011b41e:	50                   	push   %eax
f011b41f:	e8 cb cf fe ff       	call   f01083ef <get_page_table>
f011b424:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b427:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b42d:	85 c0                	test   %eax,%eax
f011b42f:	75 1e                	jne    f011b44f <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b431:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b438:	83 ec 04             	sub    $0x4,%esp
f011b43b:	68 c0 f0 12 f0       	push   $0xf012f0c0
f011b440:	68 e7 05 00 00       	push   $0x5e7
f011b445:	68 53 ce 12 f0       	push   $0xf012ce53
f011b44a:	e8 ea 4e fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b44f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b452:	c1 e8 0c             	shr    $0xc,%eax
f011b455:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b45a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b45d:	eb 62                	jmp    f011b4c1 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b45f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b465:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b468:	c1 e2 02             	shl    $0x2,%edx
f011b46b:	01 d0                	add    %edx,%eax
f011b46d:	8b 00                	mov    (%eax),%eax
f011b46f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b474:	89 c2                	mov    %eax,%edx
f011b476:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b479:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b47e:	01 c2                	add    %eax,%edx
f011b480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b483:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b48a:	39 c2                	cmp    %eax,%edx
f011b48c:	74 1d                	je     f011b4ab <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b48e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b492:	74 17                	je     f011b4ab <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b494:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b49b:	83 ec 0c             	sub    $0xc,%esp
f011b49e:	68 20 f1 12 f0       	push   $0xf012f120
f011b4a3:	e8 e3 5a fe ff       	call   f0100f8b <cprintf>
f011b4a8:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b4ab:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b4ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b4b1:	01 d0                	add    %edx,%eax
f011b4b3:	05 00 10 00 00       	add    $0x1000,%eax
f011b4b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b4bb:	ff 45 e4             	incl   -0x1c(%ebp)
f011b4be:	ff 45 f4             	incl   -0xc(%ebp)
f011b4c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b4c4:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b4c7:	7d 11                	jge    f011b4da <test_kheap_phys_addr+0x748>
f011b4c9:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b4d0:	7f 08                	jg     f011b4da <test_kheap_phys_addr+0x748>
f011b4d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b4d5:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b4d8:	72 85                	jb     f011b45f <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b4da:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b4dd:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b4e0:	0f 82 26 ff ff ff    	jb     f011b40c <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b4e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b4ea:	74 04                	je     f011b4f0 <test_kheap_phys_addr+0x75e>
f011b4ec:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b4f0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b4f7:	83 ec 0c             	sub    $0xc,%esp
f011b4fa:	68 44 f1 12 f0       	push   $0xf012f144
f011b4ff:	e8 87 5a fe ff       	call   f0100f8b <cprintf>
f011b504:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b507:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b50e:	e9 b0 00 00 00       	jmp    f011b5c3 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b513:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b516:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b51d:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b520:	83 ec 0c             	sub    $0xc,%esp
f011b523:	ff 75 90             	pushl  -0x70(%ebp)
f011b526:	e8 67 e3 fe ff       	call   f0109892 <kheap_physical_address>
f011b52b:	83 c4 10             	add    $0x10,%esp
f011b52e:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b531:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b536:	83 ec 04             	sub    $0x4,%esp
f011b539:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b53f:	52                   	push   %edx
f011b540:	ff 75 90             	pushl  -0x70(%ebp)
f011b543:	50                   	push   %eax
f011b544:	e8 a6 ce fe ff       	call   f01083ef <get_page_table>
f011b549:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b54c:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b552:	85 c0                	test   %eax,%eax
f011b554:	75 1e                	jne    f011b574 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b556:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b55d:	83 ec 04             	sub    $0x4,%esp
f011b560:	68 94 f1 12 f0       	push   $0xf012f194
f011b565:	68 04 06 00 00       	push   $0x604
f011b56a:	68 53 ce 12 f0       	push   $0xf012ce53
f011b56f:	e8 c5 4d fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b574:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b57a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b57d:	c1 ea 0c             	shr    $0xc,%edx
f011b580:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b586:	c1 e2 02             	shl    $0x2,%edx
f011b589:	01 d0                	add    %edx,%eax
f011b58b:	8b 00                	mov    (%eax),%eax
f011b58d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b592:	89 c2                	mov    %eax,%edx
f011b594:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b597:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b59c:	01 d0                	add    %edx,%eax
f011b59e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b5a1:	74 1d                	je     f011b5c0 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b5a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b5a7:	74 17                	je     f011b5c0 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b5a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5b0:	83 ec 0c             	sub    $0xc,%esp
f011b5b3:	68 f4 f1 12 f0       	push   $0xf012f1f4
f011b5b8:	e8 ce 59 fe ff       	call   f0100f8b <cprintf>
f011b5bd:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b5c0:	ff 45 e0             	incl   -0x20(%ebp)
f011b5c3:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b5c7:	0f 8e 46 ff ff ff    	jle    f011b513 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b5cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b5d1:	74 04                	je     f011b5d7 <test_kheap_phys_addr+0x845>
f011b5d3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b5d7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b5de:	83 ec 0c             	sub    $0xc,%esp
f011b5e1:	68 18 f2 12 f0       	push   $0xf012f218
f011b5e6:	e8 a0 59 fe ff       	call   f0100f8b <cprintf>
f011b5eb:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b5ee:	e8 75 33 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b5f3:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b5f6:	e8 aa 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5fb:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b5fe:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b604:	83 ec 0c             	sub    $0xc,%esp
f011b607:	50                   	push   %eax
f011b608:	e8 80 e1 fe ff       	call   f010978d <kfree>
f011b60d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b610:	e8 90 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b615:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b618:	74 17                	je     f011b631 <test_kheap_phys_addr+0x89f>
f011b61a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b621:	83 ec 0c             	sub    $0xc,%esp
f011b624:	68 04 dd 12 f0       	push   $0xf012dd04
f011b629:	e8 5d 59 fe ff       	call   f0100f8b <cprintf>
f011b62e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b631:	e8 32 33 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b636:	89 c2                	mov    %eax,%edx
f011b638:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b63b:	29 c2                	sub    %eax,%edx
f011b63d:	89 d0                	mov    %edx,%eax
f011b63f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b644:	77 17                	ja     f011b65d <test_kheap_phys_addr+0x8cb>
f011b646:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b64d:	83 ec 0c             	sub    $0xc,%esp
f011b650:	68 40 f2 12 f0       	push   $0xf012f240
f011b655:	e8 31 59 fe ff       	call   f0100f8b <cprintf>
f011b65a:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b65d:	e8 06 33 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b662:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b665:	e8 3b 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b66a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b66d:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b673:	83 ec 0c             	sub    $0xc,%esp
f011b676:	50                   	push   %eax
f011b677:	e8 11 e1 fe ff       	call   f010978d <kfree>
f011b67c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b67f:	e8 21 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b684:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b687:	74 17                	je     f011b6a0 <test_kheap_phys_addr+0x90e>
f011b689:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b690:	83 ec 0c             	sub    $0xc,%esp
f011b693:	68 44 de 12 f0       	push   $0xf012de44
f011b698:	e8 ee 58 fe ff       	call   f0100f8b <cprintf>
f011b69d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b6a0:	e8 c3 32 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b6a5:	89 c2                	mov    %eax,%edx
f011b6a7:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b6aa:	29 c2                	sub    %eax,%edx
f011b6ac:	89 d0                	mov    %edx,%eax
f011b6ae:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b6b3:	77 17                	ja     f011b6cc <test_kheap_phys_addr+0x93a>
f011b6b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6bc:	83 ec 0c             	sub    $0xc,%esp
f011b6bf:	68 7c f2 12 f0       	push   $0xf012f27c
f011b6c4:	e8 c2 58 fe ff       	call   f0100f8b <cprintf>
f011b6c9:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b6cc:	e8 97 32 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b6d1:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b6d4:	e8 cc 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6d9:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b6dc:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b6e2:	83 ec 0c             	sub    $0xc,%esp
f011b6e5:	50                   	push   %eax
f011b6e6:	e8 a2 e0 fe ff       	call   f010978d <kfree>
f011b6eb:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6ee:	e8 b2 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6f3:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b6f6:	74 17                	je     f011b70f <test_kheap_phys_addr+0x97d>
f011b6f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6ff:	83 ec 0c             	sub    $0xc,%esp
f011b702:	68 50 df 12 f0       	push   $0xf012df50
f011b707:	e8 7f 58 fe ff       	call   f0100f8b <cprintf>
f011b70c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b70f:	e8 54 32 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011b714:	89 c2                	mov    %eax,%edx
f011b716:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b719:	29 c2                	sub    %eax,%edx
f011b71b:	89 d0                	mov    %edx,%eax
f011b71d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b722:	77 17                	ja     f011b73b <test_kheap_phys_addr+0x9a9>
f011b724:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b72b:	83 ec 0c             	sub    $0xc,%esp
f011b72e:	68 b8 f2 12 f0       	push   $0xf012f2b8
f011b733:	e8 53 58 fe ff       	call   f0100f8b <cprintf>
f011b738:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b73b:	83 ec 0c             	sub    $0xc,%esp
f011b73e:	68 f4 f2 12 f0       	push   $0xf012f2f4
f011b743:	e8 43 58 fe ff       	call   f0100f8b <cprintf>
f011b748:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b74b:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b752:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b759:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b760:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b763:	8b 15 d8 fd 17 f0    	mov    0xf017fdd8,%edx
f011b769:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b76f:	01 d0                	add    %edx,%eax
f011b771:	05 00 10 00 00       	add    $0x1000,%eax
f011b776:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b77c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b782:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b785:	eb 25                	jmp    f011b7ac <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b787:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b78a:	8d 43 01             	lea    0x1(%ebx),%eax
f011b78d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b790:	83 ec 0c             	sub    $0xc,%esp
f011b793:	ff 75 d8             	pushl  -0x28(%ebp)
f011b796:	e8 f7 e0 fe ff       	call   f0109892 <kheap_physical_address>
f011b79b:	83 c4 10             	add    $0x10,%esp
f011b79e:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b7a5:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b7ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b7af:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b7b2:	72 d3                	jb     f011b787 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b7b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b7b7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b7bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b7c4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b7ca:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b7cd:	e9 f4 00 00 00       	jmp    f011b8c6 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b7d2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b7d7:	83 ec 04             	sub    $0x4,%esp
f011b7da:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b7e0:	52                   	push   %edx
f011b7e1:	ff 75 d8             	pushl  -0x28(%ebp)
f011b7e4:	50                   	push   %eax
f011b7e5:	e8 05 cc fe ff       	call   f01083ef <get_page_table>
f011b7ea:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b7ed:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b7f3:	85 c0                	test   %eax,%eax
f011b7f5:	75 24                	jne    f011b81b <test_kheap_phys_addr+0xa89>
				if (correct)
f011b7f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7fb:	74 1e                	je     f011b81b <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b7fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b804:	83 ec 04             	sub    $0x4,%esp
f011b807:	68 44 f3 12 f0       	push   $0xf012f344
f011b80c:	68 42 06 00 00       	push   $0x642
f011b811:	68 53 ce 12 f0       	push   $0xf012ce53
f011b816:	e8 1e 4b fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b81b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b81e:	c1 e8 0c             	shr    $0xc,%eax
f011b821:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b826:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b829:	eb 7b                	jmp    f011b8a6 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b82b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b832:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b838:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b83b:	c1 e2 02             	shl    $0x2,%edx
f011b83e:	01 d0                	add    %edx,%eax
f011b840:	8b 00                	mov    (%eax),%eax
f011b842:	83 e0 01             	and    $0x1,%eax
f011b845:	85 c0                	test   %eax,%eax
f011b847:	74 24                	je     f011b86d <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b849:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b84f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b852:	c1 e2 02             	shl    $0x2,%edx
f011b855:	01 d0                	add    %edx,%eax
f011b857:	8b 00                	mov    (%eax),%eax
f011b859:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b85e:	89 c2                	mov    %eax,%edx
f011b860:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b863:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b868:	01 d0                	add    %edx,%eax
f011b86a:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b86d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b870:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b877:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b87a:	74 1d                	je     f011b899 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b87c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b880:	74 17                	je     f011b899 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b882:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b889:	83 ec 0c             	sub    $0xc,%esp
f011b88c:	68 a4 f3 12 f0       	push   $0xf012f3a4
f011b891:	e8 f5 56 fe ff       	call   f0100f8b <cprintf>
f011b896:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b899:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b8a0:	ff 45 d4             	incl   -0x2c(%ebp)
f011b8a3:	ff 45 f4             	incl   -0xc(%ebp)
f011b8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b8a9:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b8af:	7d 15                	jge    f011b8c6 <test_kheap_phys_addr+0xb34>
f011b8b1:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b8b8:	7f 0c                	jg     f011b8c6 <test_kheap_phys_addr+0xb34>
f011b8ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b8bd:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b8c0:	0f 82 65 ff ff ff    	jb     f011b82b <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b8c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b8c9:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b8cc:	0f 82 00 ff ff ff    	jb     f011b7d2 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b8d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b8d6:	74 04                	je     f011b8dc <test_kheap_phys_addr+0xb4a>
f011b8d8:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b8dc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b8e3:	83 ec 0c             	sub    $0xc,%esp
f011b8e6:	68 c8 f3 12 f0       	push   $0xf012f3c8
f011b8eb:	e8 9b 56 fe ff       	call   f0100f8b <cprintf>
f011b8f0:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b8f3:	83 ec 0c             	sub    $0xc,%esp
f011b8f6:	6a 00                	push   $0x0
f011b8f8:	e8 de da fe ff       	call   f01093db <sbrk>
f011b8fd:	83 c4 10             	add    $0x10,%esp
f011b900:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b905:	77 17                	ja     f011b91e <test_kheap_phys_addr+0xb8c>
f011b907:	83 ec 04             	sub    $0x4,%esp
f011b90a:	68 20 f4 12 f0       	push   $0xf012f420
f011b90f:	68 5d 06 00 00       	push   $0x65d
f011b914:	68 53 ce 12 f0       	push   $0xf012ce53
f011b919:	e8 1b 4a fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b91e:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b925:	e9 af 00 00 00       	jmp    f011b9d9 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b92a:	83 ec 0c             	sub    $0xc,%esp
f011b92d:	ff 75 d0             	pushl  -0x30(%ebp)
f011b930:	e8 5d df fe ff       	call   f0109892 <kheap_physical_address>
f011b935:	83 c4 10             	add    $0x10,%esp
f011b938:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b93e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b943:	83 ec 04             	sub    $0x4,%esp
f011b946:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b94c:	52                   	push   %edx
f011b94d:	ff 75 d0             	pushl  -0x30(%ebp)
f011b950:	50                   	push   %eax
f011b951:	e8 99 ca fe ff       	call   f01083ef <get_page_table>
f011b956:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b959:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b95f:	85 c0                	test   %eax,%eax
f011b961:	75 24                	jne    f011b987 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b963:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b967:	74 1e                	je     f011b987 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b969:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b970:	83 ec 04             	sub    $0x4,%esp
f011b973:	68 3c f4 12 f0       	push   $0xf012f43c
f011b978:	68 65 06 00 00       	push   $0x665
f011b97d:	68 53 ce 12 f0       	push   $0xf012ce53
f011b982:	e8 b2 49 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b987:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b98d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b990:	c1 ea 0c             	shr    $0xc,%edx
f011b993:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b999:	c1 e2 02             	shl    $0x2,%edx
f011b99c:	01 d0                	add    %edx,%eax
f011b99e:	8b 00                	mov    (%eax),%eax
f011b9a0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b9a5:	89 c2                	mov    %eax,%edx
f011b9a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b9aa:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b9af:	01 d0                	add    %edx,%eax
f011b9b1:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b9b7:	74 1d                	je     f011b9d6 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b9b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b9bd:	74 17                	je     f011b9d6 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b9bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9c6:	83 ec 0c             	sub    $0xc,%esp
f011b9c9:	68 9c f4 12 f0       	push   $0xf012f49c
f011b9ce:	e8 b8 55 fe ff       	call   f0100f8b <cprintf>
f011b9d3:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b9d6:	ff 45 d0             	incl   -0x30(%ebp)
f011b9d9:	83 ec 0c             	sub    $0xc,%esp
f011b9dc:	6a 00                	push   $0x0
f011b9de:	e8 f8 d9 fe ff       	call   f01093db <sbrk>
f011b9e3:	83 c4 10             	add    $0x10,%esp
f011b9e6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b9e9:	0f 87 3b ff ff ff    	ja     f011b92a <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b9ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b9f3:	74 04                	je     f011b9f9 <test_kheap_phys_addr+0xc67>
f011b9f5:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b9f9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011ba00:	83 ec 0c             	sub    $0xc,%esp
f011ba03:	68 c0 f4 12 f0       	push   $0xf012f4c0
f011ba08:	e8 7e 55 fe ff       	call   f0100f8b <cprintf>
f011ba0d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011ba10:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011ba17:	10 00 f9 
		i = 0;
f011ba1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011ba21:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ba27:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011ba2a:	eb 0a                	jmp    f011ba36 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011ba2c:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011ba2f:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011ba36:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011ba3d:	76 ed                	jbe    f011ba2c <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011ba3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba42:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011ba48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011ba4f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ba55:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011ba58:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011ba5f:	e9 cb 00 00 00       	jmp    f011bb2f <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011ba64:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011ba67:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011ba6c:	83 ec 04             	sub    $0x4,%esp
f011ba6f:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011ba75:	51                   	push   %ecx
f011ba76:	52                   	push   %edx
f011ba77:	50                   	push   %eax
f011ba78:	e8 72 c9 fe ff       	call   f01083ef <get_page_table>
f011ba7d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ba80:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011ba86:	85 c0                	test   %eax,%eax
f011ba88:	75 24                	jne    f011baae <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011ba8a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba8e:	74 1e                	je     f011baae <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ba90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba97:	83 ec 04             	sub    $0x4,%esp
f011ba9a:	68 fc f4 12 f0       	push   $0xf012f4fc
f011ba9f:	68 87 06 00 00       	push   $0x687
f011baa4:	68 53 ce 12 f0       	push   $0xf012ce53
f011baa9:	e8 8b 48 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011baae:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011bab5:	eb 59                	jmp    f011bb10 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011bab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011baba:	c1 e0 0c             	shl    $0xc,%eax
f011babd:	89 c2                	mov    %eax,%edx
f011babf:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bac5:	01 d0                	add    %edx,%eax
f011bac7:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011bacd:	83 ec 0c             	sub    $0xc,%esp
f011bad0:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bad6:	e8 b7 dd fe ff       	call   f0109892 <kheap_physical_address>
f011badb:	83 c4 10             	add    $0x10,%esp
f011bade:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011bae4:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011baeb:	74 1d                	je     f011bb0a <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011baed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011baf1:	74 17                	je     f011bb0a <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011baf3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bafa:	83 ec 0c             	sub    $0xc,%esp
f011bafd:	68 5c f5 12 f0       	push   $0xf012f55c
f011bb02:	e8 84 54 fe ff       	call   f0100f8b <cprintf>
f011bb07:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bb0a:	ff 45 c8             	incl   -0x38(%ebp)
f011bb0d:	ff 45 f4             	incl   -0xc(%ebp)
f011bb10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb13:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bb19:	7d 09                	jge    f011bb24 <test_kheap_phys_addr+0xd92>
f011bb1b:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011bb22:	7e 93                	jle    f011bab7 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bb24:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011bb2b:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011bb2f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bb33:	0f 88 2b ff ff ff    	js     f011ba64 <test_kheap_phys_addr+0xcd2>
f011bb39:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bb3d:	7f 0d                	jg     f011bb4c <test_kheap_phys_addr+0xdba>
f011bb3f:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011bb46:	0f 86 18 ff ff ff    	jbe    f011ba64 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011bb4c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb50:	74 04                	je     f011bb56 <test_kheap_phys_addr+0xdc4>
f011bb52:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011bb56:	83 ec 08             	sub    $0x8,%esp
f011bb59:	ff 75 f0             	pushl  -0x10(%ebp)
f011bb5c:	68 80 f5 12 f0       	push   $0xf012f580
f011bb61:	e8 25 54 fe ff       	call   f0100f8b <cprintf>
f011bb66:	83 c4 10             	add    $0x10,%esp

	return 1;
f011bb69:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bb6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bb71:	5b                   	pop    %ebx
f011bb72:	5f                   	pop    %edi
f011bb73:	5d                   	pop    %ebp
f011bb74:	c3                   	ret    

f011bb75 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011bb75:	55                   	push   %ebp
f011bb76:	89 e5                	mov    %esp,%ebp
f011bb78:	57                   	push   %edi
f011bb79:	56                   	push   %esi
f011bb7a:	53                   	push   %ebx
f011bb7b:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bb81:	89 e0                	mov    %esp,%eax
f011bb83:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bb85:	83 ec 0c             	sub    $0xc,%esp
f011bb88:	68 08 af 12 f0       	push   $0xf012af08
f011bb8d:	e8 f9 53 fe ff       	call   f0100f8b <cprintf>
f011bb92:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bb95:	83 ec 0c             	sub    $0xc,%esp
f011bb98:	68 38 af 12 f0       	push   $0xf012af38
f011bb9d:	e8 e9 53 fe ff       	call   f0100f8b <cprintf>
f011bba2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011bba5:	83 ec 0c             	sub    $0xc,%esp
f011bba8:	68 08 af 12 f0       	push   $0xf012af08
f011bbad:	e8 d9 53 fe ff       	call   f0100f8b <cprintf>
f011bbb2:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bbb5:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011bbb9:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bbbd:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bbc3:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bbc9:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bbd0:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011bbd7:	e8 8c 2d ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bbdc:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bbdf:	83 ec 0c             	sub    $0xc,%esp
f011bbe2:	68 5c ec 12 f0       	push   $0xf012ec5c
f011bbe7:	e8 9f 53 fe ff       	call   f0100f8b <cprintf>
f011bbec:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011bbef:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bbf5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bbfa:	b8 00 00 00 00       	mov    $0x0,%eax
f011bbff:	89 d7                	mov    %edx,%edi
f011bc01:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bc03:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bc09:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bc0e:	b8 00 00 00 00       	mov    $0x0,%eax
f011bc13:	89 d7                	mov    %edx,%edi
f011bc15:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bc17:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011bc1e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bc25:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bc2b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bc30:	b8 00 00 00 00       	mov    $0x0,%eax
f011bc35:	89 d7                	mov    %edx,%edi
f011bc37:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc39:	e8 2a 2d ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bc3e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc41:	e8 5f 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc46:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bc49:	83 ec 0c             	sub    $0xc,%esp
f011bc4c:	68 00 fc 1f 00       	push   $0x1ffc00
f011bc51:	e8 b8 d8 fe ff       	call   f010950e <kmalloc>
f011bc56:	83 c4 10             	add    $0x10,%esp
f011bc59:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc5f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bc65:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bc6a:	74 17                	je     f011bc83 <test_kheap_virt_addr+0x10e>
f011bc6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc73:	83 ec 0c             	sub    $0xc,%esp
f011bc76:	68 00 d0 12 f0       	push   $0xf012d000
f011bc7b:	e8 0b 53 fe ff       	call   f0100f8b <cprintf>
f011bc80:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc83:	e8 1d 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc88:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bc8b:	74 17                	je     f011bca4 <test_kheap_virt_addr+0x12f>
f011bc8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc94:	83 ec 0c             	sub    $0xc,%esp
f011bc97:	68 54 d0 12 f0       	push   $0xf012d054
f011bc9c:	e8 ea 52 fe ff       	call   f0100f8b <cprintf>
f011bca1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bca4:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bca7:	e8 bc 2c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bcac:	29 c3                	sub    %eax,%ebx
f011bcae:	89 d8                	mov    %ebx,%eax
f011bcb0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bcb5:	77 17                	ja     f011bcce <test_kheap_virt_addr+0x159>
f011bcb7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcbe:	83 ec 0c             	sub    $0xc,%esp
f011bcc1:	68 c4 d0 12 f0       	push   $0xf012d0c4
f011bcc6:	e8 c0 52 fe ff       	call   f0100f8b <cprintf>
f011bccb:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bcce:	e8 95 2c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bcd3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bcd6:	e8 ca 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcdb:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bcde:	83 ec 0c             	sub    $0xc,%esp
f011bce1:	68 00 fc 1f 00       	push   $0x1ffc00
f011bce6:	e8 23 d8 fe ff       	call   f010950e <kmalloc>
f011bceb:	83 c4 10             	add    $0x10,%esp
f011bcee:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bcf4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bcfa:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bcff:	74 17                	je     f011bd18 <test_kheap_virt_addr+0x1a3>
f011bd01:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd08:	83 ec 0c             	sub    $0xc,%esp
f011bd0b:	68 0c d1 12 f0       	push   $0xf012d10c
f011bd10:	e8 76 52 fe ff       	call   f0100f8b <cprintf>
f011bd15:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd18:	e8 88 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd1d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bd20:	74 17                	je     f011bd39 <test_kheap_virt_addr+0x1c4>
f011bd22:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd29:	83 ec 0c             	sub    $0xc,%esp
f011bd2c:	68 60 d1 12 f0       	push   $0xf012d160
f011bd31:	e8 55 52 fe ff       	call   f0100f8b <cprintf>
f011bd36:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bd39:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bd3c:	e8 27 2c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bd41:	29 c3                	sub    %eax,%ebx
f011bd43:	89 d8                	mov    %ebx,%eax
f011bd45:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd4a:	77 17                	ja     f011bd63 <test_kheap_virt_addr+0x1ee>
f011bd4c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd53:	83 ec 0c             	sub    $0xc,%esp
f011bd56:	68 d0 d1 12 f0       	push   $0xf012d1d0
f011bd5b:	e8 2b 52 fe ff       	call   f0100f8b <cprintf>
f011bd60:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011bd63:	e8 00 2c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bd68:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bd6b:	e8 35 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd70:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011bd73:	83 ec 0c             	sub    $0xc,%esp
f011bd76:	68 00 04 00 00       	push   $0x400
f011bd7b:	e8 8e d7 fe ff       	call   f010950e <kmalloc>
f011bd80:	83 c4 10             	add    $0x10,%esp
f011bd83:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bd89:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bd8f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bd94:	76 28                	jbe    f011bdbe <test_kheap_virt_addr+0x249>
f011bd96:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011bd9c:	83 ec 0c             	sub    $0xc,%esp
f011bd9f:	6a 00                	push   $0x0
f011bda1:	e8 35 d6 fe ff       	call   f01093db <sbrk>
f011bda6:	83 c4 10             	add    $0x10,%esp
f011bda9:	39 c3                	cmp    %eax,%ebx
f011bdab:	73 11                	jae    f011bdbe <test_kheap_virt_addr+0x249>
f011bdad:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bdb3:	89 c2                	mov    %eax,%edx
f011bdb5:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bdba:	39 c2                	cmp    %eax,%edx
f011bdbc:	72 17                	jb     f011bdd5 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bdbe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdc5:	83 ec 0c             	sub    $0xc,%esp
f011bdc8:	68 8c ec 12 f0       	push   $0xf012ec8c
f011bdcd:	e8 b9 51 fe ff       	call   f0100f8b <cprintf>
f011bdd2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdd5:	e8 cb 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bdda:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bddd:	74 17                	je     f011bdf6 <test_kheap_virt_addr+0x281>
f011bddf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bde6:	83 ec 0c             	sub    $0xc,%esp
f011bde9:	68 6c d2 12 f0       	push   $0xf012d26c
f011bdee:	e8 98 51 fe ff       	call   f0100f8b <cprintf>
f011bdf3:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011bdf6:	e8 6d 2b ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bdfb:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bdfe:	e8 a2 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be03:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011be06:	83 ec 0c             	sub    $0xc,%esp
f011be09:	68 00 08 00 00       	push   $0x800
f011be0e:	e8 fb d6 fe ff       	call   f010950e <kmalloc>
f011be13:	83 c4 10             	add    $0x10,%esp
f011be16:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011be1c:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011be22:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011be27:	76 28                	jbe    f011be51 <test_kheap_virt_addr+0x2dc>
f011be29:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011be2f:	83 ec 0c             	sub    $0xc,%esp
f011be32:	6a 00                	push   $0x0
f011be34:	e8 a2 d5 fe ff       	call   f01093db <sbrk>
f011be39:	83 c4 10             	add    $0x10,%esp
f011be3c:	39 c3                	cmp    %eax,%ebx
f011be3e:	73 11                	jae    f011be51 <test_kheap_virt_addr+0x2dc>
f011be40:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011be46:	89 c2                	mov    %eax,%edx
f011be48:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011be4d:	39 c2                	cmp    %eax,%edx
f011be4f:	72 17                	jb     f011be68 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011be51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be58:	83 ec 0c             	sub    $0xc,%esp
f011be5b:	68 18 ed 12 f0       	push   $0xf012ed18
f011be60:	e8 26 51 fe ff       	call   f0100f8b <cprintf>
f011be65:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be68:	e8 38 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be6d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011be70:	74 17                	je     f011be89 <test_kheap_virt_addr+0x314>
f011be72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be79:	83 ec 0c             	sub    $0xc,%esp
f011be7c:	68 78 d3 12 f0       	push   $0xf012d378
f011be81:	e8 05 51 fe ff       	call   f0100f8b <cprintf>
f011be86:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011be89:	e8 da 2a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011be8e:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011be91:	e8 0f 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be96:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011be99:	83 ec 0c             	sub    $0xc,%esp
f011be9c:	68 00 06 00 00       	push   $0x600
f011bea1:	e8 68 d6 fe ff       	call   f010950e <kmalloc>
f011bea6:	83 c4 10             	add    $0x10,%esp
f011bea9:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011beaf:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011beb5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011beba:	76 28                	jbe    f011bee4 <test_kheap_virt_addr+0x36f>
f011bebc:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011bec2:	83 ec 0c             	sub    $0xc,%esp
f011bec5:	6a 00                	push   $0x0
f011bec7:	e8 0f d5 fe ff       	call   f01093db <sbrk>
f011becc:	83 c4 10             	add    $0x10,%esp
f011becf:	39 c3                	cmp    %eax,%ebx
f011bed1:	73 11                	jae    f011bee4 <test_kheap_virt_addr+0x36f>
f011bed3:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bed9:	89 c2                	mov    %eax,%edx
f011bedb:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bee0:	39 c2                	cmp    %eax,%edx
f011bee2:	72 17                	jb     f011befb <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bee4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011beeb:	83 ec 0c             	sub    $0xc,%esp
f011beee:	68 a4 ed 12 f0       	push   $0xf012eda4
f011bef3:	e8 93 50 fe ff       	call   f0100f8b <cprintf>
f011bef8:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011befb:	e8 a5 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf00:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf03:	74 17                	je     f011bf1c <test_kheap_virt_addr+0x3a7>
f011bf05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf0c:	83 ec 0c             	sub    $0xc,%esp
f011bf0f:	68 84 d4 12 f0       	push   $0xf012d484
f011bf14:	e8 72 50 fe ff       	call   f0100f8b <cprintf>
f011bf19:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011bf1c:	e8 47 2a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bf21:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf24:	e8 7c 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf29:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bf2c:	83 ec 0c             	sub    $0xc,%esp
f011bf2f:	68 00 1c 00 00       	push   $0x1c00
f011bf34:	e8 d5 d5 fe ff       	call   f010950e <kmalloc>
f011bf39:	83 c4 10             	add    $0x10,%esp
f011bf3c:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf42:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bf48:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bf4d:	74 17                	je     f011bf66 <test_kheap_virt_addr+0x3f1>
f011bf4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf56:	83 ec 0c             	sub    $0xc,%esp
f011bf59:	68 3c d5 12 f0       	push   $0xf012d53c
f011bf5e:	e8 28 50 fe ff       	call   f0100f8b <cprintf>
f011bf63:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf66:	e8 3a 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf6b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf6e:	74 17                	je     f011bf87 <test_kheap_virt_addr+0x412>
f011bf70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf77:	83 ec 0c             	sub    $0xc,%esp
f011bf7a:	68 90 d5 12 f0       	push   $0xf012d590
f011bf7f:	e8 07 50 fe ff       	call   f0100f8b <cprintf>
f011bf84:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bf87:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bf8a:	e8 d9 29 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bf8f:	29 c3                	sub    %eax,%ebx
f011bf91:	89 d8                	mov    %ebx,%eax
f011bf93:	83 f8 01             	cmp    $0x1,%eax
f011bf96:	77 17                	ja     f011bfaf <test_kheap_virt_addr+0x43a>
f011bf98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf9f:	83 ec 0c             	sub    $0xc,%esp
f011bfa2:	68 00 d6 12 f0       	push   $0xf012d600
f011bfa7:	e8 df 4f fe ff       	call   f0100f8b <cprintf>
f011bfac:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bfaf:	e8 b4 29 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011bfb4:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bfb7:	e8 e9 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bfbc:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bfbf:	83 ec 0c             	sub    $0xc,%esp
f011bfc2:	68 00 fc 2f 00       	push   $0x2ffc00
f011bfc7:	e8 42 d5 fe ff       	call   f010950e <kmalloc>
f011bfcc:	83 c4 10             	add    $0x10,%esp
f011bfcf:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bfd5:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bfdb:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bfe0:	74 17                	je     f011bff9 <test_kheap_virt_addr+0x484>
f011bfe2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfe9:	83 ec 0c             	sub    $0xc,%esp
f011bfec:	68 30 ee 12 f0       	push   $0xf012ee30
f011bff1:	e8 95 4f fe ff       	call   f0100f8b <cprintf>
f011bff6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bff9:	e8 a7 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bffe:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c001:	74 17                	je     f011c01a <test_kheap_virt_addr+0x4a5>
f011c003:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c00a:	83 ec 0c             	sub    $0xc,%esp
f011c00d:	68 d4 d6 12 f0       	push   $0xf012d6d4
f011c012:	e8 74 4f fe ff       	call   f0100f8b <cprintf>
f011c017:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c01a:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c01d:	e8 46 29 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c022:	29 c3                	sub    %eax,%ebx
f011c024:	89 d8                	mov    %ebx,%eax
f011c026:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c02b:	77 17                	ja     f011c044 <test_kheap_virt_addr+0x4cf>
f011c02d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c034:	83 ec 0c             	sub    $0xc,%esp
f011c037:	68 84 ee 12 f0       	push   $0xf012ee84
f011c03c:	e8 4a 4f fe ff       	call   f0100f8b <cprintf>
f011c041:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c044:	e8 1f 29 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c049:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c04c:	e8 54 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c051:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011c054:	83 ec 0c             	sub    $0xc,%esp
f011c057:	68 00 fc 5f 00       	push   $0x5ffc00
f011c05c:	e8 ad d4 fe ff       	call   f010950e <kmalloc>
f011c061:	83 c4 10             	add    $0x10,%esp
f011c064:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c06a:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c070:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c075:	74 17                	je     f011c08e <test_kheap_virt_addr+0x519>
f011c077:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c07e:	83 ec 0c             	sub    $0xc,%esp
f011c081:	68 cc ee 12 f0       	push   $0xf012eecc
f011c086:	e8 00 4f fe ff       	call   f0100f8b <cprintf>
f011c08b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c08e:	e8 12 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c093:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c096:	74 17                	je     f011c0af <test_kheap_virt_addr+0x53a>
f011c098:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c09f:	83 ec 0c             	sub    $0xc,%esp
f011c0a2:	68 d0 d7 12 f0       	push   $0xf012d7d0
f011c0a7:	e8 df 4e fe ff       	call   f0100f8b <cprintf>
f011c0ac:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c0af:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c0b2:	e8 b1 28 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c0b7:	29 c3                	sub    %eax,%ebx
f011c0b9:	89 d8                	mov    %ebx,%eax
f011c0bb:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c0c0:	77 17                	ja     f011c0d9 <test_kheap_virt_addr+0x564>
f011c0c2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0c9:	83 ec 0c             	sub    $0xc,%esp
f011c0cc:	68 20 ef 12 f0       	push   $0xf012ef20
f011c0d1:	e8 b5 4e fe ff       	call   f0100f8b <cprintf>
f011c0d6:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c0d9:	e8 8a 28 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c0de:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c0e1:	e8 bf 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c0e6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c0e9:	83 ec 0c             	sub    $0xc,%esp
f011c0ec:	68 00 38 00 00       	push   $0x3800
f011c0f1:	e8 18 d4 fe ff       	call   f010950e <kmalloc>
f011c0f6:	83 c4 10             	add    $0x10,%esp
f011c0f9:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c0ff:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c105:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c10a:	74 17                	je     f011c123 <test_kheap_virt_addr+0x5ae>
f011c10c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c113:	83 ec 0c             	sub    $0xc,%esp
f011c116:	68 68 ef 12 f0       	push   $0xf012ef68
f011c11b:	e8 6b 4e fe ff       	call   f0100f8b <cprintf>
f011c120:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c123:	e8 7d 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c128:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c12b:	74 17                	je     f011c144 <test_kheap_virt_addr+0x5cf>
f011c12d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c134:	83 ec 0c             	sub    $0xc,%esp
f011c137:	68 bc ef 12 f0       	push   $0xf012efbc
f011c13c:	e8 4a 4e fe ff       	call   f0100f8b <cprintf>
f011c141:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c144:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c147:	e8 1c 28 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c14c:	29 c3                	sub    %eax,%ebx
f011c14e:	89 d8                	mov    %ebx,%eax
f011c150:	83 f8 03             	cmp    $0x3,%eax
f011c153:	77 17                	ja     f011c16c <test_kheap_virt_addr+0x5f7>
f011c155:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c15c:	83 ec 0c             	sub    $0xc,%esp
f011c15f:	68 2c f0 12 f0       	push   $0xf012f02c
f011c164:	e8 22 4e fe ff       	call   f0100f8b <cprintf>
f011c169:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c16c:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c173:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c176:	c1 e8 0c             	shr    $0xc,%eax
f011c179:	89 c2                	mov    %eax,%edx
f011c17b:	4a                   	dec    %edx
f011c17c:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c17f:	c1 e0 02             	shl    $0x2,%eax
f011c182:	8d 50 03             	lea    0x3(%eax),%edx
f011c185:	b8 10 00 00 00       	mov    $0x10,%eax
f011c18a:	48                   	dec    %eax
f011c18b:	01 d0                	add    %edx,%eax
f011c18d:	bf 10 00 00 00       	mov    $0x10,%edi
f011c192:	ba 00 00 00 00       	mov    $0x0,%edx
f011c197:	f7 f7                	div    %edi
f011c199:	6b c0 10             	imul   $0x10,%eax,%eax
f011c19c:	29 c4                	sub    %eax,%esp
f011c19e:	89 e0                	mov    %esp,%eax
f011c1a0:	83 c0 03             	add    $0x3,%eax
f011c1a3:	c1 e8 02             	shr    $0x2,%eax
f011c1a6:	c1 e0 02             	shl    $0x2,%eax
f011c1a9:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c1ac:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c1af:	c1 e8 0c             	shr    $0xc,%eax
f011c1b2:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c1b5:	83 ec 0c             	sub    $0xc,%esp
f011c1b8:	68 b4 f5 12 f0       	push   $0xf012f5b4
f011c1bd:	e8 c9 4d fe ff       	call   f0100f8b <cprintf>
f011c1c2:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c1c5:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c1cc:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c1d1:	05 00 10 00 00       	add    $0x1000,%eax
f011c1d6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c1d9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c1e0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c1e3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c1e6:	e9 2d 01 00 00       	jmp    f011c318 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c1eb:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011c1f0:	83 ec 04             	sub    $0x4,%esp
f011c1f3:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c1f9:	52                   	push   %edx
f011c1fa:	ff 75 dc             	pushl  -0x24(%ebp)
f011c1fd:	50                   	push   %eax
f011c1fe:	e8 ec c1 fe ff       	call   f01083ef <get_page_table>
f011c203:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c206:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c20c:	85 c0                	test   %eax,%eax
f011c20e:	75 1e                	jne    f011c22e <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c210:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c217:	83 ec 04             	sub    $0x4,%esp
f011c21a:	68 c0 f0 12 f0       	push   $0xf012f0c0
f011c21f:	68 26 07 00 00       	push   $0x726
f011c224:	68 53 ce 12 f0       	push   $0xf012ce53
f011c229:	e8 0b 41 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c22e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c231:	c1 e8 0c             	shr    $0xc,%eax
f011c234:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c239:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c23c:	e9 ba 00 00 00       	jmp    f011c2fb <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c241:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c244:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c247:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c24d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c250:	c1 e2 02             	shl    $0x2,%edx
f011c253:	01 d0                	add    %edx,%eax
f011c255:	8b 00                	mov    (%eax),%eax
f011c257:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c25c:	89 c2                	mov    %eax,%edx
f011c25e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c261:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c264:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c267:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c26a:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c26d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c270:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c273:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c276:	83 ec 0c             	sub    $0xc,%esp
f011c279:	50                   	push   %eax
f011c27a:	e8 70 d6 fe ff       	call   f01098ef <kheap_virtual_address>
f011c27f:	83 c4 10             	add    $0x10,%esp
f011c282:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c285:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c288:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c28b:	01 d0                	add    %edx,%eax
f011c28d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c290:	74 5c                	je     f011c2ee <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c292:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c296:	74 56                	je     f011c2ee <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c298:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c29b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c29e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c2a1:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c2a7:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c2aa:	c1 e1 02             	shl    $0x2,%ecx
f011c2ad:	01 ca                	add    %ecx,%edx
f011c2af:	8b 12                	mov    (%edx),%edx
f011c2b1:	89 d1                	mov    %edx,%ecx
f011c2b3:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c2b9:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c2bc:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c2bf:	01 da                	add    %ebx,%edx
f011c2c1:	83 ec 0c             	sub    $0xc,%esp
f011c2c4:	50                   	push   %eax
f011c2c5:	51                   	push   %ecx
f011c2c6:	52                   	push   %edx
f011c2c7:	ff 75 8c             	pushl  -0x74(%ebp)
f011c2ca:	68 00 f6 12 f0       	push   $0xf012f600
f011c2cf:	e8 b7 4c fe ff       	call   f0100f8b <cprintf>
f011c2d4:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c2d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2de:	83 ec 0c             	sub    $0xc,%esp
f011c2e1:	68 44 f6 12 f0       	push   $0xf012f644
f011c2e6:	e8 a0 4c fe ff       	call   f0100f8b <cprintf>
f011c2eb:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c2ee:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c2f5:	ff 45 d4             	incl   -0x2c(%ebp)
f011c2f8:	ff 45 d8             	incl   -0x28(%ebp)
f011c2fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c2fe:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c301:	7d 15                	jge    f011c318 <test_kheap_virt_addr+0x7a3>
f011c303:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c30a:	7f 0c                	jg     f011c318 <test_kheap_virt_addr+0x7a3>
f011c30c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c30f:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c312:	0f 82 29 ff ff ff    	jb     f011c241 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c318:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c31b:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c31e:	0f 82 c7 fe ff ff    	jb     f011c1eb <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c324:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c328:	74 04                	je     f011c32e <test_kheap_virt_addr+0x7b9>
f011c32a:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c32e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c335:	83 ec 0c             	sub    $0xc,%esp
f011c338:	68 68 f6 12 f0       	push   $0xf012f668
f011c33d:	e8 49 4c fe ff       	call   f0100f8b <cprintf>
f011c342:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c345:	e8 1e 26 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c34a:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c34d:	e8 53 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c352:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c355:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c35b:	83 ec 0c             	sub    $0xc,%esp
f011c35e:	50                   	push   %eax
f011c35f:	e8 29 d4 fe ff       	call   f010978d <kfree>
f011c364:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c367:	e8 39 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c36c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c36f:	74 17                	je     f011c388 <test_kheap_virt_addr+0x813>
f011c371:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c378:	83 ec 0c             	sub    $0xc,%esp
f011c37b:	68 90 f6 12 f0       	push   $0xf012f690
f011c380:	e8 06 4c fe ff       	call   f0100f8b <cprintf>
f011c385:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c388:	e8 db 25 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c38d:	89 c2                	mov    %eax,%edx
f011c38f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c392:	29 c2                	sub    %eax,%edx
f011c394:	89 d0                	mov    %edx,%eax
f011c396:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c39b:	77 17                	ja     f011c3b4 <test_kheap_virt_addr+0x83f>
f011c39d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3a4:	83 ec 0c             	sub    $0xc,%esp
f011c3a7:	68 00 f7 12 f0       	push   $0xf012f700
f011c3ac:	e8 da 4b fe ff       	call   f0100f8b <cprintf>
f011c3b1:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c3b4:	e8 af 25 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c3b9:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c3bc:	e8 e4 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3c1:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c3c4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c3ca:	83 ec 0c             	sub    $0xc,%esp
f011c3cd:	50                   	push   %eax
f011c3ce:	e8 ba d3 fe ff       	call   f010978d <kfree>
f011c3d3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3d6:	e8 ca 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3db:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c3de:	74 17                	je     f011c3f7 <test_kheap_virt_addr+0x882>
f011c3e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3e7:	83 ec 0c             	sub    $0xc,%esp
f011c3ea:	68 3c f7 12 f0       	push   $0xf012f73c
f011c3ef:	e8 97 4b fe ff       	call   f0100f8b <cprintf>
f011c3f4:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c3f7:	e8 6c 25 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c3fc:	89 c2                	mov    %eax,%edx
f011c3fe:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c401:	29 c2                	sub    %eax,%edx
f011c403:	89 d0                	mov    %edx,%eax
f011c405:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c40a:	77 17                	ja     f011c423 <test_kheap_virt_addr+0x8ae>
f011c40c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c413:	83 ec 0c             	sub    $0xc,%esp
f011c416:	68 ac f7 12 f0       	push   $0xf012f7ac
f011c41b:	e8 6b 4b fe ff       	call   f0100f8b <cprintf>
f011c420:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c423:	e8 40 25 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c428:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c42b:	e8 75 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c430:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c433:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c439:	83 ec 0c             	sub    $0xc,%esp
f011c43c:	50                   	push   %eax
f011c43d:	e8 4b d3 fe ff       	call   f010978d <kfree>
f011c442:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c445:	e8 5b 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c44a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c44d:	74 17                	je     f011c466 <test_kheap_virt_addr+0x8f1>
f011c44f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c456:	83 ec 0c             	sub    $0xc,%esp
f011c459:	68 e8 f7 12 f0       	push   $0xf012f7e8
f011c45e:	e8 28 4b fe ff       	call   f0100f8b <cprintf>
f011c463:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c466:	e8 fd 24 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c46b:	89 c2                	mov    %eax,%edx
f011c46d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c470:	29 c2                	sub    %eax,%edx
f011c472:	89 d0                	mov    %edx,%eax
f011c474:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c479:	77 17                	ja     f011c492 <test_kheap_virt_addr+0x91d>
f011c47b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c482:	83 ec 0c             	sub    $0xc,%esp
f011c485:	68 58 f8 12 f0       	push   $0xf012f858
f011c48a:	e8 fc 4a fe ff       	call   f0100f8b <cprintf>
f011c48f:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c492:	83 ec 0c             	sub    $0xc,%esp
f011c495:	68 94 f8 12 f0       	push   $0xf012f894
f011c49a:	e8 ec 4a fe ff       	call   f0100f8b <cprintf>
f011c49f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c4a2:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c4a9:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c4ae:	05 00 10 00 00       	add    $0x1000,%eax
f011c4b3:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c4b9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c4c0:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c4c7:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c4ca:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c4d0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c4d3:	eb 44                	jmp    f011c519 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c4d5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4d8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c4db:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c4de:	83 ec 0c             	sub    $0xc,%esp
f011c4e1:	50                   	push   %eax
f011c4e2:	e8 08 d4 fe ff       	call   f01098ef <kheap_virtual_address>
f011c4e7:	83 c4 10             	add    $0x10,%esp
f011c4ea:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c4f0:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c4f7:	74 1d                	je     f011c516 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c4f9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c4fd:	74 17                	je     f011c516 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c4ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c506:	83 ec 0c             	sub    $0xc,%esp
f011c509:	68 e4 f8 12 f0       	push   $0xf012f8e4
f011c50e:	e8 78 4a fe ff       	call   f0100f8b <cprintf>
f011c513:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c516:	ff 45 d0             	incl   -0x30(%ebp)
f011c519:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c51f:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c525:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c528:	39 c2                	cmp    %eax,%edx
f011c52a:	77 a9                	ja     f011c4d5 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c52c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c532:	05 00 04 00 00       	add    $0x400,%eax
f011c537:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c53a:	eb 64                	jmp    f011c5a0 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c53c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c53f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c542:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c545:	83 ec 0c             	sub    $0xc,%esp
f011c548:	50                   	push   %eax
f011c549:	e8 a1 d3 fe ff       	call   f01098ef <kheap_virtual_address>
f011c54e:	83 c4 10             	add    $0x10,%esp
f011c551:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c557:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c55a:	c1 e0 0c             	shl    $0xc,%eax
f011c55d:	89 c2                	mov    %eax,%edx
f011c55f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c565:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c568:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c56b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c56e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c571:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c576:	01 c8                	add    %ecx,%eax
f011c578:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c57e:	74 1d                	je     f011c59d <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c580:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c584:	74 17                	je     f011c59d <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c586:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c58d:	83 ec 0c             	sub    $0xc,%esp
f011c590:	68 08 f9 12 f0       	push   $0xf012f908
f011c595:	e8 f1 49 fe ff       	call   f0100f8b <cprintf>
f011c59a:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c59d:	ff 45 d0             	incl   -0x30(%ebp)
f011c5a0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5a6:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c5ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5af:	39 c2                	cmp    %eax,%edx
f011c5b1:	77 89                	ja     f011c53c <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c5b3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5b9:	05 02 07 00 00       	add    $0x702,%eax
f011c5be:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c5c1:	eb 44                	jmp    f011c607 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c5c3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c5c6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c5c9:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c5cc:	83 ec 0c             	sub    $0xc,%esp
f011c5cf:	50                   	push   %eax
f011c5d0:	e8 1a d3 fe ff       	call   f01098ef <kheap_virtual_address>
f011c5d5:	83 c4 10             	add    $0x10,%esp
f011c5d8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c5de:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c5e5:	74 1d                	je     f011c604 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c5e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c5eb:	74 17                	je     f011c604 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c5ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5f4:	83 ec 0c             	sub    $0xc,%esp
f011c5f7:	68 2c f9 12 f0       	push   $0xf012f92c
f011c5fc:	e8 8a 49 fe ff       	call   f0100f8b <cprintf>
f011c601:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c604:	ff 45 d0             	incl   -0x30(%ebp)
f011c607:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c60d:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c613:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c616:	39 c2                	cmp    %eax,%edx
f011c618:	77 a9                	ja     f011c5c3 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c61a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c620:	05 02 0d 00 00       	add    $0xd02,%eax
f011c625:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c628:	eb 64                	jmp    f011c68e <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c62a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c62d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c630:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c633:	83 ec 0c             	sub    $0xc,%esp
f011c636:	50                   	push   %eax
f011c637:	e8 b3 d2 fe ff       	call   f01098ef <kheap_virtual_address>
f011c63c:	83 c4 10             	add    $0x10,%esp
f011c63f:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c645:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c648:	c1 e0 0c             	shl    $0xc,%eax
f011c64b:	89 c2                	mov    %eax,%edx
f011c64d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c653:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c656:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c659:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c65c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c65f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c664:	01 c8                	add    %ecx,%eax
f011c666:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c66c:	74 1d                	je     f011c68b <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c66e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c672:	74 17                	je     f011c68b <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c674:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c67b:	83 ec 0c             	sub    $0xc,%esp
f011c67e:	68 50 f9 12 f0       	push   $0xf012f950
f011c683:	e8 03 49 fe ff       	call   f0100f8b <cprintf>
f011c688:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c68b:	ff 45 d0             	incl   -0x30(%ebp)
f011c68e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c694:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c69a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c69d:	39 c2                	cmp    %eax,%edx
f011c69f:	77 89                	ja     f011c62a <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c6a1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6a5:	74 04                	je     f011c6ab <test_kheap_virt_addr+0xb36>
f011c6a7:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c6ab:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c6b2:	83 ec 0c             	sub    $0xc,%esp
f011c6b5:	68 74 f9 12 f0       	push   $0xf012f974
f011c6ba:	e8 cc 48 fe ff       	call   f0100f8b <cprintf>
f011c6bf:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c6c2:	83 ec 0c             	sub    $0xc,%esp
f011c6c5:	6a 00                	push   $0x0
f011c6c7:	e8 0f cd fe ff       	call   f01093db <sbrk>
f011c6cc:	83 c4 10             	add    $0x10,%esp
f011c6cf:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c6d4:	77 17                	ja     f011c6ed <test_kheap_virt_addr+0xb78>
f011c6d6:	83 ec 04             	sub    $0x4,%esp
f011c6d9:	68 bb f9 12 f0       	push   $0xf012f9bb
f011c6de:	68 91 07 00 00       	push   $0x791
f011c6e3:	68 53 ce 12 f0       	push   $0xf012ce53
f011c6e8:	e8 4c 3c fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c6ed:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c6f4:	e9 d1 00 00 00       	jmp    f011c7ca <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c6f9:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011c6fe:	83 ec 04             	sub    $0x4,%esp
f011c701:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c707:	52                   	push   %edx
f011c708:	ff 75 cc             	pushl  -0x34(%ebp)
f011c70b:	50                   	push   %eax
f011c70c:	e8 de bc fe ff       	call   f01083ef <get_page_table>
f011c711:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c714:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c71a:	85 c0                	test   %eax,%eax
f011c71c:	75 1e                	jne    f011c73c <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c71e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c725:	83 ec 04             	sub    $0x4,%esp
f011c728:	68 44 f3 12 f0       	push   $0xf012f344
f011c72d:	68 97 07 00 00       	push   $0x797
f011c732:	68 53 ce 12 f0       	push   $0xf012ce53
f011c737:	e8 fd 3b fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c73c:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c742:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c745:	c1 ea 0c             	shr    $0xc,%edx
f011c748:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c74e:	c1 e2 02             	shl    $0x2,%edx
f011c751:	01 d0                	add    %edx,%eax
f011c753:	8b 00                	mov    (%eax),%eax
f011c755:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c75a:	89 c2                	mov    %eax,%edx
f011c75c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c75f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c764:	01 d0                	add    %edx,%eax
f011c766:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c76c:	83 ec 0c             	sub    $0xc,%esp
f011c76f:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c775:	e8 75 d1 fe ff       	call   f01098ef <kheap_virtual_address>
f011c77a:	83 c4 10             	add    $0x10,%esp
f011c77d:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c783:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c789:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c78c:	74 39                	je     f011c7c7 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c78e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c792:	74 33                	je     f011c7c7 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c794:	ff 75 cc             	pushl  -0x34(%ebp)
f011c797:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c79d:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c7a3:	68 d4 f9 12 f0       	push   $0xf012f9d4
f011c7a8:	e8 de 47 fe ff       	call   f0100f8b <cprintf>
f011c7ad:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c7b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7b7:	83 ec 0c             	sub    $0xc,%esp
f011c7ba:	68 00 fa 12 f0       	push   $0xf012fa00
f011c7bf:	e8 c7 47 fe ff       	call   f0100f8b <cprintf>
f011c7c4:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c7c7:	ff 45 cc             	incl   -0x34(%ebp)
f011c7ca:	83 ec 0c             	sub    $0xc,%esp
f011c7cd:	6a 00                	push   $0x0
f011c7cf:	e8 07 cc fe ff       	call   f01093db <sbrk>
f011c7d4:	83 c4 10             	add    $0x10,%esp
f011c7d7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c7da:	0f 87 19 ff ff ff    	ja     f011c6f9 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c7e0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7e4:	74 04                	je     f011c7ea <test_kheap_virt_addr+0xc75>
f011c7e6:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c7ea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c7f1:	83 ec 0c             	sub    $0xc,%esp
f011c7f4:	68 24 fa 12 f0       	push   $0xf012fa24
f011c7f9:	e8 8d 47 fe ff       	call   f0100f8b <cprintf>
f011c7fe:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c801:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c808:	eb 5a                	jmp    f011c864 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c80a:	83 ec 0c             	sub    $0xc,%esp
f011c80d:	ff 75 c8             	pushl  -0x38(%ebp)
f011c810:	e8 da d0 fe ff       	call   f01098ef <kheap_virtual_address>
f011c815:	83 c4 10             	add    $0x10,%esp
f011c818:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c81e:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c825:	74 36                	je     f011c85d <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c827:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c82b:	74 30                	je     f011c85d <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c82d:	83 ec 04             	sub    $0x4,%esp
f011c830:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c836:	ff 75 c8             	pushl  -0x38(%ebp)
f011c839:	68 63 fa 12 f0       	push   $0xf012fa63
f011c83e:	e8 48 47 fe ff       	call   f0100f8b <cprintf>
f011c843:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c846:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c84d:	83 ec 0c             	sub    $0xc,%esp
f011c850:	68 80 fa 12 f0       	push   $0xf012fa80
f011c855:	e8 31 47 fe ff       	call   f0100f8b <cprintf>
f011c85a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c85d:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c864:	b8 d0 d7 b0 00       	mov    $0xb0d7d0,%eax
f011c869:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c86c:	72 9c                	jb     f011c80a <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c86e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c872:	74 04                	je     f011c878 <test_kheap_virt_addr+0xd03>
f011c874:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c878:	83 ec 08             	sub    $0x8,%esp
f011c87b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c87e:	68 a4 fa 12 f0       	push   $0xf012faa4
f011c883:	e8 03 47 fe ff       	call   f0100f8b <cprintf>
f011c888:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c88b:	b8 01 00 00 00       	mov    $0x1,%eax
f011c890:	89 f4                	mov    %esi,%esp

}
f011c892:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c895:	5b                   	pop    %ebx
f011c896:	5e                   	pop    %esi
f011c897:	5f                   	pop    %edi
f011c898:	5d                   	pop    %ebp
f011c899:	c3                   	ret    

f011c89a <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c89a:	55                   	push   %ebp
f011c89b:	89 e5                	mov    %esp,%ebp
f011c89d:	57                   	push   %edi
f011c89e:	56                   	push   %esi
f011c89f:	53                   	push   %ebx
f011c8a0:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c8a6:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c8ac:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c8b1:	b8 00 00 00 00       	mov    $0x0,%eax
f011c8b6:	89 d7                	mov    %edx,%edi
f011c8b8:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c8ba:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c8c1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c8c8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c8cf:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011c8d4:	0f b6 c0             	movzbl %al,%eax
f011c8d7:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c8da:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c8e1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c8e4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c8e7:	39 c2                	cmp    %eax,%edx
f011c8e9:	73 02                	jae    f011c8ed <test_ksbrk+0x53>
f011c8eb:	89 c2                	mov    %eax,%edx
f011c8ed:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011c8f2:	0f b6 c0             	movzbl %al,%eax
f011c8f5:	c1 e0 04             	shl    $0x4,%eax
f011c8f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c8fb:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c902:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c905:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c908:	39 c8                	cmp    %ecx,%eax
f011c90a:	73 02                	jae    f011c90e <test_ksbrk+0x74>
f011c90c:	89 c8                	mov    %ecx,%eax
f011c90e:	01 d0                	add    %edx,%eax
f011c910:	83 c0 10             	add    $0x10,%eax
f011c913:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c918:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c91b:	83 ec 0c             	sub    $0xc,%esp
f011c91e:	68 d8 fa 12 f0       	push   $0xf012fad8
f011c923:	e8 63 46 fe ff       	call   f0100f8b <cprintf>
f011c928:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c92b:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c932:	e8 31 20 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c937:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c93a:	e8 66 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c93f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c942:	83 ec 10             	sub    $0x10,%esp
f011c945:	89 e0                	mov    %esp,%eax
f011c947:	89 c2                	mov    %eax,%edx
f011c949:	bb 10 17 6c f0       	mov    $0xf06c1710,%ebx
f011c94e:	b8 04 00 00 00       	mov    $0x4,%eax
f011c953:	89 d7                	mov    %edx,%edi
f011c955:	89 de                	mov    %ebx,%esi
f011c957:	89 c1                	mov    %eax,%ecx
f011c959:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c95b:	e8 53 3e 00 00       	call   f01207b3 <print_blocks_list>
f011c960:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c963:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c966:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c969:	29 c2                	sub    %eax,%edx
f011c96b:	89 d0                	mov    %edx,%eax
f011c96d:	83 ec 0c             	sub    $0xc,%esp
f011c970:	50                   	push   %eax
f011c971:	e8 98 cb fe ff       	call   f010950e <kmalloc>
f011c976:	83 c4 10             	add    $0x10,%esp
f011c979:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c97f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c982:	89 c2                	mov    %eax,%edx
f011c984:	c1 ea 1f             	shr    $0x1f,%edx
f011c987:	01 d0                	add    %edx,%eax
f011c989:	d1 f8                	sar    %eax
f011c98b:	89 c2                	mov    %eax,%edx
f011c98d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c990:	01 d0                	add    %edx,%eax
f011c992:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c995:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c99b:	6a 01                	push   $0x1
f011c99d:	ff 75 b8             	pushl  -0x48(%ebp)
f011c9a0:	ff 75 ac             	pushl  -0x54(%ebp)
f011c9a3:	50                   	push   %eax
f011c9a4:	e8 db 43 ff ff       	call   f0110d84 <check_block>
f011c9a9:	83 c4 10             	add    $0x10,%esp
f011c9ac:	85 c0                	test   %eax,%eax
f011c9ae:	75 17                	jne    f011c9c7 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c9b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9b7:	83 ec 0c             	sub    $0xc,%esp
f011c9ba:	68 29 fb 12 f0       	push   $0xf012fb29
f011c9bf:	e8 c7 45 fe ff       	call   f0100f8b <cprintf>
f011c9c4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c9c7:	e8 9c 1f ff ff       	call   f010e968 <sys_calculate_free_frames>
f011c9cc:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c9cf:	74 17                	je     f011c9e8 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c9d1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9d8:	83 ec 0c             	sub    $0xc,%esp
f011c9db:	68 40 fb 12 f0       	push   $0xf012fb40
f011c9e0:	e8 a6 45 fe ff       	call   f0100f8b <cprintf>
f011c9e5:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c9e8:	e8 b8 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c9ed:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c9f0:	74 17                	je     f011ca09 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c9f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9f9:	83 ec 0c             	sub    $0xc,%esp
f011c9fc:	68 60 fb 12 f0       	push   $0xf012fb60
f011ca01:	e8 85 45 fe ff       	call   f0100f8b <cprintf>
f011ca06:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011ca09:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ca0e:	0f b6 c0             	movzbl %al,%eax
f011ca11:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011ca14:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011ca1b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ca1e:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011ca21:	39 c2                	cmp    %eax,%edx
f011ca23:	73 02                	jae    f011ca27 <test_ksbrk+0x18d>
f011ca25:	89 c2                	mov    %eax,%edx
f011ca27:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ca2c:	0f b6 c0             	movzbl %al,%eax
f011ca2f:	c1 e0 04             	shl    $0x4,%eax
f011ca32:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011ca35:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011ca3c:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011ca3f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ca42:	39 c8                	cmp    %ecx,%eax
f011ca44:	73 02                	jae    f011ca48 <test_ksbrk+0x1ae>
f011ca46:	89 c8                	mov    %ecx,%eax
f011ca48:	01 d0                	add    %edx,%eax
f011ca4a:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011ca4f:	29 c2                	sub    %eax,%edx
f011ca51:	89 d0                	mov    %edx,%eax
f011ca53:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011ca56:	e8 0d 1f ff ff       	call   f010e968 <sys_calculate_free_frames>
f011ca5b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ca5e:	e8 42 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca63:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011ca66:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca69:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ca6c:	29 c2                	sub    %eax,%edx
f011ca6e:	89 d0                	mov    %edx,%eax
f011ca70:	83 ec 0c             	sub    $0xc,%esp
f011ca73:	50                   	push   %eax
f011ca74:	e8 95 ca fe ff       	call   f010950e <kmalloc>
f011ca79:	83 c4 10             	add    $0x10,%esp
f011ca7c:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011ca82:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca85:	89 c2                	mov    %eax,%edx
f011ca87:	c1 ea 1f             	shr    $0x1f,%edx
f011ca8a:	01 d0                	add    %edx,%eax
f011ca8c:	d1 f8                	sar    %eax
f011ca8e:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011ca94:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011ca97:	01 d0                	add    %edx,%eax
f011ca99:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011ca9c:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011caa2:	6a 01                	push   $0x1
f011caa4:	ff 75 b8             	pushl  -0x48(%ebp)
f011caa7:	ff 75 ac             	pushl  -0x54(%ebp)
f011caaa:	50                   	push   %eax
f011caab:	e8 d4 42 ff ff       	call   f0110d84 <check_block>
f011cab0:	83 c4 10             	add    $0x10,%esp
f011cab3:	85 c0                	test   %eax,%eax
f011cab5:	75 17                	jne    f011cace <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011cab7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cabe:	83 ec 0c             	sub    $0xc,%esp
f011cac1:	68 ce fb 12 f0       	push   $0xf012fbce
f011cac6:	e8 c0 44 fe ff       	call   f0100f8b <cprintf>
f011cacb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cace:	e8 95 1e ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cad3:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cad6:	74 17                	je     f011caef <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011cad8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cadf:	83 ec 0c             	sub    $0xc,%esp
f011cae2:	68 e8 fb 12 f0       	push   $0xf012fbe8
f011cae7:	e8 9f 44 fe ff       	call   f0100f8b <cprintf>
f011caec:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011caef:	e8 b1 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011caf4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011caf7:	74 17                	je     f011cb10 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011caf9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb00:	83 ec 0c             	sub    $0xc,%esp
f011cb03:	68 08 fc 12 f0       	push   $0xf012fc08
f011cb08:	e8 7e 44 fe ff       	call   f0100f8b <cprintf>
f011cb0d:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011cb10:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cb17:	e8 4c 1e ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cb1c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cb1f:	e8 81 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cb24:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cb27:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cb2a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cb2d:	29 c2                	sub    %eax,%edx
f011cb2f:	89 d0                	mov    %edx,%eax
f011cb31:	83 ec 0c             	sub    $0xc,%esp
f011cb34:	50                   	push   %eax
f011cb35:	e8 d4 c9 fe ff       	call   f010950e <kmalloc>
f011cb3a:	83 c4 10             	add    $0x10,%esp
f011cb3d:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cb43:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cb46:	89 c2                	mov    %eax,%edx
f011cb48:	c1 ea 1f             	shr    $0x1f,%edx
f011cb4b:	01 d0                	add    %edx,%eax
f011cb4d:	d1 f8                	sar    %eax
f011cb4f:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011cb54:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cb57:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cb5d:	6a 01                	push   $0x1
f011cb5f:	ff 75 b8             	pushl  -0x48(%ebp)
f011cb62:	ff 75 ac             	pushl  -0x54(%ebp)
f011cb65:	50                   	push   %eax
f011cb66:	e8 19 42 ff ff       	call   f0110d84 <check_block>
f011cb6b:	83 c4 10             	add    $0x10,%esp
f011cb6e:	85 c0                	test   %eax,%eax
f011cb70:	75 17                	jne    f011cb89 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cb72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb79:	83 ec 0c             	sub    $0xc,%esp
f011cb7c:	68 76 fc 12 f0       	push   $0xf012fc76
f011cb81:	e8 05 44 fe ff       	call   f0100f8b <cprintf>
f011cb86:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cb89:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cb8c:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cb8f:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cb94:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cb97:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cb9a:	6a 00                	push   $0x0
f011cb9c:	ff 75 98             	pushl  -0x68(%ebp)
f011cb9f:	ff 75 ac             	pushl  -0x54(%ebp)
f011cba2:	ff 75 ac             	pushl  -0x54(%ebp)
f011cba5:	e8 da 41 ff ff       	call   f0110d84 <check_block>
f011cbaa:	83 c4 10             	add    $0x10,%esp
f011cbad:	85 c0                	test   %eax,%eax
f011cbaf:	75 17                	jne    f011cbc8 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011cbb1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbb8:	83 ec 0c             	sub    $0xc,%esp
f011cbbb:	68 8d fc 12 f0       	push   $0xf012fc8d
f011cbc0:	e8 c6 43 fe ff       	call   f0100f8b <cprintf>
f011cbc5:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cbc8:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cbcf:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cbd2:	8b 00                	mov    (%eax),%eax
f011cbd4:	83 f8 01             	cmp    $0x1,%eax
f011cbd7:	74 17                	je     f011cbf0 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011cbd9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbe0:	83 ec 0c             	sub    $0xc,%esp
f011cbe3:	68 a4 fc 12 f0       	push   $0xf012fca4
f011cbe8:	e8 9e 43 fe ff       	call   f0100f8b <cprintf>
f011cbed:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cbf0:	83 ec 0c             	sub    $0xc,%esp
f011cbf3:	6a 00                	push   $0x0
f011cbf5:	e8 e1 c7 fe ff       	call   f01093db <sbrk>
f011cbfa:	83 c4 10             	add    $0x10,%esp
f011cbfd:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cc00:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cc07:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cc0a:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cc0d:	74 1d                	je     f011cc2c <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cc0f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc16:	83 ec 04             	sub    $0x4,%esp
f011cc19:	ff 75 90             	pushl  -0x70(%ebp)
f011cc1c:	ff 75 8c             	pushl  -0x74(%ebp)
f011cc1f:	68 d0 fc 12 f0       	push   $0xf012fcd0
f011cc24:	e8 62 43 fe ff       	call   f0100f8b <cprintf>
f011cc29:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cc2c:	e8 37 1d ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cc31:	89 c2                	mov    %eax,%edx
f011cc33:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cc36:	29 d0                	sub    %edx,%eax
f011cc38:	83 f8 01             	cmp    $0x1,%eax
f011cc3b:	74 17                	je     f011cc54 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cc3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc44:	83 ec 0c             	sub    $0xc,%esp
f011cc47:	68 04 fd 12 f0       	push   $0xf012fd04
f011cc4c:	e8 3a 43 fe ff       	call   f0100f8b <cprintf>
f011cc51:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cc54:	e8 4c 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc59:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cc5c:	74 17                	je     f011cc75 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc5e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc65:	83 ec 0c             	sub    $0xc,%esp
f011cc68:	68 24 fd 12 f0       	push   $0xf012fd24
f011cc6d:	e8 19 43 fe ff       	call   f0100f8b <cprintf>
f011cc72:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011cc75:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cc7c:	e8 e7 1c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cc81:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cc84:	e8 1c 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc89:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011cc8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc8f:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cc92:	29 c2                	sub    %eax,%edx
f011cc94:	89 d0                	mov    %edx,%eax
f011cc96:	83 ec 0c             	sub    $0xc,%esp
f011cc99:	50                   	push   %eax
f011cc9a:	e8 6f c8 fe ff       	call   f010950e <kmalloc>
f011cc9f:	83 c4 10             	add    $0x10,%esp
f011cca2:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011cca8:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011ccaf:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011ccb5:	6a 01                	push   $0x1
f011ccb7:	ff 75 b8             	pushl  -0x48(%ebp)
f011ccba:	ff 75 ac             	pushl  -0x54(%ebp)
f011ccbd:	50                   	push   %eax
f011ccbe:	e8 c1 40 ff ff       	call   f0110d84 <check_block>
f011ccc3:	83 c4 10             	add    $0x10,%esp
f011ccc6:	85 c0                	test   %eax,%eax
f011ccc8:	75 17                	jne    f011cce1 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011ccca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccd1:	83 ec 0c             	sub    $0xc,%esp
f011ccd4:	68 93 fd 12 f0       	push   $0xf012fd93
f011ccd9:	e8 ad 42 fe ff       	call   f0100f8b <cprintf>
f011ccde:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cce1:	e8 82 1c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cce6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cce9:	74 17                	je     f011cd02 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cceb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccf2:	83 ec 0c             	sub    $0xc,%esp
f011ccf5:	68 ac fd 12 f0       	push   $0xf012fdac
f011ccfa:	e8 8c 42 fe ff       	call   f0100f8b <cprintf>
f011ccff:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd02:	e8 9e 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd07:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd0a:	74 17                	je     f011cd23 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd13:	83 ec 0c             	sub    $0xc,%esp
f011cd16:	68 cc fd 12 f0       	push   $0xf012fdcc
f011cd1b:	e8 6b 42 fe ff       	call   f0100f8b <cprintf>
f011cd20:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011cd23:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd27:	74 04                	je     f011cd2d <test_ksbrk+0x493>
		eval += 25;
f011cd29:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011cd2d:	83 ec 0c             	sub    $0xc,%esp
f011cd30:	68 3c fe 12 f0       	push   $0xf012fe3c
f011cd35:	e8 51 42 fe ff       	call   f0100f8b <cprintf>
f011cd3a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011cd3d:	83 ec 0c             	sub    $0xc,%esp
f011cd40:	6a 00                	push   $0x0
f011cd42:	e8 94 c6 fe ff       	call   f01093db <sbrk>
f011cd47:	83 c4 10             	add    $0x10,%esp
f011cd4a:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011cd4d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cd54:	e8 0f 1c ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cd59:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cd5c:	e8 44 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd61:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011cd64:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd67:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd6a:	29 c2                	sub    %eax,%edx
f011cd6c:	89 d0                	mov    %edx,%eax
f011cd6e:	83 ec 0c             	sub    $0xc,%esp
f011cd71:	50                   	push   %eax
f011cd72:	e8 97 c7 fe ff       	call   f010950e <kmalloc>
f011cd77:	83 c4 10             	add    $0x10,%esp
f011cd7a:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cd80:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd83:	89 c2                	mov    %eax,%edx
f011cd85:	c1 ea 1f             	shr    $0x1f,%edx
f011cd88:	01 d0                	add    %edx,%eax
f011cd8a:	d1 f8                	sar    %eax
f011cd8c:	89 c2                	mov    %eax,%edx
f011cd8e:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cd91:	01 d0                	add    %edx,%eax
f011cd93:	83 e8 04             	sub    $0x4,%eax
f011cd96:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cd99:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cd9f:	6a 01                	push   $0x1
f011cda1:	ff 75 b8             	pushl  -0x48(%ebp)
f011cda4:	ff 75 ac             	pushl  -0x54(%ebp)
f011cda7:	50                   	push   %eax
f011cda8:	e8 d7 3f ff ff       	call   f0110d84 <check_block>
f011cdad:	83 c4 10             	add    $0x10,%esp
f011cdb0:	85 c0                	test   %eax,%eax
f011cdb2:	75 17                	jne    f011cdcb <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011cdb4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdbb:	83 ec 0c             	sub    $0xc,%esp
f011cdbe:	68 9f fe 12 f0       	push   $0xf012fe9f
f011cdc3:	e8 c3 41 fe ff       	call   f0100f8b <cprintf>
f011cdc8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cdcb:	e8 98 1b ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cdd0:	89 c2                	mov    %eax,%edx
f011cdd2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cdd5:	29 d0                	sub    %edx,%eax
f011cdd7:	83 f8 01             	cmp    $0x1,%eax
f011cdda:	74 17                	je     f011cdf3 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011cddc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cde3:	83 ec 0c             	sub    $0xc,%esp
f011cde6:	68 b8 fe 12 f0       	push   $0xf012feb8
f011cdeb:	e8 9b 41 fe ff       	call   f0100f8b <cprintf>
f011cdf0:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cdf3:	e8 ad 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cdf8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cdfb:	74 17                	je     f011ce14 <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdfd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce04:	83 ec 0c             	sub    $0xc,%esp
f011ce07:	68 d8 fe 12 f0       	push   $0xf012fed8
f011ce0c:	e8 7a 41 fe ff       	call   f0100f8b <cprintf>
f011ce11:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011ce14:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011ce1b:	e8 48 1b ff ff       	call   f010e968 <sys_calculate_free_frames>
f011ce20:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ce23:	e8 7d 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce28:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011ce2b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce2e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce31:	29 c2                	sub    %eax,%edx
f011ce33:	89 d0                	mov    %edx,%eax
f011ce35:	83 ec 0c             	sub    $0xc,%esp
f011ce38:	50                   	push   %eax
f011ce39:	e8 d0 c6 fe ff       	call   f010950e <kmalloc>
f011ce3e:	83 c4 10             	add    $0x10,%esp
f011ce41:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011ce47:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011ce4e:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011ce54:	6a 01                	push   $0x1
f011ce56:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce59:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce5c:	50                   	push   %eax
f011ce5d:	e8 22 3f ff ff       	call   f0110d84 <check_block>
f011ce62:	83 c4 10             	add    $0x10,%esp
f011ce65:	85 c0                	test   %eax,%eax
f011ce67:	75 17                	jne    f011ce80 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011ce69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce70:	83 ec 0c             	sub    $0xc,%esp
f011ce73:	68 46 ff 12 f0       	push   $0xf012ff46
f011ce78:	e8 0e 41 fe ff       	call   f0100f8b <cprintf>
f011ce7d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ce80:	e8 e3 1a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011ce85:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ce88:	74 17                	je     f011cea1 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011ce8a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce91:	83 ec 0c             	sub    $0xc,%esp
f011ce94:	68 60 ff 12 f0       	push   $0xf012ff60
f011ce99:	e8 ed 40 fe ff       	call   f0100f8b <cprintf>
f011ce9e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cea1:	e8 ff 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cea6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cea9:	74 17                	je     f011cec2 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ceab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ceb2:	83 ec 0c             	sub    $0xc,%esp
f011ceb5:	68 80 ff 12 f0       	push   $0xf012ff80
f011ceba:	e8 cc 40 fe ff       	call   f0100f8b <cprintf>
f011cebf:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011cec2:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cec9:	e8 9a 1a ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cece:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ced1:	e8 cf 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ced6:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ced9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cedc:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cedf:	29 c2                	sub    %eax,%edx
f011cee1:	89 d0                	mov    %edx,%eax
f011cee3:	83 ec 0c             	sub    $0xc,%esp
f011cee6:	50                   	push   %eax
f011cee7:	e8 22 c6 fe ff       	call   f010950e <kmalloc>
f011ceec:	83 c4 10             	add    $0x10,%esp
f011ceef:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011cef5:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cefc:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cf02:	6a 01                	push   $0x1
f011cf04:	ff 75 b8             	pushl  -0x48(%ebp)
f011cf07:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf0a:	50                   	push   %eax
f011cf0b:	e8 74 3e ff ff       	call   f0110d84 <check_block>
f011cf10:	83 c4 10             	add    $0x10,%esp
f011cf13:	85 c0                	test   %eax,%eax
f011cf15:	75 17                	jne    f011cf2e <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011cf17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf1e:	83 ec 0c             	sub    $0xc,%esp
f011cf21:	68 ee ff 12 f0       	push   $0xf012ffee
f011cf26:	e8 60 40 fe ff       	call   f0100f8b <cprintf>
f011cf2b:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cf2e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cf31:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011cf34:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cf3b:	6a 00                	push   $0x0
f011cf3d:	ff 75 98             	pushl  -0x68(%ebp)
f011cf40:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf43:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf46:	e8 39 3e ff ff       	call   f0110d84 <check_block>
f011cf4b:	83 c4 10             	add    $0x10,%esp
f011cf4e:	85 c0                	test   %eax,%eax
f011cf50:	75 17                	jne    f011cf69 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011cf52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf59:	83 ec 0c             	sub    $0xc,%esp
f011cf5c:	68 05 00 13 f0       	push   $0xf0130005
f011cf61:	e8 25 40 fe ff       	call   f0100f8b <cprintf>
f011cf66:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011cf69:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cf6c:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011cf71:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cf74:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cf77:	8b 00                	mov    (%eax),%eax
f011cf79:	83 f8 01             	cmp    $0x1,%eax
f011cf7c:	74 17                	je     f011cf95 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011cf7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf85:	83 ec 0c             	sub    $0xc,%esp
f011cf88:	68 1c 00 13 f0       	push   $0xf013001c
f011cf8d:	e8 f9 3f fe ff       	call   f0100f8b <cprintf>
f011cf92:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cf95:	83 ec 0c             	sub    $0xc,%esp
f011cf98:	6a 00                	push   $0x0
f011cf9a:	e8 3c c4 fe ff       	call   f01093db <sbrk>
f011cf9f:	83 c4 10             	add    $0x10,%esp
f011cfa2:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011cfa5:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cfa8:	05 00 20 00 00       	add    $0x2000,%eax
f011cfad:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cfb0:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cfb3:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cfb6:	74 1d                	je     f011cfd5 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cfb8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfbf:	83 ec 04             	sub    $0x4,%esp
f011cfc2:	ff 75 90             	pushl  -0x70(%ebp)
f011cfc5:	ff 75 8c             	pushl  -0x74(%ebp)
f011cfc8:	68 48 00 13 f0       	push   $0xf0130048
f011cfcd:	e8 b9 3f fe ff       	call   f0100f8b <cprintf>
f011cfd2:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cfd5:	e8 8e 19 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011cfda:	89 c2                	mov    %eax,%edx
f011cfdc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cfdf:	29 d0                	sub    %edx,%eax
f011cfe1:	83 f8 01             	cmp    $0x1,%eax
f011cfe4:	74 17                	je     f011cffd <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011cfe6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfed:	83 ec 0c             	sub    $0xc,%esp
f011cff0:	68 7c 00 13 f0       	push   $0xf013007c
f011cff5:	e8 91 3f fe ff       	call   f0100f8b <cprintf>
f011cffa:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cffd:	e8 a3 78 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d002:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d005:	74 17                	je     f011d01e <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d007:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d00e:	83 ec 0c             	sub    $0xc,%esp
f011d011:	68 9c 00 13 f0       	push   $0xf013009c
f011d016:	e8 70 3f fe ff       	call   f0100f8b <cprintf>
f011d01b:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011d01e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d022:	74 04                	je     f011d028 <test_ksbrk+0x78e>
		eval += 25;
f011d024:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011d028:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011d02f:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011d035:	bb d8 03 13 f0       	mov    $0xf01303d8,%ebx
f011d03a:	ba 05 00 00 00       	mov    $0x5,%edx
f011d03f:	89 c7                	mov    %eax,%edi
f011d041:	89 de                	mov    %ebx,%esi
f011d043:	89 d1                	mov    %edx,%ecx
f011d045:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011d047:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d04d:	bb ec 03 13 f0       	mov    $0xf01303ec,%ebx
f011d052:	ba 05 00 00 00       	mov    $0x5,%edx
f011d057:	89 c7                	mov    %eax,%edi
f011d059:	89 de                	mov    %ebx,%esi
f011d05b:	89 d1                	mov    %edx,%ecx
f011d05d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011d05f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011d065:	bb 00 04 13 f0       	mov    $0xf0130400,%ebx
f011d06a:	ba 05 00 00 00       	mov    $0x5,%edx
f011d06f:	89 c7                	mov    %eax,%edi
f011d071:	89 de                	mov    %ebx,%esi
f011d073:	89 d1                	mov    %edx,%ecx
f011d075:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d077:	83 ec 04             	sub    $0x4,%esp
f011d07a:	68 00 00 00 f8       	push   $0xf8000000
f011d07f:	68 00 10 00 00       	push   $0x1000
f011d084:	68 00 00 00 f6       	push   $0xf6000000
f011d089:	e8 36 c2 fe ff       	call   f01092c4 <initialize_kheap_dynamic_allocator>
f011d08e:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d091:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d098:	eb 1b                	jmp    f011d0b5 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d09a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011d09f:	83 ec 08             	sub    $0x8,%esp
f011d0a2:	ff 75 dc             	pushl  -0x24(%ebp)
f011d0a5:	50                   	push   %eax
f011d0a6:	e8 34 b7 fe ff       	call   f01087df <unmap_frame>
f011d0ab:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d0ae:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d0b5:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d0bc:	76 dc                	jbe    f011d09a <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d0be:	83 ec 0c             	sub    $0xc,%esp
f011d0c1:	68 0c 01 13 f0       	push   $0xf013010c
f011d0c6:	e8 c0 3e fe ff       	call   f0100f8b <cprintf>
f011d0cb:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d0ce:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d0d5:	e9 21 01 00 00       	jmp    f011d1fb <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d0da:	e8 89 18 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d0df:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d0e2:	e8 be 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d0e7:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d0ea:	83 ec 0c             	sub    $0xc,%esp
f011d0ed:	6a 00                	push   $0x0
f011d0ef:	e8 e7 c2 fe ff       	call   f01093db <sbrk>
f011d0f4:	83 c4 10             	add    $0x10,%esp
f011d0f7:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d0fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d0fd:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d104:	83 ec 0c             	sub    $0xc,%esp
f011d107:	50                   	push   %eax
f011d108:	e8 ce c2 fe ff       	call   f01093db <sbrk>
f011d10d:	83 c4 10             	add    $0x10,%esp
f011d110:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d113:	83 ec 0c             	sub    $0xc,%esp
f011d116:	6a 00                	push   $0x0
f011d118:	e8 be c2 fe ff       	call   f01093db <sbrk>
f011d11d:	83 c4 10             	add    $0x10,%esp
f011d120:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d123:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d12a:	e8 76 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d12f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d132:	74 1a                	je     f011d14e <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d134:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d13b:	83 ec 08             	sub    $0x8,%esp
f011d13e:	ff 75 d8             	pushl  -0x28(%ebp)
f011d141:	68 50 01 13 f0       	push   $0xf0130150
f011d146:	e8 40 3e fe ff       	call   f0100f8b <cprintf>
f011d14b:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d14e:	e8 15 18 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d153:	89 c2                	mov    %eax,%edx
f011d155:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d158:	29 d0                	sub    %edx,%eax
f011d15a:	89 c2                	mov    %eax,%edx
f011d15c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d15f:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d166:	39 c2                	cmp    %eax,%edx
f011d168:	74 1a                	je     f011d184 <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d16a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d171:	83 ec 08             	sub    $0x8,%esp
f011d174:	ff 75 d8             	pushl  -0x28(%ebp)
f011d177:	68 c0 01 13 f0       	push   $0xf01301c0
f011d17c:	e8 0a 3e fe ff       	call   f0100f8b <cprintf>
f011d181:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d184:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d187:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d18e:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d191:	39 c2                	cmp    %eax,%edx
f011d193:	74 25                	je     f011d1ba <test_ksbrk+0x920>
			{
				correct = 0;
f011d195:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d19c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d19f:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d1a6:	ff 75 80             	pushl  -0x80(%ebp)
f011d1a9:	50                   	push   %eax
f011d1aa:	ff 75 d8             	pushl  -0x28(%ebp)
f011d1ad:	68 e0 01 13 f0       	push   $0xf01301e0
f011d1b2:	e8 d4 3d fe ff       	call   f0100f8b <cprintf>
f011d1b7:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d1ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d1bd:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d1c4:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d1c7:	74 25                	je     f011d1ee <test_ksbrk+0x954>
			{
				correct = 0;
f011d1c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d1d0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d1d3:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d1da:	ff 75 90             	pushl  -0x70(%ebp)
f011d1dd:	50                   	push   %eax
f011d1de:	ff 75 d8             	pushl  -0x28(%ebp)
f011d1e1:	68 18 02 13 f0       	push   $0xf0130218
f011d1e6:	e8 a0 3d fe ff       	call   f0100f8b <cprintf>
f011d1eb:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d1ee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d1f2:	74 04                	je     f011d1f8 <test_ksbrk+0x95e>
				eval += 10;
f011d1f4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d1f8:	ff 45 d8             	incl   -0x28(%ebp)
f011d1fb:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d1fe:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d201:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d204:	39 c2                	cmp    %eax,%edx
f011d206:	0f 87 ce fe ff ff    	ja     f011d0da <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d20c:	83 ec 0c             	sub    $0xc,%esp
f011d20f:	68 4c 02 13 f0       	push   $0xf013024c
f011d214:	e8 72 3d fe ff       	call   f0100f8b <cprintf>
f011d219:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d21c:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d21f:	48                   	dec    %eax
f011d220:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d223:	e9 18 01 00 00       	jmp    f011d340 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d228:	e8 3b 17 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d22d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d230:	e8 70 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d235:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d238:	83 ec 0c             	sub    $0xc,%esp
f011d23b:	6a 00                	push   $0x0
f011d23d:	e8 99 c1 fe ff       	call   f01093db <sbrk>
f011d242:	83 c4 10             	add    $0x10,%esp
f011d245:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d248:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d24b:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d252:	83 ec 0c             	sub    $0xc,%esp
f011d255:	50                   	push   %eax
f011d256:	e8 80 c1 fe ff       	call   f01093db <sbrk>
f011d25b:	83 c4 10             	add    $0x10,%esp
f011d25e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d264:	83 ec 0c             	sub    $0xc,%esp
f011d267:	6a 00                	push   $0x0
f011d269:	e8 6d c1 fe ff       	call   f01093db <sbrk>
f011d26e:	83 c4 10             	add    $0x10,%esp
f011d271:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d274:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d27b:	e8 25 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d280:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d283:	74 1a                	je     f011d29f <test_ksbrk+0xa05>
			{
				correct = 0;
f011d285:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d28c:	83 ec 08             	sub    $0x8,%esp
f011d28f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d292:	68 9c 02 13 f0       	push   $0xf013029c
f011d297:	e8 ef 3c fe ff       	call   f0100f8b <cprintf>
f011d29c:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d29f:	e8 c4 16 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d2a4:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d2a7:	74 1a                	je     f011d2c3 <test_ksbrk+0xa29>
			{
				correct = 0;
f011d2a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d2b0:	83 ec 08             	sub    $0x8,%esp
f011d2b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d2b6:	68 0c 03 13 f0       	push   $0xf013030c
f011d2bb:	e8 cb 3c fe ff       	call   f0100f8b <cprintf>
f011d2c0:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d2c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d2c6:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d2cd:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d2d3:	39 c2                	cmp    %eax,%edx
f011d2d5:	74 28                	je     f011d2ff <test_ksbrk+0xa65>
			{
				correct = 0;
f011d2d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d2de:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d2e1:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d2e8:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d2ee:	50                   	push   %eax
f011d2ef:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d2f2:	68 2c 03 13 f0       	push   $0xf013032c
f011d2f7:	e8 8f 3c fe ff       	call   f0100f8b <cprintf>
f011d2fc:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d2ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d302:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d309:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d30c:	74 25                	je     f011d333 <test_ksbrk+0xa99>
			{
				correct = 0;
f011d30e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d315:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d318:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d31f:	ff 75 90             	pushl  -0x70(%ebp)
f011d322:	50                   	push   %eax
f011d323:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d326:	68 64 03 13 f0       	push   $0xf0130364
f011d32b:	e8 5b 3c fe ff       	call   f0100f8b <cprintf>
f011d330:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d333:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d337:	74 04                	je     f011d33d <test_ksbrk+0xaa3>
				eval += 10;
f011d339:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d33d:	ff 45 d4             	incl   -0x2c(%ebp)
f011d340:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d343:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d346:	0f 82 dc fe ff ff    	jb     f011d228 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d34c:	83 ec 08             	sub    $0x8,%esp
f011d34f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d352:	68 98 03 13 f0       	push   $0xf0130398
f011d357:	e8 2f 3c fe ff       	call   f0100f8b <cprintf>
f011d35c:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d35f:	83 ec 0c             	sub    $0xc,%esp
f011d362:	68 c2 03 13 f0       	push   $0xf01303c2
f011d367:	e8 1f 3c fe ff       	call   f0100f8b <cprintf>
f011d36c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d36f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d374:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d377:	5b                   	pop    %ebx
f011d378:	5e                   	pop    %esi
f011d379:	5f                   	pop    %edi
f011d37a:	5d                   	pop    %ebp
f011d37b:	c3                   	ret    

f011d37c <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d37c:	55                   	push   %ebp
f011d37d:	89 e5                	mov    %esp,%ebp
f011d37f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d382:	83 ec 04             	sub    $0x4,%esp
f011d385:	68 14 04 13 f0       	push   $0xf0130414
f011d38a:	68 c2 08 00 00       	push   $0x8c2
f011d38f:	68 53 ce 12 f0       	push   $0xf012ce53
f011d394:	e8 a0 2f fe ff       	call   f0100339 <_panic>

f011d399 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d399:	55                   	push   %ebp
f011d39a:	89 e5                	mov    %esp,%ebp
f011d39c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d39f:	83 ec 04             	sub    $0x4,%esp
f011d3a2:	68 14 04 13 f0       	push   $0xf0130414
f011d3a7:	68 c7 08 00 00       	push   $0x8c7
f011d3ac:	68 53 ce 12 f0       	push   $0xf012ce53
f011d3b1:	e8 83 2f fe ff       	call   f0100339 <_panic>

f011d3b6 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d3b6:	55                   	push   %ebp
f011d3b7:	89 e5                	mov    %esp,%ebp
f011d3b9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d3bc:	83 ec 04             	sub    $0x4,%esp
f011d3bf:	68 14 04 13 f0       	push   $0xf0130414
f011d3c4:	68 cc 08 00 00       	push   $0x8cc
f011d3c9:	68 53 ce 12 f0       	push   $0xf012ce53
f011d3ce:	e8 66 2f fe ff       	call   f0100339 <_panic>

f011d3d3 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d3d3:	55                   	push   %ebp
f011d3d4:	89 e5                	mov    %esp,%ebp
f011d3d6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d3d9:	83 ec 04             	sub    $0x4,%esp
f011d3dc:	68 14 04 13 f0       	push   $0xf0130414
f011d3e1:	68 d1 08 00 00       	push   $0x8d1
f011d3e6:	68 53 ce 12 f0       	push   $0xf012ce53
f011d3eb:	e8 49 2f fe ff       	call   f0100339 <_panic>

f011d3f0 <test_kfree>:
}

int test_kfree()
{
f011d3f0:	55                   	push   %ebp
f011d3f1:	89 e5                	mov    %esp,%ebp
f011d3f3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d3f6:	83 ec 04             	sub    $0x4,%esp
f011d3f9:	68 14 04 13 f0       	push   $0xf0130414
f011d3fe:	68 d6 08 00 00       	push   $0x8d6
f011d403:	68 53 ce 12 f0       	push   $0xf012ce53
f011d408:	e8 2c 2f fe ff       	call   f0100339 <_panic>

f011d40d <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d40d:	55                   	push   %ebp
f011d40e:	89 e5                	mov    %esp,%ebp
f011d410:	57                   	push   %edi
f011d411:	56                   	push   %esi
f011d412:	53                   	push   %ebx
f011d413:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d419:	a0 dc fd 17 f0       	mov    0xf017fddc,%al
f011d41e:	84 c0                	test   %al,%al
f011d420:	74 56                	je     f011d478 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d422:	c6 05 dc fd 17 f0 00 	movb   $0x0,0xf017fddc
		initFreeFrames = sys_calculate_free_frames() ;
f011d429:	e8 3a 15 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d42e:	a3 e8 d4 b0 f0       	mov    %eax,0xf0b0d4e8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d433:	e8 6d 74 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d438:	a3 e4 d4 b0 f0       	mov    %eax,0xf0b0d4e4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d43d:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d443:	bb 79 05 13 f0       	mov    $0xf0130579,%ebx
f011d448:	ba 11 00 00 00       	mov    $0x11,%edx
f011d44d:	89 c7                	mov    %eax,%edi
f011d44f:	89 de                	mov    %ebx,%esi
f011d451:	89 d1                	mov    %edx,%ecx
f011d453:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d455:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d45b:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d460:	b0 00                	mov    $0x0,%al
f011d462:	89 d7                	mov    %edx,%edi
f011d464:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d466:	83 ec 0c             	sub    $0xc,%esp
f011d469:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d46f:	50                   	push   %eax
f011d470:	e8 86 4a fe ff       	call   f0101efb <execute_command>
f011d475:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d478:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d47f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d486:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f011d48b:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d48e:	eb 2b                	jmp    f011d4bb <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d490:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d493:	83 c0 20             	add    $0x20,%eax
f011d496:	83 ec 08             	sub    $0x8,%esp
f011d499:	68 24 04 13 f0       	push   $0xf0130424
f011d49e:	50                   	push   %eax
f011d49f:	e8 ea 28 00 00       	call   f011fd8e <strcmp>
f011d4a4:	83 c4 10             	add    $0x10,%esp
f011d4a7:	85 c0                	test   %eax,%eax
f011d4a9:	75 08                	jne    f011d4b3 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d4ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d4ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d4b1:	eb 2f                	jmp    f011d4e2 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d4b3:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011d4b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d4bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d4bf:	74 08                	je     f011d4c9 <test_three_creation_functions+0xbc>
f011d4c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d4c4:	8b 40 08             	mov    0x8(%eax),%eax
f011d4c7:	eb 05                	jmp    f011d4ce <test_three_creation_functions+0xc1>
f011d4c9:	b8 00 00 00 00       	mov    $0x0,%eax
f011d4ce:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f011d4d3:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011d4d8:	85 c0                	test   %eax,%eax
f011d4da:	75 b4                	jne    f011d490 <test_three_creation_functions+0x83>
f011d4dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d4e0:	75 ae                	jne    f011d490 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d4e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d4e5:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d4eb:	85 c0                	test   %eax,%eax
f011d4ed:	74 17                	je     f011d506 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d4ef:	83 ec 04             	sub    $0x4,%esp
f011d4f2:	68 2c 04 13 f0       	push   $0xf013042c
f011d4f7:	68 f7 08 00 00       	push   $0x8f7
f011d4fc:	68 53 ce 12 f0       	push   $0xf012ce53
f011d501:	e8 33 2e fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d506:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d509:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d50f:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d512:	e8 51 14 ff ff       	call   f010e968 <sys_calculate_free_frames>
f011d517:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d51a:	e8 86 73 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d51f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d522:	a1 e4 d4 b0 f0       	mov    0xf0b0d4e4,%eax
f011d527:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d52a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d52d:	74 17                	je     f011d546 <test_three_creation_functions+0x139>
f011d52f:	83 ec 04             	sub    $0x4,%esp
f011d532:	68 6c ce 12 f0       	push   $0xf012ce6c
f011d537:	68 01 09 00 00       	push   $0x901
f011d53c:	68 53 ce 12 f0       	push   $0xf012ce53
f011d541:	e8 f3 2d fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d546:	a1 e8 d4 b0 f0       	mov    0xf0b0d4e8,%eax
f011d54b:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d54e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d551:	83 c2 15             	add    $0x15,%edx
f011d554:	39 d0                	cmp    %edx,%eax
f011d556:	74 17                	je     f011d56f <test_three_creation_functions+0x162>
f011d558:	83 ec 04             	sub    $0x4,%esp
f011d55b:	68 7c 04 13 f0       	push   $0xf013047c
f011d560:	68 03 09 00 00       	push   $0x903
f011d565:	68 53 ce 12 f0       	push   $0xf012ce53
f011d56a:	e8 ca 2d fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d56f:	83 ec 0c             	sub    $0xc,%esp
f011d572:	68 00 10 00 00       	push   $0x1000
f011d577:	e8 92 bf fe ff       	call   f010950e <kmalloc>
f011d57c:	83 c4 10             	add    $0x10,%esp
f011d57f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d582:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d585:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d58a:	74 17                	je     f011d5a3 <test_three_creation_functions+0x196>
f011d58c:	83 ec 04             	sub    $0x4,%esp
f011d58f:	68 bc 04 13 f0       	push   $0xf01304bc
f011d594:	68 07 09 00 00       	push   $0x907
f011d599:	68 53 ce 12 f0       	push   $0xf012ce53
f011d59e:	e8 96 2d fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d5a3:	83 ec 0c             	sub    $0xc,%esp
f011d5a6:	68 2c 05 13 f0       	push   $0xf013052c
f011d5ab:	e8 db 39 fe ff       	call   f0100f8b <cprintf>
f011d5b0:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d5b3:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d5b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d5bb:	5b                   	pop    %ebx
f011d5bc:	5e                   	pop    %esi
f011d5bd:	5f                   	pop    %edi
f011d5be:	5d                   	pop    %ebp
f011d5bf:	c3                   	ret    

f011d5c0 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d5c0:	55                   	push   %ebp
f011d5c1:	89 e5                	mov    %esp,%ebp
f011d5c3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5c6:	83 ec 04             	sub    $0x4,%esp
f011d5c9:	68 14 04 13 f0       	push   $0xf0130414
f011d5ce:	68 15 09 00 00       	push   $0x915
f011d5d3:	68 53 ce 12 f0       	push   $0xf012ce53
f011d5d8:	e8 5c 2d fe ff       	call   f0100339 <_panic>

f011d5dd <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d5dd:	55                   	push   %ebp
f011d5de:	89 e5                	mov    %esp,%ebp
f011d5e0:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5e3:	83 ec 04             	sub    $0x4,%esp
f011d5e6:	68 14 04 13 f0       	push   $0xf0130414
f011d5eb:	68 1d 09 00 00       	push   $0x91d
f011d5f0:	68 53 ce 12 f0       	push   $0xf012ce53
f011d5f5:	e8 3f 2d fe ff       	call   f0100339 <_panic>

f011d5fa <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d5fa:	55                   	push   %ebp
f011d5fb:	89 e5                	mov    %esp,%ebp
f011d5fd:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d600:	83 ec 04             	sub    $0x4,%esp
f011d603:	68 14 04 13 f0       	push   $0xf0130414
f011d608:	68 24 09 00 00       	push   $0x924
f011d60d:	68 53 ce 12 f0       	push   $0xf012ce53
f011d612:	e8 22 2d fe ff       	call   f0100339 <_panic>

f011d617 <test_kfreelast>:

}


int test_kfreelast()
{
f011d617:	55                   	push   %ebp
f011d618:	89 e5                	mov    %esp,%ebp
f011d61a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d61d:	83 ec 04             	sub    $0x4,%esp
f011d620:	68 14 04 13 f0       	push   $0xf0130414
f011d625:	68 2b 09 00 00       	push   $0x92b
f011d62a:	68 53 ce 12 f0       	push   $0xf012ce53
f011d62f:	e8 05 2d fe ff       	call   f0100339 <_panic>

f011d634 <test_krealloc>:

}

int test_krealloc() {
f011d634:	55                   	push   %ebp
f011d635:	89 e5                	mov    %esp,%ebp
f011d637:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d63a:	83 ec 04             	sub    $0x4,%esp
f011d63d:	68 14 04 13 f0       	push   $0xf0130414
f011d642:	68 30 09 00 00       	push   $0x930
f011d647:	68 53 ce 12 f0       	push   $0xf012ce53
f011d64c:	e8 e8 2c fe ff       	call   f0100339 <_panic>

f011d651 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d651:	55                   	push   %ebp
f011d652:	89 e5                	mov    %esp,%ebp
f011d654:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d657:	83 ec 04             	sub    $0x4,%esp
f011d65a:	68 14 04 13 f0       	push   $0xf0130414
f011d65f:	68 35 09 00 00       	push   $0x935
f011d664:	68 53 ce 12 f0       	push   $0xf012ce53
f011d669:	e8 cb 2c fe ff       	call   f0100339 <_panic>

f011d66e <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d66e:	55                   	push   %ebp
f011d66f:	89 e5                	mov    %esp,%ebp
f011d671:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d674:	83 ec 04             	sub    $0x4,%esp
f011d677:	68 14 04 13 f0       	push   $0xf0130414
f011d67c:	68 3b 09 00 00       	push   $0x93b
f011d681:	68 53 ce 12 f0       	push   $0xf012ce53
f011d686:	e8 ae 2c fe ff       	call   f0100339 <_panic>

f011d68b <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d68b:	55                   	push   %ebp
f011d68c:	89 e5                	mov    %esp,%ebp
f011d68e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d691:	83 ec 04             	sub    $0x4,%esp
f011d694:	68 14 04 13 f0       	push   $0xf0130414
f011d699:	68 40 09 00 00       	push   $0x940
f011d69e:	68 53 ce 12 f0       	push   $0xf012ce53
f011d6a3:	e8 91 2c fe ff       	call   f0100339 <_panic>

f011d6a8 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d6a8:	55                   	push   %ebp
f011d6a9:	89 e5                	mov    %esp,%ebp
f011d6ab:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6ae:	83 ec 04             	sub    $0x4,%esp
f011d6b1:	68 14 04 13 f0       	push   $0xf0130414
f011d6b6:	68 46 09 00 00       	push   $0x946
f011d6bb:	68 53 ce 12 f0       	push   $0xf012ce53
f011d6c0:	e8 74 2c fe ff       	call   f0100339 <_panic>

f011d6c5 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d6c5:	55                   	push   %ebp
f011d6c6:	89 e5                	mov    %esp,%ebp
f011d6c8:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d6cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d6d2:	e9 84 00 00 00       	jmp    f011d75b <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d6d7:	83 ec 08             	sub    $0x8,%esp
f011d6da:	ff 75 f4             	pushl  -0xc(%ebp)
f011d6dd:	68 e0 05 13 f0       	push   $0xf01305e0
f011d6e2:	e8 a4 38 fe ff       	call   f0100f8b <cprintf>
f011d6e7:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d6ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d6f1:	eb 4c                	jmp    f011d73f <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d6f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d6f6:	89 d0                	mov    %edx,%eax
f011d6f8:	c1 e0 02             	shl    $0x2,%eax
f011d6fb:	01 d0                	add    %edx,%eax
f011d6fd:	c1 e0 03             	shl    $0x3,%eax
f011d700:	89 c2                	mov    %eax,%edx
f011d702:	8b 45 08             	mov    0x8(%ebp),%eax
f011d705:	01 c2                	add    %eax,%edx
f011d707:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d70a:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d70d:	85 c0                	test   %eax,%eax
f011d70f:	74 36                	je     f011d747 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d711:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d714:	89 d0                	mov    %edx,%eax
f011d716:	c1 e0 02             	shl    $0x2,%eax
f011d719:	01 d0                	add    %edx,%eax
f011d71b:	c1 e0 03             	shl    $0x3,%eax
f011d71e:	89 c2                	mov    %eax,%edx
f011d720:	8b 45 08             	mov    0x8(%ebp),%eax
f011d723:	01 c2                	add    %eax,%edx
f011d725:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d728:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d72b:	83 ec 08             	sub    $0x8,%esp
f011d72e:	50                   	push   %eax
f011d72f:	68 e8 05 13 f0       	push   $0xf01305e8
f011d734:	e8 52 38 fe ff       	call   f0100f8b <cprintf>
f011d739:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d73c:	ff 45 f0             	incl   -0x10(%ebp)
f011d73f:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d743:	7e ae                	jle    f011d6f3 <print_order+0x2e>
f011d745:	eb 01                	jmp    f011d748 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d747:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d748:	83 ec 0c             	sub    $0xc,%esp
f011d74b:	68 ed 05 13 f0       	push   $0xf01305ed
f011d750:	e8 36 38 fe ff       	call   f0100f8b <cprintf>
f011d755:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d758:	ff 45 f4             	incl   -0xc(%ebp)
f011d75b:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d75f:	0f 8e 72 ff ff ff    	jle    f011d6d7 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d765:	90                   	nop
f011d766:	c9                   	leave  
f011d767:	c3                   	ret    

f011d768 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d768:	55                   	push   %ebp
f011d769:	89 e5                	mov    %esp,%ebp
f011d76b:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d76e:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d775:	83 ec 0c             	sub    $0xc,%esp
f011d778:	68 e0 15 6c f0       	push   $0xf06c15e0
f011d77d:	e8 52 25 ff ff       	call   f010fcd4 <acquire_spinlock>
f011d782:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d785:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d78c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d793:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d796:	8b 45 10             	mov    0x10(%ebp),%eax
f011d799:	01 d0                	add    %edx,%eax
f011d79b:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d79e:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011d7a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d7a6:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011d7ab:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d7ae:	ff 75 e8             	pushl  -0x18(%ebp)
f011d7b1:	ff 75 0c             	pushl  0xc(%ebp)
f011d7b4:	ff 75 08             	pushl  0x8(%ebp)
f011d7b7:	68 f0 05 13 f0       	push   $0xf01305f0
f011d7bc:	e8 ca 37 fe ff       	call   f0100f8b <cprintf>
f011d7c1:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d7c4:	eb 34                	jmp    f011d7fa <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d7c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d7c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d7cc:	7d 05                	jge    f011d7d3 <find_in_range+0x6b>
			{
				i++;
f011d7ce:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d7d1:	eb 1e                	jmp    f011d7f1 <find_in_range+0x89>
			}
			if (i >= end)
f011d7d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d7d6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d7d9:	7d 29                	jge    f011d804 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d7db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d7de:	8b 40 10             	mov    0x10(%eax),%eax
f011d7e1:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d7e4:	75 08                	jne    f011d7ee <find_in_range+0x86>
			{
				ret = i;
f011d7e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d7e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d7ec:	eb 17                	jmp    f011d805 <find_in_range+0x9d>
			}
			i++;
f011d7ee:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d7f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d7f4:	8b 40 0c             	mov    0xc(%eax),%eax
f011d7f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d7fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d7fd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d800:	7c c4                	jl     f011d7c6 <find_in_range+0x5e>
f011d802:	eb 01                	jmp    f011d805 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d804:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d805:	83 ec 0c             	sub    $0xc,%esp
f011d808:	68 e0 15 6c f0       	push   $0xf06c15e0
f011d80d:	e8 49 25 ff ff       	call   f010fd5b <release_spinlock>
f011d812:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d815:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d818:	c9                   	leave  
f011d819:	c3                   	ret    

f011d81a <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d81a:	55                   	push   %ebp
f011d81b:	89 e5                	mov    %esp,%ebp
f011d81d:	57                   	push   %edi
f011d81e:	56                   	push   %esi
f011d81f:	53                   	push   %ebx
f011d820:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d823:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011d828:	84 c0                	test   %al,%al
f011d82a:	0f 84 9b 01 00 00    	je     f011d9cb <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d830:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d837:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d83a:	bb 68 07 13 f0       	mov    $0xf0130768,%ebx
f011d83f:	ba 05 00 00 00       	mov    $0x5,%edx
f011d844:	89 c7                	mov    %eax,%edi
f011d846:	89 de                	mov    %ebx,%esi
f011d848:	89 d1                	mov    %edx,%ecx
f011d84a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d84c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d853:	e9 44 01 00 00       	jmp    f011d99c <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d858:	6a 00                	push   $0x0
f011d85a:	6a 00                	push   $0x0
f011d85c:	68 f4 01 00 00       	push   $0x1f4
f011d861:	68 21 06 13 f0       	push   $0xf0130621
f011d866:	e8 5d d7 fe ff       	call   f010afc8 <env_create>
f011d86b:	83 c4 10             	add    $0x10,%esp
f011d86e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d871:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d874:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d879:	99                   	cltd   
f011d87a:	f7 f9                	idiv   %ecx
f011d87c:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d87f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d882:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d886:	83 ec 08             	sub    $0x8,%esp
f011d889:	50                   	push   %eax
f011d88a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d88d:	e8 f4 8d fe ff       	call   f0106686 <env_set_nice>
f011d892:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d895:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d899:	75 14                	jne    f011d8af <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d89b:	83 ec 04             	sub    $0x4,%esp
f011d89e:	68 29 06 13 f0       	push   $0xf0130629
f011d8a3:	6a 53                	push   $0x53
f011d8a5:	68 42 06 13 f0       	push   $0xf0130642
f011d8aa:	e8 8a 2a fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d8af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d8b2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d8b8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d8bd:	74 14                	je     f011d8d3 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d8bf:	83 ec 04             	sub    $0x4,%esp
f011d8c2:	68 60 06 13 f0       	push   $0xf0130660
f011d8c7:	6a 55                	push   $0x55
f011d8c9:	68 42 06 13 f0       	push   $0xf0130642
f011d8ce:	e8 66 2a fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d8d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d8d6:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d8da:	83 c0 0a             	add    $0xa,%eax
f011d8dd:	83 f8 14             	cmp    $0x14,%eax
f011d8e0:	0f 87 a5 00 00 00    	ja     f011d98b <test_bsd_nice_0+0x171>
f011d8e6:	8b 04 85 7c 07 13 f0 	mov    -0xfecf884(,%eax,4),%eax
f011d8ed:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d8ef:	a1 7c 13 6c f0       	mov    0xf06c137c,%eax
f011d8f4:	8d 50 01             	lea    0x1(%eax),%edx
f011d8f7:	89 15 7c 13 6c f0    	mov    %edx,0xf06c137c
f011d8fd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d900:	8b 52 10             	mov    0x10(%edx),%edx
f011d903:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d90a:	eb 7f                	jmp    f011d98b <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d90c:	a1 80 13 6c f0       	mov    0xf06c1380,%eax
f011d911:	8d 50 01             	lea    0x1(%eax),%edx
f011d914:	89 15 80 13 6c f0    	mov    %edx,0xf06c1380
f011d91a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d91d:	8b 52 10             	mov    0x10(%edx),%edx
f011d920:	83 c0 0a             	add    $0xa,%eax
f011d923:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d92a:	eb 5f                	jmp    f011d98b <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d92c:	a1 84 13 6c f0       	mov    0xf06c1384,%eax
f011d931:	8d 50 01             	lea    0x1(%eax),%edx
f011d934:	89 15 84 13 6c f0    	mov    %edx,0xf06c1384
f011d93a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d93d:	8b 52 10             	mov    0x10(%edx),%edx
f011d940:	83 c0 14             	add    $0x14,%eax
f011d943:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d94a:	eb 3f                	jmp    f011d98b <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d94c:	a1 88 13 6c f0       	mov    0xf06c1388,%eax
f011d951:	8d 50 01             	lea    0x1(%eax),%edx
f011d954:	89 15 88 13 6c f0    	mov    %edx,0xf06c1388
f011d95a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d95d:	8b 52 10             	mov    0x10(%edx),%edx
f011d960:	83 c0 1e             	add    $0x1e,%eax
f011d963:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d96a:	eb 1f                	jmp    f011d98b <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d96c:	a1 8c 13 6c f0       	mov    0xf06c138c,%eax
f011d971:	8d 50 01             	lea    0x1(%eax),%edx
f011d974:	89 15 8c 13 6c f0    	mov    %edx,0xf06c138c
f011d97a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d97d:	8b 52 10             	mov    0x10(%edx),%edx
f011d980:	83 c0 28             	add    $0x28,%eax
f011d983:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d98a:	90                   	nop
			}
			sched_new_env(env);
f011d98b:	83 ec 0c             	sub    $0xc,%esp
f011d98e:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d991:	e8 86 7d fe ff       	call   f010571c <sched_new_env>
f011d996:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d999:	ff 45 e4             	incl   -0x1c(%ebp)
f011d99c:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d9a0:	0f 8e b2 fe ff ff    	jle    f011d858 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d9a6:	83 ec 0c             	sub    $0xc,%esp
f011d9a9:	68 90 06 13 f0       	push   $0xf0130690
f011d9ae:	e8 d8 35 fe ff       	call   f0100f8b <cprintf>
f011d9b3:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d9b6:	83 ec 0c             	sub    $0xc,%esp
f011d9b9:	68 df 06 13 f0       	push   $0xf01306df
f011d9be:	e8 38 45 fe ff       	call   f0101efb <execute_command>
f011d9c3:	83 c4 10             	add    $0x10,%esp
f011d9c6:	e9 c0 00 00 00       	jmp    f011da8b <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d9cb:	83 ec 0c             	sub    $0xc,%esp
f011d9ce:	68 e6 06 13 f0       	push   $0xf01306e6
f011d9d3:	e8 b3 35 fe ff       	call   f0100f8b <cprintf>
f011d9d8:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d9db:	e8 74 84 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d9e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d9e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d9ee:	e9 87 00 00 00       	jmp    f011da7a <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d9f3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d9fa:	eb 52                	jmp    f011da4e <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d9fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d9ff:	8b 14 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%edx
f011da06:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011da09:	89 c8                	mov    %ecx,%eax
f011da0b:	c1 e0 02             	shl    $0x2,%eax
f011da0e:	01 c8                	add    %ecx,%eax
f011da10:	01 c0                	add    %eax,%eax
f011da12:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011da15:	01 c8                	add    %ecx,%eax
f011da17:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011da1e:	83 ec 04             	sub    $0x4,%esp
f011da21:	52                   	push   %edx
f011da22:	ff 75 e0             	pushl  -0x20(%ebp)
f011da25:	50                   	push   %eax
f011da26:	e8 3d fd ff ff       	call   f011d768 <find_in_range>
f011da2b:	83 c4 10             	add    $0x10,%esp
f011da2e:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011da31:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011da35:	75 14                	jne    f011da4b <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011da37:	83 ec 04             	sub    $0x4,%esp
f011da3a:	68 f8 06 13 f0       	push   $0xf01306f8
f011da3f:	6a 7b                	push   $0x7b
f011da41:	68 42 06 13 f0       	push   $0xf0130642
f011da46:	e8 ee 28 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011da4b:	ff 45 d8             	incl   -0x28(%ebp)
f011da4e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011da51:	89 d0                	mov    %edx,%eax
f011da53:	c1 e0 02             	shl    $0x2,%eax
f011da56:	01 d0                	add    %edx,%eax
f011da58:	01 c0                	add    %eax,%eax
f011da5a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011da5d:	01 d0                	add    %edx,%eax
f011da5f:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011da66:	85 c0                	test   %eax,%eax
f011da68:	75 92                	jne    f011d9fc <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011da6a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da6d:	8b 04 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%eax
f011da74:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011da77:	ff 45 dc             	incl   -0x24(%ebp)
f011da7a:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011da7e:	0f 8e 6f ff ff ff    	jle    f011d9f3 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011da84:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011da8b:	83 ec 0c             	sub    $0xc,%esp
f011da8e:	68 2c 07 13 f0       	push   $0xf013072c
f011da93:	e8 f3 34 fe ff       	call   f0100f8b <cprintf>
f011da98:	83 c4 10             	add    $0x10,%esp
}
f011da9b:	90                   	nop
f011da9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011da9f:	5b                   	pop    %ebx
f011daa0:	5e                   	pop    %esi
f011daa1:	5f                   	pop    %edi
f011daa2:	5d                   	pop    %ebp
f011daa3:	c3                   	ret    

f011daa4 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011daa4:	55                   	push   %ebp
f011daa5:	89 e5                	mov    %esp,%ebp
f011daa7:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011daaa:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011daaf:	84 c0                	test   %al,%al
f011dab1:	0f 84 50 01 00 00    	je     f011dc07 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011dab7:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011dabe:	6a 00                	push   $0x0
f011dac0:	6a 00                	push   $0x0
f011dac2:	68 f4 01 00 00       	push   $0x1f4
f011dac7:	68 21 06 13 f0       	push   $0xf0130621
f011dacc:	e8 f7 d4 fe ff       	call   f010afc8 <env_create>
f011dad1:	83 c4 10             	add    $0x10,%esp
f011dad4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011dad7:	6a 00                	push   $0x0
f011dad9:	6a 00                	push   $0x0
f011dadb:	68 f4 01 00 00       	push   $0x1f4
f011dae0:	68 d0 07 13 f0       	push   $0xf01307d0
f011dae5:	e8 de d4 fe ff       	call   f010afc8 <env_create>
f011daea:	83 c4 10             	add    $0x10,%esp
f011daed:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011daf0:	6a 00                	push   $0x0
f011daf2:	6a 00                	push   $0x0
f011daf4:	68 f4 01 00 00       	push   $0x1f4
f011daf9:	68 dd 07 13 f0       	push   $0xf01307dd
f011dafe:	e8 c5 d4 fe ff       	call   f010afc8 <env_create>
f011db03:	83 c4 10             	add    $0x10,%esp
f011db06:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011db09:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011db0d:	74 0c                	je     f011db1b <test_bsd_nice_1+0x77>
f011db0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011db13:	74 06                	je     f011db1b <test_bsd_nice_1+0x77>
f011db15:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011db19:	75 17                	jne    f011db32 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011db1b:	83 ec 04             	sub    $0x4,%esp
f011db1e:	68 29 06 13 f0       	push   $0xf0130629
f011db23:	68 8e 00 00 00       	push   $0x8e
f011db28:	68 42 06 13 f0       	push   $0xf0130642
f011db2d:	e8 07 28 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011db32:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db35:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db3b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011db40:	75 20                	jne    f011db62 <test_bsd_nice_1+0xbe>
f011db42:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db45:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db4b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011db50:	75 10                	jne    f011db62 <test_bsd_nice_1+0xbe>
f011db52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011db55:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db5b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011db60:	74 35                	je     f011db97 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011db62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011db65:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011db6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db6e:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011db74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db77:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db7d:	83 ec 08             	sub    $0x8,%esp
f011db80:	51                   	push   %ecx
f011db81:	52                   	push   %edx
f011db82:	50                   	push   %eax
f011db83:	68 ec 07 13 f0       	push   $0xf01307ec
f011db88:	68 90 00 00 00       	push   $0x90
f011db8d:	68 42 06 13 f0       	push   $0xf0130642
f011db92:	e8 a2 27 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011db97:	83 ec 0c             	sub    $0xc,%esp
f011db9a:	ff 75 ec             	pushl  -0x14(%ebp)
f011db9d:	e8 7a 7b fe ff       	call   f010571c <sched_new_env>
f011dba2:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011dba5:	83 ec 0c             	sub    $0xc,%esp
f011dba8:	ff 75 e8             	pushl  -0x18(%ebp)
f011dbab:	e8 6c 7b fe ff       	call   f010571c <sched_new_env>
f011dbb0:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011dbb3:	83 ec 0c             	sub    $0xc,%esp
f011dbb6:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dbb9:	e8 5e 7b fe ff       	call   f010571c <sched_new_env>
f011dbbe:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011dbc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dbc4:	8b 40 10             	mov    0x10(%eax),%eax
f011dbc7:	a3 00 d5 b0 f0       	mov    %eax,0xf0b0d500
		prog_orders[1][0] = fibEnv->env_id;
f011dbcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dbcf:	8b 40 10             	mov    0x10(%eax),%eax
f011dbd2:	a3 28 d5 b0 f0       	mov    %eax,0xf0b0d528
		prog_orders[2][0] = fibposnEnv->env_id;
f011dbd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dbda:	8b 40 10             	mov    0x10(%eax),%eax
f011dbdd:	a3 50 d5 b0 f0       	mov    %eax,0xf0b0d550
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dbe2:	83 ec 0c             	sub    $0xc,%esp
f011dbe5:	68 90 06 13 f0       	push   $0xf0130690
f011dbea:	e8 9c 33 fe ff       	call   f0100f8b <cprintf>
f011dbef:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011dbf2:	83 ec 0c             	sub    $0xc,%esp
f011dbf5:	68 df 06 13 f0       	push   $0xf01306df
f011dbfa:	e8 fc 42 fe ff       	call   f0101efb <execute_command>
f011dbff:	83 c4 10             	add    $0x10,%esp
f011dc02:	e9 9e 00 00 00       	jmp    f011dca5 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011dc07:	83 ec 0c             	sub    $0xc,%esp
f011dc0a:	68 e6 06 13 f0       	push   $0xf01306e6
f011dc0f:	e8 77 33 fe ff       	call   f0100f8b <cprintf>
f011dc14:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dc17:	e8 38 82 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011dc1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011dc23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011dc2a:	83 ec 0c             	sub    $0xc,%esp
f011dc2d:	68 e0 15 6c f0       	push   $0xf06c15e0
f011dc32:	e8 9d 20 ff ff       	call   f010fcd4 <acquire_spinlock>
f011dc37:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dc3a:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011dc3f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011dc42:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011dc47:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dc4a:	eb 41                	jmp    f011dc8d <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011dc4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dc4f:	89 d0                	mov    %edx,%eax
f011dc51:	c1 e0 02             	shl    $0x2,%eax
f011dc54:	01 d0                	add    %edx,%eax
f011dc56:	c1 e0 03             	shl    $0x3,%eax
f011dc59:	05 00 d5 b0 f0       	add    $0xf0b0d500,%eax
f011dc5e:	8b 10                	mov    (%eax),%edx
f011dc60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc63:	8b 40 10             	mov    0x10(%eax),%eax
f011dc66:	39 c2                	cmp    %eax,%edx
f011dc68:	74 17                	je     f011dc81 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011dc6a:	83 ec 04             	sub    $0x4,%esp
f011dc6d:	68 f8 06 13 f0       	push   $0xf01306f8
f011dc72:	68 ab 00 00 00       	push   $0xab
f011dc77:	68 42 06 13 f0       	push   $0xf0130642
f011dc7c:	e8 b8 26 fe ff       	call   f0100339 <_panic>
				i++;
f011dc81:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dc84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc87:	8b 40 0c             	mov    0xc(%eax),%eax
f011dc8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dc8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dc90:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dc93:	7c b7                	jl     f011dc4c <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011dc95:	83 ec 0c             	sub    $0xc,%esp
f011dc98:	68 e0 15 6c f0       	push   $0xf06c15e0
f011dc9d:	e8 b9 20 ff ff       	call   f010fd5b <release_spinlock>
f011dca2:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011dca5:	83 ec 0c             	sub    $0xc,%esp
f011dca8:	68 58 08 13 f0       	push   $0xf0130858
f011dcad:	e8 d9 32 fe ff       	call   f0100f8b <cprintf>
f011dcb2:	83 c4 10             	add    $0x10,%esp
}
f011dcb5:	90                   	nop
f011dcb6:	c9                   	leave  
f011dcb7:	c3                   	ret    

f011dcb8 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011dcb8:	55                   	push   %ebp
f011dcb9:	89 e5                	mov    %esp,%ebp
f011dcbb:	57                   	push   %edi
f011dcbc:	56                   	push   %esi
f011dcbd:	53                   	push   %ebx
f011dcbe:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dcc1:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011dcc6:	84 c0                	test   %al,%al
f011dcc8:	0f 84 ae 01 00 00    	je     f011de7c <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011dcce:	83 ec 0c             	sub    $0xc,%esp
f011dcd1:	6a 01                	push   $0x1
f011dcd3:	e8 fe 10 00 00       	call   f011edd6 <chksch>
f011dcd8:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011dcdb:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011dce2:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dce5:	bb dc 08 13 f0       	mov    $0xf01308dc,%ebx
f011dcea:	ba 05 00 00 00       	mov    $0x5,%edx
f011dcef:	89 c7                	mov    %eax,%edi
f011dcf1:	89 de                	mov    %ebx,%esi
f011dcf3:	89 d1                	mov    %edx,%ecx
f011dcf5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dcf7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dcfe:	e9 4a 01 00 00       	jmp    f011de4d <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011dd03:	6a 00                	push   $0x0
f011dd05:	6a 00                	push   $0x0
f011dd07:	68 10 27 00 00       	push   $0x2710
f011dd0c:	68 94 08 13 f0       	push   $0xf0130894
f011dd11:	e8 b2 d2 fe ff       	call   f010afc8 <env_create>
f011dd16:	83 c4 10             	add    $0x10,%esp
f011dd19:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dd1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dd1f:	b9 05 00 00 00       	mov    $0x5,%ecx
f011dd24:	99                   	cltd   
f011dd25:	f7 f9                	idiv   %ecx
f011dd27:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011dd2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dd2d:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dd31:	83 ec 08             	sub    $0x8,%esp
f011dd34:	50                   	push   %eax
f011dd35:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dd38:	e8 49 89 fe ff       	call   f0106686 <env_set_nice>
f011dd3d:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dd40:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dd44:	75 17                	jne    f011dd5d <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011dd46:	83 ec 04             	sub    $0x4,%esp
f011dd49:	68 29 06 13 f0       	push   $0xf0130629
f011dd4e:	68 c1 00 00 00       	push   $0xc1
f011dd53:	68 42 06 13 f0       	push   $0xf0130642
f011dd58:	e8 dc 25 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011dd5d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dd60:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dd66:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011dd6b:	74 17                	je     f011dd84 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011dd6d:	83 ec 04             	sub    $0x4,%esp
f011dd70:	68 60 06 13 f0       	push   $0xf0130660
f011dd75:	68 c3 00 00 00       	push   $0xc3
f011dd7a:	68 42 06 13 f0       	push   $0xf0130642
f011dd7f:	e8 b5 25 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dd84:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dd87:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dd8b:	83 c0 0f             	add    $0xf,%eax
f011dd8e:	83 f8 1e             	cmp    $0x1e,%eax
f011dd91:	0f 87 a5 00 00 00    	ja     f011de3c <test_bsd_nice_2+0x184>
f011dd97:	8b 04 85 f0 08 13 f0 	mov    -0xfecf710(,%eax,4),%eax
f011dd9e:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dda0:	a1 7c 13 6c f0       	mov    0xf06c137c,%eax
f011dda5:	8d 50 01             	lea    0x1(%eax),%edx
f011dda8:	89 15 7c 13 6c f0    	mov    %edx,0xf06c137c
f011ddae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ddb1:	8b 52 10             	mov    0x10(%edx),%edx
f011ddb4:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011ddbb:	eb 7f                	jmp    f011de3c <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011ddbd:	a1 80 13 6c f0       	mov    0xf06c1380,%eax
f011ddc2:	8d 50 01             	lea    0x1(%eax),%edx
f011ddc5:	89 15 80 13 6c f0    	mov    %edx,0xf06c1380
f011ddcb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ddce:	8b 52 10             	mov    0x10(%edx),%edx
f011ddd1:	83 c0 0a             	add    $0xa,%eax
f011ddd4:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011dddb:	eb 5f                	jmp    f011de3c <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011dddd:	a1 84 13 6c f0       	mov    0xf06c1384,%eax
f011dde2:	8d 50 01             	lea    0x1(%eax),%edx
f011dde5:	89 15 84 13 6c f0    	mov    %edx,0xf06c1384
f011ddeb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ddee:	8b 52 10             	mov    0x10(%edx),%edx
f011ddf1:	83 c0 14             	add    $0x14,%eax
f011ddf4:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011ddfb:	eb 3f                	jmp    f011de3c <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011ddfd:	a1 88 13 6c f0       	mov    0xf06c1388,%eax
f011de02:	8d 50 01             	lea    0x1(%eax),%edx
f011de05:	89 15 88 13 6c f0    	mov    %edx,0xf06c1388
f011de0b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de0e:	8b 52 10             	mov    0x10(%edx),%edx
f011de11:	83 c0 1e             	add    $0x1e,%eax
f011de14:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de1b:	eb 1f                	jmp    f011de3c <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011de1d:	a1 8c 13 6c f0       	mov    0xf06c138c,%eax
f011de22:	8d 50 01             	lea    0x1(%eax),%edx
f011de25:	89 15 8c 13 6c f0    	mov    %edx,0xf06c138c
f011de2b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de2e:	8b 52 10             	mov    0x10(%edx),%edx
f011de31:	83 c0 28             	add    $0x28,%eax
f011de34:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de3b:	90                   	nop
			}
			sched_new_env(env);
f011de3c:	83 ec 0c             	sub    $0xc,%esp
f011de3f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011de42:	e8 d5 78 fe ff       	call   f010571c <sched_new_env>
f011de47:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011de4a:	ff 45 e4             	incl   -0x1c(%ebp)
f011de4d:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011de51:	0f 8e ac fe ff ff    	jle    f011dd03 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011de57:	83 ec 0c             	sub    $0xc,%esp
f011de5a:	68 90 06 13 f0       	push   $0xf0130690
f011de5f:	e8 27 31 fe ff       	call   f0100f8b <cprintf>
f011de64:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011de67:	83 ec 0c             	sub    $0xc,%esp
f011de6a:	68 df 06 13 f0       	push   $0xf01306df
f011de6f:	e8 87 40 fe ff       	call   f0101efb <execute_command>
f011de74:	83 c4 10             	add    $0x10,%esp
f011de77:	e9 d0 00 00 00       	jmp    f011df4c <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011de7c:	83 ec 0c             	sub    $0xc,%esp
f011de7f:	6a 00                	push   $0x0
f011de81:	e8 50 0f 00 00       	call   f011edd6 <chksch>
f011de86:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011de89:	83 ec 0c             	sub    $0xc,%esp
f011de8c:	68 e6 06 13 f0       	push   $0xf01306e6
f011de91:	e8 f5 30 fe ff       	call   f0100f8b <cprintf>
f011de96:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011de99:	e8 b6 7f fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011de9e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dea5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011deac:	e9 8a 00 00 00       	jmp    f011df3b <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011deb1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011deb8:	eb 55                	jmp    f011df0f <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011deba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011debd:	8b 14 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%edx
f011dec4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011dec7:	89 c8                	mov    %ecx,%eax
f011dec9:	c1 e0 02             	shl    $0x2,%eax
f011decc:	01 c8                	add    %ecx,%eax
f011dece:	01 c0                	add    %eax,%eax
f011ded0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011ded3:	01 c8                	add    %ecx,%eax
f011ded5:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011dedc:	83 ec 04             	sub    $0x4,%esp
f011dedf:	52                   	push   %edx
f011dee0:	ff 75 e0             	pushl  -0x20(%ebp)
f011dee3:	50                   	push   %eax
f011dee4:	e8 7f f8 ff ff       	call   f011d768 <find_in_range>
f011dee9:	83 c4 10             	add    $0x10,%esp
f011deec:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011deef:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011def3:	75 17                	jne    f011df0c <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011def5:	83 ec 04             	sub    $0x4,%esp
f011def8:	68 f8 06 13 f0       	push   $0xf01306f8
f011defd:	68 ea 00 00 00       	push   $0xea
f011df02:	68 42 06 13 f0       	push   $0xf0130642
f011df07:	e8 2d 24 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011df0c:	ff 45 d8             	incl   -0x28(%ebp)
f011df0f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011df12:	89 d0                	mov    %edx,%eax
f011df14:	c1 e0 02             	shl    $0x2,%eax
f011df17:	01 d0                	add    %edx,%eax
f011df19:	01 c0                	add    %eax,%eax
f011df1b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011df1e:	01 d0                	add    %edx,%eax
f011df20:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011df27:	85 c0                	test   %eax,%eax
f011df29:	75 8f                	jne    f011deba <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011df2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df2e:	8b 04 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%eax
f011df35:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011df38:	ff 45 dc             	incl   -0x24(%ebp)
f011df3b:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011df3f:	0f 8e 6c ff ff ff    	jle    f011deb1 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011df45:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011df4c:	83 ec 0c             	sub    $0xc,%esp
f011df4f:	68 a0 08 13 f0       	push   $0xf01308a0
f011df54:	e8 32 30 fe ff       	call   f0100f8b <cprintf>
f011df59:	83 c4 10             	add    $0x10,%esp
}
f011df5c:	90                   	nop
f011df5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011df60:	5b                   	pop    %ebx
f011df61:	5e                   	pop    %esi
f011df62:	5f                   	pop    %edi
f011df63:	5d                   	pop    %ebp
f011df64:	c3                   	ret    

f011df65 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011df65:	55                   	push   %ebp
f011df66:	89 e5                	mov    %esp,%ebp
f011df68:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011df6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011df71:	8b 45 08             	mov    0x8(%ebp),%eax
f011df74:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011df77:	89 10                	mov    %edx,(%eax)
}
f011df79:	8b 45 08             	mov    0x8(%ebp),%eax
f011df7c:	c9                   	leave  
f011df7d:	c2 04 00             	ret    $0x4

f011df80 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011df80:	55                   	push   %ebp
f011df81:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011df83:	8b 45 08             	mov    0x8(%ebp),%eax
f011df86:	85 c0                	test   %eax,%eax
f011df88:	78 16                	js     f011dfa0 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011df8a:	8b 45 08             	mov    0x8(%ebp),%eax
f011df8d:	05 00 20 00 00       	add    $0x2000,%eax
f011df92:	85 c0                	test   %eax,%eax
f011df94:	79 05                	jns    f011df9b <fix_round+0x1b>
f011df96:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011df9b:	c1 f8 0e             	sar    $0xe,%eax
f011df9e:	eb 14                	jmp    f011dfb4 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011dfa0:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfa3:	2d 00 20 00 00       	sub    $0x2000,%eax
f011dfa8:	85 c0                	test   %eax,%eax
f011dfaa:	79 05                	jns    f011dfb1 <fix_round+0x31>
f011dfac:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011dfb1:	c1 f8 0e             	sar    $0xe,%eax
}
f011dfb4:	5d                   	pop    %ebp
f011dfb5:	c3                   	ret    

f011dfb6 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011dfb6:	55                   	push   %ebp
f011dfb7:	89 e5                	mov    %esp,%ebp
f011dfb9:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011dfbc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011dfc0:	79 16                	jns    f011dfd8 <fix_scale+0x22>
f011dfc2:	68 6c 09 13 f0       	push   $0xf013096c
f011dfc7:	68 73 09 13 f0       	push   $0xf0130973
f011dfcc:	6a 5a                	push   $0x5a
f011dfce:	68 88 09 13 f0       	push   $0xf0130988
f011dfd3:	e8 61 23 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011dfd8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011dfdb:	0f af 45 10          	imul   0x10(%ebp),%eax
f011dfdf:	89 c2                	mov    %eax,%edx
f011dfe1:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfe4:	83 ec 08             	sub    $0x8,%esp
f011dfe7:	52                   	push   %edx
f011dfe8:	50                   	push   %eax
f011dfe9:	e8 77 ff ff ff       	call   f011df65 <__mk_fix>
f011dfee:	83 c4 0c             	add    $0xc,%esp
}
f011dff1:	8b 45 08             	mov    0x8(%ebp),%eax
f011dff4:	c9                   	leave  
f011dff5:	c2 04 00             	ret    $0x4

f011dff8 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011dff8:	55                   	push   %ebp
f011dff9:	89 e5                	mov    %esp,%ebp
f011dffb:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011dffe:	83 ec 08             	sub    $0x8,%esp
f011e001:	68 9c 09 13 f0       	push   $0xf013099c
f011e006:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e00b:	e8 93 1c ff ff       	call   f010fca3 <init_spinlock>
f011e010:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011e013:	83 ec 0c             	sub    $0xc,%esp
f011e016:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e01b:	e8 b4 1c ff ff       	call   f010fcd4 <acquire_spinlock>
f011e020:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011e023:	c7 05 c8 14 6c f0 00 	movl   $0x0,0xf06c14c8
f011e02a:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011e02d:	83 ec 0c             	sub    $0xc,%esp
f011e030:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e035:	e8 21 1d ff ff       	call   f010fd5b <release_spinlock>
f011e03a:	83 c4 10             	add    $0x10,%esp
}
f011e03d:	90                   	nop
f011e03e:	c9                   	leave  
f011e03f:	c3                   	ret    

f011e040 <inctst>:
void inctst()
{
f011e040:	55                   	push   %ebp
f011e041:	89 e5                	mov    %esp,%ebp
f011e043:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011e046:	83 ec 0c             	sub    $0xc,%esp
f011e049:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e04e:	e8 81 1c ff ff       	call   f010fcd4 <acquire_spinlock>
f011e053:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011e056:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e05b:	40                   	inc    %eax
f011e05c:	a3 c8 14 6c f0       	mov    %eax,0xf06c14c8
	}
	release_spinlock(&tstcntlock);
f011e061:	83 ec 0c             	sub    $0xc,%esp
f011e064:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e069:	e8 ed 1c ff ff       	call   f010fd5b <release_spinlock>
f011e06e:	83 c4 10             	add    $0x10,%esp
}
f011e071:	90                   	nop
f011e072:	c9                   	leave  
f011e073:	c3                   	ret    

f011e074 <gettst>:
uint32 gettst()
{
f011e074:	55                   	push   %ebp
f011e075:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e077:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
}
f011e07c:	5d                   	pop    %ebp
f011e07d:	c3                   	ret    

f011e07e <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e07e:	55                   	push   %ebp
f011e07f:	89 e5                	mov    %esp,%ebp
f011e081:	83 ec 28             	sub    $0x28,%esp
f011e084:	8b 45 14             	mov    0x14(%ebp),%eax
f011e087:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e08a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e091:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e095:	83 f8 65             	cmp    $0x65,%eax
f011e098:	74 5d                	je     f011e0f7 <tst+0x79>
f011e09a:	83 f8 65             	cmp    $0x65,%eax
f011e09d:	7f 0a                	jg     f011e0a9 <tst+0x2b>
f011e09f:	83 f8 62             	cmp    $0x62,%eax
f011e0a2:	74 73                	je     f011e117 <tst+0x99>
f011e0a4:	e9 91 00 00 00       	jmp    f011e13a <tst+0xbc>
f011e0a9:	83 f8 67             	cmp    $0x67,%eax
f011e0ac:	74 29                	je     f011e0d7 <tst+0x59>
f011e0ae:	83 f8 6c             	cmp    $0x6c,%eax
f011e0b1:	0f 85 83 00 00 00    	jne    f011e13a <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e0b7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0ba:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e0bd:	73 09                	jae    f011e0c8 <tst+0x4a>
			chk = 1;
f011e0bf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e0c6:	eb 68                	jmp    f011e130 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e0c8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e0cc:	74 62                	je     f011e130 <tst+0xb2>
			chk = 1;
f011e0ce:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e0d5:	eb 59                	jmp    f011e130 <tst+0xb2>
	case 'g':
		if (n > v1)
f011e0d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0da:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e0dd:	76 09                	jbe    f011e0e8 <tst+0x6a>
			chk = 1;
f011e0df:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e0e6:	eb 4b                	jmp    f011e133 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e0e8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e0ec:	74 45                	je     f011e133 <tst+0xb5>
			chk = 1;
f011e0ee:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e0f5:	eb 3c                	jmp    f011e133 <tst+0xb5>
	case 'e':
		if (n == v1)
f011e0f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e0fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e0fd:	75 09                	jne    f011e108 <tst+0x8a>
			chk = 1;
f011e0ff:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e106:	eb 2e                	jmp    f011e136 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e108:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e10c:	74 28                	je     f011e136 <tst+0xb8>
			chk = 1;
f011e10e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e115:	eb 1f                	jmp    f011e136 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e117:	8b 45 08             	mov    0x8(%ebp),%eax
f011e11a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e11d:	72 1a                	jb     f011e139 <tst+0xbb>
f011e11f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e122:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e125:	77 12                	ja     f011e139 <tst+0xbb>
			chk = 1;
f011e127:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e12e:	eb 09                	jmp    f011e139 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e130:	90                   	nop
f011e131:	eb 07                	jmp    f011e13a <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e133:	90                   	nop
f011e134:	eb 04                	jmp    f011e13a <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e136:	90                   	nop
f011e137:	eb 01                	jmp    f011e13a <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e139:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e13a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e13e:	75 14                	jne    f011e154 <tst+0xd6>
f011e140:	83 ec 04             	sub    $0x4,%esp
f011e143:	68 a8 09 13 f0       	push   $0xf01309a8
f011e148:	6a 48                	push   $0x48
f011e14a:	68 bb 09 13 f0       	push   $0xf01309bb
f011e14f:	e8 e5 21 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e154:	83 ec 0c             	sub    $0xc,%esp
f011e157:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e15c:	e8 73 1b ff ff       	call   f010fcd4 <acquire_spinlock>
f011e161:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e164:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e169:	40                   	inc    %eax
f011e16a:	a3 c8 14 6c f0       	mov    %eax,0xf06c14c8
	}
	release_spinlock(&tstcntlock);
f011e16f:	83 ec 0c             	sub    $0xc,%esp
f011e172:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e177:	e8 df 1b ff ff       	call   f010fd5b <release_spinlock>
f011e17c:	83 c4 10             	add    $0x10,%esp

	return;
f011e17f:	90                   	nop
}
f011e180:	c9                   	leave  
f011e181:	c3                   	ret    

f011e182 <chktst>:

void chktst(uint32 n)
{
f011e182:	55                   	push   %ebp
f011e183:	89 e5                	mov    %esp,%ebp
f011e185:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e188:	83 ec 0c             	sub    $0xc,%esp
f011e18b:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e190:	e8 3f 1b ff ff       	call   f010fcd4 <acquire_spinlock>
f011e195:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e198:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e19d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e1a0:	83 ec 0c             	sub    $0xc,%esp
f011e1a3:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e1a8:	e8 ae 1b ff ff       	call   f010fd5b <release_spinlock>
f011e1ad:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e1b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e1b3:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e1b6:	75 12                	jne    f011e1ca <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e1b8:	83 ec 0c             	sub    $0xc,%esp
f011e1bb:	68 d4 09 13 f0       	push   $0xf01309d4
f011e1c0:	e8 c6 2d fe ff       	call   f0100f8b <cprintf>
f011e1c5:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e1c8:	eb 14                	jmp    f011e1de <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e1ca:	83 ec 04             	sub    $0x4,%esp
f011e1cd:	68 00 0a 13 f0       	push   $0xf0130a00
f011e1d2:	6a 5e                	push   $0x5e
f011e1d4:	68 bb 09 13 f0       	push   $0xf01309bb
f011e1d9:	e8 5b 21 fe ff       	call   f0100339 <_panic>
}
f011e1de:	c9                   	leave  
f011e1df:	c3                   	ret    

f011e1e0 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e1e0:	55                   	push   %ebp
f011e1e1:	89 e5                	mov    %esp,%ebp
f011e1e3:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e1e6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e1ea:	77 07                	ja     f011e1f3 <nearest_pow2_ceil+0x13>
f011e1ec:	b8 01 00 00 00       	mov    $0x1,%eax
f011e1f1:	eb 20                	jmp    f011e213 <nearest_pow2_ceil+0x33>
	int power = 2;
f011e1f3:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e1fa:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e1fd:	eb 08                	jmp    f011e207 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e1ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e202:	01 c0                	add    %eax,%eax
f011e204:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e207:	d1 6d 08             	shrl   0x8(%ebp)
f011e20a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e20e:	75 ef                	jne    f011e1ff <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e210:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e213:	c9                   	leave  
f011e214:	c3                   	ret    

f011e215 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e215:	55                   	push   %ebp
f011e216:	89 e5                	mov    %esp,%ebp
f011e218:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e21b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e21f:	77 07                	ja     f011e228 <log2_ceil+0x13>
f011e221:	b8 01 00 00 00       	mov    $0x1,%eax
f011e226:	eb 1b                	jmp    f011e243 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e228:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e22f:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e232:	eb 03                	jmp    f011e237 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e234:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e237:	d1 6d 08             	shrl   0x8(%ebp)
f011e23a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e23e:	75 f4                	jne    f011e234 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e240:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e243:	c9                   	leave  
f011e244:	c3                   	ret    

f011e245 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e245:	55                   	push   %ebp
f011e246:	89 e5                	mov    %esp,%ebp
f011e248:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e24b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e252:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e259:	eb 12                	jmp    f011e26d <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e25b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e25e:	89 d0                	mov    %edx,%eax
f011e260:	c1 e0 02             	shl    $0x2,%eax
f011e263:	01 d0                	add    %edx,%eax
f011e265:	01 c0                	add    %eax,%eax
f011e267:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e26a:	ff 45 f0             	incl   -0x10(%ebp)
f011e26d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e270:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e273:	7c e6                	jl     f011e25b <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e275:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e278:	83 ec 04             	sub    $0x4,%esp
f011e27b:	ff 75 f4             	pushl  -0xc(%ebp)
f011e27e:	ff 75 08             	pushl  0x8(%ebp)
f011e281:	50                   	push   %eax
f011e282:	e8 2f fd ff ff       	call   f011dfb6 <fix_scale>
f011e287:	83 c4 0c             	add    $0xc,%esp
f011e28a:	83 ec 0c             	sub    $0xc,%esp
f011e28d:	ff 75 dc             	pushl  -0x24(%ebp)
f011e290:	e8 eb fc ff ff       	call   f011df80 <fix_round>
f011e295:	83 c4 10             	add    $0x10,%esp
f011e298:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e29b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e29e:	99                   	cltd   
f011e29f:	f7 7d f4             	idivl  -0xc(%ebp)
f011e2a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e2a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e2a8:	99                   	cltd   
f011e2a9:	f7 7d f4             	idivl  -0xc(%ebp)
f011e2ac:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e2af:	83 ec 08             	sub    $0x8,%esp
f011e2b2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e2b5:	50                   	push   %eax
f011e2b6:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e2b9:	e8 6a 1e 00 00       	call   f0120128 <ltostr>
f011e2be:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e2c1:	83 ec 08             	sub    $0x8,%esp
f011e2c4:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e2c7:	50                   	push   %eax
f011e2c8:	ff 75 e0             	pushl  -0x20(%ebp)
f011e2cb:	e8 58 1e 00 00       	call   f0120128 <ltostr>
f011e2d0:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e2d3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e2d6:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e2db:	f7 e9                	imul   %ecx
f011e2dd:	c1 fa 02             	sar    $0x2,%edx
f011e2e0:	89 c8                	mov    %ecx,%eax
f011e2e2:	c1 f8 1f             	sar    $0x1f,%eax
f011e2e5:	29 c2                	sub    %eax,%edx
f011e2e7:	89 d0                	mov    %edx,%eax
f011e2e9:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e2ec:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e2f3:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e2fa:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e300:	eb 31                	jmp    f011e333 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e302:	83 ec 04             	sub    $0x4,%esp
f011e305:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e308:	50                   	push   %eax
f011e309:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e30c:	50                   	push   %eax
f011e30d:	68 1c 0a 13 f0       	push   $0xf0130a1c
f011e312:	e8 ea 1e 00 00       	call   f0120201 <strcconcat>
f011e317:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e31a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e31d:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e322:	f7 e9                	imul   %ecx
f011e324:	c1 fa 02             	sar    $0x2,%edx
f011e327:	89 c8                	mov    %ecx,%eax
f011e329:	c1 f8 1f             	sar    $0x1f,%eax
f011e32c:	29 c2                	sub    %eax,%edx
f011e32e:	89 d0                	mov    %edx,%eax
f011e330:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e333:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e336:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e339:	7c c7                	jl     f011e302 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e33b:	83 ec 04             	sub    $0x4,%esp
f011e33e:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e341:	50                   	push   %eax
f011e342:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e345:	50                   	push   %eax
f011e346:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e349:	50                   	push   %eax
f011e34a:	e8 b2 1e 00 00       	call   f0120201 <strcconcat>
f011e34f:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e352:	83 ec 04             	sub    $0x4,%esp
f011e355:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e358:	50                   	push   %eax
f011e359:	68 1e 0a 13 f0       	push   $0xf0130a1e
f011e35e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e361:	50                   	push   %eax
f011e362:	e8 9a 1e 00 00       	call   f0120201 <strcconcat>
f011e367:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e36a:	83 ec 04             	sub    $0x4,%esp
f011e36d:	ff 75 10             	pushl  0x10(%ebp)
f011e370:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e373:	50                   	push   %eax
f011e374:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e377:	50                   	push   %eax
f011e378:	e8 84 1e 00 00       	call   f0120201 <strcconcat>
f011e37d:	83 c4 10             	add    $0x10,%esp

}
f011e380:	90                   	nop
f011e381:	c9                   	leave  
f011e382:	c3                   	ret    

f011e383 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e383:	55                   	push   %ebp
f011e384:	89 e5                	mov    %esp,%ebp
f011e386:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e38c:	83 ec 0c             	sub    $0xc,%esp
f011e38f:	68 20 0a 13 f0       	push   $0xf0130a20
f011e394:	e8 e9 18 00 00       	call   f011fc82 <strlen>
f011e399:	83 c4 10             	add    $0x10,%esp
f011e39c:	83 ec 04             	sub    $0x4,%esp
f011e39f:	50                   	push   %eax
f011e3a0:	68 20 0a 13 f0       	push   $0xf0130a20
f011e3a5:	ff 75 08             	pushl  0x8(%ebp)
f011e3a8:	e8 19 1a 00 00       	call   f011fdc6 <strncmp>
f011e3ad:	83 c4 10             	add    $0x10,%esp
f011e3b0:	85 c0                	test   %eax,%eax
f011e3b2:	0f 85 8a 00 00 00    	jne    f011e442 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e3b8:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e3bb:	50                   	push   %eax
f011e3bc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e3c2:	50                   	push   %eax
f011e3c3:	68 2e 0a 13 f0       	push   $0xf0130a2e
f011e3c8:	ff 75 08             	pushl  0x8(%ebp)
f011e3cb:	e8 c7 1e 00 00       	call   f0120297 <strsplit>
f011e3d0:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e3d3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e3d9:	83 ec 04             	sub    $0x4,%esp
f011e3dc:	6a 0a                	push   $0xa
f011e3de:	6a 00                	push   $0x0
f011e3e0:	50                   	push   %eax
f011e3e1:	e8 fc 1b 00 00       	call   f011ffe2 <strtol>
f011e3e6:	83 c4 10             	add    $0x10,%esp
f011e3e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e3ec:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e3f3:	83 ec 04             	sub    $0x4,%esp
f011e3f6:	6a 00                	push   $0x0
f011e3f8:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e3fb:	50                   	push   %eax
f011e3fc:	ff 75 e0             	pushl  -0x20(%ebp)
f011e3ff:	e8 92 d6 fe ff       	call   f010ba96 <envid2env>
f011e404:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e407:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e40a:	8b 40 10             	mov    0x10(%eax),%eax
f011e40d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e410:	74 19                	je     f011e42b <sys_utilities+0xa8>
f011e412:	68 30 0a 13 f0       	push   $0xf0130a30
f011e417:	68 73 09 13 f0       	push   $0xf0130973
f011e41c:	68 a4 00 00 00       	push   $0xa4
f011e421:	68 bb 09 13 f0       	push   $0xf01309bb
f011e426:	e8 0e 1f fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e42b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e42e:	83 ec 08             	sub    $0x8,%esp
f011e431:	ff 75 0c             	pushl  0xc(%ebp)
f011e434:	50                   	push   %eax
f011e435:	e8 4c 82 fe ff       	call   f0106686 <env_set_nice>
f011e43a:	83 c4 10             	add    $0x10,%esp
f011e43d:	e9 12 04 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e442:	83 ec 0c             	sub    $0xc,%esp
f011e445:	68 45 0a 13 f0       	push   $0xf0130a45
f011e44a:	e8 33 18 00 00       	call   f011fc82 <strlen>
f011e44f:	83 c4 10             	add    $0x10,%esp
f011e452:	83 ec 04             	sub    $0x4,%esp
f011e455:	50                   	push   %eax
f011e456:	68 45 0a 13 f0       	push   $0xf0130a45
f011e45b:	ff 75 08             	pushl  0x8(%ebp)
f011e45e:	e8 63 19 00 00       	call   f011fdc6 <strncmp>
f011e463:	83 c4 10             	add    $0x10,%esp
f011e466:	85 c0                	test   %eax,%eax
f011e468:	0f 85 a6 01 00 00    	jne    f011e614 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e46e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e471:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e474:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e477:	50                   	push   %eax
f011e478:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e47e:	50                   	push   %eax
f011e47f:	68 2e 0a 13 f0       	push   $0xf0130a2e
f011e484:	ff 75 08             	pushl  0x8(%ebp)
f011e487:	e8 0b 1e 00 00       	call   f0120297 <strsplit>
f011e48c:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e48f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e495:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e498:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e49f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e4a6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e4ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4b0:	8b 00                	mov    (%eax),%eax
f011e4b2:	85 c0                	test   %eax,%eax
f011e4b4:	79 1c                	jns    f011e4d2 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e4b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e4bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4c0:	8b 00                	mov    (%eax),%eax
f011e4c2:	f7 d8                	neg    %eax
f011e4c4:	89 c2                	mov    %eax,%edx
f011e4c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4c9:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e4cb:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e4d2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e4d9:	83 ec 0c             	sub    $0xc,%esp
f011e4dc:	68 e0 15 6c f0       	push   $0xf06c15e0
f011e4e1:	e8 ee 17 ff ff       	call   f010fcd4 <acquire_spinlock>
f011e4e6:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e4e9:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011e4ee:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e4f1:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011e4f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e4f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e4fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e4ff:	eb 6c                	jmp    f011e56d <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e501:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e504:	83 c0 20             	add    $0x20,%eax
f011e507:	83 ec 08             	sub    $0x8,%esp
f011e50a:	ff 75 d8             	pushl  -0x28(%ebp)
f011e50d:	50                   	push   %eax
f011e50e:	e8 7b 18 00 00       	call   f011fd8e <strcmp>
f011e513:	83 c4 10             	add    $0x10,%esp
f011e516:	85 c0                	test   %eax,%eax
f011e518:	75 46                	jne    f011e560 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e51a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e51d:	8b 00                	mov    (%eax),%eax
f011e51f:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e522:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e525:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e527:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e52b:	74 14                	je     f011e541 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e52d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e530:	8b 40 10             	mov    0x10(%eax),%eax
f011e533:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e536:	7d 1d                	jge    f011e555 <sys_utilities+0x1d2>
					{
						success = 0;
f011e538:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e53f:	eb 32                	jmp    f011e573 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e541:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e544:	8b 40 10             	mov    0x10(%eax),%eax
f011e547:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e54a:	7e 09                	jle    f011e555 <sys_utilities+0x1d2>
					{
						success = 0;
f011e54c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e553:	eb 1e                	jmp    f011e573 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e558:	8b 40 10             	mov    0x10(%eax),%eax
f011e55b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e55e:	eb 01                	jmp    f011e561 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e560:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e561:	ff 4d e4             	decl   -0x1c(%ebp)
f011e564:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e567:	8b 40 0c             	mov    0xc(%eax),%eax
f011e56a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e56d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e571:	7f 8e                	jg     f011e501 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e573:	83 ec 0c             	sub    $0xc,%esp
f011e576:	68 e0 15 6c f0       	push   $0xf06c15e0
f011e57b:	e8 db 17 ff ff       	call   f010fd5b <release_spinlock>
f011e580:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e583:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e586:	8b 00                	mov    (%eax),%eax
f011e588:	85 c0                	test   %eax,%eax
f011e58a:	75 06                	jne    f011e592 <sys_utilities+0x20f>
f011e58c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e590:	75 41                	jne    f011e5d3 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e592:	83 ec 0c             	sub    $0xc,%esp
f011e595:	68 58 0a 13 f0       	push   $0xf0130a58
f011e59a:	e8 ec 29 fe ff       	call   f0100f8b <cprintf>
f011e59f:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e5a2:	83 ec 08             	sub    $0x8,%esp
f011e5a5:	ff 75 d8             	pushl  -0x28(%ebp)
f011e5a8:	68 88 0a 13 f0       	push   $0xf0130a88
f011e5ad:	e8 d9 29 fe ff       	call   f0100f8b <cprintf>
f011e5b2:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e5b5:	83 ec 0c             	sub    $0xc,%esp
f011e5b8:	68 58 0a 13 f0       	push   $0xf0130a58
f011e5bd:	e8 c9 29 fe ff       	call   f0100f8b <cprintf>
f011e5c2:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e5c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e5c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e5ce:	e9 81 02 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e5d3:	83 ec 0c             	sub    $0xc,%esp
f011e5d6:	68 a8 0a 13 f0       	push   $0xf0130aa8
f011e5db:	e8 ab 29 fe ff       	call   f0100f8b <cprintf>
f011e5e0:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e5e3:	83 ec 08             	sub    $0x8,%esp
f011e5e6:	ff 75 d8             	pushl  -0x28(%ebp)
f011e5e9:	68 e0 0a 13 f0       	push   $0xf0130ae0
f011e5ee:	e8 98 29 fe ff       	call   f0100f8b <cprintf>
f011e5f3:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e5f6:	83 ec 0c             	sub    $0xc,%esp
f011e5f9:	68 a8 0a 13 f0       	push   $0xf0130aa8
f011e5fe:	e8 88 29 fe ff       	call   f0100f8b <cprintf>
f011e603:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e606:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e609:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e60f:	e9 40 02 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e614:	83 ec 08             	sub    $0x8,%esp
f011e617:	68 03 0b 13 f0       	push   $0xf0130b03
f011e61c:	ff 75 08             	pushl  0x8(%ebp)
f011e61f:	e8 6a 17 00 00       	call   f011fd8e <strcmp>
f011e624:	83 c4 10             	add    $0x10,%esp
f011e627:	85 c0                	test   %eax,%eax
f011e629:	75 77                	jne    f011e6a2 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e62b:	a1 e0 fd 17 f0       	mov    0xf017fde0,%eax
f011e630:	85 c0                	test   %eax,%eax
f011e632:	74 34                	je     f011e668 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e634:	c7 05 e0 fd 17 f0 00 	movl   $0x0,0xf017fde0
f011e63b:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e63e:	83 ec 08             	sub    $0x8,%esp
f011e641:	68 0d 0b 13 f0       	push   $0xf0130b0d
f011e646:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e64b:	e8 44 1a ff ff       	call   f0110094 <init_channel>
f011e650:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e653:	83 ec 08             	sub    $0x8,%esp
f011e656:	68 1a 0b 13 f0       	push   $0xf0130b1a
f011e65b:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e660:	e8 3e 16 ff ff       	call   f010fca3 <init_spinlock>
f011e665:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e668:	83 ec 0c             	sub    $0xc,%esp
f011e66b:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e670:	e8 5f 16 ff ff       	call   f010fcd4 <acquire_spinlock>
f011e675:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e678:	83 ec 08             	sub    $0x8,%esp
f011e67b:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e680:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e685:	e8 37 1a ff ff       	call   f01100c1 <sleep>
f011e68a:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e68d:	83 ec 0c             	sub    $0xc,%esp
f011e690:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e695:	e8 c1 16 ff ff       	call   f010fd5b <release_spinlock>
f011e69a:	83 c4 10             	add    $0x10,%esp
f011e69d:	e9 b2 01 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e6a2:	83 ec 08             	sub    $0x8,%esp
f011e6a5:	68 2c 0b 13 f0       	push   $0xf0130b2c
f011e6aa:	ff 75 08             	pushl  0x8(%ebp)
f011e6ad:	e8 dc 16 00 00       	call   f011fd8e <strcmp>
f011e6b2:	83 c4 10             	add    $0x10,%esp
f011e6b5:	85 c0                	test   %eax,%eax
f011e6b7:	75 15                	jne    f011e6ce <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e6b9:	83 ec 0c             	sub    $0xc,%esp
f011e6bc:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e6c1:	e8 68 1a ff ff       	call   f011012e <wakeup_one>
f011e6c6:	83 c4 10             	add    $0x10,%esp
f011e6c9:	e9 86 01 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e6ce:	83 ec 08             	sub    $0x8,%esp
f011e6d1:	68 3a 0b 13 f0       	push   $0xf0130b3a
f011e6d6:	ff 75 08             	pushl  0x8(%ebp)
f011e6d9:	e8 b0 16 00 00       	call   f011fd8e <strcmp>
f011e6de:	83 c4 10             	add    $0x10,%esp
f011e6e1:	85 c0                	test   %eax,%eax
f011e6e3:	75 15                	jne    f011e6fa <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e6e5:	83 ec 0c             	sub    $0xc,%esp
f011e6e8:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e6ed:	e8 c0 1a ff ff       	call   f01101b2 <wakeup_all>
f011e6f2:	83 c4 10             	add    $0x10,%esp
f011e6f5:	e9 5a 01 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e6fa:	83 ec 08             	sub    $0x8,%esp
f011e6fd:	68 48 0b 13 f0       	push   $0xf0130b48
f011e702:	ff 75 08             	pushl  0x8(%ebp)
f011e705:	e8 84 16 00 00       	call   f011fd8e <strcmp>
f011e70a:	83 c4 10             	add    $0x10,%esp
f011e70d:	85 c0                	test   %eax,%eax
f011e70f:	75 17                	jne    f011e728 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e711:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e714:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e717:	a1 ec d5 b0 f0       	mov    0xf0b0d5ec,%eax
f011e71c:	89 c2                	mov    %eax,%edx
f011e71e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e721:	89 10                	mov    %edx,(%eax)
f011e723:	e9 2c 01 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e728:	83 ec 08             	sub    $0x8,%esp
f011e72b:	68 5d 0b 13 f0       	push   $0xf0130b5d
f011e730:	ff 75 08             	pushl  0x8(%ebp)
f011e733:	e8 56 16 00 00       	call   f011fd8e <strcmp>
f011e738:	83 c4 10             	add    $0x10,%esp
f011e73b:	85 c0                	test   %eax,%eax
f011e73d:	75 1a                	jne    f011e759 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e73f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e742:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e745:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011e74a:	8b 40 0c             	mov    0xc(%eax),%eax
f011e74d:	89 c2                	mov    %eax,%edx
f011e74f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e752:	89 10                	mov    %edx,(%eax)
f011e754:	e9 fb 00 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e759:	83 ec 08             	sub    $0x8,%esp
f011e75c:	68 73 0b 13 f0       	push   $0xf0130b73
f011e761:	ff 75 08             	pushl  0x8(%ebp)
f011e764:	e8 25 16 00 00       	call   f011fd8e <strcmp>
f011e769:	83 c4 10             	add    $0x10,%esp
f011e76c:	85 c0                	test   %eax,%eax
f011e76e:	75 3d                	jne    f011e7ad <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e770:	a1 e4 fd 17 f0       	mov    0xf017fde4,%eax
f011e775:	85 c0                	test   %eax,%eax
f011e777:	74 1f                	je     f011e798 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e779:	c7 05 e4 fd 17 f0 00 	movl   $0x0,0xf017fde4
f011e780:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e783:	83 ec 08             	sub    $0x8,%esp
f011e786:	68 88 0b 13 f0       	push   $0xf0130b88
f011e78b:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e790:	e8 99 17 ff ff       	call   f010ff2e <init_sleeplock>
f011e795:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e798:	83 ec 0c             	sub    $0xc,%esp
f011e79b:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e7a0:	e8 4d 18 ff ff       	call   f010fff2 <acquire_sleeplock>
f011e7a5:	83 c4 10             	add    $0x10,%esp
f011e7a8:	e9 a7 00 00 00       	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e7ad:	83 ec 08             	sub    $0x8,%esp
f011e7b0:	68 98 0b 13 f0       	push   $0xf0130b98
f011e7b5:	ff 75 08             	pushl  0x8(%ebp)
f011e7b8:	e8 d1 15 00 00       	call   f011fd8e <strcmp>
f011e7bd:	83 c4 10             	add    $0x10,%esp
f011e7c0:	85 c0                	test   %eax,%eax
f011e7c2:	75 12                	jne    f011e7d6 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e7c4:	83 ec 0c             	sub    $0xc,%esp
f011e7c7:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e7cc:	e8 7b 18 ff ff       	call   f011004c <release_sleeplock>
f011e7d1:	83 c4 10             	add    $0x10,%esp
f011e7d4:	eb 7e                	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e7d6:	83 ec 08             	sub    $0x8,%esp
f011e7d9:	68 ad 0b 13 f0       	push   $0xf0130bad
f011e7de:	ff 75 08             	pushl  0x8(%ebp)
f011e7e1:	e8 a8 15 00 00       	call   f011fd8e <strcmp>
f011e7e6:	83 c4 10             	add    $0x10,%esp
f011e7e9:	85 c0                	test   %eax,%eax
f011e7eb:	75 14                	jne    f011e801 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e7ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e7f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e7f3:	a1 c0 d6 b0 f0       	mov    0xf0b0d6c0,%eax
f011e7f8:	89 c2                	mov    %eax,%edx
f011e7fa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e7fd:	89 10                	mov    %edx,(%eax)
f011e7ff:	eb 53                	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e801:	83 ec 08             	sub    $0x8,%esp
f011e804:	68 c2 0b 13 f0       	push   $0xf0130bc2
f011e809:	ff 75 08             	pushl  0x8(%ebp)
f011e80c:	e8 7d 15 00 00       	call   f011fd8e <strcmp>
f011e811:	83 c4 10             	add    $0x10,%esp
f011e814:	85 c0                	test   %eax,%eax
f011e816:	75 13                	jne    f011e82b <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e818:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e81b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e81e:	8b 15 40 d6 b0 f0    	mov    0xf0b0d640,%edx
f011e824:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e827:	89 10                	mov    %edx,(%eax)
f011e829:	eb 29                	jmp    f011e854 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e82b:	83 ec 08             	sub    $0x8,%esp
f011e82e:	68 d3 0b 13 f0       	push   $0xf0130bd3
f011e833:	ff 75 08             	pushl  0x8(%ebp)
f011e836:	e8 53 15 00 00       	call   f011fd8e <strcmp>
f011e83b:	83 c4 10             	add    $0x10,%esp
f011e83e:	85 c0                	test   %eax,%eax
f011e840:	75 12                	jne    f011e854 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e842:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e845:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e848:	a1 44 d7 b0 f0       	mov    0xf0b0d744,%eax
f011e84d:	89 c2                	mov    %eax,%edx
f011e84f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e852:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e854:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e858:	79 5b                	jns    f011e8b5 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e85a:	83 ec 08             	sub    $0x8,%esp
f011e85d:	68 e4 0b 13 f0       	push   $0xf0130be4
f011e862:	ff 75 08             	pushl  0x8(%ebp)
f011e865:	e8 24 15 00 00       	call   f011fd8e <strcmp>
f011e86a:	83 c4 10             	add    $0x10,%esp
f011e86d:	85 c0                	test   %eax,%eax
f011e86f:	75 44                	jne    f011e8b5 <sys_utilities+0x532>
		{
			switch (value)
f011e871:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e874:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e877:	74 07                	je     f011e880 <sys_utilities+0x4fd>
f011e879:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e87c:	74 19                	je     f011e897 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e87e:	eb 35                	jmp    f011e8b5 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e880:	83 ec 0c             	sub    $0xc,%esp
f011e883:	68 f4 0b 13 f0       	push   $0xf0130bf4
f011e888:	e8 fe 26 fe ff       	call   f0100f8b <cprintf>
f011e88d:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e890:	e8 a4 0d ff ff       	call   f010f639 <setPageReplacmentAlgorithmFIFO>
				break;
f011e895:	eb 1e                	jmp    f011e8b5 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e897:	83 ec 0c             	sub    $0xc,%esp
f011e89a:	68 64 0c 13 f0       	push   $0xf0130c64
f011e89f:	e8 e7 26 fe ff       	call   f0100f8b <cprintf>
f011e8a4:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e8a7:	83 ec 0c             	sub    $0xc,%esp
f011e8aa:	6a 02                	push   $0x2
f011e8ac:	e8 45 0d ff ff       	call   f010f5f6 <setPageReplacmentAlgorithmLRU>
f011e8b1:	83 c4 10             	add    $0x10,%esp
				break;
f011e8b4:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e8b5:	90                   	nop
f011e8b6:	c9                   	leave  
f011e8b7:	c3                   	ret    

f011e8b8 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e8b8:	55                   	push   %ebp
f011e8b9:	89 e5                	mov    %esp,%ebp
f011e8bb:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e8be:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8c1:	8b 00                	mov    (%eax),%eax
f011e8c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e8c6:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8c9:	8b 00                	mov    (%eax),%eax
f011e8cb:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e8ce:	eb 52                	jmp    f011e922 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e8d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e8d3:	8b 00                	mov    (%eax),%eax
f011e8d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e8d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e8db:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e8de:	75 12                	jne    f011e8f2 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e8e0:	83 ec 0c             	sub    $0xc,%esp
f011e8e3:	68 d8 0c 13 f0       	push   $0xf0130cd8
f011e8e8:	e8 9e 26 fe ff       	call   f0100f8b <cprintf>
f011e8ed:	83 c4 10             	add    $0x10,%esp
			break;
f011e8f0:	eb 3f                	jmp    f011e931 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e8f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e8f6:	74 38                	je     f011e930 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e8f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e8fb:	8b 00                	mov    (%eax),%eax
f011e8fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e900:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e903:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e906:	75 12                	jne    f011e91a <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e908:	83 ec 0c             	sub    $0xc,%esp
f011e90b:	68 f4 0c 13 f0       	push   $0xf0130cf4
f011e910:	e8 76 26 fe ff       	call   f0100f8b <cprintf>
f011e915:	83 c4 10             	add    $0x10,%esp
			break;
f011e918:	eb 17                	jmp    f011e931 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e91a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e91d:	8b 00                	mov    (%eax),%eax
f011e91f:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e922:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e926:	74 09                	je     f011e931 <detect_loop_in_FrameInfo_list+0x79>
f011e928:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e92c:	75 a2                	jne    f011e8d0 <detect_loop_in_FrameInfo_list+0x18>
f011e92e:	eb 01                	jmp    f011e931 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e930:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e931:	83 ec 0c             	sub    $0xc,%esp
f011e934:	68 0b 0d 13 f0       	push   $0xf0130d0b
f011e939:	e8 4d 26 fe ff       	call   f0100f8b <cprintf>
f011e93e:	83 c4 10             	add    $0x10,%esp
}
f011e941:	90                   	nop
f011e942:	c9                   	leave  
f011e943:	c3                   	ret    

f011e944 <scarce_memory>:

void scarce_memory()
{
f011e944:	55                   	push   %ebp
f011e945:	89 e5                	mov    %esp,%ebp
f011e947:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e94a:	a1 b0 17 6c f0       	mov    0xf06c17b0,%eax
f011e94f:	ba 64 00 00 00       	mov    $0x64,%edx
f011e954:	29 c2                	sub    %eax,%edx
f011e956:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011e95b:	0f af c2             	imul   %edx,%eax
f011e95e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e963:	f7 e2                	mul    %edx
f011e965:	89 d0                	mov    %edx,%eax
f011e967:	c1 e8 05             	shr    $0x5,%eax
f011e96a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e96d:	a1 b0 17 6c f0       	mov    0xf06c17b0,%eax
f011e972:	ba 64 00 00 00       	mov    $0x64,%edx
f011e977:	29 c2                	sub    %eax,%edx
f011e979:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011e97e:	89 d1                	mov    %edx,%ecx
f011e980:	0f af c8             	imul   %eax,%ecx
f011e983:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e988:	f7 e1                	mul    %ecx
f011e98a:	c1 ea 05             	shr    $0x5,%edx
f011e98d:	89 d0                	mov    %edx,%eax
f011e98f:	c1 e0 02             	shl    $0x2,%eax
f011e992:	01 d0                	add    %edx,%eax
f011e994:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e99b:	01 d0                	add    %edx,%eax
f011e99d:	c1 e0 02             	shl    $0x2,%eax
f011e9a0:	29 c1                	sub    %eax,%ecx
f011e9a2:	89 ca                	mov    %ecx,%edx
f011e9a4:	85 d2                	test   %edx,%edx
f011e9a6:	74 03                	je     f011e9ab <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e9a8:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e9ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e9b2:	83 ec 0c             	sub    $0xc,%esp
f011e9b5:	68 a0 16 6c f0       	push   $0xf06c16a0
f011e9ba:	e8 15 13 ff ff       	call   f010fcd4 <acquire_spinlock>
f011e9bf:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e9c2:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f011e9c7:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e9ca:	8b 15 78 18 6c f0    	mov    0xf06c1878,%edx
f011e9d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e9d3:	29 c2                	sub    %eax,%edx
f011e9d5:	89 d0                	mov    %edx,%eax
f011e9d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e9da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e9dd:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e9e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e9e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e9ea:	eb 12                	jmp    f011e9fe <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e9ec:	83 ec 0c             	sub    $0xc,%esp
f011e9ef:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e9f2:	50                   	push   %eax
f011e9f3:	e8 ba 97 fe ff       	call   f01081b2 <allocate_frame>
f011e9f8:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e9fb:	ff 45 f0             	incl   -0x10(%ebp)
f011e9fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ea01:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ea04:	76 e6                	jbe    f011e9ec <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011ea06:	83 ec 0c             	sub    $0xc,%esp
f011ea09:	68 a0 16 6c f0       	push   $0xf06c16a0
f011ea0e:	e8 48 13 ff ff       	call   f010fd5b <release_spinlock>
f011ea13:	83 c4 10             	add    $0x10,%esp

}
f011ea16:	90                   	nop
f011ea17:	c9                   	leave  
f011ea18:	c3                   	ret    

f011ea19 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011ea19:	55                   	push   %ebp
f011ea1a:	89 e5                	mov    %esp,%ebp
f011ea1c:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011ea1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011ea26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011ea2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011ea34:	e8 0d d0 fe ff       	call   f010ba46 <get_cpu_proc>
f011ea39:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011ea3c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ea40:	75 19                	jne    f011ea5b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011ea42:	68 25 0d 13 f0       	push   $0xf0130d25
f011ea47:	68 73 09 13 f0       	push   $0xf0130973
f011ea4c:	68 79 01 00 00       	push   $0x179
f011ea51:	68 bb 09 13 f0       	push   $0xf01309bb
f011ea56:	e8 de 18 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011ea5b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ea5f:	0f 85 d6 01 00 00    	jne    f011ec3b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011ea65:	83 ec 0c             	sub    $0xc,%esp
f011ea68:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ea6d:	e8 62 12 ff ff       	call   f010fcd4 <acquire_spinlock>
f011ea72:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ea75:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ea7c:	e9 d2 00 00 00       	jmp    f011eb53 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ea81:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ea88:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ea8d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ea90:	c1 e2 04             	shl    $0x4,%edx
f011ea93:	01 d0                	add    %edx,%eax
f011ea95:	8b 00                	mov    (%eax),%eax
f011ea97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ea9a:	eb 7c                	jmp    f011eb18 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011ea9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea9f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eaa5:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eaa8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eaab:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eab1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011eab4:	0f af c2             	imul   %edx,%eax
f011eab7:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eabc:	f7 e2                	mul    %edx
f011eabe:	89 d0                	mov    %edx,%eax
f011eac0:	c1 e8 05             	shr    $0x5,%eax
f011eac3:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eac6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eac9:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eacf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ead2:	89 d1                	mov    %edx,%ecx
f011ead4:	0f af c8             	imul   %eax,%ecx
f011ead7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eadc:	f7 e1                	mul    %ecx
f011eade:	c1 ea 05             	shr    $0x5,%edx
f011eae1:	89 d0                	mov    %edx,%eax
f011eae3:	c1 e0 02             	shl    $0x2,%eax
f011eae6:	01 d0                	add    %edx,%eax
f011eae8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011eaef:	01 d0                	add    %edx,%eax
f011eaf1:	c1 e0 02             	shl    $0x2,%eax
f011eaf4:	29 c1                	sub    %eax,%ecx
f011eaf6:	89 ca                	mov    %ecx,%edx
f011eaf8:	85 d2                	test   %edx,%edx
f011eafa:	74 03                	je     f011eaff <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011eafc:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011eaff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011eb02:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011eb05:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eb0a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eb0d:	c1 e2 04             	shl    $0x4,%edx
f011eb10:	01 d0                	add    %edx,%eax
f011eb12:	8b 40 08             	mov    0x8(%eax),%eax
f011eb15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eb18:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eb1d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eb20:	c1 e2 04             	shl    $0x4,%edx
f011eb23:	01 d0                	add    %edx,%eax
f011eb25:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eb29:	74 08                	je     f011eb33 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011eb2b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eb2e:	8b 52 08             	mov    0x8(%edx),%edx
f011eb31:	eb 05                	jmp    f011eb38 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011eb33:	ba 00 00 00 00       	mov    $0x0,%edx
f011eb38:	89 50 08             	mov    %edx,0x8(%eax)
f011eb3b:	8b 40 08             	mov    0x8(%eax),%eax
f011eb3e:	85 c0                	test   %eax,%eax
f011eb40:	0f 85 56 ff ff ff    	jne    f011ea9c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011eb46:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eb4a:	0f 85 4c ff ff ff    	jne    f011ea9c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011eb50:	ff 45 e8             	incl   -0x18(%ebp)
f011eb53:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011eb58:	0f b6 c0             	movzbl %al,%eax
f011eb5b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011eb5e:	0f 8f 1d ff ff ff    	jg     f011ea81 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011eb64:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eb6b:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f011eb70:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011eb73:	eb 1a                	jmp    f011eb8f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011eb75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb78:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eb7e:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011eb81:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011eb84:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eb87:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011eb8c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011eb8f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011eb93:	74 08                	je     f011eb9d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011eb95:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb98:	8b 40 08             	mov    0x8(%eax),%eax
f011eb9b:	eb 05                	jmp    f011eba2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011eb9d:	b8 00 00 00 00       	mov    $0x0,%eax
f011eba2:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f011eba7:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011ebac:	85 c0                	test   %eax,%eax
f011ebae:	75 c5                	jne    f011eb75 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011ebb0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ebb4:	75 bf                	jne    f011eb75 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ebb6:	83 ec 0c             	sub    $0xc,%esp
f011ebb9:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ebbe:	e8 98 11 ff ff       	call   f010fd5b <release_spinlock>
f011ebc3:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011ebc6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ebca:	0f 84 d4 00 00 00    	je     f011eca4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ebd0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebd3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ebd9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ebdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebdf:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ebe5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ebe8:	0f af c2             	imul   %edx,%eax
f011ebeb:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ebf0:	f7 e2                	mul    %edx
f011ebf2:	89 d0                	mov    %edx,%eax
f011ebf4:	c1 e8 05             	shr    $0x5,%eax
f011ebf7:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ebfa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebfd:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec03:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ec06:	89 d1                	mov    %edx,%ecx
f011ec08:	0f af c8             	imul   %eax,%ecx
f011ec0b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ec10:	f7 e1                	mul    %ecx
f011ec12:	c1 ea 05             	shr    $0x5,%edx
f011ec15:	89 d0                	mov    %edx,%eax
f011ec17:	c1 e0 02             	shl    $0x2,%eax
f011ec1a:	01 d0                	add    %edx,%eax
f011ec1c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec23:	01 d0                	add    %edx,%eax
f011ec25:	c1 e0 02             	shl    $0x2,%eax
f011ec28:	29 c1                	sub    %eax,%ecx
f011ec2a:	89 ca                	mov    %ecx,%edx
f011ec2c:	85 d2                	test   %edx,%edx
f011ec2e:	74 03                	je     f011ec33 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011ec30:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ec33:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ec36:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ec39:	eb 69                	jmp    f011eca4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ec3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec3e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ec44:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ec47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec4a:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec50:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ec53:	0f af c2             	imul   %edx,%eax
f011ec56:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ec5b:	f7 e2                	mul    %edx
f011ec5d:	89 d0                	mov    %edx,%eax
f011ec5f:	c1 e8 05             	shr    $0x5,%eax
f011ec62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ec65:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec68:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ec71:	89 d1                	mov    %edx,%ecx
f011ec73:	0f af c8             	imul   %eax,%ecx
f011ec76:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ec7b:	f7 e1                	mul    %ecx
f011ec7d:	c1 ea 05             	shr    $0x5,%edx
f011ec80:	89 d0                	mov    %edx,%eax
f011ec82:	c1 e0 02             	shl    $0x2,%eax
f011ec85:	01 d0                	add    %edx,%eax
f011ec87:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec8e:	01 d0                	add    %edx,%eax
f011ec90:	c1 e0 02             	shl    $0x2,%eax
f011ec93:	29 c1                	sub    %eax,%ecx
f011ec95:	89 ca                	mov    %ecx,%edx
f011ec97:	85 d2                	test   %edx,%edx
f011ec99:	74 03                	je     f011ec9e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011ec9b:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ec9e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011eca1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011eca4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011eca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecaa:	01 c2                	add    %eax,%edx
f011ecac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ecaf:	01 d0                	add    %edx,%eax
}
f011ecb1:	c9                   	leave  
f011ecb2:	c3                   	ret    

f011ecb3 <schenv>:


void schenv()
{
f011ecb3:	55                   	push   %ebp
f011ecb4:	89 e5                	mov    %esp,%ebp
f011ecb6:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011ecb9:	c6 05 e0 2d 6c f0 00 	movb   $0x0,0xf06c2de0
	__ne = NULL;
f011ecc0:	c7 05 cc 1a 6c f0 00 	movl   $0x0,0xf06c1acc
f011ecc7:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011ecca:	83 ec 0c             	sub    $0xc,%esp
f011eccd:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ecd2:	e8 fd 0f ff ff       	call   f010fcd4 <acquire_spinlock>
f011ecd7:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ecda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ece1:	eb 3f                	jmp    f011ed22 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011ece3:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ece8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eceb:	c1 e2 04             	shl    $0x4,%edx
f011ecee:	01 d0                	add    %edx,%eax
f011ecf0:	83 ec 0c             	sub    $0xc,%esp
f011ecf3:	50                   	push   %eax
f011ecf4:	e8 99 62 fe ff       	call   f0104f92 <queue_size>
f011ecf9:	83 c4 10             	add    $0x10,%esp
f011ecfc:	85 c0                	test   %eax,%eax
f011ecfe:	74 1f                	je     f011ed1f <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011ed00:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ed05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed08:	c1 e2 04             	shl    $0x4,%edx
f011ed0b:	01 d0                	add    %edx,%eax
f011ed0d:	8b 40 04             	mov    0x4(%eax),%eax
f011ed10:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
				__nl = i;
f011ed15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed18:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
				break;
f011ed1d:	eb 10                	jmp    f011ed2f <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ed1f:	ff 45 f4             	incl   -0xc(%ebp)
f011ed22:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ed27:	0f b6 c0             	movzbl %al,%eax
f011ed2a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ed2d:	7f b4                	jg     f011ece3 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011ed2f:	83 ec 0c             	sub    $0xc,%esp
f011ed32:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ed37:	e8 1f 10 ff ff       	call   f010fd5b <release_spinlock>
f011ed3c:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011ed3f:	e8 02 cd fe ff       	call   f010ba46 <get_cpu_proc>
f011ed44:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011ed47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ed4b:	0f 84 82 00 00 00    	je     f011edd3 <schenv+0x120>
	{
		if (__ne != NULL)
f011ed51:	a1 cc 1a 6c f0       	mov    0xf06c1acc,%eax
f011ed56:	85 c0                	test   %eax,%eax
f011ed58:	74 49                	je     f011eda3 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011ed5a:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ed5f:	0f b6 c0             	movzbl %al,%eax
f011ed62:	8d 50 01             	lea    0x1(%eax),%edx
f011ed65:	a0 e0 2d 6c f0       	mov    0xf06c2de0,%al
f011ed6a:	0f b6 c0             	movzbl %al,%eax
f011ed6d:	39 c2                	cmp    %eax,%edx
f011ed6f:	7d 62                	jge    f011edd3 <schenv+0x120>
			{
				__ne = cur_env;
f011ed71:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed74:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011ed79:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ed7e:	0f b6 c0             	movzbl %al,%eax
f011ed81:	8a 15 44 2d 6c f0    	mov    0xf06c2d44,%dl
f011ed87:	0f b6 d2             	movzbl %dl,%edx
f011ed8a:	4a                   	dec    %edx
f011ed8b:	39 d0                	cmp    %edx,%eax
f011ed8d:	7d 08                	jge    f011ed97 <schenv+0xe4>
f011ed8f:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ed94:	40                   	inc    %eax
f011ed95:	eb 05                	jmp    f011ed9c <schenv+0xe9>
f011ed97:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ed9c:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011eda1:	eb 30                	jmp    f011edd3 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011eda3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eda6:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011edab:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edb0:	0f b6 c0             	movzbl %al,%eax
f011edb3:	8a 15 44 2d 6c f0    	mov    0xf06c2d44,%dl
f011edb9:	0f b6 d2             	movzbl %dl,%edx
f011edbc:	4a                   	dec    %edx
f011edbd:	39 d0                	cmp    %edx,%eax
f011edbf:	7d 08                	jge    f011edc9 <schenv+0x116>
f011edc1:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edc6:	40                   	inc    %eax
f011edc7:	eb 05                	jmp    f011edce <schenv+0x11b>
f011edc9:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edce:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
		}
	}
}
f011edd3:	90                   	nop
f011edd4:	c9                   	leave  
f011edd5:	c3                   	ret    

f011edd6 <chksch>:

void chksch(uint8 onoff)
{
f011edd6:	55                   	push   %ebp
f011edd7:	89 e5                	mov    %esp,%ebp
f011edd9:	83 ec 18             	sub    $0x18,%esp
f011eddc:	8b 45 08             	mov    0x8(%ebp),%eax
f011eddf:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ede2:	e8 2b 79 fe ff       	call   f0106712 <isSchedMethodBSD>
f011ede7:	85 c0                	test   %eax,%eax
f011ede9:	74 48                	je     f011ee33 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011edeb:	e8 d0 78 fe ff       	call   f01066c0 <get_load_average>
f011edf0:	a3 68 2d 6c f0       	mov    %eax,0xf06c2d68
f011edf5:	a1 68 2d 6c f0       	mov    0xf06c2d68,%eax
f011edfa:	a3 7c 18 6c f0       	mov    %eax,0xf06c187c
		acquire_spinlock(&ProcessQueues.qlock);
f011edff:	83 ec 0c             	sub    $0xc,%esp
f011ee02:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee07:	e8 c8 0e ff ff       	call   f010fcd4 <acquire_spinlock>
f011ee0c:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011ee0f:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011ee14:	a3 20 17 6c f0       	mov    %eax,0xf06c1720
		}
		release_spinlock(&ProcessQueues.qlock);
f011ee19:	83 ec 0c             	sub    $0xc,%esp
f011ee1c:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee21:	e8 35 0f ff ff       	call   f010fd5b <release_spinlock>
f011ee26:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011ee29:	c7 05 dc 1a 6c f0 01 	movl   $0x1,0xf06c1adc
f011ee30:	00 00 00 
	}
	__chkstatus = onoff;
f011ee33:	8a 45 f4             	mov    -0xc(%ebp),%al
f011ee36:	a2 c8 1a 6c f0       	mov    %al,0xf06c1ac8
}
f011ee3b:	90                   	nop
f011ee3c:	c9                   	leave  
f011ee3d:	c3                   	ret    

f011ee3e <chk1>:
void chk1()
{
f011ee3e:	55                   	push   %ebp
f011ee3f:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011ee41:	90                   	nop
f011ee42:	5d                   	pop    %ebp
f011ee43:	c3                   	ret    

f011ee44 <chk2>:
void chk2(struct Env* __se)
{
f011ee44:	55                   	push   %ebp
f011ee45:	89 e5                	mov    %esp,%ebp
f011ee47:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011ee4a:	a0 c8 1a 6c f0       	mov    0xf06c1ac8,%al
f011ee4f:	84 c0                	test   %al,%al
f011ee51:	0f 84 59 03 00 00    	je     f011f1b0 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ee57:	e8 b6 78 fe ff       	call   f0106712 <isSchedMethodBSD>
f011ee5c:	85 c0                	test   %eax,%eax
f011ee5e:	0f 84 4d 03 00 00    	je     f011f1b1 <chk2+0x36d>
	{
		__nla = get_load_average();
f011ee64:	e8 57 78 fe ff       	call   f01066c0 <get_load_average>
f011ee69:	a3 b4 17 6c f0       	mov    %eax,0xf06c17b4
		acquire_spinlock(&ProcessQueues.qlock);
f011ee6e:	83 ec 0c             	sub    $0xc,%esp
f011ee71:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee76:	e8 59 0e ff ff       	call   f010fcd4 <acquire_spinlock>
f011ee7b:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011ee7e:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011ee83:	a3 d0 1a 6c f0       	mov    %eax,0xf06c1ad0
		}
		release_spinlock(&ProcessQueues.qlock);
f011ee88:	83 ec 0c             	sub    $0xc,%esp
f011ee8b:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee90:	e8 c6 0e ff ff       	call   f010fd5b <release_spinlock>
f011ee95:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011ee98:	a1 dc 1a 6c f0       	mov    0xf06c1adc,%eax
f011ee9d:	85 c0                	test   %eax,%eax
f011ee9f:	74 72                	je     f011ef13 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011eea1:	83 ec 0c             	sub    $0xc,%esp
f011eea4:	68 e0 15 6c f0       	push   $0xf06c15e0
f011eea9:	e8 26 0e ff ff       	call   f010fcd4 <acquire_spinlock>
f011eeae:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011eeb1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011eeb5:	0f 95 c0             	setne  %al
f011eeb8:	0f b6 c0             	movzbl %al,%eax
f011eebb:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011eec0:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011eec5:	0f b6 c0             	movzbl %al,%eax
f011eec8:	48                   	dec    %eax
f011eec9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011eecc:	eb 20                	jmp    f011eeee <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011eece:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eed3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eed6:	c1 e2 04             	shl    $0x4,%edx
f011eed9:	01 d0                	add    %edx,%eax
f011eedb:	8b 40 0c             	mov    0xc(%eax),%eax
f011eede:	8b 15 94 1c 6c f0    	mov    0xf06c1c94,%edx
f011eee4:	01 d0                	add    %edx,%eax
f011eee6:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011eeeb:	ff 4d f4             	decl   -0xc(%ebp)
f011eeee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011eef2:	79 da                	jns    f011eece <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011eef4:	c7 05 dc 1a 6c f0 00 	movl   $0x0,0xf06c1adc
f011eefb:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011eefe:	83 ec 0c             	sub    $0xc,%esp
f011ef01:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ef06:	e8 50 0e ff ff       	call   f010fd5b <release_spinlock>
f011ef0b:	83 c4 10             	add    $0x10,%esp
f011ef0e:	e9 91 02 00 00       	jmp    f011f1a4 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011ef13:	8b 15 20 17 6c f0    	mov    0xf06c1720,%edx
f011ef19:	a1 d0 1a 6c f0       	mov    0xf06c1ad0,%eax
f011ef1e:	39 c2                	cmp    %eax,%edx
f011ef20:	74 63                	je     f011ef85 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011ef22:	83 ec 0c             	sub    $0xc,%esp
f011ef25:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ef2a:	e8 a5 0d ff ff       	call   f010fcd4 <acquire_spinlock>
f011ef2f:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011ef32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ef36:	0f 95 c0             	setne  %al
f011ef39:	0f b6 c0             	movzbl %al,%eax
f011ef3c:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef41:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ef46:	0f b6 c0             	movzbl %al,%eax
f011ef49:	48                   	dec    %eax
f011ef4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ef4d:	eb 20                	jmp    f011ef6f <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011ef4f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ef54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ef57:	c1 e2 04             	shl    $0x4,%edx
f011ef5a:	01 d0                	add    %edx,%eax
f011ef5c:	8b 40 0c             	mov    0xc(%eax),%eax
f011ef5f:	8b 15 94 1c 6c f0    	mov    0xf06c1c94,%edx
f011ef65:	01 d0                	add    %edx,%eax
f011ef67:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef6c:	ff 4d f0             	decl   -0x10(%ebp)
f011ef6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ef73:	79 da                	jns    f011ef4f <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011ef75:	83 ec 0c             	sub    $0xc,%esp
f011ef78:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ef7d:	e8 d9 0d ff ff       	call   f010fd5b <release_spinlock>
f011ef82:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011ef85:	e8 cf 76 fe ff       	call   f0106659 <timer_ticks>
f011ef8a:	6a 00                	push   $0x0
f011ef8c:	68 e8 03 00 00       	push   $0x3e8
f011ef91:	52                   	push   %edx
f011ef92:	50                   	push   %eax
f011ef93:	e8 f0 31 00 00       	call   f0122188 <__moddi3>
f011ef98:	83 c4 10             	add    $0x10,%esp
f011ef9b:	09 d0                	or     %edx,%eax
f011ef9d:	85 c0                	test   %eax,%eax
f011ef9f:	75 32                	jne    f011efd3 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011efa1:	8b 15 7c 18 6c f0    	mov    0xf06c187c,%edx
f011efa7:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011efac:	39 c2                	cmp    %eax,%edx
f011efae:	75 19                	jne    f011efc9 <chk2+0x185>
f011efb0:	68 35 0d 13 f0       	push   $0xf0130d35
f011efb5:	68 73 09 13 f0       	push   $0xf0130973
f011efba:	68 35 02 00 00       	push   $0x235
f011efbf:	68 bb 09 13 f0       	push   $0xf01309bb
f011efc4:	e8 00 14 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011efc9:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011efce:	a3 7c 18 6c f0       	mov    %eax,0xf06c187c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011efd3:	e8 81 76 fe ff       	call   f0106659 <timer_ticks>
f011efd8:	6a 00                	push   $0x0
f011efda:	6a 64                	push   $0x64
f011efdc:	52                   	push   %edx
f011efdd:	50                   	push   %eax
f011efde:	e8 a5 31 00 00       	call   f0122188 <__moddi3>
f011efe3:	83 c4 10             	add    $0x10,%esp
f011efe6:	09 d0                	or     %edx,%eax
f011efe8:	85 c0                	test   %eax,%eax
f011efea:	0f 85 b4 01 00 00    	jne    f011f1a4 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011eff0:	8b 0d 68 2d 6c f0    	mov    0xf06c2d68,%ecx
f011eff6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011effb:	f7 e9                	imul   %ecx
f011effd:	c1 fa 05             	sar    $0x5,%edx
f011f000:	89 c8                	mov    %ecx,%eax
f011f002:	c1 f8 1f             	sar    $0x1f,%eax
f011f005:	29 c2                	sub    %eax,%edx
f011f007:	89 d0                	mov    %edx,%eax
f011f009:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f00c:	8b 0d 68 2d 6c f0    	mov    0xf06c2d68,%ecx
f011f012:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f017:	f7 e9                	imul   %ecx
f011f019:	c1 fa 05             	sar    $0x5,%edx
f011f01c:	89 c8                	mov    %ecx,%eax
f011f01e:	c1 f8 1f             	sar    $0x1f,%eax
f011f021:	29 c2                	sub    %eax,%edx
f011f023:	89 d0                	mov    %edx,%eax
f011f025:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f028:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f02b:	89 d0                	mov    %edx,%eax
f011f02d:	c1 e0 02             	shl    $0x2,%eax
f011f030:	01 d0                	add    %edx,%eax
f011f032:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f039:	01 d0                	add    %edx,%eax
f011f03b:	c1 e0 02             	shl    $0x2,%eax
f011f03e:	29 c1                	sub    %eax,%ecx
f011f040:	89 c8                	mov    %ecx,%eax
f011f042:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f045:	8b 0d b4 17 6c f0    	mov    0xf06c17b4,%ecx
f011f04b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f050:	f7 e9                	imul   %ecx
f011f052:	c1 fa 05             	sar    $0x5,%edx
f011f055:	89 c8                	mov    %ecx,%eax
f011f057:	c1 f8 1f             	sar    $0x1f,%eax
f011f05a:	29 c2                	sub    %eax,%edx
f011f05c:	89 d0                	mov    %edx,%eax
f011f05e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f061:	8b 0d b4 17 6c f0    	mov    0xf06c17b4,%ecx
f011f067:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f06c:	f7 e9                	imul   %ecx
f011f06e:	c1 fa 05             	sar    $0x5,%edx
f011f071:	89 c8                	mov    %ecx,%eax
f011f073:	c1 f8 1f             	sar    $0x1f,%eax
f011f076:	29 c2                	sub    %eax,%edx
f011f078:	89 d0                	mov    %edx,%eax
f011f07a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f07d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f080:	89 d0                	mov    %edx,%eax
f011f082:	c1 e0 02             	shl    $0x2,%eax
f011f085:	01 d0                	add    %edx,%eax
f011f087:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f08e:	01 d0                	add    %edx,%eax
f011f090:	c1 e0 02             	shl    $0x2,%eax
f011f093:	29 c1                	sub    %eax,%ecx
f011f095:	89 c8                	mov    %ecx,%eax
f011f097:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f09a:	8b 15 d0 1a 6c f0    	mov    0xf06c1ad0,%edx
f011f0a0:	a1 20 17 6c f0       	mov    0xf06c1720,%eax
f011f0a5:	39 c2                	cmp    %eax,%edx
f011f0a7:	0f 85 ed 00 00 00    	jne    f011f19a <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f0ad:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f0b2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0b5:	7e 5b                	jle    f011f112 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f0b7:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f0bc:	83 ec 08             	sub    $0x8,%esp
f011f0bf:	ff 75 e0             	pushl  -0x20(%ebp)
f011f0c2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f0c5:	ff 75 e8             	pushl  -0x18(%ebp)
f011f0c8:	ff 75 ec             	pushl  -0x14(%ebp)
f011f0cb:	50                   	push   %eax
f011f0cc:	68 48 0d 13 f0       	push   $0xf0130d48
f011f0d1:	e8 b5 1e fe ff       	call   f0100f8b <cprintf>
f011f0d6:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f0d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f0dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0df:	0f 8f b5 00 00 00    	jg     f011f19a <chk2+0x356>
f011f0e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f0e8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0eb:	75 0c                	jne    f011f0f9 <chk2+0x2b5>
f011f0ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f0f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f0f3:	0f 8d a1 00 00 00    	jge    f011f19a <chk2+0x356>
f011f0f9:	68 90 0d 13 f0       	push   $0xf0130d90
f011f0fe:	68 73 09 13 f0       	push   $0xf0130973
f011f103:	68 4a 02 00 00       	push   $0x24a
f011f108:	68 bb 09 13 f0       	push   $0xf01309bb
f011f10d:	e8 b7 12 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f112:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f117:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f11a:	7d 53                	jge    f011f16f <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f11c:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f121:	83 ec 08             	sub    $0x8,%esp
f011f124:	ff 75 e0             	pushl  -0x20(%ebp)
f011f127:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f12a:	ff 75 e8             	pushl  -0x18(%ebp)
f011f12d:	ff 75 ec             	pushl  -0x14(%ebp)
f011f130:	50                   	push   %eax
f011f131:	68 d0 0d 13 f0       	push   $0xf0130dd0
f011f136:	e8 50 1e fe ff       	call   f0100f8b <cprintf>
f011f13b:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f13e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f141:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f144:	7c 54                	jl     f011f19a <chk2+0x356>
f011f146:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f149:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f14c:	75 08                	jne    f011f156 <chk2+0x312>
f011f14e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f151:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f154:	7e 44                	jle    f011f19a <chk2+0x356>
f011f156:	68 18 0e 13 f0       	push   $0xf0130e18
f011f15b:	68 73 09 13 f0       	push   $0xf0130973
f011f160:	68 50 02 00 00       	push   $0x250
f011f165:	68 bb 09 13 f0       	push   $0xf01309bb
f011f16a:	e8 5a 12 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f16f:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f174:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f177:	75 21                	jne    f011f19a <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f179:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f17c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f17f:	74 19                	je     f011f19a <chk2+0x356>
f011f181:	68 58 0e 13 f0       	push   $0xf0130e58
f011f186:	68 73 09 13 f0       	push   $0xf0130973
f011f18b:	68 54 02 00 00       	push   $0x254
f011f190:	68 bb 09 13 f0       	push   $0xf01309bb
f011f195:	e8 2f 12 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f19a:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011f19f:	a3 68 2d 6c f0       	mov    %eax,0xf06c2d68
			}
		}
		__pnexit = __nnexit;
f011f1a4:	a1 d0 1a 6c f0       	mov    0xf06c1ad0,%eax
f011f1a9:	a3 20 17 6c f0       	mov    %eax,0xf06c1720
f011f1ae:	eb 01                	jmp    f011f1b1 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f1b0:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f1b1:	c9                   	leave  
f011f1b2:	c3                   	ret    

f011f1b3 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f1b3:	55                   	push   %ebp
f011f1b4:	89 e5                	mov    %esp,%ebp
f011f1b6:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f1b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f1c0:	eb 40                	jmp    f011f202 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f1c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f1c5:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f1cb:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f1d0:	83 ec 08             	sub    $0x8,%esp
f011f1d3:	52                   	push   %edx
f011f1d4:	50                   	push   %eax
f011f1d5:	e8 af 01 00 00       	call   f011f389 <check_va2pa>
f011f1da:	83 c4 10             	add    $0x10,%esp
f011f1dd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f1e0:	74 19                	je     f011f1fb <check_boot_pgdir+0x48>
f011f1e2:	68 6c 0e 13 f0       	push   $0xf0130e6c
f011f1e7:	68 73 09 13 f0       	push   $0xf0130973
f011f1ec:	68 9b 02 00 00       	push   $0x29b
f011f1f1:	68 bb 09 13 f0       	push   $0xf01309bb
f011f1f6:	e8 3e 11 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f1fb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f202:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f205:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f20b:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f011f210:	39 c2                	cmp    %eax,%edx
f011f212:	72 ae                	jb     f011f1c2 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f214:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f21b:	e9 81 00 00 00       	jmp    f011f2a1 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f220:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f223:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f228:	85 c0                	test   %eax,%eax
f011f22a:	74 6d                	je     f011f299 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f22c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f22f:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f235:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f23a:	83 ec 08             	sub    $0x8,%esp
f011f23d:	52                   	push   %edx
f011f23e:	50                   	push   %eax
f011f23f:	e8 45 01 00 00       	call   f011f389 <check_va2pa>
f011f244:	83 c4 10             	add    $0x10,%esp
f011f247:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f011f24e:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f255:	77 17                	ja     f011f26e <check_boot_pgdir+0xbb>
f011f257:	ff 75 f0             	pushl  -0x10(%ebp)
f011f25a:	68 a4 0e 13 f0       	push   $0xf0130ea4
f011f25f:	68 a9 02 00 00       	push   $0x2a9
f011f264:	68 bb 09 13 f0       	push   $0xf01309bb
f011f269:	e8 cb 10 fe ff       	call   f0100339 <_panic>
f011f26e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f271:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f277:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f27a:	01 ca                	add    %ecx,%edx
f011f27c:	39 d0                	cmp    %edx,%eax
f011f27e:	74 1a                	je     f011f29a <check_boot_pgdir+0xe7>
f011f280:	68 d8 0e 13 f0       	push   $0xf0130ed8
f011f285:	68 73 09 13 f0       	push   $0xf0130973
f011f28a:	68 a9 02 00 00       	push   $0x2a9
f011f28f:	68 bb 09 13 f0       	push   $0xf01309bb
f011f294:	e8 a0 10 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f299:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f29a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f2a1:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f2a8:	0f 86 72 ff ff ff    	jbe    f011f220 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f2ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f2b5:	e9 af 00 00 00       	jmp    f011f369 <check_boot_pgdir+0x1b6>
		switch (i) {
f011f2ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f2bd:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f2c2:	74 11                	je     f011f2d5 <check_boot_pgdir+0x122>
f011f2c4:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f2c9:	72 36                	jb     f011f301 <check_boot_pgdir+0x14e>
f011f2cb:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f2d0:	83 f8 02             	cmp    $0x2,%eax
f011f2d3:	77 2c                	ja     f011f301 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f2d5:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f2da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f2dd:	c1 e2 02             	shl    $0x2,%edx
f011f2e0:	01 d0                	add    %edx,%eax
f011f2e2:	8b 00                	mov    (%eax),%eax
f011f2e4:	85 c0                	test   %eax,%eax
f011f2e6:	75 7a                	jne    f011f362 <check_boot_pgdir+0x1af>
f011f2e8:	68 5e 0f 13 f0       	push   $0xf0130f5e
f011f2ed:	68 73 09 13 f0       	push   $0xf0130973
f011f2f2:	68 b4 02 00 00       	push   $0x2b4
f011f2f7:	68 bb 09 13 f0       	push   $0xf01309bb
f011f2fc:	e8 38 10 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f301:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f308:	76 2c                	jbe    f011f336 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f30a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f30f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f312:	c1 e2 02             	shl    $0x2,%edx
f011f315:	01 d0                	add    %edx,%eax
f011f317:	8b 00                	mov    (%eax),%eax
f011f319:	85 c0                	test   %eax,%eax
f011f31b:	75 48                	jne    f011f365 <check_boot_pgdir+0x1b2>
f011f31d:	68 5e 0f 13 f0       	push   $0xf0130f5e
f011f322:	68 73 09 13 f0       	push   $0xf0130973
f011f327:	68 b8 02 00 00       	push   $0x2b8
f011f32c:	68 bb 09 13 f0       	push   $0xf01309bb
f011f331:	e8 03 10 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f336:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f33b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f33e:	c1 e2 02             	shl    $0x2,%edx
f011f341:	01 d0                	add    %edx,%eax
f011f343:	8b 00                	mov    (%eax),%eax
f011f345:	85 c0                	test   %eax,%eax
f011f347:	74 1c                	je     f011f365 <check_boot_pgdir+0x1b2>
f011f349:	68 74 0f 13 f0       	push   $0xf0130f74
f011f34e:	68 73 09 13 f0       	push   $0xf0130973
f011f353:	68 ba 02 00 00       	push   $0x2ba
f011f358:	68 bb 09 13 f0       	push   $0xf01309bb
f011f35d:	e8 d7 0f fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f362:	90                   	nop
f011f363:	eb 01                	jmp    f011f366 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f365:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f366:	ff 45 f4             	incl   -0xc(%ebp)
f011f369:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f370:	0f 86 44 ff ff ff    	jbe    f011f2ba <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f376:	83 ec 0c             	sub    $0xc,%esp
f011f379:	68 90 0f 13 f0       	push   $0xf0130f90
f011f37e:	e8 08 1c fe ff       	call   f0100f8b <cprintf>
f011f383:	83 c4 10             	add    $0x10,%esp
}
f011f386:	90                   	nop
f011f387:	c9                   	leave  
f011f388:	c3                   	ret    

f011f389 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f389:	55                   	push   %ebp
f011f38a:	89 e5                	mov    %esp,%ebp
f011f38c:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f38f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f392:	c1 e8 16             	shr    $0x16,%eax
f011f395:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f39c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f39f:	01 d0                	add    %edx,%eax
f011f3a1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f3a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f3a7:	8b 00                	mov    (%eax),%eax
f011f3a9:	83 e0 01             	and    $0x1,%eax
f011f3ac:	85 c0                	test   %eax,%eax
f011f3ae:	75 0a                	jne    f011f3ba <check_va2pa+0x31>
		return ~0;
f011f3b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f3b5:	e9 87 00 00 00       	jmp    f011f441 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f3ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f3bd:	8b 00                	mov    (%eax),%eax
f011f3bf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f3c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f3c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f3ca:	c1 e8 0c             	shr    $0xc,%eax
f011f3cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f3d0:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011f3d5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f3d8:	72 17                	jb     f011f3f1 <check_va2pa+0x68>
f011f3da:	ff 75 f0             	pushl  -0x10(%ebp)
f011f3dd:	68 b4 0f 13 f0       	push   $0xf0130fb4
f011f3e2:	68 d0 02 00 00       	push   $0x2d0
f011f3e7:	68 bb 09 13 f0       	push   $0xf01309bb
f011f3ec:	e8 48 0f fe ff       	call   f0100339 <_panic>
f011f3f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f3f4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f3f9:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f3fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3ff:	c1 e8 0c             	shr    $0xc,%eax
f011f402:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f407:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f40e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f411:	01 d0                	add    %edx,%eax
f011f413:	8b 00                	mov    (%eax),%eax
f011f415:	83 e0 01             	and    $0x1,%eax
f011f418:	85 c0                	test   %eax,%eax
f011f41a:	75 07                	jne    f011f423 <check_va2pa+0x9a>
		return ~0;
f011f41c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f421:	eb 1e                	jmp    f011f441 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f423:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f426:	c1 e8 0c             	shr    $0xc,%eax
f011f429:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f42e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f435:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f438:	01 d0                	add    %edx,%eax
f011f43a:	8b 00                	mov    (%eax),%eax
f011f43c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f441:	c9                   	leave  
f011f442:	c3                   	ret    

f011f443 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f443:	55                   	push   %ebp
f011f444:	89 e5                	mov    %esp,%ebp
f011f446:	53                   	push   %ebx
f011f447:	83 ec 14             	sub    $0x14,%esp
f011f44a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f44d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f450:	8b 45 14             	mov    0x14(%ebp),%eax
f011f453:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f456:	8b 45 18             	mov    0x18(%ebp),%eax
f011f459:	ba 00 00 00 00       	mov    $0x0,%edx
f011f45e:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f461:	77 55                	ja     f011f4b8 <printnum+0x75>
f011f463:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f466:	72 05                	jb     f011f46d <printnum+0x2a>
f011f468:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f46b:	77 4b                	ja     f011f4b8 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f46d:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f470:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f473:	8b 45 18             	mov    0x18(%ebp),%eax
f011f476:	ba 00 00 00 00       	mov    $0x0,%edx
f011f47b:	52                   	push   %edx
f011f47c:	50                   	push   %eax
f011f47d:	ff 75 f4             	pushl  -0xc(%ebp)
f011f480:	ff 75 f0             	pushl  -0x10(%ebp)
f011f483:	e8 98 2e 00 00       	call   f0122320 <__udivdi3>
f011f488:	83 c4 10             	add    $0x10,%esp
f011f48b:	83 ec 04             	sub    $0x4,%esp
f011f48e:	ff 75 20             	pushl  0x20(%ebp)
f011f491:	53                   	push   %ebx
f011f492:	ff 75 18             	pushl  0x18(%ebp)
f011f495:	52                   	push   %edx
f011f496:	50                   	push   %eax
f011f497:	ff 75 0c             	pushl  0xc(%ebp)
f011f49a:	ff 75 08             	pushl  0x8(%ebp)
f011f49d:	e8 a1 ff ff ff       	call   f011f443 <printnum>
f011f4a2:	83 c4 20             	add    $0x20,%esp
f011f4a5:	eb 1a                	jmp    f011f4c1 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f4a7:	83 ec 08             	sub    $0x8,%esp
f011f4aa:	ff 75 0c             	pushl  0xc(%ebp)
f011f4ad:	ff 75 20             	pushl  0x20(%ebp)
f011f4b0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4b3:	ff d0                	call   *%eax
f011f4b5:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f4b8:	ff 4d 1c             	decl   0x1c(%ebp)
f011f4bb:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f4bf:	7f e6                	jg     f011f4a7 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f4c1:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f4c4:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f4c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f4cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4cf:	53                   	push   %ebx
f011f4d0:	51                   	push   %ecx
f011f4d1:	52                   	push   %edx
f011f4d2:	50                   	push   %eax
f011f4d3:	e8 58 2f 00 00       	call   f0122430 <__umoddi3>
f011f4d8:	83 c4 10             	add    $0x10,%esp
f011f4db:	05 14 12 13 f0       	add    $0xf0131214,%eax
f011f4e0:	8a 00                	mov    (%eax),%al
f011f4e2:	0f be c0             	movsbl %al,%eax
f011f4e5:	83 ec 08             	sub    $0x8,%esp
f011f4e8:	ff 75 0c             	pushl  0xc(%ebp)
f011f4eb:	50                   	push   %eax
f011f4ec:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4ef:	ff d0                	call   *%eax
f011f4f1:	83 c4 10             	add    $0x10,%esp
}
f011f4f4:	90                   	nop
f011f4f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f4f8:	c9                   	leave  
f011f4f9:	c3                   	ret    

f011f4fa <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f4fa:	55                   	push   %ebp
f011f4fb:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f4fd:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f501:	7e 1c                	jle    f011f51f <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f503:	8b 45 08             	mov    0x8(%ebp),%eax
f011f506:	8b 00                	mov    (%eax),%eax
f011f508:	8d 50 08             	lea    0x8(%eax),%edx
f011f50b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f50e:	89 10                	mov    %edx,(%eax)
f011f510:	8b 45 08             	mov    0x8(%ebp),%eax
f011f513:	8b 00                	mov    (%eax),%eax
f011f515:	83 e8 08             	sub    $0x8,%eax
f011f518:	8b 50 04             	mov    0x4(%eax),%edx
f011f51b:	8b 00                	mov    (%eax),%eax
f011f51d:	eb 40                	jmp    f011f55f <getuint+0x65>
	else if (lflag)
f011f51f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f523:	74 1e                	je     f011f543 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f525:	8b 45 08             	mov    0x8(%ebp),%eax
f011f528:	8b 00                	mov    (%eax),%eax
f011f52a:	8d 50 04             	lea    0x4(%eax),%edx
f011f52d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f530:	89 10                	mov    %edx,(%eax)
f011f532:	8b 45 08             	mov    0x8(%ebp),%eax
f011f535:	8b 00                	mov    (%eax),%eax
f011f537:	83 e8 04             	sub    $0x4,%eax
f011f53a:	8b 00                	mov    (%eax),%eax
f011f53c:	ba 00 00 00 00       	mov    $0x0,%edx
f011f541:	eb 1c                	jmp    f011f55f <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f543:	8b 45 08             	mov    0x8(%ebp),%eax
f011f546:	8b 00                	mov    (%eax),%eax
f011f548:	8d 50 04             	lea    0x4(%eax),%edx
f011f54b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f54e:	89 10                	mov    %edx,(%eax)
f011f550:	8b 45 08             	mov    0x8(%ebp),%eax
f011f553:	8b 00                	mov    (%eax),%eax
f011f555:	83 e8 04             	sub    $0x4,%eax
f011f558:	8b 00                	mov    (%eax),%eax
f011f55a:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f55f:	5d                   	pop    %ebp
f011f560:	c3                   	ret    

f011f561 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f561:	55                   	push   %ebp
f011f562:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f564:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f568:	7e 1c                	jle    f011f586 <getint+0x25>
		return va_arg(*ap, long long);
f011f56a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f56d:	8b 00                	mov    (%eax),%eax
f011f56f:	8d 50 08             	lea    0x8(%eax),%edx
f011f572:	8b 45 08             	mov    0x8(%ebp),%eax
f011f575:	89 10                	mov    %edx,(%eax)
f011f577:	8b 45 08             	mov    0x8(%ebp),%eax
f011f57a:	8b 00                	mov    (%eax),%eax
f011f57c:	83 e8 08             	sub    $0x8,%eax
f011f57f:	8b 50 04             	mov    0x4(%eax),%edx
f011f582:	8b 00                	mov    (%eax),%eax
f011f584:	eb 38                	jmp    f011f5be <getint+0x5d>
	else if (lflag)
f011f586:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f58a:	74 1a                	je     f011f5a6 <getint+0x45>
		return va_arg(*ap, long);
f011f58c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f58f:	8b 00                	mov    (%eax),%eax
f011f591:	8d 50 04             	lea    0x4(%eax),%edx
f011f594:	8b 45 08             	mov    0x8(%ebp),%eax
f011f597:	89 10                	mov    %edx,(%eax)
f011f599:	8b 45 08             	mov    0x8(%ebp),%eax
f011f59c:	8b 00                	mov    (%eax),%eax
f011f59e:	83 e8 04             	sub    $0x4,%eax
f011f5a1:	8b 00                	mov    (%eax),%eax
f011f5a3:	99                   	cltd   
f011f5a4:	eb 18                	jmp    f011f5be <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f5a6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5a9:	8b 00                	mov    (%eax),%eax
f011f5ab:	8d 50 04             	lea    0x4(%eax),%edx
f011f5ae:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5b1:	89 10                	mov    %edx,(%eax)
f011f5b3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5b6:	8b 00                	mov    (%eax),%eax
f011f5b8:	83 e8 04             	sub    $0x4,%eax
f011f5bb:	8b 00                	mov    (%eax),%eax
f011f5bd:	99                   	cltd   
}
f011f5be:	5d                   	pop    %ebp
f011f5bf:	c3                   	ret    

f011f5c0 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f5c0:	55                   	push   %ebp
f011f5c1:	89 e5                	mov    %esp,%ebp
f011f5c3:	56                   	push   %esi
f011f5c4:	53                   	push   %ebx
f011f5c5:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f5c8:	eb 17                	jmp    f011f5e1 <vprintfmt+0x21>
			if (ch == '\0')
f011f5ca:	85 db                	test   %ebx,%ebx
f011f5cc:	0f 84 c1 03 00 00    	je     f011f993 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f5d2:	83 ec 08             	sub    $0x8,%esp
f011f5d5:	ff 75 0c             	pushl  0xc(%ebp)
f011f5d8:	53                   	push   %ebx
f011f5d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5dc:	ff d0                	call   *%eax
f011f5de:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f5e1:	8b 45 10             	mov    0x10(%ebp),%eax
f011f5e4:	8d 50 01             	lea    0x1(%eax),%edx
f011f5e7:	89 55 10             	mov    %edx,0x10(%ebp)
f011f5ea:	8a 00                	mov    (%eax),%al
f011f5ec:	0f b6 d8             	movzbl %al,%ebx
f011f5ef:	83 fb 25             	cmp    $0x25,%ebx
f011f5f2:	75 d6                	jne    f011f5ca <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f5f4:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f5f8:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f5ff:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f606:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f60d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f614:	8b 45 10             	mov    0x10(%ebp),%eax
f011f617:	8d 50 01             	lea    0x1(%eax),%edx
f011f61a:	89 55 10             	mov    %edx,0x10(%ebp)
f011f61d:	8a 00                	mov    (%eax),%al
f011f61f:	0f b6 d8             	movzbl %al,%ebx
f011f622:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f625:	83 f8 5b             	cmp    $0x5b,%eax
f011f628:	0f 87 3d 03 00 00    	ja     f011f96b <vprintfmt+0x3ab>
f011f62e:	8b 04 85 38 12 13 f0 	mov    -0xfecedc8(,%eax,4),%eax
f011f635:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f637:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f63b:	eb d7                	jmp    f011f614 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f63d:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f641:	eb d1                	jmp    f011f614 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f643:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f64a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f64d:	89 d0                	mov    %edx,%eax
f011f64f:	c1 e0 02             	shl    $0x2,%eax
f011f652:	01 d0                	add    %edx,%eax
f011f654:	01 c0                	add    %eax,%eax
f011f656:	01 d8                	add    %ebx,%eax
f011f658:	83 e8 30             	sub    $0x30,%eax
f011f65b:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f65e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f661:	8a 00                	mov    (%eax),%al
f011f663:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f666:	83 fb 2f             	cmp    $0x2f,%ebx
f011f669:	7e 3e                	jle    f011f6a9 <vprintfmt+0xe9>
f011f66b:	83 fb 39             	cmp    $0x39,%ebx
f011f66e:	7f 39                	jg     f011f6a9 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f670:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f673:	eb d5                	jmp    f011f64a <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f675:	8b 45 14             	mov    0x14(%ebp),%eax
f011f678:	83 c0 04             	add    $0x4,%eax
f011f67b:	89 45 14             	mov    %eax,0x14(%ebp)
f011f67e:	8b 45 14             	mov    0x14(%ebp),%eax
f011f681:	83 e8 04             	sub    $0x4,%eax
f011f684:	8b 00                	mov    (%eax),%eax
f011f686:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f689:	eb 1f                	jmp    f011f6aa <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f68b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f68f:	79 83                	jns    f011f614 <vprintfmt+0x54>
				width = 0;
f011f691:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f698:	e9 77 ff ff ff       	jmp    f011f614 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f69d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f6a4:	e9 6b ff ff ff       	jmp    f011f614 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f6a9:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f6aa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f6ae:	0f 89 60 ff ff ff    	jns    f011f614 <vprintfmt+0x54>
				width = precision, precision = -1;
f011f6b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f6b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f6ba:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f6c1:	e9 4e ff ff ff       	jmp    f011f614 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f6c6:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f6c9:	e9 46 ff ff ff       	jmp    f011f614 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f6ce:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6d1:	83 c0 04             	add    $0x4,%eax
f011f6d4:	89 45 14             	mov    %eax,0x14(%ebp)
f011f6d7:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6da:	83 e8 04             	sub    $0x4,%eax
f011f6dd:	8b 00                	mov    (%eax),%eax
f011f6df:	83 ec 08             	sub    $0x8,%esp
f011f6e2:	ff 75 0c             	pushl  0xc(%ebp)
f011f6e5:	50                   	push   %eax
f011f6e6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6e9:	ff d0                	call   *%eax
f011f6eb:	83 c4 10             	add    $0x10,%esp
			break;
f011f6ee:	e9 9b 02 00 00       	jmp    f011f98e <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f6f3:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6f6:	83 c0 04             	add    $0x4,%eax
f011f6f9:	89 45 14             	mov    %eax,0x14(%ebp)
f011f6fc:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6ff:	83 e8 04             	sub    $0x4,%eax
f011f702:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f704:	85 db                	test   %ebx,%ebx
f011f706:	79 02                	jns    f011f70a <vprintfmt+0x14a>
				err = -err;
f011f708:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f70a:	83 fb 64             	cmp    $0x64,%ebx
f011f70d:	7f 0b                	jg     f011f71a <vprintfmt+0x15a>
f011f70f:	8b 34 9d 80 10 13 f0 	mov    -0xfecef80(,%ebx,4),%esi
f011f716:	85 f6                	test   %esi,%esi
f011f718:	75 19                	jne    f011f733 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f71a:	53                   	push   %ebx
f011f71b:	68 25 12 13 f0       	push   $0xf0131225
f011f720:	ff 75 0c             	pushl  0xc(%ebp)
f011f723:	ff 75 08             	pushl  0x8(%ebp)
f011f726:	e8 70 02 00 00       	call   f011f99b <printfmt>
f011f72b:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f72e:	e9 5b 02 00 00       	jmp    f011f98e <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f733:	56                   	push   %esi
f011f734:	68 2e 12 13 f0       	push   $0xf013122e
f011f739:	ff 75 0c             	pushl  0xc(%ebp)
f011f73c:	ff 75 08             	pushl  0x8(%ebp)
f011f73f:	e8 57 02 00 00       	call   f011f99b <printfmt>
f011f744:	83 c4 10             	add    $0x10,%esp
			break;
f011f747:	e9 42 02 00 00       	jmp    f011f98e <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f74c:	8b 45 14             	mov    0x14(%ebp),%eax
f011f74f:	83 c0 04             	add    $0x4,%eax
f011f752:	89 45 14             	mov    %eax,0x14(%ebp)
f011f755:	8b 45 14             	mov    0x14(%ebp),%eax
f011f758:	83 e8 04             	sub    $0x4,%eax
f011f75b:	8b 30                	mov    (%eax),%esi
f011f75d:	85 f6                	test   %esi,%esi
f011f75f:	75 05                	jne    f011f766 <vprintfmt+0x1a6>
				p = "(null)";
f011f761:	be 31 12 13 f0       	mov    $0xf0131231,%esi
			if (width > 0 && padc != '-')
f011f766:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f76a:	7e 6d                	jle    f011f7d9 <vprintfmt+0x219>
f011f76c:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f770:	74 67                	je     f011f7d9 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f772:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f775:	83 ec 08             	sub    $0x8,%esp
f011f778:	50                   	push   %eax
f011f779:	56                   	push   %esi
f011f77a:	e8 26 05 00 00       	call   f011fca5 <strnlen>
f011f77f:	83 c4 10             	add    $0x10,%esp
f011f782:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f785:	eb 16                	jmp    f011f79d <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f787:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f78b:	83 ec 08             	sub    $0x8,%esp
f011f78e:	ff 75 0c             	pushl  0xc(%ebp)
f011f791:	50                   	push   %eax
f011f792:	8b 45 08             	mov    0x8(%ebp),%eax
f011f795:	ff d0                	call   *%eax
f011f797:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f79a:	ff 4d e4             	decl   -0x1c(%ebp)
f011f79d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f7a1:	7f e4                	jg     f011f787 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f7a3:	eb 34                	jmp    f011f7d9 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f7a5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f7a9:	74 1c                	je     f011f7c7 <vprintfmt+0x207>
f011f7ab:	83 fb 1f             	cmp    $0x1f,%ebx
f011f7ae:	7e 05                	jle    f011f7b5 <vprintfmt+0x1f5>
f011f7b0:	83 fb 7e             	cmp    $0x7e,%ebx
f011f7b3:	7e 12                	jle    f011f7c7 <vprintfmt+0x207>
					putch('?', putdat);
f011f7b5:	83 ec 08             	sub    $0x8,%esp
f011f7b8:	ff 75 0c             	pushl  0xc(%ebp)
f011f7bb:	6a 3f                	push   $0x3f
f011f7bd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7c0:	ff d0                	call   *%eax
f011f7c2:	83 c4 10             	add    $0x10,%esp
f011f7c5:	eb 0f                	jmp    f011f7d6 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f7c7:	83 ec 08             	sub    $0x8,%esp
f011f7ca:	ff 75 0c             	pushl  0xc(%ebp)
f011f7cd:	53                   	push   %ebx
f011f7ce:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7d1:	ff d0                	call   *%eax
f011f7d3:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f7d6:	ff 4d e4             	decl   -0x1c(%ebp)
f011f7d9:	89 f0                	mov    %esi,%eax
f011f7db:	8d 70 01             	lea    0x1(%eax),%esi
f011f7de:	8a 00                	mov    (%eax),%al
f011f7e0:	0f be d8             	movsbl %al,%ebx
f011f7e3:	85 db                	test   %ebx,%ebx
f011f7e5:	74 24                	je     f011f80b <vprintfmt+0x24b>
f011f7e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f7eb:	78 b8                	js     f011f7a5 <vprintfmt+0x1e5>
f011f7ed:	ff 4d e0             	decl   -0x20(%ebp)
f011f7f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f7f4:	79 af                	jns    f011f7a5 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f7f6:	eb 13                	jmp    f011f80b <vprintfmt+0x24b>
				putch(' ', putdat);
f011f7f8:	83 ec 08             	sub    $0x8,%esp
f011f7fb:	ff 75 0c             	pushl  0xc(%ebp)
f011f7fe:	6a 20                	push   $0x20
f011f800:	8b 45 08             	mov    0x8(%ebp),%eax
f011f803:	ff d0                	call   *%eax
f011f805:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f808:	ff 4d e4             	decl   -0x1c(%ebp)
f011f80b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f80f:	7f e7                	jg     f011f7f8 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f811:	e9 78 01 00 00       	jmp    f011f98e <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f816:	83 ec 08             	sub    $0x8,%esp
f011f819:	ff 75 e8             	pushl  -0x18(%ebp)
f011f81c:	8d 45 14             	lea    0x14(%ebp),%eax
f011f81f:	50                   	push   %eax
f011f820:	e8 3c fd ff ff       	call   f011f561 <getint>
f011f825:	83 c4 10             	add    $0x10,%esp
f011f828:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f82b:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f82e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f831:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f834:	85 d2                	test   %edx,%edx
f011f836:	79 23                	jns    f011f85b <vprintfmt+0x29b>
				putch('-', putdat);
f011f838:	83 ec 08             	sub    $0x8,%esp
f011f83b:	ff 75 0c             	pushl  0xc(%ebp)
f011f83e:	6a 2d                	push   $0x2d
f011f840:	8b 45 08             	mov    0x8(%ebp),%eax
f011f843:	ff d0                	call   *%eax
f011f845:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f848:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f84b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f84e:	f7 d8                	neg    %eax
f011f850:	83 d2 00             	adc    $0x0,%edx
f011f853:	f7 da                	neg    %edx
f011f855:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f858:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f85b:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f862:	e9 bc 00 00 00       	jmp    f011f923 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f867:	83 ec 08             	sub    $0x8,%esp
f011f86a:	ff 75 e8             	pushl  -0x18(%ebp)
f011f86d:	8d 45 14             	lea    0x14(%ebp),%eax
f011f870:	50                   	push   %eax
f011f871:	e8 84 fc ff ff       	call   f011f4fa <getuint>
f011f876:	83 c4 10             	add    $0x10,%esp
f011f879:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f87c:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f87f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f886:	e9 98 00 00 00       	jmp    f011f923 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f88b:	83 ec 08             	sub    $0x8,%esp
f011f88e:	ff 75 0c             	pushl  0xc(%ebp)
f011f891:	6a 58                	push   $0x58
f011f893:	8b 45 08             	mov    0x8(%ebp),%eax
f011f896:	ff d0                	call   *%eax
f011f898:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f89b:	83 ec 08             	sub    $0x8,%esp
f011f89e:	ff 75 0c             	pushl  0xc(%ebp)
f011f8a1:	6a 58                	push   $0x58
f011f8a3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8a6:	ff d0                	call   *%eax
f011f8a8:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f8ab:	83 ec 08             	sub    $0x8,%esp
f011f8ae:	ff 75 0c             	pushl  0xc(%ebp)
f011f8b1:	6a 58                	push   $0x58
f011f8b3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8b6:	ff d0                	call   *%eax
f011f8b8:	83 c4 10             	add    $0x10,%esp
			break;
f011f8bb:	e9 ce 00 00 00       	jmp    f011f98e <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f8c0:	83 ec 08             	sub    $0x8,%esp
f011f8c3:	ff 75 0c             	pushl  0xc(%ebp)
f011f8c6:	6a 30                	push   $0x30
f011f8c8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8cb:	ff d0                	call   *%eax
f011f8cd:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f8d0:	83 ec 08             	sub    $0x8,%esp
f011f8d3:	ff 75 0c             	pushl  0xc(%ebp)
f011f8d6:	6a 78                	push   $0x78
f011f8d8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8db:	ff d0                	call   *%eax
f011f8dd:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f8e0:	8b 45 14             	mov    0x14(%ebp),%eax
f011f8e3:	83 c0 04             	add    $0x4,%eax
f011f8e6:	89 45 14             	mov    %eax,0x14(%ebp)
f011f8e9:	8b 45 14             	mov    0x14(%ebp),%eax
f011f8ec:	83 e8 04             	sub    $0x4,%eax
f011f8ef:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f8f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f8f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f8fb:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f902:	eb 1f                	jmp    f011f923 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f904:	83 ec 08             	sub    $0x8,%esp
f011f907:	ff 75 e8             	pushl  -0x18(%ebp)
f011f90a:	8d 45 14             	lea    0x14(%ebp),%eax
f011f90d:	50                   	push   %eax
f011f90e:	e8 e7 fb ff ff       	call   f011f4fa <getuint>
f011f913:	83 c4 10             	add    $0x10,%esp
f011f916:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f919:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f91c:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f923:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f92a:	83 ec 04             	sub    $0x4,%esp
f011f92d:	52                   	push   %edx
f011f92e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f931:	50                   	push   %eax
f011f932:	ff 75 f4             	pushl  -0xc(%ebp)
f011f935:	ff 75 f0             	pushl  -0x10(%ebp)
f011f938:	ff 75 0c             	pushl  0xc(%ebp)
f011f93b:	ff 75 08             	pushl  0x8(%ebp)
f011f93e:	e8 00 fb ff ff       	call   f011f443 <printnum>
f011f943:	83 c4 20             	add    $0x20,%esp
			break;
f011f946:	eb 46                	jmp    f011f98e <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f948:	83 ec 08             	sub    $0x8,%esp
f011f94b:	ff 75 0c             	pushl  0xc(%ebp)
f011f94e:	53                   	push   %ebx
f011f94f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f952:	ff d0                	call   *%eax
f011f954:	83 c4 10             	add    $0x10,%esp
			break;
f011f957:	eb 35                	jmp    f011f98e <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f959:	c6 05 c0 15 6c f0 00 	movb   $0x0,0xf06c15c0
			break;
f011f960:	eb 2c                	jmp    f011f98e <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f962:	c6 05 c0 15 6c f0 01 	movb   $0x1,0xf06c15c0
			break;
f011f969:	eb 23                	jmp    f011f98e <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f96b:	83 ec 08             	sub    $0x8,%esp
f011f96e:	ff 75 0c             	pushl  0xc(%ebp)
f011f971:	6a 25                	push   $0x25
f011f973:	8b 45 08             	mov    0x8(%ebp),%eax
f011f976:	ff d0                	call   *%eax
f011f978:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f97b:	ff 4d 10             	decl   0x10(%ebp)
f011f97e:	eb 03                	jmp    f011f983 <vprintfmt+0x3c3>
f011f980:	ff 4d 10             	decl   0x10(%ebp)
f011f983:	8b 45 10             	mov    0x10(%ebp),%eax
f011f986:	48                   	dec    %eax
f011f987:	8a 00                	mov    (%eax),%al
f011f989:	3c 25                	cmp    $0x25,%al
f011f98b:	75 f3                	jne    f011f980 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f98d:	90                   	nop
		}
	}
f011f98e:	e9 35 fc ff ff       	jmp    f011f5c8 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f993:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f994:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f997:	5b                   	pop    %ebx
f011f998:	5e                   	pop    %esi
f011f999:	5d                   	pop    %ebp
f011f99a:	c3                   	ret    

f011f99b <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f99b:	55                   	push   %ebp
f011f99c:	89 e5                	mov    %esp,%ebp
f011f99e:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f9a1:	8d 45 10             	lea    0x10(%ebp),%eax
f011f9a4:	83 c0 04             	add    $0x4,%eax
f011f9a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f9aa:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9ad:	ff 75 f4             	pushl  -0xc(%ebp)
f011f9b0:	50                   	push   %eax
f011f9b1:	ff 75 0c             	pushl  0xc(%ebp)
f011f9b4:	ff 75 08             	pushl  0x8(%ebp)
f011f9b7:	e8 04 fc ff ff       	call   f011f5c0 <vprintfmt>
f011f9bc:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f9bf:	90                   	nop
f011f9c0:	c9                   	leave  
f011f9c1:	c3                   	ret    

f011f9c2 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f9c2:	55                   	push   %ebp
f011f9c3:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f9c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9c8:	8b 40 08             	mov    0x8(%eax),%eax
f011f9cb:	8d 50 01             	lea    0x1(%eax),%edx
f011f9ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9d1:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f9d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9d7:	8b 10                	mov    (%eax),%edx
f011f9d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9dc:	8b 40 04             	mov    0x4(%eax),%eax
f011f9df:	39 c2                	cmp    %eax,%edx
f011f9e1:	73 12                	jae    f011f9f5 <sprintputch+0x33>
		*b->buf++ = ch;
f011f9e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9e6:	8b 00                	mov    (%eax),%eax
f011f9e8:	8d 48 01             	lea    0x1(%eax),%ecx
f011f9eb:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f9ee:	89 0a                	mov    %ecx,(%edx)
f011f9f0:	8b 55 08             	mov    0x8(%ebp),%edx
f011f9f3:	88 10                	mov    %dl,(%eax)
}
f011f9f5:	90                   	nop
f011f9f6:	5d                   	pop    %ebp
f011f9f7:	c3                   	ret    

f011f9f8 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f9f8:	55                   	push   %ebp
f011f9f9:	89 e5                	mov    %esp,%ebp
f011f9fb:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f9fe:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa01:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fa04:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa07:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fa0a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa0d:	01 d0                	add    %edx,%eax
f011fa0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fa12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011fa19:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa1d:	74 06                	je     f011fa25 <vsnprintf+0x2d>
f011fa1f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fa23:	7f 07                	jg     f011fa2c <vsnprintf+0x34>
		return -E_INVAL;
f011fa25:	b8 03 00 00 00       	mov    $0x3,%eax
f011fa2a:	eb 20                	jmp    f011fa4c <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011fa2c:	ff 75 14             	pushl  0x14(%ebp)
f011fa2f:	ff 75 10             	pushl  0x10(%ebp)
f011fa32:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011fa35:	50                   	push   %eax
f011fa36:	68 c2 f9 11 f0       	push   $0xf011f9c2
f011fa3b:	e8 80 fb ff ff       	call   f011f5c0 <vprintfmt>
f011fa40:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011fa43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fa46:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011fa49:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fa4c:	c9                   	leave  
f011fa4d:	c3                   	ret    

f011fa4e <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011fa4e:	55                   	push   %ebp
f011fa4f:	89 e5                	mov    %esp,%ebp
f011fa51:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011fa54:	8d 45 10             	lea    0x10(%ebp),%eax
f011fa57:	83 c0 04             	add    $0x4,%eax
f011fa5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011fa5d:	8b 45 10             	mov    0x10(%ebp),%eax
f011fa60:	ff 75 f4             	pushl  -0xc(%ebp)
f011fa63:	50                   	push   %eax
f011fa64:	ff 75 0c             	pushl  0xc(%ebp)
f011fa67:	ff 75 08             	pushl  0x8(%ebp)
f011fa6a:	e8 89 ff ff ff       	call   f011f9f8 <vsnprintf>
f011fa6f:	83 c4 10             	add    $0x10,%esp
f011fa72:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fa75:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011fa78:	c9                   	leave  
f011fa79:	c3                   	ret    

f011fa7a <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011fa7a:	55                   	push   %ebp
f011fa7b:	89 e5                	mov    %esp,%ebp
f011fa7d:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fa80:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa84:	74 13                	je     f011fa99 <readline+0x1f>
		cprintf("%s", prompt);
f011fa86:	83 ec 08             	sub    $0x8,%esp
f011fa89:	ff 75 08             	pushl  0x8(%ebp)
f011fa8c:	68 a8 13 13 f0       	push   $0xf01313a8
f011fa91:	e8 f5 14 fe ff       	call   f0100f8b <cprintf>
f011fa96:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011fa99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011faa0:	83 ec 0c             	sub    $0xc,%esp
f011faa3:	6a 00                	push   $0x0
f011faa5:	e8 ee 13 fe ff       	call   f0100e98 <iscons>
f011faaa:	83 c4 10             	add    $0x10,%esp
f011faad:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fab0:	e8 ca 13 fe ff       	call   f0100e7f <getchar>
f011fab5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fab8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fabc:	79 22                	jns    f011fae0 <readline+0x66>
			if (c != -E_EOF)
f011fabe:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fac2:	0f 84 ad 00 00 00    	je     f011fb75 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fac8:	83 ec 08             	sub    $0x8,%esp
f011facb:	ff 75 ec             	pushl  -0x14(%ebp)
f011face:	68 ab 13 13 f0       	push   $0xf01313ab
f011fad3:	e8 b3 14 fe ff       	call   f0100f8b <cprintf>
f011fad8:	83 c4 10             	add    $0x10,%esp
			break;
f011fadb:	e9 95 00 00 00       	jmp    f011fb75 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fae0:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fae4:	7e 34                	jle    f011fb1a <readline+0xa0>
f011fae6:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011faed:	7f 2b                	jg     f011fb1a <readline+0xa0>
			if (echoing)
f011faef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011faf3:	74 0e                	je     f011fb03 <readline+0x89>
				cputchar(c);
f011faf5:	83 ec 0c             	sub    $0xc,%esp
f011faf8:	ff 75 ec             	pushl  -0x14(%ebp)
f011fafb:	e8 68 13 fe ff       	call   f0100e68 <cputchar>
f011fb00:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fb03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb06:	8d 50 01             	lea    0x1(%eax),%edx
f011fb09:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fb0c:	89 c2                	mov    %eax,%edx
f011fb0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb11:	01 d0                	add    %edx,%eax
f011fb13:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fb16:	88 10                	mov    %dl,(%eax)
f011fb18:	eb 56                	jmp    f011fb70 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fb1a:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fb1e:	75 1f                	jne    f011fb3f <readline+0xc5>
f011fb20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb24:	7e 19                	jle    f011fb3f <readline+0xc5>
			if (echoing)
f011fb26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb2a:	74 0e                	je     f011fb3a <readline+0xc0>
				cputchar(c);
f011fb2c:	83 ec 0c             	sub    $0xc,%esp
f011fb2f:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb32:	e8 31 13 fe ff       	call   f0100e68 <cputchar>
f011fb37:	83 c4 10             	add    $0x10,%esp

			i--;
f011fb3a:	ff 4d f4             	decl   -0xc(%ebp)
f011fb3d:	eb 31                	jmp    f011fb70 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fb3f:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fb43:	74 0a                	je     f011fb4f <readline+0xd5>
f011fb45:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fb49:	0f 85 61 ff ff ff    	jne    f011fab0 <readline+0x36>
			if (echoing)
f011fb4f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb53:	74 0e                	je     f011fb63 <readline+0xe9>
				cputchar(c);
f011fb55:	83 ec 0c             	sub    $0xc,%esp
f011fb58:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb5b:	e8 08 13 fe ff       	call   f0100e68 <cputchar>
f011fb60:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fb63:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb66:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb69:	01 d0                	add    %edx,%eax
f011fb6b:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fb6e:	eb 06                	jmp    f011fb76 <readline+0xfc>
		}
	}
f011fb70:	e9 3b ff ff ff       	jmp    f011fab0 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fb75:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fb76:	90                   	nop
f011fb77:	c9                   	leave  
f011fb78:	c3                   	ret    

f011fb79 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fb79:	55                   	push   %ebp
f011fb7a:	89 e5                	mov    %esp,%ebp
f011fb7c:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fb7f:	e8 53 ec fe ff       	call   f010e7d7 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011fb84:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fb88:	74 13                	je     f011fb9d <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fb8a:	83 ec 08             	sub    $0x8,%esp
f011fb8d:	ff 75 08             	pushl  0x8(%ebp)
f011fb90:	68 a8 13 13 f0       	push   $0xf01313a8
f011fb95:	e8 f1 13 fe ff       	call   f0100f8b <cprintf>
f011fb9a:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fb9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011fba4:	83 ec 0c             	sub    $0xc,%esp
f011fba7:	6a 00                	push   $0x0
f011fba9:	e8 ea 12 fe ff       	call   f0100e98 <iscons>
f011fbae:	83 c4 10             	add    $0x10,%esp
f011fbb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fbb4:	e8 c6 12 fe ff       	call   f0100e7f <getchar>
f011fbb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fbbc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fbc0:	79 22                	jns    f011fbe4 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fbc2:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fbc6:	0f 84 ad 00 00 00    	je     f011fc79 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011fbcc:	83 ec 08             	sub    $0x8,%esp
f011fbcf:	ff 75 ec             	pushl  -0x14(%ebp)
f011fbd2:	68 ab 13 13 f0       	push   $0xf01313ab
f011fbd7:	e8 af 13 fe ff       	call   f0100f8b <cprintf>
f011fbdc:	83 c4 10             	add    $0x10,%esp
				break;
f011fbdf:	e9 95 00 00 00       	jmp    f011fc79 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fbe4:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fbe8:	7e 34                	jle    f011fc1e <atomic_readline+0xa5>
f011fbea:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fbf1:	7f 2b                	jg     f011fc1e <atomic_readline+0xa5>
				if (echoing)
f011fbf3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fbf7:	74 0e                	je     f011fc07 <atomic_readline+0x8e>
					cputchar(c);
f011fbf9:	83 ec 0c             	sub    $0xc,%esp
f011fbfc:	ff 75 ec             	pushl  -0x14(%ebp)
f011fbff:	e8 64 12 fe ff       	call   f0100e68 <cputchar>
f011fc04:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fc07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc0a:	8d 50 01             	lea    0x1(%eax),%edx
f011fc0d:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fc10:	89 c2                	mov    %eax,%edx
f011fc12:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc15:	01 d0                	add    %edx,%eax
f011fc17:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fc1a:	88 10                	mov    %dl,(%eax)
f011fc1c:	eb 56                	jmp    f011fc74 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fc1e:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fc22:	75 1f                	jne    f011fc43 <atomic_readline+0xca>
f011fc24:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fc28:	7e 19                	jle    f011fc43 <atomic_readline+0xca>
				if (echoing)
f011fc2a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fc2e:	74 0e                	je     f011fc3e <atomic_readline+0xc5>
					cputchar(c);
f011fc30:	83 ec 0c             	sub    $0xc,%esp
f011fc33:	ff 75 ec             	pushl  -0x14(%ebp)
f011fc36:	e8 2d 12 fe ff       	call   f0100e68 <cputchar>
f011fc3b:	83 c4 10             	add    $0x10,%esp
				i--;
f011fc3e:	ff 4d f4             	decl   -0xc(%ebp)
f011fc41:	eb 31                	jmp    f011fc74 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011fc43:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fc47:	74 0a                	je     f011fc53 <atomic_readline+0xda>
f011fc49:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fc4d:	0f 85 61 ff ff ff    	jne    f011fbb4 <atomic_readline+0x3b>
				if (echoing)
f011fc53:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fc57:	74 0e                	je     f011fc67 <atomic_readline+0xee>
					cputchar(c);
f011fc59:	83 ec 0c             	sub    $0xc,%esp
f011fc5c:	ff 75 ec             	pushl  -0x14(%ebp)
f011fc5f:	e8 04 12 fe ff       	call   f0100e68 <cputchar>
f011fc64:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011fc67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc6d:	01 d0                	add    %edx,%eax
f011fc6f:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011fc72:	eb 06                	jmp    f011fc7a <atomic_readline+0x101>
			}
		}
f011fc74:	e9 3b ff ff ff       	jmp    f011fbb4 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011fc79:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011fc7a:	e8 66 eb fe ff       	call   f010e7e5 <sys_unlock_cons>
}
f011fc7f:	90                   	nop
f011fc80:	c9                   	leave  
f011fc81:	c3                   	ret    

f011fc82 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011fc82:	55                   	push   %ebp
f011fc83:	89 e5                	mov    %esp,%ebp
f011fc85:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011fc88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fc8f:	eb 06                	jmp    f011fc97 <strlen+0x15>
		n++;
f011fc91:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011fc94:	ff 45 08             	incl   0x8(%ebp)
f011fc97:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc9a:	8a 00                	mov    (%eax),%al
f011fc9c:	84 c0                	test   %al,%al
f011fc9e:	75 f1                	jne    f011fc91 <strlen+0xf>
		n++;
	return n;
f011fca0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fca3:	c9                   	leave  
f011fca4:	c3                   	ret    

f011fca5 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011fca5:	55                   	push   %ebp
f011fca6:	89 e5                	mov    %esp,%ebp
f011fca8:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fcab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fcb2:	eb 09                	jmp    f011fcbd <strnlen+0x18>
		n++;
f011fcb4:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fcb7:	ff 45 08             	incl   0x8(%ebp)
f011fcba:	ff 4d 0c             	decl   0xc(%ebp)
f011fcbd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fcc1:	74 09                	je     f011fccc <strnlen+0x27>
f011fcc3:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcc6:	8a 00                	mov    (%eax),%al
f011fcc8:	84 c0                	test   %al,%al
f011fcca:	75 e8                	jne    f011fcb4 <strnlen+0xf>
		n++;
	return n;
f011fccc:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fccf:	c9                   	leave  
f011fcd0:	c3                   	ret    

f011fcd1 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011fcd1:	55                   	push   %ebp
f011fcd2:	89 e5                	mov    %esp,%ebp
f011fcd4:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011fcd7:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcda:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011fcdd:	90                   	nop
f011fcde:	8b 45 08             	mov    0x8(%ebp),%eax
f011fce1:	8d 50 01             	lea    0x1(%eax),%edx
f011fce4:	89 55 08             	mov    %edx,0x8(%ebp)
f011fce7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fcea:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fced:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fcf0:	8a 12                	mov    (%edx),%dl
f011fcf2:	88 10                	mov    %dl,(%eax)
f011fcf4:	8a 00                	mov    (%eax),%al
f011fcf6:	84 c0                	test   %al,%al
f011fcf8:	75 e4                	jne    f011fcde <strcpy+0xd>
		/* do nothing */;
	return ret;
f011fcfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fcfd:	c9                   	leave  
f011fcfe:	c3                   	ret    

f011fcff <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011fcff:	55                   	push   %ebp
f011fd00:	89 e5                	mov    %esp,%ebp
f011fd02:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011fd05:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd08:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011fd0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fd12:	eb 1f                	jmp    f011fd33 <strncpy+0x34>
		*dst++ = *src;
f011fd14:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd17:	8d 50 01             	lea    0x1(%eax),%edx
f011fd1a:	89 55 08             	mov    %edx,0x8(%ebp)
f011fd1d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fd20:	8a 12                	mov    (%edx),%dl
f011fd22:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011fd24:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd27:	8a 00                	mov    (%eax),%al
f011fd29:	84 c0                	test   %al,%al
f011fd2b:	74 03                	je     f011fd30 <strncpy+0x31>
			src++;
f011fd2d:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011fd30:	ff 45 fc             	incl   -0x4(%ebp)
f011fd33:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fd36:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fd39:	72 d9                	jb     f011fd14 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011fd3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011fd3e:	c9                   	leave  
f011fd3f:	c3                   	ret    

f011fd40 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011fd40:	55                   	push   %ebp
f011fd41:	89 e5                	mov    %esp,%ebp
f011fd43:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011fd46:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd49:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011fd4c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd50:	74 30                	je     f011fd82 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011fd52:	eb 16                	jmp    f011fd6a <strlcpy+0x2a>
			*dst++ = *src++;
f011fd54:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd57:	8d 50 01             	lea    0x1(%eax),%edx
f011fd5a:	89 55 08             	mov    %edx,0x8(%ebp)
f011fd5d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fd60:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fd63:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fd66:	8a 12                	mov    (%edx),%dl
f011fd68:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011fd6a:	ff 4d 10             	decl   0x10(%ebp)
f011fd6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd71:	74 09                	je     f011fd7c <strlcpy+0x3c>
f011fd73:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd76:	8a 00                	mov    (%eax),%al
f011fd78:	84 c0                	test   %al,%al
f011fd7a:	75 d8                	jne    f011fd54 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011fd7c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd7f:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011fd82:	8b 55 08             	mov    0x8(%ebp),%edx
f011fd85:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fd88:	29 c2                	sub    %eax,%edx
f011fd8a:	89 d0                	mov    %edx,%eax
}
f011fd8c:	c9                   	leave  
f011fd8d:	c3                   	ret    

f011fd8e <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011fd8e:	55                   	push   %ebp
f011fd8f:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011fd91:	eb 06                	jmp    f011fd99 <strcmp+0xb>
		p++, q++;
f011fd93:	ff 45 08             	incl   0x8(%ebp)
f011fd96:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011fd99:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd9c:	8a 00                	mov    (%eax),%al
f011fd9e:	84 c0                	test   %al,%al
f011fda0:	74 0e                	je     f011fdb0 <strcmp+0x22>
f011fda2:	8b 45 08             	mov    0x8(%ebp),%eax
f011fda5:	8a 10                	mov    (%eax),%dl
f011fda7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdaa:	8a 00                	mov    (%eax),%al
f011fdac:	38 c2                	cmp    %al,%dl
f011fdae:	74 e3                	je     f011fd93 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011fdb0:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdb3:	8a 00                	mov    (%eax),%al
f011fdb5:	0f b6 d0             	movzbl %al,%edx
f011fdb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdbb:	8a 00                	mov    (%eax),%al
f011fdbd:	0f b6 c0             	movzbl %al,%eax
f011fdc0:	29 c2                	sub    %eax,%edx
f011fdc2:	89 d0                	mov    %edx,%eax
}
f011fdc4:	5d                   	pop    %ebp
f011fdc5:	c3                   	ret    

f011fdc6 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011fdc6:	55                   	push   %ebp
f011fdc7:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011fdc9:	eb 09                	jmp    f011fdd4 <strncmp+0xe>
		n--, p++, q++;
f011fdcb:	ff 4d 10             	decl   0x10(%ebp)
f011fdce:	ff 45 08             	incl   0x8(%ebp)
f011fdd1:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011fdd4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fdd8:	74 17                	je     f011fdf1 <strncmp+0x2b>
f011fdda:	8b 45 08             	mov    0x8(%ebp),%eax
f011fddd:	8a 00                	mov    (%eax),%al
f011fddf:	84 c0                	test   %al,%al
f011fde1:	74 0e                	je     f011fdf1 <strncmp+0x2b>
f011fde3:	8b 45 08             	mov    0x8(%ebp),%eax
f011fde6:	8a 10                	mov    (%eax),%dl
f011fde8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdeb:	8a 00                	mov    (%eax),%al
f011fded:	38 c2                	cmp    %al,%dl
f011fdef:	74 da                	je     f011fdcb <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011fdf1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fdf5:	75 07                	jne    f011fdfe <strncmp+0x38>
		return 0;
f011fdf7:	b8 00 00 00 00       	mov    $0x0,%eax
f011fdfc:	eb 14                	jmp    f011fe12 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011fdfe:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe01:	8a 00                	mov    (%eax),%al
f011fe03:	0f b6 d0             	movzbl %al,%edx
f011fe06:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe09:	8a 00                	mov    (%eax),%al
f011fe0b:	0f b6 c0             	movzbl %al,%eax
f011fe0e:	29 c2                	sub    %eax,%edx
f011fe10:	89 d0                	mov    %edx,%eax
}
f011fe12:	5d                   	pop    %ebp
f011fe13:	c3                   	ret    

f011fe14 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011fe14:	55                   	push   %ebp
f011fe15:	89 e5                	mov    %esp,%ebp
f011fe17:	83 ec 04             	sub    $0x4,%esp
f011fe1a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe1d:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fe20:	eb 12                	jmp    f011fe34 <strchr+0x20>
		if (*s == c)
f011fe22:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe25:	8a 00                	mov    (%eax),%al
f011fe27:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fe2a:	75 05                	jne    f011fe31 <strchr+0x1d>
			return (char *) s;
f011fe2c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe2f:	eb 11                	jmp    f011fe42 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011fe31:	ff 45 08             	incl   0x8(%ebp)
f011fe34:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe37:	8a 00                	mov    (%eax),%al
f011fe39:	84 c0                	test   %al,%al
f011fe3b:	75 e5                	jne    f011fe22 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011fe3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fe42:	c9                   	leave  
f011fe43:	c3                   	ret    

f011fe44 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011fe44:	55                   	push   %ebp
f011fe45:	89 e5                	mov    %esp,%ebp
f011fe47:	83 ec 04             	sub    $0x4,%esp
f011fe4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe4d:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fe50:	eb 0d                	jmp    f011fe5f <strfind+0x1b>
		if (*s == c)
f011fe52:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe55:	8a 00                	mov    (%eax),%al
f011fe57:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fe5a:	74 0e                	je     f011fe6a <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011fe5c:	ff 45 08             	incl   0x8(%ebp)
f011fe5f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe62:	8a 00                	mov    (%eax),%al
f011fe64:	84 c0                	test   %al,%al
f011fe66:	75 ea                	jne    f011fe52 <strfind+0xe>
f011fe68:	eb 01                	jmp    f011fe6b <strfind+0x27>
		if (*s == c)
			break;
f011fe6a:	90                   	nop
	return (char *) s;
f011fe6b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe6e:	c9                   	leave  
f011fe6f:	c3                   	ret    

f011fe70 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011fe70:	55                   	push   %ebp
f011fe71:	89 e5                	mov    %esp,%ebp
f011fe73:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011fe76:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe79:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011fe7c:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe7f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011fe82:	eb 0e                	jmp    f011fe92 <memset+0x22>
		*p++ = c;
f011fe84:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fe87:	8d 50 01             	lea    0x1(%eax),%edx
f011fe8a:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fe8d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fe90:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011fe92:	ff 4d f8             	decl   -0x8(%ebp)
f011fe95:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011fe99:	79 e9                	jns    f011fe84 <memset+0x14>
		*p++ = c;

	return v;
f011fe9b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe9e:	c9                   	leave  
f011fe9f:	c3                   	ret    

f011fea0 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011fea0:	55                   	push   %ebp
f011fea1:	89 e5                	mov    %esp,%ebp
f011fea3:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fea6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fea9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011feac:	8b 45 08             	mov    0x8(%ebp),%eax
f011feaf:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011feb2:	eb 16                	jmp    f011feca <memcpy+0x2a>
		*d++ = *s++;
f011feb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011feb7:	8d 50 01             	lea    0x1(%eax),%edx
f011feba:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011febd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fec0:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fec3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011fec6:	8a 12                	mov    (%edx),%dl
f011fec8:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011feca:	8b 45 10             	mov    0x10(%ebp),%eax
f011fecd:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fed0:	89 55 10             	mov    %edx,0x10(%ebp)
f011fed3:	85 c0                	test   %eax,%eax
f011fed5:	75 dd                	jne    f011feb4 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011fed7:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011feda:	c9                   	leave  
f011fedb:	c3                   	ret    

f011fedc <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011fedc:	55                   	push   %ebp
f011fedd:	89 e5                	mov    %esp,%ebp
f011fedf:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fee2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fee5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011fee8:	8b 45 08             	mov    0x8(%ebp),%eax
f011feeb:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011feee:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fef1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011fef4:	73 50                	jae    f011ff46 <memmove+0x6a>
f011fef6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fef9:	8b 45 10             	mov    0x10(%ebp),%eax
f011fefc:	01 d0                	add    %edx,%eax
f011fefe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ff01:	76 43                	jbe    f011ff46 <memmove+0x6a>
		s += n;
f011ff03:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff06:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011ff09:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff0c:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011ff0f:	eb 10                	jmp    f011ff21 <memmove+0x45>
			*--d = *--s;
f011ff11:	ff 4d f8             	decl   -0x8(%ebp)
f011ff14:	ff 4d fc             	decl   -0x4(%ebp)
f011ff17:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff1a:	8a 10                	mov    (%eax),%dl
f011ff1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff1f:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011ff21:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff24:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff27:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff2a:	85 c0                	test   %eax,%eax
f011ff2c:	75 e3                	jne    f011ff11 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011ff2e:	eb 23                	jmp    f011ff53 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011ff30:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff33:	8d 50 01             	lea    0x1(%eax),%edx
f011ff36:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ff39:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ff3c:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ff3f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ff42:	8a 12                	mov    (%edx),%dl
f011ff44:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011ff46:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff49:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff4c:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff4f:	85 c0                	test   %eax,%eax
f011ff51:	75 dd                	jne    f011ff30 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011ff53:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ff56:	c9                   	leave  
f011ff57:	c3                   	ret    

f011ff58 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011ff58:	55                   	push   %ebp
f011ff59:	89 e5                	mov    %esp,%ebp
f011ff5b:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011ff5e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff61:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ff64:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff67:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ff6a:	eb 2a                	jmp    f011ff96 <memcmp+0x3e>
		if (*s1 != *s2)
f011ff6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff6f:	8a 10                	mov    (%eax),%dl
f011ff71:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff74:	8a 00                	mov    (%eax),%al
f011ff76:	38 c2                	cmp    %al,%dl
f011ff78:	74 16                	je     f011ff90 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ff7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff7d:	8a 00                	mov    (%eax),%al
f011ff7f:	0f b6 d0             	movzbl %al,%edx
f011ff82:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff85:	8a 00                	mov    (%eax),%al
f011ff87:	0f b6 c0             	movzbl %al,%eax
f011ff8a:	29 c2                	sub    %eax,%edx
f011ff8c:	89 d0                	mov    %edx,%eax
f011ff8e:	eb 18                	jmp    f011ffa8 <memcmp+0x50>
		s1++, s2++;
f011ff90:	ff 45 fc             	incl   -0x4(%ebp)
f011ff93:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ff96:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff99:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff9c:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff9f:	85 c0                	test   %eax,%eax
f011ffa1:	75 c9                	jne    f011ff6c <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ffa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ffa8:	c9                   	leave  
f011ffa9:	c3                   	ret    

f011ffaa <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ffaa:	55                   	push   %ebp
f011ffab:	89 e5                	mov    %esp,%ebp
f011ffad:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ffb0:	8b 55 08             	mov    0x8(%ebp),%edx
f011ffb3:	8b 45 10             	mov    0x10(%ebp),%eax
f011ffb6:	01 d0                	add    %edx,%eax
f011ffb8:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ffbb:	eb 15                	jmp    f011ffd2 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ffbd:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffc0:	8a 00                	mov    (%eax),%al
f011ffc2:	0f b6 d0             	movzbl %al,%edx
f011ffc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffc8:	0f b6 c0             	movzbl %al,%eax
f011ffcb:	39 c2                	cmp    %eax,%edx
f011ffcd:	74 0d                	je     f011ffdc <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ffcf:	ff 45 08             	incl   0x8(%ebp)
f011ffd2:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffd5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ffd8:	72 e3                	jb     f011ffbd <memfind+0x13>
f011ffda:	eb 01                	jmp    f011ffdd <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ffdc:	90                   	nop
	return (void *) s;
f011ffdd:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ffe0:	c9                   	leave  
f011ffe1:	c3                   	ret    

f011ffe2 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ffe2:	55                   	push   %ebp
f011ffe3:	89 e5                	mov    %esp,%ebp
f011ffe5:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ffe8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ffef:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011fff6:	eb 03                	jmp    f011fffb <strtol+0x19>
		s++;
f011fff8:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011fffb:	8b 45 08             	mov    0x8(%ebp),%eax
f011fffe:	8a 00                	mov    (%eax),%al
f0120000:	3c 20                	cmp    $0x20,%al
f0120002:	74 f4                	je     f011fff8 <strtol+0x16>
f0120004:	8b 45 08             	mov    0x8(%ebp),%eax
f0120007:	8a 00                	mov    (%eax),%al
f0120009:	3c 09                	cmp    $0x9,%al
f012000b:	74 eb                	je     f011fff8 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f012000d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120010:	8a 00                	mov    (%eax),%al
f0120012:	3c 2b                	cmp    $0x2b,%al
f0120014:	75 05                	jne    f012001b <strtol+0x39>
		s++;
f0120016:	ff 45 08             	incl   0x8(%ebp)
f0120019:	eb 13                	jmp    f012002e <strtol+0x4c>
	else if (*s == '-')
f012001b:	8b 45 08             	mov    0x8(%ebp),%eax
f012001e:	8a 00                	mov    (%eax),%al
f0120020:	3c 2d                	cmp    $0x2d,%al
f0120022:	75 0a                	jne    f012002e <strtol+0x4c>
		s++, neg = 1;
f0120024:	ff 45 08             	incl   0x8(%ebp)
f0120027:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f012002e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120032:	74 06                	je     f012003a <strtol+0x58>
f0120034:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f0120038:	75 20                	jne    f012005a <strtol+0x78>
f012003a:	8b 45 08             	mov    0x8(%ebp),%eax
f012003d:	8a 00                	mov    (%eax),%al
f012003f:	3c 30                	cmp    $0x30,%al
f0120041:	75 17                	jne    f012005a <strtol+0x78>
f0120043:	8b 45 08             	mov    0x8(%ebp),%eax
f0120046:	40                   	inc    %eax
f0120047:	8a 00                	mov    (%eax),%al
f0120049:	3c 78                	cmp    $0x78,%al
f012004b:	75 0d                	jne    f012005a <strtol+0x78>
		s += 2, base = 16;
f012004d:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f0120051:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0120058:	eb 28                	jmp    f0120082 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f012005a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012005e:	75 15                	jne    f0120075 <strtol+0x93>
f0120060:	8b 45 08             	mov    0x8(%ebp),%eax
f0120063:	8a 00                	mov    (%eax),%al
f0120065:	3c 30                	cmp    $0x30,%al
f0120067:	75 0c                	jne    f0120075 <strtol+0x93>
		s++, base = 8;
f0120069:	ff 45 08             	incl   0x8(%ebp)
f012006c:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f0120073:	eb 0d                	jmp    f0120082 <strtol+0xa0>
	else if (base == 0)
f0120075:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120079:	75 07                	jne    f0120082 <strtol+0xa0>
		base = 10;
f012007b:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f0120082:	8b 45 08             	mov    0x8(%ebp),%eax
f0120085:	8a 00                	mov    (%eax),%al
f0120087:	3c 2f                	cmp    $0x2f,%al
f0120089:	7e 19                	jle    f01200a4 <strtol+0xc2>
f012008b:	8b 45 08             	mov    0x8(%ebp),%eax
f012008e:	8a 00                	mov    (%eax),%al
f0120090:	3c 39                	cmp    $0x39,%al
f0120092:	7f 10                	jg     f01200a4 <strtol+0xc2>
			dig = *s - '0';
f0120094:	8b 45 08             	mov    0x8(%ebp),%eax
f0120097:	8a 00                	mov    (%eax),%al
f0120099:	0f be c0             	movsbl %al,%eax
f012009c:	83 e8 30             	sub    $0x30,%eax
f012009f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01200a2:	eb 42                	jmp    f01200e6 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f01200a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01200a7:	8a 00                	mov    (%eax),%al
f01200a9:	3c 60                	cmp    $0x60,%al
f01200ab:	7e 19                	jle    f01200c6 <strtol+0xe4>
f01200ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01200b0:	8a 00                	mov    (%eax),%al
f01200b2:	3c 7a                	cmp    $0x7a,%al
f01200b4:	7f 10                	jg     f01200c6 <strtol+0xe4>
			dig = *s - 'a' + 10;
f01200b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01200b9:	8a 00                	mov    (%eax),%al
f01200bb:	0f be c0             	movsbl %al,%eax
f01200be:	83 e8 57             	sub    $0x57,%eax
f01200c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01200c4:	eb 20                	jmp    f01200e6 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f01200c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01200c9:	8a 00                	mov    (%eax),%al
f01200cb:	3c 40                	cmp    $0x40,%al
f01200cd:	7e 39                	jle    f0120108 <strtol+0x126>
f01200cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01200d2:	8a 00                	mov    (%eax),%al
f01200d4:	3c 5a                	cmp    $0x5a,%al
f01200d6:	7f 30                	jg     f0120108 <strtol+0x126>
			dig = *s - 'A' + 10;
f01200d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01200db:	8a 00                	mov    (%eax),%al
f01200dd:	0f be c0             	movsbl %al,%eax
f01200e0:	83 e8 37             	sub    $0x37,%eax
f01200e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f01200e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200e9:	3b 45 10             	cmp    0x10(%ebp),%eax
f01200ec:	7d 19                	jge    f0120107 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f01200ee:	ff 45 08             	incl   0x8(%ebp)
f01200f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01200f4:	0f af 45 10          	imul   0x10(%ebp),%eax
f01200f8:	89 c2                	mov    %eax,%edx
f01200fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200fd:	01 d0                	add    %edx,%eax
f01200ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f0120102:	e9 7b ff ff ff       	jmp    f0120082 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f0120107:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f0120108:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012010c:	74 08                	je     f0120116 <strtol+0x134>
		*endptr = (char *) s;
f012010e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120111:	8b 55 08             	mov    0x8(%ebp),%edx
f0120114:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f0120116:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f012011a:	74 07                	je     f0120123 <strtol+0x141>
f012011c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012011f:	f7 d8                	neg    %eax
f0120121:	eb 03                	jmp    f0120126 <strtol+0x144>
f0120123:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0120126:	c9                   	leave  
f0120127:	c3                   	ret    

f0120128 <ltostr>:

void
ltostr(long value, char *str)
{
f0120128:	55                   	push   %ebp
f0120129:	89 e5                	mov    %esp,%ebp
f012012b:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f012012e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0120135:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f012013c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120140:	79 13                	jns    f0120155 <ltostr+0x2d>
	{
		neg = 1;
f0120142:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0120149:	8b 45 0c             	mov    0xc(%ebp),%eax
f012014c:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f012014f:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0120152:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f0120155:	8b 45 08             	mov    0x8(%ebp),%eax
f0120158:	b9 0a 00 00 00       	mov    $0xa,%ecx
f012015d:	99                   	cltd   
f012015e:	f7 f9                	idiv   %ecx
f0120160:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f0120163:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120166:	8d 50 01             	lea    0x1(%eax),%edx
f0120169:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012016c:	89 c2                	mov    %eax,%edx
f012016e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120171:	01 d0                	add    %edx,%eax
f0120173:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120176:	83 c2 30             	add    $0x30,%edx
f0120179:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f012017b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f012017e:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120183:	f7 e9                	imul   %ecx
f0120185:	c1 fa 02             	sar    $0x2,%edx
f0120188:	89 c8                	mov    %ecx,%eax
f012018a:	c1 f8 1f             	sar    $0x1f,%eax
f012018d:	29 c2                	sub    %eax,%edx
f012018f:	89 d0                	mov    %edx,%eax
f0120191:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f0120194:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120198:	75 bb                	jne    f0120155 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f012019a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f01201a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201a4:	48                   	dec    %eax
f01201a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f01201a8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01201ac:	74 3d                	je     f01201eb <ltostr+0xc3>
		start = 1 ;
f01201ae:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f01201b5:	eb 34                	jmp    f01201eb <ltostr+0xc3>
	{
		char tmp = str[start] ;
f01201b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01201ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201bd:	01 d0                	add    %edx,%eax
f01201bf:	8a 00                	mov    (%eax),%al
f01201c1:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f01201c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01201c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201ca:	01 c2                	add    %eax,%edx
f01201cc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f01201cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201d2:	01 c8                	add    %ecx,%eax
f01201d4:	8a 00                	mov    (%eax),%al
f01201d6:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f01201d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01201db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201de:	01 c2                	add    %eax,%edx
f01201e0:	8a 45 eb             	mov    -0x15(%ebp),%al
f01201e3:	88 02                	mov    %al,(%edx)
		start++ ;
f01201e5:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f01201e8:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f01201eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201ee:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01201f1:	7c c4                	jl     f01201b7 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f01201f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01201f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201f9:	01 d0                	add    %edx,%eax
f01201fb:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f01201fe:	90                   	nop
f01201ff:	c9                   	leave  
f0120200:	c3                   	ret    

f0120201 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0120201:	55                   	push   %ebp
f0120202:	89 e5                	mov    %esp,%ebp
f0120204:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0120207:	ff 75 08             	pushl  0x8(%ebp)
f012020a:	e8 73 fa ff ff       	call   f011fc82 <strlen>
f012020f:	83 c4 04             	add    $0x4,%esp
f0120212:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0120215:	ff 75 0c             	pushl  0xc(%ebp)
f0120218:	e8 65 fa ff ff       	call   f011fc82 <strlen>
f012021d:	83 c4 04             	add    $0x4,%esp
f0120220:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120223:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f012022a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120231:	eb 17                	jmp    f012024a <strcconcat+0x49>
		final[s] = str1[s] ;
f0120233:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120236:	8b 45 10             	mov    0x10(%ebp),%eax
f0120239:	01 c2                	add    %eax,%edx
f012023b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f012023e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120241:	01 c8                	add    %ecx,%eax
f0120243:	8a 00                	mov    (%eax),%al
f0120245:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0120247:	ff 45 fc             	incl   -0x4(%ebp)
f012024a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012024d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120250:	7c e1                	jl     f0120233 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0120252:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0120259:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0120260:	eb 1f                	jmp    f0120281 <strcconcat+0x80>
		final[s++] = str2[i] ;
f0120262:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120265:	8d 50 01             	lea    0x1(%eax),%edx
f0120268:	89 55 fc             	mov    %edx,-0x4(%ebp)
f012026b:	89 c2                	mov    %eax,%edx
f012026d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120270:	01 c2                	add    %eax,%edx
f0120272:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f0120275:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120278:	01 c8                	add    %ecx,%eax
f012027a:	8a 00                	mov    (%eax),%al
f012027c:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f012027e:	ff 45 f8             	incl   -0x8(%ebp)
f0120281:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120284:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120287:	7c d9                	jl     f0120262 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120289:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012028c:	8b 45 10             	mov    0x10(%ebp),%eax
f012028f:	01 d0                	add    %edx,%eax
f0120291:	c6 00 00             	movb   $0x0,(%eax)
}
f0120294:	90                   	nop
f0120295:	c9                   	leave  
f0120296:	c3                   	ret    

f0120297 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120297:	55                   	push   %ebp
f0120298:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f012029a:	8b 45 14             	mov    0x14(%ebp),%eax
f012029d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f01202a3:	8b 45 14             	mov    0x14(%ebp),%eax
f01202a6:	8b 00                	mov    (%eax),%eax
f01202a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01202af:	8b 45 10             	mov    0x10(%ebp),%eax
f01202b2:	01 d0                	add    %edx,%eax
f01202b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f01202ba:	eb 0c                	jmp    f01202c8 <strsplit+0x31>
			*string++ = 0;
f01202bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01202bf:	8d 50 01             	lea    0x1(%eax),%edx
f01202c2:	89 55 08             	mov    %edx,0x8(%ebp)
f01202c5:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f01202c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01202cb:	8a 00                	mov    (%eax),%al
f01202cd:	84 c0                	test   %al,%al
f01202cf:	74 18                	je     f01202e9 <strsplit+0x52>
f01202d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01202d4:	8a 00                	mov    (%eax),%al
f01202d6:	0f be c0             	movsbl %al,%eax
f01202d9:	50                   	push   %eax
f01202da:	ff 75 0c             	pushl  0xc(%ebp)
f01202dd:	e8 32 fb ff ff       	call   f011fe14 <strchr>
f01202e2:	83 c4 08             	add    $0x8,%esp
f01202e5:	85 c0                	test   %eax,%eax
f01202e7:	75 d3                	jne    f01202bc <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f01202e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01202ec:	8a 00                	mov    (%eax),%al
f01202ee:	84 c0                	test   %al,%al
f01202f0:	74 5a                	je     f012034c <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f01202f2:	8b 45 14             	mov    0x14(%ebp),%eax
f01202f5:	8b 00                	mov    (%eax),%eax
f01202f7:	83 f8 0f             	cmp    $0xf,%eax
f01202fa:	75 07                	jne    f0120303 <strsplit+0x6c>
		{
			return 0;
f01202fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0120301:	eb 66                	jmp    f0120369 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0120303:	8b 45 14             	mov    0x14(%ebp),%eax
f0120306:	8b 00                	mov    (%eax),%eax
f0120308:	8d 48 01             	lea    0x1(%eax),%ecx
f012030b:	8b 55 14             	mov    0x14(%ebp),%edx
f012030e:	89 0a                	mov    %ecx,(%edx)
f0120310:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120317:	8b 45 10             	mov    0x10(%ebp),%eax
f012031a:	01 c2                	add    %eax,%edx
f012031c:	8b 45 08             	mov    0x8(%ebp),%eax
f012031f:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120321:	eb 03                	jmp    f0120326 <strsplit+0x8f>
			string++;
f0120323:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120326:	8b 45 08             	mov    0x8(%ebp),%eax
f0120329:	8a 00                	mov    (%eax),%al
f012032b:	84 c0                	test   %al,%al
f012032d:	74 8b                	je     f01202ba <strsplit+0x23>
f012032f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120332:	8a 00                	mov    (%eax),%al
f0120334:	0f be c0             	movsbl %al,%eax
f0120337:	50                   	push   %eax
f0120338:	ff 75 0c             	pushl  0xc(%ebp)
f012033b:	e8 d4 fa ff ff       	call   f011fe14 <strchr>
f0120340:	83 c4 08             	add    $0x8,%esp
f0120343:	85 c0                	test   %eax,%eax
f0120345:	74 dc                	je     f0120323 <strsplit+0x8c>
			string++;
	}
f0120347:	e9 6e ff ff ff       	jmp    f01202ba <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f012034c:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f012034d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120350:	8b 00                	mov    (%eax),%eax
f0120352:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120359:	8b 45 10             	mov    0x10(%ebp),%eax
f012035c:	01 d0                	add    %edx,%eax
f012035e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0120364:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120369:	c9                   	leave  
f012036a:	c3                   	ret    

f012036b <str2lower>:


char* str2lower(char *dst, const char *src)
{
f012036b:	55                   	push   %ebp
f012036c:	89 e5                	mov    %esp,%ebp
f012036e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0120371:	83 ec 04             	sub    $0x4,%esp
f0120374:	68 bc 13 13 f0       	push   $0xf01313bc
f0120379:	68 3f 01 00 00       	push   $0x13f
f012037e:	68 de 13 13 f0       	push   $0xf01313de
f0120383:	e8 b1 ff fd ff       	call   f0100339 <_panic>

f0120388 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120388:	55                   	push   %ebp
f0120389:	89 e5                	mov    %esp,%ebp
f012038b:	83 ec 18             	sub    $0x18,%esp
f012038e:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120395:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120398:	89 c2                	mov    %eax,%edx
f012039a:	ec                   	in     (%dx),%al
f012039b:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f012039e:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01203a1:	0f b6 c0             	movzbl %al,%eax
f01203a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01203a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203aa:	25 c0 00 00 00       	and    $0xc0,%eax
f01203af:	83 f8 40             	cmp    $0x40,%eax
f01203b2:	75 10                	jne    f01203c4 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f01203b4:	83 ec 0c             	sub    $0xc,%esp
f01203b7:	68 e0 14 6c f0       	push   $0xf06c14e0
f01203bc:	e8 6d fd fe ff       	call   f011012e <wakeup_one>
f01203c1:	83 c4 10             	add    $0x10,%esp
	}

}
f01203c4:	90                   	nop
f01203c5:	c9                   	leave  
f01203c6:	c3                   	ret    

f01203c7 <ide_init>:

void ide_init()
{
f01203c7:	55                   	push   %ebp
f01203c8:	89 e5                	mov    %esp,%ebp
f01203ca:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f01203cd:	83 ec 08             	sub    $0x8,%esp
f01203d0:	68 88 03 12 f0       	push   $0xf0120388
f01203d5:	6a 0e                	push   $0xe
f01203d7:	e8 03 df fe ff       	call   f010e2df <irq_install_handler>
f01203dc:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f01203df:	83 ec 08             	sub    $0x8,%esp
f01203e2:	68 ec 13 13 f0       	push   $0xf01313ec
f01203e7:	68 e0 14 6c f0       	push   $0xf06c14e0
f01203ec:	e8 a3 fc fe ff       	call   f0110094 <init_channel>
f01203f1:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f01203f4:	83 ec 08             	sub    $0x8,%esp
f01203f7:	68 f9 13 13 f0       	push   $0xf01313f9
f01203fc:	68 00 1b 6c f0       	push   $0xf06c1b00
f0120401:	e8 9d f8 fe ff       	call   f010fca3 <init_spinlock>
f0120406:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0120409:	90                   	nop
f012040a:	c9                   	leave  
f012040b:	c3                   	ret    

f012040c <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f012040c:	55                   	push   %ebp
f012040d:	89 e5                	mov    %esp,%ebp
f012040f:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120412:	90                   	nop
f0120413:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f012041a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012041d:	89 c2                	mov    %eax,%edx
f012041f:	ec                   	in     (%dx),%al
f0120420:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120423:	8a 45 ef             	mov    -0x11(%ebp),%al
f0120426:	0f b6 c0             	movzbl %al,%eax
f0120429:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012042c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012042f:	25 c0 00 00 00       	and    $0xc0,%eax
f0120434:	83 f8 40             	cmp    $0x40,%eax
f0120437:	75 da                	jne    f0120413 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0120439:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012043d:	74 24                	je     f0120463 <ide_wait_ready+0x57>
f012043f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120442:	83 e0 21             	and    $0x21,%eax
f0120445:	85 c0                	test   %eax,%eax
f0120447:	74 1a                	je     f0120463 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0120449:	83 ec 0c             	sub    $0xc,%esp
f012044c:	ff 75 f4             	pushl  -0xc(%ebp)
f012044f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120452:	68 0c 14 13 f0       	push   $0xf013140c
f0120457:	6a 5d                	push   $0x5d
f0120459:	68 2f 14 13 f0       	push   $0xf013142f
f012045e:	e8 d6 fe fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0120463:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120468:	c9                   	leave  
f0120469:	c3                   	ret    

f012046a <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f012046a:	55                   	push   %ebp
f012046b:	89 e5                	mov    %esp,%ebp
f012046d:	57                   	push   %edi
f012046e:	53                   	push   %ebx
f012046f:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0120472:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120479:	76 16                	jbe    f0120491 <ide_read+0x27>
f012047b:	68 3a 14 13 f0       	push   $0xf013143a
f0120480:	68 47 14 13 f0       	push   $0xf0131447
f0120485:	6a 68                	push   $0x68
f0120487:	68 2f 14 13 f0       	push   $0xf013142f
f012048c:	e8 a8 fe fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0120491:	83 ec 0c             	sub    $0xc,%esp
f0120494:	6a 00                	push   $0x0
f0120496:	e8 71 ff ff ff       	call   f012040c <ide_wait_ready>
f012049b:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f012049e:	8b 45 10             	mov    0x10(%ebp),%eax
f01204a1:	0f b6 c0             	movzbl %al,%eax
f01204a4:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01204ab:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01204ae:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01204b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01204b4:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01204b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01204b8:	0f b6 c0             	movzbl %al,%eax
f01204bb:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f01204c2:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01204c5:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01204c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01204cb:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01204cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01204cf:	c1 e8 08             	shr    $0x8,%eax
f01204d2:	0f b6 c0             	movzbl %al,%eax
f01204d5:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01204dc:	88 45 d4             	mov    %al,-0x2c(%ebp)
f01204df:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01204e2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01204e5:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f01204e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01204e9:	c1 e8 10             	shr    $0x10,%eax
f01204ec:	0f b6 c0             	movzbl %al,%eax
f01204ef:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01204f6:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01204f9:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01204fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01204ff:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120500:	a1 90 13 6c f0       	mov    0xf06c1390,%eax
f0120505:	83 e0 01             	and    $0x1,%eax
f0120508:	c1 e0 04             	shl    $0x4,%eax
f012050b:	88 c2                	mov    %al,%dl
f012050d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120510:	c1 e8 18             	shr    $0x18,%eax
f0120513:	83 e0 0f             	and    $0xf,%eax
f0120516:	09 d0                	or     %edx,%eax
f0120518:	83 c8 e0             	or     $0xffffffe0,%eax
f012051b:	0f b6 c0             	movzbl %al,%eax
f012051e:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120525:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120528:	8a 45 d6             	mov    -0x2a(%ebp),%al
f012052b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012052e:	ee                   	out    %al,(%dx)
f012052f:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120536:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f012053a:	8a 45 d7             	mov    -0x29(%ebp),%al
f012053d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120540:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120541:	eb 55                	jmp    f0120598 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120543:	83 ec 0c             	sub    $0xc,%esp
f0120546:	6a 01                	push   $0x1
f0120548:	e8 bf fe ff ff       	call   f012040c <ide_wait_ready>
f012054d:	83 c4 10             	add    $0x10,%esp
f0120550:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120553:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120557:	79 05                	jns    f012055e <ide_read+0xf4>
			return r;
f0120559:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012055c:	eb 45                	jmp    f01205a3 <ide_read+0x139>
f012055e:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120565:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120568:	89 45 cc             	mov    %eax,-0x34(%ebp)
f012056b:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0120572:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120575:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120578:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012057b:	89 cb                	mov    %ecx,%ebx
f012057d:	89 df                	mov    %ebx,%edi
f012057f:	89 c1                	mov    %eax,%ecx
f0120581:	fc                   	cld    
f0120582:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0120584:	89 c8                	mov    %ecx,%eax
f0120586:	89 fb                	mov    %edi,%ebx
f0120588:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f012058b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f012058e:	ff 4d 10             	decl   0x10(%ebp)
f0120591:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120598:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012059c:	75 a5                	jne    f0120543 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f012059e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01205a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01205a6:	5b                   	pop    %ebx
f01205a7:	5f                   	pop    %edi
f01205a8:	5d                   	pop    %ebp
f01205a9:	c3                   	ret    

f01205aa <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f01205aa:	55                   	push   %ebp
f01205ab:	89 e5                	mov    %esp,%ebp
f01205ad:	56                   	push   %esi
f01205ae:	53                   	push   %ebx
f01205af:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f01205b2:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01205b9:	76 19                	jbe    f01205d4 <ide_write+0x2a>
f01205bb:	68 3a 14 13 f0       	push   $0xf013143a
f01205c0:	68 47 14 13 f0       	push   $0xf0131447
f01205c5:	68 82 00 00 00       	push   $0x82
f01205ca:	68 2f 14 13 f0       	push   $0xf013142f
f01205cf:	e8 65 fd fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f01205d4:	83 ec 0c             	sub    $0xc,%esp
f01205d7:	6a 00                	push   $0x0
f01205d9:	e8 2e fe ff ff       	call   f012040c <ide_wait_ready>
f01205de:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f01205e1:	8b 45 10             	mov    0x10(%ebp),%eax
f01205e4:	0f b6 c0             	movzbl %al,%eax
f01205e7:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01205ee:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01205f1:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01205f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01205f7:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01205f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01205fb:	0f b6 c0             	movzbl %al,%eax
f01205fe:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120605:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120608:	8a 45 d3             	mov    -0x2d(%ebp),%al
f012060b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012060e:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f012060f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120612:	c1 e8 08             	shr    $0x8,%eax
f0120615:	0f b6 c0             	movzbl %al,%eax
f0120618:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f012061f:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120622:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120625:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120628:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120629:	8b 45 08             	mov    0x8(%ebp),%eax
f012062c:	c1 e8 10             	shr    $0x10,%eax
f012062f:	0f b6 c0             	movzbl %al,%eax
f0120632:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120639:	88 45 d5             	mov    %al,-0x2b(%ebp)
f012063c:	8a 45 d5             	mov    -0x2b(%ebp),%al
f012063f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120642:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120643:	a1 90 13 6c f0       	mov    0xf06c1390,%eax
f0120648:	83 e0 01             	and    $0x1,%eax
f012064b:	c1 e0 04             	shl    $0x4,%eax
f012064e:	88 c2                	mov    %al,%dl
f0120650:	8b 45 08             	mov    0x8(%ebp),%eax
f0120653:	c1 e8 18             	shr    $0x18,%eax
f0120656:	83 e0 0f             	and    $0xf,%eax
f0120659:	09 d0                	or     %edx,%eax
f012065b:	83 c8 e0             	or     $0xffffffe0,%eax
f012065e:	0f b6 c0             	movzbl %al,%eax
f0120661:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120668:	88 45 d6             	mov    %al,-0x2a(%ebp)
f012066b:	8a 45 d6             	mov    -0x2a(%ebp),%al
f012066e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120671:	ee                   	out    %al,(%dx)
f0120672:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120679:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f012067d:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120680:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120683:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120684:	eb 55                	jmp    f01206db <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120686:	83 ec 0c             	sub    $0xc,%esp
f0120689:	6a 01                	push   $0x1
f012068b:	e8 7c fd ff ff       	call   f012040c <ide_wait_ready>
f0120690:	83 c4 10             	add    $0x10,%esp
f0120693:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120696:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012069a:	79 05                	jns    f01206a1 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f012069c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012069f:	eb 45                	jmp    f01206e6 <ide_write+0x13c>
f01206a1:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01206a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ab:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01206ae:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f01206b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01206b8:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f01206bb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01206be:	89 cb                	mov    %ecx,%ebx
f01206c0:	89 de                	mov    %ebx,%esi
f01206c2:	89 c1                	mov    %eax,%ecx
f01206c4:	fc                   	cld    
f01206c5:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f01206c7:	89 c8                	mov    %ecx,%eax
f01206c9:	89 f3                	mov    %esi,%ebx
f01206cb:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01206ce:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01206d1:	ff 4d 10             	decl   0x10(%ebp)
f01206d4:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f01206db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01206df:	75 a5                	jne    f0120686 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f01206e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01206e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01206e9:	5b                   	pop    %ebx
f01206ea:	5e                   	pop    %esi
f01206eb:	5d                   	pop    %ebp
f01206ec:	c3                   	ret    

f01206ed <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f01206ed:	55                   	push   %ebp
f01206ee:	89 e5                	mov    %esp,%ebp
f01206f0:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01206f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01206f6:	83 e8 04             	sub    $0x4,%eax
f01206f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f01206fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01206ff:	8b 00                	mov    (%eax),%eax
f0120701:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120704:	c9                   	leave  
f0120705:	c3                   	ret    

f0120706 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120706:	55                   	push   %ebp
f0120707:	89 e5                	mov    %esp,%ebp
f0120709:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f012070c:	8b 45 08             	mov    0x8(%ebp),%eax
f012070f:	83 e8 04             	sub    $0x4,%eax
f0120712:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120715:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120718:	8b 00                	mov    (%eax),%eax
f012071a:	83 e0 01             	and    $0x1,%eax
f012071d:	85 c0                	test   %eax,%eax
f012071f:	0f 94 c0             	sete   %al
}
f0120722:	c9                   	leave  
f0120723:	c3                   	ret    

f0120724 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120724:	55                   	push   %ebp
f0120725:	89 e5                	mov    %esp,%ebp
f0120727:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f012072a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120731:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120734:	83 f8 02             	cmp    $0x2,%eax
f0120737:	74 2b                	je     f0120764 <alloc_block+0x40>
f0120739:	83 f8 02             	cmp    $0x2,%eax
f012073c:	7f 07                	jg     f0120745 <alloc_block+0x21>
f012073e:	83 f8 01             	cmp    $0x1,%eax
f0120741:	74 0e                	je     f0120751 <alloc_block+0x2d>
f0120743:	eb 58                	jmp    f012079d <alloc_block+0x79>
f0120745:	83 f8 03             	cmp    $0x3,%eax
f0120748:	74 2d                	je     f0120777 <alloc_block+0x53>
f012074a:	83 f8 04             	cmp    $0x4,%eax
f012074d:	74 3b                	je     f012078a <alloc_block+0x66>
f012074f:	eb 4c                	jmp    f012079d <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0120751:	83 ec 0c             	sub    $0xc,%esp
f0120754:	ff 75 08             	pushl  0x8(%ebp)
f0120757:	e8 11 03 00 00       	call   f0120a6d <alloc_block_FF>
f012075c:	83 c4 10             	add    $0x10,%esp
f012075f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120762:	eb 4a                	jmp    f01207ae <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0120764:	83 ec 0c             	sub    $0xc,%esp
f0120767:	ff 75 08             	pushl  0x8(%ebp)
f012076a:	e8 fa 19 00 00       	call   f0122169 <alloc_block_NF>
f012076f:	83 c4 10             	add    $0x10,%esp
f0120772:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120775:	eb 37                	jmp    f01207ae <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0120777:	83 ec 0c             	sub    $0xc,%esp
f012077a:	ff 75 08             	pushl  0x8(%ebp)
f012077d:	e8 a7 07 00 00       	call   f0120f29 <alloc_block_BF>
f0120782:	83 c4 10             	add    $0x10,%esp
f0120785:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120788:	eb 24                	jmp    f01207ae <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f012078a:	83 ec 0c             	sub    $0xc,%esp
f012078d:	ff 75 08             	pushl  0x8(%ebp)
f0120790:	e8 b7 19 00 00       	call   f012214c <alloc_block_WF>
f0120795:	83 c4 10             	add    $0x10,%esp
f0120798:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012079b:	eb 11                	jmp    f01207ae <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f012079d:	83 ec 0c             	sub    $0xc,%esp
f01207a0:	68 5c 14 13 f0       	push   $0xf013145c
f01207a5:	e8 e1 07 fe ff       	call   f0100f8b <cprintf>
f01207aa:	83 c4 10             	add    $0x10,%esp
		break;
f01207ad:	90                   	nop
	}
	return va;
f01207ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01207b1:	c9                   	leave  
f01207b2:	c3                   	ret    

f01207b3 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f01207b3:	55                   	push   %ebp
f01207b4:	89 e5                	mov    %esp,%ebp
f01207b6:	53                   	push   %ebx
f01207b7:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f01207ba:	83 ec 0c             	sub    $0xc,%esp
f01207bd:	68 7c 14 13 f0       	push   $0xf013147c
f01207c2:	e8 c4 07 fe ff       	call   f0100f8b <cprintf>
f01207c7:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f01207ca:	83 ec 0c             	sub    $0xc,%esp
f01207cd:	68 a7 14 13 f0       	push   $0xf01314a7
f01207d2:	e8 b4 07 fe ff       	call   f0100f8b <cprintf>
f01207d7:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f01207da:	8b 45 08             	mov    0x8(%ebp),%eax
f01207dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01207e0:	eb 37                	jmp    f0120819 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f01207e2:	83 ec 0c             	sub    $0xc,%esp
f01207e5:	ff 75 f4             	pushl  -0xc(%ebp)
f01207e8:	e8 19 ff ff ff       	call   f0120706 <is_free_block>
f01207ed:	83 c4 10             	add    $0x10,%esp
f01207f0:	0f be d8             	movsbl %al,%ebx
f01207f3:	83 ec 0c             	sub    $0xc,%esp
f01207f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01207f9:	e8 ef fe ff ff       	call   f01206ed <get_block_size>
f01207fe:	83 c4 10             	add    $0x10,%esp
f0120801:	83 ec 04             	sub    $0x4,%esp
f0120804:	53                   	push   %ebx
f0120805:	50                   	push   %eax
f0120806:	68 bf 14 13 f0       	push   $0xf01314bf
f012080b:	e8 7b 07 fe ff       	call   f0100f8b <cprintf>
f0120810:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120813:	8b 45 10             	mov    0x10(%ebp),%eax
f0120816:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120819:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012081d:	74 07                	je     f0120826 <print_blocks_list+0x73>
f012081f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120822:	8b 00                	mov    (%eax),%eax
f0120824:	eb 05                	jmp    f012082b <print_blocks_list+0x78>
f0120826:	b8 00 00 00 00       	mov    $0x0,%eax
f012082b:	89 45 10             	mov    %eax,0x10(%ebp)
f012082e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120831:	85 c0                	test   %eax,%eax
f0120833:	75 ad                	jne    f01207e2 <print_blocks_list+0x2f>
f0120835:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120839:	75 a7                	jne    f01207e2 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f012083b:	83 ec 0c             	sub    $0xc,%esp
f012083e:	68 7c 14 13 f0       	push   $0xf013147c
f0120843:	e8 43 07 fe ff       	call   f0100f8b <cprintf>
f0120848:	83 c4 10             	add    $0x10,%esp

}
f012084b:	90                   	nop
f012084c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f012084f:	c9                   	leave  
f0120850:	c3                   	ret    

f0120851 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120851:	55                   	push   %ebp
f0120852:	89 e5                	mov    %esp,%ebp
f0120854:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0120857:	8b 45 0c             	mov    0xc(%ebp),%eax
f012085a:	83 e0 01             	and    $0x1,%eax
f012085d:	85 c0                	test   %eax,%eax
f012085f:	74 03                	je     f0120864 <initialize_dynamic_allocator+0x13>
f0120861:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f0120864:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120868:	0f 84 c7 01 00 00    	je     f0120a35 <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f012086e:	c7 05 94 13 6c f0 01 	movl   $0x1,0xf06c1394
f0120875:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0120878:	8b 55 08             	mov    0x8(%ebp),%edx
f012087b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012087e:	01 d0                	add    %edx,%eax
f0120880:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0120885:	0f 87 ad 01 00 00    	ja     f0120a38 <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f012088b:	8b 45 08             	mov    0x8(%ebp),%eax
f012088e:	85 c0                	test   %eax,%eax
f0120890:	0f 89 a5 01 00 00    	jns    f0120a3b <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f0120896:	8b 55 08             	mov    0x8(%ebp),%edx
f0120899:	8b 45 0c             	mov    0xc(%ebp),%eax
f012089c:	01 d0                	add    %edx,%eax
f012089e:	83 e8 04             	sub    $0x4,%eax
f01208a1:	a3 54 2d 6c f0       	mov    %eax,0xf06c2d54
     struct BlockElement * element = NULL;
f01208a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f01208ad:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01208b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01208b5:	e9 87 00 00 00       	jmp    f0120941 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f01208ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208be:	75 14                	jne    f01208d4 <initialize_dynamic_allocator+0x83>
f01208c0:	83 ec 04             	sub    $0x4,%esp
f01208c3:	68 d7 14 13 f0       	push   $0xf01314d7
f01208c8:	6a 79                	push   $0x79
f01208ca:	68 f5 14 13 f0       	push   $0xf01314f5
f01208cf:	e8 65 fa fd ff       	call   f0100339 <_panic>
f01208d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208d7:	8b 00                	mov    (%eax),%eax
f01208d9:	85 c0                	test   %eax,%eax
f01208db:	74 10                	je     f01208ed <initialize_dynamic_allocator+0x9c>
f01208dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208e0:	8b 00                	mov    (%eax),%eax
f01208e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01208e5:	8b 52 04             	mov    0x4(%edx),%edx
f01208e8:	89 50 04             	mov    %edx,0x4(%eax)
f01208eb:	eb 0b                	jmp    f01208f8 <initialize_dynamic_allocator+0xa7>
f01208ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208f0:	8b 40 04             	mov    0x4(%eax),%eax
f01208f3:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01208f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208fb:	8b 40 04             	mov    0x4(%eax),%eax
f01208fe:	85 c0                	test   %eax,%eax
f0120900:	74 0f                	je     f0120911 <initialize_dynamic_allocator+0xc0>
f0120902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120905:	8b 40 04             	mov    0x4(%eax),%eax
f0120908:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012090b:	8b 12                	mov    (%edx),%edx
f012090d:	89 10                	mov    %edx,(%eax)
f012090f:	eb 0a                	jmp    f012091b <initialize_dynamic_allocator+0xca>
f0120911:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120914:	8b 00                	mov    (%eax),%eax
f0120916:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012091b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012091e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120924:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120927:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012092e:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120933:	48                   	dec    %eax
f0120934:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f0120939:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f012093e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120941:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120945:	74 07                	je     f012094e <initialize_dynamic_allocator+0xfd>
f0120947:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012094a:	8b 00                	mov    (%eax),%eax
f012094c:	eb 05                	jmp    f0120953 <initialize_dynamic_allocator+0x102>
f012094e:	b8 00 00 00 00       	mov    $0x0,%eax
f0120953:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0120958:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f012095d:	85 c0                	test   %eax,%eax
f012095f:	0f 85 55 ff ff ff    	jne    f01208ba <initialize_dynamic_allocator+0x69>
f0120965:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120969:	0f 85 4b ff ff ff    	jne    f01208ba <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f012096f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120972:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f0120975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120978:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f012097e:	a1 54 2d 6c f0       	mov    0xf06c2d54,%eax
f0120983:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
    end_block->info = 1;
f0120988:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f012098d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0120993:	8b 45 08             	mov    0x8(%ebp),%eax
f0120996:	83 c0 08             	add    $0x8,%eax
f0120999:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f012099c:	8b 45 08             	mov    0x8(%ebp),%eax
f012099f:	83 c0 04             	add    $0x4,%eax
f01209a2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01209a5:	83 ea 08             	sub    $0x8,%edx
f01209a8:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01209aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01209ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01209b0:	01 d0                	add    %edx,%eax
f01209b2:	83 e8 08             	sub    $0x8,%eax
f01209b5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01209b8:	83 ea 08             	sub    $0x8,%edx
f01209bb:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f01209bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f01209c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209c9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f01209d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01209d4:	75 17                	jne    f01209ed <initialize_dynamic_allocator+0x19c>
f01209d6:	83 ec 04             	sub    $0x4,%esp
f01209d9:	68 10 15 13 f0       	push   $0xf0131510
f01209de:	68 90 00 00 00       	push   $0x90
f01209e3:	68 f5 14 13 f0       	push   $0xf01314f5
f01209e8:	e8 4c f9 fd ff       	call   f0100339 <_panic>
f01209ed:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f01209f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209f6:	89 10                	mov    %edx,(%eax)
f01209f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209fb:	8b 00                	mov    (%eax),%eax
f01209fd:	85 c0                	test   %eax,%eax
f01209ff:	74 0d                	je     f0120a0e <initialize_dynamic_allocator+0x1bd>
f0120a01:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120a06:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a09:	89 50 04             	mov    %edx,0x4(%eax)
f0120a0c:	eb 08                	jmp    f0120a16 <initialize_dynamic_allocator+0x1c5>
f0120a0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a11:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a19:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120a1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a21:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a28:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120a2d:	40                   	inc    %eax
f0120a2e:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120a33:	eb 07                	jmp    f0120a3c <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120a35:	90                   	nop
f0120a36:	eb 04                	jmp    f0120a3c <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f0120a38:	90                   	nop
f0120a39:	eb 01                	jmp    f0120a3c <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120a3b:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120a3c:	c9                   	leave  
f0120a3d:	c3                   	ret    

f0120a3e <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120a3e:	55                   	push   %ebp
f0120a3f:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120a41:	8b 45 10             	mov    0x10(%ebp),%eax
f0120a44:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120a47:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a4a:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a50:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120a52:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a55:	83 e8 04             	sub    $0x4,%eax
f0120a58:	8b 00                	mov    (%eax),%eax
f0120a5a:	83 e0 fe             	and    $0xfffffffe,%eax
f0120a5d:	8d 50 f8             	lea    -0x8(%eax),%edx
f0120a60:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a63:	01 c2                	add    %eax,%edx
f0120a65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a68:	89 02                	mov    %eax,(%edx)
}
f0120a6a:	90                   	nop
f0120a6b:	5d                   	pop    %ebp
f0120a6c:	c3                   	ret    

f0120a6d <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120a6d:	55                   	push   %ebp
f0120a6e:	89 e5                	mov    %esp,%ebp
f0120a70:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120a73:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a76:	83 e0 01             	and    $0x1,%eax
f0120a79:	85 c0                	test   %eax,%eax
f0120a7b:	74 03                	je     f0120a80 <alloc_block_FF+0x13>
f0120a7d:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120a80:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120a84:	77 07                	ja     f0120a8d <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120a86:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120a8d:	a1 94 13 6c f0       	mov    0xf06c1394,%eax
f0120a92:	85 c0                	test   %eax,%eax
f0120a94:	75 73                	jne    f0120b09 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120a96:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a99:	83 c0 10             	add    $0x10,%eax
f0120a9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120a9f:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120aa6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120aa9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120aac:	01 d0                	add    %edx,%eax
f0120aae:	48                   	dec    %eax
f0120aaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120ab2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120ab5:	ba 00 00 00 00       	mov    $0x0,%edx
f0120aba:	f7 75 ec             	divl   -0x14(%ebp)
f0120abd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120ac0:	29 d0                	sub    %edx,%eax
f0120ac2:	c1 e8 0c             	shr    $0xc,%eax
f0120ac5:	83 ec 0c             	sub    $0xc,%esp
f0120ac8:	50                   	push   %eax
f0120ac9:	e8 0d 89 fe ff       	call   f01093db <sbrk>
f0120ace:	83 c4 10             	add    $0x10,%esp
f0120ad1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120ad4:	83 ec 0c             	sub    $0xc,%esp
f0120ad7:	6a 00                	push   $0x0
f0120ad9:	e8 fd 88 fe ff       	call   f01093db <sbrk>
f0120ade:	83 c4 10             	add    $0x10,%esp
f0120ae1:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120ae4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120ae7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120aea:	83 ec 08             	sub    $0x8,%esp
f0120aed:	50                   	push   %eax
f0120aee:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120af1:	e8 5b fd ff ff       	call   f0120851 <initialize_dynamic_allocator>
f0120af6:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120af9:	83 ec 0c             	sub    $0xc,%esp
f0120afc:	68 33 15 13 f0       	push   $0xf0131533
f0120b01:	e8 85 04 fe ff       	call   f0100f8b <cprintf>
f0120b06:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120b09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120b0d:	75 0a                	jne    f0120b19 <alloc_block_FF+0xac>
	        return NULL;
f0120b0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0120b14:	e9 0e 04 00 00       	jmp    f0120f27 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120b19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120b20:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120b28:	e9 f3 02 00 00       	jmp    f0120e20 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b30:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120b33:	83 ec 0c             	sub    $0xc,%esp
f0120b36:	ff 75 bc             	pushl  -0x44(%ebp)
f0120b39:	e8 af fb ff ff       	call   f01206ed <get_block_size>
f0120b3e:	83 c4 10             	add    $0x10,%esp
f0120b41:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120b44:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b47:	83 c0 08             	add    $0x8,%eax
f0120b4a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120b4d:	0f 87 c5 02 00 00    	ja     f0120e18 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120b53:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b56:	83 c0 18             	add    $0x18,%eax
f0120b59:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120b5c:	0f 87 19 02 00 00    	ja     f0120d7b <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120b62:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120b65:	2b 45 08             	sub    0x8(%ebp),%eax
f0120b68:	83 e8 08             	sub    $0x8,%eax
f0120b6b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120b6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b71:	8d 50 08             	lea    0x8(%eax),%edx
f0120b74:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120b77:	01 d0                	add    %edx,%eax
f0120b79:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120b7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b7f:	83 c0 08             	add    $0x8,%eax
f0120b82:	83 ec 04             	sub    $0x4,%esp
f0120b85:	6a 01                	push   $0x1
f0120b87:	50                   	push   %eax
f0120b88:	ff 75 bc             	pushl  -0x44(%ebp)
f0120b8b:	e8 ae fe ff ff       	call   f0120a3e <set_block_data>
f0120b90:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b96:	8b 40 04             	mov    0x4(%eax),%eax
f0120b99:	85 c0                	test   %eax,%eax
f0120b9b:	75 68                	jne    f0120c05 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b9d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120ba1:	75 17                	jne    f0120bba <alloc_block_FF+0x14d>
f0120ba3:	83 ec 04             	sub    $0x4,%esp
f0120ba6:	68 10 15 13 f0       	push   $0xf0131510
f0120bab:	68 d7 00 00 00       	push   $0xd7
f0120bb0:	68 f5 14 13 f0       	push   $0xf01314f5
f0120bb5:	e8 7f f7 fd ff       	call   f0100339 <_panic>
f0120bba:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0120bc0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bc3:	89 10                	mov    %edx,(%eax)
f0120bc5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bc8:	8b 00                	mov    (%eax),%eax
f0120bca:	85 c0                	test   %eax,%eax
f0120bcc:	74 0d                	je     f0120bdb <alloc_block_FF+0x16e>
f0120bce:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120bd3:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120bd6:	89 50 04             	mov    %edx,0x4(%eax)
f0120bd9:	eb 08                	jmp    f0120be3 <alloc_block_FF+0x176>
f0120bdb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bde:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120be3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120be6:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120beb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120bee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120bf5:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120bfa:	40                   	inc    %eax
f0120bfb:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120c00:	e9 dc 00 00 00       	jmp    f0120ce1 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120c05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c08:	8b 00                	mov    (%eax),%eax
f0120c0a:	85 c0                	test   %eax,%eax
f0120c0c:	75 65                	jne    f0120c73 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120c0e:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120c12:	75 17                	jne    f0120c2b <alloc_block_FF+0x1be>
f0120c14:	83 ec 04             	sub    $0x4,%esp
f0120c17:	68 44 15 13 f0       	push   $0xf0131544
f0120c1c:	68 db 00 00 00       	push   $0xdb
f0120c21:	68 f5 14 13 f0       	push   $0xf01314f5
f0120c26:	e8 0e f7 fd ff       	call   f0100339 <_panic>
f0120c2b:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0120c31:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c34:	89 50 04             	mov    %edx,0x4(%eax)
f0120c37:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c3a:	8b 40 04             	mov    0x4(%eax),%eax
f0120c3d:	85 c0                	test   %eax,%eax
f0120c3f:	74 0c                	je     f0120c4d <alloc_block_FF+0x1e0>
f0120c41:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0120c46:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c49:	89 10                	mov    %edx,(%eax)
f0120c4b:	eb 08                	jmp    f0120c55 <alloc_block_FF+0x1e8>
f0120c4d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c50:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120c55:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c58:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120c5d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c66:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120c6b:	40                   	inc    %eax
f0120c6c:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120c71:	eb 6e                	jmp    f0120ce1 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120c73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c77:	74 06                	je     f0120c7f <alloc_block_FF+0x212>
f0120c79:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120c7d:	75 17                	jne    f0120c96 <alloc_block_FF+0x229>
f0120c7f:	83 ec 04             	sub    $0x4,%esp
f0120c82:	68 68 15 13 f0       	push   $0xf0131568
f0120c87:	68 df 00 00 00       	push   $0xdf
f0120c8c:	68 f5 14 13 f0       	push   $0xf01314f5
f0120c91:	e8 a3 f6 fd ff       	call   f0100339 <_panic>
f0120c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c99:	8b 10                	mov    (%eax),%edx
f0120c9b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c9e:	89 10                	mov    %edx,(%eax)
f0120ca0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ca3:	8b 00                	mov    (%eax),%eax
f0120ca5:	85 c0                	test   %eax,%eax
f0120ca7:	74 0b                	je     f0120cb4 <alloc_block_FF+0x247>
f0120ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cac:	8b 00                	mov    (%eax),%eax
f0120cae:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120cb1:	89 50 04             	mov    %edx,0x4(%eax)
f0120cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cb7:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120cba:	89 10                	mov    %edx,(%eax)
f0120cbc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120cc2:	89 50 04             	mov    %edx,0x4(%eax)
f0120cc5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cc8:	8b 00                	mov    (%eax),%eax
f0120cca:	85 c0                	test   %eax,%eax
f0120ccc:	75 08                	jne    f0120cd6 <alloc_block_FF+0x269>
f0120cce:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cd1:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120cd6:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120cdb:	40                   	inc    %eax
f0120cdc:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ce5:	75 17                	jne    f0120cfe <alloc_block_FF+0x291>
f0120ce7:	83 ec 04             	sub    $0x4,%esp
f0120cea:	68 d7 14 13 f0       	push   $0xf01314d7
f0120cef:	68 e1 00 00 00       	push   $0xe1
f0120cf4:	68 f5 14 13 f0       	push   $0xf01314f5
f0120cf9:	e8 3b f6 fd ff       	call   f0100339 <_panic>
f0120cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d01:	8b 00                	mov    (%eax),%eax
f0120d03:	85 c0                	test   %eax,%eax
f0120d05:	74 10                	je     f0120d17 <alloc_block_FF+0x2aa>
f0120d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d0a:	8b 00                	mov    (%eax),%eax
f0120d0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d0f:	8b 52 04             	mov    0x4(%edx),%edx
f0120d12:	89 50 04             	mov    %edx,0x4(%eax)
f0120d15:	eb 0b                	jmp    f0120d22 <alloc_block_FF+0x2b5>
f0120d17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d1a:	8b 40 04             	mov    0x4(%eax),%eax
f0120d1d:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120d22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d25:	8b 40 04             	mov    0x4(%eax),%eax
f0120d28:	85 c0                	test   %eax,%eax
f0120d2a:	74 0f                	je     f0120d3b <alloc_block_FF+0x2ce>
f0120d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d2f:	8b 40 04             	mov    0x4(%eax),%eax
f0120d32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d35:	8b 12                	mov    (%edx),%edx
f0120d37:	89 10                	mov    %edx,(%eax)
f0120d39:	eb 0a                	jmp    f0120d45 <alloc_block_FF+0x2d8>
f0120d3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d3e:	8b 00                	mov    (%eax),%eax
f0120d40:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d48:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120d4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d51:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d58:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120d5d:	48                   	dec    %eax
f0120d5e:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				set_block_data(new_block_va, remaining_size, 0);
f0120d63:	83 ec 04             	sub    $0x4,%esp
f0120d66:	6a 00                	push   $0x0
f0120d68:	ff 75 b4             	pushl  -0x4c(%ebp)
f0120d6b:	ff 75 b0             	pushl  -0x50(%ebp)
f0120d6e:	e8 cb fc ff ff       	call   f0120a3e <set_block_data>
f0120d73:	83 c4 10             	add    $0x10,%esp
f0120d76:	e9 95 00 00 00       	jmp    f0120e10 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0120d7b:	83 ec 04             	sub    $0x4,%esp
f0120d7e:	6a 01                	push   $0x1
f0120d80:	ff 75 b8             	pushl  -0x48(%ebp)
f0120d83:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d86:	e8 b3 fc ff ff       	call   f0120a3e <set_block_data>
f0120d8b:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120d8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d92:	75 17                	jne    f0120dab <alloc_block_FF+0x33e>
f0120d94:	83 ec 04             	sub    $0x4,%esp
f0120d97:	68 d7 14 13 f0       	push   $0xf01314d7
f0120d9c:	68 e8 00 00 00       	push   $0xe8
f0120da1:	68 f5 14 13 f0       	push   $0xf01314f5
f0120da6:	e8 8e f5 fd ff       	call   f0100339 <_panic>
f0120dab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dae:	8b 00                	mov    (%eax),%eax
f0120db0:	85 c0                	test   %eax,%eax
f0120db2:	74 10                	je     f0120dc4 <alloc_block_FF+0x357>
f0120db4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120db7:	8b 00                	mov    (%eax),%eax
f0120db9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120dbc:	8b 52 04             	mov    0x4(%edx),%edx
f0120dbf:	89 50 04             	mov    %edx,0x4(%eax)
f0120dc2:	eb 0b                	jmp    f0120dcf <alloc_block_FF+0x362>
f0120dc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dc7:	8b 40 04             	mov    0x4(%eax),%eax
f0120dca:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dd2:	8b 40 04             	mov    0x4(%eax),%eax
f0120dd5:	85 c0                	test   %eax,%eax
f0120dd7:	74 0f                	je     f0120de8 <alloc_block_FF+0x37b>
f0120dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ddc:	8b 40 04             	mov    0x4(%eax),%eax
f0120ddf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120de2:	8b 12                	mov    (%edx),%edx
f0120de4:	89 10                	mov    %edx,(%eax)
f0120de6:	eb 0a                	jmp    f0120df2 <alloc_block_FF+0x385>
f0120de8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120deb:	8b 00                	mov    (%eax),%eax
f0120ded:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120df2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120df5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120dfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dfe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120e05:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120e0a:	48                   	dec    %eax
f0120e0b:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
	            }
	            return va;
f0120e10:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120e13:	e9 0f 01 00 00       	jmp    f0120f27 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120e18:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0120e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120e20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120e24:	74 07                	je     f0120e2d <alloc_block_FF+0x3c0>
f0120e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e29:	8b 00                	mov    (%eax),%eax
f0120e2b:	eb 05                	jmp    f0120e32 <alloc_block_FF+0x3c5>
f0120e2d:	b8 00 00 00 00       	mov    $0x0,%eax
f0120e32:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0120e37:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0120e3c:	85 c0                	test   %eax,%eax
f0120e3e:	0f 85 e9 fc ff ff    	jne    f0120b2d <alloc_block_FF+0xc0>
f0120e44:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120e48:	0f 85 df fc ff ff    	jne    f0120b2d <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0120e4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e51:	83 c0 08             	add    $0x8,%eax
f0120e54:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120e57:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0120e5e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120e61:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120e64:	01 d0                	add    %edx,%eax
f0120e66:	48                   	dec    %eax
f0120e67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0120e6a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120e6d:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e72:	f7 75 d8             	divl   -0x28(%ebp)
f0120e75:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120e78:	29 d0                	sub    %edx,%eax
f0120e7a:	c1 e8 0c             	shr    $0xc,%eax
f0120e7d:	83 ec 0c             	sub    $0xc,%esp
f0120e80:	50                   	push   %eax
f0120e81:	e8 55 85 fe ff       	call   f01093db <sbrk>
f0120e86:	83 c4 10             	add    $0x10,%esp
f0120e89:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0120e8c:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0120e90:	75 0a                	jne    f0120e9c <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0120e92:	b8 00 00 00 00       	mov    $0x0,%eax
f0120e97:	e9 8b 00 00 00       	jmp    f0120f27 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120e9c:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0120ea3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120ea6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120ea9:	01 d0                	add    %edx,%eax
f0120eab:	48                   	dec    %eax
f0120eac:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120eaf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120eb2:	ba 00 00 00 00       	mov    $0x0,%edx
f0120eb7:	f7 75 cc             	divl   -0x34(%ebp)
f0120eba:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120ebd:	29 d0                	sub    %edx,%eax
f0120ebf:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120ec2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120ec5:	01 d0                	add    %edx,%eax
f0120ec7:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
			end_block->info = 1;
f0120ecc:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f0120ed1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120ed7:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120ede:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120ee1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120ee4:	01 d0                	add    %edx,%eax
f0120ee6:	48                   	dec    %eax
f0120ee7:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120eea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120eed:	ba 00 00 00 00       	mov    $0x0,%edx
f0120ef2:	f7 75 c4             	divl   -0x3c(%ebp)
f0120ef5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120ef8:	29 d0                	sub    %edx,%eax
f0120efa:	83 ec 04             	sub    $0x4,%esp
f0120efd:	6a 01                	push   $0x1
f0120eff:	50                   	push   %eax
f0120f00:	ff 75 d0             	pushl  -0x30(%ebp)
f0120f03:	e8 36 fb ff ff       	call   f0120a3e <set_block_data>
f0120f08:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0120f0b:	83 ec 0c             	sub    $0xc,%esp
f0120f0e:	ff 75 d0             	pushl  -0x30(%ebp)
f0120f11:	e8 1b 0a 00 00       	call   f0121931 <free_block>
f0120f16:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0120f19:	83 ec 0c             	sub    $0xc,%esp
f0120f1c:	ff 75 08             	pushl  0x8(%ebp)
f0120f1f:	e8 49 fb ff ff       	call   f0120a6d <alloc_block_FF>
f0120f24:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0120f27:	c9                   	leave  
f0120f28:	c3                   	ret    

f0120f29 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0120f29:	55                   	push   %ebp
f0120f2a:	89 e5                	mov    %esp,%ebp
f0120f2c:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120f2f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f32:	83 e0 01             	and    $0x1,%eax
f0120f35:	85 c0                	test   %eax,%eax
f0120f37:	74 03                	je     f0120f3c <alloc_block_BF+0x13>
f0120f39:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120f3c:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120f40:	77 07                	ja     f0120f49 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120f42:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120f49:	a1 94 13 6c f0       	mov    0xf06c1394,%eax
f0120f4e:	85 c0                	test   %eax,%eax
f0120f50:	75 73                	jne    f0120fc5 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120f52:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f55:	83 c0 10             	add    $0x10,%eax
f0120f58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120f5b:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0120f62:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120f65:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120f68:	01 d0                	add    %edx,%eax
f0120f6a:	48                   	dec    %eax
f0120f6b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120f6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f71:	ba 00 00 00 00       	mov    $0x0,%edx
f0120f76:	f7 75 e0             	divl   -0x20(%ebp)
f0120f79:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f7c:	29 d0                	sub    %edx,%eax
f0120f7e:	c1 e8 0c             	shr    $0xc,%eax
f0120f81:	83 ec 0c             	sub    $0xc,%esp
f0120f84:	50                   	push   %eax
f0120f85:	e8 51 84 fe ff       	call   f01093db <sbrk>
f0120f8a:	83 c4 10             	add    $0x10,%esp
f0120f8d:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120f90:	83 ec 0c             	sub    $0xc,%esp
f0120f93:	6a 00                	push   $0x0
f0120f95:	e8 41 84 fe ff       	call   f01093db <sbrk>
f0120f9a:	83 c4 10             	add    $0x10,%esp
f0120f9d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120fa0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120fa3:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0120fa6:	83 ec 08             	sub    $0x8,%esp
f0120fa9:	50                   	push   %eax
f0120faa:	ff 75 d8             	pushl  -0x28(%ebp)
f0120fad:	e8 9f f8 ff ff       	call   f0120851 <initialize_dynamic_allocator>
f0120fb2:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120fb5:	83 ec 0c             	sub    $0xc,%esp
f0120fb8:	68 33 15 13 f0       	push   $0xf0131533
f0120fbd:	e8 c9 ff fd ff       	call   f0100f8b <cprintf>
f0120fc2:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0120fc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0120fcc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0120fd3:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0120fda:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120fe1:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120fe6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120fe9:	e9 1d 01 00 00       	jmp    f012110b <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120fee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ff1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0120ff4:	83 ec 0c             	sub    $0xc,%esp
f0120ff7:	ff 75 a8             	pushl  -0x58(%ebp)
f0120ffa:	e8 ee f6 ff ff       	call   f01206ed <get_block_size>
f0120fff:	83 c4 10             	add    $0x10,%esp
f0121002:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0121005:	8b 45 08             	mov    0x8(%ebp),%eax
f0121008:	83 c0 08             	add    $0x8,%eax
f012100b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012100e:	0f 87 ef 00 00 00    	ja     f0121103 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0121014:	8b 45 08             	mov    0x8(%ebp),%eax
f0121017:	83 c0 18             	add    $0x18,%eax
f012101a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012101d:	77 1d                	ja     f012103c <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f012101f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121022:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121025:	0f 86 d8 00 00 00    	jbe    f0121103 <alloc_block_BF+0x1da>
				{
					best_va = va;
f012102b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012102e:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0121031:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121034:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121037:	e9 c7 00 00 00       	jmp    f0121103 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f012103c:	8b 45 08             	mov    0x8(%ebp),%eax
f012103f:	83 c0 08             	add    $0x8,%eax
f0121042:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121045:	0f 85 9d 00 00 00    	jne    f01210e8 <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f012104b:	83 ec 04             	sub    $0x4,%esp
f012104e:	6a 01                	push   $0x1
f0121050:	ff 75 a4             	pushl  -0x5c(%ebp)
f0121053:	ff 75 a8             	pushl  -0x58(%ebp)
f0121056:	e8 e3 f9 ff ff       	call   f0120a3e <set_block_data>
f012105b:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f012105e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121062:	75 17                	jne    f012107b <alloc_block_BF+0x152>
f0121064:	83 ec 04             	sub    $0x4,%esp
f0121067:	68 d7 14 13 f0       	push   $0xf01314d7
f012106c:	68 2c 01 00 00       	push   $0x12c
f0121071:	68 f5 14 13 f0       	push   $0xf01314f5
f0121076:	e8 be f2 fd ff       	call   f0100339 <_panic>
f012107b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012107e:	8b 00                	mov    (%eax),%eax
f0121080:	85 c0                	test   %eax,%eax
f0121082:	74 10                	je     f0121094 <alloc_block_BF+0x16b>
f0121084:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121087:	8b 00                	mov    (%eax),%eax
f0121089:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012108c:	8b 52 04             	mov    0x4(%edx),%edx
f012108f:	89 50 04             	mov    %edx,0x4(%eax)
f0121092:	eb 0b                	jmp    f012109f <alloc_block_BF+0x176>
f0121094:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121097:	8b 40 04             	mov    0x4(%eax),%eax
f012109a:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012109f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210a2:	8b 40 04             	mov    0x4(%eax),%eax
f01210a5:	85 c0                	test   %eax,%eax
f01210a7:	74 0f                	je     f01210b8 <alloc_block_BF+0x18f>
f01210a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210ac:	8b 40 04             	mov    0x4(%eax),%eax
f01210af:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01210b2:	8b 12                	mov    (%edx),%edx
f01210b4:	89 10                	mov    %edx,(%eax)
f01210b6:	eb 0a                	jmp    f01210c2 <alloc_block_BF+0x199>
f01210b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210bb:	8b 00                	mov    (%eax),%eax
f01210bd:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01210c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01210cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210ce:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01210d5:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01210da:	48                   	dec    %eax
f01210db:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
					return va;
f01210e0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01210e3:	e9 24 04 00 00       	jmp    f012150c <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f01210e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01210eb:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01210ee:	76 13                	jbe    f0121103 <alloc_block_BF+0x1da>
					{
						internal = 1;
f01210f0:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f01210f7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01210fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f01210fd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121100:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f0121103:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121108:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012110b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012110f:	74 07                	je     f0121118 <alloc_block_BF+0x1ef>
f0121111:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121114:	8b 00                	mov    (%eax),%eax
f0121116:	eb 05                	jmp    f012111d <alloc_block_BF+0x1f4>
f0121118:	b8 00 00 00 00       	mov    $0x0,%eax
f012111d:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0121122:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121127:	85 c0                	test   %eax,%eax
f0121129:	0f 85 bf fe ff ff    	jne    f0120fee <alloc_block_BF+0xc5>
f012112f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121133:	0f 85 b5 fe ff ff    	jne    f0120fee <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0121139:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012113d:	0f 84 26 02 00 00    	je     f0121369 <alloc_block_BF+0x440>
f0121143:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0121147:	0f 85 1c 02 00 00    	jne    f0121369 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f012114d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121150:	2b 45 08             	sub    0x8(%ebp),%eax
f0121153:	83 e8 08             	sub    $0x8,%eax
f0121156:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0121159:	8b 45 08             	mov    0x8(%ebp),%eax
f012115c:	8d 50 08             	lea    0x8(%eax),%edx
f012115f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121162:	01 d0                	add    %edx,%eax
f0121164:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0121167:	8b 45 08             	mov    0x8(%ebp),%eax
f012116a:	83 c0 08             	add    $0x8,%eax
f012116d:	83 ec 04             	sub    $0x4,%esp
f0121170:	6a 01                	push   $0x1
f0121172:	50                   	push   %eax
f0121173:	ff 75 f0             	pushl  -0x10(%ebp)
f0121176:	e8 c3 f8 ff ff       	call   f0120a3e <set_block_data>
f012117b:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f012117e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121181:	8b 40 04             	mov    0x4(%eax),%eax
f0121184:	85 c0                	test   %eax,%eax
f0121186:	75 68                	jne    f01211f0 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121188:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f012118c:	75 17                	jne    f01211a5 <alloc_block_BF+0x27c>
f012118e:	83 ec 04             	sub    $0x4,%esp
f0121191:	68 10 15 13 f0       	push   $0xf0131510
f0121196:	68 45 01 00 00       	push   $0x145
f012119b:	68 f5 14 13 f0       	push   $0xf01314f5
f01211a0:	e8 94 f1 fd ff       	call   f0100339 <_panic>
f01211a5:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f01211ab:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211ae:	89 10                	mov    %edx,(%eax)
f01211b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211b3:	8b 00                	mov    (%eax),%eax
f01211b5:	85 c0                	test   %eax,%eax
f01211b7:	74 0d                	je     f01211c6 <alloc_block_BF+0x29d>
f01211b9:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01211be:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01211c1:	89 50 04             	mov    %edx,0x4(%eax)
f01211c4:	eb 08                	jmp    f01211ce <alloc_block_BF+0x2a5>
f01211c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211c9:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01211ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211d1:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01211d6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211d9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01211e0:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01211e5:	40                   	inc    %eax
f01211e6:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f01211eb:	e9 dc 00 00 00       	jmp    f01212cc <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f01211f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211f3:	8b 00                	mov    (%eax),%eax
f01211f5:	85 c0                	test   %eax,%eax
f01211f7:	75 65                	jne    f012125e <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f01211f9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01211fd:	75 17                	jne    f0121216 <alloc_block_BF+0x2ed>
f01211ff:	83 ec 04             	sub    $0x4,%esp
f0121202:	68 44 15 13 f0       	push   $0xf0131544
f0121207:	68 4a 01 00 00       	push   $0x14a
f012120c:	68 f5 14 13 f0       	push   $0xf01314f5
f0121211:	e8 23 f1 fd ff       	call   f0100339 <_panic>
f0121216:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f012121c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012121f:	89 50 04             	mov    %edx,0x4(%eax)
f0121222:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121225:	8b 40 04             	mov    0x4(%eax),%eax
f0121228:	85 c0                	test   %eax,%eax
f012122a:	74 0c                	je     f0121238 <alloc_block_BF+0x30f>
f012122c:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121231:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121234:	89 10                	mov    %edx,(%eax)
f0121236:	eb 08                	jmp    f0121240 <alloc_block_BF+0x317>
f0121238:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012123b:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121240:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121243:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121248:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012124b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121251:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121256:	40                   	inc    %eax
f0121257:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f012125c:	eb 6e                	jmp    f01212cc <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f012125e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121262:	74 06                	je     f012126a <alloc_block_BF+0x341>
f0121264:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121268:	75 17                	jne    f0121281 <alloc_block_BF+0x358>
f012126a:	83 ec 04             	sub    $0x4,%esp
f012126d:	68 68 15 13 f0       	push   $0xf0131568
f0121272:	68 4f 01 00 00       	push   $0x14f
f0121277:	68 f5 14 13 f0       	push   $0xf01314f5
f012127c:	e8 b8 f0 fd ff       	call   f0100339 <_panic>
f0121281:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121284:	8b 10                	mov    (%eax),%edx
f0121286:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121289:	89 10                	mov    %edx,(%eax)
f012128b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012128e:	8b 00                	mov    (%eax),%eax
f0121290:	85 c0                	test   %eax,%eax
f0121292:	74 0b                	je     f012129f <alloc_block_BF+0x376>
f0121294:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121297:	8b 00                	mov    (%eax),%eax
f0121299:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012129c:	89 50 04             	mov    %edx,0x4(%eax)
f012129f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212a2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01212a5:	89 10                	mov    %edx,(%eax)
f01212a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01212ad:	89 50 04             	mov    %edx,0x4(%eax)
f01212b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212b3:	8b 00                	mov    (%eax),%eax
f01212b5:	85 c0                	test   %eax,%eax
f01212b7:	75 08                	jne    f01212c1 <alloc_block_BF+0x398>
f01212b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212bc:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01212c1:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01212c6:	40                   	inc    %eax
f01212c7:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f01212cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01212d0:	75 17                	jne    f01212e9 <alloc_block_BF+0x3c0>
f01212d2:	83 ec 04             	sub    $0x4,%esp
f01212d5:	68 d7 14 13 f0       	push   $0xf01314d7
f01212da:	68 51 01 00 00       	push   $0x151
f01212df:	68 f5 14 13 f0       	push   $0xf01314f5
f01212e4:	e8 50 f0 fd ff       	call   f0100339 <_panic>
f01212e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212ec:	8b 00                	mov    (%eax),%eax
f01212ee:	85 c0                	test   %eax,%eax
f01212f0:	74 10                	je     f0121302 <alloc_block_BF+0x3d9>
f01212f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212f5:	8b 00                	mov    (%eax),%eax
f01212f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01212fa:	8b 52 04             	mov    0x4(%edx),%edx
f01212fd:	89 50 04             	mov    %edx,0x4(%eax)
f0121300:	eb 0b                	jmp    f012130d <alloc_block_BF+0x3e4>
f0121302:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121305:	8b 40 04             	mov    0x4(%eax),%eax
f0121308:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012130d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121310:	8b 40 04             	mov    0x4(%eax),%eax
f0121313:	85 c0                	test   %eax,%eax
f0121315:	74 0f                	je     f0121326 <alloc_block_BF+0x3fd>
f0121317:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012131a:	8b 40 04             	mov    0x4(%eax),%eax
f012131d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121320:	8b 12                	mov    (%edx),%edx
f0121322:	89 10                	mov    %edx,(%eax)
f0121324:	eb 0a                	jmp    f0121330 <alloc_block_BF+0x407>
f0121326:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121329:	8b 00                	mov    (%eax),%eax
f012132b:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121330:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121333:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121339:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012133c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121343:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121348:	48                   	dec    %eax
f0121349:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			set_block_data(new_block_va, remaining_size, 0);
f012134e:	83 ec 04             	sub    $0x4,%esp
f0121351:	6a 00                	push   $0x0
f0121353:	ff 75 d0             	pushl  -0x30(%ebp)
f0121356:	ff 75 cc             	pushl  -0x34(%ebp)
f0121359:	e8 e0 f6 ff ff       	call   f0120a3e <set_block_data>
f012135e:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0121361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121364:	e9 a3 01 00 00       	jmp    f012150c <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0121369:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f012136d:	0f 85 9d 00 00 00    	jne    f0121410 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f0121373:	83 ec 04             	sub    $0x4,%esp
f0121376:	6a 01                	push   $0x1
f0121378:	ff 75 ec             	pushl  -0x14(%ebp)
f012137b:	ff 75 f0             	pushl  -0x10(%ebp)
f012137e:	e8 bb f6 ff ff       	call   f0120a3e <set_block_data>
f0121383:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0121386:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012138a:	75 17                	jne    f01213a3 <alloc_block_BF+0x47a>
f012138c:	83 ec 04             	sub    $0x4,%esp
f012138f:	68 d7 14 13 f0       	push   $0xf01314d7
f0121394:	68 58 01 00 00       	push   $0x158
f0121399:	68 f5 14 13 f0       	push   $0xf01314f5
f012139e:	e8 96 ef fd ff       	call   f0100339 <_panic>
f01213a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213a6:	8b 00                	mov    (%eax),%eax
f01213a8:	85 c0                	test   %eax,%eax
f01213aa:	74 10                	je     f01213bc <alloc_block_BF+0x493>
f01213ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213af:	8b 00                	mov    (%eax),%eax
f01213b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01213b4:	8b 52 04             	mov    0x4(%edx),%edx
f01213b7:	89 50 04             	mov    %edx,0x4(%eax)
f01213ba:	eb 0b                	jmp    f01213c7 <alloc_block_BF+0x49e>
f01213bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213bf:	8b 40 04             	mov    0x4(%eax),%eax
f01213c2:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01213c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213ca:	8b 40 04             	mov    0x4(%eax),%eax
f01213cd:	85 c0                	test   %eax,%eax
f01213cf:	74 0f                	je     f01213e0 <alloc_block_BF+0x4b7>
f01213d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213d4:	8b 40 04             	mov    0x4(%eax),%eax
f01213d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01213da:	8b 12                	mov    (%edx),%edx
f01213dc:	89 10                	mov    %edx,(%eax)
f01213de:	eb 0a                	jmp    f01213ea <alloc_block_BF+0x4c1>
f01213e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213e3:	8b 00                	mov    (%eax),%eax
f01213e5:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01213ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01213f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213f6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01213fd:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121402:	48                   	dec    %eax
f0121403:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		return best_va;
f0121408:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012140b:	e9 fc 00 00 00       	jmp    f012150c <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0121410:	8b 45 08             	mov    0x8(%ebp),%eax
f0121413:	83 c0 08             	add    $0x8,%eax
f0121416:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0121419:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121420:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121423:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121426:	01 d0                	add    %edx,%eax
f0121428:	48                   	dec    %eax
f0121429:	89 45 c0             	mov    %eax,-0x40(%ebp)
f012142c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012142f:	ba 00 00 00 00       	mov    $0x0,%edx
f0121434:	f7 75 c4             	divl   -0x3c(%ebp)
f0121437:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012143a:	29 d0                	sub    %edx,%eax
f012143c:	c1 e8 0c             	shr    $0xc,%eax
f012143f:	83 ec 0c             	sub    $0xc,%esp
f0121442:	50                   	push   %eax
f0121443:	e8 93 7f fe ff       	call   f01093db <sbrk>
f0121448:	83 c4 10             	add    $0x10,%esp
f012144b:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f012144e:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0121452:	75 0a                	jne    f012145e <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f0121454:	b8 00 00 00 00       	mov    $0x0,%eax
f0121459:	e9 ae 00 00 00       	jmp    f012150c <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f012145e:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0121465:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121468:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012146b:	01 d0                	add    %edx,%eax
f012146d:	48                   	dec    %eax
f012146e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0121471:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0121474:	ba 00 00 00 00       	mov    $0x0,%edx
f0121479:	f7 75 b8             	divl   -0x48(%ebp)
f012147c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012147f:	29 d0                	sub    %edx,%eax
f0121481:	8d 50 fc             	lea    -0x4(%eax),%edx
f0121484:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121487:	01 d0                	add    %edx,%eax
f0121489:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
				end_block->info = 1;
f012148e:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f0121493:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0121499:	83 ec 0c             	sub    $0xc,%esp
f012149c:	68 9c 15 13 f0       	push   $0xf013159c
f01214a1:	e8 e5 fa fd ff       	call   f0100f8b <cprintf>
f01214a6:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f01214a9:	83 ec 08             	sub    $0x8,%esp
f01214ac:	ff 75 bc             	pushl  -0x44(%ebp)
f01214af:	68 a1 15 13 f0       	push   $0xf01315a1
f01214b4:	e8 d2 fa fd ff       	call   f0100f8b <cprintf>
f01214b9:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f01214bc:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f01214c3:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01214c6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01214c9:	01 d0                	add    %edx,%eax
f01214cb:	48                   	dec    %eax
f01214cc:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01214cf:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01214d2:	ba 00 00 00 00       	mov    $0x0,%edx
f01214d7:	f7 75 b0             	divl   -0x50(%ebp)
f01214da:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01214dd:	29 d0                	sub    %edx,%eax
f01214df:	83 ec 04             	sub    $0x4,%esp
f01214e2:	6a 01                	push   $0x1
f01214e4:	50                   	push   %eax
f01214e5:	ff 75 bc             	pushl  -0x44(%ebp)
f01214e8:	e8 51 f5 ff ff       	call   f0120a3e <set_block_data>
f01214ed:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f01214f0:	83 ec 0c             	sub    $0xc,%esp
f01214f3:	ff 75 bc             	pushl  -0x44(%ebp)
f01214f6:	e8 36 04 00 00       	call   f0121931 <free_block>
f01214fb:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f01214fe:	83 ec 0c             	sub    $0xc,%esp
f0121501:	ff 75 08             	pushl  0x8(%ebp)
f0121504:	e8 20 fa ff ff       	call   f0120f29 <alloc_block_BF>
f0121509:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f012150c:	c9                   	leave  
f012150d:	c3                   	ret    

f012150e <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f012150e:	55                   	push   %ebp
f012150f:	89 e5                	mov    %esp,%ebp
f0121511:	53                   	push   %ebx
f0121512:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f0121515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f012151c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0121523:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121527:	74 1e                	je     f0121547 <merging+0x39>
f0121529:	ff 75 08             	pushl  0x8(%ebp)
f012152c:	e8 bc f1 ff ff       	call   f01206ed <get_block_size>
f0121531:	83 c4 04             	add    $0x4,%esp
f0121534:	89 c2                	mov    %eax,%edx
f0121536:	8b 45 08             	mov    0x8(%ebp),%eax
f0121539:	01 d0                	add    %edx,%eax
f012153b:	3b 45 10             	cmp    0x10(%ebp),%eax
f012153e:	75 07                	jne    f0121547 <merging+0x39>
		prev_is_free = 1;
f0121540:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0121547:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012154b:	74 1e                	je     f012156b <merging+0x5d>
f012154d:	ff 75 10             	pushl  0x10(%ebp)
f0121550:	e8 98 f1 ff ff       	call   f01206ed <get_block_size>
f0121555:	83 c4 04             	add    $0x4,%esp
f0121558:	89 c2                	mov    %eax,%edx
f012155a:	8b 45 10             	mov    0x10(%ebp),%eax
f012155d:	01 d0                	add    %edx,%eax
f012155f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0121562:	75 07                	jne    f012156b <merging+0x5d>
		next_is_free = 1;
f0121564:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f012156b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012156f:	0f 84 cc 00 00 00    	je     f0121641 <merging+0x133>
f0121575:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121579:	0f 84 c2 00 00 00    	je     f0121641 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f012157f:	ff 75 08             	pushl  0x8(%ebp)
f0121582:	e8 66 f1 ff ff       	call   f01206ed <get_block_size>
f0121587:	83 c4 04             	add    $0x4,%esp
f012158a:	89 c3                	mov    %eax,%ebx
f012158c:	ff 75 10             	pushl  0x10(%ebp)
f012158f:	e8 59 f1 ff ff       	call   f01206ed <get_block_size>
f0121594:	83 c4 04             	add    $0x4,%esp
f0121597:	01 c3                	add    %eax,%ebx
f0121599:	ff 75 0c             	pushl  0xc(%ebp)
f012159c:	e8 4c f1 ff ff       	call   f01206ed <get_block_size>
f01215a1:	83 c4 04             	add    $0x4,%esp
f01215a4:	01 d8                	add    %ebx,%eax
f01215a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01215a9:	6a 00                	push   $0x0
f01215ab:	ff 75 ec             	pushl  -0x14(%ebp)
f01215ae:	ff 75 08             	pushl  0x8(%ebp)
f01215b1:	e8 88 f4 ff ff       	call   f0120a3e <set_block_data>
f01215b6:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f01215b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01215bd:	75 17                	jne    f01215d6 <merging+0xc8>
f01215bf:	83 ec 04             	sub    $0x4,%esp
f01215c2:	68 d7 14 13 f0       	push   $0xf01314d7
f01215c7:	68 7d 01 00 00       	push   $0x17d
f01215cc:	68 f5 14 13 f0       	push   $0xf01314f5
f01215d1:	e8 63 ed fd ff       	call   f0100339 <_panic>
f01215d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215d9:	8b 00                	mov    (%eax),%eax
f01215db:	85 c0                	test   %eax,%eax
f01215dd:	74 10                	je     f01215ef <merging+0xe1>
f01215df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215e2:	8b 00                	mov    (%eax),%eax
f01215e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01215e7:	8b 52 04             	mov    0x4(%edx),%edx
f01215ea:	89 50 04             	mov    %edx,0x4(%eax)
f01215ed:	eb 0b                	jmp    f01215fa <merging+0xec>
f01215ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215f2:	8b 40 04             	mov    0x4(%eax),%eax
f01215f5:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01215fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01215fd:	8b 40 04             	mov    0x4(%eax),%eax
f0121600:	85 c0                	test   %eax,%eax
f0121602:	74 0f                	je     f0121613 <merging+0x105>
f0121604:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121607:	8b 40 04             	mov    0x4(%eax),%eax
f012160a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012160d:	8b 12                	mov    (%edx),%edx
f012160f:	89 10                	mov    %edx,(%eax)
f0121611:	eb 0a                	jmp    f012161d <merging+0x10f>
f0121613:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121616:	8b 00                	mov    (%eax),%eax
f0121618:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012161d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121620:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121626:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121629:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121630:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121635:	48                   	dec    %eax
f0121636:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f012163b:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012163c:	e9 ea 02 00 00       	jmp    f012192b <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0121641:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121645:	74 3b                	je     f0121682 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0121647:	83 ec 0c             	sub    $0xc,%esp
f012164a:	ff 75 08             	pushl  0x8(%ebp)
f012164d:	e8 9b f0 ff ff       	call   f01206ed <get_block_size>
f0121652:	83 c4 10             	add    $0x10,%esp
f0121655:	89 c3                	mov    %eax,%ebx
f0121657:	83 ec 0c             	sub    $0xc,%esp
f012165a:	ff 75 10             	pushl  0x10(%ebp)
f012165d:	e8 8b f0 ff ff       	call   f01206ed <get_block_size>
f0121662:	83 c4 10             	add    $0x10,%esp
f0121665:	01 d8                	add    %ebx,%eax
f0121667:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f012166a:	83 ec 04             	sub    $0x4,%esp
f012166d:	6a 00                	push   $0x0
f012166f:	ff 75 e8             	pushl  -0x18(%ebp)
f0121672:	ff 75 08             	pushl  0x8(%ebp)
f0121675:	e8 c4 f3 ff ff       	call   f0120a3e <set_block_data>
f012167a:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012167d:	e9 a9 02 00 00       	jmp    f012192b <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0121682:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121686:	0f 84 2d 01 00 00    	je     f01217b9 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f012168c:	83 ec 0c             	sub    $0xc,%esp
f012168f:	ff 75 10             	pushl  0x10(%ebp)
f0121692:	e8 56 f0 ff ff       	call   f01206ed <get_block_size>
f0121697:	83 c4 10             	add    $0x10,%esp
f012169a:	89 c3                	mov    %eax,%ebx
f012169c:	83 ec 0c             	sub    $0xc,%esp
f012169f:	ff 75 0c             	pushl  0xc(%ebp)
f01216a2:	e8 46 f0 ff ff       	call   f01206ed <get_block_size>
f01216a7:	83 c4 10             	add    $0x10,%esp
f01216aa:	01 d8                	add    %ebx,%eax
f01216ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f01216af:	83 ec 04             	sub    $0x4,%esp
f01216b2:	6a 00                	push   $0x0
f01216b4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01216b7:	ff 75 10             	pushl  0x10(%ebp)
f01216ba:	e8 7f f3 ff ff       	call   f0120a3e <set_block_data>
f01216bf:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f01216c2:	8b 45 10             	mov    0x10(%ebp),%eax
f01216c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f01216c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01216cc:	74 06                	je     f01216d4 <merging+0x1c6>
f01216ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01216d2:	75 17                	jne    f01216eb <merging+0x1dd>
f01216d4:	83 ec 04             	sub    $0x4,%esp
f01216d7:	68 b0 15 13 f0       	push   $0xf01315b0
f01216dc:	68 8d 01 00 00       	push   $0x18d
f01216e1:	68 f5 14 13 f0       	push   $0xf01314f5
f01216e6:	e8 4e ec fd ff       	call   f0100339 <_panic>
f01216eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216ee:	8b 50 04             	mov    0x4(%eax),%edx
f01216f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01216f4:	89 50 04             	mov    %edx,0x4(%eax)
f01216f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01216fa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01216fd:	89 10                	mov    %edx,(%eax)
f01216ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121702:	8b 40 04             	mov    0x4(%eax),%eax
f0121705:	85 c0                	test   %eax,%eax
f0121707:	74 0d                	je     f0121716 <merging+0x208>
f0121709:	8b 45 0c             	mov    0xc(%ebp),%eax
f012170c:	8b 40 04             	mov    0x4(%eax),%eax
f012170f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121712:	89 10                	mov    %edx,(%eax)
f0121714:	eb 08                	jmp    f012171e <merging+0x210>
f0121716:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121719:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012171e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121721:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121724:	89 50 04             	mov    %edx,0x4(%eax)
f0121727:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f012172c:	40                   	inc    %eax
f012172d:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		LIST_REMOVE(&freeBlocksList, next_block);
f0121732:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121736:	75 17                	jne    f012174f <merging+0x241>
f0121738:	83 ec 04             	sub    $0x4,%esp
f012173b:	68 d7 14 13 f0       	push   $0xf01314d7
f0121740:	68 8e 01 00 00       	push   $0x18e
f0121745:	68 f5 14 13 f0       	push   $0xf01314f5
f012174a:	e8 ea eb fd ff       	call   f0100339 <_panic>
f012174f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121752:	8b 00                	mov    (%eax),%eax
f0121754:	85 c0                	test   %eax,%eax
f0121756:	74 10                	je     f0121768 <merging+0x25a>
f0121758:	8b 45 0c             	mov    0xc(%ebp),%eax
f012175b:	8b 00                	mov    (%eax),%eax
f012175d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121760:	8b 52 04             	mov    0x4(%edx),%edx
f0121763:	89 50 04             	mov    %edx,0x4(%eax)
f0121766:	eb 0b                	jmp    f0121773 <merging+0x265>
f0121768:	8b 45 0c             	mov    0xc(%ebp),%eax
f012176b:	8b 40 04             	mov    0x4(%eax),%eax
f012176e:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121773:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121776:	8b 40 04             	mov    0x4(%eax),%eax
f0121779:	85 c0                	test   %eax,%eax
f012177b:	74 0f                	je     f012178c <merging+0x27e>
f012177d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121780:	8b 40 04             	mov    0x4(%eax),%eax
f0121783:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121786:	8b 12                	mov    (%edx),%edx
f0121788:	89 10                	mov    %edx,(%eax)
f012178a:	eb 0a                	jmp    f0121796 <merging+0x288>
f012178c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012178f:	8b 00                	mov    (%eax),%eax
f0121791:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121796:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121799:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012179f:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217a2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01217a9:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01217ae:	48                   	dec    %eax
f01217af:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01217b4:	e9 72 01 00 00       	jmp    f012192b <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01217b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01217bc:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f01217bf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01217c3:	74 79                	je     f012183e <merging+0x330>
f01217c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01217c9:	74 73                	je     f012183e <merging+0x330>
f01217cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01217cf:	74 06                	je     f01217d7 <merging+0x2c9>
f01217d1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01217d5:	75 17                	jne    f01217ee <merging+0x2e0>
f01217d7:	83 ec 04             	sub    $0x4,%esp
f01217da:	68 68 15 13 f0       	push   $0xf0131568
f01217df:	68 94 01 00 00       	push   $0x194
f01217e4:	68 f5 14 13 f0       	push   $0xf01314f5
f01217e9:	e8 4b eb fd ff       	call   f0100339 <_panic>
f01217ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01217f1:	8b 10                	mov    (%eax),%edx
f01217f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217f6:	89 10                	mov    %edx,(%eax)
f01217f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217fb:	8b 00                	mov    (%eax),%eax
f01217fd:	85 c0                	test   %eax,%eax
f01217ff:	74 0b                	je     f012180c <merging+0x2fe>
f0121801:	8b 45 08             	mov    0x8(%ebp),%eax
f0121804:	8b 00                	mov    (%eax),%eax
f0121806:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121809:	89 50 04             	mov    %edx,0x4(%eax)
f012180c:	8b 45 08             	mov    0x8(%ebp),%eax
f012180f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121812:	89 10                	mov    %edx,(%eax)
f0121814:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121817:	8b 55 08             	mov    0x8(%ebp),%edx
f012181a:	89 50 04             	mov    %edx,0x4(%eax)
f012181d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121820:	8b 00                	mov    (%eax),%eax
f0121822:	85 c0                	test   %eax,%eax
f0121824:	75 08                	jne    f012182e <merging+0x320>
f0121826:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121829:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012182e:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121833:	40                   	inc    %eax
f0121834:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121839:	e9 ce 00 00 00       	jmp    f012190c <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f012183e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121842:	74 65                	je     f01218a9 <merging+0x39b>
f0121844:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121848:	75 17                	jne    f0121861 <merging+0x353>
f012184a:	83 ec 04             	sub    $0x4,%esp
f012184d:	68 44 15 13 f0       	push   $0xf0131544
f0121852:	68 95 01 00 00       	push   $0x195
f0121857:	68 f5 14 13 f0       	push   $0xf01314f5
f012185c:	e8 d8 ea fd ff       	call   f0100339 <_panic>
f0121861:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0121867:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012186a:	89 50 04             	mov    %edx,0x4(%eax)
f012186d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121870:	8b 40 04             	mov    0x4(%eax),%eax
f0121873:	85 c0                	test   %eax,%eax
f0121875:	74 0c                	je     f0121883 <merging+0x375>
f0121877:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f012187c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012187f:	89 10                	mov    %edx,(%eax)
f0121881:	eb 08                	jmp    f012188b <merging+0x37d>
f0121883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121886:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012188b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012188e:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121893:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121896:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012189c:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01218a1:	40                   	inc    %eax
f01218a2:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f01218a7:	eb 63                	jmp    f012190c <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01218a9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01218ad:	75 17                	jne    f01218c6 <merging+0x3b8>
f01218af:	83 ec 04             	sub    $0x4,%esp
f01218b2:	68 10 15 13 f0       	push   $0xf0131510
f01218b7:	68 98 01 00 00       	push   $0x198
f01218bc:	68 f5 14 13 f0       	push   $0xf01314f5
f01218c1:	e8 73 ea fd ff       	call   f0100339 <_panic>
f01218c6:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f01218cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218cf:	89 10                	mov    %edx,(%eax)
f01218d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218d4:	8b 00                	mov    (%eax),%eax
f01218d6:	85 c0                	test   %eax,%eax
f01218d8:	74 0d                	je     f01218e7 <merging+0x3d9>
f01218da:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01218df:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01218e2:	89 50 04             	mov    %edx,0x4(%eax)
f01218e5:	eb 08                	jmp    f01218ef <merging+0x3e1>
f01218e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218ea:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01218ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218f2:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01218f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121901:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121906:	40                   	inc    %eax
f0121907:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		}
		set_block_data(va, get_block_size(va), 0);
f012190c:	83 ec 0c             	sub    $0xc,%esp
f012190f:	ff 75 10             	pushl  0x10(%ebp)
f0121912:	e8 d6 ed ff ff       	call   f01206ed <get_block_size>
f0121917:	83 c4 10             	add    $0x10,%esp
f012191a:	83 ec 04             	sub    $0x4,%esp
f012191d:	6a 00                	push   $0x0
f012191f:	50                   	push   %eax
f0121920:	ff 75 10             	pushl  0x10(%ebp)
f0121923:	e8 16 f1 ff ff       	call   f0120a3e <set_block_data>
f0121928:	83 c4 10             	add    $0x10,%esp
	}
}
f012192b:	90                   	nop
f012192c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f012192f:	c9                   	leave  
f0121930:	c3                   	ret    

f0121931 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121931:	55                   	push   %ebp
f0121932:	89 e5                	mov    %esp,%ebp
f0121934:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0121937:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f012193c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f012193f:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121944:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121947:	73 1b                	jae    f0121964 <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0121949:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f012194e:	83 ec 04             	sub    $0x4,%esp
f0121951:	ff 75 08             	pushl  0x8(%ebp)
f0121954:	6a 00                	push   $0x0
f0121956:	50                   	push   %eax
f0121957:	e8 b2 fb ff ff       	call   f012150e <merging>
f012195c:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f012195f:	e9 8b 00 00 00       	jmp    f01219ef <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f0121964:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121969:	3b 45 08             	cmp    0x8(%ebp),%eax
f012196c:	76 18                	jbe    f0121986 <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f012196e:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121973:	83 ec 04             	sub    $0x4,%esp
f0121976:	ff 75 08             	pushl  0x8(%ebp)
f0121979:	50                   	push   %eax
f012197a:	6a 00                	push   $0x0
f012197c:	e8 8d fb ff ff       	call   f012150e <merging>
f0121981:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121984:	eb 69                	jmp    f01219ef <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121986:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f012198b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012198e:	eb 39                	jmp    f01219c9 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0121990:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121993:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121996:	73 29                	jae    f01219c1 <free_block+0x90>
f0121998:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012199b:	8b 00                	mov    (%eax),%eax
f012199d:	3b 45 08             	cmp    0x8(%ebp),%eax
f01219a0:	76 1f                	jbe    f01219c1 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01219a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219a5:	8b 00                	mov    (%eax),%eax
f01219a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01219aa:	83 ec 04             	sub    $0x4,%esp
f01219ad:	ff 75 08             	pushl  0x8(%ebp)
f01219b0:	ff 75 f0             	pushl  -0x10(%ebp)
f01219b3:	ff 75 f4             	pushl  -0xc(%ebp)
f01219b6:	e8 53 fb ff ff       	call   f012150e <merging>
f01219bb:	83 c4 10             	add    $0x10,%esp
			break;
f01219be:	90                   	nop
		}
	}
}
f01219bf:	eb 2e                	jmp    f01219ef <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01219c1:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f01219c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01219c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01219cd:	74 07                	je     f01219d6 <free_block+0xa5>
f01219cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219d2:	8b 00                	mov    (%eax),%eax
f01219d4:	eb 05                	jmp    f01219db <free_block+0xaa>
f01219d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01219db:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f01219e0:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f01219e5:	85 c0                	test   %eax,%eax
f01219e7:	75 a7                	jne    f0121990 <free_block+0x5f>
f01219e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01219ed:	75 a1                	jne    f0121990 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01219ef:	90                   	nop
f01219f0:	c9                   	leave  
f01219f1:	c3                   	ret    

f01219f2 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f01219f2:	55                   	push   %ebp
f01219f3:	89 e5                	mov    %esp,%ebp
f01219f5:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f01219f8:	ff 75 08             	pushl  0x8(%ebp)
f01219fb:	e8 ed ec ff ff       	call   f01206ed <get_block_size>
f0121a00:	83 c4 04             	add    $0x4,%esp
f0121a03:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121a06:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121a0d:	eb 17                	jmp    f0121a26 <copy_data+0x34>
f0121a0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a15:	01 c2                	add    %eax,%edx
f0121a17:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121a1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a1d:	01 c8                	add    %ecx,%eax
f0121a1f:	8a 00                	mov    (%eax),%al
f0121a21:	88 02                	mov    %al,(%edx)
f0121a23:	ff 45 fc             	incl   -0x4(%ebp)
f0121a26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121a29:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121a2c:	72 e1                	jb     f0121a0f <copy_data+0x1d>
}
f0121a2e:	90                   	nop
f0121a2f:	c9                   	leave  
f0121a30:	c3                   	ret    

f0121a31 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121a31:	55                   	push   %ebp
f0121a32:	89 e5                	mov    %esp,%ebp
f0121a34:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121a37:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121a3b:	75 23                	jne    f0121a60 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121a3d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121a41:	74 13                	je     f0121a56 <realloc_block_FF+0x25>
f0121a43:	83 ec 0c             	sub    $0xc,%esp
f0121a46:	ff 75 0c             	pushl  0xc(%ebp)
f0121a49:	e8 1f f0 ff ff       	call   f0120a6d <alloc_block_FF>
f0121a4e:	83 c4 10             	add    $0x10,%esp
f0121a51:	e9 f4 06 00 00       	jmp    f012214a <realloc_block_FF+0x719>
		return NULL;
f0121a56:	b8 00 00 00 00       	mov    $0x0,%eax
f0121a5b:	e9 ea 06 00 00       	jmp    f012214a <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f0121a60:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121a64:	75 18                	jne    f0121a7e <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121a66:	83 ec 0c             	sub    $0xc,%esp
f0121a69:	ff 75 08             	pushl  0x8(%ebp)
f0121a6c:	e8 c0 fe ff ff       	call   f0121931 <free_block>
f0121a71:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121a74:	b8 00 00 00 00       	mov    $0x0,%eax
f0121a79:	e9 cc 06 00 00       	jmp    f012214a <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f0121a7e:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121a82:	77 07                	ja     f0121a8b <realloc_block_FF+0x5a>
f0121a84:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121a8b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a8e:	83 e0 01             	and    $0x1,%eax
f0121a91:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121a94:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a97:	83 c0 08             	add    $0x8,%eax
f0121a9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121a9d:	83 ec 0c             	sub    $0xc,%esp
f0121aa0:	ff 75 08             	pushl  0x8(%ebp)
f0121aa3:	e8 45 ec ff ff       	call   f01206ed <get_block_size>
f0121aa8:	83 c4 10             	add    $0x10,%esp
f0121aab:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121ab1:	83 e8 08             	sub    $0x8,%eax
f0121ab4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121ab7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121aba:	83 e8 04             	sub    $0x4,%eax
f0121abd:	8b 00                	mov    (%eax),%eax
f0121abf:	83 e0 fe             	and    $0xfffffffe,%eax
f0121ac2:	89 c2                	mov    %eax,%edx
f0121ac4:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ac7:	01 d0                	add    %edx,%eax
f0121ac9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121acc:	83 ec 0c             	sub    $0xc,%esp
f0121acf:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121ad2:	e8 16 ec ff ff       	call   f01206ed <get_block_size>
f0121ad7:	83 c4 10             	add    $0x10,%esp
f0121ada:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121add:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121ae0:	83 e8 08             	sub    $0x8,%eax
f0121ae3:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ae9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121aec:	75 08                	jne    f0121af6 <realloc_block_FF+0xc5>
	{
		 return va;
f0121aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0121af1:	e9 54 06 00 00       	jmp    f012214a <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f0121af6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121af9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121afc:	0f 83 e5 03 00 00    	jae    f0121ee7 <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121b02:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121b05:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121b08:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121b0b:	83 ec 0c             	sub    $0xc,%esp
f0121b0e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121b11:	e8 f0 eb ff ff       	call   f0120706 <is_free_block>
f0121b16:	83 c4 10             	add    $0x10,%esp
f0121b19:	84 c0                	test   %al,%al
f0121b1b:	0f 84 3b 01 00 00    	je     f0121c5c <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121b21:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121b24:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121b27:	01 d0                	add    %edx,%eax
f0121b29:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121b2c:	83 ec 04             	sub    $0x4,%esp
f0121b2f:	6a 01                	push   $0x1
f0121b31:	ff 75 f0             	pushl  -0x10(%ebp)
f0121b34:	ff 75 08             	pushl  0x8(%ebp)
f0121b37:	e8 02 ef ff ff       	call   f0120a3e <set_block_data>
f0121b3c:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121b3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b42:	83 e8 04             	sub    $0x4,%eax
f0121b45:	8b 00                	mov    (%eax),%eax
f0121b47:	83 e0 fe             	and    $0xfffffffe,%eax
f0121b4a:	89 c2                	mov    %eax,%edx
f0121b4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b4f:	01 d0                	add    %edx,%eax
f0121b51:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121b54:	83 ec 04             	sub    $0x4,%esp
f0121b57:	6a 00                	push   $0x0
f0121b59:	ff 75 cc             	pushl  -0x34(%ebp)
f0121b5c:	ff 75 c8             	pushl  -0x38(%ebp)
f0121b5f:	e8 da ee ff ff       	call   f0120a3e <set_block_data>
f0121b64:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121b67:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121b6b:	74 06                	je     f0121b73 <realloc_block_FF+0x142>
f0121b6d:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121b71:	75 17                	jne    f0121b8a <realloc_block_FF+0x159>
f0121b73:	83 ec 04             	sub    $0x4,%esp
f0121b76:	68 68 15 13 f0       	push   $0xf0131568
f0121b7b:	68 f6 01 00 00       	push   $0x1f6
f0121b80:	68 f5 14 13 f0       	push   $0xf01314f5
f0121b85:	e8 af e7 fd ff       	call   f0100339 <_panic>
f0121b8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b8d:	8b 10                	mov    (%eax),%edx
f0121b8f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b92:	89 10                	mov    %edx,(%eax)
f0121b94:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b97:	8b 00                	mov    (%eax),%eax
f0121b99:	85 c0                	test   %eax,%eax
f0121b9b:	74 0b                	je     f0121ba8 <realloc_block_FF+0x177>
f0121b9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ba0:	8b 00                	mov    (%eax),%eax
f0121ba2:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121ba5:	89 50 04             	mov    %edx,0x4(%eax)
f0121ba8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bab:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121bae:	89 10                	mov    %edx,(%eax)
f0121bb0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121bb3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121bb6:	89 50 04             	mov    %edx,0x4(%eax)
f0121bb9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121bbc:	8b 00                	mov    (%eax),%eax
f0121bbe:	85 c0                	test   %eax,%eax
f0121bc0:	75 08                	jne    f0121bca <realloc_block_FF+0x199>
f0121bc2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121bc5:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121bca:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121bcf:	40                   	inc    %eax
f0121bd0:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121bd5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121bd9:	75 17                	jne    f0121bf2 <realloc_block_FF+0x1c1>
f0121bdb:	83 ec 04             	sub    $0x4,%esp
f0121bde:	68 d7 14 13 f0       	push   $0xf01314d7
f0121be3:	68 f7 01 00 00       	push   $0x1f7
f0121be8:	68 f5 14 13 f0       	push   $0xf01314f5
f0121bed:	e8 47 e7 fd ff       	call   f0100339 <_panic>
f0121bf2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bf5:	8b 00                	mov    (%eax),%eax
f0121bf7:	85 c0                	test   %eax,%eax
f0121bf9:	74 10                	je     f0121c0b <realloc_block_FF+0x1da>
f0121bfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bfe:	8b 00                	mov    (%eax),%eax
f0121c00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c03:	8b 52 04             	mov    0x4(%edx),%edx
f0121c06:	89 50 04             	mov    %edx,0x4(%eax)
f0121c09:	eb 0b                	jmp    f0121c16 <realloc_block_FF+0x1e5>
f0121c0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c0e:	8b 40 04             	mov    0x4(%eax),%eax
f0121c11:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121c16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c19:	8b 40 04             	mov    0x4(%eax),%eax
f0121c1c:	85 c0                	test   %eax,%eax
f0121c1e:	74 0f                	je     f0121c2f <realloc_block_FF+0x1fe>
f0121c20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c23:	8b 40 04             	mov    0x4(%eax),%eax
f0121c26:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c29:	8b 12                	mov    (%edx),%edx
f0121c2b:	89 10                	mov    %edx,(%eax)
f0121c2d:	eb 0a                	jmp    f0121c39 <realloc_block_FF+0x208>
f0121c2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c32:	8b 00                	mov    (%eax),%eax
f0121c34:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121c39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c3c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121c42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c45:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121c4c:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121c51:	48                   	dec    %eax
f0121c52:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121c57:	e9 83 02 00 00       	jmp    f0121edf <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f0121c5c:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121c60:	0f 86 69 02 00 00    	jbe    f0121ecf <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121c66:	83 ec 04             	sub    $0x4,%esp
f0121c69:	6a 01                	push   $0x1
f0121c6b:	ff 75 f0             	pushl  -0x10(%ebp)
f0121c6e:	ff 75 08             	pushl  0x8(%ebp)
f0121c71:	e8 c8 ed ff ff       	call   f0120a3e <set_block_data>
f0121c76:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121c79:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c7c:	83 e8 04             	sub    $0x4,%eax
f0121c7f:	8b 00                	mov    (%eax),%eax
f0121c81:	83 e0 fe             	and    $0xfffffffe,%eax
f0121c84:	89 c2                	mov    %eax,%edx
f0121c86:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c89:	01 d0                	add    %edx,%eax
f0121c8b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121c8e:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121c93:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121c96:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121c9a:	75 68                	jne    f0121d04 <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121c9c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121ca0:	75 17                	jne    f0121cb9 <realloc_block_FF+0x288>
f0121ca2:	83 ec 04             	sub    $0x4,%esp
f0121ca5:	68 10 15 13 f0       	push   $0xf0131510
f0121caa:	68 06 02 00 00       	push   $0x206
f0121caf:	68 f5 14 13 f0       	push   $0xf01314f5
f0121cb4:	e8 80 e6 fd ff       	call   f0100339 <_panic>
f0121cb9:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0121cbf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cc2:	89 10                	mov    %edx,(%eax)
f0121cc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cc7:	8b 00                	mov    (%eax),%eax
f0121cc9:	85 c0                	test   %eax,%eax
f0121ccb:	74 0d                	je     f0121cda <realloc_block_FF+0x2a9>
f0121ccd:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121cd2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121cd5:	89 50 04             	mov    %edx,0x4(%eax)
f0121cd8:	eb 08                	jmp    f0121ce2 <realloc_block_FF+0x2b1>
f0121cda:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cdd:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121ce2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ce5:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121cea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ced:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121cf4:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121cf9:	40                   	inc    %eax
f0121cfa:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121cff:	e9 b0 01 00 00       	jmp    f0121eb4 <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121d04:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d09:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d0c:	76 68                	jbe    f0121d76 <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121d0e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121d12:	75 17                	jne    f0121d2b <realloc_block_FF+0x2fa>
f0121d14:	83 ec 04             	sub    $0x4,%esp
f0121d17:	68 10 15 13 f0       	push   $0xf0131510
f0121d1c:	68 0b 02 00 00       	push   $0x20b
f0121d21:	68 f5 14 13 f0       	push   $0xf01314f5
f0121d26:	e8 0e e6 fd ff       	call   f0100339 <_panic>
f0121d2b:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0121d31:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d34:	89 10                	mov    %edx,(%eax)
f0121d36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d39:	8b 00                	mov    (%eax),%eax
f0121d3b:	85 c0                	test   %eax,%eax
f0121d3d:	74 0d                	je     f0121d4c <realloc_block_FF+0x31b>
f0121d3f:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d44:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d47:	89 50 04             	mov    %edx,0x4(%eax)
f0121d4a:	eb 08                	jmp    f0121d54 <realloc_block_FF+0x323>
f0121d4c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d4f:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121d54:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d57:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121d5c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d5f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121d66:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121d6b:	40                   	inc    %eax
f0121d6c:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121d71:	e9 3e 01 00 00       	jmp    f0121eb4 <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0121d76:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d7b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d7e:	73 68                	jae    f0121de8 <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121d80:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121d84:	75 17                	jne    f0121d9d <realloc_block_FF+0x36c>
f0121d86:	83 ec 04             	sub    $0x4,%esp
f0121d89:	68 44 15 13 f0       	push   $0xf0131544
f0121d8e:	68 10 02 00 00       	push   $0x210
f0121d93:	68 f5 14 13 f0       	push   $0xf01314f5
f0121d98:	e8 9c e5 fd ff       	call   f0100339 <_panic>
f0121d9d:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0121da3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121da6:	89 50 04             	mov    %edx,0x4(%eax)
f0121da9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dac:	8b 40 04             	mov    0x4(%eax),%eax
f0121daf:	85 c0                	test   %eax,%eax
f0121db1:	74 0c                	je     f0121dbf <realloc_block_FF+0x38e>
f0121db3:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121db8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121dbb:	89 10                	mov    %edx,(%eax)
f0121dbd:	eb 08                	jmp    f0121dc7 <realloc_block_FF+0x396>
f0121dbf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dc2:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121dc7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dca:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121dcf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dd2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121dd8:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121ddd:	40                   	inc    %eax
f0121dde:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121de3:	e9 cc 00 00 00       	jmp    f0121eb4 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0121de8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121def:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121df4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121df7:	e9 8a 00 00 00       	jmp    f0121e86 <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121dfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121dff:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121e02:	73 7a                	jae    f0121e7e <realloc_block_FF+0x44d>
f0121e04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e07:	8b 00                	mov    (%eax),%eax
f0121e09:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121e0c:	73 70                	jae    f0121e7e <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121e0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121e12:	74 06                	je     f0121e1a <realloc_block_FF+0x3e9>
f0121e14:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121e18:	75 17                	jne    f0121e31 <realloc_block_FF+0x400>
f0121e1a:	83 ec 04             	sub    $0x4,%esp
f0121e1d:	68 68 15 13 f0       	push   $0xf0131568
f0121e22:	68 1a 02 00 00       	push   $0x21a
f0121e27:	68 f5 14 13 f0       	push   $0xf01314f5
f0121e2c:	e8 08 e5 fd ff       	call   f0100339 <_panic>
f0121e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e34:	8b 10                	mov    (%eax),%edx
f0121e36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e39:	89 10                	mov    %edx,(%eax)
f0121e3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e3e:	8b 00                	mov    (%eax),%eax
f0121e40:	85 c0                	test   %eax,%eax
f0121e42:	74 0b                	je     f0121e4f <realloc_block_FF+0x41e>
f0121e44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e47:	8b 00                	mov    (%eax),%eax
f0121e49:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121e4c:	89 50 04             	mov    %edx,0x4(%eax)
f0121e4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e52:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121e55:	89 10                	mov    %edx,(%eax)
f0121e57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121e5d:	89 50 04             	mov    %edx,0x4(%eax)
f0121e60:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e63:	8b 00                	mov    (%eax),%eax
f0121e65:	85 c0                	test   %eax,%eax
f0121e67:	75 08                	jne    f0121e71 <realloc_block_FF+0x440>
f0121e69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e6c:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121e71:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121e76:	40                   	inc    %eax
f0121e77:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
							break;
f0121e7c:	eb 36                	jmp    f0121eb4 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0121e7e:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121e83:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121e86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121e8a:	74 07                	je     f0121e93 <realloc_block_FF+0x462>
f0121e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e8f:	8b 00                	mov    (%eax),%eax
f0121e91:	eb 05                	jmp    f0121e98 <realloc_block_FF+0x467>
f0121e93:	b8 00 00 00 00       	mov    $0x0,%eax
f0121e98:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0121e9d:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121ea2:	85 c0                	test   %eax,%eax
f0121ea4:	0f 85 52 ff ff ff    	jne    f0121dfc <realloc_block_FF+0x3cb>
f0121eaa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121eae:	0f 85 48 ff ff ff    	jne    f0121dfc <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0121eb4:	83 ec 04             	sub    $0x4,%esp
f0121eb7:	6a 00                	push   $0x0
f0121eb9:	ff 75 d8             	pushl  -0x28(%ebp)
f0121ebc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121ebf:	e8 7a eb ff ff       	call   f0120a3e <set_block_data>
f0121ec4:	83 c4 10             	add    $0x10,%esp
				return va;
f0121ec7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121eca:	e9 7b 02 00 00       	jmp    f012214a <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121ecf:	83 ec 0c             	sub    $0xc,%esp
f0121ed2:	68 e5 15 13 f0       	push   $0xf01315e5
f0121ed7:	e8 af f0 fd ff       	call   f0100f8b <cprintf>
f0121edc:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121edf:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ee2:	e9 63 02 00 00       	jmp    f012214a <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0121ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121eea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121eed:	0f 86 4d 02 00 00    	jbe    f0122140 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121ef3:	83 ec 0c             	sub    $0xc,%esp
f0121ef6:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121ef9:	e8 08 e8 ff ff       	call   f0120706 <is_free_block>
f0121efe:	83 c4 10             	add    $0x10,%esp
f0121f01:	84 c0                	test   %al,%al
f0121f03:	0f 84 37 02 00 00    	je     f0122140 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0121f09:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121f0c:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121f0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121f12:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121f15:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0121f18:	76 38                	jbe    f0121f52 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0121f1a:	83 ec 0c             	sub    $0xc,%esp
f0121f1d:	ff 75 08             	pushl  0x8(%ebp)
f0121f20:	e8 0c fa ff ff       	call   f0121931 <free_block>
f0121f25:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f0121f28:	83 ec 0c             	sub    $0xc,%esp
f0121f2b:	ff 75 0c             	pushl  0xc(%ebp)
f0121f2e:	e8 3a eb ff ff       	call   f0120a6d <alloc_block_FF>
f0121f33:	83 c4 10             	add    $0x10,%esp
f0121f36:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0121f39:	83 ec 08             	sub    $0x8,%esp
f0121f3c:	ff 75 c0             	pushl  -0x40(%ebp)
f0121f3f:	ff 75 08             	pushl  0x8(%ebp)
f0121f42:	e8 ab fa ff ff       	call   f01219f2 <copy_data>
f0121f47:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0121f4a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121f4d:	e9 f8 01 00 00       	jmp    f012214a <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0121f52:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121f55:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0121f58:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0121f5b:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0121f5f:	0f 87 a0 00 00 00    	ja     f0122005 <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0121f65:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f69:	75 17                	jne    f0121f82 <realloc_block_FF+0x551>
f0121f6b:	83 ec 04             	sub    $0x4,%esp
f0121f6e:	68 d7 14 13 f0       	push   $0xf01314d7
f0121f73:	68 38 02 00 00       	push   $0x238
f0121f78:	68 f5 14 13 f0       	push   $0xf01314f5
f0121f7d:	e8 b7 e3 fd ff       	call   f0100339 <_panic>
f0121f82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f85:	8b 00                	mov    (%eax),%eax
f0121f87:	85 c0                	test   %eax,%eax
f0121f89:	74 10                	je     f0121f9b <realloc_block_FF+0x56a>
f0121f8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f8e:	8b 00                	mov    (%eax),%eax
f0121f90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121f93:	8b 52 04             	mov    0x4(%edx),%edx
f0121f96:	89 50 04             	mov    %edx,0x4(%eax)
f0121f99:	eb 0b                	jmp    f0121fa6 <realloc_block_FF+0x575>
f0121f9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f9e:	8b 40 04             	mov    0x4(%eax),%eax
f0121fa1:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121fa6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fa9:	8b 40 04             	mov    0x4(%eax),%eax
f0121fac:	85 c0                	test   %eax,%eax
f0121fae:	74 0f                	je     f0121fbf <realloc_block_FF+0x58e>
f0121fb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fb3:	8b 40 04             	mov    0x4(%eax),%eax
f0121fb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121fb9:	8b 12                	mov    (%edx),%edx
f0121fbb:	89 10                	mov    %edx,(%eax)
f0121fbd:	eb 0a                	jmp    f0121fc9 <realloc_block_FF+0x598>
f0121fbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fc2:	8b 00                	mov    (%eax),%eax
f0121fc4:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121fc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fcc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121fd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fd5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121fdc:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121fe1:	48                   	dec    %eax
f0121fe2:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0121fe7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121fea:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121fed:	01 d0                	add    %edx,%eax
f0121fef:	83 ec 04             	sub    $0x4,%esp
f0121ff2:	6a 01                	push   $0x1
f0121ff4:	50                   	push   %eax
f0121ff5:	ff 75 08             	pushl  0x8(%ebp)
f0121ff8:	e8 41 ea ff ff       	call   f0120a3e <set_block_data>
f0121ffd:	83 c4 10             	add    $0x10,%esp
f0122000:	e9 36 01 00 00       	jmp    f012213b <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0122005:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122008:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012200b:	01 d0                	add    %edx,%eax
f012200d:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0122010:	83 ec 04             	sub    $0x4,%esp
f0122013:	6a 01                	push   $0x1
f0122015:	ff 75 f0             	pushl  -0x10(%ebp)
f0122018:	ff 75 08             	pushl  0x8(%ebp)
f012201b:	e8 1e ea ff ff       	call   f0120a3e <set_block_data>
f0122020:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0122023:	8b 45 08             	mov    0x8(%ebp),%eax
f0122026:	83 e8 04             	sub    $0x4,%eax
f0122029:	8b 00                	mov    (%eax),%eax
f012202b:	83 e0 fe             	and    $0xfffffffe,%eax
f012202e:	89 c2                	mov    %eax,%edx
f0122030:	8b 45 08             	mov    0x8(%ebp),%eax
f0122033:	01 d0                	add    %edx,%eax
f0122035:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0122038:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012203c:	74 06                	je     f0122044 <realloc_block_FF+0x613>
f012203e:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0122042:	75 17                	jne    f012205b <realloc_block_FF+0x62a>
f0122044:	83 ec 04             	sub    $0x4,%esp
f0122047:	68 68 15 13 f0       	push   $0xf0131568
f012204c:	68 44 02 00 00       	push   $0x244
f0122051:	68 f5 14 13 f0       	push   $0xf01314f5
f0122056:	e8 de e2 fd ff       	call   f0100339 <_panic>
f012205b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012205e:	8b 10                	mov    (%eax),%edx
f0122060:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122063:	89 10                	mov    %edx,(%eax)
f0122065:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122068:	8b 00                	mov    (%eax),%eax
f012206a:	85 c0                	test   %eax,%eax
f012206c:	74 0b                	je     f0122079 <realloc_block_FF+0x648>
f012206e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122071:	8b 00                	mov    (%eax),%eax
f0122073:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0122076:	89 50 04             	mov    %edx,0x4(%eax)
f0122079:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012207c:	8b 55 b8             	mov    -0x48(%ebp),%edx
f012207f:	89 10                	mov    %edx,(%eax)
f0122081:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122084:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122087:	89 50 04             	mov    %edx,0x4(%eax)
f012208a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012208d:	8b 00                	mov    (%eax),%eax
f012208f:	85 c0                	test   %eax,%eax
f0122091:	75 08                	jne    f012209b <realloc_block_FF+0x66a>
f0122093:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122096:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012209b:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01220a0:	40                   	inc    %eax
f01220a1:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f01220a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01220aa:	75 17                	jne    f01220c3 <realloc_block_FF+0x692>
f01220ac:	83 ec 04             	sub    $0x4,%esp
f01220af:	68 d7 14 13 f0       	push   $0xf01314d7
f01220b4:	68 45 02 00 00       	push   $0x245
f01220b9:	68 f5 14 13 f0       	push   $0xf01314f5
f01220be:	e8 76 e2 fd ff       	call   f0100339 <_panic>
f01220c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220c6:	8b 00                	mov    (%eax),%eax
f01220c8:	85 c0                	test   %eax,%eax
f01220ca:	74 10                	je     f01220dc <realloc_block_FF+0x6ab>
f01220cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220cf:	8b 00                	mov    (%eax),%eax
f01220d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01220d4:	8b 52 04             	mov    0x4(%edx),%edx
f01220d7:	89 50 04             	mov    %edx,0x4(%eax)
f01220da:	eb 0b                	jmp    f01220e7 <realloc_block_FF+0x6b6>
f01220dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220df:	8b 40 04             	mov    0x4(%eax),%eax
f01220e2:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01220e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220ea:	8b 40 04             	mov    0x4(%eax),%eax
f01220ed:	85 c0                	test   %eax,%eax
f01220ef:	74 0f                	je     f0122100 <realloc_block_FF+0x6cf>
f01220f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220f4:	8b 40 04             	mov    0x4(%eax),%eax
f01220f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01220fa:	8b 12                	mov    (%edx),%edx
f01220fc:	89 10                	mov    %edx,(%eax)
f01220fe:	eb 0a                	jmp    f012210a <realloc_block_FF+0x6d9>
f0122100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122103:	8b 00                	mov    (%eax),%eax
f0122105:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012210a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012210d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122113:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122116:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012211d:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0122122:	48                   	dec    %eax
f0122123:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				set_block_data(next_new_va, remaining_size, 0);
f0122128:	83 ec 04             	sub    $0x4,%esp
f012212b:	6a 00                	push   $0x0
f012212d:	ff 75 bc             	pushl  -0x44(%ebp)
f0122130:	ff 75 b8             	pushl  -0x48(%ebp)
f0122133:	e8 06 e9 ff ff       	call   f0120a3e <set_block_data>
f0122138:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f012213b:	8b 45 08             	mov    0x8(%ebp),%eax
f012213e:	eb 0a                	jmp    f012214a <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0122140:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f0122147:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012214a:	c9                   	leave  
f012214b:	c3                   	ret    

f012214c <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f012214c:	55                   	push   %ebp
f012214d:	89 e5                	mov    %esp,%ebp
f012214f:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0122152:	83 ec 04             	sub    $0x4,%esp
f0122155:	68 ec 15 13 f0       	push   $0xf01315ec
f012215a:	68 58 02 00 00       	push   $0x258
f012215f:	68 f5 14 13 f0       	push   $0xf01314f5
f0122164:	e8 d0 e1 fd ff       	call   f0100339 <_panic>

f0122169 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0122169:	55                   	push   %ebp
f012216a:	89 e5                	mov    %esp,%ebp
f012216c:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f012216f:	83 ec 04             	sub    $0x4,%esp
f0122172:	68 14 16 13 f0       	push   $0xf0131614
f0122177:	68 61 02 00 00       	push   $0x261
f012217c:	68 f5 14 13 f0       	push   $0xf01314f5
f0122181:	e8 b3 e1 fd ff       	call   f0100339 <_panic>
f0122186:	66 90                	xchg   %ax,%ax

f0122188 <__moddi3>:
f0122188:	55                   	push   %ebp
f0122189:	57                   	push   %edi
f012218a:	56                   	push   %esi
f012218b:	53                   	push   %ebx
f012218c:	83 ec 2c             	sub    $0x2c,%esp
f012218f:	8b 74 24 40          	mov    0x40(%esp),%esi
f0122193:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0122197:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f012219b:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f012219f:	89 d8                	mov    %ebx,%eax
f01221a1:	85 ff                	test   %edi,%edi
f01221a3:	0f 88 d3 00 00 00    	js     f012227c <__moddi3+0xf4>
f01221a9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01221b0:	00 
f01221b1:	85 c0                	test   %eax,%eax
f01221b3:	0f 88 ab 00 00 00    	js     f0122264 <__moddi3+0xdc>
f01221b9:	89 0c 24             	mov    %ecx,(%esp)
f01221bc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01221c0:	89 74 24 10          	mov    %esi,0x10(%esp)
f01221c4:	89 fb                	mov    %edi,%ebx
f01221c6:	8b 14 24             	mov    (%esp),%edx
f01221c9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01221cd:	89 d0                	mov    %edx,%eax
f01221cf:	89 54 24 18          	mov    %edx,0x18(%esp)
f01221d3:	89 ca                	mov    %ecx,%edx
f01221d5:	8b 0c 24             	mov    (%esp),%ecx
f01221d8:	89 34 24             	mov    %esi,(%esp)
f01221db:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01221df:	85 d2                	test   %edx,%edx
f01221e1:	75 15                	jne    f01221f8 <__moddi3+0x70>
f01221e3:	89 c7                	mov    %eax,%edi
f01221e5:	39 d8                	cmp    %ebx,%eax
f01221e7:	76 5b                	jbe    f0122244 <__moddi3+0xbc>
f01221e9:	89 f0                	mov    %esi,%eax
f01221eb:	89 da                	mov    %ebx,%edx
f01221ed:	f7 f7                	div    %edi
f01221ef:	89 d3                	mov    %edx,%ebx
f01221f1:	89 d8                	mov    %ebx,%eax
f01221f3:	31 d2                	xor    %edx,%edx
f01221f5:	eb 09                	jmp    f0122200 <__moddi3+0x78>
f01221f7:	90                   	nop
f01221f8:	39 fa                	cmp    %edi,%edx
f01221fa:	76 1c                	jbe    f0122218 <__moddi3+0x90>
f01221fc:	89 f0                	mov    %esi,%eax
f01221fe:	89 fa                	mov    %edi,%edx
f0122200:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0122204:	85 c9                	test   %ecx,%ecx
f0122206:	74 07                	je     f012220f <__moddi3+0x87>
f0122208:	f7 d8                	neg    %eax
f012220a:	83 d2 00             	adc    $0x0,%edx
f012220d:	f7 da                	neg    %edx
f012220f:	83 c4 2c             	add    $0x2c,%esp
f0122212:	5b                   	pop    %ebx
f0122213:	5e                   	pop    %esi
f0122214:	5f                   	pop    %edi
f0122215:	5d                   	pop    %ebp
f0122216:	c3                   	ret    
f0122217:	90                   	nop
f0122218:	0f bd c2             	bsr    %edx,%eax
f012221b:	83 f0 1f             	xor    $0x1f,%eax
f012221e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0122222:	75 6c                	jne    f0122290 <__moddi3+0x108>
f0122224:	39 fa                	cmp    %edi,%edx
f0122226:	72 05                	jb     f012222d <__moddi3+0xa5>
f0122228:	3b 0c 24             	cmp    (%esp),%ecx
f012222b:	77 0e                	ja     f012223b <__moddi3+0xb3>
f012222d:	8b 34 24             	mov    (%esp),%esi
f0122230:	29 ce                	sub    %ecx,%esi
f0122232:	19 d3                	sbb    %edx,%ebx
f0122234:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0122238:	89 34 24             	mov    %esi,(%esp)
f012223b:	8b 04 24             	mov    (%esp),%eax
f012223e:	8b 54 24 14          	mov    0x14(%esp),%edx
f0122242:	eb bc                	jmp    f0122200 <__moddi3+0x78>
f0122244:	85 c9                	test   %ecx,%ecx
f0122246:	75 0b                	jne    f0122253 <__moddi3+0xcb>
f0122248:	b8 01 00 00 00       	mov    $0x1,%eax
f012224d:	31 d2                	xor    %edx,%edx
f012224f:	f7 f1                	div    %ecx
f0122251:	89 c1                	mov    %eax,%ecx
f0122253:	89 d8                	mov    %ebx,%eax
f0122255:	31 d2                	xor    %edx,%edx
f0122257:	f7 f1                	div    %ecx
f0122259:	8b 04 24             	mov    (%esp),%eax
f012225c:	f7 f1                	div    %ecx
f012225e:	89 d3                	mov    %edx,%ebx
f0122260:	eb 8f                	jmp    f01221f1 <__moddi3+0x69>
f0122262:	66 90                	xchg   %ax,%ax
f0122264:	89 c8                	mov    %ecx,%eax
f0122266:	89 da                	mov    %ebx,%edx
f0122268:	f7 d8                	neg    %eax
f012226a:	83 d2 00             	adc    $0x0,%edx
f012226d:	f7 da                	neg    %edx
f012226f:	89 04 24             	mov    %eax,(%esp)
f0122272:	89 54 24 04          	mov    %edx,0x4(%esp)
f0122276:	e9 45 ff ff ff       	jmp    f01221c0 <__moddi3+0x38>
f012227b:	90                   	nop
f012227c:	f7 de                	neg    %esi
f012227e:	83 d7 00             	adc    $0x0,%edi
f0122281:	f7 df                	neg    %edi
f0122283:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f012228a:	ff 
f012228b:	e9 21 ff ff ff       	jmp    f01221b1 <__moddi3+0x29>
f0122290:	b8 20 00 00 00       	mov    $0x20,%eax
f0122295:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0122299:	29 f8                	sub    %edi,%eax
f012229b:	89 c6                	mov    %eax,%esi
f012229d:	89 44 24 14          	mov    %eax,0x14(%esp)
f01222a1:	89 f9                	mov    %edi,%ecx
f01222a3:	d3 e2                	shl    %cl,%edx
f01222a5:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01222a9:	89 e8                	mov    %ebp,%eax
f01222ab:	89 f1                	mov    %esi,%ecx
f01222ad:	d3 e8                	shr    %cl,%eax
f01222af:	09 d0                	or     %edx,%eax
f01222b1:	89 04 24             	mov    %eax,(%esp)
f01222b4:	89 ea                	mov    %ebp,%edx
f01222b6:	89 f9                	mov    %edi,%ecx
f01222b8:	d3 e2                	shl    %cl,%edx
f01222ba:	89 d7                	mov    %edx,%edi
f01222bc:	89 da                	mov    %ebx,%edx
f01222be:	d3 e2                	shl    %cl,%edx
f01222c0:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01222c4:	d3 e5                	shl    %cl,%ebp
f01222c6:	8b 44 24 10          	mov    0x10(%esp),%eax
f01222ca:	89 f1                	mov    %esi,%ecx
f01222cc:	d3 e8                	shr    %cl,%eax
f01222ce:	09 d0                	or     %edx,%eax
f01222d0:	d3 eb                	shr    %cl,%ebx
f01222d2:	89 da                	mov    %ebx,%edx
f01222d4:	f7 34 24             	divl   (%esp)
f01222d7:	89 d3                	mov    %edx,%ebx
f01222d9:	f7 e7                	mul    %edi
f01222db:	89 c6                	mov    %eax,%esi
f01222dd:	89 d1                	mov    %edx,%ecx
f01222df:	39 d3                	cmp    %edx,%ebx
f01222e1:	72 29                	jb     f012230c <__moddi3+0x184>
f01222e3:	74 33                	je     f0122318 <__moddi3+0x190>
f01222e5:	89 e8                	mov    %ebp,%eax
f01222e7:	29 f0                	sub    %esi,%eax
f01222e9:	19 cb                	sbb    %ecx,%ebx
f01222eb:	89 de                	mov    %ebx,%esi
f01222ed:	8a 4c 24 14          	mov    0x14(%esp),%cl
f01222f1:	d3 e6                	shl    %cl,%esi
f01222f3:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01222f7:	89 f9                	mov    %edi,%ecx
f01222f9:	d3 e8                	shr    %cl,%eax
f01222fb:	09 c6                	or     %eax,%esi
f01222fd:	89 f0                	mov    %esi,%eax
f01222ff:	89 f9                	mov    %edi,%ecx
f0122301:	d3 eb                	shr    %cl,%ebx
f0122303:	89 da                	mov    %ebx,%edx
f0122305:	e9 f6 fe ff ff       	jmp    f0122200 <__moddi3+0x78>
f012230a:	66 90                	xchg   %ax,%ax
f012230c:	29 f8                	sub    %edi,%eax
f012230e:	1b 14 24             	sbb    (%esp),%edx
f0122311:	89 d1                	mov    %edx,%ecx
f0122313:	89 c6                	mov    %eax,%esi
f0122315:	eb ce                	jmp    f01222e5 <__moddi3+0x15d>
f0122317:	90                   	nop
f0122318:	39 c5                	cmp    %eax,%ebp
f012231a:	72 f0                	jb     f012230c <__moddi3+0x184>
f012231c:	89 d9                	mov    %ebx,%ecx
f012231e:	eb c5                	jmp    f01222e5 <__moddi3+0x15d>

f0122320 <__udivdi3>:
f0122320:	55                   	push   %ebp
f0122321:	57                   	push   %edi
f0122322:	56                   	push   %esi
f0122323:	53                   	push   %ebx
f0122324:	83 ec 1c             	sub    $0x1c,%esp
f0122327:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012232b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f012232f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122333:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0122337:	89 ca                	mov    %ecx,%edx
f0122339:	89 f8                	mov    %edi,%eax
f012233b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f012233f:	85 f6                	test   %esi,%esi
f0122341:	75 2d                	jne    f0122370 <__udivdi3+0x50>
f0122343:	39 cf                	cmp    %ecx,%edi
f0122345:	77 65                	ja     f01223ac <__udivdi3+0x8c>
f0122347:	89 fd                	mov    %edi,%ebp
f0122349:	85 ff                	test   %edi,%edi
f012234b:	75 0b                	jne    f0122358 <__udivdi3+0x38>
f012234d:	b8 01 00 00 00       	mov    $0x1,%eax
f0122352:	31 d2                	xor    %edx,%edx
f0122354:	f7 f7                	div    %edi
f0122356:	89 c5                	mov    %eax,%ebp
f0122358:	31 d2                	xor    %edx,%edx
f012235a:	89 c8                	mov    %ecx,%eax
f012235c:	f7 f5                	div    %ebp
f012235e:	89 c1                	mov    %eax,%ecx
f0122360:	89 d8                	mov    %ebx,%eax
f0122362:	f7 f5                	div    %ebp
f0122364:	89 cf                	mov    %ecx,%edi
f0122366:	89 fa                	mov    %edi,%edx
f0122368:	83 c4 1c             	add    $0x1c,%esp
f012236b:	5b                   	pop    %ebx
f012236c:	5e                   	pop    %esi
f012236d:	5f                   	pop    %edi
f012236e:	5d                   	pop    %ebp
f012236f:	c3                   	ret    
f0122370:	39 ce                	cmp    %ecx,%esi
f0122372:	77 28                	ja     f012239c <__udivdi3+0x7c>
f0122374:	0f bd fe             	bsr    %esi,%edi
f0122377:	83 f7 1f             	xor    $0x1f,%edi
f012237a:	75 40                	jne    f01223bc <__udivdi3+0x9c>
f012237c:	39 ce                	cmp    %ecx,%esi
f012237e:	72 0a                	jb     f012238a <__udivdi3+0x6a>
f0122380:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0122384:	0f 87 9e 00 00 00    	ja     f0122428 <__udivdi3+0x108>
f012238a:	b8 01 00 00 00       	mov    $0x1,%eax
f012238f:	89 fa                	mov    %edi,%edx
f0122391:	83 c4 1c             	add    $0x1c,%esp
f0122394:	5b                   	pop    %ebx
f0122395:	5e                   	pop    %esi
f0122396:	5f                   	pop    %edi
f0122397:	5d                   	pop    %ebp
f0122398:	c3                   	ret    
f0122399:	8d 76 00             	lea    0x0(%esi),%esi
f012239c:	31 ff                	xor    %edi,%edi
f012239e:	31 c0                	xor    %eax,%eax
f01223a0:	89 fa                	mov    %edi,%edx
f01223a2:	83 c4 1c             	add    $0x1c,%esp
f01223a5:	5b                   	pop    %ebx
f01223a6:	5e                   	pop    %esi
f01223a7:	5f                   	pop    %edi
f01223a8:	5d                   	pop    %ebp
f01223a9:	c3                   	ret    
f01223aa:	66 90                	xchg   %ax,%ax
f01223ac:	89 d8                	mov    %ebx,%eax
f01223ae:	f7 f7                	div    %edi
f01223b0:	31 ff                	xor    %edi,%edi
f01223b2:	89 fa                	mov    %edi,%edx
f01223b4:	83 c4 1c             	add    $0x1c,%esp
f01223b7:	5b                   	pop    %ebx
f01223b8:	5e                   	pop    %esi
f01223b9:	5f                   	pop    %edi
f01223ba:	5d                   	pop    %ebp
f01223bb:	c3                   	ret    
f01223bc:	bd 20 00 00 00       	mov    $0x20,%ebp
f01223c1:	89 eb                	mov    %ebp,%ebx
f01223c3:	29 fb                	sub    %edi,%ebx
f01223c5:	89 f9                	mov    %edi,%ecx
f01223c7:	d3 e6                	shl    %cl,%esi
f01223c9:	89 c5                	mov    %eax,%ebp
f01223cb:	88 d9                	mov    %bl,%cl
f01223cd:	d3 ed                	shr    %cl,%ebp
f01223cf:	89 e9                	mov    %ebp,%ecx
f01223d1:	09 f1                	or     %esi,%ecx
f01223d3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01223d7:	89 f9                	mov    %edi,%ecx
f01223d9:	d3 e0                	shl    %cl,%eax
f01223db:	89 c5                	mov    %eax,%ebp
f01223dd:	89 d6                	mov    %edx,%esi
f01223df:	88 d9                	mov    %bl,%cl
f01223e1:	d3 ee                	shr    %cl,%esi
f01223e3:	89 f9                	mov    %edi,%ecx
f01223e5:	d3 e2                	shl    %cl,%edx
f01223e7:	8b 44 24 08          	mov    0x8(%esp),%eax
f01223eb:	88 d9                	mov    %bl,%cl
f01223ed:	d3 e8                	shr    %cl,%eax
f01223ef:	09 c2                	or     %eax,%edx
f01223f1:	89 d0                	mov    %edx,%eax
f01223f3:	89 f2                	mov    %esi,%edx
f01223f5:	f7 74 24 0c          	divl   0xc(%esp)
f01223f9:	89 d6                	mov    %edx,%esi
f01223fb:	89 c3                	mov    %eax,%ebx
f01223fd:	f7 e5                	mul    %ebp
f01223ff:	39 d6                	cmp    %edx,%esi
f0122401:	72 19                	jb     f012241c <__udivdi3+0xfc>
f0122403:	74 0b                	je     f0122410 <__udivdi3+0xf0>
f0122405:	89 d8                	mov    %ebx,%eax
f0122407:	31 ff                	xor    %edi,%edi
f0122409:	e9 58 ff ff ff       	jmp    f0122366 <__udivdi3+0x46>
f012240e:	66 90                	xchg   %ax,%ax
f0122410:	8b 54 24 08          	mov    0x8(%esp),%edx
f0122414:	89 f9                	mov    %edi,%ecx
f0122416:	d3 e2                	shl    %cl,%edx
f0122418:	39 c2                	cmp    %eax,%edx
f012241a:	73 e9                	jae    f0122405 <__udivdi3+0xe5>
f012241c:	8d 43 ff             	lea    -0x1(%ebx),%eax
f012241f:	31 ff                	xor    %edi,%edi
f0122421:	e9 40 ff ff ff       	jmp    f0122366 <__udivdi3+0x46>
f0122426:	66 90                	xchg   %ax,%ax
f0122428:	31 c0                	xor    %eax,%eax
f012242a:	e9 37 ff ff ff       	jmp    f0122366 <__udivdi3+0x46>
f012242f:	90                   	nop

f0122430 <__umoddi3>:
f0122430:	55                   	push   %ebp
f0122431:	57                   	push   %edi
f0122432:	56                   	push   %esi
f0122433:	53                   	push   %ebx
f0122434:	83 ec 1c             	sub    $0x1c,%esp
f0122437:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012243b:	8b 74 24 34          	mov    0x34(%esp),%esi
f012243f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122443:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0122447:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012244b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f012244f:	89 f3                	mov    %esi,%ebx
f0122451:	89 fa                	mov    %edi,%edx
f0122453:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0122457:	89 34 24             	mov    %esi,(%esp)
f012245a:	85 c0                	test   %eax,%eax
f012245c:	75 1a                	jne    f0122478 <__umoddi3+0x48>
f012245e:	39 f7                	cmp    %esi,%edi
f0122460:	0f 86 a2 00 00 00    	jbe    f0122508 <__umoddi3+0xd8>
f0122466:	89 c8                	mov    %ecx,%eax
f0122468:	89 f2                	mov    %esi,%edx
f012246a:	f7 f7                	div    %edi
f012246c:	89 d0                	mov    %edx,%eax
f012246e:	31 d2                	xor    %edx,%edx
f0122470:	83 c4 1c             	add    $0x1c,%esp
f0122473:	5b                   	pop    %ebx
f0122474:	5e                   	pop    %esi
f0122475:	5f                   	pop    %edi
f0122476:	5d                   	pop    %ebp
f0122477:	c3                   	ret    
f0122478:	39 f0                	cmp    %esi,%eax
f012247a:	0f 87 ac 00 00 00    	ja     f012252c <__umoddi3+0xfc>
f0122480:	0f bd e8             	bsr    %eax,%ebp
f0122483:	83 f5 1f             	xor    $0x1f,%ebp
f0122486:	0f 84 ac 00 00 00    	je     f0122538 <__umoddi3+0x108>
f012248c:	bf 20 00 00 00       	mov    $0x20,%edi
f0122491:	29 ef                	sub    %ebp,%edi
f0122493:	89 fe                	mov    %edi,%esi
f0122495:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0122499:	89 e9                	mov    %ebp,%ecx
f012249b:	d3 e0                	shl    %cl,%eax
f012249d:	89 d7                	mov    %edx,%edi
f012249f:	89 f1                	mov    %esi,%ecx
f01224a1:	d3 ef                	shr    %cl,%edi
f01224a3:	09 c7                	or     %eax,%edi
f01224a5:	89 e9                	mov    %ebp,%ecx
f01224a7:	d3 e2                	shl    %cl,%edx
f01224a9:	89 14 24             	mov    %edx,(%esp)
f01224ac:	89 d8                	mov    %ebx,%eax
f01224ae:	d3 e0                	shl    %cl,%eax
f01224b0:	89 c2                	mov    %eax,%edx
f01224b2:	8b 44 24 08          	mov    0x8(%esp),%eax
f01224b6:	d3 e0                	shl    %cl,%eax
f01224b8:	89 44 24 04          	mov    %eax,0x4(%esp)
f01224bc:	8b 44 24 08          	mov    0x8(%esp),%eax
f01224c0:	89 f1                	mov    %esi,%ecx
f01224c2:	d3 e8                	shr    %cl,%eax
f01224c4:	09 d0                	or     %edx,%eax
f01224c6:	d3 eb                	shr    %cl,%ebx
f01224c8:	89 da                	mov    %ebx,%edx
f01224ca:	f7 f7                	div    %edi
f01224cc:	89 d3                	mov    %edx,%ebx
f01224ce:	f7 24 24             	mull   (%esp)
f01224d1:	89 c6                	mov    %eax,%esi
f01224d3:	89 d1                	mov    %edx,%ecx
f01224d5:	39 d3                	cmp    %edx,%ebx
f01224d7:	0f 82 87 00 00 00    	jb     f0122564 <__umoddi3+0x134>
f01224dd:	0f 84 91 00 00 00    	je     f0122574 <__umoddi3+0x144>
f01224e3:	8b 54 24 04          	mov    0x4(%esp),%edx
f01224e7:	29 f2                	sub    %esi,%edx
f01224e9:	19 cb                	sbb    %ecx,%ebx
f01224eb:	89 d8                	mov    %ebx,%eax
f01224ed:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f01224f1:	d3 e0                	shl    %cl,%eax
f01224f3:	89 e9                	mov    %ebp,%ecx
f01224f5:	d3 ea                	shr    %cl,%edx
f01224f7:	09 d0                	or     %edx,%eax
f01224f9:	89 e9                	mov    %ebp,%ecx
f01224fb:	d3 eb                	shr    %cl,%ebx
f01224fd:	89 da                	mov    %ebx,%edx
f01224ff:	83 c4 1c             	add    $0x1c,%esp
f0122502:	5b                   	pop    %ebx
f0122503:	5e                   	pop    %esi
f0122504:	5f                   	pop    %edi
f0122505:	5d                   	pop    %ebp
f0122506:	c3                   	ret    
f0122507:	90                   	nop
f0122508:	89 fd                	mov    %edi,%ebp
f012250a:	85 ff                	test   %edi,%edi
f012250c:	75 0b                	jne    f0122519 <__umoddi3+0xe9>
f012250e:	b8 01 00 00 00       	mov    $0x1,%eax
f0122513:	31 d2                	xor    %edx,%edx
f0122515:	f7 f7                	div    %edi
f0122517:	89 c5                	mov    %eax,%ebp
f0122519:	89 f0                	mov    %esi,%eax
f012251b:	31 d2                	xor    %edx,%edx
f012251d:	f7 f5                	div    %ebp
f012251f:	89 c8                	mov    %ecx,%eax
f0122521:	f7 f5                	div    %ebp
f0122523:	89 d0                	mov    %edx,%eax
f0122525:	e9 44 ff ff ff       	jmp    f012246e <__umoddi3+0x3e>
f012252a:	66 90                	xchg   %ax,%ax
f012252c:	89 c8                	mov    %ecx,%eax
f012252e:	89 f2                	mov    %esi,%edx
f0122530:	83 c4 1c             	add    $0x1c,%esp
f0122533:	5b                   	pop    %ebx
f0122534:	5e                   	pop    %esi
f0122535:	5f                   	pop    %edi
f0122536:	5d                   	pop    %ebp
f0122537:	c3                   	ret    
f0122538:	3b 04 24             	cmp    (%esp),%eax
f012253b:	72 06                	jb     f0122543 <__umoddi3+0x113>
f012253d:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0122541:	77 0f                	ja     f0122552 <__umoddi3+0x122>
f0122543:	89 f2                	mov    %esi,%edx
f0122545:	29 f9                	sub    %edi,%ecx
f0122547:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012254b:	89 14 24             	mov    %edx,(%esp)
f012254e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0122552:	8b 44 24 04          	mov    0x4(%esp),%eax
f0122556:	8b 14 24             	mov    (%esp),%edx
f0122559:	83 c4 1c             	add    $0x1c,%esp
f012255c:	5b                   	pop    %ebx
f012255d:	5e                   	pop    %esi
f012255e:	5f                   	pop    %edi
f012255f:	5d                   	pop    %ebp
f0122560:	c3                   	ret    
f0122561:	8d 76 00             	lea    0x0(%esi),%esi
f0122564:	2b 04 24             	sub    (%esp),%eax
f0122567:	19 fa                	sbb    %edi,%edx
f0122569:	89 d1                	mov    %edx,%ecx
f012256b:	89 c6                	mov    %eax,%esi
f012256d:	e9 71 ff ff ff       	jmp    f01224e3 <__umoddi3+0xb3>
f0122572:	66 90                	xchg   %ax,%ax
f0122574:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0122578:	72 ea                	jb     f0122564 <__umoddi3+0x134>
f012257a:	89 d9                	mov    %ebx,%ecx
f012257c:	e9 62 ff ff ff       	jmp    f01224e3 <__umoddi3+0xb3>
