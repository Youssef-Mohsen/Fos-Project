
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 00 18 00 	lgdtl  0x180018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 00 18 f0       	mov    $0xf0180000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 64 f5 b1 f0 01 	movl   $0x1,0xf0b1f564
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 70 22 6b f2       	mov    $0xf26b2270,%edx
f010006a:	b8 3c 63 6f f0       	mov    $0xf06f633c,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 3c 63 6f f0       	push   $0xf06f633c
f010007e:	e8 17 00 02 00       	call   f012009a <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 80 27 12 f0       	push   $0xf0122780
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 c7 27 12 f0       	push   $0xf01227c7
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 db 27 12 f0       	push   $0xf01227db
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 ef 27 12 f0       	push   $0xf01227ef
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 67 73 00 00       	call   f0107441 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 fb 27 12 f0       	push   $0xf01227fb
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 03 28 12 f0       	push   $0xf0122803
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 ac 7c 00 00       	call   f0107dae <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 4d 78 00 00       	call   f0107954 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 ed 7f 00 00       	call   f01080f9 <initialize_paging>
		sharing_init();
f010010c:	e8 5e 8c 00 00       	call   f0108d6f <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 48 94 00 00       	call   f0109570 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 33 f7 00 00       	call   f010f863 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 1c f8 00 00       	call   f010f960 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 f7 f7 00 00       	call   f010f948 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 17 f8 00 00       	call   f010f978 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 88 04 02 00       	call   f01205f1 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 11 28 12 f0       	push   $0xf0122811
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 9e ae 00 00       	call   f010b01c <env_init>
		ts_init();
f010017e:	e8 82 d0 00 00       	call   f010d205 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 fb 27 12 f0       	push   $0xf01227fb
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 24 28 12 f0       	push   $0xf0122824
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 85 6f 00 00       	call   f010712d <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 4d 28 12 f0       	push   $0xf012284d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 5d 71 00 00       	call   f010731f <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 63 28 12 f0       	push   $0xf0122863
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 40 71 00 00       	call   f010731f <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 80 28 12 f0       	push   $0xf0122880
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 23 71 00 00       	call   f010731f <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 9f 28 12 f0       	push   $0xf012289f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 bc 28 12 f0       	push   $0xf01228bc
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 c2 4b 00 00       	call   f0104de6 <kclock_init>
		sched_init() ;
f0100224:	e8 b8 67 00 00       	call   f01069e1 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 e0 28 12 f0       	push   $0xf01228e0
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 00 18 f0       	mov    $0xf0180000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 00 29 12 f0       	push   $0xf0122900
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 24 29 12 f0       	push   $0xf0122924
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 7c f8 f1 f0 00 	movl   $0x0,0xf0f1f87c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 6c 29 12 f0       	push   $0xf012296c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 98 29 12 f0       	push   $0xf0122998
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 bd 29 12 f0       	push   $0xf01229bd
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 c4 29 12 f0       	push   $0xf01229c4
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 0c 2a 12 f0       	push   $0xf0122a0c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 54 2a 12 f0       	push   $0xf0122a54
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 0c 2a 12 f0       	push   $0xf0122a0c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 c4 29 12 f0       	push   $0xf01229c4
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 99 2a 12 f0       	push   $0xf0122a99
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 2c b9 00 00       	call   f010bc70 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 a0 2a 12 f0       	push   $0xf0122aa0
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 c5 2a 12 f0       	push   $0xf0122ac5
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 88 b8 00 00       	call   f010bc2e <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 c7 2a 12 f0       	push   $0xf0122ac7
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 d1 2a 12 f0       	push   $0xf0122ad1
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 c5 2a 12 f0       	push   $0xf0122ac5
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 dd 70 00 00       	call   f01074fa <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 15 70 00 00       	call   f0107437 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 16 71 00 00       	call   f010754c <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 ff 62 00 00       	call   f0106740 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 2a b8 00 00       	call   f010bc70 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 cf b7 00 00       	call   f010bc2e <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 d1 2a 12 f0       	push   $0xf0122ad1
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 c5 2a 12 f0       	push   $0xf0122ac5
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 b8 b7 00 00       	call   f010bc70 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 5d b7 00 00       	call   f010bc2e <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 ea 2a 12 f0       	push   $0xf0122aea
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 c5 2a 12 f0       	push   $0xf0122ac5
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 64 63 6f f0       	mov    0xf06f6364,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 08 2b 12 f0       	push   $0xf0122b08
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 64 63 6f f0       	mov    %eax,0xf06f6364
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 94 de 00 00       	call   f010e509 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 68 63 6f f0 b4 	movl   $0x3b4,0xf06f6368
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 68 63 6f f0 d4 	movl   $0x3d4,0xf06f6368
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 6c 63 6f f0       	mov    %eax,0xf06f636c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f010087a:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		text_length = 0;
f01008a6:	c7 05 60 63 6f f0 00 	movl   $0x0,0xf06f6360
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 70 63 6f f0 	mov    0xf06f6370,%cx
f01008b7:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 6c 63 6f f0    	mov    0xf06f636c,%ecx
f0100972:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 70 63 6f f0 	mov    %dx,0xf06f6370
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 60 63 6f f0    	mov    0xf06f6360,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 60 63 6f f0       	mov    %eax,0xf06f6360
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 df f6 01 00       	call   f01200ca <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 68 63 6f f0    	mov    0xf06f6368,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 68 63 6f f0    	mov    0xf06f6368,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 01 18 f0    	mov    -0xfe7fee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 88 65 6f f0       	mov    %eax,0xf06f6588

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 05 18 f0 	mov    -0xfe7fae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 60 63 6f f0    	mov    0xf06f6360,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 60 63 6f f0       	mov    %eax,0xf06f6360
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 1b 2b 12 f0       	push   $0xf0122b1b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 f4 d7 00 00       	call   f010e509 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 84 65 6f f0    	mov    %edx,0xf06f6584
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 80 63 6f f0    	mov    %dl,-0xf909c80(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 84 65 6f f0 00 	movl   $0x0,0xf06f6584
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 80 65 6f f0    	mov    0xf06f6580,%edx
f0100d7f:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 80 65 6f f0    	mov    %edx,0xf06f6580
f0100d96:	8a 80 80 63 6f f0    	mov    -0xf909c80(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 80 65 6f f0 00 	movl   $0x0,0xf06f6580
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 80 65 6f f0    	mov    0xf06f6580,%edx
f0100dd0:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 80 65 6f f0    	mov    %edx,0xf06f6580
f0100de7:	8a 80 80 63 6f f0    	mov    -0xf909c80(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 80 65 6f f0 00 	movl   $0x0,0xf06f6580
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 64 63 6f f0       	mov    0xf06f6364,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 27 2b 12 f0       	push   $0xf0122b27
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ed 3f 00 00       	call   f0104ea8 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 af ad 00 00       	call   f010bc70 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 44 2b 12 f0       	push   $0xf0122b44
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 6b 2b 12 f0       	push   $0xf0122b6b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 a6 3f 00 00       	call   f0104ea8 <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 68 ad 00 00       	call   f010bc70 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 80 2b 12 f0       	push   $0xf0122b80
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 6b 2b 12 f0       	push   $0xf0122b6b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 67 e8 01 00       	call   f011f7ea <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 64 65 00 00       	call   f01074fa <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 96 65 00 00       	call   f010754c <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 b4 ee 01 00       	call   f011feac <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 60 d9 f3 f0       	push   $0xf0f3d960
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 b7 f0 01 00       	call   f01200ca <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 f2 ed 01 00       	call   f011feac <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 60 d9 f3 f0       	push   $0xf0f3d960
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 f5 ef 01 00       	call   f01200ca <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 32 ef 01 00       	call   f012009a <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 ac 2b 12 f0       	push   $0xf0122bac
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 af 2b 12 f0       	push   $0xf0122baf
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 40 f9 f1 f0       	push   $0xf0f1f940
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 d7 eb 01 00       	call   f011feac <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 ec eb 01 00       	call   f011fefb <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 8f eb 01 00       	call   f011feac <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 bf 2b 12 f0       	push   $0xf0122bbf
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 6a f1 01 00       	call   f01204c1 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 c4 2b 12 f0       	push   $0xf0122bc4
f010137e:	50                   	push   %eax
f010137f:	e8 34 ec 01 00       	call   f011ffb8 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 c8 2b 12 f0       	push   $0xf0122bc8
f0101399:	50                   	push   %eax
f010139a:	e8 19 ec 01 00       	call   f011ffb8 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 cd 2b 12 f0       	push   $0xf0122bcd
f01013b4:	50                   	push   %eax
f01013b5:	e8 fe eb 01 00       	call   f011ffb8 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 cd 2b 12 f0       	push   $0xf0122bcd
f01013d5:	50                   	push   %eax
f01013d6:	e8 dd eb 01 00       	call   f011ffb8 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 85 ea 01 00       	call   f011feac <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 87 ea 01 00       	call   f011fefb <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 66 ea 01 00       	call   f011fefb <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 e3 e9 01 00       	call   f011feac <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 fe ea 01 00       	call   f011fff0 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 33 e9 01 00       	call   f011feac <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 fe ea 01 00       	call   f012009a <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 40 f9 f1 f0    	add    $0xf0f1f940,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 69 e9 01 00       	call   f011ff29 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 a9 e8 01 00       	call   f011feac <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 c1 e9 01 00       	call   f011fff0 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 0c e8 01 00       	call   f011feac <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 ac e7 01 00       	call   f011feac <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 77 e9 01 00       	call   f012009a <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 40 f9 f1 f0    	add    $0xf0f1f940,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 e2 e7 01 00       	call   f011ff29 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 24 e7 01 00       	call   f011feac <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 3f e8 01 00       	call   f011fff0 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 8a e6 01 00       	call   f011feac <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 30 e6 01 00       	call   f011feac <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 fb e7 01 00       	call   f012009a <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 40 f9 f1 f0    	add    $0xf0f1f940,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 66 e6 01 00       	call   f011ff29 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 40 f9 f1 f0       	push   $0xf0f1f940
f0101929:	e8 7e e5 01 00       	call   f011feac <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 25 e5 01 00       	call   f011feac <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 12 e5 01 00       	call   f011feac <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 40 f9 f1 f0    	lea    -0xf0e06c0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 40 f9 f1 f0       	add    $0xf0f1f940,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 b7 e4 01 00       	call   f011feac <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 40 89 f3 f0    	lea    -0xf0c76c0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 ac e4 01 00       	call   f01200ca <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 40 d5 f3 f0       	push   $0xf0f3d540
f0101c3a:	e8 8b e4 01 00       	call   f01200ca <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 5b e3 01 00       	call   f011ffb8 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 05 18 f0       	mov    %eax,0xf0180530
f0101c6f:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 40 89 f3 f0       	add    $0xf0f38940,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 3d e4 01 00       	call   f01200ca <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 7c f8 f1 f0       	mov    0xf0f1f87c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb d7 2b 12 f0       	mov    $0xf0122bd7,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb d7 2f 12 f0       	mov    $0xf0122fd7,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb d7 33 12 f0       	mov    $0xf01233d7,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 7c f8 f1 f0 00 	movl   $0x0,0xf0f1f87c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 f8 f7 f1 f0 00 	movl   $0x0,0xf0f1f7f8
f0101d59:	00 00 00 
f0101d5c:	c7 05 fc f7 f1 f0 00 	movl   $0x0,0xf0f1f7fc
f0101d63:	00 00 00 
f0101d66:	c7 05 04 f8 f1 f0 00 	movl   $0x0,0xf0f1f804
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 14 e3 01 00       	call   f012009a <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 d1 2b 12 f0       	push   $0xf0122bd1
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 1e a1 00 00       	call   f010befd <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 53 56 00 00       	call   f0107437 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 20 f9 f1 f0       	mov    %eax,0xf0f1f920
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 40 d9 f3 f0       	mov    %eax,0xf0f3d940
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 20 f9 f1 f0       	mov    0xf0f1f920,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 20 f9 f1 f0    	mov    %edx,0xf0f1f920
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 40 d9 f3 f0       	mov    0xf0f3d940,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 40 d9 f3 f0       	mov    %eax,0xf0f3d940
f0101e98:	a1 40 d9 f3 f0       	mov    0xf0f3d940,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 20 f9 f1 f0       	mov    %eax,0xf0f1f920
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 40 d9 f3 f0       	mov    %eax,0xf0f3d940
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 20 f9 f1 f0       	mov    0xf0f1f920,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 20 f9 f1 f0    	mov    %edx,0xf0f1f920
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 40 d9 f3 f0       	mov    0xf0f3d940,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 40 d9 f3 f0       	mov    %eax,0xf0f3d940
f0101ed4:	a1 40 d9 f3 f0       	mov    0xf0f3d940,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 bf 2b 12 f0       	push   $0xf0122bbf
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 ab e5 01 00       	call   f01204c1 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 d7 37 12 f0       	push   $0xf01237d7
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 f0 37 12 f0       	push   $0xf01237f0
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 41 38 12 f0       	push   $0xf0123841
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 5c 38 12 f0       	push   $0xf012385c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 8c 38 12 f0       	push   $0xf012388c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 41 38 12 f0       	push   $0xf0123841
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 b6 38 12 f0       	push   $0xf01238b6
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 00 f8 f1 f0       	mov    %eax,0xf0f1f800
f010203b:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 c0 38 12 f0       	push   $0xf01238c0
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 23 39 12 f0       	push   $0xf0123923
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 2c 39 12 f0       	push   $0xf012392c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 00 f8 f1 f0       	mov    %eax,0xf0f1f800
f010218b:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 05 18 f0       	add    $0xf0180548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 34 39 12 f0       	push   $0xf0123934
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 41 38 12 f0       	push   $0xf0123841
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 fc f7 f1 f0       	mov    %eax,0xf0f1f7fc
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 f8 f7 f1 f0       	mov    %eax,0xf0f1f7f8
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 04 f8 f1 f0       	mov    %eax,0xf0f1f804

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 00 f8 f1 f0       	mov    %eax,0xf0f1f800
f0102292:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 da dc 01 00       	call   f011ffb8 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 f8 f7 f1 f0    	mov    0xf0f1f7f8,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 05 18 f0       	add    $0xf0180550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 f8 f7 f1 f0    	mov    0xf0f1f7f8,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010238d:	a3 fc f7 f1 f0       	mov    %eax,0xf0f1f7fc
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023a3:	a3 f8 f7 f1 f0       	mov    %eax,0xf0f1f7f8
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 04 f8 f1 f0       	mov    %eax,0xf0f1f804
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 f8 f7 f1 f0    	mov    0xf0f1f7f8,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 f8 f7 f1 f0    	mov    0xf0f1f7f8,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010248c:	a3 fc f7 f1 f0       	mov    %eax,0xf0f1f7fc
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01024a2:	a3 f8 f7 f1 f0       	mov    %eax,0xf0f1f7f8
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 04 f8 f1 f0       	mov    %eax,0xf0f1f804
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 18 f6 b1 f0 00 	movl   $0x0,0xf0b1f618
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 18 f6 b1 f0 02 	movl   $0x2,0xf0b1f618
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 18 f6 b1 f0 03 	movl   $0x3,0xf0b1f618
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:

f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 18 f6 b1 f0 04 	movl   $0x4,0xf0b1f618
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:
static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:

f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 64 f5 b1 f0 01 	movl   $0x1,0xf0b1f564
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 64 f5 b1 f0 02 	movl   $0x2,0xf0b1f564
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 64 f5 b1 f0 03 	movl   $0x3,0xf0b1f564
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 64 f5 b1 f0 04 	movl   $0x4,0xf0b1f564
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 54 39 12 f0       	push   $0xf0123954
f0102662:	6a 56                	push   $0x56
f0102664:	68 7c 39 12 f0       	push   $0xf012397c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 05 18 f0       	add    $0xf0180544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 b3 42 12 f0       	push   $0xf01242b3
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 bc 42 12 f0       	push   $0xf01242bc
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 d1 42 12 f0       	push   $0xf01242d1
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 ed 42 12 f0       	push   $0xf01242ed
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 08 43 12 f0       	push   $0xf0124308
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 79 27 12 00       	mov    $0x122779,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 79 27 12 f0       	push   $0xf0122779
f010278e:	68 44 43 12 f0       	push   $0xf0124344
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 3c 63 6f 00       	mov    $0x6f633c,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 3c 63 6f f0       	push   $0xf06f633c
f01027a9:	68 80 43 12 f0       	push   $0xf0124380
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 70 22 6b 02       	mov    $0x26b2270,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 70 22 6b f2       	push   $0xf26b2270
f01027c4:	68 c8 43 12 f0       	push   $0xf01243c8
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 70 22 6b f2       	mov    $0xf26b2270,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 04 44 12 f0       	push   $0xf0124404
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 e2 d9 01 00       	call   f012020c <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 a1 d9 01 00       	call   f012020c <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 37 94 00 00       	call   f010bcc0 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 6b d9 01 00       	call   f012020c <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 30 44 12 f0       	push   $0xf0124430
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 e5 d8 01 00       	call   f012020c <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 62 d5 01 00       	call   f011feac <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 67 d8 01 00       	call   f012020c <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 5a 44 12 f0       	push   $0xf012445a
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 1b d8 01 00       	call   f012020c <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 b1 92 00 00       	call   f010bcc0 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 e5 d7 01 00       	call   f012020c <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 5a 44 12 f0       	push   $0xf012445a
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 74 44 12 f0       	push   $0xf0124474
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 54 d7 01 00       	call   f012020c <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 9e 44 12 f0       	push   $0xf012449e
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 a1 44 12 f0       	push   $0xf01244a1
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 f7 d6 01 00       	call   f012020c <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 8d 91 00 00       	call   f010bcc0 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 c1 d6 01 00       	call   f012020c <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 a6 d6 01 00       	call   f012020c <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 a3 44 12 f0       	push   $0xf01244a3
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 0a d6 01 00       	call   f012020c <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 a0 90 00 00       	call   f010bcc0 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 c3 d5 01 00       	call   f012020c <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 d8 6e 00 00       	call   f0109b5d <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 89 6d 00 00       	call   f0109a1a <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 76 59 00 00       	call   f0108631 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 b4 44 12 f0       	push   $0xf01244b4
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 ce d4 01 00       	call   f012020c <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 64 8f 00 00       	call   f010bcc0 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 87 d4 01 00       	call   f012020c <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 46 57 00 00       	call   f01084dd <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 de 44 12 f0       	push   $0xf01244de
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 d2 5b 00 00       	call   f01089aa <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 f8 44 12 f0       	push   $0xf01244f8
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 43 5b 00 00       	call   f01089aa <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 07 5e 00 00       	call   f0108c8c <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 3c 45 12 f0       	push   $0xf012453c
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 30 f7 b1 f0       	mov    0xf0b1f730,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 94 45 12 f0       	push   $0xf0124594
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0102ef6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102efd:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f00:	83 f8 04             	cmp    $0x4,%eax
f0102f03:	0f 84 c3 00 00 00    	je     f0102fcc <CreateEnv+0xf8>
f0102f09:	83 f8 05             	cmp    $0x5,%eax
f0102f0c:	74 0e                	je     f0102f1c <CreateEnv+0x48>
f0102f0e:	83 f8 03             	cmp    $0x3,%eax
f0102f11:	0f 84 4a 01 00 00    	je     f0103061 <CreateEnv+0x18d>
f0102f17:	e9 8d 01 00 00       	jmp    f01030a9 <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f1c:	83 ec 0c             	sub    $0xc,%esp
f0102f1f:	6a 02                	push   $0x2
f0102f21:	e8 85 c9 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f0102f26:	83 c4 10             	add    $0x10,%esp
f0102f29:	85 c0                	test   %eax,%eax
f0102f2b:	75 1a                	jne    f0102f47 <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f2d:	83 ec 0c             	sub    $0xc,%esp
f0102f30:	68 d0 45 12 f0       	push   $0xf01245d0
f0102f35:	e8 51 e0 ff ff       	call   f0100f8b <cprintf>
f0102f3a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f3d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f42:	e9 7b 02 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0102f47:	e8 6f 3a 00 00       	call   f01069bb <isSchedMethodBSD>
f0102f4c:	85 c0                	test   %eax,%eax
f0102f4e:	74 1d                	je     f0102f6d <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f53:	83 c0 10             	add    $0x10,%eax
f0102f56:	8b 00                	mov    (%eax),%eax
f0102f58:	83 ec 04             	sub    $0x4,%esp
f0102f5b:	6a 0a                	push   $0xa
f0102f5d:	6a 00                	push   $0x0
f0102f5f:	50                   	push   %eax
f0102f60:	e8 a7 d2 01 00       	call   f012020c <strtol>
f0102f65:	83 c4 10             	add    $0x10,%esp
f0102f68:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102f6b:	eb 24                	jmp    f0102f91 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0102f6d:	e8 5c 3a 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0102f72:	85 c0                	test   %eax,%eax
f0102f74:	74 1b                	je     f0102f91 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 10             	add    $0x10,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 81 d2 01 00       	call   f012020c <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f94:	83 c0 0c             	add    $0xc,%eax
f0102f97:	8b 00                	mov    (%eax),%eax
f0102f99:	83 ec 04             	sub    $0x4,%esp
f0102f9c:	6a 0a                	push   $0xa
f0102f9e:	6a 00                	push   $0x0
f0102fa0:	50                   	push   %eax
f0102fa1:	e8 66 d2 01 00       	call   f012020c <strtol>
f0102fa6:	83 c4 10             	add    $0x10,%esp
f0102fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fac:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faf:	83 c0 08             	add    $0x8,%eax
f0102fb2:	8b 00                	mov    (%eax),%eax
f0102fb4:	83 ec 04             	sub    $0x4,%esp
f0102fb7:	6a 0a                	push   $0xa
f0102fb9:	6a 00                	push   $0x0
f0102fbb:	50                   	push   %eax
f0102fbc:	e8 4b d2 01 00       	call   f012020c <strtol>
f0102fc1:	83 c4 10             	add    $0x10,%esp
f0102fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102fc7:	e9 f7 00 00 00       	jmp    f01030c3 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102fcc:	83 ec 0c             	sub    $0xc,%esp
f0102fcf:	6a 02                	push   $0x2
f0102fd1:	e8 d5 c8 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f0102fd6:	83 c4 10             	add    $0x10,%esp
f0102fd9:	85 c0                	test   %eax,%eax
f0102fdb:	75 4c                	jne    f0103029 <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0102fdd:	e8 d9 39 00 00       	call   f01069bb <isSchedMethodBSD>
f0102fe2:	85 c0                	test   %eax,%eax
f0102fe4:	74 1d                	je     f0103003 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe9:	83 c0 0c             	add    $0xc,%eax
f0102fec:	8b 00                	mov    (%eax),%eax
f0102fee:	83 ec 04             	sub    $0x4,%esp
f0102ff1:	6a 0a                	push   $0xa
f0102ff3:	6a 00                	push   $0x0
f0102ff5:	50                   	push   %eax
f0102ff6:	e8 11 d2 01 00       	call   f012020c <strtol>
f0102ffb:	83 c4 10             	add    $0x10,%esp
f0102ffe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103001:	eb 41                	jmp    f0103044 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103003:	e8 c6 39 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0103008:	85 c0                	test   %eax,%eax
f010300a:	74 38                	je     f0103044 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f010300c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010300f:	83 c0 0c             	add    $0xc,%eax
f0103012:	8b 00                	mov    (%eax),%eax
f0103014:	83 ec 04             	sub    $0x4,%esp
f0103017:	6a 0a                	push   $0xa
f0103019:	6a 00                	push   $0x0
f010301b:	50                   	push   %eax
f010301c:	e8 eb d1 01 00       	call   f012020c <strtol>
f0103021:	83 c4 10             	add    $0x10,%esp
f0103024:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103027:	eb 1b                	jmp    f0103044 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103029:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302c:	83 c0 0c             	add    $0xc,%eax
f010302f:	8b 00                	mov    (%eax),%eax
f0103031:	83 ec 04             	sub    $0x4,%esp
f0103034:	6a 0a                	push   $0xa
f0103036:	6a 00                	push   $0x0
f0103038:	50                   	push   %eax
f0103039:	e8 ce d1 01 00       	call   f012020c <strtol>
f010303e:	83 c4 10             	add    $0x10,%esp
f0103041:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103044:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103047:	83 c0 08             	add    $0x8,%eax
f010304a:	8b 00                	mov    (%eax),%eax
f010304c:	83 ec 04             	sub    $0x4,%esp
f010304f:	6a 0a                	push   $0xa
f0103051:	6a 00                	push   $0x0
f0103053:	50                   	push   %eax
f0103054:	e8 b3 d1 01 00       	call   f012020c <strtol>
f0103059:	83 c4 10             	add    $0x10,%esp
f010305c:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f010305f:	eb 62                	jmp    f01030c3 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103061:	83 ec 0c             	sub    $0xc,%esp
f0103064:	6a 02                	push   $0x2
f0103066:	e8 40 c8 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010306b:	83 c4 10             	add    $0x10,%esp
f010306e:	85 c0                	test   %eax,%eax
f0103070:	74 1a                	je     f010308c <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103072:	83 ec 0c             	sub    $0xc,%esp
f0103075:	68 7c 46 12 f0       	push   $0xf012467c
f010307a:	e8 0c df ff ff       	call   f0100f8b <cprintf>
f010307f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103082:	b8 00 00 00 00       	mov    $0x0,%eax
f0103087:	e9 36 01 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f010308c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010308f:	83 c0 08             	add    $0x8,%eax
f0103092:	8b 00                	mov    (%eax),%eax
f0103094:	83 ec 04             	sub    $0x4,%esp
f0103097:	6a 0a                	push   $0xa
f0103099:	6a 00                	push   $0x0
f010309b:	50                   	push   %eax
f010309c:	e8 6b d1 01 00       	call   f012020c <strtol>
f01030a1:	83 c4 10             	add    $0x10,%esp
f01030a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f01030a7:	eb 1a                	jmp    f01030c3 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f01030a9:	83 ec 0c             	sub    $0xc,%esp
f01030ac:	68 0c 47 12 f0       	push   $0xf012470c
f01030b1:	e8 d5 de ff ff       	call   f0100f8b <cprintf>
f01030b6:	83 c4 10             	add    $0x10,%esp
			return NULL;
f01030b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01030be:	e9 ff 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01030c3:	83 ec 0c             	sub    $0xc,%esp
f01030c6:	6a 02                	push   $0x2
f01030c8:	e8 de c7 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f01030cd:	83 c4 10             	add    $0x10,%esp
f01030d0:	85 c0                	test   %eax,%eax
f01030d2:	74 23                	je     f01030f7 <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f01030d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030d7:	48                   	dec    %eax
f01030d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01030db:	73 1a                	jae    f01030f7 <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f01030dd:	83 ec 0c             	sub    $0xc,%esp
f01030e0:	68 a4 47 12 f0       	push   $0xf01247a4
f01030e5:	e8 a1 de ff ff       	call   f0100f8b <cprintf>
f01030ea:	83 c4 10             	add    $0x10,%esp
				return NULL;
f01030ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01030f2:	e9 cb 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030f7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01030fb:	76 19                	jbe    f0103116 <CreateEnv+0x242>
f01030fd:	68 fc 47 12 f0       	push   $0xf01247fc
f0103102:	68 41 48 12 f0       	push   $0xf0124841
f0103107:	68 af 01 00 00       	push   $0x1af
f010310c:	68 56 48 12 f0       	push   $0xf0124856
f0103111:	e8 23 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103116:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f010311a:	76 19                	jbe    f0103135 <CreateEnv+0x261>
f010311c:	68 fc 47 12 f0       	push   $0xf01247fc
f0103121:	68 41 48 12 f0       	push   $0xf0124841
f0103126:	68 cd 01 00 00       	push   $0x1cd
f010312b:	68 56 48 12 f0       	push   $0xf0124856
f0103130:	e8 04 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103135:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103138:	83 c0 04             	add    $0x4,%eax
f010313b:	8b 00                	mov    (%eax),%eax
f010313d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103140:	ff 75 f0             	pushl  -0x10(%ebp)
f0103143:	ff 75 f4             	pushl  -0xc(%ebp)
f0103146:	50                   	push   %eax
f0103147:	e8 a6 80 00 00       	call   f010b1f2 <env_create>
f010314c:	83 c4 10             	add    $0x10,%esp
f010314f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103152:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103156:	74 49                	je     f01031a1 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103158:	83 ec 08             	sub    $0x8,%esp
f010315b:	ff 75 ec             	pushl  -0x14(%ebp)
f010315e:	68 6a 48 12 f0       	push   $0xf012486a
f0103163:	e8 23 de ff ff       	call   f0100f8b <cprintf>
f0103168:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f010316b:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010316f:	7c 06                	jl     f0103177 <CreateEnv+0x2a3>
f0103171:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103175:	7e 19                	jle    f0103190 <CreateEnv+0x2bc>
f0103177:	68 7c 48 12 f0       	push   $0xf012487c
f010317c:	68 41 48 12 f0       	push   $0xf0124841
f0103181:	68 d2 01 00 00       	push   $0x1d2
f0103186:	68 56 48 12 f0       	push   $0xf0124856
f010318b:	e8 a9 d1 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103190:	83 ec 08             	sub    $0x8,%esp
f0103193:	ff 75 ec             	pushl  -0x14(%ebp)
f0103196:	ff 75 e0             	pushl  -0x20(%ebp)
f0103199:	e8 53 37 00 00       	call   f01068f1 <env_set_nice>
f010319e:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f01031a1:	e8 28 38 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01031a6:	85 c0                	test   %eax,%eax
f01031a8:	74 15                	je     f01031bf <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f01031aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01031ad:	8b 40 10             	mov    0x10(%eax),%eax
f01031b0:	83 ec 08             	sub    $0x8,%esp
f01031b3:	ff 75 e8             	pushl  -0x18(%ebp)
f01031b6:	50                   	push   %eax
f01031b7:	e8 8c 37 00 00       	call   f0106948 <env_set_priority>
f01031bc:	83 c4 10             	add    $0x10,%esp

	return env;
f01031bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01031c2:	c9                   	leave  
f01031c3:	c3                   	ret    

f01031c4 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f01031c4:	55                   	push   %ebp
f01031c5:	89 e5                	mov    %esp,%ebp
f01031c7:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ca:	83 ec 08             	sub    $0x8,%esp
f01031cd:	ff 75 0c             	pushl  0xc(%ebp)
f01031d0:	ff 75 08             	pushl  0x8(%ebp)
f01031d3:	e8 fc fc ff ff       	call   f0102ed4 <CreateEnv>
f01031d8:	83 c4 10             	add    $0x10,%esp
f01031db:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f01031de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01031e2:	75 07                	jne    f01031eb <command_run_program+0x27>
f01031e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01031e9:	eb 46                	jmp    f0103231 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01031eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031ee:	8b 40 10             	mov    0x10(%eax),%eax
f01031f1:	83 ec 08             	sub    $0x8,%esp
f01031f4:	50                   	push   %eax
f01031f5:	68 ac 48 12 f0       	push   $0xf01248ac
f01031fa:	e8 8c dd ff ff       	call   f0100f8b <cprintf>
f01031ff:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103202:	83 ec 0c             	sub    $0xc,%esp
f0103205:	ff 75 f4             	pushl  -0xc(%ebp)
f0103208:	e8 7a 27 00 00       	call   f0105987 <sched_new_env>
f010320d:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103210:	c7 05 30 f7 b1 f0 00 	movl   $0x0,0xf0b1f730
f0103217:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f010321a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321d:	8b 40 10             	mov    0x10(%eax),%eax
f0103220:	83 ec 0c             	sub    $0xc,%esp
f0103223:	50                   	push   %eax
f0103224:	e8 b4 27 00 00       	call   f01059dd <sched_run_env>
f0103229:	83 c4 10             	add    $0x10,%esp

	return 0;
f010322c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103231:	c9                   	leave  
f0103232:	c3                   	ret    

f0103233 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103233:	55                   	push   %ebp
f0103234:	89 e5                	mov    %esp,%ebp
f0103236:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103239:	8b 45 0c             	mov    0xc(%ebp),%eax
f010323c:	83 c0 04             	add    $0x4,%eax
f010323f:	8b 00                	mov    (%eax),%eax
f0103241:	83 ec 04             	sub    $0x4,%esp
f0103244:	6a 0a                	push   $0xa
f0103246:	6a 00                	push   $0x0
f0103248:	50                   	push   %eax
f0103249:	e8 be cf 01 00       	call   f012020c <strtol>
f010324e:	83 c4 10             	add    $0x10,%esp
f0103251:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103257:	83 ec 0c             	sub    $0xc,%esp
f010325a:	50                   	push   %eax
f010325b:	e8 c3 2a 00 00       	call   f0105d23 <sched_kill_env>
f0103260:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103268:	c9                   	leave  
f0103269:	c3                   	ret    

f010326a <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f010326a:	55                   	push   %ebp
f010326b:	89 e5                	mov    %esp,%ebp
f010326d:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103270:	83 ec 08             	sub    $0x8,%esp
f0103273:	ff 75 0c             	pushl  0xc(%ebp)
f0103276:	ff 75 08             	pushl  0x8(%ebp)
f0103279:	e8 56 fc ff ff       	call   f0102ed4 <CreateEnv>
f010327e:	83 c4 10             	add    $0x10,%esp
f0103281:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103284:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103288:	75 07                	jne    f0103291 <commnad_load_env+0x27>
		return 0 ;
f010328a:	b8 00 00 00 00       	mov    $0x0,%eax
f010328f:	eb 2a                	jmp    f01032bb <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103291:	83 ec 0c             	sub    $0xc,%esp
f0103294:	ff 75 f4             	pushl  -0xc(%ebp)
f0103297:	e8 eb 26 00 00       	call   f0105987 <sched_new_env>
f010329c:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010329f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032a2:	8b 40 10             	mov    0x10(%eax),%eax
f01032a5:	83 ec 08             	sub    $0x8,%esp
f01032a8:	50                   	push   %eax
f01032a9:	68 ac 48 12 f0       	push   $0xf01248ac
f01032ae:	e8 d8 dc ff ff       	call   f0100f8b <cprintf>
f01032b3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032bb:	c9                   	leave  
f01032bc:	c3                   	ret    

f01032bd <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01032bd:	55                   	push   %ebp
f01032be:	89 e5                	mov    %esp,%ebp
f01032c0:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f01032c3:	c7 05 30 f7 b1 f0 00 	movl   $0x0,0xf0b1f730
f01032ca:	00 00 00 
	sched_run_all();
f01032cd:	e8 0e 30 00 00       	call   f01062e0 <sched_run_all>

	return 0 ;
f01032d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032d7:	c9                   	leave  
f01032d8:	c3                   	ret    

f01032d9 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01032d9:	55                   	push   %ebp
f01032da:	89 e5                	mov    %esp,%ebp
f01032dc:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01032df:	e8 db 2d 00 00       	call   f01060bf <sched_print_all>

	return 0 ;
f01032e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032e9:	c9                   	leave  
f01032ea:	c3                   	ret    

f01032eb <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01032eb:	55                   	push   %ebp
f01032ec:	89 e5                	mov    %esp,%ebp
f01032ee:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01032f1:	e8 7f 30 00 00       	call   f0106375 <sched_kill_all>

	return 0 ;
f01032f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032fb:	c9                   	leave  
f01032fc:	c3                   	ret    

f01032fd <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01032fd:	55                   	push   %ebp
f01032fe:	89 e5                	mov    %esp,%ebp
f0103300:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103303:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103307:	7f 1a                	jg     f0103323 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103309:	83 ec 0c             	sub    $0xc,%esp
f010330c:	68 c4 48 12 f0       	push   $0xf01248c4
f0103311:	e8 75 dc ff ff       	call   f0100f8b <cprintf>
f0103316:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103319:	b8 00 00 00 00       	mov    $0x0,%eax
f010331e:	e9 83 00 00 00       	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103323:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103326:	83 c0 04             	add    $0x4,%eax
f0103329:	8b 00                	mov    (%eax),%eax
f010332b:	83 ec 04             	sub    $0x4,%esp
f010332e:	6a 0a                	push   $0xa
f0103330:	6a 00                	push   $0x0
f0103332:	50                   	push   %eax
f0103333:	e8 d4 ce 01 00       	call   f012020c <strtol>
f0103338:	83 c4 10             	add    $0x10,%esp
f010333b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f010333e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103342:	75 20                	jne    f0103364 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103344:	83 ec 0c             	sub    $0xc,%esp
f0103347:	ff 75 f4             	pushl  -0xc(%ebp)
f010334a:	e8 d1 c4 00 00       	call   f010f820 <setPageReplacmentAlgorithmLRU>
f010334f:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103352:	83 ec 0c             	sub    $0xc,%esp
f0103355:	68 24 49 12 f0       	push   $0xf0124924
f010335a:	e8 2c dc ff ff       	call   f0100f8b <cprintf>
f010335f:	83 c4 10             	add    $0x10,%esp
f0103362:	eb 3d                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103364:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103368:	75 20                	jne    f010338a <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010336a:	83 ec 0c             	sub    $0xc,%esp
f010336d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103370:	e8 ab c4 00 00       	call   f010f820 <setPageReplacmentAlgorithmLRU>
f0103375:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103378:	83 ec 0c             	sub    $0xc,%esp
f010337b:	68 68 49 12 f0       	push   $0xf0124968
f0103380:	e8 06 dc ff ff       	call   f0100f8b <cprintf>
f0103385:	83 c4 10             	add    $0x10,%esp
f0103388:	eb 17                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010338a:	83 ec 0c             	sub    $0xc,%esp
f010338d:	68 a8 49 12 f0       	push   $0xf01249a8
f0103392:	e8 f4 db ff ff       	call   f0100f8b <cprintf>
f0103397:	83 c4 10             	add    $0x10,%esp
		return 0;
f010339a:	b8 00 00 00 00       	mov    $0x0,%eax
f010339f:	eb 05                	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01033a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a6:	c9                   	leave  
f01033a7:	c3                   	ret    

f01033a8 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01033a8:	55                   	push   %ebp
f01033a9:	89 e5                	mov    %esp,%ebp
f01033ab:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01033ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033b1:	83 c0 04             	add    $0x4,%eax
f01033b4:	8b 00                	mov    (%eax),%eax
f01033b6:	83 ec 04             	sub    $0x4,%esp
f01033b9:	6a 0a                	push   $0xa
f01033bb:	6a 00                	push   $0x0
f01033bd:	50                   	push   %eax
f01033be:	e8 49 ce 01 00       	call   f012020c <strtol>
f01033c3:	83 c4 10             	add    $0x10,%esp
f01033c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f01033c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033cc:	83 c0 08             	add    $0x8,%eax
f01033cf:	8b 00                	mov    (%eax),%eax
f01033d1:	83 ec 04             	sub    $0x4,%esp
f01033d4:	6a 0a                	push   $0xa
f01033d6:	6a 00                	push   $0x0
f01033d8:	50                   	push   %eax
f01033d9:	e8 2e ce 01 00       	call   f012020c <strtol>
f01033de:	83 c4 10             	add    $0x10,%esp
f01033e1:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f01033e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01033e8:	75 17                	jne    f0103401 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f01033ea:	83 ec 0c             	sub    $0xc,%esp
f01033ed:	68 fc 49 12 f0       	push   $0xf01249fc
f01033f2:	e8 94 db ff ff       	call   f0100f8b <cprintf>
f01033f7:	83 c4 10             	add    $0x10,%esp
		return 0;
f01033fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01033ff:	eb 4b                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0103401:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f0103405:	74 22                	je     f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f0103407:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f010340b:	75 05                	jne    f0103412 <command_set_page_rep_nthCLOCK+0x6a>
f010340d:	f7 5d f4             	negl   -0xc(%ebp)
f0103410:	eb 17                	jmp    f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0103412:	83 ec 0c             	sub    $0xc,%esp
f0103415:	68 2c 4a 12 f0       	push   $0xf0124a2c
f010341a:	e8 6c db ff ff       	call   f0100f8b <cprintf>
f010341f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103422:	b8 00 00 00 00       	mov    $0x0,%eax
f0103427:	eb 23                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103429:	83 ec 0c             	sub    $0xc,%esp
f010342c:	ff 75 f4             	pushl  -0xc(%ebp)
f010342f:	e8 5f c4 00 00       	call   f010f893 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103434:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103437:	83 ec 0c             	sub    $0xc,%esp
f010343a:	68 68 4a 12 f0       	push   $0xf0124a68
f010343f:	e8 47 db ff ff       	call   f0100f8b <cprintf>
f0103444:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103447:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010344c:	c9                   	leave  
f010344d:	c3                   	ret    

f010344e <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010344e:	55                   	push   %ebp
f010344f:	89 e5                	mov    %esp,%ebp
f0103451:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103454:	e8 fa c3 00 00       	call   f010f853 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103459:	83 ec 0c             	sub    $0xc,%esp
f010345c:	68 9c 4a 12 f0       	push   $0xf0124a9c
f0103461:	e8 25 db ff ff       	call   f0100f8b <cprintf>
f0103466:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103469:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010346e:	c9                   	leave  
f010346f:	c3                   	ret    

f0103470 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0103470:	55                   	push   %ebp
f0103471:	89 e5                	mov    %esp,%ebp
f0103473:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103476:	e8 e8 c3 00 00       	call   f010f863 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f010347b:	83 ec 0c             	sub    $0xc,%esp
f010347e:	68 c8 4a 12 f0       	push   $0xf0124ac8
f0103483:	e8 03 db ff ff       	call   f0100f8b <cprintf>
f0103488:	83 c4 10             	add    $0x10,%esp
	return 0;
f010348b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103490:	c9                   	leave  
f0103491:	c3                   	ret    

f0103492 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0103492:	55                   	push   %ebp
f0103493:	89 e5                	mov    %esp,%ebp
f0103495:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0103498:	e8 d6 c3 00 00       	call   f010f873 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f010349d:	83 ec 0c             	sub    $0xc,%esp
f01034a0:	68 f0 4a 12 f0       	push   $0xf0124af0
f01034a5:	e8 e1 da ff ff       	call   f0100f8b <cprintf>
f01034aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034b2:	c9                   	leave  
f01034b3:	c3                   	ret    

f01034b4 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01034b4:	55                   	push   %ebp
f01034b5:	89 e5                	mov    %esp,%ebp
f01034b7:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01034ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034bd:	83 c0 04             	add    $0x4,%eax
f01034c0:	8b 00                	mov    (%eax),%eax
f01034c2:	83 ec 04             	sub    $0x4,%esp
f01034c5:	6a 0a                	push   $0xa
f01034c7:	6a 00                	push   $0x0
f01034c9:	50                   	push   %eax
f01034ca:	e8 3d cd 01 00       	call   f012020c <strtol>
f01034cf:	83 c4 10             	add    $0x10,%esp
f01034d2:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01034d5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01034d9:	83 ec 0c             	sub    $0xc,%esp
f01034dc:	50                   	push   %eax
f01034dd:	e8 7f 37 00 00       	call   f0106c61 <sched_init_RR>
f01034e2:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f01034e5:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f01034ea:	8a 00                	mov    (%eax),%al
f01034ec:	0f b6 c0             	movzbl %al,%eax
f01034ef:	83 ec 08             	sub    $0x8,%esp
f01034f2:	50                   	push   %eax
f01034f3:	68 24 4b 12 f0       	push   $0xf0124b24
f01034f8:	e8 8e da ff ff       	call   f0100f8b <cprintf>
f01034fd:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103500:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103505:	c9                   	leave  
f0103506:	c3                   	ret    

f0103507 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103507:	55                   	push   %ebp
f0103508:	89 e5                	mov    %esp,%ebp
f010350a:	53                   	push   %ebx
f010350b:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010350e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103511:	83 c0 04             	add    $0x4,%eax
f0103514:	8b 00                	mov    (%eax),%eax
f0103516:	83 ec 04             	sub    $0x4,%esp
f0103519:	6a 0a                	push   $0xa
f010351b:	6a 00                	push   $0x0
f010351d:	50                   	push   %eax
f010351e:	e8 e9 cc 01 00       	call   f012020c <strtol>
f0103523:	83 c4 10             	add    $0x10,%esp
f0103526:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103529:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103530:	eb 2e                	jmp    f0103560 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0103532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103535:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103538:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010353b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103542:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103545:	01 d0                	add    %edx,%eax
f0103547:	8b 00                	mov    (%eax),%eax
f0103549:	83 ec 04             	sub    $0x4,%esp
f010354c:	6a 0a                	push   $0xa
f010354e:	6a 00                	push   $0x0
f0103550:	50                   	push   %eax
f0103551:	e8 b6 cc 01 00       	call   f012020c <strtol>
f0103556:	83 c4 10             	add    $0x10,%esp
f0103559:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010355d:	ff 45 f4             	incl   -0xc(%ebp)
f0103560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103563:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103566:	7c ca                	jl     f0103532 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103568:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010356c:	83 ec 08             	sub    $0x8,%esp
f010356f:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103572:	52                   	push   %edx
f0103573:	50                   	push   %eax
f0103574:	e8 96 37 00 00       	call   f0106d0f <sched_init_MLFQ>
f0103579:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010357c:	83 ec 0c             	sub    $0xc,%esp
f010357f:	68 5c 4b 12 f0       	push   $0xf0124b5c
f0103584:	e8 02 da ff ff       	call   f0100f8b <cprintf>
f0103589:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010358c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103593:	eb 24                	jmp    f01035b9 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f0103595:	8b 15 44 f4 b1 f0    	mov    0xf0b1f444,%edx
f010359b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010359e:	01 d0                	add    %edx,%eax
f01035a0:	8a 00                	mov    (%eax),%al
f01035a2:	0f b6 c0             	movzbl %al,%eax
f01035a5:	83 ec 08             	sub    $0x8,%esp
f01035a8:	50                   	push   %eax
f01035a9:	68 89 4b 12 f0       	push   $0xf0124b89
f01035ae:	e8 d8 d9 ff ff       	call   f0100f8b <cprintf>
f01035b3:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01035b6:	ff 45 f0             	incl   -0x10(%ebp)
f01035b9:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f01035be:	0f b6 c0             	movzbl %al,%eax
f01035c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01035c4:	7f cf                	jg     f0103595 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01035c6:	83 ec 0c             	sub    $0xc,%esp
f01035c9:	68 a1 44 12 f0       	push   $0xf01244a1
f01035ce:	e8 b8 d9 ff ff       	call   f0100f8b <cprintf>
f01035d3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01035de:	c9                   	leave  
f01035df:	c3                   	ret    

f01035e0 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01035e0:	55                   	push   %ebp
f01035e1:	89 e5                	mov    %esp,%ebp
f01035e3:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01035e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e9:	83 c0 04             	add    $0x4,%eax
f01035ec:	8b 00                	mov    (%eax),%eax
f01035ee:	83 ec 04             	sub    $0x4,%esp
f01035f1:	6a 0a                	push   $0xa
f01035f3:	6a 00                	push   $0x0
f01035f5:	50                   	push   %eax
f01035f6:	e8 11 cc 01 00       	call   f012020c <strtol>
f01035fb:	83 c4 10             	add    $0x10,%esp
f01035fe:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103601:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103604:	83 c0 08             	add    $0x8,%eax
f0103607:	8b 00                	mov    (%eax),%eax
f0103609:	83 ec 04             	sub    $0x4,%esp
f010360c:	6a 0a                	push   $0xa
f010360e:	6a 00                	push   $0x0
f0103610:	50                   	push   %eax
f0103611:	e8 f6 cb 01 00       	call   f012020c <strtol>
f0103616:	83 c4 10             	add    $0x10,%esp
f0103619:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f010361c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103620:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103624:	83 ec 08             	sub    $0x8,%esp
f0103627:	52                   	push   %edx
f0103628:	50                   	push   %eax
f0103629:	e8 09 37 00 00       	call   f0106d37 <sched_init_BSD>
f010362e:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0103631:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103635:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103639:	83 ec 04             	sub    $0x4,%esp
f010363c:	52                   	push   %edx
f010363d:	50                   	push   %eax
f010363e:	68 90 4b 12 f0       	push   $0xf0124b90
f0103643:	e8 43 d9 ff ff       	call   f0100f8b <cprintf>
f0103648:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010364b:	83 ec 0c             	sub    $0xc,%esp
f010364e:	68 a1 44 12 f0       	push   $0xf01244a1
f0103653:	e8 33 d9 ff ff       	call   f0100f8b <cprintf>
f0103658:	83 c4 10             	add    $0x10,%esp
	return 0;
f010365b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103660:	c9                   	leave  
f0103661:	c3                   	ret    

f0103662 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0103662:	55                   	push   %ebp
f0103663:	89 e5                	mov    %esp,%ebp
f0103665:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f0103668:	8b 45 0c             	mov    0xc(%ebp),%eax
f010366b:	83 c0 04             	add    $0x4,%eax
f010366e:	8b 00                	mov    (%eax),%eax
f0103670:	83 ec 04             	sub    $0x4,%esp
f0103673:	6a 0a                	push   $0xa
f0103675:	6a 00                	push   $0x0
f0103677:	50                   	push   %eax
f0103678:	e8 8f cb 01 00       	call   f012020c <strtol>
f010367d:	83 c4 10             	add    $0x10,%esp
f0103680:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f0103683:	83 ec 0c             	sub    $0xc,%esp
f0103686:	ff 75 f4             	pushl  -0xc(%ebp)
f0103689:	e8 eb 32 00 00       	call   f0106979 <sched_set_starv_thresh>
f010368e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103691:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103696:	c9                   	leave  
f0103697:	c3                   	ret    

f0103698 <command_set_priority>:
int command_set_priority(int number_of_arguments, char **arguments)
{
f0103698:	55                   	push   %ebp
f0103699:	89 e5                	mov    %esp,%ebp
f010369b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010369e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a1:	83 c0 04             	add    $0x4,%eax
f01036a4:	8b 00                	mov    (%eax),%eax
f01036a6:	83 ec 04             	sub    $0x4,%esp
f01036a9:	6a 0a                	push   $0xa
f01036ab:	6a 00                	push   $0x0
f01036ad:	50                   	push   %eax
f01036ae:	e8 59 cb 01 00       	call   f012020c <strtol>
f01036b3:	83 c4 10             	add    $0x10,%esp
f01036b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01036b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036bc:	83 c0 08             	add    $0x8,%eax
f01036bf:	8b 00                	mov    (%eax),%eax
f01036c1:	83 ec 04             	sub    $0x4,%esp
f01036c4:	6a 0a                	push   $0xa
f01036c6:	6a 00                	push   $0x0
f01036c8:	50                   	push   %eax
f01036c9:	e8 3e cb 01 00       	call   f012020c <strtol>
f01036ce:	83 c4 10             	add    $0x10,%esp
f01036d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01036d4:	83 ec 08             	sub    $0x8,%esp
f01036d7:	ff 75 f0             	pushl  -0x10(%ebp)
f01036da:	ff 75 f4             	pushl  -0xc(%ebp)
f01036dd:	e8 66 32 00 00       	call   f0106948 <env_set_priority>
f01036e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036ea:	c9                   	leave  
f01036eb:	c3                   	ret    

f01036ec <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01036ec:	55                   	push   %ebp
f01036ed:	89 e5                	mov    %esp,%ebp
f01036ef:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01036f2:	e8 b1 32 00 00       	call   f01069a8 <isSchedMethodMLFQ>
f01036f7:	85 c0                	test   %eax,%eax
f01036f9:	74 5f                	je     f010375a <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01036fb:	83 ec 0c             	sub    $0xc,%esp
f01036fe:	68 cc 4b 12 f0       	push   $0xf0124bcc
f0103703:	e8 83 d8 ff ff       	call   f0100f8b <cprintf>
f0103708:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010370b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103712:	eb 24                	jmp    f0103738 <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f0103714:	8b 15 44 f4 b1 f0    	mov    0xf0b1f444,%edx
f010371a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010371d:	01 d0                	add    %edx,%eax
f010371f:	8a 00                	mov    (%eax),%al
f0103721:	0f b6 c0             	movzbl %al,%eax
f0103724:	83 ec 08             	sub    $0x8,%esp
f0103727:	50                   	push   %eax
f0103728:	68 89 4b 12 f0       	push   $0xf0124b89
f010372d:	e8 59 d8 ff ff       	call   f0100f8b <cprintf>
f0103732:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103735:	ff 45 f4             	incl   -0xc(%ebp)
f0103738:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f010373d:	0f b6 c0             	movzbl %al,%eax
f0103740:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103743:	7f cf                	jg     f0103714 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103745:	83 ec 0c             	sub    $0xc,%esp
f0103748:	68 a1 44 12 f0       	push   $0xf01244a1
f010374d:	e8 39 d8 ff ff       	call   f0100f8b <cprintf>
f0103752:	83 c4 10             	add    $0x10,%esp
f0103755:	e9 94 00 00 00       	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f010375a:	e8 37 32 00 00       	call   f0106996 <isSchedMethodRR>
f010375f:	85 c0                	test   %eax,%eax
f0103761:	74 1d                	je     f0103780 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103763:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0103768:	8a 00                	mov    (%eax),%al
f010376a:	0f b6 c0             	movzbl %al,%eax
f010376d:	83 ec 08             	sub    $0x8,%esp
f0103770:	50                   	push   %eax
f0103771:	68 00 4c 12 f0       	push   $0xf0124c00
f0103776:	e8 10 d8 ff ff       	call   f0100f8b <cprintf>
f010377b:	83 c4 10             	add    $0x10,%esp
f010377e:	eb 6e                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0103780:	e8 36 32 00 00       	call   f01069bb <isSchedMethodBSD>
f0103785:	85 c0                	test   %eax,%eax
f0103787:	74 26                	je     f01037af <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103789:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f010378e:	8a 00                	mov    (%eax),%al
f0103790:	0f b6 d0             	movzbl %al,%edx
f0103793:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f0103798:	0f b6 c0             	movzbl %al,%eax
f010379b:	83 ec 04             	sub    $0x4,%esp
f010379e:	52                   	push   %edx
f010379f:	50                   	push   %eax
f01037a0:	68 90 4b 12 f0       	push   $0xf0124b90
f01037a5:	e8 e1 d7 ff ff       	call   f0100f8b <cprintf>
f01037aa:	83 c4 10             	add    $0x10,%esp
f01037ad:	eb 3f                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01037af:	e8 1a 32 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01037b4:	85 c0                	test   %eax,%eax
f01037b6:	74 26                	je     f01037de <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01037b8:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f01037bd:	8a 00                	mov    (%eax),%al
f01037bf:	0f b6 d0             	movzbl %al,%edx
f01037c2:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f01037c7:	0f b6 c0             	movzbl %al,%eax
f01037ca:	83 ec 04             	sub    $0x4,%esp
f01037cd:	52                   	push   %edx
f01037ce:	50                   	push   %eax
f01037cf:	68 3c 4c 12 f0       	push   $0xf0124c3c
f01037d4:	e8 b2 d7 ff ff       	call   f0100f8b <cprintf>
f01037d9:	83 c4 10             	add    $0x10,%esp
f01037dc:	eb 10                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01037de:	83 ec 0c             	sub    $0xc,%esp
f01037e1:	68 84 4c 12 f0       	push   $0xf0124c84
f01037e6:	e8 a0 d7 ff ff       	call   f0100f8b <cprintf>
f01037eb:	83 c4 10             	add    $0x10,%esp

	return 0;
f01037ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037f3:	c9                   	leave  
f01037f4:	c3                   	ret    

f01037f5 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01037f5:	55                   	push   %ebp
f01037f6:	89 e5                	mov    %esp,%ebp
f01037f8:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01037fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01037fe:	83 c0 04             	add    $0x4,%eax
f0103801:	8b 00                	mov    (%eax),%eax
f0103803:	83 ec 04             	sub    $0x4,%esp
f0103806:	6a 0a                	push   $0xa
f0103808:	6a 00                	push   $0x0
f010380a:	50                   	push   %eax
f010380b:	e8 fc c9 01 00       	call   f012020c <strtol>
f0103810:	83 c4 10             	add    $0x10,%esp
f0103813:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103816:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103819:	0f b6 c0             	movzbl %al,%eax
f010381c:	83 ec 0c             	sub    $0xc,%esp
f010381f:	50                   	push   %eax
f0103820:	e8 db b7 01 00       	call   f011f000 <chksch>
f0103825:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010382c:	75 12                	jne    f0103840 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010382e:	83 ec 0c             	sub    $0xc,%esp
f0103831:	68 ac 4c 12 f0       	push   $0xf0124cac
f0103836:	e8 50 d7 ff ff       	call   f0100f8b <cprintf>
f010383b:	83 c4 10             	add    $0x10,%esp
f010383e:	eb 16                	jmp    f0103856 <command_sch_test+0x61>
	else if (status == 1)
f0103840:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103844:	75 10                	jne    f0103856 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103846:	83 ec 0c             	sub    $0xc,%esp
f0103849:	68 d4 4c 12 f0       	push   $0xf0124cd4
f010384e:	e8 38 d7 ff ff       	call   f0100f8b <cprintf>
f0103853:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103856:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010385b:	c9                   	leave  
f010385c:	c3                   	ret    

f010385d <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010385d:	55                   	push   %ebp
f010385e:	89 e5                	mov    %esp,%ebp
f0103860:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103863:	e8 59 c0 00 00       	call   f010f8c1 <isPageReplacmentAlgorithmCLOCK>
f0103868:	85 c0                	test   %eax,%eax
f010386a:	74 15                	je     f0103881 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010386c:	83 ec 0c             	sub    $0xc,%esp
f010386f:	68 f8 4c 12 f0       	push   $0xf0124cf8
f0103874:	e8 12 d7 ff ff       	call   f0100f8b <cprintf>
f0103879:	83 c4 10             	add    $0x10,%esp
f010387c:	e9 e1 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103881:	83 ec 0c             	sub    $0xc,%esp
f0103884:	6a 01                	push   $0x1
f0103886:	e8 20 c0 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010388b:	83 c4 10             	add    $0x10,%esp
f010388e:	85 c0                	test   %eax,%eax
f0103890:	74 15                	je     f01038a7 <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103892:	83 ec 0c             	sub    $0xc,%esp
f0103895:	68 20 4d 12 f0       	push   $0xf0124d20
f010389a:	e8 ec d6 ff ff       	call   f0100f8b <cprintf>
f010389f:	83 c4 10             	add    $0x10,%esp
f01038a2:	e9 bb 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01038a7:	83 ec 0c             	sub    $0xc,%esp
f01038aa:	6a 02                	push   $0x2
f01038ac:	e8 fa bf 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f01038b1:	83 c4 10             	add    $0x10,%esp
f01038b4:	85 c0                	test   %eax,%eax
f01038b6:	74 15                	je     f01038cd <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01038b8:	83 ec 0c             	sub    $0xc,%esp
f01038bb:	68 60 4d 12 f0       	push   $0xf0124d60
f01038c0:	e8 c6 d6 ff ff       	call   f0100f8b <cprintf>
f01038c5:	83 c4 10             	add    $0x10,%esp
f01038c8:	e9 95 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmFIFO())
f01038cd:	e8 0a c0 00 00       	call   f010f8dc <isPageReplacmentAlgorithmFIFO>
f01038d2:	85 c0                	test   %eax,%eax
f01038d4:	74 12                	je     f01038e8 <command_print_page_rep+0x8b>
		cprintf("Page replacement algorithm is FIFO\n");
f01038d6:	83 ec 0c             	sub    $0xc,%esp
f01038d9:	68 9c 4d 12 f0       	push   $0xf0124d9c
f01038de:	e8 a8 d6 ff ff       	call   f0100f8b <cprintf>
f01038e3:	83 c4 10             	add    $0x10,%esp
f01038e6:	eb 7a                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01038e8:	e8 0a c0 00 00       	call   f010f8f7 <isPageReplacmentAlgorithmModifiedCLOCK>
f01038ed:	85 c0                	test   %eax,%eax
f01038ef:	74 12                	je     f0103903 <command_print_page_rep+0xa6>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01038f1:	83 ec 0c             	sub    $0xc,%esp
f01038f4:	68 c0 4d 12 f0       	push   $0xf0124dc0
f01038f9:	e8 8d d6 ff ff       	call   f0100f8b <cprintf>
f01038fe:	83 c4 10             	add    $0x10,%esp
f0103901:	eb 5f                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0103903:	e8 25 c0 00 00       	call   f010f92d <isPageReplacmentAlgorithmNchanceCLOCK>
f0103908:	85 c0                	test   %eax,%eax
f010390a:	74 46                	je     f0103952 <command_print_page_rep+0xf5>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f010390c:	83 ec 0c             	sub    $0xc,%esp
f010390f:	68 f0 4d 12 f0       	push   $0xf0124df0
f0103914:	e8 72 d6 ff ff       	call   f0100f8b <cprintf>
f0103919:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f010391c:	a1 14 f1 71 f0       	mov    0xf071f114,%eax
f0103921:	85 c0                	test   %eax,%eax
f0103923:	7e 12                	jle    f0103937 <command_print_page_rep+0xda>
f0103925:	83 ec 0c             	sub    $0xc,%esp
f0103928:	68 20 4e 12 f0       	push   $0xf0124e20
f010392d:	e8 59 d6 ff ff       	call   f0100f8b <cprintf>
f0103932:	83 c4 10             	add    $0x10,%esp
f0103935:	eb 2b                	jmp    f0103962 <command_print_page_rep+0x105>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f0103937:	a1 14 f1 71 f0       	mov    0xf071f114,%eax
f010393c:	85 c0                	test   %eax,%eax
f010393e:	79 22                	jns    f0103962 <command_print_page_rep+0x105>
f0103940:	83 ec 0c             	sub    $0xc,%esp
f0103943:	68 2e 4e 12 f0       	push   $0xf0124e2e
f0103948:	e8 3e d6 ff ff       	call   f0100f8b <cprintf>
f010394d:	83 c4 10             	add    $0x10,%esp
f0103950:	eb 10                	jmp    f0103962 <command_print_page_rep+0x105>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0103952:	83 ec 0c             	sub    $0xc,%esp
f0103955:	68 40 4e 12 f0       	push   $0xf0124e40
f010395a:	e8 2c d6 ff ff       	call   f0100f8b <cprintf>
f010395f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103962:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103967:	c9                   	leave  
f0103968:	c3                   	ret    

f0103969 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103969:	55                   	push   %ebp
f010396a:	89 e5                	mov    %esp,%ebp
f010396c:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010396f:	e8 3b ec ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103974:	83 ec 0c             	sub    $0xc,%esp
f0103977:	68 6c 4e 12 f0       	push   $0xf0124e6c
f010397c:	e8 0a d6 ff ff       	call   f0100f8b <cprintf>
f0103981:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103984:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103989:	c9                   	leave  
f010398a:	c3                   	ret    

f010398b <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010398b:	55                   	push   %ebp
f010398c:	89 e5                	mov    %esp,%ebp
f010398e:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103991:	e8 29 ec ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f0103996:	83 ec 0c             	sub    $0xc,%esp
f0103999:	68 9c 4e 12 f0       	push   $0xf0124e9c
f010399e:	e8 e8 d5 ff ff       	call   f0100f8b <cprintf>
f01039a3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ab:	c9                   	leave  
f01039ac:	c3                   	ret    

f01039ad <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01039ad:	55                   	push   %ebp
f01039ae:	89 e5                	mov    %esp,%ebp
f01039b0:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01039b3:	e8 17 ec ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01039b8:	83 ec 0c             	sub    $0xc,%esp
f01039bb:	68 cc 4e 12 f0       	push   $0xf0124ecc
f01039c0:	e8 c6 d5 ff ff       	call   f0100f8b <cprintf>
f01039c5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039cd:	c9                   	leave  
f01039ce:	c3                   	ret    

f01039cf <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01039cf:	55                   	push   %ebp
f01039d0:	89 e5                	mov    %esp,%ebp
f01039d2:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01039d5:	e8 05 ec ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01039da:	83 ec 0c             	sub    $0xc,%esp
f01039dd:	68 fc 4e 12 f0       	push   $0xf0124efc
f01039e2:	e8 a4 d5 ff ff       	call   f0100f8b <cprintf>
f01039e7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ef:	c9                   	leave  
f01039f0:	c3                   	ret    

f01039f1 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01039f1:	55                   	push   %ebp
f01039f2:	89 e5                	mov    %esp,%ebp
f01039f4:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f01039f7:	e8 f3 eb ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f01039fc:	84 c0                	test   %al,%al
f01039fe:	74 12                	je     f0103a12 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103a00:	83 ec 0c             	sub    $0xc,%esp
f0103a03:	68 2c 4f 12 f0       	push   $0xf0124f2c
f0103a08:	e8 7e d5 ff ff       	call   f0100f8b <cprintf>
f0103a0d:	83 c4 10             	add    $0x10,%esp
f0103a10:	eb 61                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0103a12:	e8 ed eb ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103a17:	84 c0                	test   %al,%al
f0103a19:	74 12                	je     f0103a2d <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103a1b:	83 ec 0c             	sub    $0xc,%esp
f0103a1e:	68 58 4f 12 f0       	push   $0xf0124f58
f0103a23:	e8 63 d5 ff ff       	call   f0100f8b <cprintf>
f0103a28:	83 c4 10             	add    $0x10,%esp
f0103a2b:	eb 46                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103a2d:	e8 e7 eb ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f0103a32:	84 c0                	test   %al,%al
f0103a34:	74 12                	je     f0103a48 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103a36:	83 ec 0c             	sub    $0xc,%esp
f0103a39:	68 84 4f 12 f0       	push   $0xf0124f84
f0103a3e:	e8 48 d5 ff ff       	call   f0100f8b <cprintf>
f0103a43:	83 c4 10             	add    $0x10,%esp
f0103a46:	eb 2b                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103a48:	e8 e1 eb ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103a4d:	84 c0                	test   %al,%al
f0103a4f:	74 12                	je     f0103a63 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0103a51:	83 ec 0c             	sub    $0xc,%esp
f0103a54:	68 b0 4f 12 f0       	push   $0xf0124fb0
f0103a59:	e8 2d d5 ff ff       	call   f0100f8b <cprintf>
f0103a5e:	83 c4 10             	add    $0x10,%esp
f0103a61:	eb 10                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0103a63:	83 ec 0c             	sub    $0xc,%esp
f0103a66:	68 dc 4f 12 f0       	push   $0xf0124fdc
f0103a6b:	e8 1b d5 ff ff       	call   f0100f8b <cprintf>
f0103a70:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103a73:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a78:	c9                   	leave  
f0103a79:	c3                   	ret    

f0103a7a <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103a7a:	55                   	push   %ebp
f0103a7b:	89 e5                	mov    %esp,%ebp
f0103a7d:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103a80:	e8 72 ea ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103a85:	83 ec 0c             	sub    $0xc,%esp
f0103a88:	68 08 50 12 f0       	push   $0xf0125008
f0103a8d:	e8 f9 d4 ff ff       	call   f0100f8b <cprintf>
f0103a92:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a95:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a9a:	c9                   	leave  
f0103a9b:	c3                   	ret    

f0103a9c <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103a9c:	55                   	push   %ebp
f0103a9d:	89 e5                	mov    %esp,%ebp
f0103a9f:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f0103aa2:	e8 60 ea ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103aa7:	83 ec 0c             	sub    $0xc,%esp
f0103aaa:	68 08 50 12 f0       	push   $0xf0125008
f0103aaf:	e8 d7 d4 ff ff       	call   f0100f8b <cprintf>
f0103ab4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103abc:	c9                   	leave  
f0103abd:	c3                   	ret    

f0103abe <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103abe:	55                   	push   %ebp
f0103abf:	89 e5                	mov    %esp,%ebp
f0103ac1:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103ac4:	e8 4e ea ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103ac9:	83 ec 0c             	sub    $0xc,%esp
f0103acc:	68 3c 50 12 f0       	push   $0xf012503c
f0103ad1:	e8 b5 d4 ff ff       	call   f0100f8b <cprintf>
f0103ad6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ad9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ade:	c9                   	leave  
f0103adf:	c3                   	ret    

f0103ae0 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103ae0:	55                   	push   %ebp
f0103ae1:	89 e5                	mov    %esp,%ebp
f0103ae3:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103ae6:	e8 3c ea ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103aeb:	83 ec 0c             	sub    $0xc,%esp
f0103aee:	68 6c 50 12 f0       	push   $0xf012506c
f0103af3:	e8 93 d4 ff ff       	call   f0100f8b <cprintf>
f0103af8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103afb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b00:	c9                   	leave  
f0103b01:	c3                   	ret    

f0103b02 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103b02:	55                   	push   %ebp
f0103b03:	89 e5                	mov    %esp,%ebp
f0103b05:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103b08:	e8 2a ea ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103b0d:	83 ec 0c             	sub    $0xc,%esp
f0103b10:	68 9c 50 12 f0       	push   $0xf012509c
f0103b15:	e8 71 d4 ff ff       	call   f0100f8b <cprintf>
f0103b1a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b1d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b22:	c9                   	leave  
f0103b23:	c3                   	ret    

f0103b24 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103b24:	55                   	push   %ebp
f0103b25:	89 e5                	mov    %esp,%ebp
f0103b27:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103b2a:	e8 18 ea ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f0103b2f:	84 c0                	test   %al,%al
f0103b31:	74 12                	je     f0103b45 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103b33:	83 ec 0c             	sub    $0xc,%esp
f0103b36:	68 d0 50 12 f0       	push   $0xf01250d0
f0103b3b:	e8 4b d4 ff ff       	call   f0100f8b <cprintf>
f0103b40:	83 c4 10             	add    $0x10,%esp
f0103b43:	eb 7c                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103b45:	e8 11 ea ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103b4a:	84 c0                	test   %al,%al
f0103b4c:	74 12                	je     f0103b60 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0103b4e:	83 ec 0c             	sub    $0xc,%esp
f0103b51:	68 0c 51 12 f0       	push   $0xf012510c
f0103b56:	e8 30 d4 ff ff       	call   f0100f8b <cprintf>
f0103b5b:	83 c4 10             	add    $0x10,%esp
f0103b5e:	eb 61                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f0103b60:	e8 0b ea ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103b65:	84 c0                	test   %al,%al
f0103b67:	74 12                	je     f0103b7b <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103b69:	83 ec 0c             	sub    $0xc,%esp
f0103b6c:	68 3c 51 12 f0       	push   $0xf012513c
f0103b71:	e8 15 d4 ff ff       	call   f0100f8b <cprintf>
f0103b76:	83 c4 10             	add    $0x10,%esp
f0103b79:	eb 46                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103b7b:	e8 05 ea ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f0103b80:	84 c0                	test   %al,%al
f0103b82:	74 12                	je     f0103b96 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103b84:	83 ec 0c             	sub    $0xc,%esp
f0103b87:	68 68 51 12 f0       	push   $0xf0125168
f0103b8c:	e8 fa d3 ff ff       	call   f0100f8b <cprintf>
f0103b91:	83 c4 10             	add    $0x10,%esp
f0103b94:	eb 2b                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f0103b96:	e8 ff e9 ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f0103b9b:	84 c0                	test   %al,%al
f0103b9d:	74 12                	je     f0103bb1 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103b9f:	83 ec 0c             	sub    $0xc,%esp
f0103ba2:	68 94 51 12 f0       	push   $0xf0125194
f0103ba7:	e8 df d3 ff ff       	call   f0100f8b <cprintf>
f0103bac:	83 c4 10             	add    $0x10,%esp
f0103baf:	eb 10                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103bb1:	83 ec 0c             	sub    $0xc,%esp
f0103bb4:	68 c4 51 12 f0       	push   $0xf01251c4
f0103bb9:	e8 cd d3 ff ff       	call   f0100f8b <cprintf>
f0103bbe:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103bc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bc6:	c9                   	leave  
f0103bc7:	c3                   	ret    

f0103bc8 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103bc8:	55                   	push   %ebp
f0103bc9:	89 e5                	mov    %esp,%ebp
f0103bcb:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103bce:	e8 9b bd 00 00       	call   f010f96e <isBufferingEnabled>
f0103bd3:	84 c0                	test   %al,%al
f0103bd5:	75 12                	jne    f0103be9 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103bd7:	83 ec 0c             	sub    $0xc,%esp
f0103bda:	68 f4 51 12 f0       	push   $0xf01251f4
f0103bdf:	e8 a7 d3 ff ff       	call   f0100f8b <cprintf>
f0103be4:	83 c4 10             	add    $0x10,%esp
f0103be7:	eb 1d                	jmp    f0103c06 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103be9:	83 ec 0c             	sub    $0xc,%esp
f0103bec:	6a 00                	push   $0x0
f0103bee:	e8 55 bd 00 00       	call   f010f948 <enableModifiedBuffer>
f0103bf3:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103bf6:	83 ec 0c             	sub    $0xc,%esp
f0103bf9:	68 30 52 12 f0       	push   $0xf0125230
f0103bfe:	e8 88 d3 ff ff       	call   f0100f8b <cprintf>
f0103c03:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c06:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c0b:	c9                   	leave  
f0103c0c:	c3                   	ret    

f0103c0d <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103c0d:	55                   	push   %ebp
f0103c0e:	89 e5                	mov    %esp,%ebp
f0103c10:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103c13:	e8 56 bd 00 00       	call   f010f96e <isBufferingEnabled>
f0103c18:	84 c0                	test   %al,%al
f0103c1a:	75 12                	jne    f0103c2e <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103c1c:	83 ec 0c             	sub    $0xc,%esp
f0103c1f:	68 f4 51 12 f0       	push   $0xf01251f4
f0103c24:	e8 62 d3 ff ff       	call   f0100f8b <cprintf>
f0103c29:	83 c4 10             	add    $0x10,%esp
f0103c2c:	eb 1d                	jmp    f0103c4b <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103c2e:	83 ec 0c             	sub    $0xc,%esp
f0103c31:	6a 01                	push   $0x1
f0103c33:	e8 10 bd 00 00       	call   f010f948 <enableModifiedBuffer>
f0103c38:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103c3b:	83 ec 0c             	sub    $0xc,%esp
f0103c3e:	68 54 52 12 f0       	push   $0xf0125254
f0103c43:	e8 43 d3 ff ff       	call   f0100f8b <cprintf>
f0103c48:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c50:	c9                   	leave  
f0103c51:	c3                   	ret    

f0103c52 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103c52:	55                   	push   %ebp
f0103c53:	89 e5                	mov    %esp,%ebp
f0103c55:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103c58:	83 ec 0c             	sub    $0xc,%esp
f0103c5b:	6a 00                	push   $0x0
f0103c5d:	e8 fe bc 00 00       	call   f010f960 <enableBuffering>
f0103c62:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103c65:	83 ec 0c             	sub    $0xc,%esp
f0103c68:	6a 00                	push   $0x0
f0103c6a:	e8 d9 bc 00 00       	call   f010f948 <enableModifiedBuffer>
f0103c6f:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103c72:	83 ec 0c             	sub    $0xc,%esp
f0103c75:	68 74 52 12 f0       	push   $0xf0125274
f0103c7a:	e8 0c d3 ff ff       	call   f0100f8b <cprintf>
f0103c7f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103c82:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c87:	c9                   	leave  
f0103c88:	c3                   	ret    

f0103c89 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103c89:	55                   	push   %ebp
f0103c8a:	89 e5                	mov    %esp,%ebp
f0103c8c:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103c8f:	83 ec 0c             	sub    $0xc,%esp
f0103c92:	6a 01                	push   $0x1
f0103c94:	e8 c7 bc 00 00       	call   f010f960 <enableBuffering>
f0103c99:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103c9c:	83 ec 0c             	sub    $0xc,%esp
f0103c9f:	6a 01                	push   $0x1
f0103ca1:	e8 a2 bc 00 00       	call   f010f948 <enableModifiedBuffer>
f0103ca6:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ca9:	e8 d8 bc 00 00       	call   f010f986 <getModifiedBufferLength>
f0103cae:	85 c0                	test   %eax,%eax
f0103cb0:	75 59                	jne    f0103d0b <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103cb2:	83 ec 0c             	sub    $0xc,%esp
f0103cb5:	68 90 52 12 f0       	push   $0xf0125290
f0103cba:	e8 cc d2 ff ff       	call   f0100f8b <cprintf>
f0103cbf:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103cc2:	83 ec 08             	sub    $0x8,%esp
f0103cc5:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103cc8:	50                   	push   %eax
f0103cc9:	68 c0 52 12 f0       	push   $0xf01252c0
f0103cce:	e8 d1 bf 01 00       	call   f011fca4 <readline>
f0103cd3:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103cd6:	83 ec 04             	sub    $0x4,%esp
f0103cd9:	6a 0a                	push   $0xa
f0103cdb:	6a 00                	push   $0x0
f0103cdd:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ce0:	50                   	push   %eax
f0103ce1:	e8 26 c5 01 00       	call   f012020c <strtol>
f0103ce6:	83 c4 10             	add    $0x10,%esp
f0103ce9:	83 ec 0c             	sub    $0xc,%esp
f0103cec:	50                   	push   %eax
f0103ced:	e8 86 bc 00 00       	call   f010f978 <setModifiedBufferLength>
f0103cf2:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103cf5:	e8 8c bc 00 00       	call   f010f986 <getModifiedBufferLength>
f0103cfa:	83 ec 08             	sub    $0x8,%esp
f0103cfd:	50                   	push   %eax
f0103cfe:	68 ec 52 12 f0       	push   $0xf01252ec
f0103d03:	e8 83 d2 ff ff       	call   f0100f8b <cprintf>
f0103d08:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103d0b:	83 ec 0c             	sub    $0xc,%esp
f0103d0e:	68 11 53 12 f0       	push   $0xf0125311
f0103d13:	e8 73 d2 ff ff       	call   f0100f8b <cprintf>
f0103d18:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d20:	c9                   	leave  
f0103d21:	c3                   	ret    

f0103d22 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d22:	55                   	push   %ebp
f0103d23:	89 e5                	mov    %esp,%ebp
f0103d25:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103d28:	e8 41 bc 00 00       	call   f010f96e <isBufferingEnabled>
f0103d2d:	84 c0                	test   %al,%al
f0103d2f:	75 12                	jne    f0103d43 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103d31:	83 ec 0c             	sub    $0xc,%esp
f0103d34:	68 2c 53 12 f0       	push   $0xf012532c
f0103d39:	e8 4d d2 ff ff       	call   f0100f8b <cprintf>
f0103d3e:	83 c4 10             	add    $0x10,%esp
f0103d41:	eb 19                	jmp    f0103d5c <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103d43:	e8 0e bc 00 00       	call   f010f956 <isModifiedBufferEnabled>
f0103d48:	84 c0                	test   %al,%al
f0103d4a:	75 10                	jne    f0103d5c <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103d4c:	83 ec 0c             	sub    $0xc,%esp
f0103d4f:	68 7c 53 12 f0       	push   $0xf012537c
f0103d54:	e8 32 d2 ff ff       	call   f0100f8b <cprintf>
f0103d59:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d5f:	83 c0 04             	add    $0x4,%eax
f0103d62:	8b 00                	mov    (%eax),%eax
f0103d64:	83 ec 04             	sub    $0x4,%esp
f0103d67:	6a 0a                	push   $0xa
f0103d69:	6a 00                	push   $0x0
f0103d6b:	50                   	push   %eax
f0103d6c:	e8 9b c4 01 00       	call   f012020c <strtol>
f0103d71:	83 c4 10             	add    $0x10,%esp
f0103d74:	83 ec 0c             	sub    $0xc,%esp
f0103d77:	50                   	push   %eax
f0103d78:	e8 fb bb 00 00       	call   f010f978 <setModifiedBufferLength>
f0103d7d:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103d80:	e8 01 bc 00 00       	call   f010f986 <getModifiedBufferLength>
f0103d85:	83 ec 08             	sub    $0x8,%esp
f0103d88:	50                   	push   %eax
f0103d89:	68 ec 52 12 f0       	push   $0xf01252ec
f0103d8e:	e8 f8 d1 ff ff       	call   f0100f8b <cprintf>
f0103d93:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d96:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d9b:	c9                   	leave  
f0103d9c:	c3                   	ret    

f0103d9d <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d9d:	55                   	push   %ebp
f0103d9e:	89 e5                	mov    %esp,%ebp
f0103da0:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103da3:	e8 c6 bb 00 00       	call   f010f96e <isBufferingEnabled>
f0103da8:	84 c0                	test   %al,%al
f0103daa:	75 12                	jne    f0103dbe <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103dac:	83 ec 0c             	sub    $0xc,%esp
f0103daf:	68 2c 53 12 f0       	push   $0xf012532c
f0103db4:	e8 d2 d1 ff ff       	call   f0100f8b <cprintf>
f0103db9:	83 c4 10             	add    $0x10,%esp
f0103dbc:	eb 19                	jmp    f0103dd7 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103dbe:	e8 93 bb 00 00       	call   f010f956 <isModifiedBufferEnabled>
f0103dc3:	84 c0                	test   %al,%al
f0103dc5:	75 10                	jne    f0103dd7 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103dc7:	83 ec 0c             	sub    $0xc,%esp
f0103dca:	68 7c 53 12 f0       	push   $0xf012537c
f0103dcf:	e8 b7 d1 ff ff       	call   f0100f8b <cprintf>
f0103dd4:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103dd7:	e8 aa bb 00 00       	call   f010f986 <getModifiedBufferLength>
f0103ddc:	83 ec 08             	sub    $0x8,%esp
f0103ddf:	50                   	push   %eax
f0103de0:	68 c2 53 12 f0       	push   $0xf01253c2
f0103de5:	e8 a1 d1 ff ff       	call   f0100f8b <cprintf>
f0103dea:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ded:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103df2:	c9                   	leave  
f0103df3:	c3                   	ret    

f0103df4 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103df4:	55                   	push   %ebp
f0103df5:	89 e5                	mov    %esp,%ebp
f0103df7:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103dfa:	83 ec 08             	sub    $0x8,%esp
f0103dfd:	ff 75 0c             	pushl  0xc(%ebp)
f0103e00:	ff 75 08             	pushl  0x8(%ebp)
f0103e03:	e8 dd c6 00 00       	call   f01104e5 <tst_handler>
f0103e08:	83 c4 10             	add    $0x10,%esp
}
f0103e0b:	c9                   	leave  
f0103e0c:	c3                   	ret    

f0103e0d <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103e0d:	55                   	push   %ebp
f0103e0e:	89 e5                	mov    %esp,%ebp
f0103e10:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e13:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e16:	05 00 14 00 00       	add    $0x1400,%eax
f0103e1b:	c1 e0 03             	shl    $0x3,%eax
f0103e1e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e21:	83 ec 04             	sub    $0x4,%esp
f0103e24:	6a 08                	push   $0x8
f0103e26:	ff 75 0c             	pushl  0xc(%ebp)
f0103e29:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e2c:	e8 63 c8 01 00       	call   f0120694 <ide_read>
f0103e31:	83 c4 10             	add    $0x10,%esp
f0103e34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e3a:	c9                   	leave  
f0103e3b:	c3                   	ret    

f0103e3c <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103e3c:	55                   	push   %ebp
f0103e3d:	89 e5                	mov    %esp,%ebp
f0103e3f:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e42:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e45:	05 00 14 00 00       	add    $0x1400,%eax
f0103e4a:	c1 e0 03             	shl    $0x3,%eax
f0103e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e50:	83 ec 04             	sub    $0x4,%esp
f0103e53:	6a 08                	push   $0x8
f0103e55:	ff 75 0c             	pushl  0xc(%ebp)
f0103e58:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e5b:	e8 74 c9 01 00       	call   f01207d4 <ide_write>
f0103e60:	83 c4 10             	add    $0x10,%esp
f0103e63:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103e66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e6a:	74 14                	je     f0103e80 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103e6c:	83 ec 04             	sub    $0x4,%esp
f0103e6f:	68 e0 53 12 f0       	push   $0xf01253e0
f0103e74:	6a 2f                	push   $0x2f
f0103e76:	68 f7 53 12 f0       	push   $0xf01253f7
f0103e7b:	e8 b9 c4 ff ff       	call   f0100339 <_panic>
	return success;
f0103e80:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e83:	c9                   	leave  
f0103e84:	c3                   	ret    

f0103e85 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103e85:	55                   	push   %ebp
f0103e86:	89 e5                	mov    %esp,%ebp
f0103e88:	53                   	push   %ebx
f0103e89:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103e8c:	c7 05 60 f7 f1 f0 00 	movl   $0x0,0xf0f1f760
f0103e93:	00 00 00 
f0103e96:	c7 05 64 f7 f1 f0 00 	movl   $0x0,0xf0f1f764
f0103e9d:	00 00 00 
f0103ea0:	c7 05 6c f7 f1 f0 00 	movl   $0x0,0xf0f1f76c
f0103ea7:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103eaa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103eb1:	e9 e8 00 00 00       	jmp    f0103f9e <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103eb6:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ebf:	89 d0                	mov    %edx,%eax
f0103ec1:	01 c0                	add    %eax,%eax
f0103ec3:	01 d0                	add    %edx,%eax
f0103ec5:	c1 e0 03             	shl    $0x3,%eax
f0103ec8:	01 c8                	add    %ecx,%eax
f0103eca:	83 ec 0c             	sub    $0xc,%esp
f0103ecd:	50                   	push   %eax
f0103ece:	e8 ef 45 00 00       	call   f01084c2 <initialize_frame_info>
f0103ed3:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ed6:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103edc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103edf:	89 d0                	mov    %edx,%eax
f0103ee1:	01 c0                	add    %eax,%eax
f0103ee3:	01 d0                	add    %edx,%eax
f0103ee5:	c1 e0 03             	shl    $0x3,%eax
f0103ee8:	01 c8                	add    %ecx,%eax
f0103eea:	85 c0                	test   %eax,%eax
f0103eec:	75 14                	jne    f0103f02 <initialize_disk_page_file+0x7d>
f0103eee:	83 ec 04             	sub    $0x4,%esp
f0103ef1:	68 14 54 12 f0       	push   $0xf0125414
f0103ef6:	6a 56                	push   $0x56
f0103ef8:	68 f7 53 12 f0       	push   $0xf01253f7
f0103efd:	e8 37 c4 ff ff       	call   f0100339 <_panic>
f0103f02:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f0b:	89 d0                	mov    %edx,%eax
f0103f0d:	01 c0                	add    %eax,%eax
f0103f0f:	01 d0                	add    %edx,%eax
f0103f11:	c1 e0 03             	shl    $0x3,%eax
f0103f14:	01 c8                	add    %ecx,%eax
f0103f16:	8b 15 60 f7 f1 f0    	mov    0xf0f1f760,%edx
f0103f1c:	89 10                	mov    %edx,(%eax)
f0103f1e:	8b 00                	mov    (%eax),%eax
f0103f20:	85 c0                	test   %eax,%eax
f0103f22:	74 1f                	je     f0103f43 <initialize_disk_page_file+0xbe>
f0103f24:	8b 15 60 f7 f1 f0    	mov    0xf0f1f760,%edx
f0103f2a:	8b 1d 40 ee 71 f0    	mov    0xf071ee40,%ebx
f0103f30:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103f33:	89 c8                	mov    %ecx,%eax
f0103f35:	01 c0                	add    %eax,%eax
f0103f37:	01 c8                	add    %ecx,%eax
f0103f39:	c1 e0 03             	shl    $0x3,%eax
f0103f3c:	01 d8                	add    %ebx,%eax
f0103f3e:	89 42 04             	mov    %eax,0x4(%edx)
f0103f41:	eb 19                	jmp    f0103f5c <initialize_disk_page_file+0xd7>
f0103f43:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f4c:	89 d0                	mov    %edx,%eax
f0103f4e:	01 c0                	add    %eax,%eax
f0103f50:	01 d0                	add    %edx,%eax
f0103f52:	c1 e0 03             	shl    $0x3,%eax
f0103f55:	01 c8                	add    %ecx,%eax
f0103f57:	a3 64 f7 f1 f0       	mov    %eax,0xf0f1f764
f0103f5c:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f65:	89 d0                	mov    %edx,%eax
f0103f67:	01 c0                	add    %eax,%eax
f0103f69:	01 d0                	add    %edx,%eax
f0103f6b:	c1 e0 03             	shl    $0x3,%eax
f0103f6e:	01 c8                	add    %ecx,%eax
f0103f70:	a3 60 f7 f1 f0       	mov    %eax,0xf0f1f760
f0103f75:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f7e:	89 d0                	mov    %edx,%eax
f0103f80:	01 c0                	add    %eax,%eax
f0103f82:	01 d0                	add    %edx,%eax
f0103f84:	c1 e0 03             	shl    $0x3,%eax
f0103f87:	01 c8                	add    %ecx,%eax
f0103f89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f90:	a1 6c f7 f1 f0       	mov    0xf0f1f76c,%eax
f0103f95:	40                   	inc    %eax
f0103f96:	a3 6c f7 f1 f0       	mov    %eax,0xf0f1f76c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103f9b:	ff 45 f4             	incl   -0xc(%ebp)
f0103f9e:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103fa5:	0f 8e 0b ff ff ff    	jle    f0103eb6 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103fab:	90                   	nop
f0103fac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103faf:	c9                   	leave  
f0103fb0:	c3                   	ret    

f0103fb1 <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103fb1:	55                   	push   %ebp
f0103fb2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103fb4:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fb7:	8b 15 40 ee 71 f0    	mov    0xf071ee40,%edx
f0103fbd:	29 d0                	sub    %edx,%eax
f0103fbf:	c1 f8 03             	sar    $0x3,%eax
f0103fc2:	89 c2                	mov    %eax,%edx
f0103fc4:	89 d0                	mov    %edx,%eax
f0103fc6:	c1 e0 02             	shl    $0x2,%eax
f0103fc9:	01 d0                	add    %edx,%eax
f0103fcb:	c1 e0 02             	shl    $0x2,%eax
f0103fce:	01 d0                	add    %edx,%eax
f0103fd0:	c1 e0 02             	shl    $0x2,%eax
f0103fd3:	01 d0                	add    %edx,%eax
f0103fd5:	89 c1                	mov    %eax,%ecx
f0103fd7:	c1 e1 08             	shl    $0x8,%ecx
f0103fda:	01 c8                	add    %ecx,%eax
f0103fdc:	89 c1                	mov    %eax,%ecx
f0103fde:	c1 e1 10             	shl    $0x10,%ecx
f0103fe1:	01 c8                	add    %ecx,%eax
f0103fe3:	01 c0                	add    %eax,%eax
f0103fe5:	01 d0                	add    %edx,%eax
}
f0103fe7:	5d                   	pop    %ebp
f0103fe8:	c3                   	ret    

f0103fe9 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103fe9:	55                   	push   %ebp
f0103fea:	89 e5                	mov    %esp,%ebp
f0103fec:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103fef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ff6:	83 ec 0c             	sub    $0xc,%esp
f0103ff9:	68 70 f7 f1 f0       	push   $0xf0f1f770
f0103ffe:	e8 fb be 00 00       	call   f010fefe <acquire_spinlock>
f0104003:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104006:	a1 60 f7 f1 f0       	mov    0xf0f1f760,%eax
f010400b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f010400e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104012:	75 0c                	jne    f0104020 <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104014:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f010401b:	e9 a2 00 00 00       	jmp    f01040c2 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104020:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104024:	75 14                	jne    f010403a <allocate_disk_frame+0x51>
f0104026:	83 ec 04             	sub    $0x4,%esp
f0104029:	68 37 54 12 f0       	push   $0xf0125437
f010402e:	6a 7b                	push   $0x7b
f0104030:	68 f7 53 12 f0       	push   $0xf01253f7
f0104035:	e8 ff c2 ff ff       	call   f0100339 <_panic>
f010403a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010403d:	8b 00                	mov    (%eax),%eax
f010403f:	85 c0                	test   %eax,%eax
f0104041:	74 10                	je     f0104053 <allocate_disk_frame+0x6a>
f0104043:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104046:	8b 00                	mov    (%eax),%eax
f0104048:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010404b:	8b 52 04             	mov    0x4(%edx),%edx
f010404e:	89 50 04             	mov    %edx,0x4(%eax)
f0104051:	eb 0b                	jmp    f010405e <allocate_disk_frame+0x75>
f0104053:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104056:	8b 40 04             	mov    0x4(%eax),%eax
f0104059:	a3 64 f7 f1 f0       	mov    %eax,0xf0f1f764
f010405e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104061:	8b 40 04             	mov    0x4(%eax),%eax
f0104064:	85 c0                	test   %eax,%eax
f0104066:	74 0f                	je     f0104077 <allocate_disk_frame+0x8e>
f0104068:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010406b:	8b 40 04             	mov    0x4(%eax),%eax
f010406e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104071:	8b 12                	mov    (%edx),%edx
f0104073:	89 10                	mov    %edx,(%eax)
f0104075:	eb 0a                	jmp    f0104081 <allocate_disk_frame+0x98>
f0104077:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010407a:	8b 00                	mov    (%eax),%eax
f010407c:	a3 60 f7 f1 f0       	mov    %eax,0xf0f1f760
f0104081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104084:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010408a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010408d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104094:	a1 6c f7 f1 f0       	mov    0xf0f1f76c,%eax
f0104099:	48                   	dec    %eax
f010409a:	a3 6c f7 f1 f0       	mov    %eax,0xf0f1f76c
			initialize_frame_info(ptr_frame_info);
f010409f:	83 ec 0c             	sub    $0xc,%esp
f01040a2:	ff 75 f0             	pushl  -0x10(%ebp)
f01040a5:	e8 18 44 00 00       	call   f01084c2 <initialize_frame_info>
f01040aa:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f01040ad:	83 ec 0c             	sub    $0xc,%esp
f01040b0:	ff 75 f0             	pushl  -0x10(%ebp)
f01040b3:	e8 f9 fe ff ff       	call   f0103fb1 <to_disk_frame_number>
f01040b8:	83 c4 10             	add    $0x10,%esp
f01040bb:	89 c2                	mov    %eax,%edx
f01040bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01040c0:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01040c2:	83 ec 0c             	sub    $0xc,%esp
f01040c5:	68 70 f7 f1 f0       	push   $0xf0f1f770
f01040ca:	e8 b6 be 00 00       	call   f010ff85 <release_spinlock>
f01040cf:	83 c4 10             	add    $0x10,%esp

	return ret;
f01040d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01040d5:	c9                   	leave  
f01040d6:	c3                   	ret    

f01040d7 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f01040d7:	55                   	push   %ebp
f01040d8:	89 e5                	mov    %esp,%ebp
f01040da:	53                   	push   %ebx
f01040db:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f01040de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01040e2:	0f 84 ea 00 00 00    	je     f01041d2 <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f01040e8:	83 ec 0c             	sub    $0xc,%esp
f01040eb:	68 70 f7 f1 f0       	push   $0xf0f1f770
f01040f0:	e8 09 be 00 00       	call   f010fefe <acquire_spinlock>
f01040f5:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f01040f8:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f01040fe:	8b 55 08             	mov    0x8(%ebp),%edx
f0104101:	89 d0                	mov    %edx,%eax
f0104103:	01 c0                	add    %eax,%eax
f0104105:	01 d0                	add    %edx,%eax
f0104107:	c1 e0 03             	shl    $0x3,%eax
f010410a:	01 c8                	add    %ecx,%eax
f010410c:	85 c0                	test   %eax,%eax
f010410e:	75 17                	jne    f0104127 <free_disk_frame+0x50>
f0104110:	83 ec 04             	sub    $0x4,%esp
f0104113:	68 14 54 12 f0       	push   $0xf0125414
f0104118:	68 8e 00 00 00       	push   $0x8e
f010411d:	68 f7 53 12 f0       	push   $0xf01253f7
f0104122:	e8 12 c2 ff ff       	call   f0100339 <_panic>
f0104127:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f010412d:	8b 55 08             	mov    0x8(%ebp),%edx
f0104130:	89 d0                	mov    %edx,%eax
f0104132:	01 c0                	add    %eax,%eax
f0104134:	01 d0                	add    %edx,%eax
f0104136:	c1 e0 03             	shl    $0x3,%eax
f0104139:	01 c8                	add    %ecx,%eax
f010413b:	8b 15 60 f7 f1 f0    	mov    0xf0f1f760,%edx
f0104141:	89 10                	mov    %edx,(%eax)
f0104143:	8b 00                	mov    (%eax),%eax
f0104145:	85 c0                	test   %eax,%eax
f0104147:	74 1f                	je     f0104168 <free_disk_frame+0x91>
f0104149:	8b 15 60 f7 f1 f0    	mov    0xf0f1f760,%edx
f010414f:	8b 1d 40 ee 71 f0    	mov    0xf071ee40,%ebx
f0104155:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104158:	89 c8                	mov    %ecx,%eax
f010415a:	01 c0                	add    %eax,%eax
f010415c:	01 c8                	add    %ecx,%eax
f010415e:	c1 e0 03             	shl    $0x3,%eax
f0104161:	01 d8                	add    %ebx,%eax
f0104163:	89 42 04             	mov    %eax,0x4(%edx)
f0104166:	eb 19                	jmp    f0104181 <free_disk_frame+0xaa>
f0104168:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f010416e:	8b 55 08             	mov    0x8(%ebp),%edx
f0104171:	89 d0                	mov    %edx,%eax
f0104173:	01 c0                	add    %eax,%eax
f0104175:	01 d0                	add    %edx,%eax
f0104177:	c1 e0 03             	shl    $0x3,%eax
f010417a:	01 c8                	add    %ecx,%eax
f010417c:	a3 64 f7 f1 f0       	mov    %eax,0xf0f1f764
f0104181:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0104187:	8b 55 08             	mov    0x8(%ebp),%edx
f010418a:	89 d0                	mov    %edx,%eax
f010418c:	01 c0                	add    %eax,%eax
f010418e:	01 d0                	add    %edx,%eax
f0104190:	c1 e0 03             	shl    $0x3,%eax
f0104193:	01 c8                	add    %ecx,%eax
f0104195:	a3 60 f7 f1 f0       	mov    %eax,0xf0f1f760
f010419a:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f01041a0:	8b 55 08             	mov    0x8(%ebp),%edx
f01041a3:	89 d0                	mov    %edx,%eax
f01041a5:	01 c0                	add    %eax,%eax
f01041a7:	01 d0                	add    %edx,%eax
f01041a9:	c1 e0 03             	shl    $0x3,%eax
f01041ac:	01 c8                	add    %ecx,%eax
f01041ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01041b5:	a1 6c f7 f1 f0       	mov    0xf0f1f76c,%eax
f01041ba:	40                   	inc    %eax
f01041bb:	a3 6c f7 f1 f0       	mov    %eax,0xf0f1f76c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01041c0:	83 ec 0c             	sub    $0xc,%esp
f01041c3:	68 70 f7 f1 f0       	push   $0xf0f1f770
f01041c8:	e8 b8 bd 00 00       	call   f010ff85 <release_spinlock>
f01041cd:	83 c4 10             	add    $0x10,%esp
f01041d0:	eb 01                	jmp    f01041d3 <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f01041d2:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f01041d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01041d6:	c9                   	leave  
f01041d7:	c3                   	ret    

f01041d8 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f01041d8:	55                   	push   %ebp
f01041d9:	89 e5                	mov    %esp,%ebp
f01041db:	53                   	push   %ebx
f01041dc:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f01041df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01041e2:	c1 e8 16             	shr    $0x16,%eax
f01041e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01041ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01041ef:	01 d0                	add    %edx,%eax
f01041f1:	8b 00                	mov    (%eax),%eax
f01041f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01041f6:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01041fd:	77 1d                	ja     f010421c <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f01041ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104202:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104207:	83 ec 0c             	sub    $0xc,%esp
f010420a:	50                   	push   %eax
f010420b:	e8 4d 59 00 00       	call   f0109b5d <kheap_virtual_address>
f0104210:	83 c4 10             	add    $0x10,%esp
f0104213:	89 c2                	mov    %eax,%edx
f0104215:	8b 45 14             	mov    0x14(%ebp),%eax
f0104218:	89 10                	mov    %edx,(%eax)
f010421a:	eb 44                	jmp    f0104260 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f010421c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010421f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104224:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104227:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010422a:	c1 e8 0c             	shr    $0xc,%eax
f010422d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104230:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0104235:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104238:	72 17                	jb     f0104251 <get_disk_page_table+0x79>
f010423a:	ff 75 f0             	pushl  -0x10(%ebp)
f010423d:	68 58 54 12 f0       	push   $0xf0125458
f0104242:	68 9d 00 00 00       	push   $0x9d
f0104247:	68 f7 53 12 f0       	push   $0xf01253f7
f010424c:	e8 e8 c0 ff ff       	call   f0100339 <_panic>
f0104251:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104254:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104259:	89 c2                	mov    %eax,%edx
f010425b:	8b 45 14             	mov    0x14(%ebp),%eax
f010425e:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0104260:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104264:	0f 85 80 00 00 00    	jne    f01042ea <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010426a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010426e:	74 6a                	je     f01042da <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0104270:	83 ec 0c             	sub    $0xc,%esp
f0104273:	68 00 10 00 00       	push   $0x1000
f0104278:	e8 3d 55 00 00       	call   f01097ba <kmalloc>
f010427d:	83 c4 10             	add    $0x10,%esp
f0104280:	89 c2                	mov    %eax,%edx
f0104282:	8b 45 14             	mov    0x14(%ebp),%eax
f0104285:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104287:	8b 45 14             	mov    0x14(%ebp),%eax
f010428a:	8b 00                	mov    (%eax),%eax
f010428c:	85 c0                	test   %eax,%eax
f010428e:	75 07                	jne    f0104297 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0104290:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104295:	eb 58                	jmp    f01042ef <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0104297:	8b 45 0c             	mov    0xc(%ebp),%eax
f010429a:	c1 e8 16             	shr    $0x16,%eax
f010429d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01042a7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01042aa:	8b 45 14             	mov    0x14(%ebp),%eax
f01042ad:	8b 00                	mov    (%eax),%eax
f01042af:	83 ec 0c             	sub    $0xc,%esp
f01042b2:	50                   	push   %eax
f01042b3:	e8 48 58 00 00       	call   f0109b00 <kheap_physical_address>
f01042b8:	83 c4 10             	add    $0x10,%esp
f01042bb:	83 c8 01             	or     $0x1,%eax
f01042be:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01042c0:	8b 45 14             	mov    0x14(%ebp),%eax
f01042c3:	8b 00                	mov    (%eax),%eax
f01042c5:	83 ec 04             	sub    $0x4,%esp
f01042c8:	68 00 10 00 00       	push   $0x1000
f01042cd:	6a 00                	push   $0x0
f01042cf:	50                   	push   %eax
f01042d0:	e8 c5 bd 01 00       	call   f012009a <memset>
f01042d5:	83 c4 10             	add    $0x10,%esp
f01042d8:	eb 10                	jmp    f01042ea <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01042da:	8b 45 14             	mov    0x14(%ebp),%eax
f01042dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01042e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01042e8:	eb 05                	jmp    f01042ef <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01042ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01042f2:	c9                   	leave  
f01042f3:	c3                   	ret    

f01042f4 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01042f4:	55                   	push   %ebp
f01042f5:	89 e5                	mov    %esp,%ebp
f01042f7:	83 ec 28             	sub    $0x28,%esp
f01042fa:	8b 45 10             	mov    0x10(%ebp),%eax
f01042fd:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0104300:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104304:	74 72                	je     f0104378 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104306:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010430d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104310:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104315:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104318:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010431b:	ba 00 00 00 00       	mov    $0x0,%edx
f0104320:	f7 75 f4             	divl   -0xc(%ebp)
f0104323:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104326:	29 d0                	sub    %edx,%eax
f0104328:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010432b:	73 2f                	jae    f010435c <pf_add_empty_env_page+0x68>
f010432d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104330:	8b 50 6c             	mov    0x6c(%eax),%edx
f0104333:	b8 00 00 00 00       	mov    $0x0,%eax
f0104338:	29 d0                	sub    %edx,%eax
f010433a:	c1 e0 0c             	shl    $0xc,%eax
f010433d:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0104342:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104345:	76 15                	jbe    f010435c <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104347:	8b 45 08             	mov    0x8(%ebp),%eax
f010434a:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104350:	8d 50 01             	lea    0x1(%eax),%edx
f0104353:	8b 45 08             	mov    0x8(%ebp),%eax
f0104356:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f010435c:	a1 1c f6 b1 f0       	mov    0xf0b1f61c,%eax
f0104361:	83 ec 04             	sub    $0x4,%esp
f0104364:	50                   	push   %eax
f0104365:	ff 75 0c             	pushl  0xc(%ebp)
f0104368:	ff 75 08             	pushl  0x8(%ebp)
f010436b:	e8 b5 00 00 00       	call   f0104425 <pf_add_env_page>
f0104370:	83 c4 10             	add    $0x10,%esp
f0104373:	e9 ab 00 00 00       	jmp    f0104423 <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104378:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010437f:	76 19                	jbe    f010439a <pf_add_empty_env_page+0xa6>
f0104381:	68 88 54 12 f0       	push   $0xf0125488
f0104386:	68 ae 54 12 f0       	push   $0xf01254ae
f010438b:	68 dc 00 00 00       	push   $0xdc
f0104390:	68 f7 53 12 f0       	push   $0xf01253f7
f0104395:	e8 9f bf ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010439a:	8b 45 08             	mov    0x8(%ebp),%eax
f010439d:	83 e8 80             	sub    $0xffffff80,%eax
f01043a0:	83 ec 08             	sub    $0x8,%esp
f01043a3:	50                   	push   %eax
f01043a4:	ff 75 08             	pushl  0x8(%ebp)
f01043a7:	e8 c2 05 00 00       	call   f010496e <get_disk_page_directory>
f01043ac:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01043af:	8b 45 08             	mov    0x8(%ebp),%eax
f01043b2:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01043b8:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01043bb:	52                   	push   %edx
f01043bc:	6a 01                	push   $0x1
f01043be:	ff 75 0c             	pushl  0xc(%ebp)
f01043c1:	50                   	push   %eax
f01043c2:	e8 11 fe ff ff       	call   f01041d8 <get_disk_page_table>
f01043c7:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01043ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01043d0:	c1 ea 0c             	shr    $0xc,%edx
f01043d3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01043d9:	c1 e2 02             	shl    $0x2,%edx
f01043dc:	01 d0                	add    %edx,%eax
f01043de:	8b 00                	mov    (%eax),%eax
f01043e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01043e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043e6:	85 c0                	test   %eax,%eax
f01043e8:	75 34                	jne    f010441e <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01043ea:	83 ec 0c             	sub    $0xc,%esp
f01043ed:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01043f0:	50                   	push   %eax
f01043f1:	e8 f3 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01043f6:	83 c4 10             	add    $0x10,%esp
f01043f9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01043fc:	75 07                	jne    f0104405 <pf_add_empty_env_page+0x111>
f01043fe:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104403:	eb 1e                	jmp    f0104423 <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104405:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104408:	8b 55 0c             	mov    0xc(%ebp),%edx
f010440b:	c1 ea 0c             	shr    $0xc,%edx
f010440e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104414:	c1 e2 02             	shl    $0x2,%edx
f0104417:	01 c2                	add    %eax,%edx
f0104419:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010441c:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010441e:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0104423:	c9                   	leave  
f0104424:	c3                   	ret    

f0104425 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104425:	55                   	push   %ebp
f0104426:	89 e5                	mov    %esp,%ebp
f0104428:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010442b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104432:	76 19                	jbe    f010444d <pf_add_env_page+0x28>
f0104434:	68 88 54 12 f0       	push   $0xf0125488
f0104439:	68 ae 54 12 f0       	push   $0xf01254ae
f010443e:	68 f1 00 00 00       	push   $0xf1
f0104443:	68 f7 53 12 f0       	push   $0xf01253f7
f0104448:	e8 ec be ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010444d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104450:	83 e8 80             	sub    $0xffffff80,%eax
f0104453:	83 ec 08             	sub    $0x8,%esp
f0104456:	50                   	push   %eax
f0104457:	ff 75 08             	pushl  0x8(%ebp)
f010445a:	e8 0f 05 00 00       	call   f010496e <get_disk_page_directory>
f010445f:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0104462:	8b 45 08             	mov    0x8(%ebp),%eax
f0104465:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010446b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010446e:	52                   	push   %edx
f010446f:	6a 01                	push   $0x1
f0104471:	ff 75 0c             	pushl  0xc(%ebp)
f0104474:	50                   	push   %eax
f0104475:	e8 5e fd ff ff       	call   f01041d8 <get_disk_page_table>
f010447a:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010447d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104480:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104483:	c1 ea 0c             	shr    $0xc,%edx
f0104486:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010448c:	c1 e2 02             	shl    $0x2,%edx
f010448f:	01 d0                	add    %edx,%eax
f0104491:	8b 00                	mov    (%eax),%eax
f0104493:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0104496:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104499:	85 c0                	test   %eax,%eax
f010449b:	75 34                	jne    f01044d1 <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010449d:	83 ec 0c             	sub    $0xc,%esp
f01044a0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01044a3:	50                   	push   %eax
f01044a4:	e8 40 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01044a9:	83 c4 10             	add    $0x10,%esp
f01044ac:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01044af:	75 07                	jne    f01044b8 <pf_add_env_page+0x93>
f01044b1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01044b6:	eb 31                	jmp    f01044e9 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01044b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044bb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044be:	c1 ea 0c             	shr    $0xc,%edx
f01044c1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044c7:	c1 e2 02             	shl    $0x2,%edx
f01044ca:	01 c2                	add    %eax,%edx
f01044cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044cf:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01044d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044d4:	83 ec 08             	sub    $0x8,%esp
f01044d7:	ff 75 10             	pushl  0x10(%ebp)
f01044da:	50                   	push   %eax
f01044db:	e8 5c f9 ff ff       	call   f0103e3c <write_disk_page>
f01044e0:	83 c4 10             	add    $0x10,%esp
f01044e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01044e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01044e9:	c9                   	leave  
f01044ea:	c3                   	ret    

f01044eb <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01044eb:	55                   	push   %ebp
f01044ec:	89 e5                	mov    %esp,%ebp
f01044ee:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01044f1:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01044f8:	76 19                	jbe    f0104513 <pf_update_env_page+0x28>
f01044fa:	68 88 54 12 f0       	push   $0xf0125488
f01044ff:	68 ae 54 12 f0       	push   $0xf01254ae
f0104504:	68 13 01 00 00       	push   $0x113
f0104509:	68 f7 53 12 f0       	push   $0xf01253f7
f010450e:	e8 26 be ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104513:	8b 45 08             	mov    0x8(%ebp),%eax
f0104516:	83 e8 80             	sub    $0xffffff80,%eax
f0104519:	83 ec 08             	sub    $0x8,%esp
f010451c:	50                   	push   %eax
f010451d:	ff 75 08             	pushl  0x8(%ebp)
f0104520:	e8 49 04 00 00       	call   f010496e <get_disk_page_directory>
f0104525:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104528:	8b 45 08             	mov    0x8(%ebp),%eax
f010452b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104531:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104534:	52                   	push   %edx
f0104535:	6a 00                	push   $0x0
f0104537:	ff 75 0c             	pushl  0xc(%ebp)
f010453a:	50                   	push   %eax
f010453b:	e8 98 fc ff ff       	call   f01041d8 <get_disk_page_table>
f0104540:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104543:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104546:	85 c0                	test   %eax,%eax
f0104548:	74 29                	je     f0104573 <pf_update_env_page+0x88>
f010454a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010454d:	85 c0                	test   %eax,%eax
f010454f:	0f 84 bf 00 00 00    	je     f0104614 <pf_update_env_page+0x129>
f0104555:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104558:	8b 55 0c             	mov    0xc(%ebp),%edx
f010455b:	c1 ea 0c             	shr    $0xc,%edx
f010455e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104564:	c1 e2 02             	shl    $0x2,%edx
f0104567:	01 d0                	add    %edx,%eax
f0104569:	8b 00                	mov    (%eax),%eax
f010456b:	85 c0                	test   %eax,%eax
f010456d:	0f 85 a1 00 00 00    	jne    f0104614 <pf_update_env_page+0x129>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0104573:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104576:	85 c0                	test   %eax,%eax
f0104578:	79 09                	jns    f0104583 <pf_update_env_page+0x98>
f010457a:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0104581:	76 30                	jbe    f01045b3 <pf_update_env_page+0xc8>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0104583:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010458a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010458d:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104592:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104595:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104598:	ba 00 00 00 00       	mov    $0x0,%edx
f010459d:	f7 75 f4             	divl   -0xc(%ebp)
f01045a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045a3:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f01045a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01045a8:	77 53                	ja     f01045fd <pf_update_env_page+0x112>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01045aa:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01045b1:	77 4a                	ja     f01045fd <pf_update_env_page+0x112>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f01045b3:	83 ec 04             	sub    $0x4,%esp
f01045b6:	6a 00                	push   $0x0
f01045b8:	ff 75 0c             	pushl  0xc(%ebp)
f01045bb:	ff 75 08             	pushl  0x8(%ebp)
f01045be:	e8 31 fd ff ff       	call   f01042f4 <pf_add_empty_env_page>
f01045c3:	83 c4 10             	add    $0x10,%esp
f01045c6:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01045c9:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f01045cd:	75 17                	jne    f01045e6 <pf_update_env_page+0xfb>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01045cf:	83 ec 04             	sub    $0x4,%esp
f01045d2:	68 c4 54 12 f0       	push   $0xf01254c4
f01045d7:	68 43 01 00 00       	push   $0x143
f01045dc:	68 f7 53 12 f0       	push   $0xf01253f7
f01045e1:	e8 53 bd ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01045e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01045e9:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f01045ef:	8d 50 01             	lea    0x1(%eax),%edx
f01045f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01045f5:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f01045fb:	eb 17                	jmp    f0104614 <pf_update_env_page+0x129>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01045fd:	83 ec 04             	sub    $0x4,%esp
f0104600:	68 10 55 12 f0       	push   $0xf0125510
f0104605:	68 4c 01 00 00       	push   $0x14c
f010460a:	68 f7 53 12 f0       	push   $0xf01253f7
f010460f:	e8 25 bd ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104614:	8b 45 08             	mov    0x8(%ebp),%eax
f0104617:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010461d:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104620:	52                   	push   %edx
f0104621:	6a 00                	push   $0x0
f0104623:	ff 75 0c             	pushl  0xc(%ebp)
f0104626:	50                   	push   %eax
f0104627:	e8 ac fb ff ff       	call   f01041d8 <get_disk_page_table>
f010462c:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010462f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104632:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104635:	c1 ea 0c             	shr    $0xc,%edx
f0104638:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010463e:	c1 e2 02             	shl    $0x2,%edx
f0104641:	01 d0                	add    %edx,%eax
f0104643:	8b 00                	mov    (%eax),%eax
f0104645:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0104648:	8b 45 08             	mov    0x8(%ebp),%eax
f010464b:	8b 40 64             	mov    0x64(%eax),%eax
f010464e:	6a 00                	push   $0x0
f0104650:	68 00 f0 3f 00       	push   $0x3ff000
f0104655:	ff 75 10             	pushl  0x10(%ebp)
f0104658:	50                   	push   %eax
f0104659:	e8 4c 43 00 00       	call   f01089aa <map_frame>
f010465e:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f0104661:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0104668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010466b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104670:	83 ec 08             	sub    $0x8,%esp
f0104673:	50                   	push   %eax
f0104674:	ff 75 e8             	pushl  -0x18(%ebp)
f0104677:	e8 c0 f7 ff ff       	call   f0103e3c <write_disk_page>
f010467c:	83 c4 10             	add    $0x10,%esp
f010467f:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104682:	8b 45 10             	mov    0x10(%ebp),%eax
f0104685:	8b 40 08             	mov    0x8(%eax),%eax
f0104688:	40                   	inc    %eax
f0104689:	8b 55 10             	mov    0x10(%ebp),%edx
f010468c:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0104690:	8b 45 08             	mov    0x8(%ebp),%eax
f0104693:	8b 40 64             	mov    0x64(%eax),%eax
f0104696:	83 ec 08             	sub    $0x8,%esp
f0104699:	68 00 f0 3f 00       	push   $0x3ff000
f010469e:	50                   	push   %eax
f010469f:	e8 66 44 00 00       	call   f0108b0a <unmap_frame>
f01046a4:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01046a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01046aa:	8b 40 08             	mov    0x8(%eax),%eax
f01046ad:	48                   	dec    %eax
f01046ae:	8b 55 10             	mov    0x10(%ebp),%edx
f01046b1:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01046b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01046b8:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01046be:	8d 50 01             	lea    0x1(%eax),%edx
f01046c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046c4:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01046ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01046cd:	c9                   	leave  
f01046ce:	c3                   	ret    

f01046cf <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01046cf:	55                   	push   %ebp
f01046d0:	89 e5                	mov    %esp,%ebp
f01046d2:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01046d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01046db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01046de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01046e3:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01046e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e9:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046ef:	85 c0                	test   %eax,%eax
f01046f1:	75 0a                	jne    f01046fd <pf_read_env_page+0x2e>
f01046f3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01046f8:	e9 93 00 00 00       	jmp    f0104790 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01046fd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104700:	8b 45 08             	mov    0x8(%ebp),%eax
f0104703:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104709:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010470c:	51                   	push   %ecx
f010470d:	6a 00                	push   $0x0
f010470f:	52                   	push   %edx
f0104710:	50                   	push   %eax
f0104711:	e8 c2 fa ff ff       	call   f01041d8 <get_disk_page_table>
f0104716:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104719:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010471c:	85 c0                	test   %eax,%eax
f010471e:	75 07                	jne    f0104727 <pf_read_env_page+0x58>
f0104720:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104725:	eb 69                	jmp    f0104790 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104727:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010472a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010472d:	c1 ea 0c             	shr    $0xc,%edx
f0104730:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104736:	c1 e2 02             	shl    $0x2,%edx
f0104739:	01 d0                	add    %edx,%eax
f010473b:	8b 00                	mov    (%eax),%eax
f010473d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104740:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104744:	75 07                	jne    f010474d <pf_read_env_page+0x7e>
f0104746:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010474b:	eb 43                	jmp    f0104790 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010474d:	83 ec 08             	sub    $0x8,%esp
f0104750:	ff 75 0c             	pushl  0xc(%ebp)
f0104753:	ff 75 f0             	pushl  -0x10(%ebp)
f0104756:	e8 b2 f6 ff ff       	call   f0103e0d <read_disk_page>
f010475b:	83 c4 10             	add    $0x10,%esp
f010475e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104761:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104764:	8b 45 08             	mov    0x8(%ebp),%eax
f0104767:	8b 40 64             	mov    0x64(%eax),%eax
f010476a:	6a 40                	push   $0x40
f010476c:	6a 00                	push   $0x0
f010476e:	52                   	push   %edx
f010476f:	50                   	push   %eax
f0104770:	e8 7f 57 00 00       	call   f0109ef4 <pt_set_page_permissions>
f0104775:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104778:	8b 45 08             	mov    0x8(%ebp),%eax
f010477b:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104781:	8d 50 01             	lea    0x1(%eax),%edx
f0104784:	8b 45 08             	mov    0x8(%ebp),%eax
f0104787:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010478d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104790:	c9                   	leave  
f0104791:	c3                   	ret    

f0104792 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104792:	55                   	push   %ebp
f0104793:	89 e5                	mov    %esp,%ebp
f0104795:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104798:	8b 45 08             	mov    0x8(%ebp),%eax
f010479b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047a1:	85 c0                	test   %eax,%eax
f01047a3:	74 65                	je     f010480a <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01047a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a8:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047ae:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01047b1:	52                   	push   %edx
f01047b2:	6a 00                	push   $0x0
f01047b4:	ff 75 0c             	pushl  0xc(%ebp)
f01047b7:	50                   	push   %eax
f01047b8:	e8 1b fa ff ff       	call   f01041d8 <get_disk_page_table>
f01047bd:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01047c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047c3:	85 c0                	test   %eax,%eax
f01047c5:	74 46                	je     f010480d <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01047c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047ca:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047cd:	c1 ea 0c             	shr    $0xc,%edx
f01047d0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047d6:	c1 e2 02             	shl    $0x2,%edx
f01047d9:	01 d0                	add    %edx,%eax
f01047db:	8b 00                	mov    (%eax),%eax
f01047dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01047e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047e3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047e6:	c1 ea 0c             	shr    $0xc,%edx
f01047e9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047ef:	c1 e2 02             	shl    $0x2,%edx
f01047f2:	01 d0                	add    %edx,%eax
f01047f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01047fa:	83 ec 0c             	sub    $0xc,%esp
f01047fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0104800:	e8 d2 f8 ff ff       	call   f01040d7 <free_disk_frame>
f0104805:	83 c4 10             	add    $0x10,%esp
f0104808:	eb 04                	jmp    f010480e <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010480a:	90                   	nop
f010480b:	eb 01                	jmp    f010480e <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010480d:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010480e:	c9                   	leave  
f010480f:	c3                   	ret    

f0104810 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104810:	55                   	push   %ebp
f0104811:	89 e5                	mov    %esp,%ebp
f0104813:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104816:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010481d:	e9 c1 00 00 00       	jmp    f01048e3 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104822:	8b 45 08             	mov    0x8(%ebp),%eax
f0104825:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010482b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010482e:	c1 e2 02             	shl    $0x2,%edx
f0104831:	01 d0                	add    %edx,%eax
f0104833:	8b 00                	mov    (%eax),%eax
f0104835:	83 e0 01             	and    $0x1,%eax
f0104838:	85 c0                	test   %eax,%eax
f010483a:	0f 84 9f 00 00 00    	je     f01048df <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104840:	8b 45 08             	mov    0x8(%ebp),%eax
f0104843:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104849:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010484c:	c1 e2 02             	shl    $0x2,%edx
f010484f:	01 d0                	add    %edx,%eax
f0104851:	8b 00                	mov    (%eax),%eax
f0104853:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104858:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010485b:	83 ec 0c             	sub    $0xc,%esp
f010485e:	ff 75 ec             	pushl  -0x14(%ebp)
f0104861:	e8 f7 52 00 00       	call   f0109b5d <kheap_virtual_address>
f0104866:	83 c4 10             	add    $0x10,%esp
f0104869:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010486c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104873:	eb 3a                	jmp    f01048af <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104875:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104878:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010487f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104882:	01 d0                	add    %edx,%eax
f0104884:	8b 00                	mov    (%eax),%eax
f0104886:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0104889:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010488c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104893:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104896:	01 d0                	add    %edx,%eax
f0104898:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f010489e:	83 ec 0c             	sub    $0xc,%esp
f01048a1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01048a4:	e8 2e f8 ff ff       	call   f01040d7 <free_disk_frame>
f01048a9:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01048ac:	ff 45 f0             	incl   -0x10(%ebp)
f01048af:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01048b6:	76 bd                	jbe    f0104875 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01048b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01048bb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048c4:	c1 e2 02             	shl    $0x2,%edx
f01048c7:	01 d0                	add    %edx,%eax
f01048c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01048cf:	83 ec 0c             	sub    $0xc,%esp
f01048d2:	ff 75 e8             	pushl  -0x18(%ebp)
f01048d5:	e8 40 51 00 00       	call   f0109a1a <kfree>
f01048da:	83 c4 10             	add    $0x10,%esp
f01048dd:	eb 01                	jmp    f01048e0 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01048df:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01048e0:	ff 45 f4             	incl   -0xc(%ebp)
f01048e3:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01048ea:	0f 86 32 ff ff ff    	jbe    f0104822 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01048f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f3:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048f9:	83 ec 0c             	sub    $0xc,%esp
f01048fc:	50                   	push   %eax
f01048fd:	e8 18 51 00 00       	call   f0109a1a <kfree>
f0104902:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104905:	8b 45 08             	mov    0x8(%ebp),%eax
f0104908:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010490f:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104912:	8b 45 08             	mov    0x8(%ebp),%eax
f0104915:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010491c:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010491f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104922:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104928:	85 c0                	test   %eax,%eax
f010492a:	74 3f                	je     f010496b <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010492c:	83 ec 0c             	sub    $0xc,%esp
f010492f:	ff 75 08             	pushl  0x8(%ebp)
f0104932:	e8 14 03 00 00       	call   f0104c4b <__pf_remove_env_all_tables>
f0104937:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010493a:	8b 45 08             	mov    0x8(%ebp),%eax
f010493d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104943:	83 ec 0c             	sub    $0xc,%esp
f0104946:	50                   	push   %eax
f0104947:	e8 ce 50 00 00       	call   f0109a1a <kfree>
f010494c:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f010494f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104952:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f0104959:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010495c:	8b 45 08             	mov    0x8(%ebp),%eax
f010495f:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104966:	00 00 00 
f0104969:	eb 01                	jmp    f010496c <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010496b:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010496c:	c9                   	leave  
f010496d:	c3                   	ret    

f010496e <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010496e:	55                   	push   %ebp
f010496f:	89 e5                	mov    %esp,%ebp
f0104971:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104974:	8b 45 08             	mov    0x8(%ebp),%eax
f0104977:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010497d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104980:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104982:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104985:	8b 00                	mov    (%eax),%eax
f0104987:	85 c0                	test   %eax,%eax
f0104989:	75 5b                	jne    f01049e6 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010498b:	83 ec 0c             	sub    $0xc,%esp
f010498e:	68 00 10 00 00       	push   $0x1000
f0104993:	e8 22 4e 00 00       	call   f01097ba <kmalloc>
f0104998:	83 c4 10             	add    $0x10,%esp
f010499b:	89 c2                	mov    %eax,%edx
f010499d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a0:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01049a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a5:	8b 00                	mov    (%eax),%eax
f01049a7:	85 c0                	test   %eax,%eax
f01049a9:	75 07                	jne    f01049b2 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01049ab:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01049b0:	eb 39                	jmp    f01049eb <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01049b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049b5:	8b 00                	mov    (%eax),%eax
f01049b7:	83 ec 0c             	sub    $0xc,%esp
f01049ba:	50                   	push   %eax
f01049bb:	e8 40 51 00 00       	call   f0109b00 <kheap_physical_address>
f01049c0:	83 c4 10             	add    $0x10,%esp
f01049c3:	89 c2                	mov    %eax,%edx
f01049c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c8:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01049ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049d1:	8b 00                	mov    (%eax),%eax
f01049d3:	83 ec 04             	sub    $0x4,%esp
f01049d6:	68 00 10 00 00       	push   $0x1000
f01049db:	6a 00                	push   $0x0
f01049dd:	50                   	push   %eax
f01049de:	e8 b7 b6 01 00       	call   f012009a <memset>
f01049e3:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01049e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049eb:	c9                   	leave  
f01049ec:	c3                   	ret    

f01049ed <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01049ed:	55                   	push   %ebp
f01049ee:	89 e5                	mov    %esp,%ebp
f01049f0:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f01049f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01049fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a01:	eb 7e                	jmp    f0104a81 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104a03:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a06:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a0f:	c1 e2 02             	shl    $0x2,%edx
f0104a12:	01 d0                	add    %edx,%eax
f0104a14:	8b 00                	mov    (%eax),%eax
f0104a16:	83 e0 01             	and    $0x1,%eax
f0104a19:	85 c0                	test   %eax,%eax
f0104a1b:	74 60                	je     f0104a7d <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104a1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a20:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a29:	c1 e2 02             	shl    $0x2,%edx
f0104a2c:	01 d0                	add    %edx,%eax
f0104a2e:	8b 00                	mov    (%eax),%eax
f0104a30:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104a35:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0104a38:	83 ec 0c             	sub    $0xc,%esp
f0104a3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0104a3e:	e8 1a 51 00 00       	call   f0109b5d <kheap_virtual_address>
f0104a43:	83 c4 10             	add    $0x10,%esp
f0104a46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104a50:	eb 20                	jmp    f0104a72 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104a52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104a55:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104a5f:	01 d0                	add    %edx,%eax
f0104a61:	8b 00                	mov    (%eax),%eax
f0104a63:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104a66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0104a6a:	74 03                	je     f0104a6f <pf_calculate_allocated_pages+0x82>
				counter ++;
f0104a6c:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a6f:	ff 45 ec             	incl   -0x14(%ebp)
f0104a72:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104a79:	76 d7                	jbe    f0104a52 <pf_calculate_allocated_pages+0x65>
f0104a7b:	eb 01                	jmp    f0104a7e <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104a7d:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104a7e:	ff 45 f4             	incl   -0xc(%ebp)
f0104a81:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a88:	0f 86 75 ff ff ff    	jbe    f0104a03 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104a8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a91:	c9                   	leave  
f0104a92:	c3                   	ret    

f0104a93 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104a93:	55                   	push   %ebp
f0104a94:	89 e5                	mov    %esp,%ebp
f0104a96:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104a99:	83 ec 0c             	sub    $0xc,%esp
f0104a9c:	68 70 f7 f1 f0       	push   $0xf0f1f770
f0104aa1:	e8 58 b4 00 00       	call   f010fefe <acquire_spinlock>
f0104aa6:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104aa9:	a1 6c f7 f1 f0       	mov    0xf0f1f76c,%eax
f0104aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104ab1:	83 ec 0c             	sub    $0xc,%esp
f0104ab4:	68 70 f7 f1 f0       	push   $0xf0f1f770
f0104ab9:	e8 c7 b4 00 00       	call   f010ff85 <release_spinlock>
f0104abe:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104ac4:	c9                   	leave  
f0104ac5:	c3                   	ret    

f0104ac6 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104ac6:	55                   	push   %ebp
f0104ac7:	89 e5                	mov    %esp,%ebp
f0104ac9:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104acc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104acf:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f0104ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ad8:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104ada:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104add:	8b 00                	mov    (%eax),%eax
f0104adf:	85 c0                	test   %eax,%eax
f0104ae1:	75 5b                	jne    f0104b3e <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0104ae3:	83 ec 0c             	sub    $0xc,%esp
f0104ae6:	68 00 10 00 00       	push   $0x1000
f0104aeb:	e8 ca 4c 00 00       	call   f01097ba <kmalloc>
f0104af0:	83 c4 10             	add    $0x10,%esp
f0104af3:	89 c2                	mov    %eax,%edx
f0104af5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104af8:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f0104afa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afd:	8b 00                	mov    (%eax),%eax
f0104aff:	85 c0                	test   %eax,%eax
f0104b01:	75 07                	jne    f0104b0a <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104b03:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104b08:	eb 39                	jmp    f0104b43 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f0104b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b0d:	8b 00                	mov    (%eax),%eax
f0104b0f:	83 ec 0c             	sub    $0xc,%esp
f0104b12:	50                   	push   %eax
f0104b13:	e8 e8 4f 00 00       	call   f0109b00 <kheap_physical_address>
f0104b18:	83 c4 10             	add    $0x10,%esp
f0104b1b:	89 c2                	mov    %eax,%edx
f0104b1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b20:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104b26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b29:	8b 00                	mov    (%eax),%eax
f0104b2b:	83 ec 04             	sub    $0x4,%esp
f0104b2e:	68 00 10 00 00       	push   $0x1000
f0104b33:	6a 00                	push   $0x0
f0104b35:	50                   	push   %eax
f0104b36:	e8 5f b5 01 00       	call   f012009a <memset>
f0104b3b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104b3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b43:	c9                   	leave  
f0104b44:	c3                   	ret    

f0104b45 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104b45:	55                   	push   %ebp
f0104b46:	89 e5                	mov    %esp,%ebp
f0104b48:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104b4b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104b52:	76 19                	jbe    f0104b6d <__pf_write_env_table+0x28>
f0104b54:	68 88 54 12 f0       	push   $0xf0125488
f0104b59:	68 ae 54 12 f0       	push   $0xf01254ae
f0104b5e:	68 96 02 00 00       	push   $0x296
f0104b63:	68 f7 53 12 f0       	push   $0xf01253f7
f0104b68:	e8 cc b7 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0104b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b70:	05 88 00 00 00       	add    $0x88,%eax
f0104b75:	83 ec 08             	sub    $0x8,%esp
f0104b78:	50                   	push   %eax
f0104b79:	ff 75 08             	pushl  0x8(%ebp)
f0104b7c:	e8 45 ff ff ff       	call   f0104ac6 <get_disk_table_directory>
f0104b81:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104b84:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b87:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b8d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b90:	c1 ea 16             	shr    $0x16,%edx
f0104b93:	c1 e2 02             	shl    $0x2,%edx
f0104b96:	01 d0                	add    %edx,%eax
f0104b98:	8b 00                	mov    (%eax),%eax
f0104b9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104b9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ba0:	85 c0                	test   %eax,%eax
f0104ba2:	75 34                	jne    f0104bd8 <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104ba4:	83 ec 0c             	sub    $0xc,%esp
f0104ba7:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104baa:	50                   	push   %eax
f0104bab:	e8 39 f4 ff ff       	call   f0103fe9 <allocate_disk_frame>
f0104bb0:	83 c4 10             	add    $0x10,%esp
f0104bb3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104bb6:	75 07                	jne    f0104bbf <__pf_write_env_table+0x7a>
f0104bb8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104bbd:	eb 31                	jmp    f0104bf0 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0104bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104bc8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104bcb:	c1 ea 16             	shr    $0x16,%edx
f0104bce:	c1 e2 02             	shl    $0x2,%edx
f0104bd1:	01 c2                	add    %eax,%edx
f0104bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bd6:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0104bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bdb:	83 ec 08             	sub    $0x8,%esp
f0104bde:	ff 75 10             	pushl  0x10(%ebp)
f0104be1:	50                   	push   %eax
f0104be2:	e8 55 f2 ff ff       	call   f0103e3c <write_disk_page>
f0104be7:	83 c4 10             	add    $0x10,%esp
f0104bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104bf0:	c9                   	leave  
f0104bf1:	c3                   	ret    

f0104bf2 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104bf2:	55                   	push   %ebp
f0104bf3:	89 e5                	mov    %esp,%ebp
f0104bf5:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104bf8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bfb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c01:	85 c0                	test   %eax,%eax
f0104c03:	75 07                	jne    f0104c0c <__pf_read_env_table+0x1a>
f0104c05:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c0a:	eb 3d                	jmp    f0104c49 <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104c0c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c0f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c15:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104c18:	c1 ea 16             	shr    $0x16,%edx
f0104c1b:	c1 e2 02             	shl    $0x2,%edx
f0104c1e:	01 d0                	add    %edx,%eax
f0104c20:	8b 00                	mov    (%eax),%eax
f0104c22:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104c25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104c29:	75 07                	jne    f0104c32 <__pf_read_env_table+0x40>
f0104c2b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c30:	eb 17                	jmp    f0104c49 <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104c32:	83 ec 08             	sub    $0x8,%esp
f0104c35:	ff 75 10             	pushl  0x10(%ebp)
f0104c38:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c3b:	e8 cd f1 ff ff       	call   f0103e0d <read_disk_page>
f0104c40:	83 c4 10             	add    $0x10,%esp
f0104c43:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c49:	c9                   	leave  
f0104c4a:	c3                   	ret    

f0104c4b <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104c4b:	55                   	push   %ebp
f0104c4c:	89 e5                	mov    %esp,%ebp
f0104c4e:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104c51:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c54:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c5a:	85 c0                	test   %eax,%eax
f0104c5c:	74 52                	je     f0104cb0 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104c65:	eb 3e                	jmp    f0104ca5 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c6a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c70:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c73:	c1 e2 02             	shl    $0x2,%edx
f0104c76:	01 d0                	add    %edx,%eax
f0104c78:	8b 00                	mov    (%eax),%eax
f0104c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104c7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c80:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c86:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c89:	c1 e2 02             	shl    $0x2,%edx
f0104c8c:	01 d0                	add    %edx,%eax
f0104c8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104c94:	83 ec 0c             	sub    $0xc,%esp
f0104c97:	ff 75 f0             	pushl  -0x10(%ebp)
f0104c9a:	e8 38 f4 ff ff       	call   f01040d7 <free_disk_frame>
f0104c9f:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ca2:	ff 45 f4             	incl   -0xc(%ebp)
f0104ca5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104cac:	76 b9                	jbe    f0104c67 <__pf_remove_env_all_tables+0x1c>
f0104cae:	eb 01                	jmp    f0104cb1 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104cb0:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104cb1:	c9                   	leave  
f0104cb2:	c3                   	ret    

f0104cb3 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104cb3:	55                   	push   %ebp
f0104cb4:	89 e5                	mov    %esp,%ebp
f0104cb6:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104cb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104cbd:	75 10                	jne    f0104ccf <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104cbf:	83 ec 0c             	sub    $0xc,%esp
f0104cc2:	68 8c 55 12 f0       	push   $0xf012558c
f0104cc7:	e8 bf c2 ff ff       	call   f0100f8b <cprintf>
f0104ccc:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ccf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cd2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cd8:	85 c0                	test   %eax,%eax
f0104cda:	74 43                	je     f0104d1f <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104cdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cdf:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104ce5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ce8:	c1 ea 16             	shr    $0x16,%edx
f0104ceb:	c1 e2 02             	shl    $0x2,%edx
f0104cee:	01 d0                	add    %edx,%eax
f0104cf0:	8b 00                	mov    (%eax),%eax
f0104cf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104cf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d01:	c1 ea 16             	shr    $0x16,%edx
f0104d04:	c1 e2 02             	shl    $0x2,%edx
f0104d07:	01 d0                	add    %edx,%eax
f0104d09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104d0f:	83 ec 0c             	sub    $0xc,%esp
f0104d12:	ff 75 f4             	pushl  -0xc(%ebp)
f0104d15:	e8 bd f3 ff ff       	call   f01040d7 <free_disk_frame>
f0104d1a:	83 c4 10             	add    $0x10,%esp
f0104d1d:	eb 01                	jmp    f0104d20 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104d1f:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104d20:	c9                   	leave  
f0104d21:	c3                   	ret    

f0104d22 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104d22:	55                   	push   %ebp
f0104d23:	89 e5                	mov    %esp,%ebp
f0104d25:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104d28:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104d2f:	eb 1f                	jmp    f0104d50 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d34:	83 ec 04             	sub    $0x4,%esp
f0104d37:	6a 08                	push   $0x8
f0104d39:	ff 75 08             	pushl  0x8(%ebp)
f0104d3c:	50                   	push   %eax
f0104d3d:	e8 92 ba 01 00       	call   f01207d4 <ide_write>
f0104d42:	83 c4 10             	add    $0x10,%esp
f0104d45:	85 c0                	test   %eax,%eax
f0104d47:	75 12                	jne    f0104d5b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104d49:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104d50:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104d57:	7e d8                	jle    f0104d31 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d59:	eb 01                	jmp    f0104d5c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104d5b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d5c:	90                   	nop
f0104d5d:	c9                   	leave  
f0104d5e:	c3                   	ret    

f0104d5f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104d5f:	55                   	push   %ebp
  pushl %eax
f0104d60:	50                   	push   %eax
  pushl %ebx
f0104d61:	53                   	push   %ebx
  pushl %ecx
f0104d62:	51                   	push   %ecx
  pushl %edx
f0104d63:	52                   	push   %edx
  pushl %esi
f0104d64:	56                   	push   %esi
  pushl %edi
f0104d65:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104d66:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104d6a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104d6e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104d70:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104d72:	5f                   	pop    %edi
  popl %esi
f0104d73:	5e                   	pop    %esi
  popl %edx
f0104d74:	5a                   	pop    %edx
  popl %ecx
f0104d75:	59                   	pop    %ecx
  popl %ebx
f0104d76:	5b                   	pop    %ebx
  popl %eax
f0104d77:	58                   	pop    %eax
  popl %ebp
f0104d78:	5d                   	pop    %ebp
  ret
f0104d79:	c3                   	ret    

f0104d7a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104d7a:	55                   	push   %ebp
f0104d7b:	89 e5                	mov    %esp,%ebp
f0104d7d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104d80:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d83:	0f b6 c0             	movzbl %al,%eax
f0104d86:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104d8d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104d90:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104d93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104d96:	ee                   	out    %al,(%dx)
f0104d97:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104d9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104da1:	89 c2                	mov    %eax,%edx
f0104da3:	ec                   	in     (%dx),%al
f0104da4:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104da7:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104daa:	0f b6 c0             	movzbl %al,%eax
}
f0104dad:	c9                   	leave  
f0104dae:	c3                   	ret    

f0104daf <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104daf:	55                   	push   %ebp
f0104db0:	89 e5                	mov    %esp,%ebp
f0104db2:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db8:	0f b6 c0             	movzbl %al,%eax
f0104dbb:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104dc2:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104dc5:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104dc8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104dcb:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104dcf:	0f b6 c0             	movzbl %al,%eax
f0104dd2:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104dd9:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104ddc:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104ddf:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104de2:	ee                   	out    %al,(%dx)
}
f0104de3:	90                   	nop
f0104de4:	c9                   	leave  
f0104de5:	c3                   	ret    

f0104de6 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104de6:	55                   	push   %ebp
f0104de7:	89 e5                	mov    %esp,%ebp
f0104de9:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104dec:	c7 05 28 f7 b1 f0 00 	movl   $0x0,0xf0b1f728
f0104df3:	00 00 00 
f0104df6:	c7 05 2c f7 b1 f0 00 	movl   $0x0,0xf0b1f72c
f0104dfd:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104e00:	83 ec 08             	sub    $0x8,%esp
f0104e03:	68 ea 6e 10 f0       	push   $0xf0106eea
f0104e08:	6a 00                	push   $0x0
f0104e0a:	e8 fa 96 00 00       	call   f010e509 <irq_install_handler>
f0104e0f:	83 c4 10             	add    $0x10,%esp
}
f0104e12:	90                   	nop
f0104e13:	c9                   	leave  
f0104e14:	c3                   	ret    

f0104e15 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104e15:	55                   	push   %ebp
f0104e16:	89 e5                	mov    %esp,%ebp
f0104e18:	53                   	push   %ebx
f0104e19:	83 ec 24             	sub    $0x24,%esp
f0104e1c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e1f:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104e22:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e29:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e2d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e30:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e33:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104e34:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104e38:	77 48                	ja     f0104e82 <kclock_start+0x6d>
f0104e3a:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104e41:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104e45:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e4b:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104e4c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e50:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104e55:	99                   	cltd   
f0104e56:	f7 fb                	idiv   %ebx
f0104e58:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104e5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e62:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104e67:	99                   	cltd   
f0104e68:	f7 fb                	idiv   %ebx
f0104e6a:	89 c3                	mov    %eax,%ebx
f0104e6c:	89 c8                	mov    %ecx,%eax
f0104e6e:	99                   	cltd   
f0104e6f:	f7 fb                	idiv   %ebx
f0104e71:	0f b7 c0             	movzwl %ax,%eax
f0104e74:	83 ec 0c             	sub    $0xc,%esp
f0104e77:	50                   	push   %eax
f0104e78:	e8 b3 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104e7d:	83 c4 10             	add    $0x10,%esp
f0104e80:	eb 13                	jmp    f0104e95 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e82:	6a 35                	push   $0x35
f0104e84:	68 b0 55 12 f0       	push   $0xf01255b0
f0104e89:	6a 41                	push   $0x41
f0104e8b:	68 0c 56 12 f0       	push   $0xf012560c
f0104e90:	e8 a4 b4 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104e95:	83 ec 0c             	sub    $0xc,%esp
f0104e98:	6a 00                	push   $0x0
f0104e9a:	e8 80 24 00 00       	call   f010731f <irq_clear_mask>
f0104e9f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104ea2:	90                   	nop
f0104ea3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104ea6:	c9                   	leave  
f0104ea7:	c3                   	ret    

f0104ea8 <kclock_stop>:

void
kclock_stop(void)
{
f0104ea8:	55                   	push   %ebp
f0104ea9:	89 e5                	mov    %esp,%ebp
f0104eab:	83 ec 18             	sub    $0x18,%esp
f0104eae:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104eb5:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104eb9:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ebf:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104ec0:	83 ec 0c             	sub    $0xc,%esp
f0104ec3:	6a 00                	push   $0x0
f0104ec5:	e8 e0 23 00 00       	call   f01072aa <irq_set_mask>
f0104eca:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104ecd:	90                   	nop
f0104ece:	c9                   	leave  
f0104ecf:	c3                   	ret    

f0104ed0 <kclock_resume>:

void
kclock_resume(void)
{
f0104ed0:	55                   	push   %ebp
f0104ed1:	89 e5                	mov    %esp,%ebp
f0104ed3:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ed6:	e8 f5 01 00 00       	call   f01050d0 <kclock_read_cnt0_latch>
f0104edb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104edf:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104ee4:	77 06                	ja     f0104eec <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104ee6:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104eec:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ef0:	83 e0 01             	and    $0x1,%eax
f0104ef3:	66 85 c0             	test   %ax,%ax
f0104ef6:	74 09                	je     f0104f01 <kclock_resume+0x31>
		cnt0++;
f0104ef8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104efc:	40                   	inc    %eax
f0104efd:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104f01:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104f08:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104f0c:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104f0f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f12:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f13:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104f17:	83 ec 0c             	sub    $0xc,%esp
f0104f1a:	50                   	push   %eax
f0104f1b:	e8 10 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f20:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f23:	83 ec 0c             	sub    $0xc,%esp
f0104f26:	6a 00                	push   $0x0
f0104f28:	e8 f2 23 00 00       	call   f010731f <irq_clear_mask>
f0104f2d:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104f30:	90                   	nop
f0104f31:	c9                   	leave  
f0104f32:	c3                   	ret    

f0104f33 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104f33:	55                   	push   %ebp
f0104f34:	89 e5                	mov    %esp,%ebp
f0104f36:	83 ec 28             	sub    $0x28,%esp
f0104f39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f3c:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104f3f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f46:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104f4a:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f50:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f51:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104f55:	83 ec 0c             	sub    $0xc,%esp
f0104f58:	50                   	push   %eax
f0104f59:	e8 d2 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f5e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f61:	83 ec 0c             	sub    $0xc,%esp
f0104f64:	6a 00                	push   $0x0
f0104f66:	e8 b4 23 00 00       	call   f010731f <irq_clear_mask>
f0104f6b:	83 c4 10             	add    $0x10,%esp
}
f0104f6e:	90                   	nop
f0104f6f:	c9                   	leave  
f0104f70:	c3                   	ret    

f0104f71 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104f71:	55                   	push   %ebp
f0104f72:	89 e5                	mov    %esp,%ebp
f0104f74:	56                   	push   %esi
f0104f75:	53                   	push   %ebx
f0104f76:	83 ec 20             	sub    $0x20,%esp
f0104f79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104f7f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104f83:	0f 87 8a 00 00 00    	ja     f0105013 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104f89:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104f8d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104f92:	99                   	cltd   
f0104f93:	f7 fe                	idiv   %esi
f0104f95:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104f9b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104f9f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fa4:	99                   	cltd   
f0104fa5:	f7 fb                	idiv   %ebx
f0104fa7:	89 c6                	mov    %eax,%esi
f0104fa9:	89 c8                	mov    %ecx,%eax
f0104fab:	99                   	cltd   
f0104fac:	f7 fe                	idiv   %esi
f0104fae:	89 c3                	mov    %eax,%ebx
f0104fb0:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104fb4:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104fb9:	99                   	cltd   
f0104fba:	f7 f9                	idiv   %ecx
f0104fbc:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104fc2:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104fc6:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fcb:	99                   	cltd   
f0104fcc:	f7 fe                	idiv   %esi
f0104fce:	89 c6                	mov    %eax,%esi
f0104fd0:	89 c8                	mov    %ecx,%eax
f0104fd2:	99                   	cltd   
f0104fd3:	f7 fe                	idiv   %esi
f0104fd5:	25 01 00 00 80       	and    $0x80000001,%eax
f0104fda:	85 c0                	test   %eax,%eax
f0104fdc:	79 05                	jns    f0104fe3 <kclock_set_quantum+0x72>
f0104fde:	48                   	dec    %eax
f0104fdf:	83 c8 fe             	or     $0xfffffffe,%eax
f0104fe2:	40                   	inc    %eax
f0104fe3:	01 d8                	add    %ebx,%eax
f0104fe5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104fe8:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104fef:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104ff3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104ff6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104ff9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ffd:	0f b7 c0             	movzwl %ax,%eax
f0105000:	83 ec 0c             	sub    $0xc,%esp
f0105003:	50                   	push   %eax
f0105004:	e8 27 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0105009:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f010500c:	e8 97 fe ff ff       	call   f0104ea8 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105011:	eb 16                	jmp    f0105029 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105013:	6a 35                	push   $0x35
f0105015:	68 b0 55 12 f0       	push   $0xf01255b0
f010501a:	68 ea 00 00 00       	push   $0xea
f010501f:	68 0c 56 12 f0       	push   $0xf012560c
f0105024:	e8 10 b3 ff ff       	call   f0100339 <_panic>
	}
}
f0105029:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010502c:	5b                   	pop    %ebx
f010502d:	5e                   	pop    %esi
f010502e:	5d                   	pop    %ebp
f010502f:	c3                   	ret    

f0105030 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105030:	55                   	push   %ebp
f0105031:	89 e5                	mov    %esp,%ebp
f0105033:	83 ec 28             	sub    $0x28,%esp
f0105036:	8b 45 08             	mov    0x8(%ebp),%eax
f0105039:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f010503d:	e8 b8 24 00 00       	call   f01074fa <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105045:	0f b6 c0             	movzbl %al,%eax
f0105048:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f010504f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105052:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105055:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105058:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010505c:	66 c1 e8 08          	shr    $0x8,%ax
f0105060:	0f b6 c0             	movzbl %al,%eax
f0105063:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f010506a:	88 45 ef             	mov    %al,-0x11(%ebp)
f010506d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105070:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105073:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105074:	e8 d3 24 00 00       	call   f010754c <popcli>

}
f0105079:	90                   	nop
f010507a:	c9                   	leave  
f010507b:	c3                   	ret    

f010507c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f010507c:	55                   	push   %ebp
f010507d:	89 e5                	mov    %esp,%ebp
f010507f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105082:	e8 73 24 00 00       	call   f01074fa <pushcli>
f0105087:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010508e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105091:	89 c2                	mov    %eax,%edx
f0105093:	ec                   	in     (%dx),%al
f0105094:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105097:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f010509a:	88 45 f7             	mov    %al,-0x9(%ebp)
f010509d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01050a7:	89 c2                	mov    %eax,%edx
f01050a9:	ec                   	in     (%dx),%al
f01050aa:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f01050ad:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f01050b0:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f01050b3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01050b7:	c1 e0 08             	shl    $0x8,%eax
f01050ba:	89 c2                	mov    %eax,%edx
f01050bc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01050c0:	09 d0                	or     %edx,%eax
f01050c2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f01050c6:	e8 81 24 00 00       	call   f010754c <popcli>
	return cnt0 ;
f01050cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01050ce:	c9                   	leave  
f01050cf:	c3                   	ret    

f01050d0 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f01050d0:	55                   	push   %ebp
f01050d1:	89 e5                	mov    %esp,%ebp
f01050d3:	83 ec 30             	sub    $0x30,%esp
f01050d6:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01050e0:	89 c2                	mov    %eax,%edx
f01050e2:	ec                   	in     (%dx),%al
f01050e3:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f01050e6:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f01050e9:	88 45 ff             	mov    %al,-0x1(%ebp)
f01050ec:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f01050f3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01050f7:	8a 45 dc             	mov    -0x24(%ebp),%al
f01050fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050fd:	ee                   	out    %al,(%dx)
f01050fe:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105105:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105108:	89 c2                	mov    %eax,%edx
f010510a:	ec                   	in     (%dx),%al
f010510b:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f010510e:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105111:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105114:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010511b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010511e:	89 c2                	mov    %eax,%edx
f0105120:	ec                   	in     (%dx),%al
f0105121:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105124:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105127:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f010512a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f010512e:	c1 e0 08             	shl    $0x8,%eax
f0105131:	89 c2                	mov    %eax,%edx
f0105133:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105137:	09 d0                	or     %edx,%eax
f0105139:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f010513d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105141:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105148:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010514b:	8a 45 df             	mov    -0x21(%ebp),%al
f010514e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105151:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105152:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105155:	c9                   	leave  
f0105156:	c3                   	ret    

f0105157 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105157:	55                   	push   %ebp
f0105158:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f010515a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010515e:	74 1d                	je     f010517d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105160:	8b 45 08             	mov    0x8(%ebp),%eax
f0105163:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105169:	8b 45 08             	mov    0x8(%ebp),%eax
f010516c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105173:	8b 45 08             	mov    0x8(%ebp),%eax
f0105176:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f010517d:	90                   	nop
f010517e:	5d                   	pop    %ebp
f010517f:	c3                   	ret    

f0105180 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105180:	55                   	push   %ebp
f0105181:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105183:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105187:	74 08                	je     f0105191 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105189:	8b 45 08             	mov    0x8(%ebp),%eax
f010518c:	8b 40 0c             	mov    0xc(%eax),%eax
f010518f:	eb 05                	jmp    f0105196 <queue_size+0x16>
	}
	else
	{
		return 0;
f0105191:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0105196:	5d                   	pop    %ebp
f0105197:	c3                   	ret    

f0105198 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0105198:	55                   	push   %ebp
f0105199:	89 e5                	mov    %esp,%ebp
f010519b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010519e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051a2:	75 16                	jne    f01051ba <enqueue+0x22>
f01051a4:	68 20 56 12 f0       	push   $0xf0125620
f01051a9:	68 2e 56 12 f0       	push   $0xf012562e
f01051ae:	6a 34                	push   $0x34
f01051b0:	68 43 56 12 f0       	push   $0xf0125643
f01051b5:	e8 7f b1 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f01051ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051be:	74 66                	je     f0105226 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f01051c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051c4:	75 14                	jne    f01051da <enqueue+0x42>
f01051c6:	83 ec 04             	sub    $0x4,%esp
f01051c9:	68 5c 56 12 f0       	push   $0xf012565c
f01051ce:	6a 37                	push   $0x37
f01051d0:	68 43 56 12 f0       	push   $0xf0125643
f01051d5:	e8 5f b1 ff ff       	call   f0100339 <_panic>
f01051da:	8b 45 08             	mov    0x8(%ebp),%eax
f01051dd:	8b 10                	mov    (%eax),%edx
f01051df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e2:	89 50 08             	mov    %edx,0x8(%eax)
f01051e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e8:	8b 40 08             	mov    0x8(%eax),%eax
f01051eb:	85 c0                	test   %eax,%eax
f01051ed:	74 0d                	je     f01051fc <enqueue+0x64>
f01051ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01051f2:	8b 00                	mov    (%eax),%eax
f01051f4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051f7:	89 50 0c             	mov    %edx,0xc(%eax)
f01051fa:	eb 09                	jmp    f0105205 <enqueue+0x6d>
f01051fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01051ff:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105202:	89 50 04             	mov    %edx,0x4(%eax)
f0105205:	8b 45 08             	mov    0x8(%ebp),%eax
f0105208:	8b 55 0c             	mov    0xc(%ebp),%edx
f010520b:	89 10                	mov    %edx,(%eax)
f010520d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105210:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105217:	8b 45 08             	mov    0x8(%ebp),%eax
f010521a:	8b 40 0c             	mov    0xc(%eax),%eax
f010521d:	8d 50 01             	lea    0x1(%eax),%edx
f0105220:	8b 45 08             	mov    0x8(%ebp),%eax
f0105223:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105226:	90                   	nop
f0105227:	c9                   	leave  
f0105228:	c3                   	ret    

f0105229 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105229:	55                   	push   %ebp
f010522a:	89 e5                	mov    %esp,%ebp
f010522c:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f010522f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105233:	75 0a                	jne    f010523f <dequeue+0x16>
f0105235:	b8 00 00 00 00       	mov    $0x0,%eax
f010523a:	e9 a0 00 00 00       	jmp    f01052df <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f010523f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105242:	8b 40 04             	mov    0x4(%eax),%eax
f0105245:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105248:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010524c:	0f 84 8a 00 00 00    	je     f01052dc <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105252:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105256:	75 14                	jne    f010526c <dequeue+0x43>
f0105258:	83 ec 04             	sub    $0x4,%esp
f010525b:	68 7f 56 12 f0       	push   $0xf012567f
f0105260:	6a 44                	push   $0x44
f0105262:	68 43 56 12 f0       	push   $0xf0125643
f0105267:	e8 cd b0 ff ff       	call   f0100339 <_panic>
f010526c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010526f:	8b 40 08             	mov    0x8(%eax),%eax
f0105272:	85 c0                	test   %eax,%eax
f0105274:	74 11                	je     f0105287 <dequeue+0x5e>
f0105276:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105279:	8b 40 08             	mov    0x8(%eax),%eax
f010527c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010527f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105282:	89 50 0c             	mov    %edx,0xc(%eax)
f0105285:	eb 0c                	jmp    f0105293 <dequeue+0x6a>
f0105287:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010528a:	8b 50 0c             	mov    0xc(%eax),%edx
f010528d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105290:	89 50 04             	mov    %edx,0x4(%eax)
f0105293:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105296:	8b 40 0c             	mov    0xc(%eax),%eax
f0105299:	85 c0                	test   %eax,%eax
f010529b:	74 11                	je     f01052ae <dequeue+0x85>
f010529d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052a0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052a6:	8b 52 08             	mov    0x8(%edx),%edx
f01052a9:	89 50 08             	mov    %edx,0x8(%eax)
f01052ac:	eb 0b                	jmp    f01052b9 <dequeue+0x90>
f01052ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052b1:	8b 50 08             	mov    0x8(%eax),%edx
f01052b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01052b7:	89 10                	mov    %edx,(%eax)
f01052b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01052c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052c6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01052cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052d3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01052d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d9:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01052dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01052df:	c9                   	leave  
f01052e0:	c3                   	ret    

f01052e1 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01052e1:	55                   	push   %ebp
f01052e2:	89 e5                	mov    %esp,%ebp
f01052e4:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01052e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052eb:	75 16                	jne    f0105303 <remove_from_queue+0x22>
f01052ed:	68 20 56 12 f0       	push   $0xf0125620
f01052f2:	68 2e 56 12 f0       	push   $0xf012562e
f01052f7:	6a 4e                	push   $0x4e
f01052f9:	68 43 56 12 f0       	push   $0xf0125643
f01052fe:	e8 36 b0 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105303:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105307:	0f 84 8a 00 00 00    	je     f0105397 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010530d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105311:	75 14                	jne    f0105327 <remove_from_queue+0x46>
f0105313:	83 ec 04             	sub    $0x4,%esp
f0105316:	68 7f 56 12 f0       	push   $0xf012567f
f010531b:	6a 52                	push   $0x52
f010531d:	68 43 56 12 f0       	push   $0xf0125643
f0105322:	e8 12 b0 ff ff       	call   f0100339 <_panic>
f0105327:	8b 45 0c             	mov    0xc(%ebp),%eax
f010532a:	8b 40 08             	mov    0x8(%eax),%eax
f010532d:	85 c0                	test   %eax,%eax
f010532f:	74 11                	je     f0105342 <remove_from_queue+0x61>
f0105331:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105334:	8b 40 08             	mov    0x8(%eax),%eax
f0105337:	8b 55 0c             	mov    0xc(%ebp),%edx
f010533a:	8b 52 0c             	mov    0xc(%edx),%edx
f010533d:	89 50 0c             	mov    %edx,0xc(%eax)
f0105340:	eb 0c                	jmp    f010534e <remove_from_queue+0x6d>
f0105342:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105345:	8b 50 0c             	mov    0xc(%eax),%edx
f0105348:	8b 45 08             	mov    0x8(%ebp),%eax
f010534b:	89 50 04             	mov    %edx,0x4(%eax)
f010534e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105351:	8b 40 0c             	mov    0xc(%eax),%eax
f0105354:	85 c0                	test   %eax,%eax
f0105356:	74 11                	je     f0105369 <remove_from_queue+0x88>
f0105358:	8b 45 0c             	mov    0xc(%ebp),%eax
f010535b:	8b 40 0c             	mov    0xc(%eax),%eax
f010535e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105361:	8b 52 08             	mov    0x8(%edx),%edx
f0105364:	89 50 08             	mov    %edx,0x8(%eax)
f0105367:	eb 0b                	jmp    f0105374 <remove_from_queue+0x93>
f0105369:	8b 45 0c             	mov    0xc(%ebp),%eax
f010536c:	8b 50 08             	mov    0x8(%eax),%edx
f010536f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105372:	89 10                	mov    %edx,(%eax)
f0105374:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105377:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010537e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105381:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105388:	8b 45 08             	mov    0x8(%ebp),%eax
f010538b:	8b 40 0c             	mov    0xc(%eax),%eax
f010538e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105391:	8b 45 08             	mov    0x8(%ebp),%eax
f0105394:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105397:	90                   	nop
f0105398:	c9                   	leave  
f0105399:	c3                   	ret    

f010539a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010539a:	55                   	push   %ebp
f010539b:	89 e5                	mov    %esp,%ebp
f010539d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01053a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053a4:	75 07                	jne    f01053ad <find_env_in_queue+0x13>
f01053a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ab:	eb 58                	jmp    f0105405 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01053ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01053b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b7:	8b 00                	mov    (%eax),%eax
f01053b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053bc:	eb 19                	jmp    f01053d7 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01053be:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053c1:	8b 40 10             	mov    0x10(%eax),%eax
f01053c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01053c7:	75 05                	jne    f01053ce <find_env_in_queue+0x34>
		{
			return ptr_env;
f01053c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053cc:	eb 37                	jmp    f0105405 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01053ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d1:	8b 40 08             	mov    0x8(%eax),%eax
f01053d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053db:	74 08                	je     f01053e5 <find_env_in_queue+0x4b>
f01053dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053e0:	8b 40 08             	mov    0x8(%eax),%eax
f01053e3:	eb 05                	jmp    f01053ea <find_env_in_queue+0x50>
f01053e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ea:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ed:	89 42 08             	mov    %eax,0x8(%edx)
f01053f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f3:	8b 40 08             	mov    0x8(%eax),%eax
f01053f6:	85 c0                	test   %eax,%eax
f01053f8:	75 c4                	jne    f01053be <find_env_in_queue+0x24>
f01053fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053fe:	75 be                	jne    f01053be <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105400:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105405:	c9                   	leave  
f0105406:	c3                   	ret    

f0105407 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105407:	55                   	push   %ebp
f0105408:	89 e5                	mov    %esp,%ebp
f010540a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010540d:	83 ec 0c             	sub    $0xc,%esp
f0105410:	68 80 f0 71 f0       	push   $0xf071f080
f0105415:	e8 e4 aa 00 00       	call   f010fefe <acquire_spinlock>
f010541a:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010541d:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105422:	85 c0                	test   %eax,%eax
f0105424:	74 11                	je     f0105437 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105426:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010542b:	83 ec 0c             	sub    $0xc,%esp
f010542e:	50                   	push   %eax
f010542f:	e8 e6 45 00 00       	call   f0109a1a <kfree>
f0105434:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105437:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f010543c:	85 c0                	test   %eax,%eax
f010543e:	74 11                	je     f0105451 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105440:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0105445:	83 ec 0c             	sub    $0xc,%esp
f0105448:	50                   	push   %eax
f0105449:	e8 cc 45 00 00       	call   f0109a1a <kfree>
f010544e:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105451:	83 ec 0c             	sub    $0xc,%esp
f0105454:	68 80 f0 71 f0       	push   $0xf071f080
f0105459:	e8 27 ab 00 00       	call   f010ff85 <release_spinlock>
f010545e:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105461:	90                   	nop
f0105462:	c9                   	leave  
f0105463:	c3                   	ret    

f0105464 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105464:	55                   	push   %ebp
f0105465:	89 e5                	mov    %esp,%ebp
f0105467:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010546a:	83 ec 0c             	sub    $0xc,%esp
f010546d:	68 80 f0 71 f0       	push   $0xf071f080
f0105472:	e8 a0 ac 00 00       	call   f0110117 <holding_spinlock>
f0105477:	83 c4 10             	add    $0x10,%esp
f010547a:	85 c0                	test   %eax,%eax
f010547c:	75 17                	jne    f0105495 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010547e:	83 ec 04             	sub    $0x4,%esp
f0105481:	68 a0 56 12 f0       	push   $0xf01256a0
f0105486:	68 85 00 00 00       	push   $0x85
f010548b:	68 43 56 12 f0       	push   $0xf0125643
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105495:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105499:	75 19                	jne    f01054b4 <sched_insert_ready0+0x50>
f010549b:	68 e1 56 12 f0       	push   $0xf01256e1
f01054a0:	68 2e 56 12 f0       	push   $0xf012562e
f01054a5:	68 88 00 00 00       	push   $0x88
f01054aa:	68 43 56 12 f0       	push   $0xf0125643
f01054af:	e8 85 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01054b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b7:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01054be:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01054c3:	83 ec 08             	sub    $0x8,%esp
f01054c6:	ff 75 08             	pushl  0x8(%ebp)
f01054c9:	50                   	push   %eax
f01054ca:	e8 c9 fc ff ff       	call   f0105198 <enqueue>
f01054cf:	83 c4 10             	add    $0x10,%esp
	}
}
f01054d2:	90                   	nop
f01054d3:	c9                   	leave  
f01054d4:	c3                   	ret    

f01054d5 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01054d5:	55                   	push   %ebp
f01054d6:	89 e5                	mov    %esp,%ebp
f01054d8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054db:	83 ec 0c             	sub    $0xc,%esp
f01054de:	68 80 f0 71 f0       	push   $0xf071f080
f01054e3:	e8 2f ac 00 00       	call   f0110117 <holding_spinlock>
f01054e8:	83 c4 10             	add    $0x10,%esp
f01054eb:	85 c0                	test   %eax,%eax
f01054ed:	75 17                	jne    f0105506 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054ef:	83 ec 04             	sub    $0x4,%esp
f01054f2:	68 a0 56 12 f0       	push   $0xf01256a0
f01054f7:	68 97 00 00 00       	push   $0x97
f01054fc:	68 43 56 12 f0       	push   $0xf0125643
f0105501:	e8 33 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105506:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010550a:	75 19                	jne    f0105525 <sched_insert_ready+0x50>
f010550c:	68 e1 56 12 f0       	push   $0xf01256e1
f0105511:	68 2e 56 12 f0       	push   $0xf012562e
f0105516:	68 9a 00 00 00       	push   $0x9a
f010551b:	68 43 56 12 f0       	push   $0xf0125643
f0105520:	e8 14 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105525:	8b 45 08             	mov    0x8(%ebp),%eax
f0105528:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f010552f:	8b 15 10 f1 71 f0    	mov    0xf071f110,%edx
f0105535:	8b 45 08             	mov    0x8(%ebp),%eax
f0105538:	8b 40 1c             	mov    0x1c(%eax),%eax
f010553b:	c1 e0 04             	shl    $0x4,%eax
f010553e:	01 d0                	add    %edx,%eax
f0105540:	83 ec 08             	sub    $0x8,%esp
f0105543:	ff 75 08             	pushl  0x8(%ebp)
f0105546:	50                   	push   %eax
f0105547:	e8 4c fc ff ff       	call   f0105198 <enqueue>
f010554c:	83 c4 10             	add    $0x10,%esp
	}
}
f010554f:	90                   	nop
f0105550:	c9                   	leave  
f0105551:	c3                   	ret    

f0105552 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105552:	55                   	push   %ebp
f0105553:	89 e5                	mov    %esp,%ebp
f0105555:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105558:	83 ec 0c             	sub    $0xc,%esp
f010555b:	68 80 f0 71 f0       	push   $0xf071f080
f0105560:	e8 b2 ab 00 00       	call   f0110117 <holding_spinlock>
f0105565:	83 c4 10             	add    $0x10,%esp
f0105568:	85 c0                	test   %eax,%eax
f010556a:	75 17                	jne    f0105583 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010556c:	83 ec 04             	sub    $0x4,%esp
f010556f:	68 a0 56 12 f0       	push   $0xf01256a0
f0105574:	68 a9 00 00 00       	push   $0xa9
f0105579:	68 43 56 12 f0       	push   $0xf0125643
f010557e:	e8 b6 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105583:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105587:	74 0b                	je     f0105594 <sched_remove_ready+0x42>
f0105589:	8b 45 08             	mov    0x8(%ebp),%eax
f010558c:	8b 40 18             	mov    0x18(%eax),%eax
f010558f:	83 f8 01             	cmp    $0x1,%eax
f0105592:	74 19                	je     f01055ad <sched_remove_ready+0x5b>
f0105594:	68 f0 56 12 f0       	push   $0xf01256f0
f0105599:	68 2e 56 12 f0       	push   $0xf012562e
f010559e:	68 ac 00 00 00       	push   $0xac
f01055a3:	68 43 56 12 f0       	push   $0xf0125643
f01055a8:	e8 8c ad ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01055ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055b4:	e9 e4 00 00 00       	jmp    f010569d <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01055b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01055bc:	8b 40 10             	mov    0x10(%eax),%eax
f01055bf:	89 c2                	mov    %eax,%edx
f01055c1:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01055c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01055c9:	c1 e1 04             	shl    $0x4,%ecx
f01055cc:	01 c8                	add    %ecx,%eax
f01055ce:	83 ec 08             	sub    $0x8,%esp
f01055d1:	52                   	push   %edx
f01055d2:	50                   	push   %eax
f01055d3:	e8 c2 fd ff ff       	call   f010539a <find_env_in_queue>
f01055d8:	83 c4 10             	add    $0x10,%esp
f01055db:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01055de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01055e2:	0f 84 b2 00 00 00    	je     f010569a <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01055e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ec:	75 17                	jne    f0105605 <sched_remove_ready+0xb3>
f01055ee:	83 ec 04             	sub    $0x4,%esp
f01055f1:	68 7f 56 12 f0       	push   $0xf012567f
f01055f6:	68 b3 00 00 00       	push   $0xb3
f01055fb:	68 43 56 12 f0       	push   $0xf0125643
f0105600:	e8 34 ad ff ff       	call   f0100339 <_panic>
f0105605:	8b 45 08             	mov    0x8(%ebp),%eax
f0105608:	8b 40 08             	mov    0x8(%eax),%eax
f010560b:	85 c0                	test   %eax,%eax
f010560d:	74 11                	je     f0105620 <sched_remove_ready+0xce>
f010560f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105612:	8b 40 08             	mov    0x8(%eax),%eax
f0105615:	8b 55 08             	mov    0x8(%ebp),%edx
f0105618:	8b 52 0c             	mov    0xc(%edx),%edx
f010561b:	89 50 0c             	mov    %edx,0xc(%eax)
f010561e:	eb 16                	jmp    f0105636 <sched_remove_ready+0xe4>
f0105620:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105625:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105628:	c1 e2 04             	shl    $0x4,%edx
f010562b:	01 c2                	add    %eax,%edx
f010562d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105630:	8b 40 0c             	mov    0xc(%eax),%eax
f0105633:	89 42 04             	mov    %eax,0x4(%edx)
f0105636:	8b 45 08             	mov    0x8(%ebp),%eax
f0105639:	8b 40 0c             	mov    0xc(%eax),%eax
f010563c:	85 c0                	test   %eax,%eax
f010563e:	74 11                	je     f0105651 <sched_remove_ready+0xff>
f0105640:	8b 45 08             	mov    0x8(%ebp),%eax
f0105643:	8b 40 0c             	mov    0xc(%eax),%eax
f0105646:	8b 55 08             	mov    0x8(%ebp),%edx
f0105649:	8b 52 08             	mov    0x8(%edx),%edx
f010564c:	89 50 08             	mov    %edx,0x8(%eax)
f010564f:	eb 15                	jmp    f0105666 <sched_remove_ready+0x114>
f0105651:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105656:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105659:	c1 e2 04             	shl    $0x4,%edx
f010565c:	01 c2                	add    %eax,%edx
f010565e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105661:	8b 40 08             	mov    0x8(%eax),%eax
f0105664:	89 02                	mov    %eax,(%edx)
f0105666:	8b 45 08             	mov    0x8(%ebp),%eax
f0105669:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105670:	8b 45 08             	mov    0x8(%ebp),%eax
f0105673:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010567a:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010567f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105682:	c1 e2 04             	shl    $0x4,%edx
f0105685:	01 d0                	add    %edx,%eax
f0105687:	8b 50 0c             	mov    0xc(%eax),%edx
f010568a:	4a                   	dec    %edx
f010568b:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f0105698:	eb 14                	jmp    f01056ae <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010569a:	ff 45 f4             	incl   -0xc(%ebp)
f010569d:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f01056a2:	0f b6 c0             	movzbl %al,%eax
f01056a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01056a8:	0f 8f 0b ff ff ff    	jg     f01055b9 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01056ae:	c9                   	leave  
f01056af:	c3                   	ret    

f01056b0 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01056b0:	55                   	push   %ebp
f01056b1:	89 e5                	mov    %esp,%ebp
f01056b3:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01056b6:	83 ec 0c             	sub    $0xc,%esp
f01056b9:	68 80 f0 71 f0       	push   $0xf071f080
f01056be:	e8 54 aa 00 00       	call   f0110117 <holding_spinlock>
f01056c3:	83 c4 10             	add    $0x10,%esp
f01056c6:	85 c0                	test   %eax,%eax
f01056c8:	75 17                	jne    f01056e1 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01056ca:	83 ec 04             	sub    $0x4,%esp
f01056cd:	68 a0 56 12 f0       	push   $0xf01256a0
f01056d2:	68 c2 00 00 00       	push   $0xc2
f01056d7:	68 43 56 12 f0       	push   $0xf0125643
f01056dc:	e8 58 ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01056e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056e5:	75 19                	jne    f0105700 <sched_insert_new+0x50>
f01056e7:	68 e1 56 12 f0       	push   $0xf01256e1
f01056ec:	68 2e 56 12 f0       	push   $0xf012562e
f01056f1:	68 c5 00 00 00       	push   $0xc5
f01056f6:	68 43 56 12 f0       	push   $0xf0125643
f01056fb:	e8 39 ac ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105700:	8b 45 08             	mov    0x8(%ebp),%eax
f0105703:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010570a:	83 ec 08             	sub    $0x8,%esp
f010570d:	ff 75 08             	pushl  0x8(%ebp)
f0105710:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0105715:	e8 7e fa ff ff       	call   f0105198 <enqueue>
f010571a:	83 c4 10             	add    $0x10,%esp
	}
}
f010571d:	90                   	nop
f010571e:	c9                   	leave  
f010571f:	c3                   	ret    

f0105720 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105720:	55                   	push   %ebp
f0105721:	89 e5                	mov    %esp,%ebp
f0105723:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105726:	83 ec 0c             	sub    $0xc,%esp
f0105729:	68 80 f0 71 f0       	push   $0xf071f080
f010572e:	e8 e4 a9 00 00       	call   f0110117 <holding_spinlock>
f0105733:	83 c4 10             	add    $0x10,%esp
f0105736:	85 c0                	test   %eax,%eax
f0105738:	75 17                	jne    f0105751 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010573a:	83 ec 04             	sub    $0x4,%esp
f010573d:	68 a0 56 12 f0       	push   $0xf01256a0
f0105742:	68 d3 00 00 00       	push   $0xd3
f0105747:	68 43 56 12 f0       	push   $0xf0125643
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105751:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105755:	74 0b                	je     f0105762 <sched_remove_new+0x42>
f0105757:	8b 45 08             	mov    0x8(%ebp),%eax
f010575a:	8b 40 18             	mov    0x18(%eax),%eax
f010575d:	83 f8 04             	cmp    $0x4,%eax
f0105760:	74 19                	je     f010577b <sched_remove_new+0x5b>
f0105762:	68 1c 57 12 f0       	push   $0xf012571c
f0105767:	68 2e 56 12 f0       	push   $0xf012562e
f010576c:	68 d6 00 00 00       	push   $0xd6
f0105771:	68 43 56 12 f0       	push   $0xf0125643
f0105776:	e8 be ab ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010577b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010577f:	75 17                	jne    f0105798 <sched_remove_new+0x78>
f0105781:	83 ec 04             	sub    $0x4,%esp
f0105784:	68 7f 56 12 f0       	push   $0xf012567f
f0105789:	68 d8 00 00 00       	push   $0xd8
f010578e:	68 43 56 12 f0       	push   $0xf0125643
f0105793:	e8 a1 ab ff ff       	call   f0100339 <_panic>
f0105798:	8b 45 08             	mov    0x8(%ebp),%eax
f010579b:	8b 40 08             	mov    0x8(%eax),%eax
f010579e:	85 c0                	test   %eax,%eax
f01057a0:	74 11                	je     f01057b3 <sched_remove_new+0x93>
f01057a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a5:	8b 40 08             	mov    0x8(%eax),%eax
f01057a8:	8b 55 08             	mov    0x8(%ebp),%edx
f01057ab:	8b 52 0c             	mov    0xc(%edx),%edx
f01057ae:	89 50 0c             	mov    %edx,0xc(%eax)
f01057b1:	eb 0b                	jmp    f01057be <sched_remove_new+0x9e>
f01057b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b6:	8b 40 0c             	mov    0xc(%eax),%eax
f01057b9:	a3 f4 f0 71 f0       	mov    %eax,0xf071f0f4
f01057be:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c1:	8b 40 0c             	mov    0xc(%eax),%eax
f01057c4:	85 c0                	test   %eax,%eax
f01057c6:	74 11                	je     f01057d9 <sched_remove_new+0xb9>
f01057c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01057cb:	8b 40 0c             	mov    0xc(%eax),%eax
f01057ce:	8b 55 08             	mov    0x8(%ebp),%edx
f01057d1:	8b 52 08             	mov    0x8(%edx),%edx
f01057d4:	89 50 08             	mov    %edx,0x8(%eax)
f01057d7:	eb 0b                	jmp    f01057e4 <sched_remove_new+0xc4>
f01057d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01057dc:	8b 40 08             	mov    0x8(%eax),%eax
f01057df:	a3 f0 f0 71 f0       	mov    %eax,0xf071f0f0
f01057e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01057ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01057f1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01057f8:	a1 fc f0 71 f0       	mov    0xf071f0fc,%eax
f01057fd:	48                   	dec    %eax
f01057fe:	a3 fc f0 71 f0       	mov    %eax,0xf071f0fc
		env->env_status = ENV_UNKNOWN;
f0105803:	8b 45 08             	mov    0x8(%ebp),%eax
f0105806:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010580d:	90                   	nop
f010580e:	c9                   	leave  
f010580f:	c3                   	ret    

f0105810 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 80 f0 71 f0       	push   $0xf071f080
f010581e:	e8 f4 a8 00 00       	call   f0110117 <holding_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
f0105826:	85 c0                	test   %eax,%eax
f0105828:	75 17                	jne    f0105841 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010582a:	83 ec 04             	sub    $0x4,%esp
f010582d:	68 a0 56 12 f0       	push   $0xf01256a0
f0105832:	68 e4 00 00 00       	push   $0xe4
f0105837:	68 43 56 12 f0       	push   $0xf0125643
f010583c:	e8 f8 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105841:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105845:	75 19                	jne    f0105860 <sched_insert_exit+0x50>
f0105847:	68 e1 56 12 f0       	push   $0xf01256e1
f010584c:	68 2e 56 12 f0       	push   $0xf012562e
f0105851:	68 e7 00 00 00       	push   $0xe7
f0105856:	68 43 56 12 f0       	push   $0xf0125643
f010585b:	e8 d9 aa ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105860:	e8 09 a1 00 00       	call   f010f96e <isBufferingEnabled>
f0105865:	84 c0                	test   %al,%al
f0105867:	74 0e                	je     f0105877 <sched_insert_exit+0x67>
f0105869:	83 ec 0c             	sub    $0xc,%esp
f010586c:	ff 75 08             	pushl  0x8(%ebp)
f010586f:	e8 7e 76 00 00       	call   f010cef2 <cleanup_buffers>
f0105874:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0105877:	8b 45 08             	mov    0x8(%ebp),%eax
f010587a:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105881:	83 ec 08             	sub    $0x8,%esp
f0105884:	ff 75 08             	pushl  0x8(%ebp)
f0105887:	68 00 f1 71 f0       	push   $0xf071f100
f010588c:	e8 07 f9 ff ff       	call   f0105198 <enqueue>
f0105891:	83 c4 10             	add    $0x10,%esp
	}
}
f0105894:	90                   	nop
f0105895:	c9                   	leave  
f0105896:	c3                   	ret    

f0105897 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0105897:	55                   	push   %ebp
f0105898:	89 e5                	mov    %esp,%ebp
f010589a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010589d:	83 ec 0c             	sub    $0xc,%esp
f01058a0:	68 80 f0 71 f0       	push   $0xf071f080
f01058a5:	e8 6d a8 00 00       	call   f0110117 <holding_spinlock>
f01058aa:	83 c4 10             	add    $0x10,%esp
f01058ad:	85 c0                	test   %eax,%eax
f01058af:	75 17                	jne    f01058c8 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01058b1:	83 ec 04             	sub    $0x4,%esp
f01058b4:	68 a0 56 12 f0       	push   $0xf01256a0
f01058b9:	68 f5 00 00 00       	push   $0xf5
f01058be:	68 43 56 12 f0       	push   $0xf0125643
f01058c3:	e8 71 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01058c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058cc:	74 0b                	je     f01058d9 <sched_remove_exit+0x42>
f01058ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01058d1:	8b 40 18             	mov    0x18(%eax),%eax
f01058d4:	83 f8 05             	cmp    $0x5,%eax
f01058d7:	74 19                	je     f01058f2 <sched_remove_exit+0x5b>
f01058d9:	68 48 57 12 f0       	push   $0xf0125748
f01058de:	68 2e 56 12 f0       	push   $0xf012562e
f01058e3:	68 f8 00 00 00       	push   $0xf8
f01058e8:	68 43 56 12 f0       	push   $0xf0125643
f01058ed:	e8 47 aa ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01058f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058f6:	75 17                	jne    f010590f <sched_remove_exit+0x78>
f01058f8:	83 ec 04             	sub    $0x4,%esp
f01058fb:	68 7f 56 12 f0       	push   $0xf012567f
f0105900:	68 fa 00 00 00       	push   $0xfa
f0105905:	68 43 56 12 f0       	push   $0xf0125643
f010590a:	e8 2a aa ff ff       	call   f0100339 <_panic>
f010590f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105912:	8b 40 08             	mov    0x8(%eax),%eax
f0105915:	85 c0                	test   %eax,%eax
f0105917:	74 11                	je     f010592a <sched_remove_exit+0x93>
f0105919:	8b 45 08             	mov    0x8(%ebp),%eax
f010591c:	8b 40 08             	mov    0x8(%eax),%eax
f010591f:	8b 55 08             	mov    0x8(%ebp),%edx
f0105922:	8b 52 0c             	mov    0xc(%edx),%edx
f0105925:	89 50 0c             	mov    %edx,0xc(%eax)
f0105928:	eb 0b                	jmp    f0105935 <sched_remove_exit+0x9e>
f010592a:	8b 45 08             	mov    0x8(%ebp),%eax
f010592d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105930:	a3 04 f1 71 f0       	mov    %eax,0xf071f104
f0105935:	8b 45 08             	mov    0x8(%ebp),%eax
f0105938:	8b 40 0c             	mov    0xc(%eax),%eax
f010593b:	85 c0                	test   %eax,%eax
f010593d:	74 11                	je     f0105950 <sched_remove_exit+0xb9>
f010593f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105942:	8b 40 0c             	mov    0xc(%eax),%eax
f0105945:	8b 55 08             	mov    0x8(%ebp),%edx
f0105948:	8b 52 08             	mov    0x8(%edx),%edx
f010594b:	89 50 08             	mov    %edx,0x8(%eax)
f010594e:	eb 0b                	jmp    f010595b <sched_remove_exit+0xc4>
f0105950:	8b 45 08             	mov    0x8(%ebp),%eax
f0105953:	8b 40 08             	mov    0x8(%eax),%eax
f0105956:	a3 00 f1 71 f0       	mov    %eax,0xf071f100
f010595b:	8b 45 08             	mov    0x8(%ebp),%eax
f010595e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105965:	8b 45 08             	mov    0x8(%ebp),%eax
f0105968:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010596f:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f0105974:	48                   	dec    %eax
f0105975:	a3 0c f1 71 f0       	mov    %eax,0xf071f10c
		env->env_status = ENV_UNKNOWN;
f010597a:	8b 45 08             	mov    0x8(%ebp),%eax
f010597d:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105984:	90                   	nop
f0105985:	c9                   	leave  
f0105986:	c3                   	ret    

f0105987 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0105987:	55                   	push   %ebp
f0105988:	89 e5                	mov    %esp,%ebp
f010598a:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010598d:	83 ec 0c             	sub    $0xc,%esp
f0105990:	68 80 f0 71 f0       	push   $0xf071f080
f0105995:	e8 64 a5 00 00       	call   f010fefe <acquire_spinlock>
f010599a:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010599d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01059a1:	75 19                	jne    f01059bc <sched_new_env+0x35>
f01059a3:	68 73 57 12 f0       	push   $0xf0125773
f01059a8:	68 2e 56 12 f0       	push   $0xf012562e
f01059ad:	68 08 01 00 00       	push   $0x108
f01059b2:	68 43 56 12 f0       	push   $0xf0125643
f01059b7:	e8 7d a9 ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01059bc:	83 ec 0c             	sub    $0xc,%esp
f01059bf:	ff 75 08             	pushl  0x8(%ebp)
f01059c2:	e8 e9 fc ff ff       	call   f01056b0 <sched_insert_new>
f01059c7:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059ca:	83 ec 0c             	sub    $0xc,%esp
f01059cd:	68 80 f0 71 f0       	push   $0xf071f080
f01059d2:	e8 ae a5 00 00       	call   f010ff85 <release_spinlock>
f01059d7:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01059da:	90                   	nop
f01059db:	c9                   	leave  
f01059dc:	c3                   	ret    

f01059dd <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01059dd:	55                   	push   %ebp
f01059de:	89 e5                	mov    %esp,%ebp
f01059e0:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059e3:	83 ec 0c             	sub    $0xc,%esp
f01059e6:	68 80 f0 71 f0       	push   $0xf071f080
f01059eb:	e8 0e a5 00 00       	call   f010fefe <acquire_spinlock>
f01059f0:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01059f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01059fa:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01059ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a02:	eb 53                	jmp    f0105a57 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a07:	8b 40 10             	mov    0x10(%eax),%eax
f0105a0a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a0d:	75 40                	jne    f0105a4f <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105a0f:	83 ec 0c             	sub    $0xc,%esp
f0105a12:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a15:	e8 06 fd ff ff       	call   f0105720 <sched_remove_new>
f0105a1a:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f0105a1d:	83 ec 0c             	sub    $0xc,%esp
f0105a20:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a23:	e8 ad fa ff ff       	call   f01054d5 <sched_insert_ready>
f0105a28:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105a2b:	e8 07 1a 00 00       	call   f0107437 <mycpu>
f0105a30:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105a36:	85 c0                	test   %eax,%eax
f0105a38:	75 46                	jne    f0105a80 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a3a:	83 ec 0c             	sub    $0xc,%esp
f0105a3d:	68 80 f0 71 f0       	push   $0xf071f080
f0105a42:	e8 3e a5 00 00       	call   f010ff85 <release_spinlock>
f0105a47:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105a4a:	e8 f6 0f 00 00       	call   f0106a45 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a4f:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a5b:	74 08                	je     f0105a65 <sched_run_env+0x88>
f0105a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a60:	8b 40 08             	mov    0x8(%eax),%eax
f0105a63:	eb 05                	jmp    f0105a6a <sched_run_env+0x8d>
f0105a65:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a6a:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105a6f:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105a74:	85 c0                	test   %eax,%eax
f0105a76:	75 8c                	jne    f0105a04 <sched_run_env+0x27>
f0105a78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a7c:	75 86                	jne    f0105a04 <sched_run_env+0x27>
f0105a7e:	eb 01                	jmp    f0105a81 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105a80:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	68 80 f0 71 f0       	push   $0xf071f080
f0105a89:	e8 f7 a4 00 00       	call   f010ff85 <release_spinlock>
f0105a8e:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105a91:	90                   	nop
f0105a92:	c9                   	leave  
f0105a93:	c3                   	ret    

f0105a94 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105a94:	55                   	push   %ebp
f0105a95:	89 e5                	mov    %esp,%ebp
f0105a97:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f0105a9a:	83 ec 0c             	sub    $0xc,%esp
f0105a9d:	68 80 f0 71 f0       	push   $0xf071f080
f0105aa2:	e8 70 a6 00 00       	call   f0110117 <holding_spinlock>
f0105aa7:	83 c4 10             	add    $0x10,%esp
f0105aaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105aad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105ab1:	75 10                	jne    f0105ac3 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105ab3:	83 ec 0c             	sub    $0xc,%esp
f0105ab6:	68 80 f0 71 f0       	push   $0xf071f080
f0105abb:	e8 3e a4 00 00       	call   f010fefe <acquire_spinlock>
f0105ac0:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105ac3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105aca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105ad1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ad5:	75 59                	jne    f0105b30 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ad7:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0105adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105adf:	eb 28                	jmp    f0105b09 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ae4:	8b 40 10             	mov    0x10(%eax),%eax
f0105ae7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aea:	75 15                	jne    f0105b01 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105aec:	83 ec 0c             	sub    $0xc,%esp
f0105aef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105af2:	e8 29 fc ff ff       	call   f0105720 <sched_remove_new>
f0105af7:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105afa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b01:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105b06:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b0d:	74 08                	je     f0105b17 <sched_exit_env+0x83>
f0105b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b12:	8b 40 08             	mov    0x8(%eax),%eax
f0105b15:	eb 05                	jmp    f0105b1c <sched_exit_env+0x88>
f0105b17:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b1c:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105b21:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105b26:	85 c0                	test   %eax,%eax
f0105b28:	75 b7                	jne    f0105ae1 <sched_exit_env+0x4d>
f0105b2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b2e:	75 b1                	jne    f0105ae1 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105b30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b34:	0f 85 67 01 00 00    	jne    f0105ca1 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b41:	e9 47 01 00 00       	jmp    f0105c8d <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b46:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105b4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b4e:	c1 e2 04             	shl    $0x4,%edx
f0105b51:	01 d0                	add    %edx,%eax
f0105b53:	8b 00                	mov    (%eax),%eax
f0105b55:	85 c0                	test   %eax,%eax
f0105b57:	0f 84 27 01 00 00    	je     f0105c84 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105b5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b64:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105b69:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b6c:	c1 e2 04             	shl    $0x4,%edx
f0105b6f:	01 d0                	add    %edx,%eax
f0105b71:	8b 00                	mov    (%eax),%eax
f0105b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b76:	e9 d1 00 00 00       	jmp    f0105c4c <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7e:	8b 40 10             	mov    0x10(%eax),%eax
f0105b81:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b84:	0f 85 af 00 00 00    	jne    f0105c39 <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b8e:	75 17                	jne    f0105ba7 <sched_exit_env+0x113>
f0105b90:	83 ec 04             	sub    $0x4,%esp
f0105b93:	68 7f 56 12 f0       	push   $0xf012567f
f0105b98:	68 56 01 00 00       	push   $0x156
f0105b9d:	68 43 56 12 f0       	push   $0xf0125643
f0105ba2:	e8 92 a7 ff ff       	call   f0100339 <_panic>
f0105ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105baa:	8b 40 08             	mov    0x8(%eax),%eax
f0105bad:	85 c0                	test   %eax,%eax
f0105baf:	74 11                	je     f0105bc2 <sched_exit_env+0x12e>
f0105bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb4:	8b 40 08             	mov    0x8(%eax),%eax
f0105bb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bba:	8b 52 0c             	mov    0xc(%edx),%edx
f0105bbd:	89 50 0c             	mov    %edx,0xc(%eax)
f0105bc0:	eb 16                	jmp    f0105bd8 <sched_exit_env+0x144>
f0105bc2:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105bc7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bca:	c1 e2 04             	shl    $0x4,%edx
f0105bcd:	01 c2                	add    %eax,%edx
f0105bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bd5:	89 42 04             	mov    %eax,0x4(%edx)
f0105bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bdb:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bde:	85 c0                	test   %eax,%eax
f0105be0:	74 11                	je     f0105bf3 <sched_exit_env+0x15f>
f0105be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105be5:	8b 40 0c             	mov    0xc(%eax),%eax
f0105be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105beb:	8b 52 08             	mov    0x8(%edx),%edx
f0105bee:	89 50 08             	mov    %edx,0x8(%eax)
f0105bf1:	eb 15                	jmp    f0105c08 <sched_exit_env+0x174>
f0105bf3:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105bf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bfb:	c1 e2 04             	shl    $0x4,%edx
f0105bfe:	01 c2                	add    %eax,%edx
f0105c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c03:	8b 40 08             	mov    0x8(%eax),%eax
f0105c06:	89 02                	mov    %eax,(%edx)
f0105c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c0b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c15:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c1c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c21:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c24:	c1 e2 04             	shl    $0x4,%edx
f0105c27:	01 d0                	add    %edx,%eax
f0105c29:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c2c:	4a                   	dec    %edx
f0105c2d:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c30:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c37:	eb 4b                	jmp    f0105c84 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c39:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c3e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c41:	c1 e2 04             	shl    $0x4,%edx
f0105c44:	01 d0                	add    %edx,%eax
f0105c46:	8b 40 08             	mov    0x8(%eax),%eax
f0105c49:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c4c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c51:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c54:	c1 e2 04             	shl    $0x4,%edx
f0105c57:	01 d0                	add    %edx,%eax
f0105c59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c5d:	74 08                	je     f0105c67 <sched_exit_env+0x1d3>
f0105c5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c62:	8b 52 08             	mov    0x8(%edx),%edx
f0105c65:	eb 05                	jmp    f0105c6c <sched_exit_env+0x1d8>
f0105c67:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c6c:	89 50 08             	mov    %edx,0x8(%eax)
f0105c6f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c72:	85 c0                	test   %eax,%eax
f0105c74:	0f 85 01 ff ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
f0105c7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c7e:	0f 85 f7 fe ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105c84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c88:	75 16                	jne    f0105ca0 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c8a:	ff 45 ec             	incl   -0x14(%ebp)
f0105c8d:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f0105c92:	0f b6 c0             	movzbl %al,%eax
f0105c95:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c98:	0f 8f a8 fe ff ff    	jg     f0105b46 <sched_exit_env+0xb2>
f0105c9e:	eb 01                	jmp    f0105ca1 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105ca0:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105ca1:	e8 ca 5f 00 00       	call   f010bc70 <get_cpu_proc>
f0105ca6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105ca9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105cad:	75 19                	jne    f0105cc8 <sched_exit_env+0x234>
f0105caf:	68 7b 57 12 f0       	push   $0xf012577b
f0105cb4:	68 2e 56 12 f0       	push   $0xf012562e
f0105cb9:	68 60 01 00 00       	push   $0x160
f0105cbe:	68 43 56 12 f0       	push   $0xf0125643
f0105cc3:	e8 71 a6 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105cc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ccc:	75 18                	jne    f0105ce6 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105cce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cd1:	8b 40 10             	mov    0x10(%eax),%eax
f0105cd4:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cd7:	75 0d                	jne    f0105ce6 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105cd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105cdf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105ce6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cea:	74 1e                	je     f0105d0a <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105cec:	83 ec 0c             	sub    $0xc,%esp
f0105cef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cf2:	e8 19 fb ff ff       	call   f0105810 <sched_insert_exit>
f0105cf7:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105cfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cfd:	8b 40 10             	mov    0x10(%eax),%eax
f0105d00:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d03:	75 05                	jne    f0105d0a <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105d05:	e8 e7 60 00 00       	call   f010bdf1 <sched>
		}
	}
	if (!lock_already_held)
f0105d0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d0e:	75 10                	jne    f0105d20 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105d10:	83 ec 0c             	sub    $0xc,%esp
f0105d13:	68 80 f0 71 f0       	push   $0xf071f080
f0105d18:	e8 68 a2 00 00       	call   f010ff85 <release_spinlock>
f0105d1d:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105d20:	90                   	nop
f0105d21:	c9                   	leave  
f0105d22:	c3                   	ret    

f0105d23 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105d23:	55                   	push   %ebp
f0105d24:	89 e5                	mov    %esp,%ebp
f0105d26:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d29:	83 ec 0c             	sub    $0xc,%esp
f0105d2c:	68 80 f0 71 f0       	push   $0xf071f080
f0105d31:	e8 c8 a1 00 00       	call   f010fefe <acquire_spinlock>
f0105d36:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105d40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105d47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d4b:	75 79                	jne    f0105dc6 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d4d:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0105d52:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d55:	eb 48                	jmp    f0105d9f <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d5a:	8b 40 10             	mov    0x10(%eax),%eax
f0105d5d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d60:	75 35                	jne    f0105d97 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d65:	8d 50 20             	lea    0x20(%eax),%edx
f0105d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d6b:	8b 40 10             	mov    0x10(%eax),%eax
f0105d6e:	83 ec 04             	sub    $0x4,%esp
f0105d71:	52                   	push   %edx
f0105d72:	50                   	push   %eax
f0105d73:	68 8c 57 12 f0       	push   $0xf012578c
f0105d78:	e8 0e b2 ff ff       	call   f0100f8b <cprintf>
f0105d7d:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105d80:	83 ec 0c             	sub    $0xc,%esp
f0105d83:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d86:	e8 95 f9 ff ff       	call   f0105720 <sched_remove_new>
f0105d8b:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d8e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d95:	eb 2f                	jmp    f0105dc6 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d97:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105d9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105da3:	74 08                	je     f0105dad <sched_kill_env+0x8a>
f0105da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105da8:	8b 40 08             	mov    0x8(%eax),%eax
f0105dab:	eb 05                	jmp    f0105db2 <sched_kill_env+0x8f>
f0105dad:	b8 00 00 00 00       	mov    $0x0,%eax
f0105db2:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105db7:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105dbc:	85 c0                	test   %eax,%eax
f0105dbe:	75 97                	jne    f0105d57 <sched_kill_env+0x34>
f0105dc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105dc4:	75 91                	jne    f0105d57 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105dc6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105dca:	0f 85 85 01 00 00    	jne    f0105f55 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105dd0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105dd7:	e9 65 01 00 00       	jmp    f0105f41 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ddc:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105de1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105de4:	c1 e2 04             	shl    $0x4,%edx
f0105de7:	01 d0                	add    %edx,%eax
f0105de9:	8b 00                	mov    (%eax),%eax
f0105deb:	85 c0                	test   %eax,%eax
f0105ded:	0f 84 45 01 00 00    	je     f0105f38 <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105df3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105dfa:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105dff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e02:	c1 e2 04             	shl    $0x4,%edx
f0105e05:	01 d0                	add    %edx,%eax
f0105e07:	8b 00                	mov    (%eax),%eax
f0105e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e0c:	e9 ef 00 00 00       	jmp    f0105f00 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e14:	8b 40 10             	mov    0x10(%eax),%eax
f0105e17:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105e1a:	0f 85 cd 00 00 00    	jne    f0105eed <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e23:	8d 50 20             	lea    0x20(%eax),%edx
f0105e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e29:	8b 40 10             	mov    0x10(%eax),%eax
f0105e2c:	ff 75 ec             	pushl  -0x14(%ebp)
f0105e2f:	52                   	push   %edx
f0105e30:	50                   	push   %eax
f0105e31:	68 b4 57 12 f0       	push   $0xf01257b4
f0105e36:	e8 50 b1 ff ff       	call   f0100f8b <cprintf>
f0105e3b:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105e3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e42:	75 17                	jne    f0105e5b <sched_kill_env+0x138>
f0105e44:	83 ec 04             	sub    $0x4,%esp
f0105e47:	68 7f 56 12 f0       	push   $0xf012567f
f0105e4c:	68 a3 01 00 00       	push   $0x1a3
f0105e51:	68 43 56 12 f0       	push   $0xf0125643
f0105e56:	e8 de a4 ff ff       	call   f0100339 <_panic>
f0105e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5e:	8b 40 08             	mov    0x8(%eax),%eax
f0105e61:	85 c0                	test   %eax,%eax
f0105e63:	74 11                	je     f0105e76 <sched_kill_env+0x153>
f0105e65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e68:	8b 40 08             	mov    0x8(%eax),%eax
f0105e6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e6e:	8b 52 0c             	mov    0xc(%edx),%edx
f0105e71:	89 50 0c             	mov    %edx,0xc(%eax)
f0105e74:	eb 16                	jmp    f0105e8c <sched_kill_env+0x169>
f0105e76:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105e7b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e7e:	c1 e2 04             	shl    $0x4,%edx
f0105e81:	01 c2                	add    %eax,%edx
f0105e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e86:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e89:	89 42 04             	mov    %eax,0x4(%edx)
f0105e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e8f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e92:	85 c0                	test   %eax,%eax
f0105e94:	74 11                	je     f0105ea7 <sched_kill_env+0x184>
f0105e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e99:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e9f:	8b 52 08             	mov    0x8(%edx),%edx
f0105ea2:	89 50 08             	mov    %edx,0x8(%eax)
f0105ea5:	eb 15                	jmp    f0105ebc <sched_kill_env+0x199>
f0105ea7:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105eac:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105eaf:	c1 e2 04             	shl    $0x4,%edx
f0105eb2:	01 c2                	add    %eax,%edx
f0105eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eb7:	8b 40 08             	mov    0x8(%eax),%eax
f0105eba:	89 02                	mov    %eax,(%edx)
f0105ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ec9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105ed0:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105ed5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ed8:	c1 e2 04             	shl    $0x4,%edx
f0105edb:	01 d0                	add    %edx,%eax
f0105edd:	8b 50 0c             	mov    0xc(%eax),%edx
f0105ee0:	4a                   	dec    %edx
f0105ee1:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105ee4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105eeb:	eb 4b                	jmp    f0105f38 <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105eed:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105ef2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ef5:	c1 e2 04             	shl    $0x4,%edx
f0105ef8:	01 d0                	add    %edx,%eax
f0105efa:	8b 40 08             	mov    0x8(%eax),%eax
f0105efd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f00:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105f05:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105f08:	c1 e2 04             	shl    $0x4,%edx
f0105f0b:	01 d0                	add    %edx,%eax
f0105f0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f11:	74 08                	je     f0105f1b <sched_kill_env+0x1f8>
f0105f13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f16:	8b 52 08             	mov    0x8(%edx),%edx
f0105f19:	eb 05                	jmp    f0105f20 <sched_kill_env+0x1fd>
f0105f1b:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f20:	89 50 08             	mov    %edx,0x8(%eax)
f0105f23:	8b 40 08             	mov    0x8(%eax),%eax
f0105f26:	85 c0                	test   %eax,%eax
f0105f28:	0f 85 e3 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
f0105f2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f32:	0f 85 d9 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105f38:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f3c:	75 16                	jne    f0105f54 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f3e:	ff 45 ec             	incl   -0x14(%ebp)
f0105f41:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f0105f46:	0f b6 c0             	movzbl %al,%eax
f0105f49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105f4c:	0f 8f 8a fe ff ff    	jg     f0105ddc <sched_kill_env+0xb9>
f0105f52:	eb 01                	jmp    f0105f55 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105f54:	90                   	nop
		}
	}
	if (!found)
f0105f55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f59:	0f 85 80 00 00 00    	jne    f0105fdf <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105f5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f66:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0105f6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f6e:	eb 48                	jmp    f0105fb8 <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105f70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f73:	8b 40 10             	mov    0x10(%eax),%eax
f0105f76:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105f79:	75 35                	jne    f0105fb0 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105f7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f7e:	8d 50 20             	lea    0x20(%eax),%edx
f0105f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f84:	8b 40 10             	mov    0x10(%eax),%eax
f0105f87:	83 ec 04             	sub    $0x4,%esp
f0105f8a:	52                   	push   %edx
f0105f8b:	50                   	push   %eax
f0105f8c:	68 e0 57 12 f0       	push   $0xf01257e0
f0105f91:	e8 f5 af ff ff       	call   f0100f8b <cprintf>
f0105f96:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105f99:	83 ec 0c             	sub    $0xc,%esp
f0105f9c:	ff 75 f4             	pushl  -0xc(%ebp)
f0105f9f:	e8 f3 f8 ff ff       	call   f0105897 <sched_remove_exit>
f0105fa4:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105fa7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105fae:	eb 2f                	jmp    f0105fdf <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fb0:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0105fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fbc:	74 08                	je     f0105fc6 <sched_kill_env+0x2a3>
f0105fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fc1:	8b 40 08             	mov    0x8(%eax),%eax
f0105fc4:	eb 05                	jmp    f0105fcb <sched_kill_env+0x2a8>
f0105fc6:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fcb:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f0105fd0:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0105fd5:	85 c0                	test   %eax,%eax
f0105fd7:	75 97                	jne    f0105f70 <sched_kill_env+0x24d>
f0105fd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fdd:	75 91                	jne    f0105f70 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105fdf:	83 ec 0c             	sub    $0xc,%esp
f0105fe2:	68 80 f0 71 f0       	push   $0xf071f080
f0105fe7:	e8 99 9f 00 00       	call   f010ff85 <release_spinlock>
f0105fec:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105fef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ff3:	74 23                	je     f0106018 <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105ff5:	83 ec 0c             	sub    $0xc,%esp
f0105ff8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ffb:	e8 28 5c 00 00       	call   f010bc28 <env_free>
f0106000:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106003:	83 ec 0c             	sub    $0xc,%esp
f0106006:	68 06 58 12 f0       	push   $0xf0125806
f010600b:	e8 7b af ff ff       	call   f0100f8b <cprintf>
f0106010:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0106013:	e9 a4 00 00 00       	jmp    f01060bc <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106018:	e8 53 5c 00 00       	call   f010bc70 <get_cpu_proc>
f010601d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106020:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106024:	75 19                	jne    f010603f <sched_kill_env+0x31c>
f0106026:	68 7b 57 12 f0       	push   $0xf012577b
f010602b:	68 2e 56 12 f0       	push   $0xf012562e
f0106030:	68 c5 01 00 00       	push   $0x1c5
f0106035:	68 43 56 12 f0       	push   $0xf0125643
f010603a:	e8 fa a2 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f010603f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106042:	8b 40 10             	mov    0x10(%eax),%eax
f0106045:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106048:	75 72                	jne    f01060bc <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f010604a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010604d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106053:	8b 40 18             	mov    0x18(%eax),%eax
f0106056:	83 f8 02             	cmp    $0x2,%eax
f0106059:	74 19                	je     f0106074 <sched_kill_env+0x351>
f010605b:	68 0c 58 12 f0       	push   $0xf012580c
f0106060:	68 2e 56 12 f0       	push   $0xf012562e
f0106065:	68 ca 01 00 00       	push   $0x1ca
f010606a:	68 43 56 12 f0       	push   $0xf0125643
f010606f:	e8 c5 a2 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106074:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106077:	8d 50 20             	lea    0x20(%eax),%edx
f010607a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010607d:	8b 40 10             	mov    0x10(%eax),%eax
f0106080:	83 ec 04             	sub    $0x4,%esp
f0106083:	52                   	push   %edx
f0106084:	50                   	push   %eax
f0106085:	68 30 58 12 f0       	push   $0xf0125830
f010608a:	e8 fc ae ff ff       	call   f0100f8b <cprintf>
f010608f:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106092:	83 ec 0c             	sub    $0xc,%esp
f0106095:	ff 75 f4             	pushl  -0xc(%ebp)
f0106098:	e8 8b 5b 00 00       	call   f010bc28 <env_free>
f010609d:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01060a0:	83 ec 0c             	sub    $0xc,%esp
f01060a3:	68 06 58 12 f0       	push   $0xf0125806
f01060a8:	e8 de ae ff ff       	call   f0100f8b <cprintf>
f01060ad:	83 c4 10             	add    $0x10,%esp
			found = 1;
f01060b0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f01060b7:	e8 35 5d 00 00       	call   f010bdf1 <sched>
		}
	}

}
f01060bc:	90                   	nop
f01060bd:	c9                   	leave  
f01060be:	c3                   	ret    

f01060bf <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f01060bf:	55                   	push   %ebp
f01060c0:	89 e5                	mov    %esp,%ebp
f01060c2:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060c5:	83 ec 0c             	sub    $0xc,%esp
f01060c8:	68 80 f0 71 f0       	push   $0xf071f080
f01060cd:	e8 2c 9e 00 00       	call   f010fefe <acquire_spinlock>
f01060d2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060d5:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01060da:	85 c0                	test   %eax,%eax
f01060dc:	74 69                	je     f0106147 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f01060de:	83 ec 0c             	sub    $0xc,%esp
f01060e1:	68 5c 58 12 f0       	push   $0xf012585c
f01060e6:	e8 a0 ae ff ff       	call   f0100f8b <cprintf>
f01060eb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060ee:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01060f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060f6:	eb 26                	jmp    f010611e <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01060f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060fb:	8d 50 20             	lea    0x20(%eax),%edx
f01060fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106101:	8b 40 10             	mov    0x10(%eax),%eax
f0106104:	83 ec 04             	sub    $0x4,%esp
f0106107:	52                   	push   %edx
f0106108:	50                   	push   %eax
f0106109:	68 7e 58 12 f0       	push   $0xf012587e
f010610e:	e8 78 ae ff ff       	call   f0100f8b <cprintf>
f0106113:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106116:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f010611b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010611e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106122:	74 08                	je     f010612c <sched_print_all+0x6d>
f0106124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106127:	8b 40 08             	mov    0x8(%eax),%eax
f010612a:	eb 05                	jmp    f0106131 <sched_print_all+0x72>
f010612c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106131:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0106136:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f010613b:	85 c0                	test   %eax,%eax
f010613d:	75 b9                	jne    f01060f8 <sched_print_all+0x39>
f010613f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106143:	75 b3                	jne    f01060f8 <sched_print_all+0x39>
f0106145:	eb 10                	jmp    f0106157 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106147:	83 ec 0c             	sub    $0xc,%esp
f010614a:	68 88 58 12 f0       	push   $0xf0125888
f010614f:	e8 37 ae ff ff       	call   f0100f8b <cprintf>
f0106154:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106157:	83 ec 0c             	sub    $0xc,%esp
f010615a:	68 a4 58 12 f0       	push   $0xf01258a4
f010615f:	e8 27 ae ff ff       	call   f0100f8b <cprintf>
f0106164:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106167:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010616e:	e9 c7 00 00 00       	jmp    f010623a <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106173:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106178:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010617b:	c1 e2 04             	shl    $0x4,%edx
f010617e:	01 d0                	add    %edx,%eax
f0106180:	8b 00                	mov    (%eax),%eax
f0106182:	85 c0                	test   %eax,%eax
f0106184:	0f 84 8a 00 00 00    	je     f0106214 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f010618a:	83 ec 08             	sub    $0x8,%esp
f010618d:	ff 75 f0             	pushl  -0x10(%ebp)
f0106190:	68 d8 58 12 f0       	push   $0xf01258d8
f0106195:	e8 f1 ad ff ff       	call   f0100f8b <cprintf>
f010619a:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010619d:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061a5:	c1 e2 04             	shl    $0x4,%edx
f01061a8:	01 d0                	add    %edx,%eax
f01061aa:	8b 00                	mov    (%eax),%eax
f01061ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061af:	eb 31                	jmp    f01061e2 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01061b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061b4:	8d 50 20             	lea    0x20(%eax),%edx
f01061b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061ba:	8b 40 10             	mov    0x10(%eax),%eax
f01061bd:	83 ec 04             	sub    $0x4,%esp
f01061c0:	52                   	push   %edx
f01061c1:	50                   	push   %eax
f01061c2:	68 7e 58 12 f0       	push   $0xf012587e
f01061c7:	e8 bf ad ff ff       	call   f0100f8b <cprintf>
f01061cc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061cf:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061d7:	c1 e2 04             	shl    $0x4,%edx
f01061da:	01 d0                	add    %edx,%eax
f01061dc:	8b 40 08             	mov    0x8(%eax),%eax
f01061df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061e2:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061ea:	c1 e2 04             	shl    $0x4,%edx
f01061ed:	01 d0                	add    %edx,%eax
f01061ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061f3:	74 08                	je     f01061fd <sched_print_all+0x13e>
f01061f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01061f8:	8b 52 08             	mov    0x8(%edx),%edx
f01061fb:	eb 05                	jmp    f0106202 <sched_print_all+0x143>
f01061fd:	ba 00 00 00 00       	mov    $0x0,%edx
f0106202:	89 50 08             	mov    %edx,0x8(%eax)
f0106205:	8b 40 08             	mov    0x8(%eax),%eax
f0106208:	85 c0                	test   %eax,%eax
f010620a:	75 a5                	jne    f01061b1 <sched_print_all+0xf2>
f010620c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106210:	75 9f                	jne    f01061b1 <sched_print_all+0xf2>
f0106212:	eb 13                	jmp    f0106227 <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106214:	83 ec 08             	sub    $0x8,%esp
f0106217:	ff 75 f0             	pushl  -0x10(%ebp)
f010621a:	68 00 59 12 f0       	push   $0xf0125900
f010621f:	e8 67 ad ff ff       	call   f0100f8b <cprintf>
f0106224:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106227:	83 ec 0c             	sub    $0xc,%esp
f010622a:	68 a4 58 12 f0       	push   $0xf01258a4
f010622f:	e8 57 ad ff ff       	call   f0100f8b <cprintf>
f0106234:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106237:	ff 45 f0             	incl   -0x10(%ebp)
f010623a:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f010623f:	0f b6 c0             	movzbl %al,%eax
f0106242:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106245:	0f 8f 28 ff ff ff    	jg     f0106173 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f010624b:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106250:	85 c0                	test   %eax,%eax
f0106252:	74 69                	je     f01062bd <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106254:	83 ec 0c             	sub    $0xc,%esp
f0106257:	68 24 59 12 f0       	push   $0xf0125924
f010625c:	e8 2a ad ff ff       	call   f0100f8b <cprintf>
f0106261:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106264:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106269:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010626c:	eb 26                	jmp    f0106294 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010626e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106271:	8d 50 20             	lea    0x20(%eax),%edx
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 10             	mov    0x10(%eax),%eax
f010627a:	83 ec 04             	sub    $0x4,%esp
f010627d:	52                   	push   %edx
f010627e:	50                   	push   %eax
f010627f:	68 7e 58 12 f0       	push   $0xf012587e
f0106284:	e8 02 ad ff ff       	call   f0100f8b <cprintf>
f0106289:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010628c:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106291:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106294:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106298:	74 08                	je     f01062a2 <sched_print_all+0x1e3>
f010629a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629d:	8b 40 08             	mov    0x8(%eax),%eax
f01062a0:	eb 05                	jmp    f01062a7 <sched_print_all+0x1e8>
f01062a2:	b8 00 00 00 00       	mov    $0x0,%eax
f01062a7:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f01062ac:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f01062b1:	85 c0                	test   %eax,%eax
f01062b3:	75 b9                	jne    f010626e <sched_print_all+0x1af>
f01062b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062b9:	75 b3                	jne    f010626e <sched_print_all+0x1af>
f01062bb:	eb 10                	jmp    f01062cd <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01062bd:	83 ec 0c             	sub    $0xc,%esp
f01062c0:	68 46 59 12 f0       	push   $0xf0125946
f01062c5:	e8 c1 ac ff ff       	call   f0100f8b <cprintf>
f01062ca:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062cd:	83 ec 0c             	sub    $0xc,%esp
f01062d0:	68 80 f0 71 f0       	push   $0xf071f080
f01062d5:	e8 ab 9c 00 00       	call   f010ff85 <release_spinlock>
f01062da:	83 c4 10             	add    $0x10,%esp
}
f01062dd:	90                   	nop
f01062de:	c9                   	leave  
f01062df:	c3                   	ret    

f01062e0 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f01062e0:	55                   	push   %ebp
f01062e1:	89 e5                	mov    %esp,%ebp
f01062e3:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062e6:	83 ec 0c             	sub    $0xc,%esp
f01062e9:	68 80 f0 71 f0       	push   $0xf071f080
f01062ee:	e8 0b 9c 00 00       	call   f010fefe <acquire_spinlock>
f01062f3:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01062f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f01062fd:	a1 fc f0 71 f0       	mov    0xf071f0fc,%eax
f0106302:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106305:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010630c:	eb 24                	jmp    f0106332 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f010630e:	83 ec 0c             	sub    $0xc,%esp
f0106311:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0106316:	e8 0e ef ff ff       	call   f0105229 <dequeue>
f010631b:	83 c4 10             	add    $0x10,%esp
f010631e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0106321:	83 ec 0c             	sub    $0xc,%esp
f0106324:	ff 75 f0             	pushl  -0x10(%ebp)
f0106327:	e8 a9 f1 ff ff       	call   f01054d5 <sched_insert_ready>
f010632c:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f010632f:	ff 45 f4             	incl   -0xc(%ebp)
f0106332:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106335:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106338:	7c d4                	jl     f010630e <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010633a:	83 ec 0c             	sub    $0xc,%esp
f010633d:	68 80 f0 71 f0       	push   $0xf071f080
f0106342:	e8 3e 9c 00 00       	call   f010ff85 <release_spinlock>
f0106347:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010634a:	e8 e8 10 00 00       	call   f0107437 <mycpu>
f010634f:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106355:	85 c0                	test   %eax,%eax
f0106357:	75 05                	jne    f010635e <sched_run_all+0x7e>
		fos_scheduler();
f0106359:	e8 e7 06 00 00       	call   f0106a45 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f010635e:	83 ec 04             	sub    $0x4,%esp
f0106361:	68 64 59 12 f0       	push   $0xf0125964
f0106366:	68 27 02 00 00       	push   $0x227
f010636b:	68 43 56 12 f0       	push   $0xf0125643
f0106370:	e8 c4 9f ff ff       	call   f0100339 <_panic>

f0106375 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0106375:	55                   	push   %ebp
f0106376:	89 e5                	mov    %esp,%ebp
f0106378:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010637b:	83 ec 0c             	sub    $0xc,%esp
f010637e:	68 80 f0 71 f0       	push   $0xf071f080
f0106383:	e8 76 9b 00 00       	call   f010fefe <acquire_spinlock>
f0106388:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f010638b:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0106390:	85 c0                	test   %eax,%eax
f0106392:	0f 84 95 00 00 00    	je     f010642d <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f0106398:	83 ec 0c             	sub    $0xc,%esp
f010639b:	68 a0 59 12 f0       	push   $0xf01259a0
f01063a0:	e8 e6 ab ff ff       	call   f0100f8b <cprintf>
f01063a5:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063a8:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01063ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063b0:	eb 52                	jmp    f0106404 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063b5:	8d 50 20             	lea    0x20(%eax),%edx
f01063b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bb:	8b 40 10             	mov    0x10(%eax),%eax
f01063be:	83 ec 04             	sub    $0x4,%esp
f01063c1:	52                   	push   %edx
f01063c2:	50                   	push   %eax
f01063c3:	68 cc 59 12 f0       	push   $0xf01259cc
f01063c8:	e8 be ab ff ff       	call   f0100f8b <cprintf>
f01063cd:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01063d0:	83 ec 0c             	sub    $0xc,%esp
f01063d3:	ff 75 f4             	pushl  -0xc(%ebp)
f01063d6:	e8 45 f3 ff ff       	call   f0105720 <sched_remove_new>
f01063db:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063de:	83 ec 0c             	sub    $0xc,%esp
f01063e1:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e4:	e8 3f 58 00 00       	call   f010bc28 <env_free>
f01063e9:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063ec:	83 ec 0c             	sub    $0xc,%esp
f01063ef:	68 06 58 12 f0       	push   $0xf0125806
f01063f4:	e8 92 ab ff ff       	call   f0100f8b <cprintf>
f01063f9:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063fc:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0106401:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106404:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106408:	74 08                	je     f0106412 <sched_kill_all+0x9d>
f010640a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010640d:	8b 40 08             	mov    0x8(%eax),%eax
f0106410:	eb 05                	jmp    f0106417 <sched_kill_all+0xa2>
f0106412:	b8 00 00 00 00       	mov    $0x0,%eax
f0106417:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f010641c:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0106421:	85 c0                	test   %eax,%eax
f0106423:	75 8d                	jne    f01063b2 <sched_kill_all+0x3d>
f0106425:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106429:	75 87                	jne    f01063b2 <sched_kill_all+0x3d>
f010642b:	eb 10                	jmp    f010643d <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010642d:	83 ec 0c             	sub    $0xc,%esp
f0106430:	68 df 59 12 f0       	push   $0xf01259df
f0106435:	e8 51 ab ff ff       	call   f0100f8b <cprintf>
f010643a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010643d:	83 ec 0c             	sub    $0xc,%esp
f0106440:	68 a4 58 12 f0       	push   $0xf01258a4
f0106445:	e8 41 ab ff ff       	call   f0100f8b <cprintf>
f010644a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010644d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106454:	e9 96 01 00 00       	jmp    f01065ef <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106459:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010645e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106461:	c1 e2 04             	shl    $0x4,%edx
f0106464:	01 d0                	add    %edx,%eax
f0106466:	8b 00                	mov    (%eax),%eax
f0106468:	85 c0                	test   %eax,%eax
f010646a:	0f 84 59 01 00 00    	je     f01065c9 <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106470:	83 ec 08             	sub    $0x8,%esp
f0106473:	ff 75 f0             	pushl  -0x10(%ebp)
f0106476:	68 fc 59 12 f0       	push   $0xf01259fc
f010647b:	e8 0b ab ff ff       	call   f0100f8b <cprintf>
f0106480:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106483:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106488:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010648b:	c1 e2 04             	shl    $0x4,%edx
f010648e:	01 d0                	add    %edx,%eax
f0106490:	8b 00                	mov    (%eax),%eax
f0106492:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106495:	e9 f5 00 00 00       	jmp    f010658f <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010649a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010649d:	8d 50 20             	lea    0x20(%eax),%edx
f01064a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064a3:	8b 40 10             	mov    0x10(%eax),%eax
f01064a6:	83 ec 04             	sub    $0x4,%esp
f01064a9:	52                   	push   %edx
f01064aa:	50                   	push   %eax
f01064ab:	68 cc 59 12 f0       	push   $0xf01259cc
f01064b0:	e8 d6 aa ff ff       	call   f0100f8b <cprintf>
f01064b5:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064bc:	75 17                	jne    f01064d5 <sched_kill_all+0x160>
f01064be:	83 ec 04             	sub    $0x4,%esp
f01064c1:	68 7f 56 12 f0       	push   $0xf012567f
f01064c6:	68 49 02 00 00       	push   $0x249
f01064cb:	68 43 56 12 f0       	push   $0xf0125643
f01064d0:	e8 64 9e ff ff       	call   f0100339 <_panic>
f01064d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064d8:	8b 40 08             	mov    0x8(%eax),%eax
f01064db:	85 c0                	test   %eax,%eax
f01064dd:	74 11                	je     f01064f0 <sched_kill_all+0x17b>
f01064df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064e2:	8b 40 08             	mov    0x8(%eax),%eax
f01064e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01064e8:	8b 52 0c             	mov    0xc(%edx),%edx
f01064eb:	89 50 0c             	mov    %edx,0xc(%eax)
f01064ee:	eb 16                	jmp    f0106506 <sched_kill_all+0x191>
f01064f0:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01064f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064f8:	c1 e2 04             	shl    $0x4,%edx
f01064fb:	01 c2                	add    %eax,%edx
f01064fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106500:	8b 40 0c             	mov    0xc(%eax),%eax
f0106503:	89 42 04             	mov    %eax,0x4(%edx)
f0106506:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106509:	8b 40 0c             	mov    0xc(%eax),%eax
f010650c:	85 c0                	test   %eax,%eax
f010650e:	74 11                	je     f0106521 <sched_kill_all+0x1ac>
f0106510:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106513:	8b 40 0c             	mov    0xc(%eax),%eax
f0106516:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106519:	8b 52 08             	mov    0x8(%edx),%edx
f010651c:	89 50 08             	mov    %edx,0x8(%eax)
f010651f:	eb 15                	jmp    f0106536 <sched_kill_all+0x1c1>
f0106521:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106526:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106529:	c1 e2 04             	shl    $0x4,%edx
f010652c:	01 c2                	add    %eax,%edx
f010652e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106531:	8b 40 08             	mov    0x8(%eax),%eax
f0106534:	89 02                	mov    %eax,(%edx)
f0106536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106539:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106543:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010654a:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010654f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106552:	c1 e2 04             	shl    $0x4,%edx
f0106555:	01 d0                	add    %edx,%eax
f0106557:	8b 50 0c             	mov    0xc(%eax),%edx
f010655a:	4a                   	dec    %edx
f010655b:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f010655e:	83 ec 0c             	sub    $0xc,%esp
f0106561:	ff 75 f4             	pushl  -0xc(%ebp)
f0106564:	e8 bf 56 00 00       	call   f010bc28 <env_free>
f0106569:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010656c:	83 ec 0c             	sub    $0xc,%esp
f010656f:	68 06 58 12 f0       	push   $0xf0125806
f0106574:	e8 12 aa ff ff       	call   f0100f8b <cprintf>
f0106579:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010657c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106581:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106584:	c1 e2 04             	shl    $0x4,%edx
f0106587:	01 d0                	add    %edx,%eax
f0106589:	8b 40 08             	mov    0x8(%eax),%eax
f010658c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010658f:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106594:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106597:	c1 e2 04             	shl    $0x4,%edx
f010659a:	01 d0                	add    %edx,%eax
f010659c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065a0:	74 08                	je     f01065aa <sched_kill_all+0x235>
f01065a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065a5:	8b 52 08             	mov    0x8(%edx),%edx
f01065a8:	eb 05                	jmp    f01065af <sched_kill_all+0x23a>
f01065aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01065af:	89 50 08             	mov    %edx,0x8(%eax)
f01065b2:	8b 40 08             	mov    0x8(%eax),%eax
f01065b5:	85 c0                	test   %eax,%eax
f01065b7:	0f 85 dd fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065c1:	0f 85 d3 fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065c7:	eb 13                	jmp    f01065dc <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01065c9:	83 ec 08             	sub    $0x8,%esp
f01065cc:	ff 75 f0             	pushl  -0x10(%ebp)
f01065cf:	68 00 59 12 f0       	push   $0xf0125900
f01065d4:	e8 b2 a9 ff ff       	call   f0100f8b <cprintf>
f01065d9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01065dc:	83 ec 0c             	sub    $0xc,%esp
f01065df:	68 a4 58 12 f0       	push   $0xf01258a4
f01065e4:	e8 a2 a9 ff ff       	call   f0100f8b <cprintf>
f01065e9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01065ec:	ff 45 f0             	incl   -0x10(%ebp)
f01065ef:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f01065f4:	0f b6 c0             	movzbl %al,%eax
f01065f7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01065fa:	0f 8f 59 fe ff ff    	jg     f0106459 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106600:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106605:	85 c0                	test   %eax,%eax
f0106607:	0f 84 95 00 00 00    	je     f01066a2 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f010660d:	83 ec 0c             	sub    $0xc,%esp
f0106610:	68 30 5a 12 f0       	push   $0xf0125a30
f0106615:	e8 71 a9 ff ff       	call   f0100f8b <cprintf>
f010661a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010661d:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106622:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106625:	eb 52                	jmp    f0106679 <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106627:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010662a:	8d 50 20             	lea    0x20(%eax),%edx
f010662d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106630:	8b 40 10             	mov    0x10(%eax),%eax
f0106633:	83 ec 04             	sub    $0x4,%esp
f0106636:	52                   	push   %edx
f0106637:	50                   	push   %eax
f0106638:	68 cc 59 12 f0       	push   $0xf01259cc
f010663d:	e8 49 a9 ff ff       	call   f0100f8b <cprintf>
f0106642:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0106645:	83 ec 0c             	sub    $0xc,%esp
f0106648:	ff 75 f4             	pushl  -0xc(%ebp)
f010664b:	e8 47 f2 ff ff       	call   f0105897 <sched_remove_exit>
f0106650:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106653:	83 ec 0c             	sub    $0xc,%esp
f0106656:	ff 75 f4             	pushl  -0xc(%ebp)
f0106659:	e8 ca 55 00 00       	call   f010bc28 <env_free>
f010665e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106661:	83 ec 0c             	sub    $0xc,%esp
f0106664:	68 06 58 12 f0       	push   $0xf0125806
f0106669:	e8 1d a9 ff ff       	call   f0100f8b <cprintf>
f010666e:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106671:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106676:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106679:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010667d:	74 08                	je     f0106687 <sched_kill_all+0x312>
f010667f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106682:	8b 40 08             	mov    0x8(%eax),%eax
f0106685:	eb 05                	jmp    f010668c <sched_kill_all+0x317>
f0106687:	b8 00 00 00 00       	mov    $0x0,%eax
f010668c:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f0106691:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106696:	85 c0                	test   %eax,%eax
f0106698:	75 8d                	jne    f0106627 <sched_kill_all+0x2b2>
f010669a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010669e:	75 87                	jne    f0106627 <sched_kill_all+0x2b2>
f01066a0:	eb 10                	jmp    f01066b2 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01066a2:	83 ec 0c             	sub    $0xc,%esp
f01066a5:	68 46 59 12 f0       	push   $0xf0125946
f01066aa:	e8 dc a8 ff ff       	call   f0100f8b <cprintf>
f01066af:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01066b2:	e8 b9 55 00 00       	call   f010bc70 <get_cpu_proc>
f01066b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01066ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01066be:	74 6b                	je     f010672b <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01066c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01066c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01066c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066c9:	8b 40 18             	mov    0x18(%eax),%eax
f01066cc:	83 f8 02             	cmp    $0x2,%eax
f01066cf:	74 19                	je     f01066ea <sched_kill_all+0x375>
f01066d1:	68 0c 58 12 f0       	push   $0xf012580c
f01066d6:	68 2e 56 12 f0       	push   $0xf012562e
f01066db:	68 69 02 00 00       	push   $0x269
f01066e0:	68 43 56 12 f0       	push   $0xf0125643
f01066e5:	e8 4f 9c ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01066ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066ed:	8d 50 20             	lea    0x20(%eax),%edx
f01066f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066f3:	8b 40 10             	mov    0x10(%eax),%eax
f01066f6:	83 ec 04             	sub    $0x4,%esp
f01066f9:	52                   	push   %edx
f01066fa:	50                   	push   %eax
f01066fb:	68 30 58 12 f0       	push   $0xf0125830
f0106700:	e8 86 a8 ff ff       	call   f0100f8b <cprintf>
f0106705:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f0106708:	83 ec 0c             	sub    $0xc,%esp
f010670b:	ff 75 f4             	pushl  -0xc(%ebp)
f010670e:	e8 15 55 00 00       	call   f010bc28 <env_free>
f0106713:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106716:	83 ec 0c             	sub    $0xc,%esp
f0106719:	68 06 58 12 f0       	push   $0xf0125806
f010671e:	e8 68 a8 ff ff       	call   f0100f8b <cprintf>
f0106723:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0106726:	e8 c6 56 00 00       	call   f010bdf1 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010672b:	83 ec 0c             	sub    $0xc,%esp
f010672e:	68 80 f0 71 f0       	push   $0xf071f080
f0106733:	e8 4d 98 00 00       	call   f010ff85 <release_spinlock>
f0106738:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010673b:	e8 82 b6 ff ff       	call   f0101dc2 <get_into_prompt>

f0106740 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106740:	55                   	push   %ebp
f0106741:	89 e5                	mov    %esp,%ebp
f0106743:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106746:	83 ec 0c             	sub    $0xc,%esp
f0106749:	68 80 f0 71 f0       	push   $0xf071f080
f010674e:	e8 ab 97 00 00       	call   f010fefe <acquire_spinlock>
f0106753:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010675d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106764:	e9 37 01 00 00       	jmp    f01068a0 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106769:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010676e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106771:	c1 e2 04             	shl    $0x4,%edx
f0106774:	01 d0                	add    %edx,%eax
f0106776:	8b 00                	mov    (%eax),%eax
f0106778:	85 c0                	test   %eax,%eax
f010677a:	0f 84 1d 01 00 00    	je     f010689d <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106780:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106787:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010678c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010678f:	c1 e2 04             	shl    $0x4,%edx
f0106792:	01 d0                	add    %edx,%eax
f0106794:	8b 00                	mov    (%eax),%eax
f0106796:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106799:	e9 c7 00 00 00       	jmp    f0106865 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010679e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01067a2:	75 17                	jne    f01067bb <sched_exit_all_ready_envs+0x7b>
f01067a4:	83 ec 04             	sub    $0x4,%esp
f01067a7:	68 7f 56 12 f0       	push   $0xf012567f
f01067ac:	68 8b 02 00 00       	push   $0x28b
f01067b1:	68 43 56 12 f0       	push   $0xf0125643
f01067b6:	e8 7e 9b ff ff       	call   f0100339 <_panic>
f01067bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067be:	8b 40 08             	mov    0x8(%eax),%eax
f01067c1:	85 c0                	test   %eax,%eax
f01067c3:	74 11                	je     f01067d6 <sched_exit_all_ready_envs+0x96>
f01067c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067c8:	8b 40 08             	mov    0x8(%eax),%eax
f01067cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ce:	8b 52 0c             	mov    0xc(%edx),%edx
f01067d1:	89 50 0c             	mov    %edx,0xc(%eax)
f01067d4:	eb 16                	jmp    f01067ec <sched_exit_all_ready_envs+0xac>
f01067d6:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01067db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01067de:	c1 e2 04             	shl    $0x4,%edx
f01067e1:	01 c2                	add    %eax,%edx
f01067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e6:	8b 40 0c             	mov    0xc(%eax),%eax
f01067e9:	89 42 04             	mov    %eax,0x4(%edx)
f01067ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067ef:	8b 40 0c             	mov    0xc(%eax),%eax
f01067f2:	85 c0                	test   %eax,%eax
f01067f4:	74 11                	je     f0106807 <sched_exit_all_ready_envs+0xc7>
f01067f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067f9:	8b 40 0c             	mov    0xc(%eax),%eax
f01067fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ff:	8b 52 08             	mov    0x8(%edx),%edx
f0106802:	89 50 08             	mov    %edx,0x8(%eax)
f0106805:	eb 15                	jmp    f010681c <sched_exit_all_ready_envs+0xdc>
f0106807:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010680c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010680f:	c1 e2 04             	shl    $0x4,%edx
f0106812:	01 c2                	add    %eax,%edx
f0106814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106817:	8b 40 08             	mov    0x8(%eax),%eax
f010681a:	89 02                	mov    %eax,(%edx)
f010681c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010681f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106826:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106829:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106830:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106835:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106838:	c1 e2 04             	shl    $0x4,%edx
f010683b:	01 d0                	add    %edx,%eax
f010683d:	8b 50 0c             	mov    0xc(%eax),%edx
f0106840:	4a                   	dec    %edx
f0106841:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106844:	83 ec 0c             	sub    $0xc,%esp
f0106847:	ff 75 f4             	pushl  -0xc(%ebp)
f010684a:	e8 c1 ef ff ff       	call   f0105810 <sched_insert_exit>
f010684f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106852:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106857:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010685a:	c1 e2 04             	shl    $0x4,%edx
f010685d:	01 d0                	add    %edx,%eax
f010685f:	8b 40 08             	mov    0x8(%eax),%eax
f0106862:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106865:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010686a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010686d:	c1 e2 04             	shl    $0x4,%edx
f0106870:	01 d0                	add    %edx,%eax
f0106872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106876:	74 08                	je     f0106880 <sched_exit_all_ready_envs+0x140>
f0106878:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010687b:	8b 52 08             	mov    0x8(%edx),%edx
f010687e:	eb 05                	jmp    f0106885 <sched_exit_all_ready_envs+0x145>
f0106880:	ba 00 00 00 00       	mov    $0x0,%edx
f0106885:	89 50 08             	mov    %edx,0x8(%eax)
f0106888:	8b 40 08             	mov    0x8(%eax),%eax
f010688b:	85 c0                	test   %eax,%eax
f010688d:	0f 85 0b ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
f0106893:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106897:	0f 85 01 ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010689d:	ff 45 f0             	incl   -0x10(%ebp)
f01068a0:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f01068a5:	0f b6 c0             	movzbl %al,%eax
f01068a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01068ab:	0f 8f b8 fe ff ff    	jg     f0106769 <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01068b1:	83 ec 0c             	sub    $0xc,%esp
f01068b4:	68 80 f0 71 f0       	push   $0xf071f080
f01068b9:	e8 c7 96 00 00       	call   f010ff85 <release_spinlock>
f01068be:	83 c4 10             	add    $0x10,%esp
}
f01068c1:	90                   	nop
f01068c2:	c9                   	leave  
f01068c3:	c3                   	ret    

f01068c4 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01068c4:	55                   	push   %ebp
f01068c5:	89 e5                	mov    %esp,%ebp
	return ticks;
f01068c7:	a1 28 f7 b1 f0       	mov    0xf0b1f728,%eax
f01068cc:	8b 15 2c f7 b1 f0    	mov    0xf0b1f72c,%edx
}
f01068d2:	5d                   	pop    %ebp
f01068d3:	c3                   	ret    

f01068d4 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01068d4:	55                   	push   %ebp
f01068d5:	89 e5                	mov    %esp,%ebp
f01068d7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068da:	83 ec 04             	sub    $0x4,%esp
f01068dd:	68 5c 5a 12 f0       	push   $0xf0125a5c
f01068e2:	68 9e 02 00 00       	push   $0x29e
f01068e7:	68 43 56 12 f0       	push   $0xf0125643
f01068ec:	e8 48 9a ff ff       	call   f0100339 <_panic>

f01068f1 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01068f1:	55                   	push   %ebp
f01068f2:	89 e5                	mov    %esp,%ebp
f01068f4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068f7:	83 ec 04             	sub    $0x4,%esp
f01068fa:	68 5c 5a 12 f0       	push   $0xf0125a5c
f01068ff:	68 a6 02 00 00       	push   $0x2a6
f0106904:	68 43 56 12 f0       	push   $0xf0125643
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>

f010690e <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f010690e:	55                   	push   %ebp
f010690f:	89 e5                	mov    %esp,%ebp
f0106911:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106914:	83 ec 04             	sub    $0x4,%esp
f0106917:	68 5c 5a 12 f0       	push   $0xf0125a5c
f010691c:	68 ae 02 00 00       	push   $0x2ae
f0106921:	68 43 56 12 f0       	push   $0xf0125643
f0106926:	e8 0e 9a ff ff       	call   f0100339 <_panic>

f010692b <get_load_average>:
}
int get_load_average()
{
f010692b:	55                   	push   %ebp
f010692c:	89 e5                	mov    %esp,%ebp
f010692e:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106931:	83 ec 04             	sub    $0x4,%esp
f0106934:	68 5c 5a 12 f0       	push   $0xf0125a5c
f0106939:	68 b6 02 00 00       	push   $0x2b6
f010693e:	68 43 56 12 f0       	push   $0xf0125643
f0106943:	e8 f1 99 ff ff       	call   f0100339 <_panic>

f0106948 <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f0106948:	55                   	push   %ebp
f0106949:	89 e5                	mov    %esp,%ebp
f010694b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - env_set_priority

	//Get the process of the given ID
	struct Env* proc ;
	envid2env(envID, &proc, 0);
f010694e:	83 ec 04             	sub    $0x4,%esp
f0106951:	6a 00                	push   $0x0
f0106953:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0106956:	50                   	push   %eax
f0106957:	ff 75 08             	pushl  0x8(%ebp)
f010695a:	e8 61 53 00 00       	call   f010bcc0 <envid2env>
f010695f:	83 c4 10             	add    $0x10,%esp

	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106962:	83 ec 04             	sub    $0x4,%esp
f0106965:	68 5c 5a 12 f0       	push   $0xf0125a5c
f010696a:	68 c8 02 00 00       	push   $0x2c8
f010696f:	68 43 56 12 f0       	push   $0xf0125643
f0106974:	e8 c0 99 ff ff       	call   f0100339 <_panic>

f0106979 <sched_set_starv_thresh>:
}

void sched_set_starv_thresh(uint32 starvThresh)
{
f0106979:	55                   	push   %ebp
f010697a:	89 e5                	mov    %esp,%ebp
f010697c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010697f:	83 ec 04             	sub    $0x4,%esp
f0106982:	68 5c 5a 12 f0       	push   $0xf0125a5c
f0106987:	68 d0 02 00 00       	push   $0x2d0
f010698c:	68 43 56 12 f0       	push   $0xf0125643
f0106991:	e8 a3 99 ff ff       	call   f0100339 <_panic>

f0106996 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0106996:	55                   	push   %ebp
f0106997:	89 e5                	mov    %esp,%ebp
f0106999:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f010699e:	85 c0                	test   %eax,%eax
f01069a0:	0f 94 c0             	sete   %al
f01069a3:	0f b6 c0             	movzbl %al,%eax
f01069a6:	5d                   	pop    %ebp
f01069a7:	c3                   	ret    

f01069a8 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01069a8:	55                   	push   %ebp
f01069a9:	89 e5                	mov    %esp,%ebp
f01069ab:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069b0:	83 f8 01             	cmp    $0x1,%eax
f01069b3:	0f 94 c0             	sete   %al
f01069b6:	0f b6 c0             	movzbl %al,%eax
f01069b9:	5d                   	pop    %ebp
f01069ba:	c3                   	ret    

f01069bb <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01069bb:	55                   	push   %ebp
f01069bc:	89 e5                	mov    %esp,%ebp
f01069be:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069c3:	83 f8 02             	cmp    $0x2,%eax
f01069c6:	0f 94 c0             	sete   %al
f01069c9:	0f b6 c0             	movzbl %al,%eax
f01069cc:	5d                   	pop    %ebp
f01069cd:	c3                   	ret    

f01069ce <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01069ce:	55                   	push   %ebp
f01069cf:	89 e5                	mov    %esp,%ebp
f01069d1:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069d6:	83 f8 03             	cmp    $0x3,%eax
f01069d9:	0f 94 c0             	sete   %al
f01069dc:	0f b6 c0             	movzbl %al,%eax
f01069df:	5d                   	pop    %ebp
f01069e0:	c3                   	ret    

f01069e1 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01069e1:	55                   	push   %ebp
f01069e2:	89 e5                	mov    %esp,%ebp
f01069e4:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01069e7:	c7 05 58 f2 b1 f0 00 	movl   $0x0,0xf0b1f258
f01069ee:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01069f1:	83 ec 0c             	sub    $0xc,%esp
f01069f4:	6a 0a                	push   $0xa
f01069f6:	e8 66 02 00 00       	call   f0106c61 <sched_init_RR>
f01069fb:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0106a06:	e8 4c e7 ff ff       	call   f0105157 <init_queue>
f0106a0b:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106a0e:	83 ec 0c             	sub    $0xc,%esp
f0106a11:	68 00 f1 71 f0       	push   $0xf071f100
f0106a16:	e8 3c e7 ff ff       	call   f0105157 <init_queue>
f0106a1b:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106a1e:	e8 14 0a 00 00       	call   f0107437 <mycpu>
f0106a23:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a2a:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106a2d:	83 ec 08             	sub    $0x8,%esp
f0106a30:	68 70 5a 12 f0       	push   $0xf0125a70
f0106a35:	68 80 f0 71 f0       	push   $0xf071f080
f0106a3a:	e8 8e 94 00 00       	call   f010fecd <init_spinlock>
f0106a3f:	83 c4 10             	add    $0x10,%esp
}
f0106a42:	90                   	nop
f0106a43:	c9                   	leave  
f0106a44:	c3                   	ret    

f0106a45 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106a45:	55                   	push   %ebp
f0106a46:	89 e5                	mov    %esp,%ebp
f0106a48:	53                   	push   %ebx
f0106a49:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106a4c:	9c                   	pushf  
f0106a4d:	58                   	pop    %eax
f0106a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0106a51:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0106a54:	25 00 02 00 00       	and    $0x200,%eax
f0106a59:	85 c0                	test   %eax,%eax
f0106a5b:	74 14                	je     f0106a71 <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106a5d:	83 ec 04             	sub    $0x4,%esp
f0106a60:	68 84 5a 12 f0       	push   $0xf0125a84
f0106a65:	6a 3a                	push   $0x3a
f0106a67:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106a6c:	e8 c8 98 ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0106a71:	e8 c1 09 00 00       	call   f0107437 <mycpu>
f0106a76:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106a79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a7c:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106a83:	00 00 00 

	chk1();
f0106a86:	e8 dd 85 01 00       	call   f011f068 <chk1>
	c->scheduler_status = SCH_STARTED;
f0106a8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a8e:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106a95:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106a98:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106a9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106aa6:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106aa7:	83 ec 0c             	sub    $0xc,%esp
f0106aaa:	68 80 f0 71 f0       	push   $0xf071f080
f0106aaf:	e8 4a 94 00 00       	call   f010fefe <acquire_spinlock>
f0106ab4:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106ab7:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f0106abc:	8b 04 85 7c 09 18 f0 	mov    -0xfe7f684(,%eax,4),%eax
f0106ac3:	ff d0                	call   *%eax
f0106ac5:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106ac8:	e8 a3 51 00 00       	call   f010bc70 <get_cpu_proc>
f0106acd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f0106ad0:	83 ec 0c             	sub    $0xc,%esp
f0106ad3:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ad6:	e8 be 51 00 00       	call   f010bc99 <set_cpu_proc>
f0106adb:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106ade:	83 ec 0c             	sub    $0xc,%esp
f0106ae1:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ae4:	e8 85 85 01 00       	call   f011f06e <chk2>
f0106ae9:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106aec:	83 ec 0c             	sub    $0xc,%esp
f0106aef:	ff 75 e0             	pushl  -0x20(%ebp)
f0106af2:	e8 a2 51 00 00       	call   f010bc99 <set_cpu_proc>
f0106af7:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106afa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106afe:	0f 84 dc 00 00 00    	je     f0106be0 <fos_scheduler+0x19b>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106b04:	83 ec 0c             	sub    $0xc,%esp
f0106b07:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b0a:	e8 8a 51 00 00       	call   f010bc99 <set_cpu_proc>
f0106b0f:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b18:	e8 f7 53 00 00       	call   f010bf14 <switchuvm>
f0106b1d:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106b20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b23:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106b2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b2d:	8b 40 04             	mov    0x4(%eax),%eax
f0106b30:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b33:	83 c2 04             	add    $0x4,%edx
f0106b36:	83 ec 08             	sub    $0x8,%esp
f0106b39:	50                   	push   %eax
f0106b3a:	52                   	push   %edx
f0106b3b:	e8 1f e2 ff ff       	call   f0104d5f <context_switch>
f0106b40:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106b43:	9c                   	pushf  
f0106b44:	58                   	pop    %eax
f0106b45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106b48:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106b4b:	25 00 02 00 00       	and    $0x200,%eax
f0106b50:	85 c0                	test   %eax,%eax
f0106b52:	74 14                	je     f0106b68 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f0106b54:	83 ec 04             	sub    $0x4,%esp
f0106b57:	68 cc 5a 12 f0       	push   $0xf0125acc
f0106b5c:	6a 77                	push   $0x77
f0106b5e:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106b63:	e8 d1 97 ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106b68:	e8 3b e3 ff ff       	call   f0104ea8 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106b6d:	e8 fe 50 00 00       	call   f010bc70 <get_cpu_proc>
f0106b72:	89 c2                	mov    %eax,%edx
f0106b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b77:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106b7d:	39 c2                	cmp    %eax,%edx
f0106b7f:	74 19                	je     f0106b9a <fos_scheduler+0x155>
f0106b81:	68 03 5b 12 f0       	push   $0xf0125b03
f0106b86:	68 1d 5b 12 f0       	push   $0xf0125b1d
f0106b8b:	68 80 00 00 00       	push   $0x80
f0106b90:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106b95:	e8 9f 97 ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b9d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106ba3:	8b 40 18             	mov    0x18(%eax),%eax
f0106ba6:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106ba9:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106bad:	75 19                	jne    f0106bc8 <fos_scheduler+0x183>
f0106baf:	68 32 5b 12 f0       	push   $0xf0125b32
f0106bb4:	68 1d 5b 12 f0       	push   $0xf0125b1d
f0106bb9:	68 82 00 00 00       	push   $0x82
f0106bbe:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106bc3:	e8 71 97 ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f0106bc8:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106bcc:	74 12                	je     f0106be0 <fos_scheduler+0x19b>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106bce:	e8 2a 53 00 00       	call   f010befd <switchkvm>
					set_cpu_proc(NULL);
f0106bd3:	83 ec 0c             	sub    $0xc,%esp
f0106bd6:	6a 00                	push   $0x0
f0106bd8:	e8 bc 50 00 00       	call   f010bc99 <set_cpu_proc>
f0106bdd:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106be0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106be4:	0f 85 cd fe ff ff    	jne    f0106ab7 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106bea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106bf8:	eb 3e                	jmp    f0106c38 <fos_scheduler+0x1f3>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106bfa:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f0106c00:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106c03:	89 d0                	mov    %edx,%eax
f0106c05:	c1 e0 03             	shl    $0x3,%eax
f0106c08:	01 d0                	add    %edx,%eax
f0106c0a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c11:	01 d8                	add    %ebx,%eax
f0106c13:	01 c0                	add    %eax,%eax
f0106c15:	01 d0                	add    %edx,%eax
f0106c17:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c1e:	01 d8                	add    %ebx,%eax
f0106c20:	01 d0                	add    %edx,%eax
f0106c22:	01 c8                	add    %ecx,%eax
f0106c24:	8b 40 18             	mov    0x18(%eax),%eax
f0106c27:	83 f8 03             	cmp    $0x3,%eax
f0106c2a:	75 09                	jne    f0106c35 <fos_scheduler+0x1f0>
			{
				is_any_blocked = 1;
f0106c2c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106c33:	eb 0d                	jmp    f0106c42 <fos_scheduler+0x1fd>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106c35:	ff 45 f0             	incl   -0x10(%ebp)
f0106c38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106c3b:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106c40:	76 b8                	jbe    f0106bfa <fos_scheduler+0x1b5>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106c42:	83 ec 0c             	sub    $0xc,%esp
f0106c45:	68 80 f0 71 f0       	push   $0xf071f080
f0106c4a:	e8 36 93 00 00       	call   f010ff85 <release_spinlock>
f0106c4f:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106c52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c56:	0f 8f 4a fe ff ff    	jg     f0106aa6 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106c5c:	e8 61 b1 ff ff       	call   f0101dc2 <get_into_prompt>

f0106c61 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0106c61:	55                   	push   %ebp
f0106c62:	89 e5                	mov    %esp,%ebp
f0106c64:	83 ec 28             	sub    $0x28,%esp
f0106c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c6a:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106c6d:	c6 05 e4 f7 f1 f0 01 	movb   $0x1,0xf0f1f7e4
#if USE_KHEAP
	sched_delete_ready_queues();
f0106c74:	e8 8e e7 ff ff       	call   f0105407 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106c79:	83 ec 0c             	sub    $0xc,%esp
f0106c7c:	6a 10                	push   $0x10
f0106c7e:	e8 37 2b 00 00       	call   f01097ba <kmalloc>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	a3 10 f1 71 f0       	mov    %eax,0xf071f110
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106c8b:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f0106c90:	0f b6 c0             	movzbl %al,%eax
f0106c93:	83 ec 0c             	sub    $0xc,%esp
f0106c96:	50                   	push   %eax
f0106c97:	e8 1e 2b 00 00       	call   f01097ba <kmalloc>
f0106c9c:	83 c4 10             	add    $0x10,%esp
f0106c9f:	a3 44 f4 b1 f0       	mov    %eax,0xf0b1f444
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106ca4:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106ca9:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106cac:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106cae:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106cb3:	8a 00                	mov    (%eax),%al
f0106cb5:	0f b6 c0             	movzbl %al,%eax
f0106cb8:	83 ec 0c             	sub    $0xc,%esp
f0106cbb:	50                   	push   %eax
f0106cbc:	e8 b0 e2 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106cc1:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106cc4:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106cc9:	83 ec 0c             	sub    $0xc,%esp
f0106ccc:	50                   	push   %eax
f0106ccd:	e8 85 e4 ff ff       	call   f0105157 <init_queue>
f0106cd2:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106cd5:	e8 f6 e3 ff ff       	call   f01050d0 <kclock_read_cnt0_latch>
f0106cda:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106cde:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106ce2:	83 ec 08             	sub    $0x8,%esp
f0106ce5:	50                   	push   %eax
f0106ce6:	68 48 5b 12 f0       	push   $0xf0125b48
f0106ceb:	e8 9b a2 ff ff       	call   f0100f8b <cprintf>
f0106cf0:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106cf3:	e8 3f 07 00 00       	call   f0107437 <mycpu>
f0106cf8:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106cff:	00 00 00 
	scheduler_method = SCH_RR;
f0106d02:	c7 05 74 f5 b1 f0 00 	movl   $0x0,0xf0b1f574
f0106d09:	00 00 00 
	//=========================================
	//=========================================
}
f0106d0c:	90                   	nop
f0106d0d:	c9                   	leave  
f0106d0e:	c3                   	ret    

f0106d0f <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106d0f:	55                   	push   %ebp
f0106d10:	89 e5                	mov    %esp,%ebp
f0106d12:	83 ec 18             	sub    $0x18,%esp
f0106d15:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d18:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106d1b:	e8 e7 e6 ff ff       	call   f0105407 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d20:	83 ec 04             	sub    $0x4,%esp
f0106d23:	68 70 5b 12 f0       	push   $0xf0125b70
f0106d28:	68 d1 00 00 00       	push   $0xd1
f0106d2d:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106d32:	e8 02 96 ff ff       	call   f0100339 <_panic>

f0106d37 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106d37:	55                   	push   %ebp
f0106d38:	89 e5                	mov    %esp,%ebp
f0106d3a:	83 ec 18             	sub    $0x18,%esp
f0106d3d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d43:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d46:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d49:	83 ec 04             	sub    $0x4,%esp
f0106d4c:	68 70 5b 12 f0       	push   $0xf0125b70
f0106d51:	68 e7 00 00 00       	push   $0xe7
f0106d56:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106d5b:	e8 d9 95 ff ff       	call   f0100339 <_panic>

f0106d60 <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0106d60:	55                   	push   %ebp
f0106d61:	89 e5                	mov    %esp,%ebp
f0106d63:	83 ec 18             	sub    $0x18,%esp
f0106d66:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d69:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d6c:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d6f:	88 45 f0             	mov    %al,-0x10(%ebp)
	//TODO: [PROJECT'24.MS3 - #07] [3] PRIORITY RR Scheduler - sched_init_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d72:	83 ec 04             	sub    $0x4,%esp
f0106d75:	68 70 5b 12 f0       	push   $0xf0125b70
f0106d7a:	68 fc 00 00 00       	push   $0xfc
f0106d7f:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106d84:	e8 b0 95 ff ff       	call   f0100339 <_panic>

f0106d89 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106d89:	55                   	push   %ebp
f0106d8a:	89 e5                	mov    %esp,%ebp
f0106d8c:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106d8f:	83 ec 0c             	sub    $0xc,%esp
f0106d92:	68 80 f0 71 f0       	push   $0xf071f080
f0106d97:	e8 7b 93 00 00       	call   f0110117 <holding_spinlock>
f0106d9c:	83 c4 10             	add    $0x10,%esp
f0106d9f:	85 c0                	test   %eax,%eax
f0106da1:	75 17                	jne    f0106dba <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106da3:	83 ec 04             	sub    $0x4,%esp
f0106da6:	68 84 5b 12 f0       	push   $0xf0125b84
f0106dab:	68 1c 01 00 00       	push   $0x11c
f0106db0:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106db5:	e8 7f 95 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106dba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106dc1:	e8 aa 4e 00 00       	call   f010bc70 <get_cpu_proc>
f0106dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106dc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106dcd:	74 14                	je     f0106de3 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106dcf:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106dd4:	83 ec 08             	sub    $0x8,%esp
f0106dd7:	ff 75 f0             	pushl  -0x10(%ebp)
f0106dda:	50                   	push   %eax
f0106ddb:	e8 b8 e3 ff ff       	call   f0105198 <enqueue>
f0106de0:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106de3:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106de8:	83 ec 0c             	sub    $0xc,%esp
f0106deb:	50                   	push   %eax
f0106dec:	e8 38 e4 ff ff       	call   f0105229 <dequeue>
f0106df1:	83 c4 10             	add    $0x10,%esp
f0106df4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106df7:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106dfc:	8a 00                	mov    (%eax),%al
f0106dfe:	0f b6 c0             	movzbl %al,%eax
f0106e01:	83 ec 0c             	sub    $0xc,%esp
f0106e04:	50                   	push   %eax
f0106e05:	e8 67 e1 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106e0a:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106e10:	c9                   	leave  
f0106e11:	c3                   	ret    

f0106e12 <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106e12:	55                   	push   %ebp
f0106e13:	89 e5                	mov    %esp,%ebp
f0106e15:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e18:	83 ec 0c             	sub    $0xc,%esp
f0106e1b:	68 80 f0 71 f0       	push   $0xf071f080
f0106e20:	e8 f2 92 00 00       	call   f0110117 <holding_spinlock>
f0106e25:	83 c4 10             	add    $0x10,%esp
f0106e28:	85 c0                	test   %eax,%eax
f0106e2a:	75 17                	jne    f0106e43 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106e2c:	83 ec 04             	sub    $0x4,%esp
f0106e2f:	68 d0 5b 12 f0       	push   $0xf0125bd0
f0106e34:	68 3b 01 00 00       	push   $0x13b
f0106e39:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106e3e:	e8 f6 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e43:	83 ec 04             	sub    $0x4,%esp
f0106e46:	68 70 5b 12 f0       	push   $0xf0125b70
f0106e4b:	68 41 01 00 00       	push   $0x141
f0106e50:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106e55:	e8 df 94 ff ff       	call   f0100339 <_panic>

f0106e5a <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106e5a:	55                   	push   %ebp
f0106e5b:	89 e5                	mov    %esp,%ebp
f0106e5d:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e60:	83 ec 0c             	sub    $0xc,%esp
f0106e63:	68 80 f0 71 f0       	push   $0xf071f080
f0106e68:	e8 aa 92 00 00       	call   f0110117 <holding_spinlock>
f0106e6d:	83 c4 10             	add    $0x10,%esp
f0106e70:	85 c0                	test   %eax,%eax
f0106e72:	75 17                	jne    f0106e8b <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106e74:	83 ec 04             	sub    $0x4,%esp
f0106e77:	68 20 5c 12 f0       	push   $0xf0125c20
f0106e7c:	68 4c 01 00 00       	push   $0x14c
f0106e81:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106e86:	e8 ae 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e8b:	83 ec 04             	sub    $0x4,%esp
f0106e8e:	68 70 5b 12 f0       	push   $0xf0125b70
f0106e93:	68 52 01 00 00       	push   $0x152
f0106e98:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106e9d:	e8 97 94 ff ff       	call   f0100339 <_panic>

f0106ea2 <fos_scheduler_PRIRR>:
}
//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0106ea2:	55                   	push   %ebp
f0106ea3:	89 e5                	mov    %esp,%ebp
f0106ea5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106ea8:	83 ec 0c             	sub    $0xc,%esp
f0106eab:	68 80 f0 71 f0       	push   $0xf071f080
f0106eb0:	e8 62 92 00 00       	call   f0110117 <holding_spinlock>
f0106eb5:	83 c4 10             	add    $0x10,%esp
f0106eb8:	85 c0                	test   %eax,%eax
f0106eba:	75 17                	jne    f0106ed3 <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0106ebc:	83 ec 04             	sub    $0x4,%esp
f0106ebf:	68 70 5c 12 f0       	push   $0xf0125c70
f0106ec4:	68 5c 01 00 00       	push   $0x15c
f0106ec9:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106ece:	e8 66 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'24.MS3 - #08] [3] PRIORITY RR Scheduler - fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ed3:	83 ec 04             	sub    $0x4,%esp
f0106ed6:	68 70 5b 12 f0       	push   $0xf0125b70
f0106edb:	68 61 01 00 00       	push   $0x161
f0106ee0:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106ee5:	e8 4f 94 ff ff       	call   f0100339 <_panic>

f0106eea <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106eea:	55                   	push   %ebp
f0106eeb:	89 e5                	mov    %esp,%ebp
f0106eed:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0106ef0:	e8 d9 fa ff ff       	call   f01069ce <isSchedMethodPRIRR>
f0106ef5:	85 c0                	test   %eax,%eax
f0106ef7:	74 17                	je     f0106f10 <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'24.MS3 - #09] [3] PRIORITY RR Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106ef9:	83 ec 04             	sub    $0x4,%esp
f0106efc:	68 70 5b 12 f0       	push   $0xf0125b70
f0106f01:	68 6f 01 00 00       	push   $0x16f
f0106f06:	68 ba 5a 12 f0       	push   $0xf0125aba
f0106f0b:	e8 29 94 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106f10:	a1 28 f7 b1 f0       	mov    0xf0b1f728,%eax
f0106f15:	8b 15 2c f7 b1 f0    	mov    0xf0b1f72c,%edx
f0106f1b:	83 c0 01             	add    $0x1,%eax
f0106f1e:	83 d2 00             	adc    $0x0,%edx
f0106f21:	a3 28 f7 b1 f0       	mov    %eax,0xf0b1f728
f0106f26:	89 15 2c f7 b1 f0    	mov    %edx,0xf0b1f72c
	struct Env* p = get_cpu_proc();
f0106f2c:	e8 3f 4d 00 00       	call   f010bc70 <get_cpu_proc>
f0106f31:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106f34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f38:	74 30                	je     f0106f6a <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f3d:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106f43:	8d 50 01             	lea    0x1(%eax),%edx
f0106f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f49:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106f4f:	83 ec 0c             	sub    $0xc,%esp
f0106f52:	6a 01                	push   $0x1
f0106f54:	e8 52 89 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f0106f59:	83 c4 10             	add    $0x10,%esp
f0106f5c:	85 c0                	test   %eax,%eax
f0106f5e:	74 05                	je     f0106f65 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106f60:	e8 08 00 00 00       	call   f0106f6d <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106f65:	e8 28 4e 00 00       	call   f010bd92 <yield>
	}
	/*****************************************/
}
f0106f6a:	90                   	nop
f0106f6b:	c9                   	leave  
f0106f6c:	c3                   	ret    

f0106f6d <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106f6d:	55                   	push   %ebp
f0106f6e:	89 e5                	mov    %esp,%ebp
f0106f70:	53                   	push   %ebx
f0106f71:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106f74:	e8 f7 4c 00 00       	call   f010bc70 <get_cpu_proc>
f0106f79:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106f7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106f80:	0f 84 a1 01 00 00    	je     f0107127 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106f86:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f89:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106f8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f92:	eb 78                	jmp    f010700c <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f97:	8b 00                	mov    (%eax),%eax
f0106f99:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106f9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f9f:	8b 40 64             	mov    0x64(%eax),%eax
f0106fa2:	83 ec 08             	sub    $0x8,%esp
f0106fa5:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fa8:	50                   	push   %eax
f0106fa9:	e8 0a 30 00 00       	call   f0109fb8 <pt_get_page_permissions>
f0106fae:	83 c4 10             	add    $0x10,%esp
f0106fb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	8b 40 08             	mov    0x8(%eax),%eax
f0106fba:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106fbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106fc0:	83 e0 20             	and    $0x20,%eax
f0106fc3:	85 c0                	test   %eax,%eax
f0106fc5:	74 2b                	je     f0106ff2 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106fc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106fca:	c1 e8 02             	shr    $0x2,%eax
f0106fcd:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106fd2:	89 c2                	mov    %eax,%edx
f0106fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd7:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106fda:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106fdd:	8b 40 64             	mov    0x64(%eax),%eax
f0106fe0:	6a 20                	push   $0x20
f0106fe2:	6a 00                	push   $0x0
f0106fe4:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fe7:	50                   	push   %eax
f0106fe8:	e8 07 2f 00 00       	call   f0109ef4 <pt_set_page_permissions>
f0106fed:	83 c4 10             	add    $0x10,%esp
f0106ff0:	eb 0e                	jmp    f0107000 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106ff2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106ff5:	c1 e8 02             	shr    $0x2,%eax
f0106ff8:	89 c2                	mov    %eax,%edx
f0106ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ffd:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0107000:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107003:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107009:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010700c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107010:	74 08                	je     f010701a <update_WS_time_stamps+0xad>
f0107012:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107015:	8b 40 10             	mov    0x10(%eax),%eax
f0107018:	eb 05                	jmp    f010701f <update_WS_time_stamps+0xb2>
f010701a:	b8 00 00 00 00       	mov    $0x0,%eax
f010701f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107022:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0107028:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010702b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107031:	85 c0                	test   %eax,%eax
f0107033:	0f 85 5b ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
f0107039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010703d:	0f 85 51 ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0107043:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010704a:	e9 ce 00 00 00       	jmp    f010711d <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f010704f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107052:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107055:	89 d0                	mov    %edx,%eax
f0107057:	01 c0                	add    %eax,%eax
f0107059:	01 d0                	add    %edx,%eax
f010705b:	c1 e0 03             	shl    $0x3,%eax
f010705e:	01 c8                	add    %ecx,%eax
f0107060:	05 b0 00 00 00       	add    $0xb0,%eax
f0107065:	8a 00                	mov    (%eax),%al
f0107067:	3c 01                	cmp    $0x1,%al
f0107069:	0f 84 ab 00 00 00    	je     f010711a <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f010706f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107072:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107075:	89 d0                	mov    %edx,%eax
f0107077:	01 c0                	add    %eax,%eax
f0107079:	01 d0                	add    %edx,%eax
f010707b:	c1 e0 03             	shl    $0x3,%eax
f010707e:	01 c8                	add    %ecx,%eax
f0107080:	05 ac 00 00 00       	add    $0xac,%eax
f0107085:	8b 00                	mov    (%eax),%eax
f0107087:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f010708a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010708d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107090:	89 d0                	mov    %edx,%eax
f0107092:	01 c0                	add    %eax,%eax
f0107094:	01 d0                	add    %edx,%eax
f0107096:	c1 e0 03             	shl    $0x3,%eax
f0107099:	01 c8                	add    %ecx,%eax
f010709b:	05 b4 00 00 00       	add    $0xb4,%eax
f01070a0:	8b 00                	mov    (%eax),%eax
f01070a2:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f01070a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070a8:	8b 40 64             	mov    0x64(%eax),%eax
f01070ab:	83 ec 08             	sub    $0x8,%esp
f01070ae:	ff 75 dc             	pushl  -0x24(%ebp)
f01070b1:	50                   	push   %eax
f01070b2:	e8 dd 2f 00 00       	call   f010a094 <pd_is_table_used>
f01070b7:	83 c4 10             	add    $0x10,%esp
f01070ba:	85 c0                	test   %eax,%eax
f01070bc:	74 3c                	je     f01070fa <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f01070be:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070c1:	c1 e8 02             	shr    $0x2,%eax
f01070c4:	0d 00 00 00 80       	or     $0x80000000,%eax
f01070c9:	89 c1                	mov    %eax,%ecx
f01070cb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01070ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01070d1:	89 d0                	mov    %edx,%eax
f01070d3:	01 c0                	add    %eax,%eax
f01070d5:	01 d0                	add    %edx,%eax
f01070d7:	c1 e0 03             	shl    $0x3,%eax
f01070da:	01 d8                	add    %ebx,%eax
f01070dc:	05 b4 00 00 00       	add    $0xb4,%eax
f01070e1:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f01070e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070e6:	8b 40 64             	mov    0x64(%eax),%eax
f01070e9:	83 ec 08             	sub    $0x8,%esp
f01070ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01070ef:	50                   	push   %eax
f01070f0:	e8 c3 2f 00 00       	call   f010a0b8 <pd_set_table_unused>
f01070f5:	83 c4 10             	add    $0x10,%esp
f01070f8:	eb 20                	jmp    f010711a <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f01070fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070fd:	c1 e8 02             	shr    $0x2,%eax
f0107100:	89 c1                	mov    %eax,%ecx
f0107102:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0107105:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107108:	89 d0                	mov    %edx,%eax
f010710a:	01 c0                	add    %eax,%eax
f010710c:	01 d0                	add    %edx,%eax
f010710e:	c1 e0 03             	shl    $0x3,%eax
f0107111:	01 d8                	add    %ebx,%eax
f0107113:	05 b4 00 00 00       	add    $0xb4,%eax
f0107118:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f010711a:	ff 45 f0             	incl   -0x10(%ebp)
f010711d:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0107121:	0f 8e 28 ff ff ff    	jle    f010704f <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0107127:	90                   	nop
f0107128:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010712b:	c9                   	leave  
f010712c:	c3                   	ret    

f010712d <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f010712d:	55                   	push   %ebp
f010712e:	89 e5                	mov    %esp,%ebp
f0107130:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107133:	c7 05 8c 65 6f f0 01 	movl   $0x1,0xf06f658c
f010713a:	00 00 00 
f010713d:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107144:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107148:	8a 45 b2             	mov    -0x4e(%ebp),%al
f010714b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010714e:	ee                   	out    %al,(%dx)
f010714f:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107156:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f010715a:	8a 45 b3             	mov    -0x4d(%ebp),%al
f010715d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107160:	ee                   	out    %al,(%dx)
f0107161:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107168:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f010716c:	8a 45 b4             	mov    -0x4c(%ebp),%al
f010716f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107172:	ee                   	out    %al,(%dx)
f0107173:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f010717a:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f010717e:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107181:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107184:	ee                   	out    %al,(%dx)
f0107185:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f010718c:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107190:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107193:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107196:	ee                   	out    %al,(%dx)
f0107197:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f010719e:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f01071a2:	8a 45 b7             	mov    -0x49(%ebp),%al
f01071a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01071a8:	ee                   	out    %al,(%dx)
f01071a9:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f01071b0:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f01071b4:	8a 45 b8             	mov    -0x48(%ebp),%al
f01071b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01071ba:	ee                   	out    %al,(%dx)
f01071bb:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f01071c2:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f01071c6:	8a 45 b9             	mov    -0x47(%ebp),%al
f01071c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01071cc:	ee                   	out    %al,(%dx)
f01071cd:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f01071d4:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f01071d8:	8a 45 ba             	mov    -0x46(%ebp),%al
f01071db:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01071de:	ee                   	out    %al,(%dx)
f01071df:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f01071e6:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f01071ea:	8a 45 bb             	mov    -0x45(%ebp),%al
f01071ed:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01071f0:	ee                   	out    %al,(%dx)
f01071f1:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f01071f8:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f01071fc:	8a 45 bc             	mov    -0x44(%ebp),%al
f01071ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107202:	ee                   	out    %al,(%dx)
f0107203:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f010720a:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f010720e:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107211:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107214:	ee                   	out    %al,(%dx)
f0107215:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f010721c:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107220:	8a 45 be             	mov    -0x42(%ebp),%al
f0107223:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107226:	ee                   	out    %al,(%dx)
f0107227:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f010722e:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107232:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107235:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107238:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107239:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010723f:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107243:	74 15                	je     f010725a <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107245:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010724b:	0f b7 c0             	movzwl %ax,%eax
f010724e:	83 ec 0c             	sub    $0xc,%esp
f0107251:	50                   	push   %eax
f0107252:	e8 06 00 00 00       	call   f010725d <irq_setmask_8259A>
f0107257:	83 c4 10             	add    $0x10,%esp
}
f010725a:	90                   	nop
f010725b:	c9                   	leave  
f010725c:	c3                   	ret    

f010725d <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f010725d:	55                   	push   %ebp
f010725e:	89 e5                	mov    %esp,%ebp
f0107260:	83 ec 14             	sub    $0x14,%esp
f0107263:	8b 45 08             	mov    0x8(%ebp),%eax
f0107266:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f010726a:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f010726f:	85 c0                	test   %eax,%eax
f0107271:	74 34                	je     f01072a7 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107273:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107276:	0f b6 c0             	movzbl %al,%eax
f0107279:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107280:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107283:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107286:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107289:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f010728a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010728d:	66 c1 e8 08          	shr    $0x8,%ax
f0107291:	0f b6 c0             	movzbl %al,%eax
f0107294:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f010729b:	88 45 f7             	mov    %al,-0x9(%ebp)
f010729e:	8a 45 f7             	mov    -0x9(%ebp),%al
f01072a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01072a4:	ee                   	out    %al,(%dx)
f01072a5:	eb 01                	jmp    f01072a8 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f01072a7:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f01072a8:	c9                   	leave  
f01072a9:	c3                   	ret    

f01072aa <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f01072aa:	55                   	push   %ebp
f01072ab:	89 e5                	mov    %esp,%ebp
f01072ad:	53                   	push   %ebx
f01072ae:	83 ec 14             	sub    $0x14,%esp
f01072b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01072b4:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01072b7:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f01072bc:	85 c0                	test   %eax,%eax
f01072be:	74 58                	je     f0107318 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01072c0:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01072c4:	77 08                	ja     f01072ce <irq_set_mask+0x24>
		port = PIC1_DATA;
f01072c6:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01072cc:	eb 0a                	jmp    f01072d8 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f01072ce:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01072d4:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f01072d8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01072dc:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01072df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e2:	89 c2                	mov    %eax,%edx
f01072e4:	ec                   	in     (%dx),%al
f01072e5:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f01072e8:	8a 45 ee             	mov    -0x12(%ebp),%al
f01072eb:	88 c2                	mov    %al,%dl
f01072ed:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01072f1:	bb 01 00 00 00       	mov    $0x1,%ebx
f01072f6:	88 c1                	mov    %al,%cl
f01072f8:	d3 e3                	shl    %cl,%ebx
f01072fa:	89 d8                	mov    %ebx,%eax
f01072fc:	09 d0                	or     %edx,%eax
f01072fe:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107301:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107305:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107309:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010730c:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010730f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107312:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107315:	ee                   	out    %al,(%dx)
f0107316:	eb 01                	jmp    f0107319 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107318:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107319:	83 c4 14             	add    $0x14,%esp
f010731c:	5b                   	pop    %ebx
f010731d:	5d                   	pop    %ebp
f010731e:	c3                   	ret    

f010731f <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f010731f:	55                   	push   %ebp
f0107320:	89 e5                	mov    %esp,%ebp
f0107322:	53                   	push   %ebx
f0107323:	83 ec 14             	sub    $0x14,%esp
f0107326:	8b 45 08             	mov    0x8(%ebp),%eax
f0107329:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010732c:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f0107331:	85 c0                	test   %eax,%eax
f0107333:	74 5a                	je     f010738f <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107335:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107339:	77 08                	ja     f0107343 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f010733b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107341:	eb 0a                	jmp    f010734d <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107343:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107349:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f010734d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107351:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107354:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107357:	89 c2                	mov    %eax,%edx
f0107359:	ec                   	in     (%dx),%al
f010735a:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f010735d:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107360:	88 c2                	mov    %al,%dl
f0107362:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107366:	bb 01 00 00 00       	mov    $0x1,%ebx
f010736b:	88 c1                	mov    %al,%cl
f010736d:	d3 e3                	shl    %cl,%ebx
f010736f:	89 d8                	mov    %ebx,%eax
f0107371:	f7 d0                	not    %eax
f0107373:	21 d0                	and    %edx,%eax
f0107375:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107378:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f010737c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107380:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107383:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107386:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107389:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010738c:	ee                   	out    %al,(%dx)
f010738d:	eb 01                	jmp    f0107390 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010738f:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107390:	83 c4 14             	add    $0x14,%esp
f0107393:	5b                   	pop    %ebx
f0107394:	5d                   	pop    %ebp
f0107395:	c3                   	ret    

f0107396 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107396:	55                   	push   %ebp
f0107397:	89 e5                	mov    %esp,%ebp
f0107399:	53                   	push   %ebx
f010739a:	83 ec 14             	sub    $0x14,%esp
f010739d:	8b 45 08             	mov    0x8(%ebp),%eax
f01073a0:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01073a3:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f01073a8:	85 c0                	test   %eax,%eax
f01073aa:	75 07                	jne    f01073b3 <irq_get_mask+0x1d>
		return -1;
f01073ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01073b1:	eb 45                	jmp    f01073f8 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01073b3:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01073b7:	77 08                	ja     f01073c1 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f01073b9:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01073bf:	eb 0a                	jmp    f01073cb <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f01073c1:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01073c7:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01073cb:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01073cf:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01073d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d5:	89 c2                	mov    %eax,%edx
f01073d7:	ec                   	in     (%dx),%al
f01073d8:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01073db:	8a 45 f3             	mov    -0xd(%ebp),%al
f01073de:	88 c2                	mov    %al,%dl
f01073e0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01073e4:	bb 01 00 00 00       	mov    $0x1,%ebx
f01073e9:	88 c1                	mov    %al,%cl
f01073eb:	d3 e3                	shl    %cl,%ebx
f01073ed:	89 d8                	mov    %ebx,%eax
f01073ef:	21 d0                	and    %edx,%eax
f01073f1:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01073f4:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01073f8:	83 c4 14             	add    $0x14,%esp
f01073fb:	5b                   	pop    %ebx
f01073fc:	5d                   	pop    %ebp
f01073fd:	c3                   	ret    

f01073fe <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01073fe:	55                   	push   %ebp
f01073ff:	89 e5                	mov    %esp,%ebp
f0107401:	83 ec 14             	sub    $0x14,%esp
f0107404:	8b 45 08             	mov    0x8(%ebp),%eax
f0107407:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f010740a:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f010740e:	76 12                	jbe    f0107422 <pic_sendEOI+0x24>
f0107410:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107417:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010741b:	8a 45 f7             	mov    -0x9(%ebp),%al
f010741e:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107421:	ee                   	out    %al,(%dx)
f0107422:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107429:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f010742d:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107430:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107433:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107434:	90                   	nop
f0107435:	c9                   	leave  
f0107436:	c3                   	ret    

f0107437 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107437:	55                   	push   %ebp
f0107438:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010743a:	b8 60 f2 b1 f0       	mov    $0xf0b1f260,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f010743f:	5d                   	pop    %ebp
f0107440:	c3                   	ret    

f0107441 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107441:	55                   	push   %ebp
f0107442:	89 e5                	mov    %esp,%ebp
f0107444:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107447:	e8 eb ff ff ff       	call   f0107437 <mycpu>
f010744c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f010744f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107452:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107459:	00 00 00 
  c->ncli = 0;
f010745c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745f:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107466:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107469:	9c                   	pushf  
f010746a:	58                   	pop    %eax
f010746b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010746e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107471:	25 00 02 00 00       	and    $0x200,%eax
f0107476:	85 c0                	test   %eax,%eax
f0107478:	0f 95 c0             	setne  %al
f010747b:	0f b6 d0             	movzbl %al,%edx
f010747e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107481:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107491:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107494:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f010749b:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f010749e:	8b 45 08             	mov    0x8(%ebp),%eax
f01074a1:	40                   	inc    %eax
f01074a2:	c1 e0 0f             	shl    $0xf,%eax
f01074a5:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01074aa:	29 c2                	sub    %eax,%edx
f01074ac:	89 d0                	mov    %edx,%eax
f01074ae:	89 c2                	mov    %eax,%edx
f01074b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b3:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f01074b6:	e8 18 01 00 00       	call   f01075d3 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f01074bb:	e8 80 5e 00 00       	call   f010d340 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f01074c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c3:	83 c0 0c             	add    $0xc,%eax
f01074c6:	83 ec 04             	sub    $0x4,%esp
f01074c9:	6a 68                	push   $0x68
f01074cb:	6a 00                	push   $0x0
f01074cd:	50                   	push   %eax
f01074ce:	e8 c7 8b 01 00       	call   f012009a <memset>
f01074d3:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01074d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d9:	05 a4 00 00 00       	add    $0xa4,%eax
f01074de:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01074e1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01074e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01074eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01074ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01074f1:	f0 87 02             	lock xchg %eax,(%edx)
f01074f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01074f7:	90                   	nop
f01074f8:	c9                   	leave  
f01074f9:	c3                   	ret    

f01074fa <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01074fa:	55                   	push   %ebp
f01074fb:	89 e5                	mov    %esp,%ebp
f01074fd:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107500:	9c                   	pushf  
f0107501:	58                   	pop    %eax
f0107502:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0107505:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107508:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010750b:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f010750c:	e8 26 ff ff ff       	call   f0107437 <mycpu>
f0107511:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0107514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107517:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010751d:	85 c0                	test   %eax,%eax
f010751f:	75 13                	jne    f0107534 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0107521:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107524:	25 00 02 00 00       	and    $0x200,%eax
f0107529:	89 c2                	mov    %eax,%edx
f010752b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107534:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107537:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010753d:	8d 50 01             	lea    0x1(%eax),%edx
f0107540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107543:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0107549:	90                   	nop
f010754a:	c9                   	leave  
f010754b:	c3                   	ret    

f010754c <popcli>:

void popcli(void)
{
f010754c:	55                   	push   %ebp
f010754d:	89 e5                	mov    %esp,%ebp
f010754f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107552:	9c                   	pushf  
f0107553:	58                   	pop    %eax
f0107554:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107557:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010755a:	25 00 02 00 00       	and    $0x200,%eax
f010755f:	85 c0                	test   %eax,%eax
f0107561:	74 14                	je     f0107577 <popcli+0x2b>
    panic("popcli - interruptible");
f0107563:	83 ec 04             	sub    $0x4,%esp
f0107566:	68 bf 5c 12 f0       	push   $0xf0125cbf
f010756b:	6a 5e                	push   $0x5e
f010756d:	68 d6 5c 12 f0       	push   $0xf0125cd6
f0107572:	e8 c2 8d ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f0107577:	e8 bb fe ff ff       	call   f0107437 <mycpu>
f010757c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010757f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107582:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107588:	8d 50 ff             	lea    -0x1(%eax),%edx
f010758b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010758e:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010759d:	85 c0                	test   %eax,%eax
f010759f:	79 14                	jns    f01075b5 <popcli+0x69>
    panic("popcli");
f01075a1:	83 ec 04             	sub    $0x4,%esp
f01075a4:	68 e5 5c 12 f0       	push   $0xf0125ce5
f01075a9:	6a 61                	push   $0x61
f01075ab:	68 d6 5c 12 f0       	push   $0xf0125cd6
f01075b0:	e8 84 8d ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f01075b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075b8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01075be:	85 c0                	test   %eax,%eax
f01075c0:	75 0e                	jne    f01075d0 <popcli+0x84>
f01075c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075c5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01075cb:	85 c0                	test   %eax,%eax
f01075cd:	74 01                	je     f01075d0 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01075cf:	fb                   	sti    
    sti();
}
f01075d0:	90                   	nop
f01075d1:	c9                   	leave  
f01075d2:	c3                   	ret    

f01075d3 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01075d3:	55                   	push   %ebp
f01075d4:	89 e5                	mov    %esp,%ebp
f01075d6:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01075d9:	e8 1c ff ff ff       	call   f01074fa <pushcli>

	c = mycpu();
f01075de:	e8 54 fe ff ff       	call   f0107437 <mycpu>
f01075e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01075e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01075f0:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01075f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075fa:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107609:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760c:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0107613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107616:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010761c:	83 e2 f0             	and    $0xfffffff0,%edx
f010761f:	83 ca 0a             	or     $0xa,%edx
f0107622:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107628:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010762b:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107631:	83 ca 10             	or     $0x10,%edx
f0107634:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010763a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763d:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107643:	83 e2 9f             	and    $0xffffff9f,%edx
f0107646:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010764c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010764f:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107655:	83 ca 80             	or     $0xffffff80,%edx
f0107658:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010765e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107661:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107667:	83 ca 0f             	or     $0xf,%edx
f010766a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107670:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107673:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107679:	83 e2 ef             	and    $0xffffffef,%edx
f010767c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107682:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107685:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010768b:	83 e2 df             	and    $0xffffffdf,%edx
f010768e:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107694:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107697:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010769d:	83 ca 40             	or     $0x40,%edx
f01076a0:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076a9:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01076af:	83 ca 80             	or     $0xffffff80,%edx
f01076b2:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076bb:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01076c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076c5:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01076cc:	ff ff 
f01076ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d1:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01076d8:	00 00 
f01076da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076dd:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01076e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076e7:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01076ed:	83 e2 f0             	and    $0xfffffff0,%edx
f01076f0:	83 ca 02             	or     $0x2,%edx
f01076f3:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01076f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076fc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107702:	83 ca 10             	or     $0x10,%edx
f0107705:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010770b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010770e:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107714:	83 e2 9f             	and    $0xffffff9f,%edx
f0107717:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010771d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107720:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107726:	83 ca 80             	or     $0xffffff80,%edx
f0107729:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010772f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107732:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107738:	83 ca 0f             	or     $0xf,%edx
f010773b:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107741:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107744:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010774a:	83 e2 ef             	and    $0xffffffef,%edx
f010774d:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107753:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107756:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010775c:	83 e2 df             	and    $0xffffffdf,%edx
f010775f:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107765:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107768:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010776e:	83 ca 40             	or     $0x40,%edx
f0107771:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107777:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010777a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107780:	83 ca 80             	or     $0xffffff80,%edx
f0107783:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107789:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010778c:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107793:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107796:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f010779d:	ff ff 
f010779f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077a2:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01077a9:	00 00 
f01077ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077ae:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01077b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077b8:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077be:	83 e2 f0             	and    $0xfffffff0,%edx
f01077c1:	83 ca 0a             	or     $0xa,%edx
f01077c4:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077cd:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077d3:	83 ca 10             	or     $0x10,%edx
f01077d6:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077df:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077e5:	83 ca 60             	or     $0x60,%edx
f01077e8:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077f1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077f7:	83 ca 80             	or     $0xffffff80,%edx
f01077fa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107803:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107809:	83 ca 0f             	or     $0xf,%edx
f010780c:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107812:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107815:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010781b:	83 e2 ef             	and    $0xffffffef,%edx
f010781e:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107824:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107827:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010782d:	83 e2 df             	and    $0xffffffdf,%edx
f0107830:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107836:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107839:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010783f:	83 ca 40             	or     $0x40,%edx
f0107842:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107848:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010784b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107851:	83 ca 80             	or     $0xffffff80,%edx
f0107854:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010785a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010785d:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107864:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107867:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f010786e:	ff ff 
f0107870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107873:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010787a:	00 00 
f010787c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010787f:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107886:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107889:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010788f:	83 e2 f0             	and    $0xfffffff0,%edx
f0107892:	83 ca 02             	or     $0x2,%edx
f0107895:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010789b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010789e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078a4:	83 ca 10             	or     $0x10,%edx
f01078a7:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078b0:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078b6:	83 ca 60             	or     $0x60,%edx
f01078b9:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078c2:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078c8:	83 ca 80             	or     $0xffffff80,%edx
f01078cb:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078d4:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078da:	83 ca 0f             	or     $0xf,%edx
f01078dd:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078e6:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078ec:	83 e2 ef             	and    $0xffffffef,%edx
f01078ef:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f8:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078fe:	83 e2 df             	and    $0xffffffdf,%edx
f0107901:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107907:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010790a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107910:	83 ca 40             	or     $0x40,%edx
f0107913:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010791c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107922:	83 ca 80             	or     $0xffffff80,%edx
f0107925:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010792b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010792e:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107935:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107938:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010793f:	00 00 00 
f0107942:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107949:	00 00 00 

	popcli();	//enable interrupt
f010794c:	e8 fb fb ff ff       	call   f010754c <popcli>


}
f0107951:	90                   	nop
f0107952:	c9                   	leave  
f0107953:	c3                   	ret    

f0107954 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107954:	55                   	push   %ebp
f0107955:	89 e5                	mov    %esp,%ebp
f0107957:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010795a:	83 ec 08             	sub    $0x8,%esp
f010795d:	68 00 10 00 00       	push   $0x1000
f0107962:	68 00 10 00 00       	push   $0x1000
f0107967:	e8 42 02 00 00       	call   f0107bae <boot_allocate_space>
f010796c:	83 c4 10             	add    $0x10,%esp
f010796f:	a3 44 f7 f1 f0       	mov    %eax,0xf0f1f744
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107974:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107979:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010797c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107983:	77 14                	ja     f0107999 <initialize_kernel_VM+0x45>
f0107985:	ff 75 e0             	pushl  -0x20(%ebp)
f0107988:	68 ec 5c 12 f0       	push   $0xf0125cec
f010798d:	6a 57                	push   $0x57
f010798f:	68 20 5d 12 f0       	push   $0xf0125d20
f0107994:	e8 a0 89 ff ff       	call   f0100339 <_panic>
f0107999:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010799c:	05 00 00 00 10       	add    $0x10000000,%eax
f01079a1:	a3 84 f8 f1 f0       	mov    %eax,0xf0f1f884
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01079a6:	c7 45 dc 00 80 17 f0 	movl   $0xf0178000,-0x24(%ebp)
f01079ad:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01079b4:	77 14                	ja     f01079ca <initialize_kernel_VM+0x76>
f01079b6:	ff 75 dc             	pushl  -0x24(%ebp)
f01079b9:	68 ec 5c 12 f0       	push   $0xf0125cec
f01079be:	6a 63                	push   $0x63
f01079c0:	68 20 5d 12 f0       	push   $0xf0125d20
f01079c5:	e8 6f 89 ff ff       	call   f0100339 <_panic>
f01079ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079cd:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01079d3:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01079d8:	83 ec 0c             	sub    $0xc,%esp
f01079db:	6a 02                	push   $0x2
f01079dd:	52                   	push   %edx
f01079de:	68 00 80 00 00       	push   $0x8000
f01079e3:	68 00 80 bf ef       	push   $0xefbf8000
f01079e8:	50                   	push   %eax
f01079e9:	e8 34 02 00 00       	call   f0107c22 <boot_map_range>
f01079ee:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01079f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01079f8:	eb 24                	jmp    f0107a1e <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01079fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079fd:	40                   	inc    %eax
f01079fe:	c1 e0 0f             	shl    $0xf,%eax
f0107a01:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107a06:	29 c2                	sub    %eax,%edx
f0107a08:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107a0d:	6a 01                	push   $0x1
f0107a0f:	6a 00                	push   $0x0
f0107a11:	52                   	push   %edx
f0107a12:	50                   	push   %eax
f0107a13:	e8 dc 24 00 00       	call   f0109ef4 <pt_set_page_permissions>
f0107a18:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107a1b:	ff 45 f4             	incl   -0xc(%ebp)
f0107a1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107a22:	7e d6                	jle    f01079fa <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107a24:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107a2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107a32:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a39:	eb 25                	jmp    f0107a60 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107a3b:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107a3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107a41:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107a46:	83 ec 04             	sub    $0x4,%esp
f0107a49:	6a 01                	push   $0x1
f0107a4b:	52                   	push   %edx
f0107a4c:	50                   	push   %eax
f0107a4d:	e8 44 02 00 00       	call   f0107c96 <boot_get_page_table>
f0107a52:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a55:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107a5c:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107a60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a64:	72 d5                	jb     f0107a3b <initialize_kernel_VM+0xe7>
f0107a66:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a6a:	77 06                	ja     f0107a72 <initialize_kernel_VM+0x11e>
f0107a6c:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107a70:	76 c9                	jbe    f0107a3b <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107a72:	8b 15 18 f3 b1 f0    	mov    0xf0b1f318,%edx
f0107a78:	89 d0                	mov    %edx,%eax
f0107a7a:	01 c0                	add    %eax,%eax
f0107a7c:	01 d0                	add    %edx,%eax
f0107a7e:	c1 e0 03             	shl    $0x3,%eax
f0107a81:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107a84:	83 ec 08             	sub    $0x8,%esp
f0107a87:	68 00 10 00 00       	push   $0x1000
f0107a8c:	ff 75 d8             	pushl  -0x28(%ebp)
f0107a8f:	e8 1a 01 00 00       	call   f0107bae <boot_allocate_space>
f0107a94:	83 c4 10             	add    $0x10,%esp
f0107a97:	a3 80 f5 b1 f0       	mov    %eax,0xf0b1f580
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107a9c:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107aa3:	83 ec 08             	sub    $0x8,%esp
f0107aa6:	68 00 10 00 00       	push   $0x1000
f0107aab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107aae:	e8 fb 00 00 00       	call   f0107bae <boot_allocate_space>
f0107ab3:	83 c4 10             	add    $0x10,%esp
f0107ab6:	a3 40 ee 71 f0       	mov    %eax,0xf071ee40
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107abb:	e8 05 05 00 00       	call   f0107fc5 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107ac0:	83 ec 0c             	sub    $0xc,%esp
f0107ac3:	68 ca 02 00 00       	push   $0x2ca
f0107ac8:	e8 3d 69 01 00       	call   f011e40a <nearest_pow2_ceil>
f0107acd:	83 c4 10             	add    $0x10,%esp
f0107ad0:	83 ec 04             	sub    $0x4,%esp
f0107ad3:	50                   	push   %eax
f0107ad4:	68 ca 02 00 00       	push   $0x2ca
f0107ad9:	68 40 5d 12 f0       	push   $0xf0125d40
f0107ade:	e8 a8 94 ff ff       	call   f0100f8b <cprintf>
f0107ae3:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107ae6:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107aed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107af0:	83 ec 08             	sub    $0x8,%esp
f0107af3:	68 00 10 00 00       	push   $0x1000
f0107af8:	50                   	push   %eax
f0107af9:	e8 b0 00 00 00       	call   f0107bae <boot_allocate_space>
f0107afe:	83 c4 10             	add    $0x10,%esp
f0107b01:	a3 90 65 6f f0       	mov    %eax,0xf06f6590
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107b06:	a1 90 65 6f f0       	mov    0xf06f6590,%eax
f0107b0b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107b0e:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f0107b15:	77 17                	ja     f0107b2e <initialize_kernel_VM+0x1da>
f0107b17:	ff 75 cc             	pushl  -0x34(%ebp)
f0107b1a:	68 ec 5c 12 f0       	push   $0xf0125cec
f0107b1f:	68 b1 00 00 00       	push   $0xb1
f0107b24:	68 20 5d 12 f0       	push   $0xf0125d20
f0107b29:	e8 0b 88 ff ff       	call   f0100339 <_panic>
f0107b2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107b31:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0107b37:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107b3a:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107b3f:	83 ec 0c             	sub    $0xc,%esp
f0107b42:	6a 04                	push   $0x4
f0107b44:	51                   	push   %ecx
f0107b45:	52                   	push   %edx
f0107b46:	68 00 00 c0 ee       	push   $0xeec00000
f0107b4b:	50                   	push   %eax
f0107b4c:	e8 d1 00 00 00       	call   f0107c22 <boot_map_range>
f0107b51:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107b54:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107b59:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107b5e:	8b 15 44 f7 f1 f0    	mov    0xf0f1f744,%edx
f0107b64:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0107b6a:	8b 12                	mov    (%edx),%edx
f0107b6c:	83 ca 05             	or     $0x5,%edx
f0107b6f:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107b71:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107b76:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107b7c:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107b81:	83 ec 0c             	sub    $0xc,%esp
f0107b84:	6a 02                	push   $0x2
f0107b86:	6a 00                	push   $0x0
f0107b88:	52                   	push   %edx
f0107b89:	68 00 00 00 f0       	push   $0xf0000000
f0107b8e:	50                   	push   %eax
f0107b8f:	e8 8e 00 00 00       	call   f0107c22 <boot_map_range>
f0107b94:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107b97:	e8 41 78 01 00       	call   f011f3dd <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107b9c:	c7 05 50 f2 b1 f0 19 	movl   $0x19,0xf0b1f250
f0107ba3:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107ba6:	e8 e6 02 00 00       	call   f0107e91 <turn_on_paging>
}
f0107bab:	90                   	nop
f0107bac:	c9                   	leave  
f0107bad:	c3                   	ret    

f0107bae <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107bae:	55                   	push   %ebp
f0107baf:	89 e5                	mov    %esp,%ebp
f0107bb1:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107bb4:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107bb9:	85 c0                	test   %eax,%eax
f0107bbb:	75 0a                	jne    f0107bc7 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107bbd:	c7 05 40 f7 f1 f0 70 	movl   $0xf26b2270,0xf0f1f740
f0107bc4:	22 6b f2 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107bca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107bcd:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107bd2:	89 c2                	mov    %eax,%edx
f0107bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bd7:	01 d0                	add    %edx,%eax
f0107bd9:	48                   	dec    %eax
f0107bda:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107be0:	ba 00 00 00 00       	mov    $0x0,%edx
f0107be5:	f7 75 f4             	divl   -0xc(%ebp)
f0107be8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107beb:	29 d0                	sub    %edx,%eax
f0107bed:	a3 40 f7 f1 f0       	mov    %eax,0xf0f1f740

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107bf2:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107bf7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107bfa:	8b 15 40 f7 f1 f0    	mov    0xf0f1f740,%edx
f0107c00:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c03:	01 d0                	add    %edx,%eax
f0107c05:	a3 40 f7 f1 f0       	mov    %eax,0xf0f1f740

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107c0a:	83 ec 04             	sub    $0x4,%esp
f0107c0d:	ff 75 08             	pushl  0x8(%ebp)
f0107c10:	6a 00                	push   $0x0
f0107c12:	ff 75 ec             	pushl  -0x14(%ebp)
f0107c15:	e8 80 84 01 00       	call   f012009a <memset>
f0107c1a:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0107c20:	c9                   	leave  
f0107c21:	c3                   	ret    

f0107c22 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0107c22:	55                   	push   %ebp
f0107c23:	89 e5                	mov    %esp,%ebp
f0107c25:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107c28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107c36:	eb 53                	jmp    f0107c8b <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0107c38:	83 ec 04             	sub    $0x4,%esp
f0107c3b:	6a 01                	push   $0x1
f0107c3d:	ff 75 0c             	pushl  0xc(%ebp)
f0107c40:	ff 75 08             	pushl  0x8(%ebp)
f0107c43:	e8 4e 00 00 00       	call   f0107c96 <boot_get_page_table>
f0107c48:	83 c4 10             	add    $0x10,%esp
f0107c4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c51:	c1 e8 0c             	shr    $0xc,%eax
f0107c54:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107c59:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c5f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107c66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107c69:	01 c2                	add    %eax,%edx
f0107c6b:	8b 45 18             	mov    0x18(%ebp),%eax
f0107c6e:	0b 45 14             	or     0x14(%ebp),%eax
f0107c71:	83 c8 01             	or     $0x1,%eax
f0107c74:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0107c76:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107c7d:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c84:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c8e:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107c91:	72 a5                	jb     f0107c38 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107c93:	90                   	nop
f0107c94:	c9                   	leave  
f0107c95:	c3                   	ret    

f0107c96 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107c96:	55                   	push   %ebp
f0107c97:	89 e5                	mov    %esp,%ebp
f0107c99:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c9f:	c1 e8 16             	shr    $0x16,%eax
f0107ca2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0107ca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ca8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107caf:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cb2:	01 d0                	add    %edx,%eax
f0107cb4:	8b 00                	mov    (%eax),%eax
f0107cb6:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107cb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107cbc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107cc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ccd:	c1 e8 0c             	shr    $0xc,%eax
f0107cd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107cd3:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0107cd8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107cdb:	72 17                	jb     f0107cf4 <boot_get_page_table+0x5e>
f0107cdd:	ff 75 e8             	pushl  -0x18(%ebp)
f0107ce0:	68 68 5d 12 f0       	push   $0xf0125d68
f0107ce5:	68 33 01 00 00       	push   $0x133
f0107cea:	68 20 5d 12 f0       	push   $0xf0125d20
f0107cef:	e8 45 86 ff ff       	call   f0100339 <_panic>
f0107cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107cf7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107cfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107cff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107d03:	75 72                	jne    f0107d77 <boot_get_page_table+0xe1>
	{
		if (create)
f0107d05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107d09:	74 65                	je     f0107d70 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107d0b:	83 ec 08             	sub    $0x8,%esp
f0107d0e:	68 00 10 00 00       	push   $0x1000
f0107d13:	68 00 10 00 00       	push   $0x1000
f0107d18:	e8 91 fe ff ff       	call   f0107bae <boot_allocate_space>
f0107d1d:	83 c4 10             	add    $0x10,%esp
f0107d20:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f0107d23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d26:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107d29:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107d30:	77 17                	ja     f0107d49 <boot_get_page_table+0xb3>
f0107d32:	ff 75 dc             	pushl  -0x24(%ebp)
f0107d35:	68 ec 5c 12 f0       	push   $0xf0125cec
f0107d3a:	68 39 01 00 00       	push   $0x139
f0107d3f:	68 20 5d 12 f0       	push   $0xf0125d20
f0107d44:	e8 f0 85 ff ff       	call   f0100339 <_panic>
f0107d49:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d4c:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d51:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107d5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d61:	01 d0                	add    %edx,%eax
f0107d63:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107d66:	83 ca 03             	or     $0x3,%edx
f0107d69:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107d6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d6e:	eb 0a                	jmp    f0107d7a <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107d70:	b8 00 00 00 00       	mov    $0x0,%eax
f0107d75:	eb 03                	jmp    f0107d7a <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107d77:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107d7a:	c9                   	leave  
f0107d7b:	c3                   	ret    

f0107d7c <nvram_read>:


int nvram_read(int r)
{
f0107d7c:	55                   	push   %ebp
f0107d7d:	89 e5                	mov    %esp,%ebp
f0107d7f:	53                   	push   %ebx
f0107d80:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107d83:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d86:	83 ec 0c             	sub    $0xc,%esp
f0107d89:	50                   	push   %eax
f0107d8a:	e8 eb cf ff ff       	call   f0104d7a <mc146818_read>
f0107d8f:	83 c4 10             	add    $0x10,%esp
f0107d92:	89 c3                	mov    %eax,%ebx
f0107d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d97:	40                   	inc    %eax
f0107d98:	83 ec 0c             	sub    $0xc,%esp
f0107d9b:	50                   	push   %eax
f0107d9c:	e8 d9 cf ff ff       	call   f0104d7a <mc146818_read>
f0107da1:	83 c4 10             	add    $0x10,%esp
f0107da4:	c1 e0 08             	shl    $0x8,%eax
f0107da7:	09 d8                	or     %ebx,%eax
}
f0107da9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107dac:	c9                   	leave  
f0107dad:	c3                   	ret    

f0107dae <detect_memory>:

void detect_memory()
{
f0107dae:	55                   	push   %ebp
f0107daf:	89 e5                	mov    %esp,%ebp
f0107db1:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107db4:	83 ec 0c             	sub    $0xc,%esp
f0107db7:	6a 15                	push   $0x15
f0107db9:	e8 be ff ff ff       	call   f0107d7c <nvram_read>
f0107dbe:	83 c4 10             	add    $0x10,%esp
f0107dc1:	c1 e0 0a             	shl    $0xa,%eax
f0107dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107dc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107dcf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107dd2:	83 ec 0c             	sub    $0xc,%esp
f0107dd5:	6a 17                	push   $0x17
f0107dd7:	e8 a0 ff ff ff       	call   f0107d7c <nvram_read>
f0107ddc:	83 c4 10             	add    $0x10,%esp
f0107ddf:	c1 e0 0a             	shl    $0xa,%eax
f0107de2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107de5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107de8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ded:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107df0:	83 ec 0c             	sub    $0xc,%esp
f0107df3:	6a 34                	push   $0x34
f0107df5:	e8 82 ff ff ff       	call   f0107d7c <nvram_read>
f0107dfa:	83 c4 10             	add    $0x10,%esp
f0107dfd:	c1 e0 10             	shl    $0x10,%eax
f0107e00:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107e03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107e06:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107e0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107e0e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107e12:	74 18                	je     f0107e2c <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107e14:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107e17:	05 00 00 00 01       	add    $0x1000000,%eax
f0107e1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107e1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e22:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107e27:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107e2a:	eb 19                	jmp    f0107e45 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107e30:	74 0d                	je     f0107e3f <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e35:	05 00 00 10 00       	add    $0x100000,%eax
f0107e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107e3d:	eb 06                	jmp    f0107e45 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107e3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e42:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107e45:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e4f:	c1 e8 0c             	shr    $0xc,%eax
f0107e52:	a3 18 f3 b1 f0       	mov    %eax,0xf0b1f318

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e5a:	c1 e8 0a             	shr    $0xa,%eax
f0107e5d:	83 ec 08             	sub    $0x8,%esp
f0107e60:	50                   	push   %eax
f0107e61:	68 98 5d 12 f0       	push   $0xf0125d98
f0107e66:	e8 20 91 ff ff       	call   f0100f8b <cprintf>
f0107e6b:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107e6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e71:	c1 e8 0a             	shr    $0xa,%eax
f0107e74:	89 c2                	mov    %eax,%edx
f0107e76:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107e79:	c1 e8 0a             	shr    $0xa,%eax
f0107e7c:	83 ec 04             	sub    $0x4,%esp
f0107e7f:	52                   	push   %edx
f0107e80:	50                   	push   %eax
f0107e81:	68 bb 5d 12 f0       	push   $0xf0125dbb
f0107e86:	e8 00 91 ff ff       	call   f0100f8b <cprintf>
f0107e8b:	83 c4 10             	add    $0x10,%esp
}
f0107e8e:	90                   	nop
f0107e8f:	c9                   	leave  
f0107e90:	c3                   	ret    

f0107e91 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107e91:	55                   	push   %ebp
f0107e92:	89 e5                	mov    %esp,%ebp
f0107e94:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107e97:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107e9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ea5:	eb 24                	jmp    f0107ecb <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107ea7:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107eac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107eaf:	c1 e2 02             	shl    $0x2,%edx
f0107eb2:	01 c2                	add    %eax,%edx
f0107eb4:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107eb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107ebc:	c1 e1 02             	shl    $0x2,%ecx
f0107ebf:	01 c8                	add    %ecx,%eax
f0107ec1:	8b 00                	mov    (%eax),%eax
f0107ec3:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ec5:	ff 45 f4             	incl   -0xc(%ebp)
f0107ec8:	ff 45 f0             	incl   -0x10(%ebp)
f0107ecb:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107ed0:	c1 e8 16             	shr    $0x16,%eax
f0107ed3:	89 c2                	mov    %eax,%edx
f0107ed5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ed8:	39 c2                	cmp    %eax,%edx
f0107eda:	77 cb                	ja     f0107ea7 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107edc:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0107ee1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107ee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107ee7:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107eea:	0f 20 c0             	mov    %cr0,%eax
f0107eed:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107ef0:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107ef3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107ef6:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107efd:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107f01:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107f04:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107f0a:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107f0d:	e8 e8 f5 ff ff       	call   f01074fa <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107f12:	e8 20 f5 ff ff       	call   f0107437 <mycpu>
f0107f17:	83 c0 74             	add    $0x74,%eax
f0107f1a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107f1d:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107f27:	48                   	dec    %eax
f0107f28:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107f2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f2f:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107f33:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f36:	c1 e8 10             	shr    $0x10,%eax
f0107f39:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107f3d:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107f40:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107f43:	e8 04 f6 ff ff       	call   f010754c <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107f48:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f4d:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107f4f:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f54:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107f56:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f5b:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107f5d:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f62:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107f64:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f69:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107f6b:	ea 72 7f 10 f0 08 00 	ljmp   $0x8,$0xf0107f72
	asm volatile("lldt %%ax" :: "a" (0));
f0107f72:	b8 00 00 00 00       	mov    $0x0,%eax
f0107f77:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107f7a:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107f81:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f88:	eb 19                	jmp    f0107fa3 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107f8a:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107f8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107f92:	c1 e2 02             	shl    $0x2,%edx
f0107f95:	01 d0                	add    %edx,%eax
f0107f97:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f9d:	ff 45 ec             	incl   -0x14(%ebp)
f0107fa0:	ff 45 e8             	incl   -0x18(%ebp)
f0107fa3:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0107fa8:	c1 e8 16             	shr    $0x16,%eax
f0107fab:	89 c2                	mov    %eax,%edx
f0107fad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107fb0:	39 c2                	cmp    %eax,%edx
f0107fb2:	77 d6                	ja     f0107f8a <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107fb4:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0107fb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fbf:	0f 22 d8             	mov    %eax,%cr3

}
f0107fc2:	90                   	nop
f0107fc3:	c9                   	leave  
f0107fc4:	c3                   	ret    

f0107fc5 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107fc5:	55                   	push   %ebp
f0107fc6:	89 e5                	mov    %esp,%ebp
f0107fc8:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107fcb:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0107fd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107fd3:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107fda:	77 17                	ja     f0107ff3 <setup_listing_to_all_page_tables_entries+0x2e>
f0107fdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0107fdf:	68 ec 5c 12 f0       	push   $0xf0125cec
f0107fe4:	68 cf 01 00 00       	push   $0x1cf
f0107fe9:	68 20 5d 12 f0       	push   $0xf0125d20
f0107fee:	e8 46 83 ff ff       	call   f0100339 <_panic>
f0107ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ff6:	05 00 00 00 10       	add    $0x10000000,%eax
f0107ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107ffe:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0108003:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108008:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010800b:	83 ca 03             	or     $0x3,%edx
f010800e:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108010:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0108015:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010801b:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0108020:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108023:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f010802a:	77 17                	ja     f0108043 <setup_listing_to_all_page_tables_entries+0x7e>
f010802c:	ff 75 ec             	pushl  -0x14(%ebp)
f010802f:	68 ec 5c 12 f0       	push   $0xf0125cec
f0108034:	68 d4 01 00 00       	push   $0x1d4
f0108039:	68 20 5d 12 f0       	push   $0xf0125d20
f010803e:	e8 f6 82 ff ff       	call   f0100339 <_panic>
f0108043:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108046:	05 00 00 00 10       	add    $0x10000000,%eax
f010804b:	83 c8 05             	or     $0x5,%eax
f010804e:	89 02                	mov    %eax,(%edx)

}
f0108050:	90                   	nop
f0108051:	c9                   	leave  
f0108052:	c3                   	ret    

f0108053 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108053:	55                   	push   %ebp
f0108054:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108056:	8b 45 08             	mov    0x8(%ebp),%eax
f0108059:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f010805f:	29 d0                	sub    %edx,%eax
f0108061:	c1 f8 03             	sar    $0x3,%eax
f0108064:	89 c2                	mov    %eax,%edx
f0108066:	89 d0                	mov    %edx,%eax
f0108068:	c1 e0 02             	shl    $0x2,%eax
f010806b:	01 d0                	add    %edx,%eax
f010806d:	c1 e0 02             	shl    $0x2,%eax
f0108070:	01 d0                	add    %edx,%eax
f0108072:	c1 e0 02             	shl    $0x2,%eax
f0108075:	01 d0                	add    %edx,%eax
f0108077:	89 c1                	mov    %eax,%ecx
f0108079:	c1 e1 08             	shl    $0x8,%ecx
f010807c:	01 c8                	add    %ecx,%eax
f010807e:	89 c1                	mov    %eax,%ecx
f0108080:	c1 e1 10             	shl    $0x10,%ecx
f0108083:	01 c8                	add    %ecx,%eax
f0108085:	01 c0                	add    %eax,%eax
f0108087:	01 d0                	add    %edx,%eax
}
f0108089:	5d                   	pop    %ebp
f010808a:	c3                   	ret    

f010808b <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010808b:	55                   	push   %ebp
f010808c:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010808e:	ff 75 08             	pushl  0x8(%ebp)
f0108091:	e8 bd ff ff ff       	call   f0108053 <to_frame_number>
f0108096:	83 c4 04             	add    $0x4,%esp
f0108099:	c1 e0 0c             	shl    $0xc,%eax
}
f010809c:	c9                   	leave  
f010809d:	c3                   	ret    

f010809e <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010809e:	55                   	push   %ebp
f010809f:	89 e5                	mov    %esp,%ebp
f01080a1:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01080a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01080a7:	c1 e8 0c             	shr    $0xc,%eax
f01080aa:	89 c2                	mov    %eax,%edx
f01080ac:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f01080b1:	39 c2                	cmp    %eax,%edx
f01080b3:	72 14                	jb     f01080c9 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01080b5:	83 ec 04             	sub    $0x4,%esp
f01080b8:	68 d8 5d 12 f0       	push   $0xf0125dd8
f01080bd:	6a 56                	push   $0x56
f01080bf:	68 fd 5d 12 f0       	push   $0xf0125dfd
f01080c4:	e8 70 82 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f01080c9:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f01080cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d2:	c1 e8 0c             	shr    $0xc,%eax
f01080d5:	89 c1                	mov    %eax,%ecx
f01080d7:	89 c8                	mov    %ecx,%eax
f01080d9:	01 c0                	add    %eax,%eax
f01080db:	01 c8                	add    %ecx,%eax
f01080dd:	c1 e0 03             	shl    $0x3,%eax
f01080e0:	01 d0                	add    %edx,%eax
}
f01080e2:	c9                   	leave  
f01080e3:	c3                   	ret    

f01080e4 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f01080e4:	55                   	push   %ebp
f01080e5:	89 e5                	mov    %esp,%ebp
f01080e7:	83 ec 10             	sub    $0x10,%esp
f01080ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01080ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f01080f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01080f3:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f01080f6:	90                   	nop
f01080f7:	c9                   	leave  
f01080f8:	c3                   	ret    

f01080f9 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f01080f9:	55                   	push   %ebp
f01080fa:	89 e5                	mov    %esp,%ebp
f01080fc:	53                   	push   %ebx
f01080fd:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108100:	c7 05 20 f1 b1 f0 00 	movl   $0x0,0xf0b1f120
f0108107:	00 00 00 
f010810a:	c7 05 24 f1 b1 f0 00 	movl   $0x0,0xf0b1f124
f0108111:	00 00 00 
f0108114:	c7 05 2c f1 b1 f0 00 	movl   $0x0,0xf0b1f12c
f010811b:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f010811e:	c7 05 30 f1 b1 f0 00 	movl   $0x0,0xf0b1f130
f0108125:	00 00 00 
f0108128:	c7 05 34 f1 b1 f0 00 	movl   $0x0,0xf0b1f134
f010812f:	00 00 00 
f0108132:	c7 05 3c f1 b1 f0 00 	movl   $0x0,0xf0b1f13c
f0108139:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f010813c:	83 ec 08             	sub    $0x8,%esp
f010813f:	68 17 5e 12 f0       	push   $0xf0125e17
f0108144:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108149:	e8 7f 7d 00 00       	call   f010fecd <init_spinlock>
f010814e:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108151:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f0108156:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f010815c:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f0108161:	83 c0 18             	add    $0x18,%eax
f0108164:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f010816a:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f010816f:	83 c0 30             	add    $0x30,%eax
f0108172:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108178:	c7 05 1c f6 b1 f0 00 	movl   $0xf0001000,0xf0b1f61c
f010817f:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108182:	c7 05 ec f7 f1 f0 00 	movl   $0xf0002000,0xf0f1f7ec
f0108189:	20 00 f0 
	i =0;
f010818c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108193:	eb 1f                	jmp    f01081b4 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108195:	8b 15 1c f6 b1 f0    	mov    0xf0b1f61c,%edx
f010819b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010819e:	01 d0                	add    %edx,%eax
f01081a0:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f01081a3:	8b 15 ec f7 f1 f0    	mov    0xf0f1f7ec,%edx
f01081a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081ac:	01 d0                	add    %edx,%eax
f01081ae:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f01081b1:	ff 45 f4             	incl   -0xc(%ebp)
f01081b4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01081bb:	7e d8                	jle    f0108195 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f01081bd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01081c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01081c7:	05 ff ff 09 00       	add    $0x9ffff,%eax
f01081cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01081cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081d2:	ba 00 00 00 00       	mov    $0x0,%edx
f01081d7:	f7 75 f0             	divl   -0x10(%ebp)
f01081da:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081dd:	29 d0                	sub    %edx,%eax
f01081df:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01081e2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f01081e9:	e9 e8 00 00 00       	jmp    f01082d6 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f01081ee:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01081f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01081f7:	89 d0                	mov    %edx,%eax
f01081f9:	01 c0                	add    %eax,%eax
f01081fb:	01 d0                	add    %edx,%eax
f01081fd:	c1 e0 03             	shl    $0x3,%eax
f0108200:	01 c8                	add    %ecx,%eax
f0108202:	83 ec 0c             	sub    $0xc,%esp
f0108205:	50                   	push   %eax
f0108206:	e8 b7 02 00 00       	call   f01084c2 <initialize_frame_info>
f010820b:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010820e:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108214:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108217:	89 d0                	mov    %edx,%eax
f0108219:	01 c0                	add    %eax,%eax
f010821b:	01 d0                	add    %edx,%eax
f010821d:	c1 e0 03             	shl    $0x3,%eax
f0108220:	01 c8                	add    %ecx,%eax
f0108222:	85 c0                	test   %eax,%eax
f0108224:	75 14                	jne    f010823a <initialize_paging+0x141>
f0108226:	83 ec 04             	sub    $0x4,%esp
f0108229:	68 28 5e 12 f0       	push   $0xf0125e28
f010822e:	6a 60                	push   $0x60
f0108230:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108235:	e8 ff 80 ff ff       	call   f0100339 <_panic>
f010823a:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108240:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108243:	89 d0                	mov    %edx,%eax
f0108245:	01 c0                	add    %eax,%eax
f0108247:	01 d0                	add    %edx,%eax
f0108249:	c1 e0 03             	shl    $0x3,%eax
f010824c:	01 c8                	add    %ecx,%eax
f010824e:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108254:	89 10                	mov    %edx,(%eax)
f0108256:	8b 00                	mov    (%eax),%eax
f0108258:	85 c0                	test   %eax,%eax
f010825a:	74 1f                	je     f010827b <initialize_paging+0x182>
f010825c:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108262:	8b 1d 80 f5 b1 f0    	mov    0xf0b1f580,%ebx
f0108268:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010826b:	89 c8                	mov    %ecx,%eax
f010826d:	01 c0                	add    %eax,%eax
f010826f:	01 c8                	add    %ecx,%eax
f0108271:	c1 e0 03             	shl    $0x3,%eax
f0108274:	01 d8                	add    %ebx,%eax
f0108276:	89 42 04             	mov    %eax,0x4(%edx)
f0108279:	eb 19                	jmp    f0108294 <initialize_paging+0x19b>
f010827b:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108281:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108284:	89 d0                	mov    %edx,%eax
f0108286:	01 c0                	add    %eax,%eax
f0108288:	01 d0                	add    %edx,%eax
f010828a:	c1 e0 03             	shl    $0x3,%eax
f010828d:	01 c8                	add    %ecx,%eax
f010828f:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f0108294:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010829a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010829d:	89 d0                	mov    %edx,%eax
f010829f:	01 c0                	add    %eax,%eax
f01082a1:	01 d0                	add    %edx,%eax
f01082a3:	c1 e0 03             	shl    $0x3,%eax
f01082a6:	01 c8                	add    %ecx,%eax
f01082a8:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01082ad:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01082b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01082b6:	89 d0                	mov    %edx,%eax
f01082b8:	01 c0                	add    %eax,%eax
f01082ba:	01 d0                	add    %edx,%eax
f01082bc:	c1 e0 03             	shl    $0x3,%eax
f01082bf:	01 c8                	add    %ecx,%eax
f01082c1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082c8:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01082cd:	40                   	inc    %eax
f01082ce:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01082d3:	ff 45 f4             	incl   -0xc(%ebp)
f01082d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01082d9:	85 c0                	test   %eax,%eax
f01082db:	79 05                	jns    f01082e2 <initialize_paging+0x1e9>
f01082dd:	05 ff 0f 00 00       	add    $0xfff,%eax
f01082e2:	c1 f8 0c             	sar    $0xc,%eax
f01082e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01082e8:	0f 8f 00 ff ff ff    	jg     f01081ee <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01082ee:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f01082f5:	eb 1d                	jmp    f0108314 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f01082f7:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01082fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108300:	89 d0                	mov    %edx,%eax
f0108302:	01 c0                	add    %eax,%eax
f0108304:	01 d0                	add    %edx,%eax
f0108306:	c1 e0 03             	shl    $0x3,%eax
f0108309:	01 c8                	add    %ecx,%eax
f010830b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108311:	ff 45 f4             	incl   -0xc(%ebp)
f0108314:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010831b:	7e da                	jle    f01082f7 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f010831d:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108324:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f0108329:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010832c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108333:	77 14                	ja     f0108349 <initialize_paging+0x250>
f0108335:	ff 75 e0             	pushl  -0x20(%ebp)
f0108338:	68 68 5e 12 f0       	push   $0xf0125e68
f010833d:	6a 68                	push   $0x68
f010833f:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108344:	e8 f0 7f ff ff       	call   f0100339 <_panic>
f0108349:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010834c:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108355:	01 d0                	add    %edx,%eax
f0108357:	48                   	dec    %eax
f0108358:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010835b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010835e:	ba 00 00 00 00       	mov    $0x0,%edx
f0108363:	f7 75 e4             	divl   -0x1c(%ebp)
f0108366:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108369:	29 d0                	sub    %edx,%eax
f010836b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f010836e:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108375:	eb 1d                	jmp    f0108394 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0108377:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010837d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108380:	89 d0                	mov    %edx,%eax
f0108382:	01 c0                	add    %eax,%eax
f0108384:	01 d0                	add    %edx,%eax
f0108386:	c1 e0 03             	shl    $0x3,%eax
f0108389:	01 c8                	add    %ecx,%eax
f010838b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108391:	ff 45 f4             	incl   -0xc(%ebp)
f0108394:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108397:	85 c0                	test   %eax,%eax
f0108399:	79 05                	jns    f01083a0 <initialize_paging+0x2a7>
f010839b:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083a0:	c1 f8 0c             	sar    $0xc,%eax
f01083a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01083a6:	7f cf                	jg     f0108377 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01083a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083ab:	85 c0                	test   %eax,%eax
f01083ad:	79 05                	jns    f01083b4 <initialize_paging+0x2bb>
f01083af:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083b4:	c1 f8 0c             	sar    $0xc,%eax
f01083b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01083ba:	e9 e8 00 00 00       	jmp    f01084a7 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f01083bf:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01083c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083c8:	89 d0                	mov    %edx,%eax
f01083ca:	01 c0                	add    %eax,%eax
f01083cc:	01 d0                	add    %edx,%eax
f01083ce:	c1 e0 03             	shl    $0x3,%eax
f01083d1:	01 c8                	add    %ecx,%eax
f01083d3:	83 ec 0c             	sub    $0xc,%esp
f01083d6:	50                   	push   %eax
f01083d7:	e8 e6 00 00 00       	call   f01084c2 <initialize_frame_info>
f01083dc:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01083df:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01083e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083e8:	89 d0                	mov    %edx,%eax
f01083ea:	01 c0                	add    %eax,%eax
f01083ec:	01 d0                	add    %edx,%eax
f01083ee:	c1 e0 03             	shl    $0x3,%eax
f01083f1:	01 c8                	add    %ecx,%eax
f01083f3:	85 c0                	test   %eax,%eax
f01083f5:	75 14                	jne    f010840b <initialize_paging+0x312>
f01083f7:	83 ec 04             	sub    $0x4,%esp
f01083fa:	68 28 5e 12 f0       	push   $0xf0125e28
f01083ff:	6a 74                	push   $0x74
f0108401:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108406:	e8 2e 7f ff ff       	call   f0100339 <_panic>
f010840b:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108411:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108414:	89 d0                	mov    %edx,%eax
f0108416:	01 c0                	add    %eax,%eax
f0108418:	01 d0                	add    %edx,%eax
f010841a:	c1 e0 03             	shl    $0x3,%eax
f010841d:	01 c8                	add    %ecx,%eax
f010841f:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108425:	89 10                	mov    %edx,(%eax)
f0108427:	8b 00                	mov    (%eax),%eax
f0108429:	85 c0                	test   %eax,%eax
f010842b:	74 1f                	je     f010844c <initialize_paging+0x353>
f010842d:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108433:	8b 1d 80 f5 b1 f0    	mov    0xf0b1f580,%ebx
f0108439:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010843c:	89 c8                	mov    %ecx,%eax
f010843e:	01 c0                	add    %eax,%eax
f0108440:	01 c8                	add    %ecx,%eax
f0108442:	c1 e0 03             	shl    $0x3,%eax
f0108445:	01 d8                	add    %ebx,%eax
f0108447:	89 42 04             	mov    %eax,0x4(%edx)
f010844a:	eb 19                	jmp    f0108465 <initialize_paging+0x36c>
f010844c:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108452:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108455:	89 d0                	mov    %edx,%eax
f0108457:	01 c0                	add    %eax,%eax
f0108459:	01 d0                	add    %edx,%eax
f010845b:	c1 e0 03             	shl    $0x3,%eax
f010845e:	01 c8                	add    %ecx,%eax
f0108460:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f0108465:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010846b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010846e:	89 d0                	mov    %edx,%eax
f0108470:	01 c0                	add    %eax,%eax
f0108472:	01 d0                	add    %edx,%eax
f0108474:	c1 e0 03             	shl    $0x3,%eax
f0108477:	01 c8                	add    %ecx,%eax
f0108479:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f010847e:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108487:	89 d0                	mov    %edx,%eax
f0108489:	01 c0                	add    %eax,%eax
f010848b:	01 d0                	add    %edx,%eax
f010848d:	c1 e0 03             	shl    $0x3,%eax
f0108490:	01 c8                	add    %ecx,%eax
f0108492:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108499:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010849e:	40                   	inc    %eax
f010849f:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01084a4:	ff 45 f4             	incl   -0xc(%ebp)
f01084a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01084aa:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f01084af:	39 c2                	cmp    %eax,%edx
f01084b1:	0f 82 08 ff ff ff    	jb     f01083bf <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f01084b7:	e8 c9 b9 ff ff       	call   f0103e85 <initialize_disk_page_file>
}
f01084bc:	90                   	nop
f01084bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01084c0:	c9                   	leave  
f01084c1:	c3                   	ret    

f01084c2 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f01084c2:	55                   	push   %ebp
f01084c3:	89 e5                	mov    %esp,%ebp
f01084c5:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f01084c8:	83 ec 04             	sub    $0x4,%esp
f01084cb:	6a 18                	push   $0x18
f01084cd:	6a 00                	push   $0x0
f01084cf:	ff 75 08             	pushl  0x8(%ebp)
f01084d2:	e8 c3 7b 01 00       	call   f012009a <memset>
f01084d7:	83 c4 10             	add    $0x10,%esp
}
f01084da:	90                   	nop
f01084db:	c9                   	leave  
f01084dc:	c3                   	ret    

f01084dd <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01084dd:	55                   	push   %ebp
f01084de:	89 e5                	mov    %esp,%ebp
f01084e0:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01084e3:	83 ec 0c             	sub    $0xc,%esp
f01084e6:	68 40 f1 b1 f0       	push   $0xf0b1f140
f01084eb:	e8 27 7c 00 00       	call   f0110117 <holding_spinlock>
f01084f0:	83 c4 10             	add    $0x10,%esp
f01084f3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01084f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01084fa:	75 10                	jne    f010850c <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01084fc:	83 ec 0c             	sub    $0xc,%esp
f01084ff:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108504:	e8 f5 79 00 00       	call   f010fefe <acquire_spinlock>
f0108509:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f010850c:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108512:	8b 45 08             	mov    0x8(%ebp),%eax
f0108515:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0108517:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f010851e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108521:	8b 00                	mov    (%eax),%eax
f0108523:	85 c0                	test   %eax,%eax
f0108525:	75 17                	jne    f010853e <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0108527:	83 ec 04             	sub    $0x4,%esp
f010852a:	68 9c 5e 12 f0       	push   $0xf0125e9c
f010852f:	68 a2 00 00 00       	push   $0xa2
f0108534:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108539:	e8 fb 7d ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f010853e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108541:	8b 00                	mov    (%eax),%eax
f0108543:	85 c0                	test   %eax,%eax
f0108545:	75 17                	jne    f010855e <allocate_frame+0x81>
f0108547:	83 ec 04             	sub    $0x4,%esp
f010854a:	68 e9 5e 12 f0       	push   $0xf0125ee9
f010854f:	68 a8 00 00 00       	push   $0xa8
f0108554:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108559:	e8 db 7d ff ff       	call   f0100339 <_panic>
f010855e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108561:	8b 00                	mov    (%eax),%eax
f0108563:	8b 00                	mov    (%eax),%eax
f0108565:	85 c0                	test   %eax,%eax
f0108567:	74 14                	je     f010857d <allocate_frame+0xa0>
f0108569:	8b 45 08             	mov    0x8(%ebp),%eax
f010856c:	8b 00                	mov    (%eax),%eax
f010856e:	8b 00                	mov    (%eax),%eax
f0108570:	8b 55 08             	mov    0x8(%ebp),%edx
f0108573:	8b 12                	mov    (%edx),%edx
f0108575:	8b 52 04             	mov    0x4(%edx),%edx
f0108578:	89 50 04             	mov    %edx,0x4(%eax)
f010857b:	eb 0d                	jmp    f010858a <allocate_frame+0xad>
f010857d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108580:	8b 00                	mov    (%eax),%eax
f0108582:	8b 40 04             	mov    0x4(%eax),%eax
f0108585:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f010858a:	8b 45 08             	mov    0x8(%ebp),%eax
f010858d:	8b 00                	mov    (%eax),%eax
f010858f:	8b 40 04             	mov    0x4(%eax),%eax
f0108592:	85 c0                	test   %eax,%eax
f0108594:	74 13                	je     f01085a9 <allocate_frame+0xcc>
f0108596:	8b 45 08             	mov    0x8(%ebp),%eax
f0108599:	8b 00                	mov    (%eax),%eax
f010859b:	8b 40 04             	mov    0x4(%eax),%eax
f010859e:	8b 55 08             	mov    0x8(%ebp),%edx
f01085a1:	8b 12                	mov    (%edx),%edx
f01085a3:	8b 12                	mov    (%edx),%edx
f01085a5:	89 10                	mov    %edx,(%eax)
f01085a7:	eb 0c                	jmp    f01085b5 <allocate_frame+0xd8>
f01085a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ac:	8b 00                	mov    (%eax),%eax
f01085ae:	8b 00                	mov    (%eax),%eax
f01085b0:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01085b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01085b8:	8b 00                	mov    (%eax),%eax
f01085ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01085c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01085c3:	8b 00                	mov    (%eax),%eax
f01085c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01085cc:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01085d1:	48                   	dec    %eax
f01085d2:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01085d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01085da:	8b 00                	mov    (%eax),%eax
f01085dc:	8a 40 14             	mov    0x14(%eax),%al
f01085df:	84 c0                	test   %al,%al
f01085e1:	74 20                	je     f0108603 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01085e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01085e6:	8b 00                	mov    (%eax),%eax
f01085e8:	8b 50 10             	mov    0x10(%eax),%edx
f01085eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ee:	8b 00                	mov    (%eax),%eax
f01085f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01085f3:	8b 40 64             	mov    0x64(%eax),%eax
f01085f6:	83 ec 08             	sub    $0x8,%esp
f01085f9:	52                   	push   %edx
f01085fa:	50                   	push   %eax
f01085fb:	e8 01 1a 00 00       	call   f010a001 <pt_clear_page_table_entry>
f0108600:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0108603:	8b 45 08             	mov    0x8(%ebp),%eax
f0108606:	8b 00                	mov    (%eax),%eax
f0108608:	83 ec 0c             	sub    $0xc,%esp
f010860b:	50                   	push   %eax
f010860c:	e8 b1 fe ff ff       	call   f01084c2 <initialize_frame_info>
f0108611:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108614:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108618:	75 10                	jne    f010862a <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010861a:	83 ec 0c             	sub    $0xc,%esp
f010861d:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108622:	e8 5e 79 00 00       	call   f010ff85 <release_spinlock>
f0108627:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010862a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010862f:	c9                   	leave  
f0108630:	c3                   	ret    

f0108631 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108631:	55                   	push   %ebp
f0108632:	89 e5                	mov    %esp,%ebp
f0108634:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0108637:	83 ec 0c             	sub    $0xc,%esp
f010863a:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010863f:	e8 d3 7a 00 00       	call   f0110117 <holding_spinlock>
f0108644:	83 c4 10             	add    $0x10,%esp
f0108647:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010864a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010864e:	75 10                	jne    f0108660 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108650:	83 ec 0c             	sub    $0xc,%esp
f0108653:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108658:	e8 a1 78 00 00       	call   f010fefe <acquire_spinlock>
f010865d:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108660:	83 ec 0c             	sub    $0xc,%esp
f0108663:	ff 75 08             	pushl  0x8(%ebp)
f0108666:	e8 57 fe ff ff       	call   f01084c2 <initialize_frame_info>
f010866b:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f010866e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108672:	75 17                	jne    f010868b <free_frame+0x5a>
f0108674:	83 ec 04             	sub    $0x4,%esp
f0108677:	68 28 5e 12 f0       	push   $0xf0125e28
f010867c:	68 cf 00 00 00       	push   $0xcf
f0108681:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108686:	e8 ae 7c ff ff       	call   f0100339 <_panic>
f010868b:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108691:	8b 45 08             	mov    0x8(%ebp),%eax
f0108694:	89 10                	mov    %edx,(%eax)
f0108696:	8b 45 08             	mov    0x8(%ebp),%eax
f0108699:	8b 00                	mov    (%eax),%eax
f010869b:	85 c0                	test   %eax,%eax
f010869d:	74 0d                	je     f01086ac <free_frame+0x7b>
f010869f:	a1 20 f1 b1 f0       	mov    0xf0b1f120,%eax
f01086a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01086a7:	89 50 04             	mov    %edx,0x4(%eax)
f01086aa:	eb 08                	jmp    f01086b4 <free_frame+0x83>
f01086ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01086af:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f01086b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01086b7:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01086bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01086bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01086c6:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01086cb:	40                   	inc    %eax
f01086cc:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01086d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01086d5:	75 10                	jne    f01086e7 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01086d7:	83 ec 0c             	sub    $0xc,%esp
f01086da:	68 40 f1 b1 f0       	push   $0xf0b1f140
f01086df:	e8 a1 78 00 00       	call   f010ff85 <release_spinlock>
f01086e4:	83 c4 10             	add    $0x10,%esp
	}
}
f01086e7:	90                   	nop
f01086e8:	c9                   	leave  
f01086e9:	c3                   	ret    

f01086ea <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01086ea:	55                   	push   %ebp
f01086eb:	89 e5                	mov    %esp,%ebp
f01086ed:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01086f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01086f3:	8b 40 08             	mov    0x8(%eax),%eax
f01086f6:	48                   	dec    %eax
f01086f7:	8b 55 08             	mov    0x8(%ebp),%edx
f01086fa:	66 89 42 08          	mov    %ax,0x8(%edx)
f01086fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0108701:	8b 40 08             	mov    0x8(%eax),%eax
f0108704:	66 85 c0             	test   %ax,%ax
f0108707:	75 0e                	jne    f0108717 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108709:	83 ec 0c             	sub    $0xc,%esp
f010870c:	ff 75 08             	pushl  0x8(%ebp)
f010870f:	e8 1d ff ff ff       	call   f0108631 <free_frame>
f0108714:	83 c4 10             	add    $0x10,%esp
}
f0108717:	90                   	nop
f0108718:	c9                   	leave  
f0108719:	c3                   	ret    

f010871a <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010871a:	55                   	push   %ebp
f010871b:	89 e5                	mov    %esp,%ebp
f010871d:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108720:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108723:	c1 e8 16             	shr    $0x16,%eax
f0108726:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010872d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0108737:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010873a:	83 e0 01             	and    $0x1,%eax
f010873d:	85 c0                	test   %eax,%eax
f010873f:	74 74                	je     f01087b5 <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108741:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108748:	77 1d                	ja     f0108767 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010874d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108752:	83 ec 0c             	sub    $0xc,%esp
f0108755:	50                   	push   %eax
f0108756:	e8 02 14 00 00       	call   f0109b5d <kheap_virtual_address>
f010875b:	83 c4 10             	add    $0x10,%esp
f010875e:	89 c2                	mov    %eax,%edx
f0108760:	8b 45 10             	mov    0x10(%ebp),%eax
f0108763:	89 10                	mov    %edx,(%eax)
f0108765:	eb 44                	jmp    f01087ab <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108767:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010876a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010876f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108772:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108775:	c1 e8 0c             	shr    $0xc,%eax
f0108778:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010877b:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108780:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108783:	72 17                	jb     f010879c <get_page_table+0x82>
f0108785:	ff 75 f0             	pushl  -0x10(%ebp)
f0108788:	68 08 5f 12 f0       	push   $0xf0125f08
f010878d:	68 fb 00 00 00       	push   $0xfb
f0108792:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108797:	e8 9d 7b ff ff       	call   f0100339 <_panic>
f010879c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010879f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01087a4:	89 c2                	mov    %eax,%edx
f01087a6:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a9:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01087ab:	b8 00 00 00 00       	mov    $0x0,%eax
f01087b0:	e9 b9 00 00 00       	jmp    f010886e <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01087b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01087b9:	0f 84 a1 00 00 00    	je     f0108860 <get_page_table+0x146>
f01087bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087c2:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01087c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01087c8:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01087cb:	83 ec 0c             	sub    $0xc,%esp
f01087ce:	6a 00                	push   $0x0
f01087d0:	e8 bb 71 00 00       	call   f010f990 <fault_handler>
f01087d5:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01087d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087db:	c1 e8 16             	shr    $0x16,%eax
f01087de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01087e8:	01 d0                	add    %edx,%eax
f01087ea:	8b 00                	mov    (%eax),%eax
f01087ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01087ef:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01087f6:	77 1d                	ja     f0108815 <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01087f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108800:	83 ec 0c             	sub    $0xc,%esp
f0108803:	50                   	push   %eax
f0108804:	e8 54 13 00 00       	call   f0109b5d <kheap_virtual_address>
f0108809:	83 c4 10             	add    $0x10,%esp
f010880c:	89 c2                	mov    %eax,%edx
f010880e:	8b 45 10             	mov    0x10(%ebp),%eax
f0108811:	89 10                	mov    %edx,(%eax)
f0108813:	eb 44                	jmp    f0108859 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108815:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108818:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010881d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108820:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108823:	c1 e8 0c             	shr    $0xc,%eax
f0108826:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108829:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f010882e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108831:	72 17                	jb     f010884a <get_page_table+0x130>
f0108833:	ff 75 e8             	pushl  -0x18(%ebp)
f0108836:	68 08 5f 12 f0       	push   $0xf0125f08
f010883b:	68 13 01 00 00       	push   $0x113
f0108840:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108845:	e8 ef 7a ff ff       	call   f0100339 <_panic>
f010884a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010884d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108852:	89 c2                	mov    %eax,%edx
f0108854:	8b 45 10             	mov    0x10(%ebp),%eax
f0108857:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0108859:	b8 00 00 00 00       	mov    $0x0,%eax
f010885e:	eb 0e                	jmp    f010886e <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108860:	8b 45 10             	mov    0x10(%ebp),%eax
f0108863:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f0108869:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f010886e:	c9                   	leave  
f010886f:	c3                   	ret    

f0108870 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108870:	55                   	push   %ebp
f0108871:	89 e5                	mov    %esp,%ebp
f0108873:	53                   	push   %ebx
f0108874:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f0108877:	83 ec 0c             	sub    $0xc,%esp
f010887a:	68 00 10 00 00       	push   $0x1000
f010887f:	e8 36 0f 00 00       	call   f01097ba <kmalloc>
f0108884:	83 c4 10             	add    $0x10,%esp
f0108887:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010888a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010888e:	75 17                	jne    f01088a7 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108890:	83 ec 04             	sub    $0x4,%esp
f0108893:	68 37 5f 12 f0       	push   $0xf0125f37
f0108898:	68 33 01 00 00       	push   $0x133
f010889d:	68 4b 5e 12 f0       	push   $0xf0125e4b
f01088a2:	e8 92 7a ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01088a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088aa:	c1 e8 16             	shr    $0x16,%eax
f01088ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088b7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01088ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088bd:	83 ec 0c             	sub    $0xc,%esp
f01088c0:	50                   	push   %eax
f01088c1:	e8 3a 12 00 00       	call   f0109b00 <kheap_physical_address>
f01088c6:	83 c4 10             	add    $0x10,%esp
f01088c9:	83 c8 07             	or     $0x7,%eax
f01088cc:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01088ce:	83 ec 04             	sub    $0x4,%esp
f01088d1:	68 00 10 00 00       	push   $0x1000
f01088d6:	6a 00                	push   $0x0
f01088d8:	ff 75 f4             	pushl  -0xc(%ebp)
f01088db:	e8 ba 77 01 00       	call   f012009a <memset>
f01088e0:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01088e3:	0f 20 d8             	mov    %cr3,%eax
f01088e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01088e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01088ec:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01088ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01088f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01088f5:	c9                   	leave  
f01088f6:	c3                   	ret    

f01088f7 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01088f7:	55                   	push   %ebp
f01088f8:	89 e5                	mov    %esp,%ebp
f01088fa:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01088fd:	83 ec 0c             	sub    $0xc,%esp
f0108900:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108903:	50                   	push   %eax
f0108904:	e8 d4 fb ff ff       	call   f01084dd <allocate_frame>
f0108909:	83 c4 10             	add    $0x10,%esp
f010890c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010890f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108912:	83 ec 0c             	sub    $0xc,%esp
f0108915:	50                   	push   %eax
f0108916:	e8 70 f7 ff ff       	call   f010808b <to_physical_address>
f010891b:	83 c4 10             	add    $0x10,%esp
f010891e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0108921:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108924:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010892a:	c1 e8 0c             	shr    $0xc,%eax
f010892d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108930:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108935:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108938:	72 17                	jb     f0108951 <__static_cpt+0x5a>
f010893a:	ff 75 ec             	pushl  -0x14(%ebp)
f010893d:	68 08 5f 12 f0       	push   $0xf0125f08
f0108942:	68 4e 01 00 00       	push   $0x14e
f0108947:	68 4b 5e 12 f0       	push   $0xf0125e4b
f010894c:	e8 e8 79 ff ff       	call   f0100339 <_panic>
f0108951:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108954:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108959:	89 c2                	mov    %eax,%edx
f010895b:	8b 45 10             	mov    0x10(%ebp),%eax
f010895e:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108960:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108963:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0108969:	8b 45 0c             	mov    0xc(%ebp),%eax
f010896c:	c1 e8 16             	shr    $0x16,%eax
f010896f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108976:	8b 45 08             	mov    0x8(%ebp),%eax
f0108979:	01 d0                	add    %edx,%eax
f010897b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010897e:	83 ca 07             	or     $0x7,%edx
f0108981:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108983:	8b 45 10             	mov    0x10(%ebp),%eax
f0108986:	8b 00                	mov    (%eax),%eax
f0108988:	83 ec 04             	sub    $0x4,%esp
f010898b:	68 00 10 00 00       	push   $0x1000
f0108990:	6a 00                	push   $0x0
f0108992:	50                   	push   %eax
f0108993:	e8 02 77 01 00       	call   f012009a <memset>
f0108998:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010899b:	0f 20 d8             	mov    %cr3,%eax
f010899e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01089a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089a4:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01089a7:	90                   	nop
f01089a8:	c9                   	leave  
f01089a9:	c3                   	ret    

f01089aa <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01089aa:	55                   	push   %ebp
f01089ab:	89 e5                	mov    %esp,%ebp
f01089ad:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01089b0:	ff 75 0c             	pushl  0xc(%ebp)
f01089b3:	e8 d3 f6 ff ff       	call   f010808b <to_physical_address>
f01089b8:	83 c4 04             	add    $0x4,%esp
f01089bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01089be:	83 ec 04             	sub    $0x4,%esp
f01089c1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01089c4:	50                   	push   %eax
f01089c5:	ff 75 10             	pushl  0x10(%ebp)
f01089c8:	ff 75 08             	pushl  0x8(%ebp)
f01089cb:	e8 4a fd ff ff       	call   f010871a <get_page_table>
f01089d0:	83 c4 10             	add    $0x10,%esp
f01089d3:	83 f8 01             	cmp    $0x1,%eax
f01089d6:	75 1b                	jne    f01089f3 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01089d8:	83 ec 08             	sub    $0x8,%esp
f01089db:	ff 75 10             	pushl  0x10(%ebp)
f01089de:	ff 75 08             	pushl  0x8(%ebp)
f01089e1:	e8 8a fe ff ff       	call   f0108870 <create_page_table>
f01089e6:	83 c4 10             	add    $0x10,%esp
f01089e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01089ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01089f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089f6:	8b 55 10             	mov    0x10(%ebp),%edx
f01089f9:	c1 ea 0c             	shr    $0xc,%edx
f01089fc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a02:	c1 e2 02             	shl    $0x2,%edx
f0108a05:	01 d0                	add    %edx,%eax
f0108a07:	8b 00                	mov    (%eax),%eax
f0108a09:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108a0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a0f:	83 e0 01             	and    $0x1,%eax
f0108a12:	85 c0                	test   %eax,%eax
f0108a14:	74 25                	je     f0108a3b <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108a21:	75 07                	jne    f0108a2a <map_frame+0x80>
			return 0;
f0108a23:	b8 00 00 00 00       	mov    $0x0,%eax
f0108a28:	eb 68                	jmp    f0108a92 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108a2a:	83 ec 08             	sub    $0x8,%esp
f0108a2d:	ff 75 10             	pushl  0x10(%ebp)
f0108a30:	ff 75 08             	pushl  0x8(%ebp)
f0108a33:	e8 d2 00 00 00       	call   f0108b0a <unmap_frame>
f0108a38:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a3e:	8b 40 08             	mov    0x8(%eax),%eax
f0108a41:	40                   	inc    %eax
f0108a42:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a45:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108a49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a4c:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a4f:	c1 ea 0c             	shr    $0xc,%edx
f0108a52:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a58:	c1 e2 02             	shl    $0x2,%edx
f0108a5b:	01 d0                	add    %edx,%eax
f0108a5d:	8b 00                	mov    (%eax),%eax
f0108a5f:	25 00 0e 00 00       	and    $0xe00,%eax
f0108a64:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0108a67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a6a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a6d:	c1 ea 0c             	shr    $0xc,%edx
f0108a70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a76:	c1 e2 02             	shl    $0x2,%edx
f0108a79:	01 c2                	add    %eax,%edx
f0108a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a7e:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108a81:	89 c1                	mov    %eax,%ecx
f0108a83:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a86:	09 c8                	or     %ecx,%eax
f0108a88:	83 c8 01             	or     $0x1,%eax
f0108a8b:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108a8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108a92:	c9                   	leave  
f0108a93:	c3                   	ret    

f0108a94 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108a94:	55                   	push   %ebp
f0108a95:	89 e5                	mov    %esp,%ebp
f0108a97:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108a9a:	83 ec 04             	sub    $0x4,%esp
f0108a9d:	ff 75 10             	pushl  0x10(%ebp)
f0108aa0:	ff 75 0c             	pushl  0xc(%ebp)
f0108aa3:	ff 75 08             	pushl  0x8(%ebp)
f0108aa6:	e8 6f fc ff ff       	call   f010871a <get_page_table>
f0108aab:	83 c4 10             	add    $0x10,%esp
f0108aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108ab1:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ab4:	8b 00                	mov    (%eax),%eax
f0108ab6:	85 c0                	test   %eax,%eax
f0108ab8:	74 49                	je     f0108b03 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108aba:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108abd:	c1 e8 0c             	shr    $0xc,%eax
f0108ac0:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108ac5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108ac8:	8b 45 10             	mov    0x10(%ebp),%eax
f0108acb:	8b 00                	mov    (%eax),%eax
f0108acd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108ad0:	c1 e2 02             	shl    $0x2,%edx
f0108ad3:	01 d0                	add    %edx,%eax
f0108ad5:	8b 00                	mov    (%eax),%eax
f0108ad7:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108ada:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108add:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ae2:	85 c0                	test   %eax,%eax
f0108ae4:	74 16                	je     f0108afc <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108ae6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ae9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108aee:	83 ec 0c             	sub    $0xc,%esp
f0108af1:	50                   	push   %eax
f0108af2:	e8 a7 f5 ff ff       	call   f010809e <to_frame_info>
f0108af7:	83 c4 10             	add    $0x10,%esp
f0108afa:	eb 0c                	jmp    f0108b08 <get_frame_info+0x74>
		}
		return 0;
f0108afc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b01:	eb 05                	jmp    f0108b08 <get_frame_info+0x74>
	}
	return 0;
f0108b03:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108b08:	c9                   	leave  
f0108b09:	c3                   	ret    

f0108b0a <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108b0a:	55                   	push   %ebp
f0108b0b:	89 e5                	mov    %esp,%ebp
f0108b0d:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108b10:	83 ec 04             	sub    $0x4,%esp
f0108b13:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108b16:	50                   	push   %eax
f0108b17:	ff 75 0c             	pushl  0xc(%ebp)
f0108b1a:	ff 75 08             	pushl  0x8(%ebp)
f0108b1d:	e8 72 ff ff ff       	call   f0108a94 <get_frame_info>
f0108b22:	83 c4 10             	add    $0x10,%esp
f0108b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108b28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b2c:	74 7d                	je     f0108bab <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b31:	8a 40 14             	mov    0x14(%eax),%al
f0108b34:	84 c0                	test   %al,%al
f0108b36:	74 1c                	je     f0108b54 <unmap_frame+0x4a>
f0108b38:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108b3f:	77 13                	ja     f0108b54 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108b41:	83 ec 08             	sub    $0x8,%esp
f0108b44:	ff 75 0c             	pushl  0xc(%ebp)
f0108b47:	68 54 5f 12 f0       	push   $0xf0125f54
f0108b4c:	e8 3a 84 ff ff       	call   f0100f8b <cprintf>
f0108b51:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108b54:	83 ec 0c             	sub    $0xc,%esp
f0108b57:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b5a:	e8 8b fb ff ff       	call   f01086ea <decrement_references>
f0108b5f:	83 c4 10             	add    $0x10,%esp
		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b65:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b68:	c1 ea 0c             	shr    $0xc,%edx
f0108b6b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b71:	c1 e2 02             	shl    $0x2,%edx
f0108b74:	01 d0                	add    %edx,%eax
f0108b76:	8b 00                	mov    (%eax),%eax
f0108b78:	25 00 0e 00 00       	and    $0xe00,%eax
f0108b7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108b80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b83:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b86:	c1 ea 0c             	shr    $0xc,%edx
f0108b89:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b8f:	c1 e2 02             	shl    $0x2,%edx
f0108b92:	01 c2                	add    %eax,%edx
f0108b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b97:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108b99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b9c:	83 ec 08             	sub    $0x8,%esp
f0108b9f:	50                   	push   %eax
f0108ba0:	ff 75 08             	pushl  0x8(%ebp)
f0108ba3:	e8 3c f5 ff ff       	call   f01080e4 <tlb_invalidate>
f0108ba8:	83 c4 10             	add    $0x10,%esp
	}
}
f0108bab:	90                   	nop
f0108bac:	c9                   	leave  
f0108bad:	c3                   	ret    

f0108bae <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108bae:	55                   	push   %ebp
f0108baf:	89 e5                	mov    %esp,%ebp
f0108bb1:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108bb4:	ff 75 0c             	pushl  0xc(%ebp)
f0108bb7:	e8 cf f4 ff ff       	call   f010808b <to_physical_address>
f0108bbc:	83 c4 04             	add    $0x4,%esp
f0108bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108bc2:	8b 45 10             	mov    0x10(%ebp),%eax
f0108bc5:	c1 e8 16             	shr    $0x16,%eax
f0108bc8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108bcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bd2:	01 d0                	add    %edx,%eax
f0108bd4:	8b 00                	mov    (%eax),%eax
f0108bd6:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108bd9:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108be0:	77 19                	ja     f0108bfb <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108be2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108be5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108bea:	83 ec 0c             	sub    $0xc,%esp
f0108bed:	50                   	push   %eax
f0108bee:	e8 6a 0f 00 00       	call   f0109b5d <kheap_virtual_address>
f0108bf3:	83 c4 10             	add    $0x10,%esp
f0108bf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108bf9:	eb 40                	jmp    f0108c3b <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108bfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108bfe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108c06:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c09:	c1 e8 0c             	shr    $0xc,%eax
f0108c0c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108c0f:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108c14:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108c17:	72 17                	jb     f0108c30 <loadtime_map_frame+0x82>
f0108c19:	ff 75 e8             	pushl  -0x18(%ebp)
f0108c1c:	68 08 5f 12 f0       	push   $0xf0125f08
f0108c21:	68 f9 01 00 00       	push   $0x1f9
f0108c26:	68 4b 5e 12 f0       	push   $0xf0125e4b
f0108c2b:	e8 09 77 ff ff       	call   f0100339 <_panic>
f0108c30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c33:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108c38:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108c3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108c3f:	75 14                	jne    f0108c55 <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108c41:	83 ec 08             	sub    $0x8,%esp
f0108c44:	ff 75 10             	pushl  0x10(%ebp)
f0108c47:	ff 75 08             	pushl  0x8(%ebp)
f0108c4a:	e8 21 fc ff ff       	call   f0108870 <create_page_table>
f0108c4f:	83 c4 10             	add    $0x10,%esp
f0108c52:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f0108c55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c58:	8b 40 08             	mov    0x8(%eax),%eax
f0108c5b:	40                   	inc    %eax
f0108c5c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c5f:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108c63:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c66:	c1 e8 0c             	shr    $0xc,%eax
f0108c69:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108c6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c78:	01 c2                	add    %eax,%edx
f0108c7a:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c7d:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108c80:	83 c8 01             	or     $0x1,%eax
f0108c83:	89 02                	mov    %eax,(%edx)

	return 0;
f0108c85:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c8a:	c9                   	leave  
f0108c8b:	c3                   	ret    

f0108c8c <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108c8c:	55                   	push   %ebp
f0108c8d:	89 e5                	mov    %esp,%ebp
f0108c8f:	57                   	push   %edi
f0108c90:	56                   	push   %esi
f0108c91:	53                   	push   %ebx
f0108c92:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0108c95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108c9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108ca3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108caa:	83 ec 0c             	sub    $0xc,%esp
f0108cad:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108cb2:	e8 60 74 00 00       	call   f0110117 <holding_spinlock>
f0108cb7:	83 c4 10             	add    $0x10,%esp
f0108cba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108cbd:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108cc1:	75 10                	jne    f0108cd3 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108cc3:	83 ec 0c             	sub    $0xc,%esp
f0108cc6:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108ccb:	e8 2e 72 00 00       	call   f010fefe <acquire_spinlock>
f0108cd0:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cd3:	a1 20 f1 b1 f0       	mov    0xf0b1f120,%eax
f0108cd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cdb:	eb 1a                	jmp    f0108cf7 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108cdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108ce0:	8a 40 14             	mov    0x14(%eax),%al
f0108ce3:	84 c0                	test   %al,%al
f0108ce5:	74 05                	je     f0108cec <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108ce7:	ff 45 dc             	incl   -0x24(%ebp)
f0108cea:	eb 03                	jmp    f0108cef <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108cec:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cef:	a1 28 f1 b1 f0       	mov    0xf0b1f128,%eax
f0108cf4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cf7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108cfb:	74 07                	je     f0108d04 <calculate_available_frames+0x78>
f0108cfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108d00:	8b 00                	mov    (%eax),%eax
f0108d02:	eb 05                	jmp    f0108d09 <calculate_available_frames+0x7d>
f0108d04:	b8 00 00 00 00       	mov    $0x0,%eax
f0108d09:	a3 28 f1 b1 f0       	mov    %eax,0xf0b1f128
f0108d0e:	a1 28 f1 b1 f0       	mov    0xf0b1f128,%eax
f0108d13:	85 c0                	test   %eax,%eax
f0108d15:	75 c6                	jne    f0108cdd <calculate_available_frames+0x51>
f0108d17:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108d1b:	75 c0                	jne    f0108cdd <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108d1d:	a1 3c f1 b1 f0       	mov    0xf0b1f13c,%eax
f0108d22:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108d25:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108d29:	75 10                	jne    f0108d3b <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108d2b:	83 ec 0c             	sub    $0xc,%esp
f0108d2e:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108d33:	e8 4d 72 00 00       	call   f010ff85 <release_spinlock>
f0108d38:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108d3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108d3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108d41:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d44:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108d47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d4a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108d4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d50:	89 c3                	mov    %eax,%ebx
f0108d52:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108d55:	ba 03 00 00 00       	mov    $0x3,%edx
f0108d5a:	89 df                	mov    %ebx,%edi
f0108d5c:	89 c6                	mov    %eax,%esi
f0108d5e:	89 d1                	mov    %edx,%ecx
f0108d60:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108d62:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d68:	5b                   	pop    %ebx
f0108d69:	5e                   	pop    %esi
f0108d6a:	5f                   	pop    %edi
f0108d6b:	5d                   	pop    %ebp
f0108d6c:	c2 04 00             	ret    $0x4

f0108d6f <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108d6f:	55                   	push   %ebp
f0108d70:	89 e5                	mov    %esp,%ebp
f0108d72:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108d75:	c7 05 e0 ef 71 f0 00 	movl   $0x0,0xf071efe0
f0108d7c:	00 00 00 
f0108d7f:	c7 05 e4 ef 71 f0 00 	movl   $0x0,0xf071efe4
f0108d86:	00 00 00 
f0108d89:	c7 05 ec ef 71 f0 00 	movl   $0x0,0xf071efec
f0108d90:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108d93:	83 ec 08             	sub    $0x8,%esp
f0108d96:	68 84 5f 12 f0       	push   $0xf0125f84
f0108d9b:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108da0:	e8 28 71 00 00       	call   f010fecd <init_spinlock>
f0108da5:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108da8:	90                   	nop
f0108da9:	c9                   	leave  
f0108daa:	c3                   	ret    

f0108dab <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108dab:	55                   	push   %ebp
f0108dac:	89 e5                	mov    %esp,%ebp
f0108dae:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108db1:	83 ec 08             	sub    $0x8,%esp
f0108db4:	ff 75 0c             	pushl  0xc(%ebp)
f0108db7:	ff 75 08             	pushl  0x8(%ebp)
f0108dba:	e8 4b 01 00 00       	call   f0108f0a <get_share>
f0108dbf:	83 c4 10             	add    $0x10,%esp
f0108dc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108dc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108dc9:	75 07                	jne    f0108dd2 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108dcb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108dd0:	eb 06                	jmp    f0108dd8 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108dd5:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108dd8:	c9                   	leave  
f0108dd9:	c3                   	ret    

f0108dda <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108dda:	55                   	push   %ebp
f0108ddb:	89 e5                	mov    %esp,%ebp
f0108ddd:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108de0:	8b 15 2c f1 b1 f0    	mov    0xf0b1f12c,%edx
f0108de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0108de9:	39 c2                	cmp    %eax,%edx
f0108deb:	73 07                	jae    f0108df4 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ded:	b8 00 00 00 00       	mov    $0x0,%eax
f0108df2:	eb 3c                	jmp    f0108e30 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108df4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108df7:	c1 e0 02             	shl    $0x2,%eax
f0108dfa:	83 ec 0c             	sub    $0xc,%esp
f0108dfd:	50                   	push   %eax
f0108dfe:	e8 b7 09 00 00       	call   f01097ba <kmalloc>
f0108e03:	83 c4 10             	add    $0x10,%esp
f0108e06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108e09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108e0d:	75 07                	jne    f0108e16 <create_frames_storage+0x3c>
f0108e0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e14:	eb 1a                	jmp    f0108e30 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108e16:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e19:	c1 e0 02             	shl    $0x2,%eax
f0108e1c:	83 ec 04             	sub    $0x4,%esp
f0108e1f:	50                   	push   %eax
f0108e20:	6a 00                	push   $0x0
f0108e22:	ff 75 f4             	pushl  -0xc(%ebp)
f0108e25:	e8 70 72 01 00       	call   f012009a <memset>
f0108e2a:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108e30:	c9                   	leave  
f0108e31:	c3                   	ret    

f0108e32 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108e32:	55                   	push   %ebp
f0108e33:	89 e5                	mov    %esp,%ebp
f0108e35:	83 ec 28             	sub    $0x28,%esp
f0108e38:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e3b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108e3e:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108e45:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e4b:	01 d0                	add    %edx,%eax
f0108e4d:	48                   	dec    %eax
f0108e4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e54:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e59:	f7 75 f4             	divl   -0xc(%ebp)
f0108e5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e5f:	29 d0                	sub    %edx,%eax
f0108e61:	c1 e8 0c             	shr    $0xc,%eax
f0108e64:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108e67:	83 ec 0c             	sub    $0xc,%esp
f0108e6a:	6a 60                	push   $0x60
f0108e6c:	e8 49 09 00 00       	call   f01097ba <kmalloc>
f0108e71:	83 c4 10             	add    $0x10,%esp
f0108e74:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108e77:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108e7b:	75 0a                	jne    f0108e87 <create_share+0x55>
f0108e7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e82:	e9 81 00 00 00       	jmp    f0108f08 <create_share+0xd6>
	created_share->references=1;
f0108e87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e8a:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108e91:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	d1 f8                	sar    %eax
f0108e98:	89 c2                	mov    %eax,%edx
f0108e9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e9d:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ea2:	83 ec 0c             	sub    $0xc,%esp
f0108ea5:	50                   	push   %eax
f0108ea6:	e8 2f ff ff ff       	call   f0108dda <create_frames_storage>
f0108eab:	83 c4 10             	add    $0x10,%esp
f0108eae:	89 c2                	mov    %eax,%edx
f0108eb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb3:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb9:	8b 40 54             	mov    0x54(%eax),%eax
f0108ebc:	85 c0                	test   %eax,%eax
f0108ebe:	75 15                	jne    f0108ed5 <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108ec0:	83 ec 0c             	sub    $0xc,%esp
f0108ec3:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ec6:	e8 4f 0b 00 00       	call   f0109a1a <kfree>
f0108ecb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ece:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ed3:	eb 33                	jmp    f0108f08 <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108ed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ed8:	8b 55 08             	mov    0x8(%ebp),%edx
f0108edb:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ee1:	83 c0 08             	add    $0x8,%eax
f0108ee4:	83 ec 08             	sub    $0x8,%esp
f0108ee7:	ff 75 0c             	pushl  0xc(%ebp)
f0108eea:	50                   	push   %eax
f0108eeb:	e8 0b 70 01 00       	call   f011fefb <strcpy>
f0108ef0:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108ef3:	8b 55 10             	mov    0x10(%ebp),%edx
f0108ef6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef9:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108efc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eff:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108f02:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108f05:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108f08:	c9                   	leave  
f0108f09:	c3                   	ret    

f0108f0a <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108f0a:	55                   	push   %ebp
f0108f0b:	89 e5                	mov    %esp,%ebp
f0108f0d:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108f10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108f17:	83 ec 0c             	sub    $0xc,%esp
f0108f1a:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108f1f:	e8 da 6f 00 00       	call   f010fefe <acquire_spinlock>
f0108f24:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f27:	a1 e0 ef 71 f0       	mov    0xf071efe0,%eax
f0108f2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f2f:	eb 41                	jmp    f0108f72 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f34:	8b 40 04             	mov    0x4(%eax),%eax
f0108f37:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108f3a:	75 2e                	jne    f0108f6a <get_share+0x60>
f0108f3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f3f:	83 c0 08             	add    $0x8,%eax
f0108f42:	83 ec 08             	sub    $0x8,%esp
f0108f45:	ff 75 0c             	pushl  0xc(%ebp)
f0108f48:	50                   	push   %eax
f0108f49:	e8 6a 70 01 00       	call   f011ffb8 <strcmp>
f0108f4e:	83 c4 10             	add    $0x10,%esp
f0108f51:	85 c0                	test   %eax,%eax
f0108f53:	75 15                	jne    f0108f6a <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108f55:	83 ec 0c             	sub    $0xc,%esp
f0108f58:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108f5d:	e8 23 70 00 00       	call   f010ff85 <release_spinlock>
f0108f62:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f68:	eb 44                	jmp    f0108fae <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f6a:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0108f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f76:	74 08                	je     f0108f80 <get_share+0x76>
f0108f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f7b:	8b 40 58             	mov    0x58(%eax),%eax
f0108f7e:	eb 05                	jmp    f0108f85 <get_share+0x7b>
f0108f80:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f85:	a3 e8 ef 71 f0       	mov    %eax,0xf071efe8
f0108f8a:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0108f8f:	85 c0                	test   %eax,%eax
f0108f91:	75 9e                	jne    f0108f31 <get_share+0x27>
f0108f93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f97:	75 98                	jne    f0108f31 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108f99:	83 ec 0c             	sub    $0xc,%esp
f0108f9c:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108fa1:	e8 df 6f 00 00       	call   f010ff85 <release_spinlock>
f0108fa6:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108fa9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108fae:	c9                   	leave  
f0108faf:	c3                   	ret    

f0108fb0 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108fb0:	55                   	push   %ebp
f0108fb1:	89 e5                	mov    %esp,%ebp
f0108fb3:	83 ec 48             	sub    $0x48,%esp
f0108fb6:	8b 45 14             	mov    0x14(%ebp),%eax
f0108fb9:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108fbc:	e8 af 2c 00 00       	call   f010bc70 <get_cpu_proc>
f0108fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108fc4:	83 ec 08             	sub    $0x8,%esp
f0108fc7:	ff 75 0c             	pushl  0xc(%ebp)
f0108fca:	ff 75 08             	pushl  0x8(%ebp)
f0108fcd:	e8 38 ff ff ff       	call   f0108f0a <get_share>
f0108fd2:	83 c4 10             	add    $0x10,%esp
f0108fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108fd8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108fdc:	74 0a                	je     f0108fe8 <createSharedObject+0x38>
f0108fde:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108fe3:	e9 59 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108fe8:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108fec:	50                   	push   %eax
f0108fed:	ff 75 10             	pushl  0x10(%ebp)
f0108ff0:	ff 75 0c             	pushl  0xc(%ebp)
f0108ff3:	ff 75 08             	pushl  0x8(%ebp)
f0108ff6:	e8 37 fe ff ff       	call   f0108e32 <create_share>
f0108ffb:	83 c4 10             	add    $0x10,%esp
f0108ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0109001:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109005:	75 0a                	jne    f0109011 <createSharedObject+0x61>
f0109007:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010900c:	e9 30 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109011:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109018:	8b 55 10             	mov    0x10(%ebp),%edx
f010901b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010901e:	01 d0                	add    %edx,%eax
f0109020:	48                   	dec    %eax
f0109021:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109024:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109027:	ba 00 00 00 00       	mov    $0x0,%edx
f010902c:	f7 75 e4             	divl   -0x1c(%ebp)
f010902f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109032:	29 d0                	sub    %edx,%eax
f0109034:	c1 e8 0c             	shr    $0xc,%eax
f0109037:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int k = 0; k < num_pages; k++)
f010903a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109041:	eb 6c                	jmp    f01090af <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0109043:	83 ec 0c             	sub    $0xc,%esp
f0109046:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109049:	50                   	push   %eax
f010904a:	e8 8e f4 ff ff       	call   f01084dd <allocate_frame>
f010904f:	83 c4 10             	add    $0x10,%esp
f0109052:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0109055:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0109059:	75 3d                	jne    f0109098 <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f010905b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010905e:	c1 e0 0c             	shl    $0xc,%eax
f0109061:	89 c2                	mov    %eax,%edx
f0109063:	8b 45 18             	mov    0x18(%ebp),%eax
f0109066:	01 d0                	add    %edx,%eax
f0109068:	89 c1                	mov    %eax,%ecx
f010906a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010906d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109070:	8b 40 64             	mov    0x64(%eax),%eax
f0109073:	6a 06                	push   $0x6
f0109075:	51                   	push   %ecx
f0109076:	52                   	push   %edx
f0109077:	50                   	push   %eax
f0109078:	e8 2d f9 ff ff       	call   f01089aa <map_frame>
f010907d:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0109080:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109083:	8b 40 54             	mov    0x54(%eax),%eax
f0109086:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109089:	c1 e2 02             	shl    $0x2,%edx
f010908c:	01 c2                	add    %eax,%edx
f010908e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109091:	89 02                	mov    %eax,(%edx)
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0109093:	ff 45 f4             	incl   -0xc(%ebp)
f0109096:	eb 17                	jmp    f01090af <createSharedObject+0xff>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0109098:	83 ec 04             	sub    $0x4,%esp
f010909b:	68 90 5f 12 f0       	push   $0xf0125f90
f01090a0:	68 a5 00 00 00       	push   $0xa5
f01090a5:	68 9c 5f 12 f0       	push   $0xf0125f9c
f01090aa:	e8 8a 72 ff ff       	call   f0100339 <_panic>
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f01090af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01090b5:	72 8c                	jb     f0109043 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f01090b7:	83 ec 0c             	sub    $0xc,%esp
f01090ba:	68 f0 ef 71 f0       	push   $0xf071eff0
f01090bf:	e8 3a 6e 00 00       	call   f010fefe <acquire_spinlock>
f01090c4:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f01090c7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01090cb:	75 17                	jne    f01090e4 <createSharedObject+0x134>
f01090cd:	83 ec 04             	sub    $0x4,%esp
f01090d0:	68 c0 5f 12 f0       	push   $0xf0125fc0
f01090d5:	68 aa 00 00 00       	push   $0xaa
f01090da:	68 9c 5f 12 f0       	push   $0xf0125f9c
f01090df:	e8 55 72 ff ff       	call   f0100339 <_panic>
f01090e4:	8b 15 e4 ef 71 f0    	mov    0xf071efe4,%edx
f01090ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090ed:	89 50 5c             	mov    %edx,0x5c(%eax)
f01090f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090f3:	8b 40 5c             	mov    0x5c(%eax),%eax
f01090f6:	85 c0                	test   %eax,%eax
f01090f8:	74 0d                	je     f0109107 <createSharedObject+0x157>
f01090fa:	a1 e4 ef 71 f0       	mov    0xf071efe4,%eax
f01090ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109102:	89 50 58             	mov    %edx,0x58(%eax)
f0109105:	eb 08                	jmp    f010910f <createSharedObject+0x15f>
f0109107:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010910a:	a3 e0 ef 71 f0       	mov    %eax,0xf071efe0
f010910f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109112:	a3 e4 ef 71 f0       	mov    %eax,0xf071efe4
f0109117:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010911a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0109121:	a1 ec ef 71 f0       	mov    0xf071efec,%eax
f0109126:	40                   	inc    %eax
f0109127:	a3 ec ef 71 f0       	mov    %eax,0xf071efec
	release_spinlock(&AllShares.shareslock);
f010912c:	83 ec 0c             	sub    $0xc,%esp
f010912f:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109134:	e8 4c 6e 00 00       	call   f010ff85 <release_spinlock>
f0109139:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f010913c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010913f:	8b 00                	mov    (%eax),%eax
}
f0109141:	c9                   	leave  
f0109142:	c3                   	ret    

f0109143 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0109143:	55                   	push   %ebp
f0109144:	89 e5                	mov    %esp,%ebp
f0109146:	53                   	push   %ebx
f0109147:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f010914a:	e8 21 2b 00 00       	call   f010bc70 <get_cpu_proc>
f010914f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0109152:	83 ec 08             	sub    $0x8,%esp
f0109155:	ff 75 0c             	pushl  0xc(%ebp)
f0109158:	ff 75 08             	pushl  0x8(%ebp)
f010915b:	e8 aa fd ff ff       	call   f0108f0a <get_share>
f0109160:	83 c4 10             	add    $0x10,%esp
f0109163:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0109166:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010916a:	75 0a                	jne    f0109176 <getSharedObject+0x33>
f010916c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0109171:	e9 a0 00 00 00       	jmp    f0109216 <getSharedObject+0xd3>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0109176:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010917d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109180:	8b 40 48             	mov    0x48(%eax),%eax
f0109183:	89 c2                	mov    %eax,%edx
f0109185:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109188:	01 d0                	add    %edx,%eax
f010918a:	48                   	dec    %eax
f010918b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010918e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109191:	ba 00 00 00 00       	mov    $0x0,%edx
f0109196:	f7 75 e8             	divl   -0x18(%ebp)
f0109199:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010919c:	29 d0                	sub    %edx,%eax
f010919e:	85 c0                	test   %eax,%eax
f01091a0:	79 05                	jns    f01091a7 <getSharedObject+0x64>
f01091a2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01091a7:	c1 f8 0c             	sar    $0xc,%eax
f01091aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f01091ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01091b4:	eb 44                	jmp    f01091fa <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f01091b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091b9:	8a 40 50             	mov    0x50(%eax),%al
f01091bc:	0f b6 c0             	movzbl %al,%eax
f01091bf:	01 c0                	add    %eax,%eax
f01091c1:	83 c8 04             	or     $0x4,%eax
f01091c4:	89 c3                	mov    %eax,%ebx
f01091c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091c9:	c1 e0 0c             	shl    $0xc,%eax
f01091cc:	89 c2                	mov    %eax,%edx
f01091ce:	8b 45 10             	mov    0x10(%ebp),%eax
f01091d1:	01 d0                	add    %edx,%eax
f01091d3:	89 c1                	mov    %eax,%ecx
f01091d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091d8:	8b 40 54             	mov    0x54(%eax),%eax
f01091db:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01091de:	c1 e2 02             	shl    $0x2,%edx
f01091e1:	01 d0                	add    %edx,%eax
f01091e3:	8b 10                	mov    (%eax),%edx
f01091e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e8:	8b 40 64             	mov    0x64(%eax),%eax
f01091eb:	53                   	push   %ebx
f01091ec:	51                   	push   %ecx
f01091ed:	52                   	push   %edx
f01091ee:	50                   	push   %eax
f01091ef:	e8 b6 f7 ff ff       	call   f01089aa <map_frame>
f01091f4:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f01091f7:	ff 45 f4             	incl   -0xc(%ebp)
f01091fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0109200:	72 b4                	jb     f01091b6 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
	}
	shared_obj->references++;
f0109202:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109205:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109208:	8d 50 01             	lea    0x1(%eax),%edx
f010920b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010920e:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0109211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109214:	8b 00                	mov    (%eax),%eax
}
f0109216:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109219:	c9                   	leave  
f010921a:	c3                   	ret    

f010921b <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f010921b:	55                   	push   %ebp
f010921c:	89 e5                	mov    %esp,%ebp
f010921e:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0109221:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109225:	0f 84 ca 00 00 00    	je     f01092f5 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f010922b:	83 ec 0c             	sub    $0xc,%esp
f010922e:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109233:	e8 c6 6c 00 00       	call   f010fefe <acquire_spinlock>
f0109238:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f010923b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010923f:	75 17                	jne    f0109258 <free_share+0x3d>
f0109241:	83 ec 04             	sub    $0x4,%esp
f0109244:	68 e3 5f 12 f0       	push   $0xf0125fe3
f0109249:	68 d7 00 00 00       	push   $0xd7
f010924e:	68 9c 5f 12 f0       	push   $0xf0125f9c
f0109253:	e8 e1 70 ff ff       	call   f0100339 <_panic>
f0109258:	8b 45 08             	mov    0x8(%ebp),%eax
f010925b:	8b 40 58             	mov    0x58(%eax),%eax
f010925e:	85 c0                	test   %eax,%eax
f0109260:	74 11                	je     f0109273 <free_share+0x58>
f0109262:	8b 45 08             	mov    0x8(%ebp),%eax
f0109265:	8b 40 58             	mov    0x58(%eax),%eax
f0109268:	8b 55 08             	mov    0x8(%ebp),%edx
f010926b:	8b 52 5c             	mov    0x5c(%edx),%edx
f010926e:	89 50 5c             	mov    %edx,0x5c(%eax)
f0109271:	eb 0b                	jmp    f010927e <free_share+0x63>
f0109273:	8b 45 08             	mov    0x8(%ebp),%eax
f0109276:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109279:	a3 e4 ef 71 f0       	mov    %eax,0xf071efe4
f010927e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109281:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109284:	85 c0                	test   %eax,%eax
f0109286:	74 11                	je     f0109299 <free_share+0x7e>
f0109288:	8b 45 08             	mov    0x8(%ebp),%eax
f010928b:	8b 40 5c             	mov    0x5c(%eax),%eax
f010928e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109291:	8b 52 58             	mov    0x58(%edx),%edx
f0109294:	89 50 58             	mov    %edx,0x58(%eax)
f0109297:	eb 0b                	jmp    f01092a4 <free_share+0x89>
f0109299:	8b 45 08             	mov    0x8(%ebp),%eax
f010929c:	8b 40 58             	mov    0x58(%eax),%eax
f010929f:	a3 e0 ef 71 f0       	mov    %eax,0xf071efe0
f01092a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01092a7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f01092ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01092b1:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f01092b8:	a1 ec ef 71 f0       	mov    0xf071efec,%eax
f01092bd:	48                   	dec    %eax
f01092be:	a3 ec ef 71 f0       	mov    %eax,0xf071efec
    release_spinlock(&AllShares.shareslock);
f01092c3:	83 ec 0c             	sub    $0xc,%esp
f01092c6:	68 f0 ef 71 f0       	push   $0xf071eff0
f01092cb:	e8 b5 6c 00 00       	call   f010ff85 <release_spinlock>
f01092d0:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f01092d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d6:	8b 40 54             	mov    0x54(%eax),%eax
f01092d9:	83 ec 0c             	sub    $0xc,%esp
f01092dc:	50                   	push   %eax
f01092dd:	e8 38 07 00 00       	call   f0109a1a <kfree>
f01092e2:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f01092e5:	83 ec 0c             	sub    $0xc,%esp
f01092e8:	ff 75 08             	pushl  0x8(%ebp)
f01092eb:	e8 2a 07 00 00       	call   f0109a1a <kfree>
f01092f0:	83 c4 10             	add    $0x10,%esp
f01092f3:	eb 01                	jmp    f01092f6 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f01092f5:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f01092f6:	c9                   	leave  
f01092f7:	c3                   	ret    

f01092f8 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f01092f8:	55                   	push   %ebp
f01092f9:	89 e5                	mov    %esp,%ebp
f01092fb:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f01092fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0109305:	83 ec 0c             	sub    $0xc,%esp
f0109308:	68 f0 ef 71 f0       	push   $0xf071eff0
f010930d:	e8 ec 6b 00 00       	call   f010fefe <acquire_spinlock>
f0109312:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109315:	a1 e0 ef 71 f0       	mov    0xf071efe0,%eax
f010931a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010931d:	eb 27                	jmp    f0109346 <get_Share_id+0x4e>
            if(founded->ID == sharedObjectID)
f010931f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109322:	8b 00                	mov    (%eax),%eax
f0109324:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109327:	75 15                	jne    f010933e <get_Share_id+0x46>
            {
                release_spinlock(&AllShares.shareslock);
f0109329:	83 ec 0c             	sub    $0xc,%esp
f010932c:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109331:	e8 4f 6c 00 00       	call   f010ff85 <release_spinlock>
f0109336:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109339:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010933c:	eb 44                	jmp    f0109382 <get_Share_id+0x8a>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010933e:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0109343:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109346:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010934a:	74 08                	je     f0109354 <get_Share_id+0x5c>
f010934c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010934f:	8b 40 58             	mov    0x58(%eax),%eax
f0109352:	eb 05                	jmp    f0109359 <get_Share_id+0x61>
f0109354:	b8 00 00 00 00       	mov    $0x0,%eax
f0109359:	a3 e8 ef 71 f0       	mov    %eax,0xf071efe8
f010935e:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0109363:	85 c0                	test   %eax,%eax
f0109365:	75 b8                	jne    f010931f <get_Share_id+0x27>
f0109367:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010936b:	75 b2                	jne    f010931f <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f010936d:	83 ec 0c             	sub    $0xc,%esp
f0109370:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109375:	e8 0b 6c 00 00       	call   f010ff85 <release_spinlock>
f010937a:	83 c4 10             	add    $0x10,%esp
        return NULL;
f010937d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109382:	c9                   	leave  
f0109383:	c3                   	ret    

f0109384 <freeSharedObject>:

int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0109384:	55                   	push   %ebp
f0109385:	89 e5                	mov    %esp,%ebp
f0109387:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
    //panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
		struct Env* myenv = get_cpu_proc();
f010938a:	e8 e1 28 00 00       	call   f010bc70 <get_cpu_proc>
f010938f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f0109392:	83 ec 08             	sub    $0x8,%esp
f0109395:	ff 75 0c             	pushl  0xc(%ebp)
f0109398:	ff 75 08             	pushl  0x8(%ebp)
f010939b:	e8 58 ff ff ff       	call   f01092f8 <get_Share_id>
f01093a0:	83 c4 10             	add    $0x10,%esp
f01093a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(ptr_share == NULL) return -1;
f01093a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01093aa:	75 0a                	jne    f01093b6 <freeSharedObject+0x32>
f01093ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01093b1:	e9 43 01 00 00       	jmp    f01094f9 <freeSharedObject+0x175>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01093b6:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01093bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01093c0:	8b 40 48             	mov    0x48(%eax),%eax
f01093c3:	89 c2                	mov    %eax,%edx
f01093c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093c8:	01 d0                	add    %edx,%eax
f01093ca:	48                   	dec    %eax
f01093cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01093ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093d1:	ba 00 00 00 00       	mov    $0x0,%edx
f01093d6:	f7 75 e0             	divl   -0x20(%ebp)
f01093d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093dc:	29 d0                	sub    %edx,%eax
f01093de:	85 c0                	test   %eax,%eax
f01093e0:	79 05                	jns    f01093e7 <freeSharedObject+0x63>
f01093e2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01093e7:	c1 f8 0c             	sar    $0xc,%eax
f01093ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01093ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093f4:	e9 bc 00 00 00       	jmp    f01094b5 <freeSharedObject+0x131>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
f01093f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093fc:	c1 e0 0c             	shl    $0xc,%eax
f01093ff:	89 c2                	mov    %eax,%edx
f0109401:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109404:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109407:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010940a:	8b 40 64             	mov    0x64(%eax),%eax
f010940d:	83 ec 04             	sub    $0x4,%esp
f0109410:	8d 55 cc             	lea    -0x34(%ebp),%edx
f0109413:	52                   	push   %edx
f0109414:	51                   	push   %ecx
f0109415:	50                   	push   %eax
f0109416:	e8 ff f2 ff ff       	call   f010871a <get_page_table>
f010941b:	83 c4 10             	add    $0x10,%esp
f010941e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
f0109421:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109424:	c1 e0 0c             	shl    $0xc,%eax
f0109427:	89 c2                	mov    %eax,%edx
f0109429:	8b 45 0c             	mov    0xc(%ebp),%eax
f010942c:	01 c2                	add    %eax,%edx
f010942e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109431:	8b 40 64             	mov    0x64(%eax),%eax
f0109434:	83 ec 08             	sub    $0x8,%esp
f0109437:	52                   	push   %edx
f0109438:	50                   	push   %eax
f0109439:	e8 cc f6 ff ff       	call   f0108b0a <unmap_frame>
f010943e:	83 c4 10             	add    $0x10,%esp
			bool isFree = 1;
f0109441:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			for(int i=0;i<1024;i++)
f0109448:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010944f:	eb 22                	jmp    f0109473 <freeSharedObject+0xef>
			{

				if((EXTRACT_ADDRESS(ptr_page_table[i])) != 0){
f0109451:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109454:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109457:	c1 e2 02             	shl    $0x2,%edx
f010945a:	01 d0                	add    %edx,%eax
f010945c:	8b 00                	mov    (%eax),%eax
f010945e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109463:	85 c0                	test   %eax,%eax
f0109465:	74 09                	je     f0109470 <freeSharedObject+0xec>
					isFree = 0;
f0109467:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					break;
f010946e:	eb 0c                	jmp    f010947c <freeSharedObject+0xf8>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
			bool isFree = 1;
			for(int i=0;i<1024;i++)
f0109470:	ff 45 ec             	incl   -0x14(%ebp)
f0109473:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010947a:	7e d5                	jle    f0109451 <freeSharedObject+0xcd>
					isFree = 0;
					break;
				}
			}

			if(isFree)
f010947c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109480:	74 30                	je     f01094b2 <freeSharedObject+0x12e>
			{
				kfree((void*)ptr_page_table);
f0109482:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109485:	83 ec 0c             	sub    $0xc,%esp
f0109488:	50                   	push   %eax
f0109489:	e8 8c 05 00 00       	call   f0109a1a <kfree>
f010948e:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
f0109491:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109494:	8b 40 64             	mov    0x64(%eax),%eax
f0109497:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010949a:	c1 e2 0c             	shl    $0xc,%edx
f010949d:	89 d1                	mov    %edx,%ecx
f010949f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01094a2:	01 ca                	add    %ecx,%edx
f01094a4:	c1 ea 16             	shr    $0x16,%edx
f01094a7:	c1 e2 02             	shl    $0x2,%edx
f01094aa:	01 d0                	add    %edx,%eax
f01094ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01094b2:	ff 45 f4             	incl   -0xc(%ebp)
f01094b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094b8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01094bb:	0f 82 38 ff ff ff    	jb     f01093f9 <freeSharedObject+0x75>
			}




        ptr_share->references--;
f01094c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094c4:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094c7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01094ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094cd:	89 50 4c             	mov    %edx,0x4c(%eax)

        if(ptr_share->references < 1){
f01094d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094d3:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094d6:	85 c0                	test   %eax,%eax
f01094d8:	75 0e                	jne    f01094e8 <freeSharedObject+0x164>
            free_share(ptr_share);
f01094da:	83 ec 0c             	sub    $0xc,%esp
f01094dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01094e0:	e8 36 fd ff ff       	call   f010921b <free_share>
f01094e5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01094e8:	0f 20 d8             	mov    %cr3,%eax
f01094eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01094ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01094f1:	0f 22 d8             	mov    %eax,%cr3
        }
        tlbflush();
        return 0;
f01094f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01094f9:	c9                   	leave  
f01094fa:	c3                   	ret    

f01094fb <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01094fb:	55                   	push   %ebp
f01094fc:	89 e5                	mov    %esp,%ebp
f01094fe:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0109503:	83 f8 01             	cmp    $0x1,%eax
f0109506:	75 04                	jne    f010950c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0109508:	b0 01                	mov    $0x1,%al
f010950a:	eb 02                	jmp    f010950e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010950c:	b0 00                	mov    $0x0,%al
f010950e:	5d                   	pop    %ebp
f010950f:	c3                   	ret    

f0109510 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0109510:	55                   	push   %ebp
f0109511:	89 e5                	mov    %esp,%ebp
f0109513:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0109518:	83 f8 02             	cmp    $0x2,%eax
f010951b:	75 04                	jne    f0109521 <isKHeapPlacementStrategyBESTFIT+0x11>
f010951d:	b0 01                	mov    $0x1,%al
f010951f:	eb 02                	jmp    f0109523 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109521:	b0 00                	mov    $0x0,%al
f0109523:	5d                   	pop    %ebp
f0109524:	c3                   	ret    

f0109525 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109525:	55                   	push   %ebp
f0109526:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0109528:	8b 45 08             	mov    0x8(%ebp),%eax
f010952b:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f0109531:	29 d0                	sub    %edx,%eax
f0109533:	c1 f8 03             	sar    $0x3,%eax
f0109536:	89 c2                	mov    %eax,%edx
f0109538:	89 d0                	mov    %edx,%eax
f010953a:	c1 e0 02             	shl    $0x2,%eax
f010953d:	01 d0                	add    %edx,%eax
f010953f:	c1 e0 02             	shl    $0x2,%eax
f0109542:	01 d0                	add    %edx,%eax
f0109544:	c1 e0 02             	shl    $0x2,%eax
f0109547:	01 d0                	add    %edx,%eax
f0109549:	89 c1                	mov    %eax,%ecx
f010954b:	c1 e1 08             	shl    $0x8,%ecx
f010954e:	01 c8                	add    %ecx,%eax
f0109550:	89 c1                	mov    %eax,%ecx
f0109552:	c1 e1 10             	shl    $0x10,%ecx
f0109555:	01 c8                	add    %ecx,%eax
f0109557:	01 c0                	add    %eax,%eax
f0109559:	01 d0                	add    %edx,%eax
}
f010955b:	5d                   	pop    %ebp
f010955c:	c3                   	ret    

f010955d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010955d:	55                   	push   %ebp
f010955e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109560:	ff 75 08             	pushl  0x8(%ebp)
f0109563:	e8 bd ff ff ff       	call   f0109525 <to_frame_number>
f0109568:	83 c4 04             	add    $0x4,%esp
f010956b:	c1 e0 0c             	shl    $0xc,%eax
}
f010956e:	c9                   	leave  
f010956f:	c3                   	ret    

f0109570 <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC



int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0109570:	55                   	push   %ebp
f0109571:	89 e5                	mov    %esp,%ebp
f0109573:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0109576:	8b 45 08             	mov    0x8(%ebp),%eax
f0109579:	a3 e8 f7 f1 f0       	mov    %eax,0xf0f1f7e8
	hard_limit = daLimit;
f010957e:	8b 45 10             	mov    0x10(%ebp),%eax
f0109581:	a3 14 f6 b1 f0       	mov    %eax,0xf0b1f614
	brk = daStart + initSizeToAllocate;
f0109586:	8b 55 08             	mov    0x8(%ebp),%edx
f0109589:	8b 45 0c             	mov    0xc(%ebp),%eax
f010958c:	01 d0                	add    %edx,%eax
f010958e:	a3 e0 f7 f1 f0       	mov    %eax,0xf0f1f7e0

	if(brk > daLimit) panic("exceeds Limit");
f0109593:	a1 e0 f7 f1 f0       	mov    0xf0f1f7e0,%eax
f0109598:	3b 45 10             	cmp    0x10(%ebp),%eax
f010959b:	76 14                	jbe    f01095b1 <initialize_kheap_dynamic_allocator+0x41>
f010959d:	83 ec 04             	sub    $0x4,%esp
f01095a0:	68 04 60 12 f0       	push   $0xf0126004
f01095a5:	6a 1a                	push   $0x1a
f01095a7:	68 12 60 12 f0       	push   $0xf0126012
f01095ac:	e8 88 6d ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f01095b1:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f01095b8:	8b 45 10             	mov    0x10(%ebp),%eax
f01095bb:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f01095be:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f01095c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095c7:	c1 e8 0c             	shr    $0xc,%eax
f01095ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f01095cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01095d4:	e9 8a 00 00 00       	jmp    f0109663 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f01095d9:	83 ec 0c             	sub    $0xc,%esp
f01095dc:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01095df:	50                   	push   %eax
f01095e0:	e8 f8 ee ff ff       	call   f01084dd <allocate_frame>
f01095e5:	83 c4 10             	add    $0x10,%esp
f01095e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f01095eb:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f01095ef:	74 5e                	je     f010964f <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f01095f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01095f4:	c1 e0 0c             	shl    $0xc,%eax
f01095f7:	89 c2                	mov    %eax,%edx
f01095f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095fc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01095ff:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109602:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109607:	6a 02                	push   $0x2
f0109609:	51                   	push   %ecx
f010960a:	52                   	push   %edx
f010960b:	50                   	push   %eax
f010960c:	e8 99 f3 ff ff       	call   f01089aa <map_frame>
f0109611:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109614:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109617:	c1 e0 0c             	shl    $0xc,%eax
f010961a:	89 c2                	mov    %eax,%edx
f010961c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010961f:	01 d0                	add    %edx,%eax
f0109621:	83 ec 0c             	sub    $0xc,%esp
f0109624:	50                   	push   %eax
f0109625:	e8 d6 04 00 00       	call   f0109b00 <kheap_physical_address>
f010962a:	83 c4 10             	add    $0x10,%esp
f010962d:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109630:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109633:	c1 e8 0c             	shr    $0xc,%eax
f0109636:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109639:	c1 e2 0c             	shl    $0xc,%edx
f010963c:	89 d1                	mov    %edx,%ecx
f010963e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109641:	01 ca                	add    %ecx,%edx
f0109643:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010964a:	ff 45 f4             	incl   -0xc(%ebp)
f010964d:	eb 14                	jmp    f0109663 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f010964f:	83 ec 04             	sub    $0x4,%esp
f0109652:	68 23 60 12 f0       	push   $0xf0126023
f0109657:	6a 2f                	push   $0x2f
f0109659:	68 12 60 12 f0       	push   $0xf0126012
f010965e:	e8 d6 6c ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109663:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109666:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109669:	0f 82 6a ff ff ff    	jb     f01095d9 <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f010966f:	83 ec 08             	sub    $0x8,%esp
f0109672:	ff 75 0c             	pushl  0xc(%ebp)
f0109675:	ff 75 08             	pushl  0x8(%ebp)
f0109678:	e8 fe 73 01 00       	call   f0120a7b <initialize_dynamic_allocator>
f010967d:	83 c4 10             	add    $0x10,%esp

	return 0;
f0109680:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109685:	c9                   	leave  
f0109686:	c3                   	ret    

f0109687 <sbrk>:

void* sbrk(int numOfPages)
{
f0109687:	55                   	push   %ebp
f0109688:	89 e5                	mov    %esp,%ebp
f010968a:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f010968d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109691:	0f 8e d6 00 00 00    	jle    f010976d <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f0109697:	8b 45 08             	mov    0x8(%ebp),%eax
f010969a:	c1 e0 0c             	shl    $0xc,%eax
f010969d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01096a0:	a1 e0 f7 f1 f0       	mov    0xf0f1f7e0,%eax
f01096a5:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01096a8:	8b 15 e0 f7 f1 f0    	mov    0xf0f1f7e0,%edx
f01096ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096b1:	01 c2                	add    %eax,%edx
f01096b3:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f01096b8:	39 c2                	cmp    %eax,%edx
f01096ba:	76 0a                	jbe    f01096c6 <sbrk+0x3f>
f01096bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01096c1:	e9 b9 00 00 00       	jmp    f010977f <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f01096c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01096cd:	eb 7d                	jmp    f010974c <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01096cf:	83 ec 0c             	sub    $0xc,%esp
f01096d2:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01096d5:	50                   	push   %eax
f01096d6:	e8 02 ee ff ff       	call   f01084dd <allocate_frame>
f01096db:	83 c4 10             	add    $0x10,%esp
f01096de:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f01096e1:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01096e5:	74 5e                	je     f0109745 <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f01096e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01096ea:	c1 e0 0c             	shl    $0xc,%eax
f01096ed:	89 c2                	mov    %eax,%edx
f01096ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096f2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01096f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01096f8:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01096fd:	6a 02                	push   $0x2
f01096ff:	51                   	push   %ecx
f0109700:	52                   	push   %edx
f0109701:	50                   	push   %eax
f0109702:	e8 a3 f2 ff ff       	call   f01089aa <map_frame>
f0109707:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010970a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010970d:	c1 e0 0c             	shl    $0xc,%eax
f0109710:	89 c2                	mov    %eax,%edx
f0109712:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109715:	01 d0                	add    %edx,%eax
f0109717:	83 ec 0c             	sub    $0xc,%esp
f010971a:	50                   	push   %eax
f010971b:	e8 e0 03 00 00       	call   f0109b00 <kheap_physical_address>
f0109720:	83 c4 10             	add    $0x10,%esp
f0109723:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f0109726:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109729:	c1 e8 0c             	shr    $0xc,%eax
f010972c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010972f:	c1 e2 0c             	shl    $0xc,%edx
f0109732:	89 d1                	mov    %edx,%ecx
f0109734:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109737:	01 ca                	add    %ecx,%edx
f0109739:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109740:	ff 45 f4             	incl   -0xc(%ebp)
f0109743:	eb 07                	jmp    f010974c <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f0109745:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010974a:	eb 33                	jmp    f010977f <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f010974c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010974f:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109752:	0f 8c 77 ff ff ff    	jl     f01096cf <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f0109758:	8b 15 e0 f7 f1 f0    	mov    0xf0f1f7e0,%edx
f010975e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109761:	01 d0                	add    %edx,%eax
f0109763:	a3 e0 f7 f1 f0       	mov    %eax,0xf0f1f7e0
		return (void *)prev_brk;
f0109768:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010976b:	eb 12                	jmp    f010977f <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f010976d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109771:	75 07                	jne    f010977a <sbrk+0xf3>
	{
		return (void *) brk;
f0109773:	a1 e0 f7 f1 f0       	mov    0xf0f1f7e0,%eax
f0109778:	eb 05                	jmp    f010977f <sbrk+0xf8>
	}

	return (void *)-1;
f010977a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f010977f:	c9                   	leave  
f0109780:	c3                   	ret    

f0109781 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0109781:	55                   	push   %ebp
f0109782:	89 e5                	mov    %esp,%ebp
f0109784:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f0109787:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f010978e:	83 ec 04             	sub    $0x4,%esp
f0109791:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109794:	50                   	push   %eax
f0109795:	ff 75 0c             	pushl  0xc(%ebp)
f0109798:	ff 75 08             	pushl  0x8(%ebp)
f010979b:	e8 f4 f2 ff ff       	call   f0108a94 <get_frame_info>
f01097a0:	83 c4 10             	add    $0x10,%esp
f01097a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01097a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01097aa:	75 07                	jne    f01097b3 <isPageAllocated+0x32>
f01097ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01097b1:	eb 05                	jmp    f01097b8 <isPageAllocated+0x37>
	return 1;
f01097b3:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01097b8:	c9                   	leave  
f01097b9:	c3                   	ret    

f01097ba <kmalloc>:

void *kmalloc(unsigned int size)
{
f01097ba:	55                   	push   %ebp
f01097bb:	89 e5                	mov    %esp,%ebp
f01097bd:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01097c0:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01097c7:	8b 55 08             	mov    0x8(%ebp),%edx
f01097ca:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01097cd:	01 d0                	add    %edx,%eax
f01097cf:	48                   	dec    %eax
f01097d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01097d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097d6:	ba 00 00 00 00       	mov    $0x0,%edx
f01097db:	f7 75 d8             	divl   -0x28(%ebp)
f01097de:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097e1:	29 d0                	sub    %edx,%eax
f01097e3:	c1 e8 0c             	shr    $0xc,%eax
f01097e6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f01097e9:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01097f0:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f01097f5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01097f8:	29 c2                	sub    %eax,%edx
f01097fa:	89 d0                	mov    %edx,%eax
f01097fc:	48                   	dec    %eax
f01097fd:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109800:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109803:	ba 00 00 00 00       	mov    $0x0,%edx
f0109808:	f7 75 cc             	divl   -0x34(%ebp)
f010980b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010980e:	29 d0                	sub    %edx,%eax
f0109810:	c1 e8 0c             	shr    $0xc,%eax
f0109813:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f0109816:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f010981d:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109824:	77 42                	ja     f0109868 <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0109826:	e8 d0 fc ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f010982b:	84 c0                	test   %al,%al
f010982d:	74 16                	je     f0109845 <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f010982f:	83 ec 0c             	sub    $0xc,%esp
f0109832:	ff 75 08             	pushl  0x8(%ebp)
f0109835:	e8 5d 74 01 00       	call   f0120c97 <alloc_block_FF>
f010983a:	83 c4 10             	add    $0x10,%esp
f010983d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109840:	e9 d0 01 00 00       	jmp    f0109a15 <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f0109845:	e8 c6 fc ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f010984a:	84 c0                	test   %al,%al
f010984c:	0f 84 c3 01 00 00    	je     f0109a15 <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f0109852:	83 ec 0c             	sub    $0xc,%esp
f0109855:	ff 75 08             	pushl  0x8(%ebp)
f0109858:	e8 f6 78 01 00       	call   f0121153 <alloc_block_BF>
f010985d:	83 c4 10             	add    $0x10,%esp
f0109860:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109863:	e9 ad 01 00 00       	jmp    f0109a15 <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f0109868:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010986b:	48                   	dec    %eax
f010986c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010986f:	0f 86 99 01 00 00    	jbe    f0109a0e <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f0109875:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f010987a:	05 00 10 00 00       	add    $0x1000,%eax
f010987f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f0109882:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109889:	e9 86 00 00 00       	jmp    f0109914 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f010988e:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109893:	83 ec 08             	sub    $0x8,%esp
f0109896:	ff 75 f0             	pushl  -0x10(%ebp)
f0109899:	50                   	push   %eax
f010989a:	e8 e2 fe ff ff       	call   f0109781 <isPageAllocated>
f010989f:	83 c4 10             	add    $0x10,%esp
f01098a2:	85 c0                	test   %eax,%eax
f01098a4:	75 61                	jne    f0109907 <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01098a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098a9:	05 00 10 00 00       	add    $0x1000,%eax
f01098ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01098b1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f01098b8:	eb 3d                	jmp    f01098f7 <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f01098ba:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01098c1:	76 0a                	jbe    f01098cd <kmalloc+0x113>
f01098c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01098c8:	e9 4b 01 00 00       	jmp    f0109a18 <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f01098cd:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01098d2:	83 ec 08             	sub    $0x8,%esp
f01098d5:	ff 75 e8             	pushl  -0x18(%ebp)
f01098d8:	50                   	push   %eax
f01098d9:	e8 a3 fe ff ff       	call   f0109781 <isPageAllocated>
f01098de:	83 c4 10             	add    $0x10,%esp
f01098e1:	85 c0                	test   %eax,%eax
f01098e3:	74 08                	je     f01098ed <kmalloc+0x133>
					{

						i = j;
f01098e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01098e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f01098eb:	eb 1a                	jmp    f0109907 <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f01098ed:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f01098f4:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f01098f7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01098fa:	48                   	dec    %eax
f01098fb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01098fe:	77 ba                	ja     f01098ba <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109900:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0109907:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010990b:	75 16                	jne    f0109923 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f010990d:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109914:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010991b:	0f 86 6d ff ff ff    	jbe    f010988e <kmalloc+0xd4>
f0109921:	eb 01                	jmp    f0109924 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109923:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109924:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109928:	75 0a                	jne    f0109934 <kmalloc+0x17a>
f010992a:	b8 00 00 00 00       	mov    $0x0,%eax
f010992f:	e9 e4 00 00 00       	jmp    f0109a18 <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f0109934:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f010993b:	eb 57                	jmp    f0109994 <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f010993d:	83 ec 0c             	sub    $0xc,%esp
f0109940:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109943:	50                   	push   %eax
f0109944:	e8 94 eb ff ff       	call   f01084dd <allocate_frame>
f0109949:	83 c4 10             	add    $0x10,%esp
f010994c:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f010994f:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109953:	74 28                	je     f010997d <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f0109955:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109958:	c1 e0 0c             	shl    $0xc,%eax
f010995b:	89 c2                	mov    %eax,%edx
f010995d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109960:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109963:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0109966:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f010996b:	6a 02                	push   $0x2
f010996d:	51                   	push   %ecx
f010996e:	52                   	push   %edx
f010996f:	50                   	push   %eax
f0109970:	e8 35 f0 ff ff       	call   f01089aa <map_frame>
f0109975:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f0109978:	ff 45 e0             	incl   -0x20(%ebp)
f010997b:	eb 17                	jmp    f0109994 <kmalloc+0x1da>
				//cprintf("kmalloc Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)i + (k * PAGE_SIZE)))]);
				//cprintf("kmalloc Index1 : %d\n",PDX((uint32)((uint32)i + (k * PAGE_SIZE))));
			}
			else
			{
				panic("No Memory");
f010997d:	83 ec 04             	sub    $0x4,%esp
f0109980:	68 23 60 12 f0       	push   $0xf0126023
f0109985:	68 b8 00 00 00       	push   $0xb8
f010998a:	68 12 60 12 f0       	push   $0xf0126012
f010998f:	e8 a5 69 ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f0109994:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109997:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010999a:	72 a1                	jb     f010993d <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f010999c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010999f:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01099a2:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f01099a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01099aa:	29 c2                	sub    %eax,%edx
f01099ac:	89 d0                	mov    %edx,%eax
f01099ae:	2d 00 10 00 00       	sub    $0x1000,%eax
f01099b3:	c1 e8 0c             	shr    $0xc,%eax
f01099b6:	89 c2                	mov    %eax,%edx
f01099b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01099bb:	89 04 95 20 f1 71 f0 	mov    %eax,-0xf8e0ee0(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f01099c2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01099c9:	eb 39                	jmp    f0109a04 <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f01099cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01099ce:	c1 e0 0c             	shl    $0xc,%eax
f01099d1:	89 c2                	mov    %eax,%edx
f01099d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01099d6:	01 d0                	add    %edx,%eax
f01099d8:	83 ec 0c             	sub    $0xc,%esp
f01099db:	50                   	push   %eax
f01099dc:	e8 1f 01 00 00       	call   f0109b00 <kheap_physical_address>
f01099e1:	83 c4 10             	add    $0x10,%esp
f01099e4:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f01099e7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01099ea:	c1 e8 0c             	shr    $0xc,%eax
f01099ed:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01099f0:	c1 e2 0c             	shl    $0xc,%edx
f01099f3:	89 d1                	mov    %edx,%ecx
f01099f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01099f8:	01 ca                	add    %ecx,%edx
f01099fa:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109a01:	ff 45 dc             	incl   -0x24(%ebp)
f0109a04:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a07:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109a0a:	72 bf                	jb     f01099cb <kmalloc+0x211>
f0109a0c:	eb 07                	jmp    f0109a15 <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f0109a0e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a13:	eb 03                	jmp    f0109a18 <kmalloc+0x25e>
	}
	return ptr;
f0109a15:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109a18:	c9                   	leave  
f0109a19:	c3                   	ret    

f0109a1a <kfree>:

void kfree(void *va)
{
f0109a1a:	55                   	push   %ebp
f0109a1b:	89 e5                	mov    %esp,%ebp
f0109a1d:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109a20:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109a25:	05 00 10 00 00       	add    $0x1000,%eax
f0109a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109a2d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109a30:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109a35:	39 c2                	cmp    %eax,%edx
f0109a37:	73 13                	jae    f0109a4c <kfree+0x32>
        free_block(va);
f0109a39:	83 ec 0c             	sub    $0xc,%esp
f0109a3c:	ff 75 08             	pushl  0x8(%ebp)
f0109a3f:	e8 f4 80 01 00       	call   f0121b38 <free_block>
f0109a44:	83 c4 10             	add    $0x10,%esp
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f0109a47:	e9 b1 00 00 00       	jmp    f0109afd <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109a4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a4f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109a52:	0f 82 8e 00 00 00    	jb     f0109ae6 <kfree+0xcc>
f0109a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a5b:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109a60:	0f 87 80 00 00 00    	ja     f0109ae6 <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f0109a66:	8b 55 08             	mov    0x8(%ebp),%edx
f0109a69:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109a6e:	29 c2                	sub    %eax,%edx
f0109a70:	89 d0                	mov    %edx,%eax
f0109a72:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109a77:	c1 e8 0c             	shr    $0xc,%eax
f0109a7a:	8b 04 85 20 f1 71 f0 	mov    -0xf8e0ee0(,%eax,4),%eax
f0109a81:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f0109a84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109a8b:	eb 4f                	jmp    f0109adc <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109a90:	c1 e0 0c             	shl    $0xc,%eax
f0109a93:	89 c2                	mov    %eax,%edx
f0109a95:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a98:	01 d0                	add    %edx,%eax
f0109a9a:	83 ec 0c             	sub    $0xc,%esp
f0109a9d:	50                   	push   %eax
f0109a9e:	e8 5d 00 00 00       	call   f0109b00 <kheap_physical_address>
f0109aa3:	83 c4 10             	add    $0x10,%esp
f0109aa6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f0109aa9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109aac:	c1 e8 0c             	shr    $0xc,%eax
f0109aaf:	c7 04 85 40 f7 b1 f0 	movl   $0x0,-0xf4e08c0(,%eax,4)
f0109ab6:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f0109aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109abd:	c1 e0 0c             	shl    $0xc,%eax
f0109ac0:	89 c2                	mov    %eax,%edx
f0109ac2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ac5:	01 c2                	add    %eax,%edx
f0109ac7:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109acc:	83 ec 08             	sub    $0x8,%esp
f0109acf:	52                   	push   %edx
f0109ad0:	50                   	push   %eax
f0109ad1:	e8 34 f0 ff ff       	call   f0108b0a <unmap_frame>
f0109ad6:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109ad9:	ff 45 f4             	incl   -0xc(%ebp)
f0109adc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109adf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109ae2:	72 a9                	jb     f0109a8d <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109ae4:	eb 17                	jmp    f0109afd <kfree+0xe3>
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
			//cprintf("kfree Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)va + (i * PAGE_SIZE)))]);
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109ae6:	83 ec 04             	sub    $0x4,%esp
f0109ae9:	68 30 60 12 f0       	push   $0xf0126030
f0109aee:	68 e2 00 00 00       	push   $0xe2
f0109af3:	68 12 60 12 f0       	push   $0xf0126012
f0109af8:	e8 3c 68 ff ff       	call   f0100339 <_panic>
    }
}
f0109afd:	90                   	nop
f0109afe:	c9                   	leave  
f0109aff:	c3                   	ret    

f0109b00 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109b00:	55                   	push   %ebp
f0109b01:	89 e5                	mov    %esp,%ebp
f0109b03:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109b06:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f0109b0d:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109b12:	83 ec 04             	sub    $0x4,%esp
f0109b15:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109b18:	52                   	push   %edx
f0109b19:	ff 75 08             	pushl  0x8(%ebp)
f0109b1c:	50                   	push   %eax
f0109b1d:	e8 72 ef ff ff       	call   f0108a94 <get_frame_info>
f0109b22:	83 c4 10             	add    $0x10,%esp
f0109b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109b28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109b2c:	75 07                	jne    f0109b35 <kheap_physical_address+0x35>
		return 0;
f0109b2e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109b33:	eb 26                	jmp    f0109b5b <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f0109b35:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b38:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109b3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109b40:	83 ec 0c             	sub    $0xc,%esp
f0109b43:	ff 75 f4             	pushl  -0xc(%ebp)
f0109b46:	e8 12 fa ff ff       	call   f010955d <to_physical_address>
f0109b4b:	83 c4 10             	add    $0x10,%esp
f0109b4e:	89 c2                	mov    %eax,%edx
f0109b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b53:	01 d0                	add    %edx,%eax
f0109b55:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f0109b58:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109b5b:	c9                   	leave  
f0109b5c:	c3                   	ret    

f0109b5d <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109b5d:	55                   	push   %ebp
f0109b5e:	89 e5                	mov    %esp,%ebp
f0109b60:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109b63:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b66:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109b6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109b6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b71:	c1 e8 0c             	shr    $0xc,%eax
f0109b74:	8b 04 85 40 f7 b1 f0 	mov    -0xf4e08c0(,%eax,4),%eax
f0109b7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109b7e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109b82:	74 06                	je     f0109b8a <kheap_virtual_address+0x2d>
f0109b84:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0109b87:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f0109b8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0109b8d:	c9                   	leave  
f0109b8e:	c3                   	ret    

f0109b8f <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109b8f:	55                   	push   %ebp
f0109b90:	89 e5                	mov    %esp,%ebp
f0109b92:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f0109b95:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f0109b9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109ba0:	75 16                	jne    f0109bb8 <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109ba2:	83 ec 0c             	sub    $0xc,%esp
f0109ba5:	ff 75 0c             	pushl  0xc(%ebp)
f0109ba8:	e8 0d fc ff ff       	call   f01097ba <kmalloc>
f0109bad:	83 c4 10             	add    $0x10,%esp
f0109bb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109bb3:	e9 37 03 00 00       	jmp    f0109eef <krealloc+0x360>
	} else if(new_size == 0){
f0109bb8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0109bbc:	75 13                	jne    f0109bd1 <krealloc+0x42>
		kfree(va);
f0109bbe:	83 ec 0c             	sub    $0xc,%esp
f0109bc1:	ff 75 08             	pushl  0x8(%ebp)
f0109bc4:	e8 51 fe ff ff       	call   f0109a1a <kfree>
f0109bc9:	83 c4 10             	add    $0x10,%esp
f0109bcc:	e9 1e 03 00 00       	jmp    f0109eef <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109bd1:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109bd6:	05 00 10 00 00       	add    $0x1000,%eax
f0109bdb:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f0109bde:	8b 55 08             	mov    0x8(%ebp),%edx
f0109be1:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109be6:	39 c2                	cmp    %eax,%edx
f0109be8:	73 19                	jae    f0109c03 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f0109bea:	83 ec 08             	sub    $0x8,%esp
f0109bed:	ff 75 0c             	pushl  0xc(%ebp)
f0109bf0:	ff 75 08             	pushl  0x8(%ebp)
f0109bf3:	e8 40 80 01 00       	call   f0121c38 <realloc_block_FF>
f0109bf8:	83 c4 10             	add    $0x10,%esp
f0109bfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109bfe:	e9 ec 02 00 00       	jmp    f0109eef <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109c03:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c06:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109c09:	0f 82 c8 02 00 00    	jb     f0109ed7 <krealloc+0x348>
f0109c0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c12:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109c17:	0f 87 ba 02 00 00    	ja     f0109ed7 <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f0109c1d:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f0109c24:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109c2a:	01 d0                	add    %edx,%eax
f0109c2c:	48                   	dec    %eax
f0109c2d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109c30:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109c33:	ba 00 00 00 00       	mov    $0x0,%edx
f0109c38:	f7 75 d4             	divl   -0x2c(%ebp)
f0109c3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109c3e:	29 d0                	sub    %edx,%eax
f0109c40:	c1 e8 0c             	shr    $0xc,%eax
f0109c43:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f0109c46:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c49:	c1 e8 0c             	shr    $0xc,%eax
f0109c4c:	8b 04 85 20 f1 71 f0 	mov    -0xf8e0ee0(,%eax,4),%eax
f0109c53:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f0109c56:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109c59:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0109c5c:	0f 87 ee 00 00 00    	ja     f0109d50 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109c62:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f0109c69:	77 63                	ja     f0109cce <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f0109c6b:	e8 8b f8 ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f0109c70:	84 c0                	test   %al,%al
f0109c72:	74 13                	je     f0109c87 <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f0109c74:	83 ec 0c             	sub    $0xc,%esp
f0109c77:	ff 75 0c             	pushl  0xc(%ebp)
f0109c7a:	e8 18 70 01 00       	call   f0120c97 <alloc_block_FF>
f0109c7f:	83 c4 10             	add    $0x10,%esp
f0109c82:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109c85:	eb 1a                	jmp    f0109ca1 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f0109c87:	e8 84 f8 ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f0109c8c:	84 c0                	test   %al,%al
f0109c8e:	74 11                	je     f0109ca1 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109c90:	83 ec 0c             	sub    $0xc,%esp
f0109c93:	ff 75 0c             	pushl  0xc(%ebp)
f0109c96:	e8 b8 74 01 00       	call   f0121153 <alloc_block_BF>
f0109c9b:	83 c4 10             	add    $0x10,%esp
f0109c9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109ca1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109ca5:	74 14                	je     f0109cbb <krealloc+0x12c>
f0109ca7:	83 ec 04             	sub    $0x4,%esp
f0109caa:	ff 75 0c             	pushl  0xc(%ebp)
f0109cad:	ff 75 08             	pushl  0x8(%ebp)
f0109cb0:	ff 75 f4             	pushl  -0xc(%ebp)
f0109cb3:	e8 12 64 01 00       	call   f01200ca <memcpy>
f0109cb8:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109cbb:	83 ec 0c             	sub    $0xc,%esp
f0109cbe:	ff 75 08             	pushl  0x8(%ebp)
f0109cc1:	e8 54 fd ff ff       	call   f0109a1a <kfree>
f0109cc6:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109cc9:	e9 20 02 00 00       	jmp    f0109eee <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109cce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109cd1:	c1 e0 0c             	shl    $0xc,%eax
f0109cd4:	89 c2                	mov    %eax,%edx
f0109cd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cd9:	01 d0                	add    %edx,%eax
f0109cdb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109cde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109ce5:	eb 4f                	jmp    f0109d36 <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109ce7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cea:	c1 e0 0c             	shl    $0xc,%eax
f0109ced:	89 c2                	mov    %eax,%edx
f0109cef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109cf2:	01 d0                	add    %edx,%eax
f0109cf4:	83 ec 0c             	sub    $0xc,%esp
f0109cf7:	50                   	push   %eax
f0109cf8:	e8 03 fe ff ff       	call   f0109b00 <kheap_physical_address>
f0109cfd:	83 c4 10             	add    $0x10,%esp
f0109d00:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109d03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109d06:	c1 e8 0c             	shr    $0xc,%eax
f0109d09:	c7 04 85 40 f7 b1 f0 	movl   $0x0,-0xf4e08c0(,%eax,4)
f0109d10:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109d14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d17:	c1 e0 0c             	shl    $0xc,%eax
f0109d1a:	89 c2                	mov    %eax,%edx
f0109d1c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109d1f:	01 c2                	add    %eax,%edx
f0109d21:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109d26:	83 ec 08             	sub    $0x8,%esp
f0109d29:	52                   	push   %edx
f0109d2a:	50                   	push   %eax
f0109d2b:	e8 da ed ff ff       	call   f0108b0a <unmap_frame>
f0109d30:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109d33:	ff 45 f0             	incl   -0x10(%ebp)
f0109d36:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109d39:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109d3c:	89 c2                	mov    %eax,%edx
f0109d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d41:	39 c2                	cmp    %eax,%edx
f0109d43:	77 a2                	ja     f0109ce7 <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109d45:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d48:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109d4b:	e9 9e 01 00 00       	jmp    f0109eee <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109d50:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109d53:	c1 e0 0c             	shl    $0xc,%eax
f0109d56:	89 c2                	mov    %eax,%edx
f0109d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d5b:	01 d0                	add    %edx,%eax
f0109d5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109d60:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109d67:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109d6e:	eb 33                	jmp    f0109da3 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109d70:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109d77:	0f 87 19 01 00 00    	ja     f0109e96 <krealloc+0x307>
f0109d7d:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109d82:	83 ec 08             	sub    $0x8,%esp
f0109d85:	ff 75 ec             	pushl  -0x14(%ebp)
f0109d88:	50                   	push   %eax
f0109d89:	e8 f3 f9 ff ff       	call   f0109781 <isPageAllocated>
f0109d8e:	83 c4 10             	add    $0x10,%esp
f0109d91:	85 c0                	test   %eax,%eax
f0109d93:	0f 85 fd 00 00 00    	jne    f0109e96 <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109d99:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109da0:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109da3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109da6:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109da9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109dac:	77 c2                	ja     f0109d70 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109dae:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109db5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109dbc:	eb 5c                	jmp    f0109e1a <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109dbe:	83 ec 0c             	sub    $0xc,%esp
f0109dc1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109dc4:	50                   	push   %eax
f0109dc5:	e8 13 e7 ff ff       	call   f01084dd <allocate_frame>
f0109dca:	83 c4 10             	add    $0x10,%esp
f0109dcd:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109dd0:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109dd4:	74 2d                	je     f0109e03 <krealloc+0x274>
f0109dd6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109dd9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109ddc:	01 d0                	add    %edx,%eax
f0109dde:	c1 e0 0c             	shl    $0xc,%eax
f0109de1:	89 c2                	mov    %eax,%edx
f0109de3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109de6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109de9:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109dec:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0109df1:	6a 02                	push   $0x2
f0109df3:	51                   	push   %ecx
f0109df4:	52                   	push   %edx
f0109df5:	50                   	push   %eax
f0109df6:	e8 af eb ff ff       	call   f01089aa <map_frame>
f0109dfb:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109dfe:	ff 45 e0             	incl   -0x20(%ebp)
f0109e01:	eb 17                	jmp    f0109e1a <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109e03:	83 ec 04             	sub    $0x4,%esp
f0109e06:	68 23 60 12 f0       	push   $0xf0126023
f0109e0b:	68 4f 01 00 00       	push   $0x14f
f0109e10:	68 12 60 12 f0       	push   $0xf0126012
f0109e15:	e8 1f 65 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109e1a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e1d:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109e20:	89 c2                	mov    %eax,%edx
f0109e22:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109e25:	39 c2                	cmp    %eax,%edx
f0109e27:	77 95                	ja     f0109dbe <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109e29:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e2c:	c1 e8 0c             	shr    $0xc,%eax
f0109e2f:	89 c2                	mov    %eax,%edx
f0109e31:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e34:	89 04 95 20 f1 71 f0 	mov    %eax,-0xf8e0ee0(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109e3b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109e42:	eb 43                	jmp    f0109e87 <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109e44:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109e47:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109e4a:	01 d0                	add    %edx,%eax
f0109e4c:	c1 e0 0c             	shl    $0xc,%eax
f0109e4f:	89 c2                	mov    %eax,%edx
f0109e51:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e54:	01 d0                	add    %edx,%eax
f0109e56:	83 ec 0c             	sub    $0xc,%esp
f0109e59:	50                   	push   %eax
f0109e5a:	e8 a1 fc ff ff       	call   f0109b00 <kheap_physical_address>
f0109e5f:	83 c4 10             	add    $0x10,%esp
f0109e62:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109e65:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109e68:	c1 e8 0c             	shr    $0xc,%eax
f0109e6b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109e6e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109e71:	01 ca                	add    %ecx,%edx
f0109e73:	89 d1                	mov    %edx,%ecx
f0109e75:	c1 e1 0c             	shl    $0xc,%ecx
f0109e78:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e7b:	01 ca                	add    %ecx,%edx
f0109e7d:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109e84:	ff 45 dc             	incl   -0x24(%ebp)
f0109e87:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e8a:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109e8d:	89 c2                	mov    %eax,%edx
f0109e8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109e92:	39 c2                	cmp    %eax,%edx
f0109e94:	77 ae                	ja     f0109e44 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109e96:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109e9a:	75 52                	jne    f0109eee <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109e9c:	83 ec 0c             	sub    $0xc,%esp
f0109e9f:	ff 75 0c             	pushl  0xc(%ebp)
f0109ea2:	e8 13 f9 ff ff       	call   f01097ba <kmalloc>
f0109ea7:	83 c4 10             	add    $0x10,%esp
f0109eaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109ead:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109eb1:	74 14                	je     f0109ec7 <krealloc+0x338>
f0109eb3:	83 ec 04             	sub    $0x4,%esp
f0109eb6:	ff 75 0c             	pushl  0xc(%ebp)
f0109eb9:	ff 75 08             	pushl  0x8(%ebp)
f0109ebc:	ff 75 f4             	pushl  -0xc(%ebp)
f0109ebf:	e8 06 62 01 00       	call   f01200ca <memcpy>
f0109ec4:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109ec7:	83 ec 0c             	sub    $0xc,%esp
f0109eca:	ff 75 08             	pushl  0x8(%ebp)
f0109ecd:	e8 48 fb ff ff       	call   f0109a1a <kfree>
f0109ed2:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109ed5:	eb 17                	jmp    f0109eee <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109ed7:	83 ec 04             	sub    $0x4,%esp
f0109eda:	68 58 60 12 f0       	push   $0xf0126058
f0109edf:	68 5e 01 00 00       	push   $0x15e
f0109ee4:	68 12 60 12 f0       	push   $0xf0126012
f0109ee9:	e8 4b 64 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109eee:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109eef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109ef2:	c9                   	leave  
f0109ef3:	c3                   	ret    

f0109ef4 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109ef4:	55                   	push   %ebp
f0109ef5:	89 e5                	mov    %esp,%ebp
f0109ef7:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109efa:	83 ec 04             	sub    $0x4,%esp
f0109efd:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109f00:	50                   	push   %eax
f0109f01:	ff 75 0c             	pushl  0xc(%ebp)
f0109f04:	ff 75 08             	pushl  0x8(%ebp)
f0109f07:	e8 0e e8 ff ff       	call   f010871a <get_page_table>
f0109f0c:	83 c4 10             	add    $0x10,%esp
f0109f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f15:	85 c0                	test   %eax,%eax
f0109f17:	74 64                	je     f0109f7d <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f1c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109f1f:	c1 ea 0c             	shr    $0xc,%edx
f0109f22:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109f28:	c1 e2 02             	shl    $0x2,%edx
f0109f2b:	01 c2                	add    %eax,%edx
f0109f2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f30:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109f33:	c1 e9 0c             	shr    $0xc,%ecx
f0109f36:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109f3c:	c1 e1 02             	shl    $0x2,%ecx
f0109f3f:	01 c8                	add    %ecx,%eax
f0109f41:	8b 00                	mov    (%eax),%eax
f0109f43:	0b 45 10             	or     0x10(%ebp),%eax
f0109f46:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109f48:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f4b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109f4e:	c1 ea 0c             	shr    $0xc,%edx
f0109f51:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109f57:	c1 e2 02             	shl    $0x2,%edx
f0109f5a:	01 d0                	add    %edx,%eax
f0109f5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109f5f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109f62:	c1 e9 0c             	shr    $0xc,%ecx
f0109f65:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109f6b:	c1 e1 02             	shl    $0x2,%ecx
f0109f6e:	01 ca                	add    %ecx,%edx
f0109f70:	8b 12                	mov    (%edx),%edx
f0109f72:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109f75:	f7 d1                	not    %ecx
f0109f77:	21 ca                	and    %ecx,%edx
f0109f79:	89 10                	mov    %edx,(%eax)
f0109f7b:	eb 27                	jmp    f0109fa4 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109f7d:	83 ec 08             	sub    $0x8,%esp
f0109f80:	ff 75 0c             	pushl  0xc(%ebp)
f0109f83:	68 84 60 12 f0       	push   $0xf0126084
f0109f88:	e8 fe 6f ff ff       	call   f0100f8b <cprintf>
f0109f8d:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109f90:	83 ec 04             	sub    $0x4,%esp
f0109f93:	68 ac 60 12 f0       	push   $0xf01260ac
f0109f98:	6a 1c                	push   $0x1c
f0109f9a:	68 20 61 12 f0       	push   $0xf0126120
f0109f9f:	e8 95 63 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109fa4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fa7:	83 ec 08             	sub    $0x8,%esp
f0109faa:	50                   	push   %eax
f0109fab:	6a 00                	push   $0x0
f0109fad:	e8 32 e1 ff ff       	call   f01080e4 <tlb_invalidate>
f0109fb2:	83 c4 10             	add    $0x10,%esp
}
f0109fb5:	90                   	nop
f0109fb6:	c9                   	leave  
f0109fb7:	c3                   	ret    

f0109fb8 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109fb8:	55                   	push   %ebp
f0109fb9:	89 e5                	mov    %esp,%ebp
f0109fbb:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109fbe:	83 ec 04             	sub    $0x4,%esp
f0109fc1:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109fc4:	50                   	push   %eax
f0109fc5:	ff 75 0c             	pushl  0xc(%ebp)
f0109fc8:	ff 75 08             	pushl  0x8(%ebp)
f0109fcb:	e8 4a e7 ff ff       	call   f010871a <get_page_table>
f0109fd0:	83 c4 10             	add    $0x10,%esp
f0109fd3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109fd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fd9:	85 c0                	test   %eax,%eax
f0109fdb:	74 1d                	je     f0109ffa <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109fdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fe0:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109fe3:	c1 ea 0c             	shr    $0xc,%edx
f0109fe6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109fec:	c1 e2 02             	shl    $0x2,%edx
f0109fef:	01 d0                	add    %edx,%eax
f0109ff1:	8b 00                	mov    (%eax),%eax
f0109ff3:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109ff8:	eb 05                	jmp    f0109fff <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109ffa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109fff:	c9                   	leave  
f010a000:	c3                   	ret    

f010a001 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f010a001:	55                   	push   %ebp
f010a002:	89 e5                	mov    %esp,%ebp
f010a004:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a007:	83 ec 04             	sub    $0x4,%esp
f010a00a:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a00d:	50                   	push   %eax
f010a00e:	ff 75 0c             	pushl  0xc(%ebp)
f010a011:	ff 75 08             	pushl  0x8(%ebp)
f010a014:	e8 01 e7 ff ff       	call   f010871a <get_page_table>
f010a019:	83 c4 10             	add    $0x10,%esp
f010a01c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010a01f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a022:	85 c0                	test   %eax,%eax
f010a024:	74 46                	je     f010a06c <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f010a026:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a029:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a02c:	c1 ea 0c             	shr    $0xc,%edx
f010a02f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a035:	c1 e2 02             	shl    $0x2,%edx
f010a038:	01 d0                	add    %edx,%eax
f010a03a:	8b 00                	mov    (%eax),%eax
f010a03c:	83 ec 04             	sub    $0x4,%esp
f010a03f:	50                   	push   %eax
f010a040:	ff 75 0c             	pushl  0xc(%ebp)
f010a043:	68 3c 61 12 f0       	push   $0xf012613c
f010a048:	e8 3e 6f ff ff       	call   f0100f8b <cprintf>
f010a04d:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010a050:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a053:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a056:	c1 ea 0c             	shr    $0xc,%edx
f010a059:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a05f:	c1 e2 02             	shl    $0x2,%edx
f010a062:	01 d0                	add    %edx,%eax
f010a064:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a06a:	eb 14                	jmp    f010a080 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a06c:	83 ec 04             	sub    $0x4,%esp
f010a06f:	68 64 61 12 f0       	push   $0xf0126164
f010a074:	6a 47                	push   $0x47
f010a076:	68 20 61 12 f0       	push   $0xf0126120
f010a07b:	e8 b9 62 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a080:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a083:	83 ec 08             	sub    $0x8,%esp
f010a086:	50                   	push   %eax
f010a087:	6a 00                	push   $0x0
f010a089:	e8 56 e0 ff ff       	call   f01080e4 <tlb_invalidate>
f010a08e:	83 c4 10             	add    $0x10,%esp
}
f010a091:	90                   	nop
f010a092:	c9                   	leave  
f010a093:	c3                   	ret    

f010a094 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010a094:	55                   	push   %ebp
f010a095:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010a097:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a09a:	c1 e8 16             	shr    $0x16,%eax
f010a09d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0a7:	01 d0                	add    %edx,%eax
f010a0a9:	8b 00                	mov    (%eax),%eax
f010a0ab:	83 e0 20             	and    $0x20,%eax
f010a0ae:	85 c0                	test   %eax,%eax
f010a0b0:	0f 95 c0             	setne  %al
f010a0b3:	0f b6 c0             	movzbl %al,%eax
}
f010a0b6:	5d                   	pop    %ebp
f010a0b7:	c3                   	ret    

f010a0b8 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010a0b8:	55                   	push   %ebp
f010a0b9:	89 e5                	mov    %esp,%ebp
f010a0bb:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f010a0be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a0c1:	c1 e8 16             	shr    $0x16,%eax
f010a0c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a0cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ce:	01 d0                	add    %edx,%eax
f010a0d0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a0d3:	c1 ea 16             	shr    $0x16,%edx
f010a0d6:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f010a0dd:	8b 55 08             	mov    0x8(%ebp),%edx
f010a0e0:	01 ca                	add    %ecx,%edx
f010a0e2:	8b 12                	mov    (%edx),%edx
f010a0e4:	83 e2 df             	and    $0xffffffdf,%edx
f010a0e7:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a0e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a0ec:	83 ec 08             	sub    $0x8,%esp
f010a0ef:	50                   	push   %eax
f010a0f0:	6a 00                	push   $0x0
f010a0f2:	e8 ed df ff ff       	call   f01080e4 <tlb_invalidate>
f010a0f7:	83 c4 10             	add    $0x10,%esp
}
f010a0fa:	90                   	nop
f010a0fb:	c9                   	leave  
f010a0fc:	c3                   	ret    

f010a0fd <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f010a0fd:	55                   	push   %ebp
f010a0fe:	89 e5                	mov    %esp,%ebp
f010a100:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f010a103:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a106:	c1 e8 16             	shr    $0x16,%eax
f010a109:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a110:	8b 45 08             	mov    0x8(%ebp),%eax
f010a113:	01 d0                	add    %edx,%eax
f010a115:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010a11b:	0f 20 d8             	mov    %cr3,%eax
f010a11e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010a121:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a124:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010a127:	90                   	nop
f010a128:	c9                   	leave  
f010a129:	c3                   	ret    

f010a12a <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010a12a:	55                   	push   %ebp
f010a12b:	89 e5                	mov    %esp,%ebp
f010a12d:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f010a130:	83 ec 0c             	sub    $0xc,%esp
f010a133:	6a 18                	push   $0x18
f010a135:	e8 80 f6 ff ff       	call   f01097ba <kmalloc>
f010a13a:	83 c4 10             	add    $0x10,%esp
f010a13d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f010a140:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a144:	75 14                	jne    f010a15a <env_page_ws_list_create_element+0x30>
f010a146:	83 ec 04             	sub    $0x4,%esp
f010a149:	68 dc 61 12 f0       	push   $0xf01261dc
f010a14e:	6a 19                	push   $0x19
f010a150:	68 0c 62 12 f0       	push   $0xf012620c
f010a155:	e8 df 61 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f010a15a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a15d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f010a160:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a163:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a166:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a169:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a16e:	89 c2                	mov    %eax,%edx
f010a170:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a173:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f010a175:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a178:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f010a17c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a17f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f010a186:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a189:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f010a190:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f010a193:	c9                   	leave  
f010a194:	c3                   	ret    

f010a195 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a195:	55                   	push   %ebp
f010a196:	89 e5                	mov    %esp,%ebp
f010a198:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a19b:	83 ec 0c             	sub    $0xc,%esp
f010a19e:	6a 02                	push   $0x2
f010a1a0:	e8 06 57 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010a1a5:	83 c4 10             	add    $0x10,%esp
f010a1a8:	85 c0                	test   %eax,%eax
f010a1aa:	0f 84 e5 03 00 00    	je     f010a595 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010a1b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010a1b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a1be:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c1:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a1c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1ca:	e9 3b 02 00 00       	jmp    f010a40a <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a1cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1d2:	8b 00                	mov    (%eax),%eax
f010a1d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a1d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a1da:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a1df:	89 c2                	mov    %eax,%edx
f010a1e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010a1e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a1ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a1ef:	39 c2                	cmp    %eax,%edx
f010a1f1:	0f 85 07 02 00 00    	jne    f010a3fe <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010a1f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1fa:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a200:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a203:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a206:	8b 10                	mov    (%eax),%edx
f010a208:	8b 45 08             	mov    0x8(%ebp),%eax
f010a20b:	8b 40 64             	mov    0x64(%eax),%eax
f010a20e:	83 ec 08             	sub    $0x8,%esp
f010a211:	52                   	push   %edx
f010a212:	50                   	push   %eax
f010a213:	e8 f2 e8 ff ff       	call   f0108b0a <unmap_frame>
f010a218:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a21b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a21f:	75 14                	jne    f010a235 <env_page_ws_invalidate+0xa0>
f010a221:	83 ec 04             	sub    $0x4,%esp
f010a224:	68 2b 62 12 f0       	push   $0xf012622b
f010a229:	6a 2f                	push   $0x2f
f010a22b:	68 0c 62 12 f0       	push   $0xf012620c
f010a230:	e8 04 61 ff ff       	call   f0100339 <_panic>
f010a235:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a238:	8b 40 10             	mov    0x10(%eax),%eax
f010a23b:	85 c0                	test   %eax,%eax
f010a23d:	74 11                	je     f010a250 <env_page_ws_invalidate+0xbb>
f010a23f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a242:	8b 40 10             	mov    0x10(%eax),%eax
f010a245:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a248:	8b 52 14             	mov    0x14(%edx),%edx
f010a24b:	89 50 14             	mov    %edx,0x14(%eax)
f010a24e:	eb 0f                	jmp    f010a25f <env_page_ws_invalidate+0xca>
f010a250:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a253:	8b 50 14             	mov    0x14(%eax),%edx
f010a256:	8b 45 08             	mov    0x8(%ebp),%eax
f010a259:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a25f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a262:	8b 40 14             	mov    0x14(%eax),%eax
f010a265:	85 c0                	test   %eax,%eax
f010a267:	74 11                	je     f010a27a <env_page_ws_invalidate+0xe5>
f010a269:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a26c:	8b 40 14             	mov    0x14(%eax),%eax
f010a26f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a272:	8b 52 10             	mov    0x10(%edx),%edx
f010a275:	89 50 10             	mov    %edx,0x10(%eax)
f010a278:	eb 0f                	jmp    f010a289 <env_page_ws_invalidate+0xf4>
f010a27a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a27d:	8b 50 10             	mov    0x10(%eax),%edx
f010a280:	8b 45 08             	mov    0x8(%ebp),%eax
f010a283:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a28c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a293:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a296:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a29d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2a0:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a2a6:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a2a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ac:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a2b2:	83 ec 0c             	sub    $0xc,%esp
f010a2b5:	ff 75 f0             	pushl  -0x10(%ebp)
f010a2b8:	e8 5d f7 ff ff       	call   f0109a1a <kfree>
f010a2bd:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a2c0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a2c4:	0f 84 2b 01 00 00    	je     f010a3f5 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a2ca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a2ce:	75 14                	jne    f010a2e4 <env_page_ws_invalidate+0x14f>
f010a2d0:	83 ec 04             	sub    $0x4,%esp
f010a2d3:	68 2b 62 12 f0       	push   $0xf012622b
f010a2d8:	6a 35                	push   $0x35
f010a2da:	68 0c 62 12 f0       	push   $0xf012620c
f010a2df:	e8 55 60 ff ff       	call   f0100339 <_panic>
f010a2e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a2e7:	8b 40 10             	mov    0x10(%eax),%eax
f010a2ea:	85 c0                	test   %eax,%eax
f010a2ec:	74 11                	je     f010a2ff <env_page_ws_invalidate+0x16a>
f010a2ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a2f1:	8b 40 10             	mov    0x10(%eax),%eax
f010a2f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a2f7:	8b 52 14             	mov    0x14(%edx),%edx
f010a2fa:	89 50 14             	mov    %edx,0x14(%eax)
f010a2fd:	eb 0f                	jmp    f010a30e <env_page_ws_invalidate+0x179>
f010a2ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a302:	8b 50 14             	mov    0x14(%eax),%edx
f010a305:	8b 45 08             	mov    0x8(%ebp),%eax
f010a308:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a30e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a311:	8b 40 14             	mov    0x14(%eax),%eax
f010a314:	85 c0                	test   %eax,%eax
f010a316:	74 11                	je     f010a329 <env_page_ws_invalidate+0x194>
f010a318:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a31b:	8b 40 14             	mov    0x14(%eax),%eax
f010a31e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a321:	8b 52 10             	mov    0x10(%edx),%edx
f010a324:	89 50 10             	mov    %edx,0x10(%eax)
f010a327:	eb 0f                	jmp    f010a338 <env_page_ws_invalidate+0x1a3>
f010a329:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a32c:	8b 50 10             	mov    0x10(%eax),%edx
f010a32f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a332:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a338:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a33b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a342:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a345:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a34c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a34f:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a355:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a358:	8b 45 08             	mov    0x8(%ebp),%eax
f010a35b:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a361:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a365:	75 14                	jne    f010a37b <env_page_ws_invalidate+0x1e6>
f010a367:	83 ec 04             	sub    $0x4,%esp
f010a36a:	68 4c 62 12 f0       	push   $0xf012624c
f010a36f:	6a 36                	push   $0x36
f010a371:	68 0c 62 12 f0       	push   $0xf012620c
f010a376:	e8 be 5f ff ff       	call   f0100339 <_panic>
f010a37b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a37e:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a384:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a387:	89 50 14             	mov    %edx,0x14(%eax)
f010a38a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a38d:	8b 40 14             	mov    0x14(%eax),%eax
f010a390:	85 c0                	test   %eax,%eax
f010a392:	74 11                	je     f010a3a5 <env_page_ws_invalidate+0x210>
f010a394:	8b 45 08             	mov    0x8(%ebp),%eax
f010a397:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a39d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3a0:	89 50 10             	mov    %edx,0x10(%eax)
f010a3a3:	eb 0c                	jmp    f010a3b1 <env_page_ws_invalidate+0x21c>
f010a3a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3ab:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a3b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3b7:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a3bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3c0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a3c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ca:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a3d0:	8d 50 01             	lea    0x1(%eax),%edx
f010a3d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d6:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a3dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3df:	8b 10                	mov    (%eax),%edx
f010a3e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3e4:	8b 40 64             	mov    0x64(%eax),%eax
f010a3e7:	6a 00                	push   $0x0
f010a3e9:	6a 01                	push   $0x1
f010a3eb:	52                   	push   %edx
f010a3ec:	50                   	push   %eax
f010a3ed:	e8 02 fb ff ff       	call   f0109ef4 <pt_set_page_permissions>
f010a3f2:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a3f5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a3fc:	eb 43                	jmp    f010a441 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a3fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010a401:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a407:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a40a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a40e:	74 08                	je     f010a418 <env_page_ws_invalidate+0x283>
f010a410:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a413:	8b 40 10             	mov    0x10(%eax),%eax
f010a416:	eb 05                	jmp    f010a41d <env_page_ws_invalidate+0x288>
f010a418:	b8 00 00 00 00       	mov    $0x0,%eax
f010a41d:	8b 55 08             	mov    0x8(%ebp),%edx
f010a420:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a426:	8b 45 08             	mov    0x8(%ebp),%eax
f010a429:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a42f:	85 c0                	test   %eax,%eax
f010a431:	0f 85 98 fd ff ff    	jne    f010a1cf <env_page_ws_invalidate+0x3a>
f010a437:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a43b:	0f 85 8e fd ff ff    	jne    f010a1cf <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a441:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a445:	0f 85 a4 02 00 00    	jne    f010a6ef <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a44b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a452:	8b 45 08             	mov    0x8(%ebp),%eax
f010a455:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a45b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a45e:	e9 f6 00 00 00       	jmp    f010a559 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a463:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a466:	8b 00                	mov    (%eax),%eax
f010a468:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a46b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a46e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a473:	89 c2                	mov    %eax,%edx
f010a475:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a478:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a47b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a47e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a483:	39 c2                	cmp    %eax,%edx
f010a485:	0f 85 c2 00 00 00    	jne    f010a54d <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a48b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a48e:	8b 10                	mov    (%eax),%edx
f010a490:	8b 45 08             	mov    0x8(%ebp),%eax
f010a493:	8b 40 64             	mov    0x64(%eax),%eax
f010a496:	83 ec 08             	sub    $0x8,%esp
f010a499:	52                   	push   %edx
f010a49a:	50                   	push   %eax
f010a49b:	e8 6a e6 ff ff       	call   f0108b0a <unmap_frame>
f010a4a0:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a4a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4a7:	75 14                	jne    f010a4bd <env_page_ws_invalidate+0x328>
f010a4a9:	83 ec 04             	sub    $0x4,%esp
f010a4ac:	68 2b 62 12 f0       	push   $0xf012622b
f010a4b1:	6a 46                	push   $0x46
f010a4b3:	68 0c 62 12 f0       	push   $0xf012620c
f010a4b8:	e8 7c 5e ff ff       	call   f0100339 <_panic>
f010a4bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4c0:	8b 40 10             	mov    0x10(%eax),%eax
f010a4c3:	85 c0                	test   %eax,%eax
f010a4c5:	74 11                	je     f010a4d8 <env_page_ws_invalidate+0x343>
f010a4c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4ca:	8b 40 10             	mov    0x10(%eax),%eax
f010a4cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a4d0:	8b 52 14             	mov    0x14(%edx),%edx
f010a4d3:	89 50 14             	mov    %edx,0x14(%eax)
f010a4d6:	eb 0f                	jmp    f010a4e7 <env_page_ws_invalidate+0x352>
f010a4d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4db:	8b 50 14             	mov    0x14(%eax),%edx
f010a4de:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4e1:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a4e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4ea:	8b 40 14             	mov    0x14(%eax),%eax
f010a4ed:	85 c0                	test   %eax,%eax
f010a4ef:	74 11                	je     f010a502 <env_page_ws_invalidate+0x36d>
f010a4f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4f4:	8b 40 14             	mov    0x14(%eax),%eax
f010a4f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a4fa:	8b 52 10             	mov    0x10(%edx),%edx
f010a4fd:	89 50 10             	mov    %edx,0x10(%eax)
f010a500:	eb 0f                	jmp    f010a511 <env_page_ws_invalidate+0x37c>
f010a502:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a505:	8b 50 10             	mov    0x10(%eax),%edx
f010a508:	8b 45 08             	mov    0x8(%ebp),%eax
f010a50b:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a511:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a514:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a51b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a51e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a525:	8b 45 08             	mov    0x8(%ebp),%eax
f010a528:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a52e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a531:	8b 45 08             	mov    0x8(%ebp),%eax
f010a534:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a53a:	83 ec 0c             	sub    $0xc,%esp
f010a53d:	ff 75 f0             	pushl  -0x10(%ebp)
f010a540:	e8 d5 f4 ff ff       	call   f0109a1a <kfree>
f010a545:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a548:	e9 a2 01 00 00       	jmp    f010a6ef <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a54d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a550:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a556:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a559:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a55d:	74 08                	je     f010a567 <env_page_ws_invalidate+0x3d2>
f010a55f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a562:	8b 40 10             	mov    0x10(%eax),%eax
f010a565:	eb 05                	jmp    f010a56c <env_page_ws_invalidate+0x3d7>
f010a567:	b8 00 00 00 00       	mov    $0x0,%eax
f010a56c:	8b 55 08             	mov    0x8(%ebp),%edx
f010a56f:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a575:	8b 45 08             	mov    0x8(%ebp),%eax
f010a578:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a57e:	85 c0                	test   %eax,%eax
f010a580:	0f 85 dd fe ff ff    	jne    f010a463 <env_page_ws_invalidate+0x2ce>
f010a586:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a58a:	0f 85 d3 fe ff ff    	jne    f010a463 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a590:	e9 5a 01 00 00       	jmp    f010a6ef <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a595:	8b 45 08             	mov    0x8(%ebp),%eax
f010a598:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a59e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a5a1:	e9 10 01 00 00       	jmp    f010a6b6 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a5a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5a9:	8b 00                	mov    (%eax),%eax
f010a5ab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a5ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a5b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a5b6:	89 c2                	mov    %eax,%edx
f010a5b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a5be:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a5c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a5c6:	39 c2                	cmp    %eax,%edx
f010a5c8:	0f 85 dc 00 00 00    	jne    f010a6aa <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a5ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5d1:	8b 10                	mov    (%eax),%edx
f010a5d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5d6:	8b 40 64             	mov    0x64(%eax),%eax
f010a5d9:	83 ec 08             	sub    $0x8,%esp
f010a5dc:	52                   	push   %edx
f010a5dd:	50                   	push   %eax
f010a5de:	e8 27 e5 ff ff       	call   f0108b0a <unmap_frame>
f010a5e3:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a5e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a5ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a5f2:	75 0f                	jne    f010a603 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a5f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5f7:	8b 50 10             	mov    0x10(%eax),%edx
f010a5fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5fd:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a603:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a607:	75 14                	jne    f010a61d <env_page_ws_invalidate+0x488>
f010a609:	83 ec 04             	sub    $0x4,%esp
f010a60c:	68 2b 62 12 f0       	push   $0xf012622b
f010a611:	6a 5c                	push   $0x5c
f010a613:	68 0c 62 12 f0       	push   $0xf012620c
f010a618:	e8 1c 5d ff ff       	call   f0100339 <_panic>
f010a61d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a620:	8b 40 10             	mov    0x10(%eax),%eax
f010a623:	85 c0                	test   %eax,%eax
f010a625:	74 11                	je     f010a638 <env_page_ws_invalidate+0x4a3>
f010a627:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a62a:	8b 40 10             	mov    0x10(%eax),%eax
f010a62d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a630:	8b 52 14             	mov    0x14(%edx),%edx
f010a633:	89 50 14             	mov    %edx,0x14(%eax)
f010a636:	eb 0f                	jmp    f010a647 <env_page_ws_invalidate+0x4b2>
f010a638:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a63b:	8b 50 14             	mov    0x14(%eax),%edx
f010a63e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a641:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a647:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a64a:	8b 40 14             	mov    0x14(%eax),%eax
f010a64d:	85 c0                	test   %eax,%eax
f010a64f:	74 11                	je     f010a662 <env_page_ws_invalidate+0x4cd>
f010a651:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a654:	8b 40 14             	mov    0x14(%eax),%eax
f010a657:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a65a:	8b 52 10             	mov    0x10(%edx),%edx
f010a65d:	89 50 10             	mov    %edx,0x10(%eax)
f010a660:	eb 0f                	jmp    f010a671 <env_page_ws_invalidate+0x4dc>
f010a662:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a665:	8b 50 10             	mov    0x10(%eax),%edx
f010a668:	8b 45 08             	mov    0x8(%ebp),%eax
f010a66b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a671:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a674:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a67b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a67e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a685:	8b 45 08             	mov    0x8(%ebp),%eax
f010a688:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a68e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a691:	8b 45 08             	mov    0x8(%ebp),%eax
f010a694:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a69a:	83 ec 0c             	sub    $0xc,%esp
f010a69d:	ff 75 ec             	pushl  -0x14(%ebp)
f010a6a0:	e8 75 f3 ff ff       	call   f0109a1a <kfree>
f010a6a5:	83 c4 10             	add    $0x10,%esp

				break;
f010a6a8:	eb 45                	jmp    f010a6ef <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6ad:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a6b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a6b6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a6ba:	74 08                	je     f010a6c4 <env_page_ws_invalidate+0x52f>
f010a6bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6bf:	8b 40 10             	mov    0x10(%eax),%eax
f010a6c2:	eb 05                	jmp    f010a6c9 <env_page_ws_invalidate+0x534>
f010a6c4:	b8 00 00 00 00       	mov    $0x0,%eax
f010a6c9:	8b 55 08             	mov    0x8(%ebp),%edx
f010a6cc:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a6d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6d5:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a6db:	85 c0                	test   %eax,%eax
f010a6dd:	0f 85 c3 fe ff ff    	jne    f010a5a6 <env_page_ws_invalidate+0x411>
f010a6e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a6e7:	0f 85 b9 fe ff ff    	jne    f010a5a6 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a6ed:	eb 00                	jmp    f010a6ef <env_page_ws_invalidate+0x55a>
f010a6ef:	90                   	nop
f010a6f0:	c9                   	leave  
f010a6f1:	c3                   	ret    

f010a6f2 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a6f2:	55                   	push   %ebp
f010a6f3:	89 e5                	mov    %esp,%ebp
f010a6f5:	53                   	push   %ebx
f010a6f6:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a6f9:	83 ec 0c             	sub    $0xc,%esp
f010a6fc:	6a 02                	push   $0x2
f010a6fe:	e8 a8 51 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010a703:	83 c4 10             	add    $0x10,%esp
f010a706:	85 c0                	test   %eax,%eax
f010a708:	0f 84 fe 00 00 00    	je     f010a80c <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a70e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a715:	83 ec 0c             	sub    $0xc,%esp
f010a718:	68 6f 62 12 f0       	push   $0xf012626f
f010a71d:	e8 69 68 ff ff       	call   f0100f8b <cprintf>
f010a722:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a725:	8b 45 08             	mov    0x8(%ebp),%eax
f010a728:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a72e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a731:	eb 2c                	jmp    f010a75f <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a733:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a736:	8b 10                	mov    (%eax),%edx
f010a738:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a73b:	8d 48 01             	lea    0x1(%eax),%ecx
f010a73e:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a741:	83 ec 04             	sub    $0x4,%esp
f010a744:	52                   	push   %edx
f010a745:	50                   	push   %eax
f010a746:	68 89 62 12 f0       	push   $0xf0126289
f010a74b:	e8 3b 68 ff ff       	call   f0100f8b <cprintf>
f010a750:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a753:	8b 45 08             	mov    0x8(%ebp),%eax
f010a756:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a75c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a75f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a763:	74 08                	je     f010a76d <env_page_ws_print+0x7b>
f010a765:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a768:	8b 40 10             	mov    0x10(%eax),%eax
f010a76b:	eb 05                	jmp    f010a772 <env_page_ws_print+0x80>
f010a76d:	b8 00 00 00 00       	mov    $0x0,%eax
f010a772:	8b 55 08             	mov    0x8(%ebp),%edx
f010a775:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a77b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a77e:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a784:	85 c0                	test   %eax,%eax
f010a786:	75 ab                	jne    f010a733 <env_page_ws_print+0x41>
f010a788:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a78c:	75 a5                	jne    f010a733 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a78e:	83 ec 0c             	sub    $0xc,%esp
f010a791:	68 91 62 12 f0       	push   $0xf0126291
f010a796:	e8 f0 67 ff ff       	call   f0100f8b <cprintf>
f010a79b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a79e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7a1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a7a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a7aa:	eb 2c                	jmp    f010a7d8 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a7ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a7af:	8b 10                	mov    (%eax),%edx
f010a7b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7b4:	8d 48 01             	lea    0x1(%eax),%ecx
f010a7b7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a7ba:	83 ec 04             	sub    $0x4,%esp
f010a7bd:	52                   	push   %edx
f010a7be:	50                   	push   %eax
f010a7bf:	68 89 62 12 f0       	push   $0xf0126289
f010a7c4:	e8 c2 67 ff ff       	call   f0100f8b <cprintf>
f010a7c9:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a7cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7cf:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a7d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a7d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a7dc:	74 08                	je     f010a7e6 <env_page_ws_print+0xf4>
f010a7de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a7e1:	8b 40 10             	mov    0x10(%eax),%eax
f010a7e4:	eb 05                	jmp    f010a7eb <env_page_ws_print+0xf9>
f010a7e6:	b8 00 00 00 00       	mov    $0x0,%eax
f010a7eb:	8b 55 08             	mov    0x8(%ebp),%edx
f010a7ee:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a7f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7f7:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a7fd:	85 c0                	test   %eax,%eax
f010a7ff:	75 ab                	jne    f010a7ac <env_page_ws_print+0xba>
f010a801:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a805:	75 a5                	jne    f010a7ac <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a807:	e9 5a 01 00 00       	jmp    f010a966 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a80c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a813:	83 ec 0c             	sub    $0xc,%esp
f010a816:	68 ac 62 12 f0       	push   $0xf01262ac
f010a81b:	e8 6b 67 ff ff       	call   f0100f8b <cprintf>
f010a820:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a823:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a82a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a82d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a833:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a836:	e9 d1 00 00 00       	jmp    f010a90c <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a83b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a83e:	8b 00                	mov    (%eax),%eax
f010a840:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a843:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a846:	8b 40 08             	mov    0x8(%eax),%eax
f010a849:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a84c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a84f:	8b 40 64             	mov    0x64(%eax),%eax
f010a852:	83 ec 08             	sub    $0x8,%esp
f010a855:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a858:	50                   	push   %eax
f010a859:	e8 5a f7 ff ff       	call   f0109fb8 <pt_get_page_permissions>
f010a85e:	83 c4 10             	add    $0x10,%esp
f010a861:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a864:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a867:	83 e0 40             	and    $0x40,%eax
f010a86a:	85 c0                	test   %eax,%eax
f010a86c:	0f 95 c0             	setne  %al
f010a86f:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a872:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a875:	83 e0 20             	and    $0x20,%eax
f010a878:	85 c0                	test   %eax,%eax
f010a87a:	0f 95 c0             	setne  %al
f010a87d:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a880:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a883:	25 00 02 00 00       	and    $0x200,%eax
f010a888:	85 c0                	test   %eax,%eax
f010a88a:	0f 95 c0             	setne  %al
f010a88d:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a890:	83 ec 04             	sub    $0x4,%esp
f010a893:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a896:	ff 75 ec             	pushl  -0x14(%ebp)
f010a899:	68 b6 62 12 f0       	push   $0xf01262b6
f010a89e:	e8 e8 66 ff ff       	call   f0100f8b <cprintf>
f010a8a3:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a8a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a8a9:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a8ac:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a8b0:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a8b4:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a8b8:	83 ec 08             	sub    $0x8,%esp
f010a8bb:	53                   	push   %ebx
f010a8bc:	ff 75 e0             	pushl  -0x20(%ebp)
f010a8bf:	51                   	push   %ecx
f010a8c0:	52                   	push   %edx
f010a8c1:	50                   	push   %eax
f010a8c2:	68 c0 62 12 f0       	push   $0xf01262c0
f010a8c7:	e8 bf 66 ff ff       	call   f0100f8b <cprintf>
f010a8cc:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a8cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8d2:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a8d8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a8db:	75 10                	jne    f010a8ed <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a8dd:	83 ec 0c             	sub    $0xc,%esp
f010a8e0:	68 07 63 12 f0       	push   $0xf0126307
f010a8e5:	e8 a1 66 ff ff       	call   f0100f8b <cprintf>
f010a8ea:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a8ed:	83 ec 0c             	sub    $0xc,%esp
f010a8f0:	68 0c 63 12 f0       	push   $0xf012630c
f010a8f5:	e8 91 66 ff ff       	call   f0100f8b <cprintf>
f010a8fa:	83 c4 10             	add    $0x10,%esp
			i++;
f010a8fd:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a900:	8b 45 08             	mov    0x8(%ebp),%eax
f010a903:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a909:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a90c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a910:	74 08                	je     f010a91a <env_page_ws_print+0x228>
f010a912:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a915:	8b 40 10             	mov    0x10(%eax),%eax
f010a918:	eb 05                	jmp    f010a91f <env_page_ws_print+0x22d>
f010a91a:	b8 00 00 00 00       	mov    $0x0,%eax
f010a91f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a922:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a928:	8b 45 08             	mov    0x8(%ebp),%eax
f010a92b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a931:	85 c0                	test   %eax,%eax
f010a933:	0f 85 02 ff ff ff    	jne    f010a83b <env_page_ws_print+0x149>
f010a939:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a93d:	0f 85 f8 fe ff ff    	jne    f010a83b <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a943:	eb 13                	jmp    f010a958 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a945:	83 ec 0c             	sub    $0xc,%esp
f010a948:	68 0e 63 12 f0       	push   $0xf012630e
f010a94d:	e8 39 66 ff ff       	call   f0100f8b <cprintf>
f010a952:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a955:	ff 45 ec             	incl   -0x14(%ebp)
f010a958:	8b 45 08             	mov    0x8(%ebp),%eax
f010a95b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a961:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a964:	77 df                	ja     f010a945 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a966:	90                   	nop
f010a967:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a96a:	c9                   	leave  
f010a96b:	c3                   	ret    

f010a96c <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a96c:	55                   	push   %ebp
f010a96d:	89 e5                	mov    %esp,%ebp
f010a96f:	53                   	push   %ebx
f010a970:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a973:	83 ec 0c             	sub    $0xc,%esp
f010a976:	68 20 63 12 f0       	push   $0xf0126320
f010a97b:	e8 0b 66 ff ff       	call   f0100f8b <cprintf>
f010a980:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a983:	83 ec 0c             	sub    $0xc,%esp
f010a986:	68 55 63 12 f0       	push   $0xf0126355
f010a98b:	e8 fb 65 ff ff       	call   f0100f8b <cprintf>
f010a990:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a993:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a99a:	e9 16 01 00 00       	jmp    f010aab5 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a99f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a9a5:	89 d0                	mov    %edx,%eax
f010a9a7:	01 c0                	add    %eax,%eax
f010a9a9:	01 d0                	add    %edx,%eax
f010a9ab:	c1 e0 03             	shl    $0x3,%eax
f010a9ae:	01 c8                	add    %ecx,%eax
f010a9b0:	05 b0 00 00 00       	add    $0xb0,%eax
f010a9b5:	8a 00                	mov    (%eax),%al
f010a9b7:	84 c0                	test   %al,%al
f010a9b9:	74 43                	je     f010a9fe <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a9bb:	83 ec 0c             	sub    $0xc,%esp
f010a9be:	68 60 63 12 f0       	push   $0xf0126360
f010a9c3:	e8 c3 65 ff ff       	call   f0100f8b <cprintf>
f010a9c8:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a9cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9ce:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a9d4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a9d7:	75 10                	jne    f010a9e9 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a9d9:	83 ec 0c             	sub    $0xc,%esp
f010a9dc:	68 6f 63 12 f0       	push   $0xf012636f
f010a9e1:	e8 a5 65 ff ff       	call   f0100f8b <cprintf>
f010a9e6:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a9e9:	83 ec 0c             	sub    $0xc,%esp
f010a9ec:	68 0c 63 12 f0       	push   $0xf012630c
f010a9f1:	e8 95 65 ff ff       	call   f0100f8b <cprintf>
f010a9f6:	83 c4 10             	add    $0x10,%esp
			continue;
f010a9f9:	e9 b4 00 00 00       	jmp    f010aab2 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a9fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa04:	89 d0                	mov    %edx,%eax
f010aa06:	01 c0                	add    %eax,%eax
f010aa08:	01 d0                	add    %edx,%eax
f010aa0a:	c1 e0 03             	shl    $0x3,%eax
f010aa0d:	01 c8                	add    %ecx,%eax
f010aa0f:	05 ac 00 00 00       	add    $0xac,%eax
f010aa14:	8b 00                	mov    (%eax),%eax
f010aa16:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010aa19:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa1f:	89 d0                	mov    %edx,%eax
f010aa21:	01 c0                	add    %eax,%eax
f010aa23:	01 d0                	add    %edx,%eax
f010aa25:	c1 e0 03             	shl    $0x3,%eax
f010aa28:	01 c8                	add    %ecx,%eax
f010aa2a:	05 ac 00 00 00       	add    $0xac,%eax
f010aa2f:	8b 00                	mov    (%eax),%eax
f010aa31:	83 ec 04             	sub    $0x4,%esp
f010aa34:	50                   	push   %eax
f010aa35:	ff 75 f4             	pushl  -0xc(%ebp)
f010aa38:	68 75 63 12 f0       	push   $0xf0126375
f010aa3d:	e8 49 65 ff ff       	call   f0100f8b <cprintf>
f010aa42:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010aa45:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa4b:	89 d0                	mov    %edx,%eax
f010aa4d:	01 c0                	add    %eax,%eax
f010aa4f:	01 d0                	add    %edx,%eax
f010aa51:	c1 e0 03             	shl    $0x3,%eax
f010aa54:	01 c8                	add    %ecx,%eax
f010aa56:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa5b:	8b 18                	mov    (%eax),%ebx
f010aa5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa60:	8b 40 64             	mov    0x64(%eax),%eax
f010aa63:	83 ec 08             	sub    $0x8,%esp
f010aa66:	ff 75 f0             	pushl  -0x10(%ebp)
f010aa69:	50                   	push   %eax
f010aa6a:	e8 25 f6 ff ff       	call   f010a094 <pd_is_table_used>
f010aa6f:	83 c4 10             	add    $0x10,%esp
f010aa72:	83 ec 04             	sub    $0x4,%esp
f010aa75:	53                   	push   %ebx
f010aa76:	50                   	push   %eax
f010aa77:	68 8c 63 12 f0       	push   $0xf012638c
f010aa7c:	e8 0a 65 ff ff       	call   f0100f8b <cprintf>
f010aa81:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010aa84:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa87:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010aa8d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010aa90:	75 10                	jne    f010aaa2 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010aa92:	83 ec 0c             	sub    $0xc,%esp
f010aa95:	68 07 63 12 f0       	push   $0xf0126307
f010aa9a:	e8 ec 64 ff ff       	call   f0100f8b <cprintf>
f010aa9f:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010aaa2:	83 ec 0c             	sub    $0xc,%esp
f010aaa5:	68 0c 63 12 f0       	push   $0xf012630c
f010aaaa:	e8 dc 64 ff ff       	call   f0100f8b <cprintf>
f010aaaf:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010aab2:	ff 45 f4             	incl   -0xc(%ebp)
f010aab5:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010aab9:	0f 86 e0 fe ff ff    	jbe    f010a99f <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010aabf:	90                   	nop
f010aac0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010aac3:	c9                   	leave  
f010aac4:	c3                   	ret    

f010aac5 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010aac5:	55                   	push   %ebp
f010aac6:	89 e5                	mov    %esp,%ebp
f010aac8:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010aacb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010aad2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010aad9:	eb 22                	jmp    f010aafd <env_table_ws_get_size+0x38>
f010aadb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aade:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010aae1:	89 d0                	mov    %edx,%eax
f010aae3:	01 c0                	add    %eax,%eax
f010aae5:	01 d0                	add    %edx,%eax
f010aae7:	c1 e0 03             	shl    $0x3,%eax
f010aaea:	01 c8                	add    %ecx,%eax
f010aaec:	05 b0 00 00 00       	add    $0xb0,%eax
f010aaf1:	8a 00                	mov    (%eax),%al
f010aaf3:	84 c0                	test   %al,%al
f010aaf5:	75 03                	jne    f010aafa <env_table_ws_get_size+0x35>
f010aaf7:	ff 45 f8             	incl   -0x8(%ebp)
f010aafa:	ff 45 fc             	incl   -0x4(%ebp)
f010aafd:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010ab01:	7e d8                	jle    f010aadb <env_table_ws_get_size+0x16>
	return counter;
f010ab03:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010ab06:	c9                   	leave  
f010ab07:	c3                   	ret    

f010ab08 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010ab08:	55                   	push   %ebp
f010ab09:	89 e5                	mov    %esp,%ebp
f010ab0b:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010ab0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010ab15:	eb 4e                	jmp    f010ab65 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010ab17:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ab1d:	89 d0                	mov    %edx,%eax
f010ab1f:	01 c0                	add    %eax,%eax
f010ab21:	01 d0                	add    %edx,%eax
f010ab23:	c1 e0 03             	shl    $0x3,%eax
f010ab26:	01 c8                	add    %ecx,%eax
f010ab28:	05 ac 00 00 00       	add    $0xac,%eax
f010ab2d:	8b 00                	mov    (%eax),%eax
f010ab2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ab32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ab35:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ab3a:	89 c2                	mov    %eax,%edx
f010ab3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ab3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ab42:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ab45:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ab4a:	39 c2                	cmp    %eax,%edx
f010ab4c:	75 14                	jne    f010ab62 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010ab4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab51:	83 ec 08             	sub    $0x8,%esp
f010ab54:	50                   	push   %eax
f010ab55:	ff 75 08             	pushl  0x8(%ebp)
f010ab58:	e8 bc 00 00 00       	call   f010ac19 <env_table_ws_clear_entry>
f010ab5d:	83 c4 10             	add    $0x10,%esp
			break;
f010ab60:	eb 09                	jmp    f010ab6b <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010ab62:	ff 45 f4             	incl   -0xc(%ebp)
f010ab65:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ab69:	7e ac                	jle    f010ab17 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010ab6b:	90                   	nop
f010ab6c:	c9                   	leave  
f010ab6d:	c3                   	ret    

f010ab6e <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010ab6e:	55                   	push   %ebp
f010ab6f:	89 e5                	mov    %esp,%ebp
f010ab71:	53                   	push   %ebx
f010ab72:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ab75:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ab79:	76 19                	jbe    f010ab94 <env_table_ws_set_entry+0x26>
f010ab7b:	68 b0 63 12 f0       	push   $0xf01263b0
f010ab80:	68 e1 63 12 f0       	push   $0xf01263e1
f010ab85:	68 3f 01 00 00       	push   $0x13f
f010ab8a:	68 0c 62 12 f0       	push   $0xf012620c
f010ab8f:	e8 a5 57 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010ab94:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010ab9b:	76 19                	jbe    f010abb6 <env_table_ws_set_entry+0x48>
f010ab9d:	68 f8 63 12 f0       	push   $0xf01263f8
f010aba2:	68 e1 63 12 f0       	push   $0xf01263e1
f010aba7:	68 40 01 00 00       	push   $0x140
f010abac:	68 0c 62 12 f0       	push   $0xf012620c
f010abb1:	e8 83 57 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010abb6:	8b 45 10             	mov    0x10(%ebp),%eax
f010abb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010abbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abbf:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010abc4:	89 c1                	mov    %eax,%ecx
f010abc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010abc9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010abcc:	89 d0                	mov    %edx,%eax
f010abce:	01 c0                	add    %eax,%eax
f010abd0:	01 d0                	add    %edx,%eax
f010abd2:	c1 e0 03             	shl    $0x3,%eax
f010abd5:	01 d8                	add    %ebx,%eax
f010abd7:	05 ac 00 00 00       	add    $0xac,%eax
f010abdc:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010abde:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abe1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010abe4:	89 d0                	mov    %edx,%eax
f010abe6:	01 c0                	add    %eax,%eax
f010abe8:	01 d0                	add    %edx,%eax
f010abea:	c1 e0 03             	shl    $0x3,%eax
f010abed:	01 c8                	add    %ecx,%eax
f010abef:	05 b0 00 00 00       	add    $0xb0,%eax
f010abf4:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010abf7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abfa:	8b 55 0c             	mov    0xc(%ebp),%edx
f010abfd:	89 d0                	mov    %edx,%eax
f010abff:	01 c0                	add    %eax,%eax
f010ac01:	01 d0                	add    %edx,%eax
f010ac03:	c1 e0 03             	shl    $0x3,%eax
f010ac06:	01 c8                	add    %ecx,%eax
f010ac08:	05 b4 00 00 00       	add    $0xb4,%eax
f010ac0d:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010ac13:	90                   	nop
}
f010ac14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ac17:	c9                   	leave  
f010ac18:	c3                   	ret    

f010ac19 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010ac19:	55                   	push   %ebp
f010ac1a:	89 e5                	mov    %esp,%ebp
f010ac1c:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ac1f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ac23:	76 19                	jbe    f010ac3e <env_table_ws_clear_entry+0x25>
f010ac25:	68 b0 63 12 f0       	push   $0xf01263b0
f010ac2a:	68 e1 63 12 f0       	push   $0xf01263e1
f010ac2f:	68 4b 01 00 00       	push   $0x14b
f010ac34:	68 0c 62 12 f0       	push   $0xf012620c
f010ac39:	e8 fb 56 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010ac3e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac41:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac44:	89 d0                	mov    %edx,%eax
f010ac46:	01 c0                	add    %eax,%eax
f010ac48:	01 d0                	add    %edx,%eax
f010ac4a:	c1 e0 03             	shl    $0x3,%eax
f010ac4d:	01 c8                	add    %ecx,%eax
f010ac4f:	05 ac 00 00 00       	add    $0xac,%eax
f010ac54:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010ac5a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac5d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac60:	89 d0                	mov    %edx,%eax
f010ac62:	01 c0                	add    %eax,%eax
f010ac64:	01 d0                	add    %edx,%eax
f010ac66:	c1 e0 03             	shl    $0x3,%eax
f010ac69:	01 c8                	add    %ecx,%eax
f010ac6b:	05 b0 00 00 00       	add    $0xb0,%eax
f010ac70:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010ac73:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac76:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac79:	89 d0                	mov    %edx,%eax
f010ac7b:	01 c0                	add    %eax,%eax
f010ac7d:	01 d0                	add    %edx,%eax
f010ac7f:	c1 e0 03             	shl    $0x3,%eax
f010ac82:	01 c8                	add    %ecx,%eax
f010ac84:	05 b4 00 00 00       	add    $0xb4,%eax
f010ac89:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010ac8f:	90                   	nop
f010ac90:	c9                   	leave  
f010ac91:	c3                   	ret    

f010ac92 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010ac92:	55                   	push   %ebp
f010ac93:	89 e5                	mov    %esp,%ebp
f010ac95:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ac98:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ac9c:	76 19                	jbe    f010acb7 <env_table_ws_get_virtual_address+0x25>
f010ac9e:	68 b0 63 12 f0       	push   $0xf01263b0
f010aca3:	68 e1 63 12 f0       	push   $0xf01263e1
f010aca8:	68 53 01 00 00       	push   $0x153
f010acad:	68 0c 62 12 f0       	push   $0xf012620c
f010acb2:	e8 82 56 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010acb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acba:	8b 55 0c             	mov    0xc(%ebp),%edx
f010acbd:	89 d0                	mov    %edx,%eax
f010acbf:	01 c0                	add    %eax,%eax
f010acc1:	01 d0                	add    %edx,%eax
f010acc3:	c1 e0 03             	shl    $0x3,%eax
f010acc6:	01 c8                	add    %ecx,%eax
f010acc8:	05 ac 00 00 00       	add    $0xac,%eax
f010accd:	8b 00                	mov    (%eax),%eax
f010accf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010acd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acd5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010acda:	c9                   	leave  
f010acdb:	c3                   	ret    

f010acdc <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010acdc:	55                   	push   %ebp
f010acdd:	89 e5                	mov    %esp,%ebp
f010acdf:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ace2:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ace6:	76 19                	jbe    f010ad01 <env_table_ws_get_time_stamp+0x25>
f010ace8:	68 b0 63 12 f0       	push   $0xf01263b0
f010aced:	68 e1 63 12 f0       	push   $0xf01263e1
f010acf2:	68 5a 01 00 00       	push   $0x15a
f010acf7:	68 0c 62 12 f0       	push   $0xf012620c
f010acfc:	e8 38 56 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010ad01:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad04:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad07:	89 d0                	mov    %edx,%eax
f010ad09:	01 c0                	add    %eax,%eax
f010ad0b:	01 d0                	add    %edx,%eax
f010ad0d:	c1 e0 03             	shl    $0x3,%eax
f010ad10:	01 c8                	add    %ecx,%eax
f010ad12:	05 b4 00 00 00       	add    $0xb4,%eax
f010ad17:	8b 00                	mov    (%eax),%eax
}
f010ad19:	c9                   	leave  
f010ad1a:	c3                   	ret    

f010ad1b <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010ad1b:	55                   	push   %ebp
f010ad1c:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010ad1e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad21:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad24:	89 d0                	mov    %edx,%eax
f010ad26:	01 c0                	add    %eax,%eax
f010ad28:	01 d0                	add    %edx,%eax
f010ad2a:	c1 e0 03             	shl    $0x3,%eax
f010ad2d:	01 c8                	add    %ecx,%eax
f010ad2f:	05 b0 00 00 00       	add    $0xb0,%eax
f010ad34:	8a 00                	mov    (%eax),%al
f010ad36:	0f b6 c0             	movzbl %al,%eax
}
f010ad39:	5d                   	pop    %ebp
f010ad3a:	c3                   	ret    

f010ad3b <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010ad3b:	55                   	push   %ebp
f010ad3c:	89 e5                	mov    %esp,%ebp
f010ad3e:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ad41:	83 ec 04             	sub    $0x4,%esp
f010ad44:	68 2b 64 12 f0       	push   $0xf012642b
f010ad49:	68 6a 01 00 00       	push   $0x16a
f010ad4e:	68 0c 62 12 f0       	push   $0xf012620c
f010ad53:	e8 e1 55 ff ff       	call   f0100339 <_panic>

f010ad58 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ad58:	55                   	push   %ebp
f010ad59:	89 e5                	mov    %esp,%ebp
f010ad5b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ad5e:	83 ec 04             	sub    $0x4,%esp
f010ad61:	68 2b 64 12 f0       	push   $0xf012642b
f010ad66:	68 6f 01 00 00       	push   $0x16f
f010ad6b:	68 0c 62 12 f0       	push   $0xf012620c
f010ad70:	e8 c4 55 ff ff       	call   f0100339 <_panic>

f010ad75 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ad75:	55                   	push   %ebp
f010ad76:	89 e5                	mov    %esp,%ebp
f010ad78:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010ad7b:	83 ec 04             	sub    $0x4,%esp
f010ad7e:	68 3c 64 12 f0       	push   $0xf012643c
f010ad83:	6a 22                	push   $0x22
f010ad85:	68 6a 64 12 f0       	push   $0xf012646a
f010ad8a:	e8 aa 55 ff ff       	call   f0100339 <_panic>

f010ad8f <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ad8f:	55                   	push   %ebp
f010ad90:	89 e5                	mov    %esp,%ebp
f010ad92:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ad95:	83 ec 04             	sub    $0x4,%esp
f010ad98:	68 88 64 12 f0       	push   $0xf0126488
f010ad9d:	6a 35                	push   $0x35
f010ad9f:	68 6a 64 12 f0       	push   $0xf012646a
f010ada4:	e8 90 55 ff ff       	call   f0100339 <_panic>

f010ada9 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ada9:	55                   	push   %ebp
f010adaa:	89 e5                	mov    %esp,%ebp
f010adac:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010adaf:	83 ec 04             	sub    $0x4,%esp
f010adb2:	68 b8 64 12 f0       	push   $0xf01264b8
f010adb7:	6a 45                	push   $0x45
f010adb9:	68 6a 64 12 f0       	push   $0xf012646a
f010adbe:	e8 76 55 ff ff       	call   f0100339 <_panic>

f010adc3 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010adc3:	55                   	push   %ebp
f010adc4:	89 e5                	mov    %esp,%ebp
f010adc6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010adc9:	83 ec 04             	sub    $0x4,%esp
f010adcc:	68 e4 64 12 f0       	push   $0xf01264e4
f010add1:	6a 53                	push   $0x53
f010add3:	68 6a 64 12 f0       	push   $0xf012646a
f010add8:	e8 5c 55 ff ff       	call   f0100339 <_panic>

f010addd <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010addd:	55                   	push   %ebp
f010adde:	89 e5                	mov    %esp,%ebp
f010ade0:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ade3:	83 ec 04             	sub    $0x4,%esp
f010ade6:	68 14 65 12 f0       	push   $0xf0126514
f010adeb:	6a 5d                	push   $0x5d
f010aded:	68 6a 64 12 f0       	push   $0xf012646a
f010adf2:	e8 42 55 ff ff       	call   f0100339 <_panic>

f010adf7 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010adf7:	55                   	push   %ebp
f010adf8:	89 e5                	mov    %esp,%ebp
f010adfa:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010adfd:	83 ec 04             	sub    $0x4,%esp
f010ae00:	68 4c 65 12 f0       	push   $0xf012654c
f010ae05:	6a 6a                	push   $0x6a
f010ae07:	68 6a 64 12 f0       	push   $0xf012646a
f010ae0c:	e8 28 55 ff ff       	call   f0100339 <_panic>

f010ae11 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010ae11:	55                   	push   %ebp
f010ae12:	89 e5                	mov    %esp,%ebp
f010ae14:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010ae17:	e8 54 0e 00 00       	call   f010bc70 <get_cpu_proc>
f010ae1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010ae1f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ae23:	7e 61                	jle    f010ae86 <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010ae25:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae28:	c1 e0 0c             	shl    $0xc,%eax
f010ae2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010ae2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae31:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ae34:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010ae37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae3a:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ae3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ae40:	01 c2                	add    %eax,%edx
f010ae42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae45:	8b 40 78             	mov    0x78(%eax),%eax
f010ae48:	39 c2                	cmp    %eax,%edx
f010ae4a:	77 09                	ja     f010ae55 <sys_sbrk+0x44>
f010ae4c:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010ae51:	85 c0                	test   %eax,%eax
f010ae53:	75 07                	jne    f010ae5c <sys_sbrk+0x4b>
f010ae55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ae5a:	eb 3d                	jmp    f010ae99 <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010ae5c:	83 ec 04             	sub    $0x4,%esp
f010ae5f:	ff 75 f0             	pushl  -0x10(%ebp)
f010ae62:	ff 75 ec             	pushl  -0x14(%ebp)
f010ae65:	ff 75 f4             	pushl  -0xc(%ebp)
f010ae68:	e8 2e 00 00 00       	call   f010ae9b <allocate_user_mem>
f010ae6d:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010ae70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae73:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ae76:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ae79:	01 c2                	add    %eax,%edx
f010ae7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae7e:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010ae81:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ae84:	eb 13                	jmp    f010ae99 <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010ae86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ae8a:	75 08                	jne    f010ae94 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010ae8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae8f:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ae92:	eb 05                	jmp    f010ae99 <sys_sbrk+0x88>
	}

	return (void *)-1;
f010ae94:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010ae99:	c9                   	leave  
f010ae9a:	c3                   	ret    

f010ae9b <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ae9b:	55                   	push   %ebp
f010ae9c:	89 e5                	mov    %esp,%ebp
f010ae9e:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010aea1:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010aea8:	8b 55 10             	mov    0x10(%ebp),%edx
f010aeab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aeae:	01 d0                	add    %edx,%eax
f010aeb0:	48                   	dec    %eax
f010aeb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010aeb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010aeb7:	ba 00 00 00 00       	mov    $0x0,%edx
f010aebc:	f7 75 f0             	divl   -0x10(%ebp)
f010aebf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010aec2:	29 d0                	sub    %edx,%eax
f010aec4:	c1 e8 0c             	shr    $0xc,%eax
f010aec7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010aeca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010aed1:	eb 78                	jmp    f010af4b <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010aed3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aed6:	c1 e0 0c             	shl    $0xc,%eax
f010aed9:	89 c2                	mov    %eax,%edx
f010aedb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010aede:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010aee1:	8b 45 08             	mov    0x8(%ebp),%eax
f010aee4:	8b 40 64             	mov    0x64(%eax),%eax
f010aee7:	83 ec 04             	sub    $0x4,%esp
f010aeea:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010aeed:	52                   	push   %edx
f010aeee:	51                   	push   %ecx
f010aeef:	50                   	push   %eax
f010aef0:	e8 25 d8 ff ff       	call   f010871a <get_page_table>
f010aef5:	83 c4 10             	add    $0x10,%esp
f010aef8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010aefb:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010aeff:	75 23                	jne    f010af24 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010af01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af04:	c1 e0 0c             	shl    $0xc,%eax
f010af07:	89 c2                	mov    %eax,%edx
f010af09:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af0c:	01 c2                	add    %eax,%edx
f010af0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010af11:	8b 40 64             	mov    0x64(%eax),%eax
f010af14:	83 ec 08             	sub    $0x8,%esp
f010af17:	52                   	push   %edx
f010af18:	50                   	push   %eax
f010af19:	e8 52 d9 ff ff       	call   f0108870 <create_page_table>
f010af1e:	83 c4 10             	add    $0x10,%esp
f010af21:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010af24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af27:	c1 e0 0c             	shl    $0xc,%eax
f010af2a:	89 c2                	mov    %eax,%edx
f010af2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af2f:	01 c2                	add    %eax,%edx
f010af31:	8b 45 08             	mov    0x8(%ebp),%eax
f010af34:	8b 40 64             	mov    0x64(%eax),%eax
f010af37:	6a 00                	push   $0x0
f010af39:	68 00 02 00 00       	push   $0x200
f010af3e:	52                   	push   %edx
f010af3f:	50                   	push   %eax
f010af40:	e8 af ef ff ff       	call   f0109ef4 <pt_set_page_permissions>
f010af45:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010af48:	ff 45 f4             	incl   -0xc(%ebp)
f010af4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af4e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010af51:	72 80                	jb     f010aed3 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010af53:	90                   	nop
f010af54:	c9                   	leave  
f010af55:	c3                   	ret    

f010af56 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010af56:	55                   	push   %ebp
f010af57:	89 e5                	mov    %esp,%ebp
f010af59:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010af5c:	8b 45 10             	mov    0x10(%ebp),%eax
f010af5f:	c1 e0 0c             	shl    $0xc,%eax
f010af62:	89 c2                	mov    %eax,%edx
f010af64:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af67:	01 c2                	add    %eax,%edx
f010af69:	8b 45 08             	mov    0x8(%ebp),%eax
f010af6c:	8b 40 64             	mov    0x64(%eax),%eax
f010af6f:	68 00 02 00 00       	push   $0x200
f010af74:	6a 00                	push   $0x0
f010af76:	52                   	push   %edx
f010af77:	50                   	push   %eax
f010af78:	e8 77 ef ff ff       	call   f0109ef4 <pt_set_page_permissions>
f010af7d:	83 c4 10             	add    $0x10,%esp
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
f010af80:	8b 45 10             	mov    0x10(%ebp),%eax
f010af83:	c1 e0 0c             	shl    $0xc,%eax
f010af86:	89 c2                	mov    %eax,%edx
f010af88:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af8b:	01 d0                	add    %edx,%eax
f010af8d:	83 ec 08             	sub    $0x8,%esp
f010af90:	50                   	push   %eax
f010af91:	ff 75 08             	pushl  0x8(%ebp)
f010af94:	e8 36 97 ff ff       	call   f01046cf <pf_read_env_page>
f010af99:	83 c4 10             	add    $0x10,%esp
f010af9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
f010af9f:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%ebp)
f010afa3:	75 1e                	jne    f010afc3 <free_user_mem+0x6d>
f010afa5:	8b 45 10             	mov    0x10(%ebp),%eax
f010afa8:	c1 e0 0c             	shl    $0xc,%eax
f010afab:	89 c2                	mov    %eax,%edx
f010afad:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afb0:	01 d0                	add    %edx,%eax
f010afb2:	83 ec 08             	sub    $0x8,%esp
f010afb5:	50                   	push   %eax
f010afb6:	ff 75 08             	pushl  0x8(%ebp)
f010afb9:	e8 d7 f1 ff ff       	call   f010a195 <env_page_ws_invalidate>
f010afbe:	83 c4 10             	add    $0x10,%esp
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);


}
f010afc1:	eb 1c                	jmp    f010afdf <free_user_mem+0x89>
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);
f010afc3:	8b 45 10             	mov    0x10(%ebp),%eax
f010afc6:	c1 e0 0c             	shl    $0xc,%eax
f010afc9:	89 c2                	mov    %eax,%edx
f010afcb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afce:	01 d0                	add    %edx,%eax
f010afd0:	83 ec 08             	sub    $0x8,%esp
f010afd3:	50                   	push   %eax
f010afd4:	ff 75 08             	pushl  0x8(%ebp)
f010afd7:	e8 b6 97 ff ff       	call   f0104792 <pf_remove_env_page>
f010afdc:	83 c4 10             	add    $0x10,%esp


}
f010afdf:	90                   	nop
f010afe0:	c9                   	leave  
f010afe1:	c3                   	ret    

f010afe2 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010afe2:	55                   	push   %ebp
f010afe3:	89 e5                	mov    %esp,%ebp
f010afe5:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010afe8:	83 ec 04             	sub    $0x4,%esp
f010afeb:	68 84 65 12 f0       	push   $0xf0126584
f010aff0:	68 de 00 00 00       	push   $0xde
f010aff5:	68 6a 64 12 f0       	push   $0xf012646a
f010affa:	e8 3a 53 ff ff       	call   f0100339 <_panic>

f010afff <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010afff:	55                   	push   %ebp
f010b000:	89 e5                	mov    %esp,%ebp
f010b002:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010b005:	83 ec 04             	sub    $0x4,%esp
f010b008:	68 c4 65 12 f0       	push   $0xf01265c4
f010b00d:	68 e8 00 00 00       	push   $0xe8
f010b012:	68 6a 64 12 f0       	push   $0xf012646a
f010b017:	e8 1d 53 ff ff       	call   f0100339 <_panic>

f010b01c <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010b01c:	55                   	push   %ebp
f010b01d:	89 e5                	mov    %esp,%ebp
f010b01f:	56                   	push   %esi
f010b020:	53                   	push   %ebx
f010b021:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010b024:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010b02b:	e9 b0 01 00 00       	jmp    f010b1e0 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010b030:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b036:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b039:	89 d0                	mov    %edx,%eax
f010b03b:	c1 e0 03             	shl    $0x3,%eax
f010b03e:	01 d0                	add    %edx,%eax
f010b040:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b047:	01 d8                	add    %ebx,%eax
f010b049:	01 c0                	add    %eax,%eax
f010b04b:	01 d0                	add    %edx,%eax
f010b04d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b054:	01 d8                	add    %ebx,%eax
f010b056:	01 d0                	add    %edx,%eax
f010b058:	01 c8                	add    %ecx,%eax
f010b05a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010b061:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b067:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b06a:	89 d0                	mov    %edx,%eax
f010b06c:	c1 e0 03             	shl    $0x3,%eax
f010b06f:	01 d0                	add    %edx,%eax
f010b071:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b078:	01 d8                	add    %ebx,%eax
f010b07a:	01 c0                	add    %eax,%eax
f010b07c:	01 d0                	add    %edx,%eax
f010b07e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b085:	01 d8                	add    %ebx,%eax
f010b087:	01 d0                	add    %edx,%eax
f010b089:	01 c8                	add    %ecx,%eax
f010b08b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010b092:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b098:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b09b:	89 d0                	mov    %edx,%eax
f010b09d:	c1 e0 03             	shl    $0x3,%eax
f010b0a0:	01 d0                	add    %edx,%eax
f010b0a2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0a9:	01 d8                	add    %ebx,%eax
f010b0ab:	01 c0                	add    %eax,%eax
f010b0ad:	01 d0                	add    %edx,%eax
f010b0af:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0b6:	01 d8                	add    %ebx,%eax
f010b0b8:	01 d0                	add    %edx,%eax
f010b0ba:	01 c8                	add    %ecx,%eax
f010b0bc:	85 c0                	test   %eax,%eax
f010b0be:	75 14                	jne    f010b0d4 <env_init+0xb8>
f010b0c0:	83 ec 04             	sub    $0x4,%esp
f010b0c3:	68 f0 65 12 f0       	push   $0xf01265f0
f010b0c8:	6a 65                	push   $0x65
f010b0ca:	68 13 66 12 f0       	push   $0xf0126613
f010b0cf:	e8 65 52 ff ff       	call   f0100339 <_panic>
f010b0d4:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b0da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b0dd:	89 d0                	mov    %edx,%eax
f010b0df:	c1 e0 03             	shl    $0x3,%eax
f010b0e2:	01 d0                	add    %edx,%eax
f010b0e4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0eb:	01 d8                	add    %ebx,%eax
f010b0ed:	01 c0                	add    %eax,%eax
f010b0ef:	01 d0                	add    %edx,%eax
f010b0f1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0f8:	01 d8                	add    %ebx,%eax
f010b0fa:	01 d0                	add    %edx,%eax
f010b0fc:	01 c8                	add    %ecx,%eax
f010b0fe:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010b104:	89 50 08             	mov    %edx,0x8(%eax)
f010b107:	8b 40 08             	mov    0x8(%eax),%eax
f010b10a:	85 c0                	test   %eax,%eax
f010b10c:	74 35                	je     f010b143 <env_init+0x127>
f010b10e:	8b 0d 94 65 6f f0    	mov    0xf06f6594,%ecx
f010b114:	8b 1d 90 65 6f f0    	mov    0xf06f6590,%ebx
f010b11a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b11d:	89 d0                	mov    %edx,%eax
f010b11f:	c1 e0 03             	shl    $0x3,%eax
f010b122:	01 d0                	add    %edx,%eax
f010b124:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b12b:	01 f0                	add    %esi,%eax
f010b12d:	01 c0                	add    %eax,%eax
f010b12f:	01 d0                	add    %edx,%eax
f010b131:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b138:	01 f0                	add    %esi,%eax
f010b13a:	01 d0                	add    %edx,%eax
f010b13c:	01 d8                	add    %ebx,%eax
f010b13e:	89 41 0c             	mov    %eax,0xc(%ecx)
f010b141:	eb 2f                	jmp    f010b172 <env_init+0x156>
f010b143:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b149:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b14c:	89 d0                	mov    %edx,%eax
f010b14e:	c1 e0 03             	shl    $0x3,%eax
f010b151:	01 d0                	add    %edx,%eax
f010b153:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b15a:	01 d8                	add    %ebx,%eax
f010b15c:	01 c0                	add    %eax,%eax
f010b15e:	01 d0                	add    %edx,%eax
f010b160:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b167:	01 d8                	add    %ebx,%eax
f010b169:	01 d0                	add    %edx,%eax
f010b16b:	01 c8                	add    %ecx,%eax
f010b16d:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010b172:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b178:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b17b:	89 d0                	mov    %edx,%eax
f010b17d:	c1 e0 03             	shl    $0x3,%eax
f010b180:	01 d0                	add    %edx,%eax
f010b182:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b189:	01 d8                	add    %ebx,%eax
f010b18b:	01 c0                	add    %eax,%eax
f010b18d:	01 d0                	add    %edx,%eax
f010b18f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b196:	01 d8                	add    %ebx,%eax
f010b198:	01 d0                	add    %edx,%eax
f010b19a:	01 c8                	add    %ecx,%eax
f010b19c:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010b1a1:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b1a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1aa:	89 d0                	mov    %edx,%eax
f010b1ac:	c1 e0 03             	shl    $0x3,%eax
f010b1af:	01 d0                	add    %edx,%eax
f010b1b1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1b8:	01 d8                	add    %ebx,%eax
f010b1ba:	01 c0                	add    %eax,%eax
f010b1bc:	01 d0                	add    %edx,%eax
f010b1be:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1c5:	01 d8                	add    %ebx,%eax
f010b1c7:	01 d0                	add    %edx,%eax
f010b1c9:	01 c8                	add    %ecx,%eax
f010b1cb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b1d2:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010b1d7:	40                   	inc    %eax
f010b1d8:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010b1dd:	ff 4d f4             	decl   -0xc(%ebp)
f010b1e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b1e4:	0f 89 46 fe ff ff    	jns    f010b030 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010b1ea:	90                   	nop
f010b1eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b1ee:	5b                   	pop    %ebx
f010b1ef:	5e                   	pop    %esi
f010b1f0:	5d                   	pop    %ebp
f010b1f1:	c3                   	ret    

f010b1f2 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010b1f2:	55                   	push   %ebp
f010b1f3:	89 e5                	mov    %esp,%ebp
f010b1f5:	57                   	push   %edi
f010b1f6:	56                   	push   %esi
f010b1f7:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010b1fd:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010b204:	83 ec 0c             	sub    $0xc,%esp
f010b207:	ff 75 08             	pushl  0x8(%ebp)
f010b20a:	e8 b8 1e 00 00       	call   f010d0c7 <get_user_program_info>
f010b20f:	83 c4 10             	add    $0x10,%esp
f010b212:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010b215:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b219:	75 0a                	jne    f010b225 <env_create+0x33>
	{
		return NULL;
f010b21b:	b8 00 00 00 00       	mov    $0x0,%eax
f010b220:	e9 aa 09 00 00       	jmp    f010bbcf <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010b225:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b228:	8b 40 08             	mov    0x8(%eax),%eax
f010b22b:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b22e:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b235:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b238:	83 ec 0c             	sub    $0xc,%esp
f010b23b:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b241:	50                   	push   %eax
f010b242:	e8 96 0e 00 00       	call   f010c0dd <allocate_environment>
f010b247:	83 c4 10             	add    $0x10,%esp
f010b24a:	85 c0                	test   %eax,%eax
f010b24c:	79 0a                	jns    f010b258 <env_create+0x66>
	{
		return NULL;
f010b24e:	b8 00 00 00 00       	mov    $0x0,%eax
f010b253:	e9 77 09 00 00       	jmp    f010bbcf <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b258:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b25b:	8b 00                	mov    (%eax),%eax
f010b25d:	83 ec 0c             	sub    $0xc,%esp
f010b260:	50                   	push   %eax
f010b261:	e8 46 4c 01 00       	call   f011feac <strlen>
f010b266:	83 c4 10             	add    $0x10,%esp
f010b269:	83 f8 3f             	cmp    $0x3f,%eax
f010b26c:	7f 1d                	jg     f010b28b <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b26e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b271:	8b 00                	mov    (%eax),%eax
f010b273:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b279:	83 c2 20             	add    $0x20,%edx
f010b27c:	83 ec 08             	sub    $0x8,%esp
f010b27f:	50                   	push   %eax
f010b280:	52                   	push   %edx
f010b281:	e8 75 4c 01 00       	call   f011fefb <strcpy>
f010b286:	83 c4 10             	add    $0x10,%esp
f010b289:	eb 1d                	jmp    f010b2a8 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b28b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b28e:	8b 00                	mov    (%eax),%eax
f010b290:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b296:	83 c2 20             	add    $0x20,%edx
f010b299:	83 ec 04             	sub    $0x4,%esp
f010b29c:	6a 3f                	push   $0x3f
f010b29e:	50                   	push   %eax
f010b29f:	52                   	push   %edx
f010b2a0:	e8 84 4c 01 00       	call   f011ff29 <strncpy>
f010b2a5:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b2a8:	e8 fc 13 00 00       	call   f010c6a9 <create_user_directory>
f010b2ad:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b2b0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b2b3:	83 ec 0c             	sub    $0xc,%esp
f010b2b6:	50                   	push   %eax
f010b2b7:	e8 44 e8 ff ff       	call   f0109b00 <kheap_physical_address>
f010b2bc:	83 c4 10             	add    $0x10,%esp
f010b2bf:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b2c2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b2cb:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b2d1:	83 ec 0c             	sub    $0xc,%esp
f010b2d4:	6a 02                	push   $0x2
f010b2d6:	e8 d0 45 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010b2db:	83 c4 10             	add    $0x10,%esp
f010b2de:	85 c0                	test   %eax,%eax
f010b2e0:	74 21                	je     f010b303 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b2e2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2e8:	8b 55 10             	mov    0x10(%ebp),%edx
f010b2eb:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b2f1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b2fa:	2b 55 10             	sub    0x10(%ebp),%edx
f010b2fd:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b303:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b307:	75 12                	jne    f010b31b <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b309:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b30f:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b316:	00 00 00 
f010b319:	eb 0f                	jmp    f010b32a <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b31b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b321:	8b 55 14             	mov    0x14(%ebp),%edx
f010b324:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b32a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b330:	83 ec 04             	sub    $0x4,%esp
f010b333:	ff 75 bc             	pushl  -0x44(%ebp)
f010b336:	ff 75 c0             	pushl  -0x40(%ebp)
f010b339:	50                   	push   %eax
f010b33a:	e8 c8 14 00 00       	call   f010c807 <initialize_environment>
f010b33f:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b342:	e8 b3 c1 ff ff       	call   f01074fa <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b347:	0f 20 d8             	mov    %cr3,%eax
f010b34a:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b34d:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b350:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b353:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b359:	8b 40 68             	mov    0x68(%eax),%eax
f010b35c:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b362:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b368:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b36b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b372:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b379:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b37f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b385:	48                   	dec    %eax
f010b386:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b389:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b390:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b393:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b399:	83 ec 08             	sub    $0x8,%esp
f010b39c:	ff 75 c8             	pushl  -0x38(%ebp)
f010b39f:	50                   	push   %eax
f010b3a0:	e8 34 1a 00 00       	call   f010cdd9 <PROGRAM_SEGMENT_FIRST>
f010b3a5:	83 c4 0c             	add    $0xc,%esp
f010b3a8:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b3ae:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b3b4:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b3b9:	89 c7                	mov    %eax,%edi
f010b3bb:	89 d6                	mov    %edx,%esi
f010b3bd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b3bf:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b3c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b3c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3cb:	8b 40 10             	mov    0x10(%eax),%eax
f010b3ce:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b3d1:	75 07                	jne    f010b3da <env_create+0x1e8>
f010b3d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b3da:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b3e0:	e9 fa 02 00 00       	jmp    f010b6df <env_create+0x4ed>
		{
			segment_counter++;
f010b3e5:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b3e8:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b3ef:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b3f2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3f8:	83 ec 0c             	sub    $0xc,%esp
f010b3fb:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b401:	52                   	push   %edx
f010b402:	ff 75 ec             	pushl  -0x14(%ebp)
f010b405:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b40b:	52                   	push   %edx
f010b40c:	ff 75 f4             	pushl  -0xc(%ebp)
f010b40f:	50                   	push   %eax
f010b410:	e8 86 0d 00 00       	call   f010c19b <program_segment_alloc_map_copy_workingset>
f010b415:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b418:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b41e:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b421:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b424:	8b 00                	mov    (%eax),%eax
f010b426:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b429:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b42c:	8b 40 0c             	mov    0xc(%eax),%eax
f010b42f:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b432:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b435:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b438:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b43b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b440:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b443:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b44a:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b44d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b450:	01 d0                	add    %edx,%eax
f010b452:	48                   	dec    %eax
f010b453:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b456:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b459:	ba 00 00 00 00       	mov    $0x0,%edx
f010b45e:	f7 75 9c             	divl   -0x64(%ebp)
f010b461:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b464:	29 d0                	sub    %edx,%eax
f010b466:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b469:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b46c:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b46f:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b472:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b475:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b478:	8b 15 ec f7 f1 f0    	mov    0xf0f1f7ec,%edx
f010b47e:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b481:	01 d0                	add    %edx,%eax
f010b483:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b486:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b48a:	74 73                	je     f010b4ff <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b48c:	a1 ec f7 f1 f0       	mov    0xf0f1f7ec,%eax
f010b491:	83 ec 04             	sub    $0x4,%esp
f010b494:	68 00 10 00 00       	push   $0x1000
f010b499:	6a 00                	push   $0x0
f010b49b:	50                   	push   %eax
f010b49c:	e8 f9 4b 01 00       	call   f012009a <memset>
f010b4a1:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b4a4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b4a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b4aa:	eb 13                	jmp    f010b4bf <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b4ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b4af:	8a 10                	mov    (%eax),%dl
f010b4b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b4b4:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b4b6:	ff 45 dc             	incl   -0x24(%ebp)
f010b4b9:	ff 45 e4             	incl   -0x1c(%ebp)
f010b4bc:	ff 45 e0             	incl   -0x20(%ebp)
f010b4bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b4c2:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b4c5:	72 e5                	jb     f010b4ac <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b4c7:	8b 15 ec f7 f1 f0    	mov    0xf0f1f7ec,%edx
f010b4cd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4d3:	83 ec 04             	sub    $0x4,%esp
f010b4d6:	52                   	push   %edx
f010b4d7:	ff 75 a0             	pushl  -0x60(%ebp)
f010b4da:	50                   	push   %eax
f010b4db:	e8 45 8f ff ff       	call   f0104425 <pf_add_env_page>
f010b4e0:	83 c4 10             	add    $0x10,%esp
f010b4e3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b4e6:	75 17                	jne    f010b4ff <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b4e8:	83 ec 04             	sub    $0x4,%esp
f010b4eb:	68 30 66 12 f0       	push   $0xf0126630
f010b4f0:	68 f5 00 00 00       	push   $0xf5
f010b4f5:	68 13 66 12 f0       	push   $0xf0126613
f010b4fa:	e8 3a 4e ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b4ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b502:	8b 50 04             	mov    0x4(%eax),%edx
f010b505:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b508:	01 d0                	add    %edx,%eax
f010b50a:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b50d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b510:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b515:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b518:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b51b:	8b 50 04             	mov    0x4(%eax),%edx
f010b51e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b521:	01 d0                	add    %edx,%eax
f010b523:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b526:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b529:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b52c:	eb 43                	jmp    f010b571 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b52e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b531:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b537:	83 ec 04             	sub    $0x4,%esp
f010b53a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b53d:	52                   	push   %edx
f010b53e:	50                   	push   %eax
f010b53f:	e8 e1 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b544:	83 c4 10             	add    $0x10,%esp
f010b547:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b54a:	75 17                	jne    f010b563 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b54c:	83 ec 04             	sub    $0x4,%esp
f010b54f:	68 30 66 12 f0       	push   $0xf0126630
f010b554:	68 02 01 00 00       	push   $0x102
f010b559:	68 13 66 12 f0       	push   $0xf0126613
f010b55e:	e8 d6 4d ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b563:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b56a:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b571:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b574:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b577:	72 b5                	jb     f010b52e <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b579:	a1 ec f7 f1 f0       	mov    0xf0f1f7ec,%eax
f010b57e:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b581:	83 ec 04             	sub    $0x4,%esp
f010b584:	68 00 10 00 00       	push   $0x1000
f010b589:	6a 00                	push   $0x0
f010b58b:	ff 75 e0             	pushl  -0x20(%ebp)
f010b58e:	e8 07 4b 01 00       	call   f012009a <memset>
f010b593:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b596:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b599:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b59c:	eb 13                	jmp    f010b5b1 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b59e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b5a1:	8a 10                	mov    (%eax),%dl
f010b5a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b5a6:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b5a8:	ff 45 dc             	incl   -0x24(%ebp)
f010b5ab:	ff 45 e4             	incl   -0x1c(%ebp)
f010b5ae:	ff 45 e0             	incl   -0x20(%ebp)
f010b5b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b5b4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b5b7:	72 e5                	jb     f010b59e <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b5b9:	8b 15 ec f7 f1 f0    	mov    0xf0f1f7ec,%edx
f010b5bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5c5:	83 ec 04             	sub    $0x4,%esp
f010b5c8:	52                   	push   %edx
f010b5c9:	ff 75 88             	pushl  -0x78(%ebp)
f010b5cc:	50                   	push   %eax
f010b5cd:	e8 53 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b5d2:	83 c4 10             	add    $0x10,%esp
f010b5d5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b5d8:	75 17                	jne    f010b5f1 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b5da:	83 ec 04             	sub    $0x4,%esp
f010b5dd:	68 30 66 12 f0       	push   $0xf0126630
f010b5e2:	68 11 01 00 00       	push   $0x111
f010b5e7:	68 13 66 12 f0       	push   $0xf0126613
f010b5ec:	e8 48 4d ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b5f1:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b5f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5fb:	8b 50 04             	mov    0x4(%eax),%edx
f010b5fe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b601:	01 c2                	add    %eax,%edx
f010b603:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b606:	01 d0                	add    %edx,%eax
f010b608:	48                   	dec    %eax
f010b609:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b60f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b615:	ba 00 00 00 00       	mov    $0x0,%edx
f010b61a:	f7 75 80             	divl   -0x80(%ebp)
f010b61d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b623:	29 d0                	sub    %edx,%eax
f010b625:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b628:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b62b:	8b 50 08             	mov    0x8(%eax),%edx
f010b62e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b631:	01 d0                	add    %edx,%eax
f010b633:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b636:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b63c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b643:	eb 41                	jmp    f010b686 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b645:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b64b:	83 ec 04             	sub    $0x4,%esp
f010b64e:	6a 01                	push   $0x1
f010b650:	ff 75 d8             	pushl  -0x28(%ebp)
f010b653:	50                   	push   %eax
f010b654:	e8 9b 8c ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010b659:	83 c4 10             	add    $0x10,%esp
f010b65c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b65f:	75 17                	jne    f010b678 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b661:	83 ec 04             	sub    $0x4,%esp
f010b664:	68 30 66 12 f0       	push   $0xf0126630
f010b669:	68 1e 01 00 00       	push   $0x11e
f010b66e:	68 13 66 12 f0       	push   $0xf0126613
f010b673:	e8 c1 4c ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b678:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b67f:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b686:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b68d:	10 00 00 
f010b690:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b696:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b69c:	01 d0                	add    %edx,%eax
f010b69e:	48                   	dec    %eax
f010b69f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b6a5:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b6ab:	ba 00 00 00 00       	mov    $0x0,%edx
f010b6b0:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b6b6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b6bc:	29 d0                	sub    %edx,%eax
f010b6be:	89 c2                	mov    %eax,%edx
f010b6c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b6c3:	39 c2                	cmp    %eax,%edx
f010b6c5:	0f 87 7a ff ff ff    	ja     f010b645 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b6cb:	83 ec 08             	sub    $0x8,%esp
f010b6ce:	ff 75 c8             	pushl  -0x38(%ebp)
f010b6d1:	ff 75 f4             	pushl  -0xc(%ebp)
f010b6d4:	e8 f5 15 00 00       	call   f010ccce <PROGRAM_SEGMENT_NEXT>
f010b6d9:	83 c4 10             	add    $0x10,%esp
f010b6dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b6df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b6e3:	0f 85 fc fc ff ff    	jne    f010b3e5 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b6e9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6ef:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b6f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b6f8:	eb 77                	jmp    f010b771 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b6fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6fd:	8b 00                	mov    (%eax),%eax
f010b6ff:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b705:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b70b:	8b 40 64             	mov    0x64(%eax),%eax
f010b70e:	83 ec 04             	sub    $0x4,%esp
f010b711:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b717:	52                   	push   %edx
f010b718:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b71e:	50                   	push   %eax
f010b71f:	e8 f6 cf ff ff       	call   f010871a <get_page_table>
f010b724:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b727:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b72d:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b733:	c1 ea 0c             	shr    $0xc,%edx
f010b736:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b73c:	c1 e2 02             	shl    $0x2,%edx
f010b73f:	01 d0                	add    %edx,%eax
f010b741:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b747:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b74d:	c1 e9 0c             	shr    $0xc,%ecx
f010b750:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b756:	c1 e1 02             	shl    $0x2,%ecx
f010b759:	01 ca                	add    %ecx,%edx
f010b75b:	8b 12                	mov    (%edx),%edx
f010b75d:	83 e2 bf             	and    $0xffffffbf,%edx
f010b760:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b762:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b768:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b76e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b771:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b777:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b77b:	74 08                	je     f010b785 <env_create+0x593>
f010b77d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b780:	8b 52 10             	mov    0x10(%edx),%edx
f010b783:	eb 05                	jmp    f010b78a <env_create+0x598>
f010b785:	ba 00 00 00 00       	mov    $0x0,%edx
f010b78a:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b790:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b796:	85 c0                	test   %eax,%eax
f010b798:	0f 85 5c ff ff ff    	jne    f010b6fa <env_create+0x508>
f010b79e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b7a2:	0f 85 52 ff ff ff    	jne    f010b6fa <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b7a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b7ab:	8b 50 08             	mov    0x8(%eax),%edx
f010b7ae:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7b4:	83 ec 08             	sub    $0x8,%esp
f010b7b7:	52                   	push   %edx
f010b7b8:	50                   	push   %eax
f010b7b9:	e8 d0 14 00 00       	call   f010cc8e <set_environment_entry_point>
f010b7be:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b7c1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7c7:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b7ce:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b7d5:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b7d8:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b7df:	e9 42 03 00 00       	jmp    f010bb26 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b7e4:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b7eb:	00 00 00 
			allocate_frame(&pp);
f010b7ee:	83 ec 0c             	sub    $0xc,%esp
f010b7f1:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b7f7:	50                   	push   %eax
f010b7f8:	e8 e0 cc ff ff       	call   f01084dd <allocate_frame>
f010b7fd:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b800:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b806:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b80c:	8b 40 64             	mov    0x64(%eax),%eax
f010b80f:	6a 06                	push   $0x6
f010b811:	ff 75 d0             	pushl  -0x30(%ebp)
f010b814:	52                   	push   %edx
f010b815:	50                   	push   %eax
f010b816:	e8 93 d3 ff ff       	call   f0108bae <loadtime_map_frame>
f010b81b:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b81e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b821:	83 ec 04             	sub    $0x4,%esp
f010b824:	68 00 10 00 00       	push   $0x1000
f010b829:	6a 00                	push   $0x0
f010b82b:	50                   	push   %eax
f010b82c:	e8 69 48 01 00       	call   f012009a <memset>
f010b831:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b834:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b83a:	83 ec 08             	sub    $0x8,%esp
f010b83d:	ff 75 d0             	pushl  -0x30(%ebp)
f010b840:	50                   	push   %eax
f010b841:	e8 e4 e8 ff ff       	call   f010a12a <env_page_ws_list_create_element>
f010b846:	83 c4 10             	add    $0x10,%esp
f010b849:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b84c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b850:	75 17                	jne    f010b869 <env_create+0x677>
f010b852:	83 ec 04             	sub    $0x4,%esp
f010b855:	68 78 66 12 f0       	push   $0xf0126678
f010b85a:	68 5d 01 00 00       	push   $0x15d
f010b85f:	68 13 66 12 f0       	push   $0xf0126613
f010b864:	e8 d0 4a ff ff       	call   f0100339 <_panic>
f010b869:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b86f:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b875:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b878:	89 50 14             	mov    %edx,0x14(%eax)
f010b87b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b87e:	8b 40 14             	mov    0x14(%eax),%eax
f010b881:	85 c0                	test   %eax,%eax
f010b883:	74 14                	je     f010b899 <env_create+0x6a7>
f010b885:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b88b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b891:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b894:	89 50 10             	mov    %edx,0x10(%eax)
f010b897:	eb 0f                	jmp    f010b8a8 <env_create+0x6b6>
f010b899:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b89f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8a2:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b8a8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8b1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b8b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b8ba:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b8c1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8c7:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b8cd:	42                   	inc    %edx
f010b8ce:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b8d4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8da:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b8e0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8e6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b8ec:	39 c2                	cmp    %eax,%edx
f010b8ee:	75 1a                	jne    f010b90a <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b8f0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8f6:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b8fc:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b902:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b908:	eb 10                	jmp    f010b91a <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b90a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b910:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b917:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b91a:	83 ec 0c             	sub    $0xc,%esp
f010b91d:	6a 02                	push   $0x2
f010b91f:	e8 87 3f 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010b924:	83 c4 10             	add    $0x10,%esp
f010b927:	85 c0                	test   %eax,%eax
f010b929:	0f 84 d3 01 00 00    	je     f010bb02 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b92f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b933:	75 17                	jne    f010b94c <env_create+0x75a>
f010b935:	83 ec 04             	sub    $0x4,%esp
f010b938:	68 9b 66 12 f0       	push   $0xf012669b
f010b93d:	68 6a 01 00 00       	push   $0x16a
f010b942:	68 13 66 12 f0       	push   $0xf0126613
f010b947:	e8 ed 49 ff ff       	call   f0100339 <_panic>
f010b94c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b94f:	8b 40 10             	mov    0x10(%eax),%eax
f010b952:	85 c0                	test   %eax,%eax
f010b954:	74 11                	je     f010b967 <env_create+0x775>
f010b956:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b959:	8b 40 10             	mov    0x10(%eax),%eax
f010b95c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b95f:	8b 52 14             	mov    0x14(%edx),%edx
f010b962:	89 50 14             	mov    %edx,0x14(%eax)
f010b965:	eb 12                	jmp    f010b979 <env_create+0x787>
f010b967:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b96d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b970:	8b 52 14             	mov    0x14(%edx),%edx
f010b973:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b979:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b97c:	8b 40 14             	mov    0x14(%eax),%eax
f010b97f:	85 c0                	test   %eax,%eax
f010b981:	74 11                	je     f010b994 <env_create+0x7a2>
f010b983:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b986:	8b 40 14             	mov    0x14(%eax),%eax
f010b989:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b98c:	8b 52 10             	mov    0x10(%edx),%edx
f010b98f:	89 50 10             	mov    %edx,0x10(%eax)
f010b992:	eb 12                	jmp    f010b9a6 <env_create+0x7b4>
f010b994:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b99a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b99d:	8b 52 10             	mov    0x10(%edx),%edx
f010b9a0:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b9a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b9a9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b9b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b9b3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b9ba:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9c0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b9c6:	4a                   	dec    %edx
f010b9c7:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b9cd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9d3:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b9d9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9df:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b9e5:	39 c2                	cmp    %eax,%edx
f010b9e7:	0f 83 8d 00 00 00    	jae    f010ba7a <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b9ed:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b9f1:	75 17                	jne    f010ba0a <env_create+0x818>
f010b9f3:	83 ec 04             	sub    $0x4,%esp
f010b9f6:	68 f0 65 12 f0       	push   $0xf01265f0
f010b9fb:	68 6f 01 00 00       	push   $0x16f
f010ba00:	68 13 66 12 f0       	push   $0xf0126613
f010ba05:	e8 2f 49 ff ff       	call   f0100339 <_panic>
f010ba0a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba10:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010ba16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba19:	89 50 10             	mov    %edx,0x10(%eax)
f010ba1c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba1f:	8b 40 10             	mov    0x10(%eax),%eax
f010ba22:	85 c0                	test   %eax,%eax
f010ba24:	74 14                	je     f010ba3a <env_create+0x848>
f010ba26:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba2c:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010ba32:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba35:	89 50 14             	mov    %edx,0x14(%eax)
f010ba38:	eb 0f                	jmp    f010ba49 <env_create+0x857>
f010ba3a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba40:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba43:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010ba49:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba4f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba52:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010ba58:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba5b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba62:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba68:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010ba6e:	42                   	inc    %edx
f010ba6f:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010ba75:	e9 88 00 00 00       	jmp    f010bb02 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010ba7a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ba7e:	75 17                	jne    f010ba97 <env_create+0x8a5>
f010ba80:	83 ec 04             	sub    $0x4,%esp
f010ba83:	68 f0 65 12 f0       	push   $0xf01265f0
f010ba88:	68 73 01 00 00       	push   $0x173
f010ba8d:	68 13 66 12 f0       	push   $0xf0126613
f010ba92:	e8 a2 48 ff ff       	call   f0100339 <_panic>
f010ba97:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba9d:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010baa3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010baa6:	89 50 10             	mov    %edx,0x10(%eax)
f010baa9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010baac:	8b 40 10             	mov    0x10(%eax),%eax
f010baaf:	85 c0                	test   %eax,%eax
f010bab1:	74 14                	je     f010bac7 <env_create+0x8d5>
f010bab3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bab9:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010babf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bac2:	89 50 14             	mov    %edx,0x14(%eax)
f010bac5:	eb 0f                	jmp    f010bad6 <env_create+0x8e4>
f010bac7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bacd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bad0:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bad6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010badc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010badf:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bae5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bae8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010baef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010baf5:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010bafb:	42                   	inc    %edx
f010bafc:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010bb02:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb08:	83 ec 04             	sub    $0x4,%esp
f010bb0b:	6a 01                	push   $0x1
f010bb0d:	ff 75 d0             	pushl  -0x30(%ebp)
f010bb10:	50                   	push   %eax
f010bb11:	e8 de 87 ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010bb16:	83 c4 10             	add    $0x10,%esp
f010bb19:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010bb1f:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010bb26:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bb29:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010bb2f:	0f 83 af fc ff ff    	jae    f010b7e4 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010bb35:	83 ec 0c             	sub    $0xc,%esp
f010bb38:	6a 02                	push   $0x2
f010bb3a:	e8 6c 3d 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010bb3f:	83 c4 10             	add    $0x10,%esp
f010bb42:	85 c0                	test   %eax,%eax
f010bb44:	74 72                	je     f010bbb8 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010bb46:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010bb4d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb53:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bb59:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bb5c:	eb 2b                	jmp    f010bb89 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010bb5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb61:	8b 10                	mov    (%eax),%edx
f010bb63:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb69:	8b 40 64             	mov    0x64(%eax),%eax
f010bb6c:	6a 01                	push   $0x1
f010bb6e:	6a 00                	push   $0x0
f010bb70:	52                   	push   %edx
f010bb71:	50                   	push   %eax
f010bb72:	e8 7d e3 ff ff       	call   f0109ef4 <pt_set_page_permissions>
f010bb77:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010bb7a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb80:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bb86:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bb89:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb8f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bb93:	74 08                	je     f010bb9d <env_create+0x9ab>
f010bb95:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb98:	8b 52 10             	mov    0x10(%edx),%edx
f010bb9b:	eb 05                	jmp    f010bba2 <env_create+0x9b0>
f010bb9d:	ba 00 00 00 00       	mov    $0x0,%edx
f010bba2:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010bba8:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bbae:	85 c0                	test   %eax,%eax
f010bbb0:	75 ac                	jne    f010bb5e <env_create+0x96c>
f010bbb2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bbb6:	75 a6                	jne    f010bb5e <env_create+0x96c>
f010bbb8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010bbbb:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010bbbe:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010bbc1:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010bbc4:	e8 83 b9 ff ff       	call   f010754c <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010bbc9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010bbcf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010bbd2:	5e                   	pop    %esi
f010bbd3:	5f                   	pop    %edi
f010bbd4:	5d                   	pop    %ebp
f010bbd5:	c3                   	ret    

f010bbd6 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010bbd6:	55                   	push   %ebp
f010bbd7:	89 e5                	mov    %esp,%ebp
f010bbd9:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010bbdc:	83 ec 0c             	sub    $0xc,%esp
f010bbdf:	68 80 f0 71 f0       	push   $0xf071f080
f010bbe4:	e8 9c 43 00 00       	call   f010ff85 <release_spinlock>
f010bbe9:	83 c4 10             	add    $0x10,%esp

	if (first)
f010bbec:	a1 94 09 18 f0       	mov    0xf0180994,%eax
f010bbf1:	85 c0                	test   %eax,%eax
f010bbf3:	74 30                	je     f010bc25 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010bbf5:	e8 76 00 00 00       	call   f010bc70 <get_cpu_proc>
f010bbfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010bbfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc00:	8b 40 10             	mov    0x10(%eax),%eax
f010bc03:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc06:	83 c2 20             	add    $0x20,%edx
f010bc09:	83 ec 04             	sub    $0x4,%esp
f010bc0c:	50                   	push   %eax
f010bc0d:	52                   	push   %edx
f010bc0e:	68 b9 66 12 f0       	push   $0xf01266b9
f010bc13:	e8 73 53 ff ff       	call   f0100f8b <cprintf>
f010bc18:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010bc1b:	c7 05 94 09 18 f0 00 	movl   $0x0,0xf0180994
f010bc22:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010bc25:	90                   	nop
f010bc26:	c9                   	leave  
f010bc27:	c3                   	ret    

f010bc28 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010bc28:	55                   	push   %ebp
f010bc29:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010bc2b:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010bc2c:	5d                   	pop    %ebp
f010bc2d:	c3                   	ret    

f010bc2e <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010bc2e:	55                   	push   %ebp
f010bc2f:	89 e5                	mov    %esp,%ebp
f010bc31:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010bc34:	e8 37 00 00 00       	call   f010bc70 <get_cpu_proc>
f010bc39:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010bc3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bc40:	75 19                	jne    f010bc5b <env_exit+0x2d>
f010bc42:	68 cf 66 12 f0       	push   $0xf01266cf
f010bc47:	68 df 66 12 f0       	push   $0xf01266df
f010bc4c:	68 ed 01 00 00       	push   $0x1ed
f010bc51:	68 13 66 12 f0       	push   $0xf0126613
f010bc56:	e8 de 46 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010bc5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc5e:	8b 40 10             	mov    0x10(%eax),%eax
f010bc61:	83 ec 0c             	sub    $0xc,%esp
f010bc64:	50                   	push   %eax
f010bc65:	e8 2a 9e ff ff       	call   f0105a94 <sched_exit_env>
f010bc6a:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010bc6d:	90                   	nop
f010bc6e:	c9                   	leave  
f010bc6f:	c3                   	ret    

f010bc70 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010bc70:	55                   	push   %ebp
f010bc71:	89 e5                	mov    %esp,%ebp
f010bc73:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010bc76:	e8 7f b8 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bc7b:	e8 b7 b7 ff ff       	call   f0107437 <mycpu>
f010bc80:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010bc83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc86:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bc8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bc8f:	e8 b8 b8 ff ff       	call   f010754c <popcli>
	return p;
f010bc94:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bc97:	c9                   	leave  
f010bc98:	c3                   	ret    

f010bc99 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bc99:	55                   	push   %ebp
f010bc9a:	89 e5                	mov    %esp,%ebp
f010bc9c:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bc9f:	e8 56 b8 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bca4:	e8 8e b7 ff ff       	call   f0107437 <mycpu>
f010bca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bcac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcaf:	8b 55 08             	mov    0x8(%ebp),%edx
f010bcb2:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bcb8:	e8 8f b8 ff ff       	call   f010754c <popcli>
}
f010bcbd:	90                   	nop
f010bcbe:	c9                   	leave  
f010bcbf:	c3                   	ret    

f010bcc0 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bcc0:	55                   	push   %ebp
f010bcc1:	89 e5                	mov    %esp,%ebp
f010bcc3:	53                   	push   %ebx
f010bcc4:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010bcc7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bccb:	75 16                	jne    f010bce3 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010bccd:	e8 9e ff ff ff       	call   f010bc70 <get_cpu_proc>
f010bcd2:	89 c2                	mov    %eax,%edx
f010bcd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bcd7:	89 10                	mov    %edx,(%eax)
		return 0;
f010bcd9:	b8 00 00 00 00       	mov    $0x0,%eax
f010bcde:	e9 aa 00 00 00       	jmp    f010bd8d <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bce3:	8b 1d 90 65 6f f0    	mov    0xf06f6590,%ebx
f010bce9:	83 ec 0c             	sub    $0xc,%esp
f010bcec:	68 ca 02 00 00       	push   $0x2ca
f010bcf1:	e8 14 27 01 00       	call   f011e40a <nearest_pow2_ceil>
f010bcf6:	83 c4 10             	add    $0x10,%esp
f010bcf9:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bcfc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcff:	21 c2                	and    %eax,%edx
f010bd01:	89 d0                	mov    %edx,%eax
f010bd03:	c1 e0 03             	shl    $0x3,%eax
f010bd06:	01 d0                	add    %edx,%eax
f010bd08:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bd0f:	01 c8                	add    %ecx,%eax
f010bd11:	01 c0                	add    %eax,%eax
f010bd13:	01 d0                	add    %edx,%eax
f010bd15:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bd1c:	01 c8                	add    %ecx,%eax
f010bd1e:	01 d0                	add    %edx,%eax
f010bd20:	01 d8                	add    %ebx,%eax
f010bd22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bd25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd28:	8b 40 18             	mov    0x18(%eax),%eax
f010bd2b:	85 c0                	test   %eax,%eax
f010bd2d:	74 0b                	je     f010bd3a <envid2env+0x7a>
f010bd2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd32:	8b 40 10             	mov    0x10(%eax),%eax
f010bd35:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bd38:	74 10                	je     f010bd4a <envid2env+0x8a>
		*env_store = 0;
f010bd3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bd43:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bd48:	eb 43                	jmp    f010bd8d <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bd4a:	e8 21 ff ff ff       	call   f010bc70 <get_cpu_proc>
f010bd4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010bd52:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bd56:	74 28                	je     f010bd80 <envid2env+0xc0>
f010bd58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd5b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bd5e:	74 20                	je     f010bd80 <envid2env+0xc0>
f010bd60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd63:	8b 50 14             	mov    0x14(%eax),%edx
f010bd66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bd69:	8b 40 10             	mov    0x10(%eax),%eax
f010bd6c:	39 c2                	cmp    %eax,%edx
f010bd6e:	74 10                	je     f010bd80 <envid2env+0xc0>
		*env_store = 0;
f010bd70:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bd79:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bd7e:	eb 0d                	jmp    f010bd8d <envid2env+0xcd>
	}

	*env_store = e;
f010bd80:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd86:	89 10                	mov    %edx,(%eax)
	return 0;
f010bd88:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bd8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bd90:	c9                   	leave  
f010bd91:	c3                   	ret    

f010bd92 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bd92:	55                   	push   %ebp
f010bd93:	89 e5                	mov    %esp,%ebp
f010bd95:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bd98:	83 ec 0c             	sub    $0xc,%esp
f010bd9b:	68 80 f0 71 f0       	push   $0xf071f080
f010bda0:	e8 59 41 00 00       	call   f010fefe <acquire_spinlock>
f010bda5:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bda8:	e8 c3 fe ff ff       	call   f010bc70 <get_cpu_proc>
f010bdad:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bdb0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdb4:	75 19                	jne    f010bdcf <yield+0x3d>
f010bdb6:	68 f4 66 12 f0       	push   $0xf01266f4
f010bdbb:	68 df 66 12 f0       	push   $0xf01266df
f010bdc0:	68 4c 02 00 00       	push   $0x24c
f010bdc5:	68 13 66 12 f0       	push   $0xf0126613
f010bdca:	e8 6a 45 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010bdcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd2:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bdd9:	e8 13 00 00 00       	call   f010bdf1 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010bdde:	83 ec 0c             	sub    $0xc,%esp
f010bde1:	68 80 f0 71 f0       	push   $0xf071f080
f010bde6:	e8 9a 41 00 00       	call   f010ff85 <release_spinlock>
f010bdeb:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bdee:	90                   	nop
f010bdef:	c9                   	leave  
f010bdf0:	c3                   	ret    

f010bdf1 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bdf1:	55                   	push   %ebp
f010bdf2:	89 e5                	mov    %esp,%ebp
f010bdf4:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bdf7:	e8 74 fe ff ff       	call   f010bc70 <get_cpu_proc>
f010bdfc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bdff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be03:	75 19                	jne    f010be1e <sched+0x2d>
f010be05:	68 f4 66 12 f0       	push   $0xf01266f4
f010be0a:	68 df 66 12 f0       	push   $0xf01266df
f010be0f:	68 60 02 00 00       	push   $0x260
f010be14:	68 13 66 12 f0       	push   $0xf0126613
f010be19:	e8 1b 45 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010be1e:	83 ec 0c             	sub    $0xc,%esp
f010be21:	68 80 f0 71 f0       	push   $0xf071f080
f010be26:	e8 ec 42 00 00       	call   f0110117 <holding_spinlock>
f010be2b:	83 c4 10             	add    $0x10,%esp
f010be2e:	85 c0                	test   %eax,%eax
f010be30:	75 17                	jne    f010be49 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010be32:	83 ec 04             	sub    $0x4,%esp
f010be35:	68 00 67 12 f0       	push   $0xf0126700
f010be3a:	68 64 02 00 00       	push   $0x264
f010be3f:	68 13 66 12 f0       	push   $0xf0126613
f010be44:	e8 f0 44 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010be49:	e8 e9 b5 ff ff       	call   f0107437 <mycpu>
f010be4e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010be54:	83 f8 01             	cmp    $0x1,%eax
f010be57:	74 20                	je     f010be79 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010be59:	e8 d9 b5 ff ff       	call   f0107437 <mycpu>
f010be5e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010be64:	50                   	push   %eax
f010be65:	68 42 67 12 f0       	push   $0xf0126742
f010be6a:	68 67 02 00 00       	push   $0x267
f010be6f:	68 13 66 12 f0       	push   $0xf0126613
f010be74:	e8 c0 44 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010be79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be7c:	8b 40 18             	mov    0x18(%eax),%eax
f010be7f:	83 f8 02             	cmp    $0x2,%eax
f010be82:	75 17                	jne    f010be9b <sched+0xaa>
		panic("sched a running process");
f010be84:	83 ec 04             	sub    $0x4,%esp
f010be87:	68 59 67 12 f0       	push   $0xf0126759
f010be8c:	68 6a 02 00 00       	push   $0x26a
f010be91:	68 13 66 12 f0       	push   $0xf0126613
f010be96:	e8 9e 44 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010be9b:	9c                   	pushf  
f010be9c:	58                   	pop    %eax
f010be9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bea0:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bea3:	25 00 02 00 00       	and    $0x200,%eax
f010bea8:	85 c0                	test   %eax,%eax
f010beaa:	74 17                	je     f010bec3 <sched+0xd2>
		panic("sched is interruptible!");
f010beac:	83 ec 04             	sub    $0x4,%esp
f010beaf:	68 71 67 12 f0       	push   $0xf0126771
f010beb4:	68 6c 02 00 00       	push   $0x26c
f010beb9:	68 13 66 12 f0       	push   $0xf0126613
f010bebe:	e8 76 44 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bec3:	e8 6f b5 ff ff       	call   f0107437 <mycpu>
f010bec8:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bece:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bed1:	e8 61 b5 ff ff       	call   f0107437 <mycpu>
f010bed6:	8b 40 04             	mov    0x4(%eax),%eax
f010bed9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bedc:	83 c2 04             	add    $0x4,%edx
f010bedf:	83 ec 08             	sub    $0x8,%esp
f010bee2:	50                   	push   %eax
f010bee3:	52                   	push   %edx
f010bee4:	e8 76 8e ff ff       	call   f0104d5f <context_switch>
f010bee9:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010beec:	e8 46 b5 ff ff       	call   f0107437 <mycpu>
f010bef1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bef4:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010befa:	90                   	nop
f010befb:	c9                   	leave  
f010befc:	c3                   	ret    

f010befd <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010befd:	55                   	push   %ebp
f010befe:	89 e5                	mov    %esp,%ebp
f010bf00:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bf03:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f010bf08:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bf0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bf0e:	0f 22 d8             	mov    %eax,%cr3
}
f010bf11:	90                   	nop
f010bf12:	c9                   	leave  
f010bf13:	c3                   	ret    

f010bf14 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bf14:	55                   	push   %ebp
f010bf15:	89 e5                	mov    %esp,%ebp
f010bf17:	53                   	push   %ebx
f010bf18:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bf1b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bf1f:	75 17                	jne    f010bf38 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bf21:	83 ec 04             	sub    $0x4,%esp
f010bf24:	68 89 67 12 f0       	push   $0xf0126789
f010bf29:	68 81 02 00 00       	push   $0x281
f010bf2e:	68 13 66 12 f0       	push   $0xf0126613
f010bf33:	e8 01 44 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bf38:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf3b:	8b 40 70             	mov    0x70(%eax),%eax
f010bf3e:	85 c0                	test   %eax,%eax
f010bf40:	75 17                	jne    f010bf59 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bf42:	83 ec 04             	sub    $0x4,%esp
f010bf45:	68 9f 67 12 f0       	push   $0xf012679f
f010bf4a:	68 83 02 00 00       	push   $0x283
f010bf4f:	68 13 66 12 f0       	push   $0xf0126613
f010bf54:	e8 e0 43 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010bf59:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf5c:	8b 40 64             	mov    0x64(%eax),%eax
f010bf5f:	85 c0                	test   %eax,%eax
f010bf61:	75 17                	jne    f010bf7a <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bf63:	83 ec 04             	sub    $0x4,%esp
f010bf66:	68 b4 67 12 f0       	push   $0xf01267b4
f010bf6b:	68 85 02 00 00       	push   $0x285
f010bf70:	68 13 66 12 f0       	push   $0xf0126613
f010bf75:	e8 bf 43 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bf7a:	e8 7b b5 ff ff       	call   f01074fa <pushcli>
	struct cpu* c = mycpu();
f010bf7f:	e8 b3 b4 ff ff       	call   f0107437 <mycpu>
f010bf84:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bf87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf8a:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf8d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bf93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf96:	83 c0 0c             	add    $0xc,%eax
f010bf99:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf9c:	83 c2 0c             	add    $0xc,%edx
f010bf9f:	c1 ea 10             	shr    $0x10,%edx
f010bfa2:	88 d3                	mov    %dl,%bl
f010bfa4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfa7:	83 c2 0c             	add    $0xc,%edx
f010bfaa:	c1 ea 18             	shr    $0x18,%edx
f010bfad:	88 d1                	mov    %dl,%cl
f010bfaf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfb2:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bfb9:	68 00 
f010bfbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfbe:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bfc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bfc8:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bfce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bfd1:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bfd7:	83 e2 f0             	and    $0xfffffff0,%edx
f010bfda:	83 ca 09             	or     $0x9,%edx
f010bfdd:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bfe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bfe6:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bfec:	83 ca 10             	or     $0x10,%edx
f010bfef:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bff8:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bffe:	83 e2 9f             	and    $0xffffff9f,%edx
f010c001:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c007:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c00a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c010:	83 ca 80             	or     $0xffffff80,%edx
f010c013:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c019:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c01c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c022:	83 e2 f0             	and    $0xfffffff0,%edx
f010c025:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c02b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c02e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c034:	83 e2 ef             	and    $0xffffffef,%edx
f010c037:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c040:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c046:	83 e2 df             	and    $0xffffffdf,%edx
f010c049:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c04f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c052:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c058:	83 ca 40             	or     $0x40,%edx
f010c05b:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c061:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c064:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c06a:	83 e2 7f             	and    $0x7f,%edx
f010c06d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c076:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c07c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c07f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c085:	83 e2 ef             	and    $0xffffffef,%edx
f010c088:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010c08e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c091:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c097:	8b 40 70             	mov    0x70(%eax),%eax
f010c09a:	05 00 80 00 00       	add    $0x8000,%eax
f010c09f:	89 c2                	mov    %eax,%edx
f010c0a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0a4:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c0a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0aa:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010c0b0:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c0b6:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c0ba:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010c0bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0c0:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c0c6:	8b 40 68             	mov    0x68(%eax),%eax
f010c0c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010c0cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c0cf:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010c0d2:	e8 75 b4 ff ff       	call   f010754c <popcli>
}
f010c0d7:	90                   	nop
f010c0d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c0db:	c9                   	leave  
f010c0dc:	c3                   	ret    

f010c0dd <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010c0dd:	55                   	push   %ebp
f010c0de:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010c0e0:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010c0e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0e9:	89 10                	mov    %edx,(%eax)
f010c0eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0ee:	8b 00                	mov    (%eax),%eax
f010c0f0:	85 c0                	test   %eax,%eax
f010c0f2:	75 07                	jne    f010c0fb <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010c0f4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010c0f9:	eb 11                	jmp    f010c10c <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010c0fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0fe:	8b 00                	mov    (%eax),%eax
f010c100:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010c107:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c10c:	5d                   	pop    %ebp
f010c10d:	c3                   	ret    

f010c10e <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010c10e:	55                   	push   %ebp
f010c10f:	89 e5                	mov    %esp,%ebp
f010c111:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010c114:	83 ec 04             	sub    $0x4,%esp
f010c117:	68 bc 05 00 00       	push   $0x5bc
f010c11c:	6a 00                	push   $0x0
f010c11e:	ff 75 08             	pushl  0x8(%ebp)
f010c121:	e8 74 3f 01 00       	call   f012009a <memset>
f010c126:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010c129:	8b 45 08             	mov    0x8(%ebp),%eax
f010c12c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010c133:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c137:	75 17                	jne    f010c150 <free_environment+0x42>
f010c139:	83 ec 04             	sub    $0x4,%esp
f010c13c:	68 f0 65 12 f0       	push   $0xf01265f0
f010c141:	68 c0 02 00 00       	push   $0x2c0
f010c146:	68 13 66 12 f0       	push   $0xf0126613
f010c14b:	e8 e9 41 ff ff       	call   f0100339 <_panic>
f010c150:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010c156:	8b 45 08             	mov    0x8(%ebp),%eax
f010c159:	89 50 08             	mov    %edx,0x8(%eax)
f010c15c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c15f:	8b 40 08             	mov    0x8(%eax),%eax
f010c162:	85 c0                	test   %eax,%eax
f010c164:	74 0d                	je     f010c173 <free_environment+0x65>
f010c166:	a1 94 65 6f f0       	mov    0xf06f6594,%eax
f010c16b:	8b 55 08             	mov    0x8(%ebp),%edx
f010c16e:	89 50 0c             	mov    %edx,0xc(%eax)
f010c171:	eb 08                	jmp    f010c17b <free_environment+0x6d>
f010c173:	8b 45 08             	mov    0x8(%ebp),%eax
f010c176:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010c17b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c17e:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010c183:	8b 45 08             	mov    0x8(%ebp),%eax
f010c186:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c18d:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010c192:	40                   	inc    %eax
f010c193:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
}
f010c198:	90                   	nop
f010c199:	c9                   	leave  
f010c19a:	c3                   	ret    

f010c19b <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010c19b:	55                   	push   %ebp
f010c19c:	89 e5                	mov    %esp,%ebp
f010c19e:	53                   	push   %ebx
f010c19f:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010c1a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c1a5:	8b 40 0c             	mov    0xc(%eax),%eax
f010c1a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010c1ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c1ae:	8b 40 08             	mov    0x8(%eax),%eax
f010c1b1:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010c1b4:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010c1bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010c1be:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c1c1:	01 c2                	add    %eax,%edx
f010c1c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c1c6:	01 d0                	add    %edx,%eax
f010c1c8:	48                   	dec    %eax
f010c1c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c1cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c1cf:	ba 00 00 00 00       	mov    $0x0,%edx
f010c1d4:	f7 75 dc             	divl   -0x24(%ebp)
f010c1d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c1da:	29 d0                	sub    %edx,%eax
f010c1dc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c1df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c1e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c1e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c1e8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c1ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c1f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c1f7:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c1fe:	8b 45 10             	mov    0x10(%ebp),%eax
f010c201:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c207:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c20e:	0f 85 f5 03 00 00    	jne    f010c609 <program_segment_alloc_map_copy_workingset+0x46e>
f010c214:	8b 45 08             	mov    0x8(%ebp),%eax
f010c217:	83 c0 20             	add    $0x20,%eax
f010c21a:	83 ec 08             	sub    $0x8,%esp
f010c21d:	68 c8 67 12 f0       	push   $0xf01267c8
f010c222:	50                   	push   %eax
f010c223:	e8 90 3d 01 00       	call   f011ffb8 <strcmp>
f010c228:	83 c4 10             	add    $0x10,%esp
f010c22b:	85 c0                	test   %eax,%eax
f010c22d:	0f 84 d6 03 00 00    	je     f010c609 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c233:	8b 45 14             	mov    0x14(%ebp),%eax
f010c236:	83 f8 06             	cmp    $0x6,%eax
f010c239:	76 05                	jbe    f010c240 <program_segment_alloc_map_copy_workingset+0xa5>
f010c23b:	b8 06 00 00 00       	mov    $0x6,%eax
f010c240:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c243:	e9 c1 03 00 00       	jmp    f010c609 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c248:	83 ec 0c             	sub    $0xc,%esp
f010c24b:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c24e:	50                   	push   %eax
f010c24f:	e8 89 c2 ff ff       	call   f01084dd <allocate_frame>
f010c254:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c257:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c25a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c25d:	8b 40 64             	mov    0x64(%eax),%eax
f010c260:	6a 06                	push   $0x6
f010c262:	ff 75 f4             	pushl  -0xc(%ebp)
f010c265:	52                   	push   %edx
f010c266:	50                   	push   %eax
f010c267:	e8 42 c9 ff ff       	call   f0108bae <loadtime_map_frame>
f010c26c:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c26f:	83 ec 08             	sub    $0x8,%esp
f010c272:	ff 75 f4             	pushl  -0xc(%ebp)
f010c275:	ff 75 08             	pushl  0x8(%ebp)
f010c278:	e8 ad de ff ff       	call   f010a12a <env_page_ws_list_create_element>
f010c27d:	83 c4 10             	add    $0x10,%esp
f010c280:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c283:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c286:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c28d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c291:	75 17                	jne    f010c2aa <program_segment_alloc_map_copy_workingset+0x10f>
f010c293:	83 ec 04             	sub    $0x4,%esp
f010c296:	68 78 66 12 f0       	push   $0xf0126678
f010c29b:	68 ea 02 00 00       	push   $0x2ea
f010c2a0:	68 13 66 12 f0       	push   $0xf0126613
f010c2a5:	e8 8f 40 ff ff       	call   f0100339 <_panic>
f010c2aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ad:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c2b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2b6:	89 50 14             	mov    %edx,0x14(%eax)
f010c2b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2bc:	8b 40 14             	mov    0x14(%eax),%eax
f010c2bf:	85 c0                	test   %eax,%eax
f010c2c1:	74 11                	je     f010c2d4 <program_segment_alloc_map_copy_workingset+0x139>
f010c2c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c6:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c2cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2cf:	89 50 10             	mov    %edx,0x10(%eax)
f010c2d2:	eb 0c                	jmp    f010c2e0 <program_segment_alloc_map_copy_workingset+0x145>
f010c2d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2da:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c2e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2e3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2e6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c2ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2ef:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c2f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f9:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c2ff:	8d 50 01             	lea    0x1(%eax),%edx
f010c302:	8b 45 08             	mov    0x8(%ebp),%eax
f010c305:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c30b:	83 ec 0c             	sub    $0xc,%esp
f010c30e:	6a 02                	push   $0x2
f010c310:	e8 96 35 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010c315:	83 c4 10             	add    $0x10,%esp
f010c318:	85 c0                	test   %eax,%eax
f010c31a:	0f 84 b3 01 00 00    	je     f010c4d3 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c320:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c324:	75 17                	jne    f010c33d <program_segment_alloc_map_copy_workingset+0x1a2>
f010c326:	83 ec 04             	sub    $0x4,%esp
f010c329:	68 9b 66 12 f0       	push   $0xf012669b
f010c32e:	68 f6 02 00 00       	push   $0x2f6
f010c333:	68 13 66 12 f0       	push   $0xf0126613
f010c338:	e8 fc 3f ff ff       	call   f0100339 <_panic>
f010c33d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c340:	8b 40 10             	mov    0x10(%eax),%eax
f010c343:	85 c0                	test   %eax,%eax
f010c345:	74 11                	je     f010c358 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c347:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c34a:	8b 40 10             	mov    0x10(%eax),%eax
f010c34d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c350:	8b 52 14             	mov    0x14(%edx),%edx
f010c353:	89 50 14             	mov    %edx,0x14(%eax)
f010c356:	eb 0f                	jmp    f010c367 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c358:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c35b:	8b 50 14             	mov    0x14(%eax),%edx
f010c35e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c361:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c367:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c36a:	8b 40 14             	mov    0x14(%eax),%eax
f010c36d:	85 c0                	test   %eax,%eax
f010c36f:	74 11                	je     f010c382 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c371:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c374:	8b 40 14             	mov    0x14(%eax),%eax
f010c377:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c37a:	8b 52 10             	mov    0x10(%edx),%edx
f010c37d:	89 50 10             	mov    %edx,0x10(%eax)
f010c380:	eb 0f                	jmp    f010c391 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c382:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c385:	8b 50 10             	mov    0x10(%eax),%edx
f010c388:	8b 45 08             	mov    0x8(%ebp),%eax
f010c38b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c391:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c394:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c39b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c39e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c3a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3a8:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c3ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c3b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3b4:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c3ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3bd:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c3c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3c6:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c3cc:	48                   	dec    %eax
f010c3cd:	39 c2                	cmp    %eax,%edx
f010c3cf:	0f 83 80 00 00 00    	jae    f010c455 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c3d5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c3d9:	75 17                	jne    f010c3f2 <program_segment_alloc_map_copy_workingset+0x257>
f010c3db:	83 ec 04             	sub    $0x4,%esp
f010c3de:	68 f0 65 12 f0       	push   $0xf01265f0
f010c3e3:	68 fa 02 00 00       	push   $0x2fa
f010c3e8:	68 13 66 12 f0       	push   $0xf0126613
f010c3ed:	e8 47 3f ff ff       	call   f0100339 <_panic>
f010c3f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3f5:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c3fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3fe:	89 50 10             	mov    %edx,0x10(%eax)
f010c401:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c404:	8b 40 10             	mov    0x10(%eax),%eax
f010c407:	85 c0                	test   %eax,%eax
f010c409:	74 11                	je     f010c41c <program_segment_alloc_map_copy_workingset+0x281>
f010c40b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c40e:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c414:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c417:	89 50 14             	mov    %edx,0x14(%eax)
f010c41a:	eb 0c                	jmp    f010c428 <program_segment_alloc_map_copy_workingset+0x28d>
f010c41c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c41f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c422:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c428:	8b 45 08             	mov    0x8(%ebp),%eax
f010c42b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c42e:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c434:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c437:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c43e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c441:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c447:	8d 50 01             	lea    0x1(%eax),%edx
f010c44a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c44d:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c453:	eb 7e                	jmp    f010c4d3 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c455:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c459:	75 17                	jne    f010c472 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c45b:	83 ec 04             	sub    $0x4,%esp
f010c45e:	68 f0 65 12 f0       	push   $0xf01265f0
f010c463:	68 ff 02 00 00       	push   $0x2ff
f010c468:	68 13 66 12 f0       	push   $0xf0126613
f010c46d:	e8 c7 3e ff ff       	call   f0100339 <_panic>
f010c472:	8b 45 08             	mov    0x8(%ebp),%eax
f010c475:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c47b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c47e:	89 50 10             	mov    %edx,0x10(%eax)
f010c481:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c484:	8b 40 10             	mov    0x10(%eax),%eax
f010c487:	85 c0                	test   %eax,%eax
f010c489:	74 11                	je     f010c49c <program_segment_alloc_map_copy_workingset+0x301>
f010c48b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c48e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c494:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c497:	89 50 14             	mov    %edx,0x14(%eax)
f010c49a:	eb 0c                	jmp    f010c4a8 <program_segment_alloc_map_copy_workingset+0x30d>
f010c49c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c49f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4a2:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c4a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4ae:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c4b4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4b7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c4be:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4c1:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c4c7:	8d 50 01             	lea    0x1(%eax),%edx
f010c4ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4cd:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c4d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4d6:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c4dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4df:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c4e5:	39 c2                	cmp    %eax,%edx
f010c4e7:	75 14                	jne    f010c4fd <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c4e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4ec:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c4f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4f5:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c4fb:	eb 0d                	jmp    f010c50a <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c4fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c500:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c507:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c50a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c50d:	c1 e8 16             	shr    $0x16,%eax
f010c510:	89 c2                	mov    %eax,%edx
f010c512:	8b 45 18             	mov    0x18(%ebp),%eax
f010c515:	8b 00                	mov    (%eax),%eax
f010c517:	39 c2                	cmp    %eax,%edx
f010c519:	0f 84 d3 00 00 00    	je     f010c5f2 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c51f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c522:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c528:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c52b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c52e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c531:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c536:	89 c1                	mov    %eax,%ecx
f010c538:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c53b:	89 d0                	mov    %edx,%eax
f010c53d:	01 c0                	add    %eax,%eax
f010c53f:	01 d0                	add    %edx,%eax
f010c541:	c1 e0 03             	shl    $0x3,%eax
f010c544:	01 d8                	add    %ebx,%eax
f010c546:	05 ac 00 00 00       	add    $0xac,%eax
f010c54b:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c54d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c550:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c556:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c559:	89 d0                	mov    %edx,%eax
f010c55b:	01 c0                	add    %eax,%eax
f010c55d:	01 d0                	add    %edx,%eax
f010c55f:	c1 e0 03             	shl    $0x3,%eax
f010c562:	01 c8                	add    %ecx,%eax
f010c564:	05 b0 00 00 00       	add    $0xb0,%eax
f010c569:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c56c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c56f:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c575:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c578:	89 d0                	mov    %edx,%eax
f010c57a:	01 c0                	add    %eax,%eax
f010c57c:	01 d0                	add    %edx,%eax
f010c57e:	c1 e0 03             	shl    $0x3,%eax
f010c581:	01 c8                	add    %ecx,%eax
f010c583:	05 b4 00 00 00       	add    $0xb4,%eax
f010c588:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c58e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c591:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c597:	8d 50 01             	lea    0x1(%eax),%edx
f010c59a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c59d:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c5a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5a6:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c5ac:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c5b1:	ba 00 00 00 00       	mov    $0x0,%edx
f010c5b6:	f7 f1                	div    %ecx
f010c5b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5bb:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c4:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c5ca:	85 c0                	test   %eax,%eax
f010c5cc:	75 17                	jne    f010c5e5 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c5ce:	83 ec 04             	sub    $0x4,%esp
f010c5d1:	68 cc 67 12 f0       	push   $0xf01267cc
f010c5d6:	68 27 03 00 00       	push   $0x327
f010c5db:	68 13 66 12 f0       	push   $0xf0126613
f010c5e0:	e8 54 3d ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c5e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5e8:	c1 e8 16             	shr    $0x16,%eax
f010c5eb:	89 c2                	mov    %eax,%edx
f010c5ed:	8b 45 18             	mov    0x18(%ebp),%eax
f010c5f0:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c5f2:	8b 45 10             	mov    0x10(%ebp),%eax
f010c5f5:	8b 00                	mov    (%eax),%eax
f010c5f7:	8d 50 01             	lea    0x1(%eax),%edx
f010c5fa:	8b 45 10             	mov    0x10(%ebp),%eax
f010c5fd:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c5ff:	ff 45 f0             	incl   -0x10(%ebp)
f010c602:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c609:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c60c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c60f:	73 0c                	jae    f010c61d <program_segment_alloc_map_copy_workingset+0x482>
f010c611:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c614:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c617:	0f 82 2b fc ff ff    	jb     f010c248 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c61d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c620:	8b 00                	mov    (%eax),%eax
f010c622:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c625:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c628:	8b 40 0c             	mov    0xc(%eax),%eax
f010c62b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c62e:	eb 10                	jmp    f010c640 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c630:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c633:	8a 10                	mov    (%eax),%dl
f010c635:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c638:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c63a:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c63d:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c640:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c643:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c646:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c649:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c64e:	89 c2                	mov    %eax,%edx
f010c650:	8b 45 10             	mov    0x10(%ebp),%eax
f010c653:	8b 00                	mov    (%eax),%eax
f010c655:	c1 e0 0c             	shl    $0xc,%eax
f010c658:	01 c2                	add    %eax,%edx
f010c65a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c65d:	39 c2                	cmp    %eax,%edx
f010c65f:	76 1d                	jbe    f010c67e <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c661:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c664:	8b 50 04             	mov    0x4(%eax),%edx
f010c667:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c66a:	01 c2                	add    %eax,%edx
f010c66c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c66f:	39 c2                	cmp    %eax,%edx
f010c671:	77 bd                	ja     f010c630 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c673:	eb 09                	jmp    f010c67e <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c675:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c678:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c67b:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c67e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c681:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c684:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c687:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c68c:	89 c2                	mov    %eax,%edx
f010c68e:	8b 45 10             	mov    0x10(%ebp),%eax
f010c691:	8b 00                	mov    (%eax),%eax
f010c693:	c1 e0 0c             	shl    $0xc,%eax
f010c696:	01 c2                	add    %eax,%edx
f010c698:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c69b:	39 c2                	cmp    %eax,%edx
f010c69d:	77 d6                	ja     f010c675 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c69f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c6a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c6a7:	c9                   	leave  
f010c6a8:	c3                   	ret    

f010c6a9 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c6a9:	55                   	push   %ebp
f010c6aa:	89 e5                	mov    %esp,%ebp
f010c6ac:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c6af:	83 ec 0c             	sub    $0xc,%esp
f010c6b2:	68 00 10 00 00       	push   $0x1000
f010c6b7:	e8 fe d0 ff ff       	call   f01097ba <kmalloc>
f010c6bc:	83 c4 10             	add    $0x10,%esp
f010c6bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c6c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c6c6:	75 17                	jne    f010c6df <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c6c8:	83 ec 04             	sub    $0x4,%esp
f010c6cb:	68 6f 68 12 f0       	push   $0xf012686f
f010c6d0:	68 57 03 00 00       	push   $0x357
f010c6d5:	68 13 66 12 f0       	push   $0xf0126613
f010c6da:	e8 5a 3c ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c6df:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c6e2:	c9                   	leave  
f010c6e3:	c3                   	ret    

f010c6e4 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c6e4:	55                   	push   %ebp
f010c6e5:	89 e5                	mov    %esp,%ebp
f010c6e7:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c6ea:	83 ec 0c             	sub    $0xc,%esp
f010c6ed:	68 00 80 00 00       	push   $0x8000
f010c6f2:	e8 c3 d0 ff ff       	call   f01097ba <kmalloc>
f010c6f7:	83 c4 10             	add    $0x10,%esp
f010c6fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c6fd:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c704:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c707:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c70c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c70f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c712:	ba 00 00 00 00       	mov    $0x0,%edx
f010c717:	f7 75 ec             	divl   -0x14(%ebp)
f010c71a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c71d:	29 d0                	sub    %edx,%eax
f010c71f:	85 c0                	test   %eax,%eax
f010c721:	79 05                	jns    f010c728 <create_user_kern_stack+0x44>
f010c723:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c728:	c1 f8 0c             	sar    $0xc,%eax
f010c72b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c72e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c735:	eb 72                	jmp    f010c7a9 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c737:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c73e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c741:	c1 e0 0c             	shl    $0xc,%eax
f010c744:	89 c2                	mov    %eax,%edx
f010c746:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c749:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c74c:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f010c751:	83 ec 04             	sub    $0x4,%esp
f010c754:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c757:	52                   	push   %edx
f010c758:	51                   	push   %ecx
f010c759:	50                   	push   %eax
f010c75a:	e8 35 c3 ff ff       	call   f0108a94 <get_frame_info>
f010c75f:	83 c4 10             	add    $0x10,%esp
f010c762:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c765:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c768:	c1 e0 0c             	shl    $0xc,%eax
f010c76b:	89 c2                	mov    %eax,%edx
f010c76d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c770:	01 d0                	add    %edx,%eax
f010c772:	6a 01                	push   $0x1
f010c774:	50                   	push   %eax
f010c775:	ff 75 e0             	pushl  -0x20(%ebp)
f010c778:	ff 75 08             	pushl  0x8(%ebp)
f010c77b:	e8 2a c2 ff ff       	call   f01089aa <map_frame>
f010c780:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c783:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c787:	75 1d                	jne    f010c7a6 <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c789:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c78c:	c1 e0 0c             	shl    $0xc,%eax
f010c78f:	89 c2                	mov    %eax,%edx
f010c791:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c794:	01 d0                	add    %edx,%eax
f010c796:	6a 01                	push   $0x1
f010c798:	6a 00                	push   $0x0
f010c79a:	50                   	push   %eax
f010c79b:	ff 75 08             	pushl  0x8(%ebp)
f010c79e:	e8 51 d7 ff ff       	call   f0109ef4 <pt_set_page_permissions>
f010c7a3:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c7a6:	ff 45 f4             	incl   -0xc(%ebp)
f010c7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7ac:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c7af:	72 86                	jb     f010c737 <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c7b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c7b4:	c9                   	leave  
f010c7b5:	c3                   	ret    

f010c7b6 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c7b6:	55                   	push   %ebp
f010c7b7:	89 e5                	mov    %esp,%ebp
f010c7b9:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c7bc:	83 ec 04             	sub    $0x4,%esp
f010c7bf:	68 8c 68 12 f0       	push   $0xf012688c
f010c7c4:	68 8e 03 00 00       	push   $0x38e
f010c7c9:	68 13 66 12 f0       	push   $0xf0126613
f010c7ce:	e8 66 3b ff ff       	call   f0100339 <_panic>

f010c7d3 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c7d3:	55                   	push   %ebp
f010c7d4:	89 e5                	mov    %esp,%ebp
f010c7d6:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c7d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c7df:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c7e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e5:	8b 55 10             	mov    0x10(%ebp),%edx
f010c7e8:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c7eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7ee:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c7f1:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c7f4:	83 ec 08             	sub    $0x8,%esp
f010c7f7:	6a 00                	push   $0x0
f010c7f9:	ff 75 0c             	pushl  0xc(%ebp)
f010c7fc:	e8 7a 42 01 00       	call   f0120a7b <initialize_dynamic_allocator>
f010c801:	83 c4 10             	add    $0x10,%esp
}
f010c804:	90                   	nop
f010c805:	c9                   	leave  
f010c806:	c3                   	ret    

f010c807 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c807:	55                   	push   %ebp
f010c808:	89 e5                	mov    %esp,%ebp
f010c80a:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c80d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c810:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c813:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c816:	8b 45 08             	mov    0x8(%ebp),%eax
f010c819:	8b 55 10             	mov    0x10(%ebp),%edx
f010c81c:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c81f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c826:	eb 17                	jmp    f010c83f <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c828:	8b 45 08             	mov    0x8(%ebp),%eax
f010c82b:	8b 40 64             	mov    0x64(%eax),%eax
f010c82e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c831:	c1 e2 02             	shl    $0x2,%edx
f010c834:	01 d0                	add    %edx,%eax
f010c836:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c83c:	ff 45 f4             	incl   -0xc(%ebp)
f010c83f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c842:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c847:	76 df                	jbe    f010c828 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c849:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c850:	eb 22                	jmp    f010c874 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c852:	8b 45 08             	mov    0x8(%ebp),%eax
f010c855:	8b 40 64             	mov    0x64(%eax),%eax
f010c858:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c85b:	c1 e2 02             	shl    $0x2,%edx
f010c85e:	01 c2                	add    %eax,%edx
f010c860:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f010c865:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c868:	c1 e1 02             	shl    $0x2,%ecx
f010c86b:	01 c8                	add    %ecx,%eax
f010c86d:	8b 00                	mov    (%eax),%eax
f010c86f:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c871:	ff 45 f4             	incl   -0xc(%ebp)
f010c874:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c87b:	7e d5                	jle    f010c852 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c87d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c880:	8b 40 64             	mov    0x64(%eax),%eax
f010c883:	83 ec 0c             	sub    $0xc,%esp
f010c886:	50                   	push   %eax
f010c887:	e8 58 fe ff ff       	call   f010c6e4 <create_user_kern_stack>
f010c88c:	83 c4 10             	add    $0x10,%esp
f010c88f:	89 c2                	mov    %eax,%edx
f010c891:	8b 45 08             	mov    0x8(%ebp),%eax
f010c894:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c897:	8b 45 08             	mov    0x8(%ebp),%eax
f010c89a:	8b 40 70             	mov    0x70(%eax),%eax
f010c89d:	05 00 80 00 00       	add    $0x8000,%eax
f010c8a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c8a5:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c8a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c8af:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c8b1:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c8b5:	ba f4 e8 10 f0       	mov    $0xf010e8f4,%edx
f010c8ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c8bd:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c8bf:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c8c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8c6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c8c9:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c8cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8cf:	8b 40 04             	mov    0x4(%eax),%eax
f010c8d2:	83 ec 04             	sub    $0x4,%esp
f010c8d5:	6a 20                	push   $0x20
f010c8d7:	6a 00                	push   $0x0
f010c8d9:	50                   	push   %eax
f010c8da:	e8 bb 37 01 00       	call   f012009a <memset>
f010c8df:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c8e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e5:	8b 40 04             	mov    0x4(%eax),%eax
f010c8e8:	ba d6 bb 10 f0       	mov    $0xf010bbd6,%edx
f010c8ed:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c8f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8f3:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c8fa:	00 00 00 
f010c8fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c900:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c907:	00 00 00 
f010c90a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c90d:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c914:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c917:	83 ec 0c             	sub    $0xc,%esp
f010c91a:	6a 02                	push   $0x2
f010c91c:	e8 8a 2f 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010c921:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c924:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c92b:	eb 54                	jmp    f010c981 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c92d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c930:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c933:	89 d0                	mov    %edx,%eax
f010c935:	01 c0                	add    %eax,%eax
f010c937:	01 d0                	add    %edx,%eax
f010c939:	c1 e0 03             	shl    $0x3,%eax
f010c93c:	01 c8                	add    %ecx,%eax
f010c93e:	05 ac 00 00 00       	add    $0xac,%eax
f010c943:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c949:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c94c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c94f:	89 d0                	mov    %edx,%eax
f010c951:	01 c0                	add    %eax,%eax
f010c953:	01 d0                	add    %edx,%eax
f010c955:	c1 e0 03             	shl    $0x3,%eax
f010c958:	01 c8                	add    %ecx,%eax
f010c95a:	05 b0 00 00 00       	add    $0xb0,%eax
f010c95f:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c962:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c965:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c968:	89 d0                	mov    %edx,%eax
f010c96a:	01 c0                	add    %eax,%eax
f010c96c:	01 d0                	add    %edx,%eax
f010c96e:	c1 e0 03             	shl    $0x3,%eax
f010c971:	01 c8                	add    %ecx,%eax
f010c973:	05 b4 00 00 00       	add    $0xb4,%eax
f010c978:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c97e:	ff 45 f4             	incl   -0xc(%ebp)
f010c981:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c985:	7e a6                	jle    f010c92d <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c987:	8b 45 08             	mov    0x8(%ebp),%eax
f010c98a:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c991:	00 00 00 

	e->pageFaultsCounter=0;
f010c994:	8b 45 08             	mov    0x8(%ebp),%eax
f010c997:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c99e:	00 00 00 
	e->tableFaultsCounter=0;
f010c9a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9a4:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c9ab:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c9ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9b1:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c9b8:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c9bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9be:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c9c5:	00 00 00 

	e->nModifiedPages=0;
f010c9c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9cb:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c9d2:	00 00 00 
	e->nNotModifiedPages=0;
f010c9d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9d8:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c9df:	00 00 00 
	e->nClocks = 0;
f010c9e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e5:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c9ec:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c9ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9f2:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c9f9:	00 00 00 
	e->nPageOut = 0;
f010c9fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9ff:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010ca06:	00 00 00 
	e->nNewPageAdded = 0;
f010ca09:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca0c:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010ca13:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010ca16:	83 ec 04             	sub    $0x4,%esp
f010ca19:	68 00 00 00 82       	push   $0x82000000
f010ca1e:	68 00 00 00 80       	push   $0x80000000
f010ca23:	ff 75 08             	pushl  0x8(%ebp)
f010ca26:	e8 a8 fd ff ff       	call   f010c7d3 <initialize_uheap_dynamic_allocator>
f010ca2b:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010ca2e:	83 ec 0c             	sub    $0xc,%esp
f010ca31:	ff 75 08             	pushl  0x8(%ebp)
f010ca34:	e8 06 00 00 00       	call   f010ca3f <complete_environment_initialization>
f010ca39:	83 c4 10             	add    $0x10,%esp
}
f010ca3c:	90                   	nop
f010ca3d:	c9                   	leave  
f010ca3e:	c3                   	ret    

f010ca3f <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010ca3f:	55                   	push   %ebp
f010ca40:	89 e5                	mov    %esp,%ebp
f010ca42:	53                   	push   %ebx
f010ca43:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010ca46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca49:	8b 40 64             	mov    0x64(%eax),%eax
f010ca4c:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010ca52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca55:	8b 40 68             	mov    0x68(%eax),%eax
f010ca58:	83 c8 03             	or     $0x3,%eax
f010ca5b:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010ca5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca60:	8b 40 64             	mov    0x64(%eax),%eax
f010ca63:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010ca69:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca6c:	8b 40 68             	mov    0x68(%eax),%eax
f010ca6f:	83 c8 05             	or     $0x5,%eax
f010ca72:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010ca74:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca77:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010ca7e:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010ca81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca84:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010ca8b:	00 00 00 
	e->disk_env_tabledir = 0;
f010ca8e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca91:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010ca98:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010ca9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca9e:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010caa5:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010caa8:	8b 45 08             	mov    0x8(%ebp),%eax
f010caab:	8b 58 10             	mov    0x10(%eax),%ebx
f010caae:	83 ec 0c             	sub    $0xc,%esp
f010cab1:	68 ca 02 00 00       	push   $0x2ca
f010cab6:	e8 84 19 01 00       	call   f011e43f <log2_ceil>
f010cabb:	83 c4 10             	add    $0x10,%esp
f010cabe:	ba 01 00 00 00       	mov    $0x1,%edx
f010cac3:	88 c1                	mov    %al,%cl
f010cac5:	d3 e2                	shl    %cl,%edx
f010cac7:	89 d0                	mov    %edx,%eax
f010cac9:	01 d8                	add    %ebx,%eax
f010cacb:	89 c3                	mov    %eax,%ebx
f010cacd:	83 ec 0c             	sub    $0xc,%esp
f010cad0:	68 ca 02 00 00       	push   $0x2ca
f010cad5:	e8 30 19 01 00       	call   f011e40a <nearest_pow2_ceil>
f010cada:	83 c4 10             	add    $0x10,%esp
f010cadd:	f7 d8                	neg    %eax
f010cadf:	21 d8                	and    %ebx,%eax
f010cae1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010cae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cae8:	7f 1e                	jg     f010cb08 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010caea:	83 ec 0c             	sub    $0xc,%esp
f010caed:	68 ca 02 00 00       	push   $0x2ca
f010caf2:	e8 48 19 01 00       	call   f011e43f <log2_ceil>
f010caf7:	83 c4 10             	add    $0x10,%esp
f010cafa:	ba 01 00 00 00       	mov    $0x1,%edx
f010caff:	88 c1                	mov    %al,%cl
f010cb01:	d3 e2                	shl    %cl,%edx
f010cb03:	89 d0                	mov    %edx,%eax
f010cb05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010cb08:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb0b:	8b 15 90 65 6f f0    	mov    0xf06f6590,%edx
f010cb11:	29 d0                	sub    %edx,%eax
f010cb13:	c1 f8 02             	sar    $0x2,%eax
f010cb16:	89 c2                	mov    %eax,%edx
f010cb18:	89 d0                	mov    %edx,%eax
f010cb1a:	c1 e0 03             	shl    $0x3,%eax
f010cb1d:	01 d0                	add    %edx,%eax
f010cb1f:	c1 e0 03             	shl    $0x3,%eax
f010cb22:	01 d0                	add    %edx,%eax
f010cb24:	c1 e0 02             	shl    $0x2,%eax
f010cb27:	01 d0                	add    %edx,%eax
f010cb29:	01 c0                	add    %eax,%eax
f010cb2b:	01 d0                	add    %edx,%eax
f010cb2d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010cb34:	01 c8                	add    %ecx,%eax
f010cb36:	c1 e0 02             	shl    $0x2,%eax
f010cb39:	01 d0                	add    %edx,%eax
f010cb3b:	c1 e0 03             	shl    $0x3,%eax
f010cb3e:	01 d0                	add    %edx,%eax
f010cb40:	c1 e0 05             	shl    $0x5,%eax
f010cb43:	29 d0                	sub    %edx,%eax
f010cb45:	c1 e0 02             	shl    $0x2,%eax
f010cb48:	01 d0                	add    %edx,%eax
f010cb4a:	01 c0                	add    %eax,%eax
f010cb4c:	01 d0                	add    %edx,%eax
f010cb4e:	c1 e0 03             	shl    $0x3,%eax
f010cb51:	01 d0                	add    %edx,%eax
f010cb53:	c1 e0 04             	shl    $0x4,%eax
f010cb56:	29 d0                	sub    %edx,%eax
f010cb58:	0b 45 f4             	or     -0xc(%ebp),%eax
f010cb5b:	89 c2                	mov    %eax,%edx
f010cb5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb60:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010cb63:	e8 08 f1 ff ff       	call   f010bc70 <get_cpu_proc>
f010cb68:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010cb6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cb6f:	75 0c                	jne    f010cb7d <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010cb71:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb74:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010cb7b:	eb 0c                	jmp    f010cb89 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010cb7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb80:	8b 50 10             	mov    0x10(%eax),%edx
f010cb83:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb86:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010cb89:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb8c:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010cb93:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb96:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010cb9d:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010cba0:	8b 45 08             	mov    0x8(%ebp),%eax
f010cba3:	8b 00                	mov    (%eax),%eax
f010cba5:	83 ec 04             	sub    $0x4,%esp
f010cba8:	6a 44                	push   $0x44
f010cbaa:	6a 00                	push   $0x0
f010cbac:	50                   	push   %eax
f010cbad:	e8 e8 34 01 00       	call   f012009a <memset>
f010cbb2:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010cbb5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbb8:	8b 00                	mov    (%eax),%eax
f010cbba:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010cbc0:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbc3:	8b 00                	mov    (%eax),%eax
f010cbc5:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010cbcb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbce:	8b 00                	mov    (%eax),%eax
f010cbd0:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010cbd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbd9:	8b 00                	mov    (%eax),%eax
f010cbdb:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010cbe2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbe5:	8b 00                	mov    (%eax),%eax
f010cbe7:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010cbed:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbf0:	8b 00                	mov    (%eax),%eax
f010cbf2:	8b 55 08             	mov    0x8(%ebp),%edx
f010cbf5:	8b 12                	mov    (%edx),%edx
f010cbf7:	8b 52 38             	mov    0x38(%edx),%edx
f010cbfa:	80 ce 02             	or     $0x2,%dh
f010cbfd:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010cc00:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cc04:	75 17                	jne    f010cc1d <complete_environment_initialization+0x1de>
f010cc06:	83 ec 04             	sub    $0x4,%esp
f010cc09:	68 9b 66 12 f0       	push   $0xf012669b
f010cc0e:	68 67 04 00 00       	push   $0x467
f010cc13:	68 13 66 12 f0       	push   $0xf0126613
f010cc18:	e8 1c 37 ff ff       	call   f0100339 <_panic>
f010cc1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc20:	8b 40 08             	mov    0x8(%eax),%eax
f010cc23:	85 c0                	test   %eax,%eax
f010cc25:	74 11                	je     f010cc38 <complete_environment_initialization+0x1f9>
f010cc27:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc2a:	8b 40 08             	mov    0x8(%eax),%eax
f010cc2d:	8b 55 08             	mov    0x8(%ebp),%edx
f010cc30:	8b 52 0c             	mov    0xc(%edx),%edx
f010cc33:	89 50 0c             	mov    %edx,0xc(%eax)
f010cc36:	eb 0b                	jmp    f010cc43 <complete_environment_initialization+0x204>
f010cc38:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc3b:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc3e:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010cc43:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc46:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc49:	85 c0                	test   %eax,%eax
f010cc4b:	74 11                	je     f010cc5e <complete_environment_initialization+0x21f>
f010cc4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc50:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc53:	8b 55 08             	mov    0x8(%ebp),%edx
f010cc56:	8b 52 08             	mov    0x8(%edx),%edx
f010cc59:	89 50 08             	mov    %edx,0x8(%eax)
f010cc5c:	eb 0b                	jmp    f010cc69 <complete_environment_initialization+0x22a>
f010cc5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc61:	8b 40 08             	mov    0x8(%eax),%eax
f010cc64:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010cc69:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc6c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010cc73:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc76:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010cc7d:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010cc82:	48                   	dec    %eax
f010cc83:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
	return ;
f010cc88:	90                   	nop
}
f010cc89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cc8c:	c9                   	leave  
f010cc8d:	c3                   	ret    

f010cc8e <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010cc8e:	55                   	push   %ebp
f010cc8f:	89 e5                	mov    %esp,%ebp
f010cc91:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cc94:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cc9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc9d:	8b 00                	mov    (%eax),%eax
f010cc9f:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cca4:	74 17                	je     f010ccbd <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010cca6:	83 ec 04             	sub    $0x4,%esp
f010cca9:	68 c1 68 12 f0       	push   $0xf01268c1
f010ccae:	68 73 04 00 00       	push   $0x473
f010ccb3:	68 13 66 12 f0       	push   $0xf0126613
f010ccb8:	e8 7c 36 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010ccbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccc0:	8b 00                	mov    (%eax),%eax
f010ccc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ccc5:	8b 52 18             	mov    0x18(%edx),%edx
f010ccc8:	89 50 30             	mov    %edx,0x30(%eax)
}
f010cccb:	90                   	nop
f010cccc:	c9                   	leave  
f010cccd:	c3                   	ret    

f010ccce <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010ccce:	55                   	push   %ebp
f010cccf:	89 e5                	mov    %esp,%ebp
f010ccd1:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010ccd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccd7:	8b 40 10             	mov    0x10(%eax),%eax
f010ccda:	8d 48 01             	lea    0x1(%eax),%ecx
f010ccdd:	8b 55 08             	mov    0x8(%ebp),%edx
f010cce0:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cce3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cce6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cce9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ccec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ccef:	8b 00                	mov    (%eax),%eax
f010ccf1:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ccf6:	74 17                	je     f010cd0f <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010ccf8:	83 ec 04             	sub    $0x4,%esp
f010ccfb:	68 c1 68 12 f0       	push   $0xf01268c1
f010cd00:	68 81 04 00 00       	push   $0x481
f010cd05:	68 13 66 12 f0       	push   $0xf0126613
f010cd0a:	e8 2a 36 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cd0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cd12:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cd15:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd18:	01 d0                	add    %edx,%eax
f010cd1a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cd1d:	eb 0f                	jmp    f010cd2e <PROGRAM_SEGMENT_NEXT+0x60>
f010cd1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd22:	8b 40 10             	mov    0x10(%eax),%eax
f010cd25:	8d 50 01             	lea    0x1(%eax),%edx
f010cd28:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd2b:	89 50 10             	mov    %edx,0x10(%eax)
f010cd2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd31:	8b 40 10             	mov    0x10(%eax),%eax
f010cd34:	c1 e0 05             	shl    $0x5,%eax
f010cd37:	89 c2                	mov    %eax,%edx
f010cd39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cd3c:	01 d0                	add    %edx,%eax
f010cd3e:	8b 00                	mov    (%eax),%eax
f010cd40:	83 f8 01             	cmp    $0x1,%eax
f010cd43:	74 13                	je     f010cd58 <PROGRAM_SEGMENT_NEXT+0x8a>
f010cd45:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd48:	8b 50 10             	mov    0x10(%eax),%edx
f010cd4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cd4e:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cd51:	0f b7 c0             	movzwl %ax,%eax
f010cd54:	39 c2                	cmp    %eax,%edx
f010cd56:	72 c7                	jb     f010cd1f <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cd58:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd5b:	8b 40 10             	mov    0x10(%eax),%eax
f010cd5e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cd61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cd64:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cd67:	0f b7 c0             	movzwl %ax,%eax
f010cd6a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010cd6d:	7e 63                	jle    f010cdd2 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cd6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd72:	c1 e0 05             	shl    $0x5,%eax
f010cd75:	89 c2                	mov    %eax,%edx
f010cd77:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cd7a:	01 d0                	add    %edx,%eax
f010cd7c:	8b 50 04             	mov    0x4(%eax),%edx
f010cd7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd82:	01 c2                	add    %eax,%edx
f010cd84:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd87:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010cd89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd8c:	c1 e0 05             	shl    $0x5,%eax
f010cd8f:	89 c2                	mov    %eax,%edx
f010cd91:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cd94:	01 d0                	add    %edx,%eax
f010cd96:	8b 50 14             	mov    0x14(%eax),%edx
f010cd99:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd9c:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010cd9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cda2:	c1 e0 05             	shl    $0x5,%eax
f010cda5:	89 c2                	mov    %eax,%edx
f010cda7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cdaa:	01 d0                	add    %edx,%eax
f010cdac:	8b 50 10             	mov    0x10(%eax),%edx
f010cdaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdb2:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cdb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdb8:	c1 e0 05             	shl    $0x5,%eax
f010cdbb:	89 c2                	mov    %eax,%edx
f010cdbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cdc0:	01 d0                	add    %edx,%eax
f010cdc2:	8b 40 08             	mov    0x8(%eax),%eax
f010cdc5:	89 c2                	mov    %eax,%edx
f010cdc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdca:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cdcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdd0:	eb 05                	jmp    f010cdd7 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010cdd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010cdd7:	c9                   	leave  
f010cdd8:	c3                   	ret    

f010cdd9 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010cdd9:	55                   	push   %ebp
f010cdda:	89 e5                	mov    %esp,%ebp
f010cddc:	57                   	push   %edi
f010cddd:	56                   	push   %esi
f010cdde:	53                   	push   %ebx
f010cddf:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cde2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cde9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cdec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cdef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cdf2:	8b 00                	mov    (%eax),%eax
f010cdf4:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cdf9:	74 17                	je     f010ce12 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cdfb:	83 ec 04             	sub    $0x4,%esp
f010cdfe:	68 c1 68 12 f0       	push   $0xf01268c1
f010ce03:	68 9d 04 00 00       	push   $0x49d
f010ce08:	68 13 66 12 f0       	push   $0xf0126613
f010ce0d:	e8 27 35 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010ce12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ce15:	8b 50 1c             	mov    0x1c(%eax),%edx
f010ce18:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce1b:	01 d0                	add    %edx,%eax
f010ce1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010ce20:	eb 07                	jmp    f010ce29 <PROGRAM_SEGMENT_FIRST+0x50>
f010ce22:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ce25:	40                   	inc    %eax
f010ce26:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010ce29:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ce2c:	c1 e0 05             	shl    $0x5,%eax
f010ce2f:	89 c2                	mov    %eax,%edx
f010ce31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ce34:	01 d0                	add    %edx,%eax
f010ce36:	8b 00                	mov    (%eax),%eax
f010ce38:	83 f8 01             	cmp    $0x1,%eax
f010ce3b:	74 10                	je     f010ce4d <PROGRAM_SEGMENT_FIRST+0x74>
f010ce3d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010ce40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ce43:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce46:	0f b7 c0             	movzwl %ax,%eax
f010ce49:	39 c2                	cmp    %eax,%edx
f010ce4b:	72 d5                	jb     f010ce22 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010ce4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ce50:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010ce53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ce56:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce59:	0f b7 c0             	movzwl %ax,%eax
f010ce5c:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010ce5f:	7e 68                	jle    f010cec9 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ce61:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ce64:	c1 e0 05             	shl    $0x5,%eax
f010ce67:	89 c2                	mov    %eax,%edx
f010ce69:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ce6c:	01 d0                	add    %edx,%eax
f010ce6e:	8b 50 04             	mov    0x4(%eax),%edx
f010ce71:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce74:	01 d0                	add    %edx,%eax
f010ce76:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010ce79:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ce7c:	c1 e0 05             	shl    $0x5,%eax
f010ce7f:	89 c2                	mov    %eax,%edx
f010ce81:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ce84:	01 d0                	add    %edx,%eax
f010ce86:	8b 40 14             	mov    0x14(%eax),%eax
f010ce89:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010ce8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ce8f:	c1 e0 05             	shl    $0x5,%eax
f010ce92:	89 c2                	mov    %eax,%edx
f010ce94:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ce97:	01 d0                	add    %edx,%eax
f010ce99:	8b 40 10             	mov    0x10(%eax),%eax
f010ce9c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010ce9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cea2:	c1 e0 05             	shl    $0x5,%eax
f010cea5:	89 c2                	mov    %eax,%edx
f010cea7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ceaa:	01 d0                	add    %edx,%eax
f010ceac:	8b 40 08             	mov    0x8(%eax),%eax
f010ceaf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010ceb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ceb5:	89 c3                	mov    %eax,%ebx
f010ceb7:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ceba:	ba 05 00 00 00       	mov    $0x5,%edx
f010cebf:	89 df                	mov    %ebx,%edi
f010cec1:	89 c6                	mov    %eax,%esi
f010cec3:	89 d1                	mov    %edx,%ecx
f010cec5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cec7:	eb 1c                	jmp    f010cee5 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cec9:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010ced0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ced3:	89 c3                	mov    %eax,%ebx
f010ced5:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ced8:	ba 05 00 00 00       	mov    $0x5,%edx
f010cedd:	89 df                	mov    %ebx,%edi
f010cedf:	89 c6                	mov    %eax,%esi
f010cee1:	89 d1                	mov    %edx,%ecx
f010cee3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cee5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cee8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ceeb:	5b                   	pop    %ebx
f010ceec:	5e                   	pop    %esi
f010ceed:	5f                   	pop    %edi
f010ceee:	5d                   	pop    %ebp
f010ceef:	c2 04 00             	ret    $0x4

f010cef2 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cef2:	55                   	push   %ebp
f010cef3:	89 e5                	mov    %esp,%ebp
f010cef5:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cef8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010ceff:	83 ec 0c             	sub    $0xc,%esp
f010cf02:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010cf07:	e8 f2 2f 00 00       	call   f010fefe <acquire_spinlock>
f010cf0c:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cf0f:	a1 30 f1 b1 f0       	mov    0xf0b1f130,%eax
f010cf14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cf17:	e9 c3 00 00 00       	jmp    f010cfdf <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cf1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf1f:	8b 40 0c             	mov    0xc(%eax),%eax
f010cf22:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cf25:	0f 85 ac 00 00 00    	jne    f010cfd7 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cf2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf2e:	8b 50 10             	mov    0x10(%eax),%edx
f010cf31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf34:	8b 40 0c             	mov    0xc(%eax),%eax
f010cf37:	8b 40 64             	mov    0x64(%eax),%eax
f010cf3a:	83 ec 08             	sub    $0x8,%esp
f010cf3d:	52                   	push   %edx
f010cf3e:	50                   	push   %eax
f010cf3f:	e8 bd d0 ff ff       	call   f010a001 <pt_clear_page_table_entry>
f010cf44:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cf47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cf4b:	75 17                	jne    f010cf64 <cleanup_buffers+0x72>
f010cf4d:	83 ec 04             	sub    $0x4,%esp
f010cf50:	68 9b 66 12 f0       	push   $0xf012669b
f010cf55:	68 c6 04 00 00       	push   $0x4c6
f010cf5a:	68 13 66 12 f0       	push   $0xf0126613
f010cf5f:	e8 d5 33 ff ff       	call   f0100339 <_panic>
f010cf64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf67:	8b 00                	mov    (%eax),%eax
f010cf69:	85 c0                	test   %eax,%eax
f010cf6b:	74 10                	je     f010cf7d <cleanup_buffers+0x8b>
f010cf6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf70:	8b 00                	mov    (%eax),%eax
f010cf72:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf75:	8b 52 04             	mov    0x4(%edx),%edx
f010cf78:	89 50 04             	mov    %edx,0x4(%eax)
f010cf7b:	eb 0b                	jmp    f010cf88 <cleanup_buffers+0x96>
f010cf7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf80:	8b 40 04             	mov    0x4(%eax),%eax
f010cf83:	a3 34 f1 b1 f0       	mov    %eax,0xf0b1f134
f010cf88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf8b:	8b 40 04             	mov    0x4(%eax),%eax
f010cf8e:	85 c0                	test   %eax,%eax
f010cf90:	74 0f                	je     f010cfa1 <cleanup_buffers+0xaf>
f010cf92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf95:	8b 40 04             	mov    0x4(%eax),%eax
f010cf98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf9b:	8b 12                	mov    (%edx),%edx
f010cf9d:	89 10                	mov    %edx,(%eax)
f010cf9f:	eb 0a                	jmp    f010cfab <cleanup_buffers+0xb9>
f010cfa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfa4:	8b 00                	mov    (%eax),%eax
f010cfa6:	a3 30 f1 b1 f0       	mov    %eax,0xf0b1f130
f010cfab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cfb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfb7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cfbe:	a1 3c f1 b1 f0       	mov    0xf0b1f13c,%eax
f010cfc3:	48                   	dec    %eax
f010cfc4:	a3 3c f1 b1 f0       	mov    %eax,0xf0b1f13c

				free_frame(ptr_fi);
f010cfc9:	83 ec 0c             	sub    $0xc,%esp
f010cfcc:	ff 75 f4             	pushl  -0xc(%ebp)
f010cfcf:	e8 5d b6 ff ff       	call   f0108631 <free_frame>
f010cfd4:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cfd7:	a1 38 f1 b1 f0       	mov    0xf0b1f138,%eax
f010cfdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cfdf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cfe3:	74 07                	je     f010cfec <cleanup_buffers+0xfa>
f010cfe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe8:	8b 00                	mov    (%eax),%eax
f010cfea:	eb 05                	jmp    f010cff1 <cleanup_buffers+0xff>
f010cfec:	b8 00 00 00 00       	mov    $0x0,%eax
f010cff1:	a3 38 f1 b1 f0       	mov    %eax,0xf0b1f138
f010cff6:	a1 38 f1 b1 f0       	mov    0xf0b1f138,%eax
f010cffb:	85 c0                	test   %eax,%eax
f010cffd:	0f 85 19 ff ff ff    	jne    f010cf1c <cleanup_buffers+0x2a>
f010d003:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d007:	0f 85 0f ff ff ff    	jne    f010cf1c <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d00d:	83 ec 0c             	sub    $0xc,%esp
f010d010:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010d015:	e8 6b 2f 00 00       	call   f010ff85 <release_spinlock>
f010d01a:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010d01d:	90                   	nop
f010d01e:	c9                   	leave  
f010d01f:	c3                   	ret    

f010d020 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010d020:	55                   	push   %ebp
f010d021:	89 e5                	mov    %esp,%ebp
f010d023:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010d026:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010d02a:	7e 06                	jle    f010d032 <set_program_priority+0x12>
f010d02c:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d030:	7e 14                	jle    f010d046 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010d032:	83 ec 04             	sub    $0x4,%esp
f010d035:	68 d8 68 12 f0       	push   $0xf01268d8
f010d03a:	6a 10                	push   $0x10
f010d03c:	68 fc 68 12 f0       	push   $0xf01268fc
f010d041:	e8 f3 32 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010d046:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d04a:	74 78                	je     f010d0c4 <set_program_priority+0xa4>
		return;
	switch(priority)
f010d04c:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d050:	77 56                	ja     f010d0a8 <set_program_priority+0x88>
f010d052:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d055:	c1 e0 02             	shl    $0x2,%eax
f010d058:	05 38 69 12 f0       	add    $0xf0126938,%eax
f010d05d:	8b 00                	mov    (%eax),%eax
f010d05f:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010d061:	83 ec 08             	sub    $0x8,%esp
f010d064:	6a 01                	push   $0x1
f010d066:	ff 75 08             	pushl  0x8(%ebp)
f010d069:	e8 ea dc ff ff       	call   f010ad58 <half_WS_Size>
f010d06e:	83 c4 10             	add    $0x10,%esp
			break;
f010d071:	eb 35                	jmp    f010d0a8 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010d073:	83 ec 08             	sub    $0x8,%esp
f010d076:	6a 00                	push   $0x0
f010d078:	ff 75 08             	pushl  0x8(%ebp)
f010d07b:	e8 d8 dc ff ff       	call   f010ad58 <half_WS_Size>
f010d080:	83 c4 10             	add    $0x10,%esp
			break;
f010d083:	eb 23                	jmp    f010d0a8 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010d085:	83 ec 08             	sub    $0x8,%esp
f010d088:	6a 01                	push   $0x1
f010d08a:	ff 75 08             	pushl  0x8(%ebp)
f010d08d:	e8 a9 dc ff ff       	call   f010ad3b <double_WS_Size>
f010d092:	83 c4 10             	add    $0x10,%esp
			break;
f010d095:	eb 11                	jmp    f010d0a8 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010d097:	83 ec 08             	sub    $0x8,%esp
f010d09a:	6a 00                	push   $0x0
f010d09c:	ff 75 08             	pushl  0x8(%ebp)
f010d09f:	e8 97 dc ff ff       	call   f010ad3b <double_WS_Size>
f010d0a4:	83 c4 10             	add    $0x10,%esp
			break;
f010d0a7:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010d0a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0ab:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d0b1:	83 ec 08             	sub    $0x8,%esp
f010d0b4:	50                   	push   %eax
f010d0b5:	68 19 69 12 f0       	push   $0xf0126919
f010d0ba:	e8 cc 3e ff ff       	call   f0100f8b <cprintf>
f010d0bf:	83 c4 10             	add    $0x10,%esp
f010d0c2:	eb 01                	jmp    f010d0c5 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010d0c4:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010d0c5:	c9                   	leave  
f010d0c6:	c3                   	ret    

f010d0c7 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010d0c7:	55                   	push   %ebp
f010d0c8:	89 e5                	mov    %esp,%ebp
f010d0ca:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d0cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d0d4:	eb 29                	jmp    f010d0ff <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010d0d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d0d9:	89 d0                	mov    %edx,%eax
f010d0db:	01 c0                	add    %eax,%eax
f010d0dd:	01 d0                	add    %edx,%eax
f010d0df:	c1 e0 02             	shl    $0x2,%eax
f010d0e2:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d0e7:	8b 00                	mov    (%eax),%eax
f010d0e9:	83 ec 08             	sub    $0x8,%esp
f010d0ec:	50                   	push   %eax
f010d0ed:	ff 75 08             	pushl  0x8(%ebp)
f010d0f0:	e8 c3 2e 01 00       	call   f011ffb8 <strcmp>
f010d0f5:	83 c4 10             	add    $0x10,%esp
f010d0f8:	85 c0                	test   %eax,%eax
f010d0fa:	74 0f                	je     f010d10b <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d0fc:	ff 45 f4             	incl   -0xc(%ebp)
f010d0ff:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d104:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d107:	7c cd                	jl     f010d0d6 <get_user_program_info+0xf>
f010d109:	eb 01                	jmp    f010d10c <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010d10b:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d10c:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d111:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d114:	75 1a                	jne    f010d130 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010d116:	83 ec 08             	sub    $0x8,%esp
f010d119:	ff 75 08             	pushl  0x8(%ebp)
f010d11c:	68 35 78 12 f0       	push   $0xf0127835
f010d121:	e8 65 3e ff ff       	call   f0100f8b <cprintf>
f010d126:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d129:	b8 00 00 00 00       	mov    $0x0,%eax
f010d12e:	eb 11                	jmp    f010d141 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010d130:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d133:	89 d0                	mov    %edx,%eax
f010d135:	01 c0                	add    %eax,%eax
f010d137:	01 d0                	add    %edx,%eax
f010d139:	c1 e0 02             	shl    $0x2,%eax
f010d13c:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d141:	c9                   	leave  
f010d142:	c3                   	ret    

f010d143 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010d143:	55                   	push   %ebp
f010d144:	89 e5                	mov    %esp,%ebp
f010d146:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d149:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d150:	eb 2d                	jmp    f010d17f <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010d152:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d155:	89 d0                	mov    %edx,%eax
f010d157:	01 c0                	add    %eax,%eax
f010d159:	01 d0                	add    %edx,%eax
f010d15b:	c1 e0 02             	shl    $0x2,%eax
f010d15e:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d163:	8b 00                	mov    (%eax),%eax
f010d165:	8b 55 08             	mov    0x8(%ebp),%edx
f010d168:	83 c2 20             	add    $0x20,%edx
f010d16b:	83 ec 08             	sub    $0x8,%esp
f010d16e:	50                   	push   %eax
f010d16f:	52                   	push   %edx
f010d170:	e8 43 2e 01 00       	call   f011ffb8 <strcmp>
f010d175:	83 c4 10             	add    $0x10,%esp
f010d178:	85 c0                	test   %eax,%eax
f010d17a:	74 0f                	je     f010d18b <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d17c:	ff 45 f4             	incl   -0xc(%ebp)
f010d17f:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d184:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d187:	7c c9                	jl     f010d152 <get_user_program_info_by_env+0xf>
f010d189:	eb 01                	jmp    f010d18c <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010d18b:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d18c:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d191:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d194:	75 17                	jne    f010d1ad <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010d196:	83 ec 0c             	sub    $0xc,%esp
f010d199:	68 50 78 12 f0       	push   $0xf0127850
f010d19e:	e8 e8 3d ff ff       	call   f0100f8b <cprintf>
f010d1a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d1a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010d1ab:	eb 11                	jmp    f010d1be <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010d1ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d1b0:	89 d0                	mov    %edx,%eax
f010d1b2:	01 c0                	add    %eax,%eax
f010d1b4:	01 d0                	add    %edx,%eax
f010d1b6:	c1 e0 02             	shl    $0x2,%eax
f010d1b9:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d1be:	c9                   	leave  
f010d1bf:	c3                   	ret    

f010d1c0 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010d1c0:	55                   	push   %ebp
f010d1c1:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010d1c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1c6:	83 f8 13             	cmp    $0x13,%eax
f010d1c9:	77 0c                	ja     f010d1d7 <trapname+0x17>
		return excnames[trapno];
f010d1cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ce:	8b 04 85 40 7c 12 f0 	mov    -0xfed83c0(,%eax,4),%eax
f010d1d5:	eb 2c                	jmp    f010d203 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010d1d7:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010d1db:	75 07                	jne    f010d1e4 <trapname+0x24>
		return "System call";
f010d1dd:	b8 80 78 12 f0       	mov    $0xf0127880,%eax
f010d1e2:	eb 1f                	jmp    f010d203 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010d1e4:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010d1e8:	75 07                	jne    f010d1f1 <trapname+0x31>
		return "Clock Interrupt";
f010d1ea:	b8 8c 78 12 f0       	mov    $0xf012788c,%eax
f010d1ef:	eb 12                	jmp    f010d203 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010d1f1:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010d1f5:	75 07                	jne    f010d1fe <trapname+0x3e>
		return "Keyboard Interrupt";
f010d1f7:	b8 9c 78 12 f0       	mov    $0xf012789c,%eax
f010d1fc:	eb 05                	jmp    f010d203 <trapname+0x43>
	return "(unknown trap)";
f010d1fe:	b8 af 78 12 f0       	mov    $0xf01278af,%eax
}
f010d203:	5d                   	pop    %ebp
f010d204:	c3                   	ret    

f010d205 <ts_init>:


void ts_init(void)
{
f010d205:	55                   	push   %ebp
f010d206:	89 e5                	mov    %esp,%ebp
f010d208:	53                   	push   %ebx
f010d209:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010d20c:	e8 e9 a2 ff ff       	call   f01074fa <pushcli>

	struct cpu* c = mycpu();
f010d211:	e8 21 a2 ff ff       	call   f0107437 <mycpu>
f010d216:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010d219:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d21c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010d223:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d226:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d22c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d22f:	83 c0 0c             	add    $0xc,%eax
f010d232:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d235:	83 c2 0c             	add    $0xc,%edx
f010d238:	c1 ea 10             	shr    $0x10,%edx
f010d23b:	88 d3                	mov    %dl,%bl
f010d23d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d240:	83 c2 0c             	add    $0xc,%edx
f010d243:	c1 ea 18             	shr    $0x18,%edx
f010d246:	88 d1                	mov    %dl,%cl
f010d248:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d24b:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d252:	68 00 
f010d254:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d257:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d25e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d261:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d267:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d26a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d270:	83 e2 f0             	and    $0xfffffff0,%edx
f010d273:	83 ca 09             	or     $0x9,%edx
f010d276:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d27c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d27f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d285:	83 ca 10             	or     $0x10,%edx
f010d288:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d28e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d291:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d297:	83 e2 9f             	and    $0xffffff9f,%edx
f010d29a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d2a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2a3:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d2a9:	83 ca 80             	or     $0xffffff80,%edx
f010d2ac:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d2b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2b5:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d2bb:	83 e2 f0             	and    $0xfffffff0,%edx
f010d2be:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d2c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2c7:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d2cd:	83 e2 ef             	and    $0xffffffef,%edx
f010d2d0:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d2d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2d9:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d2df:	83 e2 df             	and    $0xffffffdf,%edx
f010d2e2:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d2e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2eb:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d2f1:	83 ca 40             	or     $0x40,%edx
f010d2f4:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d2fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2fd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d303:	83 e2 7f             	and    $0x7f,%edx
f010d306:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d30c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d30f:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d315:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d318:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d31e:	83 e2 ef             	and    $0xffffffef,%edx
f010d321:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d327:	e8 20 a2 ff ff       	call   f010754c <popcli>
f010d32c:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d332:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d336:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d339:	90                   	nop
f010d33a:	83 c4 14             	add    $0x14,%esp
f010d33d:	5b                   	pop    %ebx
f010d33e:	5d                   	pop    %ebp
f010d33f:	c3                   	ret    

f010d340 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d340:	55                   	push   %ebp
f010d341:	89 e5                	mov    %esp,%ebp
f010d343:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d346:	b8 ee e7 10 f0       	mov    $0xf010e7ee,%eax
f010d34b:	66 a3 00 66 6f f0    	mov    %ax,0xf06f6600
f010d351:	66 c7 05 02 66 6f f0 	movw   $0x8,0xf06f6602
f010d358:	08 00 
f010d35a:	a0 04 66 6f f0       	mov    0xf06f6604,%al
f010d35f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d362:	a2 04 66 6f f0       	mov    %al,0xf06f6604
f010d367:	a0 04 66 6f f0       	mov    0xf06f6604,%al
f010d36c:	83 e0 1f             	and    $0x1f,%eax
f010d36f:	a2 04 66 6f f0       	mov    %al,0xf06f6604
f010d374:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d379:	83 e0 f0             	and    $0xfffffff0,%eax
f010d37c:	83 c8 0e             	or     $0xe,%eax
f010d37f:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d384:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d389:	83 e0 ef             	and    $0xffffffef,%eax
f010d38c:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d391:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d396:	83 e0 9f             	and    $0xffffff9f,%eax
f010d399:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d39e:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d3a3:	83 c8 80             	or     $0xffffff80,%eax
f010d3a6:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d3ab:	b8 ee e7 10 f0       	mov    $0xf010e7ee,%eax
f010d3b0:	c1 e8 10             	shr    $0x10,%eax
f010d3b3:	66 a3 06 66 6f f0    	mov    %ax,0xf06f6606
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d3b9:	b8 f6 e7 10 f0       	mov    $0xf010e7f6,%eax
f010d3be:	66 a3 30 66 6f f0    	mov    %ax,0xf06f6630
f010d3c4:	66 c7 05 32 66 6f f0 	movw   $0x8,0xf06f6632
f010d3cb:	08 00 
f010d3cd:	a0 34 66 6f f0       	mov    0xf06f6634,%al
f010d3d2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3d5:	a2 34 66 6f f0       	mov    %al,0xf06f6634
f010d3da:	a0 34 66 6f f0       	mov    0xf06f6634,%al
f010d3df:	83 e0 1f             	and    $0x1f,%eax
f010d3e2:	a2 34 66 6f f0       	mov    %al,0xf06f6634
f010d3e7:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d3ec:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3ef:	83 c8 0e             	or     $0xe,%eax
f010d3f2:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d3f7:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d3fc:	83 e0 ef             	and    $0xffffffef,%eax
f010d3ff:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d404:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d409:	83 e0 9f             	and    $0xffffff9f,%eax
f010d40c:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d411:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d416:	83 c8 80             	or     $0xffffff80,%eax
f010d419:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d41e:	b8 f6 e7 10 f0       	mov    $0xf010e7f6,%eax
f010d423:	c1 e8 10             	shr    $0x10,%eax
f010d426:	66 a3 36 66 6f f0    	mov    %ax,0xf06f6636
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d42c:	b8 fe e7 10 f0       	mov    $0xf010e7fe,%eax
f010d431:	66 a3 c0 66 6f f0    	mov    %ax,0xf06f66c0
f010d437:	66 c7 05 c2 66 6f f0 	movw   $0x8,0xf06f66c2
f010d43e:	08 00 
f010d440:	a0 c4 66 6f f0       	mov    0xf06f66c4,%al
f010d445:	83 e0 e0             	and    $0xffffffe0,%eax
f010d448:	a2 c4 66 6f f0       	mov    %al,0xf06f66c4
f010d44d:	a0 c4 66 6f f0       	mov    0xf06f66c4,%al
f010d452:	83 e0 1f             	and    $0x1f,%eax
f010d455:	a2 c4 66 6f f0       	mov    %al,0xf06f66c4
f010d45a:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d45f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d462:	83 c8 0e             	or     $0xe,%eax
f010d465:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d46a:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d46f:	83 e0 ef             	and    $0xffffffef,%eax
f010d472:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d477:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d47c:	83 c8 60             	or     $0x60,%eax
f010d47f:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d484:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d489:	83 c8 80             	or     $0xffffff80,%eax
f010d48c:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d491:	b8 fe e7 10 f0       	mov    $0xf010e7fe,%eax
f010d496:	c1 e8 10             	shr    $0x10,%eax
f010d499:	66 a3 c6 66 6f f0    	mov    %ax,0xf06f66c6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d49f:	b8 08 e8 10 f0       	mov    $0xf010e808,%eax
f010d4a4:	66 a3 c8 66 6f f0    	mov    %ax,0xf06f66c8
f010d4aa:	66 c7 05 ca 66 6f f0 	movw   $0x8,0xf06f66ca
f010d4b1:	08 00 
f010d4b3:	a0 cc 66 6f f0       	mov    0xf06f66cc,%al
f010d4b8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4bb:	a2 cc 66 6f f0       	mov    %al,0xf06f66cc
f010d4c0:	a0 cc 66 6f f0       	mov    0xf06f66cc,%al
f010d4c5:	83 e0 1f             	and    $0x1f,%eax
f010d4c8:	a2 cc 66 6f f0       	mov    %al,0xf06f66cc
f010d4cd:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d4d2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4d5:	83 c8 0e             	or     $0xe,%eax
f010d4d8:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d4dd:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d4e2:	83 e0 ef             	and    $0xffffffef,%eax
f010d4e5:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d4ea:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d4ef:	83 c8 60             	or     $0x60,%eax
f010d4f2:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d4f7:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d4fc:	83 c8 80             	or     $0xffffff80,%eax
f010d4ff:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d504:	b8 08 e8 10 f0       	mov    $0xf010e808,%eax
f010d509:	c1 e8 10             	shr    $0x10,%eax
f010d50c:	66 a3 ce 66 6f f0    	mov    %ax,0xf06f66ce
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d512:	b8 12 e8 10 f0       	mov    $0xf010e812,%eax
f010d517:	66 a3 40 67 6f f0    	mov    %ax,0xf06f6740
f010d51d:	66 c7 05 42 67 6f f0 	movw   $0x8,0xf06f6742
f010d524:	08 00 
f010d526:	a0 44 67 6f f0       	mov    0xf06f6744,%al
f010d52b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d52e:	a2 44 67 6f f0       	mov    %al,0xf06f6744
f010d533:	a0 44 67 6f f0       	mov    0xf06f6744,%al
f010d538:	83 e0 1f             	and    $0x1f,%eax
f010d53b:	a2 44 67 6f f0       	mov    %al,0xf06f6744
f010d540:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d545:	83 e0 f0             	and    $0xfffffff0,%eax
f010d548:	83 c8 0e             	or     $0xe,%eax
f010d54b:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d550:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d555:	83 e0 ef             	and    $0xffffffef,%eax
f010d558:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d55d:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d562:	83 c8 60             	or     $0x60,%eax
f010d565:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d56a:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d56f:	83 c8 80             	or     $0xffffff80,%eax
f010d572:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d577:	b8 12 e8 10 f0       	mov    $0xf010e812,%eax
f010d57c:	c1 e8 10             	shr    $0x10,%eax
f010d57f:	66 a3 46 67 6f f0    	mov    %ax,0xf06f6746

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d585:	b8 1c e8 10 f0       	mov    $0xf010e81c,%eax
f010d58a:	66 a3 c0 65 6f f0    	mov    %ax,0xf06f65c0
f010d590:	66 c7 05 c2 65 6f f0 	movw   $0x8,0xf06f65c2
f010d597:	08 00 
f010d599:	a0 c4 65 6f f0       	mov    0xf06f65c4,%al
f010d59e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5a1:	a2 c4 65 6f f0       	mov    %al,0xf06f65c4
f010d5a6:	a0 c4 65 6f f0       	mov    0xf06f65c4,%al
f010d5ab:	83 e0 1f             	and    $0x1f,%eax
f010d5ae:	a2 c4 65 6f f0       	mov    %al,0xf06f65c4
f010d5b3:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d5b8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5bb:	83 c8 0e             	or     $0xe,%eax
f010d5be:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d5c3:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d5c8:	83 e0 ef             	and    $0xffffffef,%eax
f010d5cb:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d5d0:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d5d5:	83 c8 60             	or     $0x60,%eax
f010d5d8:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d5dd:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d5e2:	83 c8 80             	or     $0xffffff80,%eax
f010d5e5:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d5ea:	b8 1c e8 10 f0       	mov    $0xf010e81c,%eax
f010d5ef:	c1 e8 10             	shr    $0x10,%eax
f010d5f2:	66 a3 c6 65 6f f0    	mov    %ax,0xf06f65c6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d5f8:	b8 26 e8 10 f0       	mov    $0xf010e826,%eax
f010d5fd:	66 a3 c8 65 6f f0    	mov    %ax,0xf06f65c8
f010d603:	66 c7 05 ca 65 6f f0 	movw   $0x8,0xf06f65ca
f010d60a:	08 00 
f010d60c:	a0 cc 65 6f f0       	mov    0xf06f65cc,%al
f010d611:	83 e0 e0             	and    $0xffffffe0,%eax
f010d614:	a2 cc 65 6f f0       	mov    %al,0xf06f65cc
f010d619:	a0 cc 65 6f f0       	mov    0xf06f65cc,%al
f010d61e:	83 e0 1f             	and    $0x1f,%eax
f010d621:	a2 cc 65 6f f0       	mov    %al,0xf06f65cc
f010d626:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d62b:	83 c8 0f             	or     $0xf,%eax
f010d62e:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d633:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d638:	83 e0 ef             	and    $0xffffffef,%eax
f010d63b:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d640:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d645:	83 c8 60             	or     $0x60,%eax
f010d648:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d64d:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d652:	83 c8 80             	or     $0xffffff80,%eax
f010d655:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d65a:	b8 26 e8 10 f0       	mov    $0xf010e826,%eax
f010d65f:	c1 e8 10             	shr    $0x10,%eax
f010d662:	66 a3 ce 65 6f f0    	mov    %ax,0xf06f65ce
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d668:	b8 30 e8 10 f0       	mov    $0xf010e830,%eax
f010d66d:	66 a3 d0 65 6f f0    	mov    %ax,0xf06f65d0
f010d673:	66 c7 05 d2 65 6f f0 	movw   $0x8,0xf06f65d2
f010d67a:	08 00 
f010d67c:	a0 d4 65 6f f0       	mov    0xf06f65d4,%al
f010d681:	83 e0 e0             	and    $0xffffffe0,%eax
f010d684:	a2 d4 65 6f f0       	mov    %al,0xf06f65d4
f010d689:	a0 d4 65 6f f0       	mov    0xf06f65d4,%al
f010d68e:	83 e0 1f             	and    $0x1f,%eax
f010d691:	a2 d4 65 6f f0       	mov    %al,0xf06f65d4
f010d696:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d69b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d69e:	83 c8 0e             	or     $0xe,%eax
f010d6a1:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d6a6:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d6ab:	83 e0 ef             	and    $0xffffffef,%eax
f010d6ae:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d6b3:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d6b8:	83 c8 60             	or     $0x60,%eax
f010d6bb:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d6c0:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d6c5:	83 c8 80             	or     $0xffffff80,%eax
f010d6c8:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d6cd:	b8 30 e8 10 f0       	mov    $0xf010e830,%eax
f010d6d2:	c1 e8 10             	shr    $0x10,%eax
f010d6d5:	66 a3 d6 65 6f f0    	mov    %ax,0xf06f65d6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d6db:	b8 3a e8 10 f0       	mov    $0xf010e83a,%eax
f010d6e0:	66 a3 d8 65 6f f0    	mov    %ax,0xf06f65d8
f010d6e6:	66 c7 05 da 65 6f f0 	movw   $0x8,0xf06f65da
f010d6ed:	08 00 
f010d6ef:	a0 dc 65 6f f0       	mov    0xf06f65dc,%al
f010d6f4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6f7:	a2 dc 65 6f f0       	mov    %al,0xf06f65dc
f010d6fc:	a0 dc 65 6f f0       	mov    0xf06f65dc,%al
f010d701:	83 e0 1f             	and    $0x1f,%eax
f010d704:	a2 dc 65 6f f0       	mov    %al,0xf06f65dc
f010d709:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d70e:	83 c8 0f             	or     $0xf,%eax
f010d711:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d716:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d71b:	83 e0 ef             	and    $0xffffffef,%eax
f010d71e:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d723:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d728:	83 c8 60             	or     $0x60,%eax
f010d72b:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d730:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d735:	83 c8 80             	or     $0xffffff80,%eax
f010d738:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d73d:	b8 3a e8 10 f0       	mov    $0xf010e83a,%eax
f010d742:	c1 e8 10             	shr    $0x10,%eax
f010d745:	66 a3 de 65 6f f0    	mov    %ax,0xf06f65de
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d74b:	b8 44 e8 10 f0       	mov    $0xf010e844,%eax
f010d750:	66 a3 e0 65 6f f0    	mov    %ax,0xf06f65e0
f010d756:	66 c7 05 e2 65 6f f0 	movw   $0x8,0xf06f65e2
f010d75d:	08 00 
f010d75f:	a0 e4 65 6f f0       	mov    0xf06f65e4,%al
f010d764:	83 e0 e0             	and    $0xffffffe0,%eax
f010d767:	a2 e4 65 6f f0       	mov    %al,0xf06f65e4
f010d76c:	a0 e4 65 6f f0       	mov    0xf06f65e4,%al
f010d771:	83 e0 1f             	and    $0x1f,%eax
f010d774:	a2 e4 65 6f f0       	mov    %al,0xf06f65e4
f010d779:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d77e:	83 c8 0f             	or     $0xf,%eax
f010d781:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d786:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d78b:	83 e0 ef             	and    $0xffffffef,%eax
f010d78e:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d793:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d798:	83 c8 60             	or     $0x60,%eax
f010d79b:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d7a0:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d7a5:	83 c8 80             	or     $0xffffff80,%eax
f010d7a8:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d7ad:	b8 44 e8 10 f0       	mov    $0xf010e844,%eax
f010d7b2:	c1 e8 10             	shr    $0x10,%eax
f010d7b5:	66 a3 e6 65 6f f0    	mov    %ax,0xf06f65e6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d7bb:	b8 4e e8 10 f0       	mov    $0xf010e84e,%eax
f010d7c0:	66 a3 e8 65 6f f0    	mov    %ax,0xf06f65e8
f010d7c6:	66 c7 05 ea 65 6f f0 	movw   $0x8,0xf06f65ea
f010d7cd:	08 00 
f010d7cf:	a0 ec 65 6f f0       	mov    0xf06f65ec,%al
f010d7d4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7d7:	a2 ec 65 6f f0       	mov    %al,0xf06f65ec
f010d7dc:	a0 ec 65 6f f0       	mov    0xf06f65ec,%al
f010d7e1:	83 e0 1f             	and    $0x1f,%eax
f010d7e4:	a2 ec 65 6f f0       	mov    %al,0xf06f65ec
f010d7e9:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d7ee:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7f1:	83 c8 0e             	or     $0xe,%eax
f010d7f4:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d7f9:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d7fe:	83 e0 ef             	and    $0xffffffef,%eax
f010d801:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d806:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d80b:	83 c8 60             	or     $0x60,%eax
f010d80e:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d813:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d818:	83 c8 80             	or     $0xffffff80,%eax
f010d81b:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d820:	b8 4e e8 10 f0       	mov    $0xf010e84e,%eax
f010d825:	c1 e8 10             	shr    $0x10,%eax
f010d828:	66 a3 ee 65 6f f0    	mov    %ax,0xf06f65ee
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d82e:	b8 58 e8 10 f0       	mov    $0xf010e858,%eax
f010d833:	66 a3 f0 65 6f f0    	mov    %ax,0xf06f65f0
f010d839:	66 c7 05 f2 65 6f f0 	movw   $0x8,0xf06f65f2
f010d840:	08 00 
f010d842:	a0 f4 65 6f f0       	mov    0xf06f65f4,%al
f010d847:	83 e0 e0             	and    $0xffffffe0,%eax
f010d84a:	a2 f4 65 6f f0       	mov    %al,0xf06f65f4
f010d84f:	a0 f4 65 6f f0       	mov    0xf06f65f4,%al
f010d854:	83 e0 1f             	and    $0x1f,%eax
f010d857:	a2 f4 65 6f f0       	mov    %al,0xf06f65f4
f010d85c:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d861:	83 e0 f0             	and    $0xfffffff0,%eax
f010d864:	83 c8 0e             	or     $0xe,%eax
f010d867:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d86c:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d871:	83 e0 ef             	and    $0xffffffef,%eax
f010d874:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d879:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d87e:	83 c8 60             	or     $0x60,%eax
f010d881:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d886:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d88b:	83 c8 80             	or     $0xffffff80,%eax
f010d88e:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d893:	b8 58 e8 10 f0       	mov    $0xf010e858,%eax
f010d898:	c1 e8 10             	shr    $0x10,%eax
f010d89b:	66 a3 f6 65 6f f0    	mov    %ax,0xf06f65f6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d8a1:	b8 62 e8 10 f0       	mov    $0xf010e862,%eax
f010d8a6:	66 a3 f8 65 6f f0    	mov    %ax,0xf06f65f8
f010d8ac:	66 c7 05 fa 65 6f f0 	movw   $0x8,0xf06f65fa
f010d8b3:	08 00 
f010d8b5:	a0 fc 65 6f f0       	mov    0xf06f65fc,%al
f010d8ba:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8bd:	a2 fc 65 6f f0       	mov    %al,0xf06f65fc
f010d8c2:	a0 fc 65 6f f0       	mov    0xf06f65fc,%al
f010d8c7:	83 e0 1f             	and    $0x1f,%eax
f010d8ca:	a2 fc 65 6f f0       	mov    %al,0xf06f65fc
f010d8cf:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d8d4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8d7:	83 c8 0e             	or     $0xe,%eax
f010d8da:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d8df:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d8e4:	83 e0 ef             	and    $0xffffffef,%eax
f010d8e7:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d8ec:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d8f1:	83 c8 60             	or     $0x60,%eax
f010d8f4:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d8f9:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d8fe:	83 c8 80             	or     $0xffffff80,%eax
f010d901:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d906:	b8 62 e8 10 f0       	mov    $0xf010e862,%eax
f010d90b:	c1 e8 10             	shr    $0x10,%eax
f010d90e:	66 a3 fe 65 6f f0    	mov    %ax,0xf06f65fe
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d914:	b8 68 e8 10 f0       	mov    $0xf010e868,%eax
f010d919:	66 a3 10 66 6f f0    	mov    %ax,0xf06f6610
f010d91f:	66 c7 05 12 66 6f f0 	movw   $0x8,0xf06f6612
f010d926:	08 00 
f010d928:	a0 14 66 6f f0       	mov    0xf06f6614,%al
f010d92d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d930:	a2 14 66 6f f0       	mov    %al,0xf06f6614
f010d935:	a0 14 66 6f f0       	mov    0xf06f6614,%al
f010d93a:	83 e0 1f             	and    $0x1f,%eax
f010d93d:	a2 14 66 6f f0       	mov    %al,0xf06f6614
f010d942:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010d947:	83 e0 f0             	and    $0xfffffff0,%eax
f010d94a:	83 c8 0e             	or     $0xe,%eax
f010d94d:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010d952:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010d957:	83 e0 ef             	and    $0xffffffef,%eax
f010d95a:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010d95f:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010d964:	83 c8 60             	or     $0x60,%eax
f010d967:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010d96c:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010d971:	83 c8 80             	or     $0xffffff80,%eax
f010d974:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010d979:	b8 68 e8 10 f0       	mov    $0xf010e868,%eax
f010d97e:	c1 e8 10             	shr    $0x10,%eax
f010d981:	66 a3 16 66 6f f0    	mov    %ax,0xf06f6616
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d987:	b8 6c e8 10 f0       	mov    $0xf010e86c,%eax
f010d98c:	66 a3 18 66 6f f0    	mov    %ax,0xf06f6618
f010d992:	66 c7 05 1a 66 6f f0 	movw   $0x8,0xf06f661a
f010d999:	08 00 
f010d99b:	a0 1c 66 6f f0       	mov    0xf06f661c,%al
f010d9a0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9a3:	a2 1c 66 6f f0       	mov    %al,0xf06f661c
f010d9a8:	a0 1c 66 6f f0       	mov    0xf06f661c,%al
f010d9ad:	83 e0 1f             	and    $0x1f,%eax
f010d9b0:	a2 1c 66 6f f0       	mov    %al,0xf06f661c
f010d9b5:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010d9ba:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9bd:	83 c8 0e             	or     $0xe,%eax
f010d9c0:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010d9c5:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010d9ca:	83 e0 ef             	and    $0xffffffef,%eax
f010d9cd:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010d9d2:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010d9d7:	83 c8 60             	or     $0x60,%eax
f010d9da:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010d9df:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010d9e4:	83 c8 80             	or     $0xffffff80,%eax
f010d9e7:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010d9ec:	b8 6c e8 10 f0       	mov    $0xf010e86c,%eax
f010d9f1:	c1 e8 10             	shr    $0x10,%eax
f010d9f4:	66 a3 1e 66 6f f0    	mov    %ax,0xf06f661e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d9fa:	b8 70 e8 10 f0       	mov    $0xf010e870,%eax
f010d9ff:	66 a3 20 66 6f f0    	mov    %ax,0xf06f6620
f010da05:	66 c7 05 22 66 6f f0 	movw   $0x8,0xf06f6622
f010da0c:	08 00 
f010da0e:	a0 24 66 6f f0       	mov    0xf06f6624,%al
f010da13:	83 e0 e0             	and    $0xffffffe0,%eax
f010da16:	a2 24 66 6f f0       	mov    %al,0xf06f6624
f010da1b:	a0 24 66 6f f0       	mov    0xf06f6624,%al
f010da20:	83 e0 1f             	and    $0x1f,%eax
f010da23:	a2 24 66 6f f0       	mov    %al,0xf06f6624
f010da28:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010da2d:	83 e0 f0             	and    $0xfffffff0,%eax
f010da30:	83 c8 0e             	or     $0xe,%eax
f010da33:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010da38:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010da3d:	83 e0 ef             	and    $0xffffffef,%eax
f010da40:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010da45:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010da4a:	83 c8 60             	or     $0x60,%eax
f010da4d:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010da52:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010da57:	83 c8 80             	or     $0xffffff80,%eax
f010da5a:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010da5f:	b8 70 e8 10 f0       	mov    $0xf010e870,%eax
f010da64:	c1 e8 10             	shr    $0x10,%eax
f010da67:	66 a3 26 66 6f f0    	mov    %ax,0xf06f6626
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010da6d:	b8 74 e8 10 f0       	mov    $0xf010e874,%eax
f010da72:	66 a3 28 66 6f f0    	mov    %ax,0xf06f6628
f010da78:	66 c7 05 2a 66 6f f0 	movw   $0x8,0xf06f662a
f010da7f:	08 00 
f010da81:	a0 2c 66 6f f0       	mov    0xf06f662c,%al
f010da86:	83 e0 e0             	and    $0xffffffe0,%eax
f010da89:	a2 2c 66 6f f0       	mov    %al,0xf06f662c
f010da8e:	a0 2c 66 6f f0       	mov    0xf06f662c,%al
f010da93:	83 e0 1f             	and    $0x1f,%eax
f010da96:	a2 2c 66 6f f0       	mov    %al,0xf06f662c
f010da9b:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010daa0:	83 e0 f0             	and    $0xfffffff0,%eax
f010daa3:	83 c8 0e             	or     $0xe,%eax
f010daa6:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010daab:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010dab0:	83 e0 ef             	and    $0xffffffef,%eax
f010dab3:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010dab8:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010dabd:	83 c8 60             	or     $0x60,%eax
f010dac0:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010dac5:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010daca:	83 c8 80             	or     $0xffffff80,%eax
f010dacd:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010dad2:	b8 74 e8 10 f0       	mov    $0xf010e874,%eax
f010dad7:	c1 e8 10             	shr    $0x10,%eax
f010dada:	66 a3 2e 66 6f f0    	mov    %ax,0xf06f662e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010dae0:	b8 78 e8 10 f0       	mov    $0xf010e878,%eax
f010dae5:	66 a3 40 66 6f f0    	mov    %ax,0xf06f6640
f010daeb:	66 c7 05 42 66 6f f0 	movw   $0x8,0xf06f6642
f010daf2:	08 00 
f010daf4:	a0 44 66 6f f0       	mov    0xf06f6644,%al
f010daf9:	83 e0 e0             	and    $0xffffffe0,%eax
f010dafc:	a2 44 66 6f f0       	mov    %al,0xf06f6644
f010db01:	a0 44 66 6f f0       	mov    0xf06f6644,%al
f010db06:	83 e0 1f             	and    $0x1f,%eax
f010db09:	a2 44 66 6f f0       	mov    %al,0xf06f6644
f010db0e:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010db13:	83 e0 f0             	and    $0xfffffff0,%eax
f010db16:	83 c8 0e             	or     $0xe,%eax
f010db19:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010db1e:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010db23:	83 e0 ef             	and    $0xffffffef,%eax
f010db26:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010db2b:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010db30:	83 c8 60             	or     $0x60,%eax
f010db33:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010db38:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010db3d:	83 c8 80             	or     $0xffffff80,%eax
f010db40:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010db45:	b8 78 e8 10 f0       	mov    $0xf010e878,%eax
f010db4a:	c1 e8 10             	shr    $0x10,%eax
f010db4d:	66 a3 46 66 6f f0    	mov    %ax,0xf06f6646
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010db53:	b8 7e e8 10 f0       	mov    $0xf010e87e,%eax
f010db58:	66 a3 48 66 6f f0    	mov    %ax,0xf06f6648
f010db5e:	66 c7 05 4a 66 6f f0 	movw   $0x8,0xf06f664a
f010db65:	08 00 
f010db67:	a0 4c 66 6f f0       	mov    0xf06f664c,%al
f010db6c:	83 e0 e0             	and    $0xffffffe0,%eax
f010db6f:	a2 4c 66 6f f0       	mov    %al,0xf06f664c
f010db74:	a0 4c 66 6f f0       	mov    0xf06f664c,%al
f010db79:	83 e0 1f             	and    $0x1f,%eax
f010db7c:	a2 4c 66 6f f0       	mov    %al,0xf06f664c
f010db81:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010db86:	83 e0 f0             	and    $0xfffffff0,%eax
f010db89:	83 c8 0e             	or     $0xe,%eax
f010db8c:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010db91:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010db96:	83 e0 ef             	and    $0xffffffef,%eax
f010db99:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010db9e:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dba3:	83 c8 60             	or     $0x60,%eax
f010dba6:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dbab:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dbb0:	83 c8 80             	or     $0xffffff80,%eax
f010dbb3:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dbb8:	b8 7e e8 10 f0       	mov    $0xf010e87e,%eax
f010dbbd:	c1 e8 10             	shr    $0x10,%eax
f010dbc0:	66 a3 4e 66 6f f0    	mov    %ax,0xf06f664e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010dbc6:	b8 82 e8 10 f0       	mov    $0xf010e882,%eax
f010dbcb:	66 a3 50 66 6f f0    	mov    %ax,0xf06f6650
f010dbd1:	66 c7 05 52 66 6f f0 	movw   $0x8,0xf06f6652
f010dbd8:	08 00 
f010dbda:	a0 54 66 6f f0       	mov    0xf06f6654,%al
f010dbdf:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbe2:	a2 54 66 6f f0       	mov    %al,0xf06f6654
f010dbe7:	a0 54 66 6f f0       	mov    0xf06f6654,%al
f010dbec:	83 e0 1f             	and    $0x1f,%eax
f010dbef:	a2 54 66 6f f0       	mov    %al,0xf06f6654
f010dbf4:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dbf9:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbfc:	83 c8 0e             	or     $0xe,%eax
f010dbff:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dc04:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dc09:	83 e0 ef             	and    $0xffffffef,%eax
f010dc0c:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dc11:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dc16:	83 c8 60             	or     $0x60,%eax
f010dc19:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dc1e:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dc23:	83 c8 80             	or     $0xffffff80,%eax
f010dc26:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dc2b:	b8 82 e8 10 f0       	mov    $0xf010e882,%eax
f010dc30:	c1 e8 10             	shr    $0x10,%eax
f010dc33:	66 a3 56 66 6f f0    	mov    %ax,0xf06f6656
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010dc39:	b8 88 e8 10 f0       	mov    $0xf010e888,%eax
f010dc3e:	66 a3 58 66 6f f0    	mov    %ax,0xf06f6658
f010dc44:	66 c7 05 5a 66 6f f0 	movw   $0x8,0xf06f665a
f010dc4b:	08 00 
f010dc4d:	a0 5c 66 6f f0       	mov    0xf06f665c,%al
f010dc52:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc55:	a2 5c 66 6f f0       	mov    %al,0xf06f665c
f010dc5a:	a0 5c 66 6f f0       	mov    0xf06f665c,%al
f010dc5f:	83 e0 1f             	and    $0x1f,%eax
f010dc62:	a2 5c 66 6f f0       	mov    %al,0xf06f665c
f010dc67:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dc6c:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc6f:	83 c8 0e             	or     $0xe,%eax
f010dc72:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dc77:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dc7c:	83 e0 ef             	and    $0xffffffef,%eax
f010dc7f:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dc84:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dc89:	83 c8 60             	or     $0x60,%eax
f010dc8c:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dc91:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dc96:	83 c8 80             	or     $0xffffff80,%eax
f010dc99:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dc9e:	b8 88 e8 10 f0       	mov    $0xf010e888,%eax
f010dca3:	c1 e8 10             	shr    $0x10,%eax
f010dca6:	66 a3 5e 66 6f f0    	mov    %ax,0xf06f665e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010dcac:	b8 8e e8 10 f0       	mov    $0xf010e88e,%eax
f010dcb1:	66 a3 d0 66 6f f0    	mov    %ax,0xf06f66d0
f010dcb7:	66 c7 05 d2 66 6f f0 	movw   $0x8,0xf06f66d2
f010dcbe:	08 00 
f010dcc0:	a0 d4 66 6f f0       	mov    0xf06f66d4,%al
f010dcc5:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcc8:	a2 d4 66 6f f0       	mov    %al,0xf06f66d4
f010dccd:	a0 d4 66 6f f0       	mov    0xf06f66d4,%al
f010dcd2:	83 e0 1f             	and    $0x1f,%eax
f010dcd5:	a2 d4 66 6f f0       	mov    %al,0xf06f66d4
f010dcda:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dcdf:	83 e0 f0             	and    $0xfffffff0,%eax
f010dce2:	83 c8 0e             	or     $0xe,%eax
f010dce5:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010dcea:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dcef:	83 e0 ef             	and    $0xffffffef,%eax
f010dcf2:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010dcf7:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dcfc:	83 c8 60             	or     $0x60,%eax
f010dcff:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010dd04:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dd09:	83 c8 80             	or     $0xffffff80,%eax
f010dd0c:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010dd11:	b8 8e e8 10 f0       	mov    $0xf010e88e,%eax
f010dd16:	c1 e8 10             	shr    $0x10,%eax
f010dd19:	66 a3 d6 66 6f f0    	mov    %ax,0xf06f66d6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010dd1f:	b8 94 e8 10 f0       	mov    $0xf010e894,%eax
f010dd24:	66 a3 d8 66 6f f0    	mov    %ax,0xf06f66d8
f010dd2a:	66 c7 05 da 66 6f f0 	movw   $0x8,0xf06f66da
f010dd31:	08 00 
f010dd33:	a0 dc 66 6f f0       	mov    0xf06f66dc,%al
f010dd38:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd3b:	a2 dc 66 6f f0       	mov    %al,0xf06f66dc
f010dd40:	a0 dc 66 6f f0       	mov    0xf06f66dc,%al
f010dd45:	83 e0 1f             	and    $0x1f,%eax
f010dd48:	a2 dc 66 6f f0       	mov    %al,0xf06f66dc
f010dd4d:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010dd52:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd55:	83 c8 0e             	or     $0xe,%eax
f010dd58:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010dd5d:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010dd62:	83 e0 ef             	and    $0xffffffef,%eax
f010dd65:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010dd6a:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010dd6f:	83 c8 60             	or     $0x60,%eax
f010dd72:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010dd77:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010dd7c:	83 c8 80             	or     $0xffffff80,%eax
f010dd7f:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010dd84:	b8 94 e8 10 f0       	mov    $0xf010e894,%eax
f010dd89:	c1 e8 10             	shr    $0x10,%eax
f010dd8c:	66 a3 de 66 6f f0    	mov    %ax,0xf06f66de
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010dd92:	b8 9a e8 10 f0       	mov    $0xf010e89a,%eax
f010dd97:	66 a3 e0 66 6f f0    	mov    %ax,0xf06f66e0
f010dd9d:	66 c7 05 e2 66 6f f0 	movw   $0x8,0xf06f66e2
f010dda4:	08 00 
f010dda6:	a0 e4 66 6f f0       	mov    0xf06f66e4,%al
f010ddab:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddae:	a2 e4 66 6f f0       	mov    %al,0xf06f66e4
f010ddb3:	a0 e4 66 6f f0       	mov    0xf06f66e4,%al
f010ddb8:	83 e0 1f             	and    $0x1f,%eax
f010ddbb:	a2 e4 66 6f f0       	mov    %al,0xf06f66e4
f010ddc0:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010ddc5:	83 e0 f0             	and    $0xfffffff0,%eax
f010ddc8:	83 c8 0e             	or     $0xe,%eax
f010ddcb:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010ddd0:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010ddd5:	83 e0 ef             	and    $0xffffffef,%eax
f010ddd8:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010dddd:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010dde2:	83 c8 60             	or     $0x60,%eax
f010dde5:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010ddea:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010ddef:	83 c8 80             	or     $0xffffff80,%eax
f010ddf2:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010ddf7:	b8 9a e8 10 f0       	mov    $0xf010e89a,%eax
f010ddfc:	c1 e8 10             	shr    $0x10,%eax
f010ddff:	66 a3 e6 66 6f f0    	mov    %ax,0xf06f66e6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010de05:	b8 a0 e8 10 f0       	mov    $0xf010e8a0,%eax
f010de0a:	66 a3 e8 66 6f f0    	mov    %ax,0xf06f66e8
f010de10:	66 c7 05 ea 66 6f f0 	movw   $0x8,0xf06f66ea
f010de17:	08 00 
f010de19:	a0 ec 66 6f f0       	mov    0xf06f66ec,%al
f010de1e:	83 e0 e0             	and    $0xffffffe0,%eax
f010de21:	a2 ec 66 6f f0       	mov    %al,0xf06f66ec
f010de26:	a0 ec 66 6f f0       	mov    0xf06f66ec,%al
f010de2b:	83 e0 1f             	and    $0x1f,%eax
f010de2e:	a2 ec 66 6f f0       	mov    %al,0xf06f66ec
f010de33:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010de38:	83 e0 f0             	and    $0xfffffff0,%eax
f010de3b:	83 c8 0e             	or     $0xe,%eax
f010de3e:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010de43:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010de48:	83 e0 ef             	and    $0xffffffef,%eax
f010de4b:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010de50:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010de55:	83 c8 60             	or     $0x60,%eax
f010de58:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010de5d:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010de62:	83 c8 80             	or     $0xffffff80,%eax
f010de65:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010de6a:	b8 a0 e8 10 f0       	mov    $0xf010e8a0,%eax
f010de6f:	c1 e8 10             	shr    $0x10,%eax
f010de72:	66 a3 ee 66 6f f0    	mov    %ax,0xf06f66ee
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010de78:	b8 a6 e8 10 f0       	mov    $0xf010e8a6,%eax
f010de7d:	66 a3 f0 66 6f f0    	mov    %ax,0xf06f66f0
f010de83:	66 c7 05 f2 66 6f f0 	movw   $0x8,0xf06f66f2
f010de8a:	08 00 
f010de8c:	a0 f4 66 6f f0       	mov    0xf06f66f4,%al
f010de91:	83 e0 e0             	and    $0xffffffe0,%eax
f010de94:	a2 f4 66 6f f0       	mov    %al,0xf06f66f4
f010de99:	a0 f4 66 6f f0       	mov    0xf06f66f4,%al
f010de9e:	83 e0 1f             	and    $0x1f,%eax
f010dea1:	a2 f4 66 6f f0       	mov    %al,0xf06f66f4
f010dea6:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010deab:	83 e0 f0             	and    $0xfffffff0,%eax
f010deae:	83 c8 0e             	or     $0xe,%eax
f010deb1:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010deb6:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010debb:	83 e0 ef             	and    $0xffffffef,%eax
f010debe:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010dec3:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010dec8:	83 c8 60             	or     $0x60,%eax
f010decb:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010ded0:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010ded5:	83 c8 80             	or     $0xffffff80,%eax
f010ded8:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010dedd:	b8 a6 e8 10 f0       	mov    $0xf010e8a6,%eax
f010dee2:	c1 e8 10             	shr    $0x10,%eax
f010dee5:	66 a3 f6 66 6f f0    	mov    %ax,0xf06f66f6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010deeb:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010def0:	66 a3 f8 66 6f f0    	mov    %ax,0xf06f66f8
f010def6:	66 c7 05 fa 66 6f f0 	movw   $0x8,0xf06f66fa
f010defd:	08 00 
f010deff:	a0 fc 66 6f f0       	mov    0xf06f66fc,%al
f010df04:	83 e0 e0             	and    $0xffffffe0,%eax
f010df07:	a2 fc 66 6f f0       	mov    %al,0xf06f66fc
f010df0c:	a0 fc 66 6f f0       	mov    0xf06f66fc,%al
f010df11:	83 e0 1f             	and    $0x1f,%eax
f010df14:	a2 fc 66 6f f0       	mov    %al,0xf06f66fc
f010df19:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010df1e:	83 e0 f0             	and    $0xfffffff0,%eax
f010df21:	83 c8 0e             	or     $0xe,%eax
f010df24:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010df29:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010df2e:	83 e0 ef             	and    $0xffffffef,%eax
f010df31:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010df36:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010df3b:	83 c8 60             	or     $0x60,%eax
f010df3e:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010df43:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010df48:	83 c8 80             	or     $0xffffff80,%eax
f010df4b:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010df50:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010df55:	c1 e8 10             	shr    $0x10,%eax
f010df58:	66 a3 fe 66 6f f0    	mov    %ax,0xf06f66fe
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010df5e:	b8 b2 e8 10 f0       	mov    $0xf010e8b2,%eax
f010df63:	66 a3 00 67 6f f0    	mov    %ax,0xf06f6700
f010df69:	66 c7 05 02 67 6f f0 	movw   $0x8,0xf06f6702
f010df70:	08 00 
f010df72:	a0 04 67 6f f0       	mov    0xf06f6704,%al
f010df77:	83 e0 e0             	and    $0xffffffe0,%eax
f010df7a:	a2 04 67 6f f0       	mov    %al,0xf06f6704
f010df7f:	a0 04 67 6f f0       	mov    0xf06f6704,%al
f010df84:	83 e0 1f             	and    $0x1f,%eax
f010df87:	a2 04 67 6f f0       	mov    %al,0xf06f6704
f010df8c:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010df91:	83 e0 f0             	and    $0xfffffff0,%eax
f010df94:	83 c8 0e             	or     $0xe,%eax
f010df97:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010df9c:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010dfa1:	83 e0 ef             	and    $0xffffffef,%eax
f010dfa4:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010dfa9:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010dfae:	83 c8 60             	or     $0x60,%eax
f010dfb1:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010dfb6:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010dfbb:	83 c8 80             	or     $0xffffff80,%eax
f010dfbe:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010dfc3:	b8 b2 e8 10 f0       	mov    $0xf010e8b2,%eax
f010dfc8:	c1 e8 10             	shr    $0x10,%eax
f010dfcb:	66 a3 06 67 6f f0    	mov    %ax,0xf06f6706
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dfd1:	b8 b8 e8 10 f0       	mov    $0xf010e8b8,%eax
f010dfd6:	66 a3 08 67 6f f0    	mov    %ax,0xf06f6708
f010dfdc:	66 c7 05 0a 67 6f f0 	movw   $0x8,0xf06f670a
f010dfe3:	08 00 
f010dfe5:	a0 0c 67 6f f0       	mov    0xf06f670c,%al
f010dfea:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfed:	a2 0c 67 6f f0       	mov    %al,0xf06f670c
f010dff2:	a0 0c 67 6f f0       	mov    0xf06f670c,%al
f010dff7:	83 e0 1f             	and    $0x1f,%eax
f010dffa:	a2 0c 67 6f f0       	mov    %al,0xf06f670c
f010dfff:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e004:	83 e0 f0             	and    $0xfffffff0,%eax
f010e007:	83 c8 0e             	or     $0xe,%eax
f010e00a:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e00f:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e014:	83 e0 ef             	and    $0xffffffef,%eax
f010e017:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e01c:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e021:	83 c8 60             	or     $0x60,%eax
f010e024:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e029:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e02e:	83 c8 80             	or     $0xffffff80,%eax
f010e031:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e036:	b8 b8 e8 10 f0       	mov    $0xf010e8b8,%eax
f010e03b:	c1 e8 10             	shr    $0x10,%eax
f010e03e:	66 a3 0e 67 6f f0    	mov    %ax,0xf06f670e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010e044:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010e049:	66 a3 10 67 6f f0    	mov    %ax,0xf06f6710
f010e04f:	66 c7 05 12 67 6f f0 	movw   $0x8,0xf06f6712
f010e056:	08 00 
f010e058:	a0 14 67 6f f0       	mov    0xf06f6714,%al
f010e05d:	83 e0 e0             	and    $0xffffffe0,%eax
f010e060:	a2 14 67 6f f0       	mov    %al,0xf06f6714
f010e065:	a0 14 67 6f f0       	mov    0xf06f6714,%al
f010e06a:	83 e0 1f             	and    $0x1f,%eax
f010e06d:	a2 14 67 6f f0       	mov    %al,0xf06f6714
f010e072:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e077:	83 e0 f0             	and    $0xfffffff0,%eax
f010e07a:	83 c8 0e             	or     $0xe,%eax
f010e07d:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e082:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e087:	83 e0 ef             	and    $0xffffffef,%eax
f010e08a:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e08f:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e094:	83 c8 60             	or     $0x60,%eax
f010e097:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e09c:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e0a1:	83 c8 80             	or     $0xffffff80,%eax
f010e0a4:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e0a9:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010e0ae:	c1 e8 10             	shr    $0x10,%eax
f010e0b1:	66 a3 16 67 6f f0    	mov    %ax,0xf06f6716
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010e0b7:	b8 c4 e8 10 f0       	mov    $0xf010e8c4,%eax
f010e0bc:	66 a3 18 67 6f f0    	mov    %ax,0xf06f6718
f010e0c2:	66 c7 05 1a 67 6f f0 	movw   $0x8,0xf06f671a
f010e0c9:	08 00 
f010e0cb:	a0 1c 67 6f f0       	mov    0xf06f671c,%al
f010e0d0:	83 e0 e0             	and    $0xffffffe0,%eax
f010e0d3:	a2 1c 67 6f f0       	mov    %al,0xf06f671c
f010e0d8:	a0 1c 67 6f f0       	mov    0xf06f671c,%al
f010e0dd:	83 e0 1f             	and    $0x1f,%eax
f010e0e0:	a2 1c 67 6f f0       	mov    %al,0xf06f671c
f010e0e5:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e0ea:	83 e0 f0             	and    $0xfffffff0,%eax
f010e0ed:	83 c8 0e             	or     $0xe,%eax
f010e0f0:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e0f5:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e0fa:	83 e0 ef             	and    $0xffffffef,%eax
f010e0fd:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e102:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e107:	83 c8 60             	or     $0x60,%eax
f010e10a:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e10f:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e114:	83 c8 80             	or     $0xffffff80,%eax
f010e117:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e11c:	b8 c4 e8 10 f0       	mov    $0xf010e8c4,%eax
f010e121:	c1 e8 10             	shr    $0x10,%eax
f010e124:	66 a3 1e 67 6f f0    	mov    %ax,0xf06f671e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010e12a:	b8 ca e8 10 f0       	mov    $0xf010e8ca,%eax
f010e12f:	66 a3 20 67 6f f0    	mov    %ax,0xf06f6720
f010e135:	66 c7 05 22 67 6f f0 	movw   $0x8,0xf06f6722
f010e13c:	08 00 
f010e13e:	a0 24 67 6f f0       	mov    0xf06f6724,%al
f010e143:	83 e0 e0             	and    $0xffffffe0,%eax
f010e146:	a2 24 67 6f f0       	mov    %al,0xf06f6724
f010e14b:	a0 24 67 6f f0       	mov    0xf06f6724,%al
f010e150:	83 e0 1f             	and    $0x1f,%eax
f010e153:	a2 24 67 6f f0       	mov    %al,0xf06f6724
f010e158:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e15d:	83 e0 f0             	and    $0xfffffff0,%eax
f010e160:	83 c8 0e             	or     $0xe,%eax
f010e163:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e168:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e16d:	83 e0 ef             	and    $0xffffffef,%eax
f010e170:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e175:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e17a:	83 c8 60             	or     $0x60,%eax
f010e17d:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e182:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e187:	83 c8 80             	or     $0xffffff80,%eax
f010e18a:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e18f:	b8 ca e8 10 f0       	mov    $0xf010e8ca,%eax
f010e194:	c1 e8 10             	shr    $0x10,%eax
f010e197:	66 a3 26 67 6f f0    	mov    %ax,0xf06f6726
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010e19d:	b8 d0 e8 10 f0       	mov    $0xf010e8d0,%eax
f010e1a2:	66 a3 28 67 6f f0    	mov    %ax,0xf06f6728
f010e1a8:	66 c7 05 2a 67 6f f0 	movw   $0x8,0xf06f672a
f010e1af:	08 00 
f010e1b1:	a0 2c 67 6f f0       	mov    0xf06f672c,%al
f010e1b6:	83 e0 e0             	and    $0xffffffe0,%eax
f010e1b9:	a2 2c 67 6f f0       	mov    %al,0xf06f672c
f010e1be:	a0 2c 67 6f f0       	mov    0xf06f672c,%al
f010e1c3:	83 e0 1f             	and    $0x1f,%eax
f010e1c6:	a2 2c 67 6f f0       	mov    %al,0xf06f672c
f010e1cb:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e1d0:	83 e0 f0             	and    $0xfffffff0,%eax
f010e1d3:	83 c8 0e             	or     $0xe,%eax
f010e1d6:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e1db:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e1e0:	83 e0 ef             	and    $0xffffffef,%eax
f010e1e3:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e1e8:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e1ed:	83 c8 60             	or     $0x60,%eax
f010e1f0:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e1f5:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e1fa:	83 c8 80             	or     $0xffffff80,%eax
f010e1fd:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e202:	b8 d0 e8 10 f0       	mov    $0xf010e8d0,%eax
f010e207:	c1 e8 10             	shr    $0x10,%eax
f010e20a:	66 a3 2e 67 6f f0    	mov    %ax,0xf06f672e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010e210:	b8 d6 e8 10 f0       	mov    $0xf010e8d6,%eax
f010e215:	66 a3 30 67 6f f0    	mov    %ax,0xf06f6730
f010e21b:	66 c7 05 32 67 6f f0 	movw   $0x8,0xf06f6732
f010e222:	08 00 
f010e224:	a0 34 67 6f f0       	mov    0xf06f6734,%al
f010e229:	83 e0 e0             	and    $0xffffffe0,%eax
f010e22c:	a2 34 67 6f f0       	mov    %al,0xf06f6734
f010e231:	a0 34 67 6f f0       	mov    0xf06f6734,%al
f010e236:	83 e0 1f             	and    $0x1f,%eax
f010e239:	a2 34 67 6f f0       	mov    %al,0xf06f6734
f010e23e:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e243:	83 e0 f0             	and    $0xfffffff0,%eax
f010e246:	83 c8 0e             	or     $0xe,%eax
f010e249:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e24e:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e253:	83 e0 ef             	and    $0xffffffef,%eax
f010e256:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e25b:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e260:	83 c8 60             	or     $0x60,%eax
f010e263:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e268:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e26d:	83 c8 80             	or     $0xffffff80,%eax
f010e270:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e275:	b8 d6 e8 10 f0       	mov    $0xf010e8d6,%eax
f010e27a:	c1 e8 10             	shr    $0x10,%eax
f010e27d:	66 a3 36 67 6f f0    	mov    %ax,0xf06f6736
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e283:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010e288:	66 a3 38 67 6f f0    	mov    %ax,0xf06f6738
f010e28e:	66 c7 05 3a 67 6f f0 	movw   $0x8,0xf06f673a
f010e295:	08 00 
f010e297:	a0 3c 67 6f f0       	mov    0xf06f673c,%al
f010e29c:	83 e0 e0             	and    $0xffffffe0,%eax
f010e29f:	a2 3c 67 6f f0       	mov    %al,0xf06f673c
f010e2a4:	a0 3c 67 6f f0       	mov    0xf06f673c,%al
f010e2a9:	83 e0 1f             	and    $0x1f,%eax
f010e2ac:	a2 3c 67 6f f0       	mov    %al,0xf06f673c
f010e2b1:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e2b6:	83 e0 f0             	and    $0xfffffff0,%eax
f010e2b9:	83 c8 0e             	or     $0xe,%eax
f010e2bc:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e2c1:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e2c6:	83 e0 ef             	and    $0xffffffef,%eax
f010e2c9:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e2ce:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e2d3:	83 c8 60             	or     $0x60,%eax
f010e2d6:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e2db:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e2e0:	83 c8 80             	or     $0xffffff80,%eax
f010e2e3:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e2e8:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010e2ed:	c1 e8 10             	shr    $0x10,%eax
f010e2f0:	66 a3 3e 67 6f f0    	mov    %ax,0xf06f673e
f010e2f6:	c7 45 fc c0 65 6f f0 	movl   $0xf06f65c0,-0x4(%ebp)
f010e2fd:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e304:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e307:	48                   	dec    %eax
f010e308:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e30c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e30f:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e313:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e316:	c1 e8 10             	shr    $0x10,%eax
f010e319:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e31d:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e320:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e323:	90                   	nop
f010e324:	c9                   	leave  
f010e325:	c3                   	ret    

f010e326 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e326:	55                   	push   %ebp
f010e327:	89 e5                	mov    %esp,%ebp
f010e329:	53                   	push   %ebx
f010e32a:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e32d:	83 ec 08             	sub    $0x8,%esp
f010e330:	ff 75 08             	pushl  0x8(%ebp)
f010e333:	68 be 78 12 f0       	push   $0xf01278be
f010e338:	e8 4e 2c ff ff       	call   f0100f8b <cprintf>
f010e33d:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e340:	8b 45 08             	mov    0x8(%ebp),%eax
f010e343:	83 ec 0c             	sub    $0xc,%esp
f010e346:	50                   	push   %eax
f010e347:	e8 fd 00 00 00       	call   f010e449 <print_regs>
f010e34c:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e34f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e352:	8b 40 20             	mov    0x20(%eax),%eax
f010e355:	0f b7 c0             	movzwl %ax,%eax
f010e358:	83 ec 08             	sub    $0x8,%esp
f010e35b:	50                   	push   %eax
f010e35c:	68 d0 78 12 f0       	push   $0xf01278d0
f010e361:	e8 25 2c ff ff       	call   f0100f8b <cprintf>
f010e366:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e369:	8b 45 08             	mov    0x8(%ebp),%eax
f010e36c:	8b 40 24             	mov    0x24(%eax),%eax
f010e36f:	0f b7 c0             	movzwl %ax,%eax
f010e372:	83 ec 08             	sub    $0x8,%esp
f010e375:	50                   	push   %eax
f010e376:	68 e3 78 12 f0       	push   $0xf01278e3
f010e37b:	e8 0b 2c ff ff       	call   f0100f8b <cprintf>
f010e380:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e383:	8b 45 08             	mov    0x8(%ebp),%eax
f010e386:	8b 58 28             	mov    0x28(%eax),%ebx
f010e389:	8b 45 08             	mov    0x8(%ebp),%eax
f010e38c:	8b 40 28             	mov    0x28(%eax),%eax
f010e38f:	83 ec 0c             	sub    $0xc,%esp
f010e392:	50                   	push   %eax
f010e393:	e8 28 ee ff ff       	call   f010d1c0 <trapname>
f010e398:	83 c4 10             	add    $0x10,%esp
f010e39b:	89 c2                	mov    %eax,%edx
f010e39d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a0:	8b 40 28             	mov    0x28(%eax),%eax
f010e3a3:	53                   	push   %ebx
f010e3a4:	52                   	push   %edx
f010e3a5:	50                   	push   %eax
f010e3a6:	68 f6 78 12 f0       	push   $0xf01278f6
f010e3ab:	e8 db 2b ff ff       	call   f0100f8b <cprintf>
f010e3b0:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e3b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3b6:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e3b9:	83 ec 08             	sub    $0x8,%esp
f010e3bc:	50                   	push   %eax
f010e3bd:	68 0d 79 12 f0       	push   $0xf012790d
f010e3c2:	e8 c4 2b ff ff       	call   f0100f8b <cprintf>
f010e3c7:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e3ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3cd:	8b 40 30             	mov    0x30(%eax),%eax
f010e3d0:	83 ec 08             	sub    $0x8,%esp
f010e3d3:	50                   	push   %eax
f010e3d4:	68 1c 79 12 f0       	push   $0xf012791c
f010e3d9:	e8 ad 2b ff ff       	call   f0100f8b <cprintf>
f010e3de:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e3e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3e4:	8b 40 34             	mov    0x34(%eax),%eax
f010e3e7:	0f b7 c0             	movzwl %ax,%eax
f010e3ea:	83 ec 08             	sub    $0x8,%esp
f010e3ed:	50                   	push   %eax
f010e3ee:	68 2b 79 12 f0       	push   $0xf012792b
f010e3f3:	e8 93 2b ff ff       	call   f0100f8b <cprintf>
f010e3f8:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e3fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3fe:	8b 40 38             	mov    0x38(%eax),%eax
f010e401:	83 ec 08             	sub    $0x8,%esp
f010e404:	50                   	push   %eax
f010e405:	68 3e 79 12 f0       	push   $0xf012793e
f010e40a:	e8 7c 2b ff ff       	call   f0100f8b <cprintf>
f010e40f:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e412:	8b 45 08             	mov    0x8(%ebp),%eax
f010e415:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e418:	83 ec 08             	sub    $0x8,%esp
f010e41b:	50                   	push   %eax
f010e41c:	68 4d 79 12 f0       	push   $0xf012794d
f010e421:	e8 65 2b ff ff       	call   f0100f8b <cprintf>
f010e426:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e429:	8b 45 08             	mov    0x8(%ebp),%eax
f010e42c:	8b 40 40             	mov    0x40(%eax),%eax
f010e42f:	0f b7 c0             	movzwl %ax,%eax
f010e432:	83 ec 08             	sub    $0x8,%esp
f010e435:	50                   	push   %eax
f010e436:	68 5c 79 12 f0       	push   $0xf012795c
f010e43b:	e8 4b 2b ff ff       	call   f0100f8b <cprintf>
f010e440:	83 c4 10             	add    $0x10,%esp
}
f010e443:	90                   	nop
f010e444:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e447:	c9                   	leave  
f010e448:	c3                   	ret    

f010e449 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e449:	55                   	push   %ebp
f010e44a:	89 e5                	mov    %esp,%ebp
f010e44c:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e44f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e452:	8b 00                	mov    (%eax),%eax
f010e454:	83 ec 08             	sub    $0x8,%esp
f010e457:	50                   	push   %eax
f010e458:	68 6f 79 12 f0       	push   $0xf012796f
f010e45d:	e8 29 2b ff ff       	call   f0100f8b <cprintf>
f010e462:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e465:	8b 45 08             	mov    0x8(%ebp),%eax
f010e468:	8b 40 04             	mov    0x4(%eax),%eax
f010e46b:	83 ec 08             	sub    $0x8,%esp
f010e46e:	50                   	push   %eax
f010e46f:	68 7e 79 12 f0       	push   $0xf012797e
f010e474:	e8 12 2b ff ff       	call   f0100f8b <cprintf>
f010e479:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e47c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e47f:	8b 40 08             	mov    0x8(%eax),%eax
f010e482:	83 ec 08             	sub    $0x8,%esp
f010e485:	50                   	push   %eax
f010e486:	68 8d 79 12 f0       	push   $0xf012798d
f010e48b:	e8 fb 2a ff ff       	call   f0100f8b <cprintf>
f010e490:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e493:	8b 45 08             	mov    0x8(%ebp),%eax
f010e496:	8b 40 0c             	mov    0xc(%eax),%eax
f010e499:	83 ec 08             	sub    $0x8,%esp
f010e49c:	50                   	push   %eax
f010e49d:	68 9c 79 12 f0       	push   $0xf012799c
f010e4a2:	e8 e4 2a ff ff       	call   f0100f8b <cprintf>
f010e4a7:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e4aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ad:	8b 40 10             	mov    0x10(%eax),%eax
f010e4b0:	83 ec 08             	sub    $0x8,%esp
f010e4b3:	50                   	push   %eax
f010e4b4:	68 ab 79 12 f0       	push   $0xf01279ab
f010e4b9:	e8 cd 2a ff ff       	call   f0100f8b <cprintf>
f010e4be:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e4c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4c4:	8b 40 14             	mov    0x14(%eax),%eax
f010e4c7:	83 ec 08             	sub    $0x8,%esp
f010e4ca:	50                   	push   %eax
f010e4cb:	68 ba 79 12 f0       	push   $0xf01279ba
f010e4d0:	e8 b6 2a ff ff       	call   f0100f8b <cprintf>
f010e4d5:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e4d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4db:	8b 40 18             	mov    0x18(%eax),%eax
f010e4de:	83 ec 08             	sub    $0x8,%esp
f010e4e1:	50                   	push   %eax
f010e4e2:	68 c9 79 12 f0       	push   $0xf01279c9
f010e4e7:	e8 9f 2a ff ff       	call   f0100f8b <cprintf>
f010e4ec:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e4ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4f2:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e4f5:	83 ec 08             	sub    $0x8,%esp
f010e4f8:	50                   	push   %eax
f010e4f9:	68 d8 79 12 f0       	push   $0xf01279d8
f010e4fe:	e8 88 2a ff ff       	call   f0100f8b <cprintf>
f010e503:	83 c4 10             	add    $0x10,%esp
}
f010e506:	90                   	nop
f010e507:	c9                   	leave  
f010e508:	c3                   	ret    

f010e509 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e509:	55                   	push   %ebp
f010e50a:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e50c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e50f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e512:	89 14 85 c0 6d 6f f0 	mov    %edx,-0xf909240(,%eax,4)
}
f010e519:	90                   	nop
f010e51a:	5d                   	pop    %ebp
f010e51b:	c3                   	ret    

f010e51c <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e51c:	55                   	push   %ebp
f010e51d:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e51f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e522:	c7 04 85 c0 6d 6f f0 	movl   $0x0,-0xf909240(,%eax,4)
f010e529:	00 00 00 00 
}
f010e52d:	90                   	nop
f010e52e:	5d                   	pop    %ebp
f010e52f:	c3                   	ret    

f010e530 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e530:	55                   	push   %ebp
f010e531:	89 e5                	mov    %esp,%ebp
f010e533:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e536:	8b 45 08             	mov    0x8(%ebp),%eax
f010e539:	8b 40 28             	mov    0x28(%eax),%eax
f010e53c:	83 e8 20             	sub    $0x20,%eax
f010e53f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e542:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e545:	8b 04 85 c0 6d 6f f0 	mov    -0xf909240(,%eax,4),%eax
f010e54c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e54f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e553:	74 0e                	je     f010e563 <irq_dispatch+0x33>
	{
		handler(tf);
f010e555:	83 ec 0c             	sub    $0xc,%esp
f010e558:	ff 75 08             	pushl  0x8(%ebp)
f010e55b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e55e:	ff d0                	call   *%eax
f010e560:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e563:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e566:	0f b6 c0             	movzbl %al,%eax
f010e569:	83 ec 0c             	sub    $0xc,%esp
f010e56c:	50                   	push   %eax
f010e56d:	e8 8c 8e ff ff       	call   f01073fe <pic_sendEOI>
f010e572:	83 c4 10             	add    $0x10,%esp
}
f010e575:	90                   	nop
f010e576:	c9                   	leave  
f010e577:	c3                   	ret    

f010e578 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e578:	55                   	push   %ebp
f010e579:	89 e5                	mov    %esp,%ebp
f010e57b:	57                   	push   %edi
f010e57c:	56                   	push   %esi
f010e57d:	53                   	push   %ebx
f010e57e:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e581:	8b 45 08             	mov    0x8(%ebp),%eax
f010e584:	8b 40 28             	mov    0x28(%eax),%eax
f010e587:	83 f8 0e             	cmp    $0xe,%eax
f010e58a:	75 51                	jne    f010e5dd <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e58c:	a0 00 6e 6f f0       	mov    0xf06f6e00,%al
f010e591:	84 c0                	test   %al,%al
f010e593:	74 1f                	je     f010e5b4 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e595:	8b 45 08             	mov    0x8(%ebp),%eax
f010e598:	8b 40 30             	mov    0x30(%eax),%eax
f010e59b:	89 c2                	mov    %eax,%edx
f010e59d:	a0 00 6e 6f f0       	mov    0xf06f6e00,%al
f010e5a2:	0f b6 c0             	movzbl %al,%eax
f010e5a5:	01 d0                	add    %edx,%eax
f010e5a7:	89 c2                	mov    %eax,%edx
f010e5a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5ac:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e5af:	e9 0c 01 00 00       	jmp    f010e6c0 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e5b4:	83 ec 0c             	sub    $0xc,%esp
f010e5b7:	6a 01                	push   $0x1
f010e5b9:	e8 ed 12 00 00       	call   f010f8ab <isPageReplacmentAlgorithmLRU>
f010e5be:	83 c4 10             	add    $0x10,%esp
f010e5c1:	85 c0                	test   %eax,%eax
f010e5c3:	74 05                	je     f010e5ca <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e5c5:	e8 a3 89 ff ff       	call   f0106f6d <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e5ca:	83 ec 0c             	sub    $0xc,%esp
f010e5cd:	ff 75 08             	pushl  0x8(%ebp)
f010e5d0:	e8 bb 13 00 00       	call   f010f990 <fault_handler>
f010e5d5:	83 c4 10             	add    $0x10,%esp
f010e5d8:	e9 e3 00 00 00       	jmp    f010e6c0 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e5dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5e0:	8b 40 28             	mov    0x28(%eax),%eax
f010e5e3:	83 f8 30             	cmp    $0x30,%eax
f010e5e6:	75 6e                	jne    f010e656 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e5e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5eb:	8b 40 38             	mov    0x38(%eax),%eax
f010e5ee:	25 00 02 00 00       	and    $0x200,%eax
f010e5f3:	85 c0                	test   %eax,%eax
f010e5f5:	74 06                	je     f010e5fd <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e5f7:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e5f8:	e8 d3 68 ff ff       	call   f0104ed0 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e5fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e600:	8b 78 04             	mov    0x4(%eax),%edi
f010e603:	8b 45 08             	mov    0x8(%ebp),%eax
f010e606:	8b 30                	mov    (%eax),%esi
f010e608:	8b 45 08             	mov    0x8(%ebp),%eax
f010e60b:	8b 58 10             	mov    0x10(%eax),%ebx
f010e60e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e611:	8b 48 18             	mov    0x18(%eax),%ecx
f010e614:	8b 45 08             	mov    0x8(%ebp),%eax
f010e617:	8b 50 14             	mov    0x14(%eax),%edx
f010e61a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e61d:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e620:	83 ec 08             	sub    $0x8,%esp
f010e623:	57                   	push   %edi
f010e624:	56                   	push   %esi
f010e625:	53                   	push   %ebx
f010e626:	51                   	push   %ecx
f010e627:	52                   	push   %edx
f010e628:	50                   	push   %eax
f010e629:	e8 a4 09 00 00       	call   f010efd2 <syscall>
f010e62e:	83 c4 20             	add    $0x20,%esp
f010e631:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e634:	8b 45 08             	mov    0x8(%ebp),%eax
f010e637:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e63a:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e63d:	9c                   	pushf  
f010e63e:	58                   	pop    %eax
f010e63f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e642:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e645:	25 00 02 00 00       	and    $0x200,%eax
f010e64a:	85 c0                	test   %eax,%eax
f010e64c:	74 72                	je     f010e6c0 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e64e:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e64f:	e8 54 68 ff ff       	call   f0104ea8 <kclock_stop>
f010e654:	eb 6a                	jmp    f010e6c0 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e656:	8b 45 08             	mov    0x8(%ebp),%eax
f010e659:	8b 40 28             	mov    0x28(%eax),%eax
f010e65c:	83 f8 08             	cmp    $0x8,%eax
f010e65f:	75 17                	jne    f010e678 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e661:	83 ec 04             	sub    $0x4,%esp
f010e664:	68 e7 79 12 f0       	push   $0xf01279e7
f010e669:	68 22 01 00 00       	push   $0x122
f010e66e:	68 f6 79 12 f0       	push   $0xf01279f6
f010e673:	e8 c1 1c ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e678:	83 ec 0c             	sub    $0xc,%esp
f010e67b:	ff 75 08             	pushl  0x8(%ebp)
f010e67e:	e8 a3 fc ff ff       	call   f010e326 <print_trapframe>
f010e683:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e686:	8b 45 08             	mov    0x8(%ebp),%eax
f010e689:	8b 40 34             	mov    0x34(%eax),%eax
f010e68c:	66 83 f8 08          	cmp    $0x8,%ax
f010e690:	75 17                	jne    f010e6a9 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e692:	83 ec 04             	sub    $0x4,%esp
f010e695:	68 07 7a 12 f0       	push   $0xf0127a07
f010e69a:	68 2a 01 00 00       	push   $0x12a
f010e69f:	68 f6 79 12 f0       	push   $0xf01279f6
f010e6a4:	e8 90 1c ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e6a9:	83 ec 04             	sub    $0x4,%esp
f010e6ac:	68 20 7a 12 f0       	push   $0xf0127a20
f010e6b1:	68 2f 01 00 00       	push   $0x12f
f010e6b6:	68 f6 79 12 f0       	push   $0xf01279f6
f010e6bb:	e8 79 1c ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e6c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e6c3:	5b                   	pop    %ebx
f010e6c4:	5e                   	pop    %esi
f010e6c5:	5f                   	pop    %edi
f010e6c6:	5d                   	pop    %ebp
f010e6c7:	c3                   	ret    

f010e6c8 <trap>:

void trap(struct Trapframe *tf)
{
f010e6c8:	55                   	push   %ebp
f010e6c9:	89 e5                	mov    %esp,%ebp
f010e6cb:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e6ce:	e8 d5 67 ff ff       	call   f0104ea8 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e6d3:	9c                   	pushf  
f010e6d4:	58                   	pop    %eax
f010e6d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e6d8:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e6db:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e6de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e6e1:	25 00 02 00 00       	and    $0x200,%eax
f010e6e6:	85 c0                	test   %eax,%eax
f010e6e8:	74 25                	je     f010e70f <trap+0x47>
	{
		print_trapframe(tf);
f010e6ea:	83 ec 0c             	sub    $0xc,%esp
f010e6ed:	ff 75 08             	pushl  0x8(%ebp)
f010e6f0:	e8 31 fc ff ff       	call   f010e326 <print_trapframe>
f010e6f5:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e6f8:	83 ec 04             	sub    $0x4,%esp
f010e6fb:	68 40 7a 12 f0       	push   $0xf0127a40
f010e700:	68 45 01 00 00       	push   $0x145
f010e705:	68 f6 79 12 f0       	push   $0xf01279f6
f010e70a:	e8 2a 1c ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e70f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e716:	e8 55 d5 ff ff       	call   f010bc70 <get_cpu_proc>
f010e71b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e71e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e721:	8b 40 34             	mov    0x34(%eax),%eax
f010e724:	0f b7 c0             	movzwl %ax,%eax
f010e727:	83 e0 03             	and    $0x3,%eax
f010e72a:	83 f8 03             	cmp    $0x3,%eax
f010e72d:	75 54                	jne    f010e783 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e72f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e733:	74 0b                	je     f010e740 <trap+0x78>
f010e735:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e738:	8b 40 18             	mov    0x18(%eax),%eax
f010e73b:	83 f8 02             	cmp    $0x2,%eax
f010e73e:	74 19                	je     f010e759 <trap+0x91>
f010e740:	68 84 7a 12 f0       	push   $0xf0127a84
f010e745:	68 b2 7a 12 f0       	push   $0xf0127ab2
f010e74a:	68 4d 01 00 00       	push   $0x14d
f010e74f:	68 f6 79 12 f0       	push   $0xf01279f6
f010e754:	e8 e0 1b ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e759:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e75c:	8b 00                	mov    (%eax),%eax
f010e75e:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e761:	74 19                	je     f010e77c <trap+0xb4>
f010e763:	68 c7 7a 12 f0       	push   $0xf0127ac7
f010e768:	68 b2 7a 12 f0       	push   $0xf0127ab2
f010e76d:	68 4f 01 00 00       	push   $0x14f
f010e772:	68 f6 79 12 f0       	push   $0xf01279f6
f010e777:	e8 bd 1b ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e77c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e783:	8b 45 08             	mov    0x8(%ebp),%eax
f010e786:	8b 40 28             	mov    0x28(%eax),%eax
f010e789:	83 f8 1f             	cmp    $0x1f,%eax
f010e78c:	76 1b                	jbe    f010e7a9 <trap+0xe1>
f010e78e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e791:	8b 40 28             	mov    0x28(%eax),%eax
f010e794:	83 f8 2f             	cmp    $0x2f,%eax
f010e797:	77 10                	ja     f010e7a9 <trap+0xe1>
	{
		irq_dispatch(tf);
f010e799:	83 ec 0c             	sub    $0xc,%esp
f010e79c:	ff 75 08             	pushl  0x8(%ebp)
f010e79f:	e8 8c fd ff ff       	call   f010e530 <irq_dispatch>
f010e7a4:	83 c4 10             	add    $0x10,%esp
f010e7a7:	eb 0e                	jmp    f010e7b7 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e7a9:	83 ec 0c             	sub    $0xc,%esp
f010e7ac:	ff 75 08             	pushl  0x8(%ebp)
f010e7af:	e8 c4 fd ff ff       	call   f010e578 <trap_dispatch>
f010e7b4:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e7b7:	9c                   	pushf  
f010e7b8:	58                   	pop    %eax
f010e7b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e7bc:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e7bf:	25 00 02 00 00       	and    $0x200,%eax
f010e7c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e7c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e7cb:	74 19                	je     f010e7e6 <trap+0x11e>
f010e7cd:	68 dd 7a 12 f0       	push   $0xf0127add
f010e7d2:	68 b2 7a 12 f0       	push   $0xf0127ab2
f010e7d7:	68 66 01 00 00       	push   $0x166
f010e7dc:	68 f6 79 12 f0       	push   $0xf01279f6
f010e7e1:	e8 53 1b ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e7e6:	e8 e5 66 ff ff       	call   f0104ed0 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e7eb:	90                   	nop
f010e7ec:	c9                   	leave  
f010e7ed:	c3                   	ret    

f010e7ee <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e7ee:	6a 08                	push   $0x8
f010e7f0:	e9 ed 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e7f5:	90                   	nop

f010e7f6 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e7f6:	6a 0e                	push   $0xe
f010e7f8:	e9 e5 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e7fd:	90                   	nop

f010e7fe <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e7fe:	6a 00                	push   $0x0
f010e800:	6a 20                	push   $0x20
f010e802:	e9 db 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e807:	90                   	nop

f010e808 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e808:	6a 00                	push   $0x0
f010e80a:	6a 21                	push   $0x21
f010e80c:	e9 d1 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e811:	90                   	nop

f010e812 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e812:	6a 00                	push   $0x0
f010e814:	6a 30                	push   $0x30
f010e816:	e9 c7 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e81b:	90                   	nop

f010e81c <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e81c:	6a 00                	push   $0x0
f010e81e:	6a 00                	push   $0x0
f010e820:	e9 bd 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e825:	90                   	nop

f010e826 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e826:	6a 00                	push   $0x0
f010e828:	6a 01                	push   $0x1
f010e82a:	e9 b3 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e82f:	90                   	nop

f010e830 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e830:	6a 00                	push   $0x0
f010e832:	6a 02                	push   $0x2
f010e834:	e9 a9 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e839:	90                   	nop

f010e83a <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e83a:	6a 00                	push   $0x0
f010e83c:	6a 03                	push   $0x3
f010e83e:	e9 9f 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e843:	90                   	nop

f010e844 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e844:	6a 00                	push   $0x0
f010e846:	6a 04                	push   $0x4
f010e848:	e9 95 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e84d:	90                   	nop

f010e84e <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e84e:	6a 00                	push   $0x0
f010e850:	6a 05                	push   $0x5
f010e852:	e9 8b 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e857:	90                   	nop

f010e858 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e858:	6a 00                	push   $0x0
f010e85a:	6a 06                	push   $0x6
f010e85c:	e9 81 00 00 00       	jmp    f010e8e2 <_alltraps>
f010e861:	90                   	nop

f010e862 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e862:	6a 00                	push   $0x0
f010e864:	6a 07                	push   $0x7
f010e866:	eb 7a                	jmp    f010e8e2 <_alltraps>

f010e868 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e868:	6a 0a                	push   $0xa
f010e86a:	eb 76                	jmp    f010e8e2 <_alltraps>

f010e86c <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e86c:	6a 0b                	push   $0xb
f010e86e:	eb 72                	jmp    f010e8e2 <_alltraps>

f010e870 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e870:	6a 0c                	push   $0xc
f010e872:	eb 6e                	jmp    f010e8e2 <_alltraps>

f010e874 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e874:	6a 0d                	push   $0xd
f010e876:	eb 6a                	jmp    f010e8e2 <_alltraps>

f010e878 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e878:	6a 00                	push   $0x0
f010e87a:	6a 10                	push   $0x10
f010e87c:	eb 64                	jmp    f010e8e2 <_alltraps>

f010e87e <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e87e:	6a 11                	push   $0x11
f010e880:	eb 60                	jmp    f010e8e2 <_alltraps>

f010e882 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e882:	6a 00                	push   $0x0
f010e884:	6a 12                	push   $0x12
f010e886:	eb 5a                	jmp    f010e8e2 <_alltraps>

f010e888 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e888:	6a 00                	push   $0x0
f010e88a:	6a 13                	push   $0x13
f010e88c:	eb 54                	jmp    f010e8e2 <_alltraps>

f010e88e <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e88e:	6a 00                	push   $0x0
f010e890:	6a 22                	push   $0x22
f010e892:	eb 4e                	jmp    f010e8e2 <_alltraps>

f010e894 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e894:	6a 00                	push   $0x0
f010e896:	6a 23                	push   $0x23
f010e898:	eb 48                	jmp    f010e8e2 <_alltraps>

f010e89a <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e89a:	6a 00                	push   $0x0
f010e89c:	6a 24                	push   $0x24
f010e89e:	eb 42                	jmp    f010e8e2 <_alltraps>

f010e8a0 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e8a0:	6a 00                	push   $0x0
f010e8a2:	6a 25                	push   $0x25
f010e8a4:	eb 3c                	jmp    f010e8e2 <_alltraps>

f010e8a6 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e8a6:	6a 00                	push   $0x0
f010e8a8:	6a 26                	push   $0x26
f010e8aa:	eb 36                	jmp    f010e8e2 <_alltraps>

f010e8ac <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e8ac:	6a 00                	push   $0x0
f010e8ae:	6a 27                	push   $0x27
f010e8b0:	eb 30                	jmp    f010e8e2 <_alltraps>

f010e8b2 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e8b2:	6a 00                	push   $0x0
f010e8b4:	6a 28                	push   $0x28
f010e8b6:	eb 2a                	jmp    f010e8e2 <_alltraps>

f010e8b8 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e8b8:	6a 00                	push   $0x0
f010e8ba:	6a 29                	push   $0x29
f010e8bc:	eb 24                	jmp    f010e8e2 <_alltraps>

f010e8be <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e8be:	6a 00                	push   $0x0
f010e8c0:	6a 2a                	push   $0x2a
f010e8c2:	eb 1e                	jmp    f010e8e2 <_alltraps>

f010e8c4 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e8c4:	6a 00                	push   $0x0
f010e8c6:	6a 2b                	push   $0x2b
f010e8c8:	eb 18                	jmp    f010e8e2 <_alltraps>

f010e8ca <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e8ca:	6a 00                	push   $0x0
f010e8cc:	6a 2c                	push   $0x2c
f010e8ce:	eb 12                	jmp    f010e8e2 <_alltraps>

f010e8d0 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e8d0:	6a 00                	push   $0x0
f010e8d2:	6a 2d                	push   $0x2d
f010e8d4:	eb 0c                	jmp    f010e8e2 <_alltraps>

f010e8d6 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e8d6:	6a 00                	push   $0x0
f010e8d8:	6a 2e                	push   $0x2e
f010e8da:	eb 06                	jmp    f010e8e2 <_alltraps>

f010e8dc <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e8dc:	6a 00                	push   $0x0
f010e8de:	6a 2f                	push   $0x2f
f010e8e0:	eb 00                	jmp    f010e8e2 <_alltraps>

f010e8e2 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e8e2:	1e                   	push   %ds
push 	%es
f010e8e3:	06                   	push   %es
pushal
f010e8e4:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e8e5:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e8e9:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e8eb:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e8ed:	54                   	push   %esp
call 	trap
f010e8ee:	e8 d5 fd ff ff       	call   f010e6c8 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e8f3:	59                   	pop    %ecx

f010e8f4 <trapret>:
.globl trapret
trapret:
popal
f010e8f4:	61                   	popa   
pop 	%es
f010e8f5:	07                   	pop    %es
pop 	%ds
f010e8f6:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e8f7:	83 c4 08             	add    $0x8,%esp
iret
f010e8fa:	cf                   	iret   

f010e8fb <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e8fb:	55                   	push   %ebp
f010e8fc:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e8fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e901:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f010e907:	29 d0                	sub    %edx,%eax
f010e909:	c1 f8 03             	sar    $0x3,%eax
f010e90c:	89 c2                	mov    %eax,%edx
f010e90e:	89 d0                	mov    %edx,%eax
f010e910:	c1 e0 02             	shl    $0x2,%eax
f010e913:	01 d0                	add    %edx,%eax
f010e915:	c1 e0 02             	shl    $0x2,%eax
f010e918:	01 d0                	add    %edx,%eax
f010e91a:	c1 e0 02             	shl    $0x2,%eax
f010e91d:	01 d0                	add    %edx,%eax
f010e91f:	89 c1                	mov    %eax,%ecx
f010e921:	c1 e1 08             	shl    $0x8,%ecx
f010e924:	01 c8                	add    %ecx,%eax
f010e926:	89 c1                	mov    %eax,%ecx
f010e928:	c1 e1 10             	shl    $0x10,%ecx
f010e92b:	01 c8                	add    %ecx,%eax
f010e92d:	01 c0                	add    %eax,%eax
f010e92f:	01 d0                	add    %edx,%eax
}
f010e931:	5d                   	pop    %ebp
f010e932:	c3                   	ret    

f010e933 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e933:	55                   	push   %ebp
f010e934:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e936:	ff 75 08             	pushl  0x8(%ebp)
f010e939:	e8 bd ff ff ff       	call   f010e8fb <to_frame_number>
f010e93e:	83 c4 04             	add    $0x4,%esp
f010e941:	c1 e0 0c             	shl    $0xc,%eax
}
f010e944:	c9                   	leave  
f010e945:	c3                   	ret    

f010e946 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e946:	55                   	push   %ebp
f010e947:	89 e5                	mov    %esp,%ebp
f010e949:	83 ec 18             	sub    $0x18,%esp
f010e94c:	8b 45 10             	mov    0x10(%ebp),%eax
f010e94f:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e952:	e8 a3 8b ff ff       	call   f01074fa <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e957:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e95b:	74 23                	je     f010e980 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e95d:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010e962:	8b 40 10             	mov    0x10(%eax),%eax
f010e965:	8b 15 80 dd 6a f2    	mov    0xf26add80,%edx
f010e96b:	83 c2 20             	add    $0x20,%edx
f010e96e:	83 ec 04             	sub    $0x4,%esp
f010e971:	50                   	push   %eax
f010e972:	52                   	push   %edx
f010e973:	68 90 7c 12 f0       	push   $0xf0127c90
f010e978:	e8 0e 26 ff ff       	call   f0100f8b <cprintf>
f010e97d:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e980:	83 ec 04             	sub    $0x4,%esp
f010e983:	ff 75 08             	pushl  0x8(%ebp)
f010e986:	ff 75 0c             	pushl  0xc(%ebp)
f010e989:	68 99 7c 12 f0       	push   $0xf0127c99
f010e98e:	e8 f8 25 ff ff       	call   f0100f8b <cprintf>
f010e993:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e996:	e8 b1 8b ff ff       	call   f010754c <popcli>
}
f010e99b:	90                   	nop
f010e99c:	c9                   	leave  
f010e99d:	c3                   	ret    

f010e99e <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e99e:	55                   	push   %ebp
f010e99f:	89 e5                	mov    %esp,%ebp
f010e9a1:	83 ec 18             	sub    $0x18,%esp
f010e9a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9a7:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e9aa:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e9ae:	83 ec 08             	sub    $0x8,%esp
f010e9b1:	50                   	push   %eax
f010e9b2:	68 9e 7c 12 f0       	push   $0xf0127c9e
f010e9b7:	e8 cf 25 ff ff       	call   f0100f8b <cprintf>
f010e9bc:	83 c4 10             	add    $0x10,%esp
}
f010e9bf:	90                   	nop
f010e9c0:	c9                   	leave  
f010e9c1:	c3                   	ret    

f010e9c2 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e9c2:	55                   	push   %ebp
f010e9c3:	89 e5                	mov    %esp,%ebp
f010e9c5:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e9c8:	9c                   	pushf  
f010e9c9:	58                   	pop    %eax
f010e9ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e9cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e9d0:	25 00 02 00 00       	and    $0x200,%eax
f010e9d5:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e9d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e9dc:	74 10                	je     f010e9ee <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e9de:	e8 e1 23 ff ff       	call   f0100dc4 <cons_getc2>
f010e9e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e9e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e9ea:	74 f2                	je     f010e9de <sys_cgetc+0x1c>
f010e9ec:	eb 0e                	jmp    f010e9fc <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e9ee:	e8 76 23 ff ff       	call   f0100d69 <cons_getc>
f010e9f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e9f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e9fa:	74 f2                	je     f010e9ee <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e9fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e9ff:	c9                   	leave  
f010ea00:	c3                   	ret    

f010ea01 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010ea01:	55                   	push   %ebp
f010ea02:	89 e5                	mov    %esp,%ebp
f010ea04:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010ea07:	e8 a4 24 ff ff       	call   f0100eb0 <cons_lock>
}
f010ea0c:	90                   	nop
f010ea0d:	c9                   	leave  
f010ea0e:	c3                   	ret    

f010ea0f <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010ea0f:	55                   	push   %ebp
f010ea10:	89 e5                	mov    %esp,%ebp
f010ea12:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010ea15:	e8 dd 24 ff ff       	call   f0100ef7 <cons_unlock>
}
f010ea1a:	90                   	nop
f010ea1b:	c9                   	leave  
f010ea1c:	c3                   	ret    

f010ea1d <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010ea1d:	55                   	push   %ebp
f010ea1e:	89 e5                	mov    %esp,%ebp
f010ea20:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010ea23:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ea28:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010ea2b:	83 ec 0c             	sub    $0xc,%esp
f010ea2e:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010ea31:	50                   	push   %eax
f010ea32:	e8 a6 9a ff ff       	call   f01084dd <allocate_frame>
f010ea37:	83 c4 10             	add    $0x10,%esp
f010ea3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010ea3d:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010ea41:	75 08                	jne    f010ea4b <__sys_allocate_page+0x2e>
		return r ;
f010ea43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ea46:	e9 e9 00 00 00       	jmp    f010eb34 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010ea4b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea4e:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010ea53:	77 0c                	ja     f010ea61 <__sys_allocate_page+0x44>
f010ea55:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea58:	25 ff 0f 00 00       	and    $0xfff,%eax
f010ea5d:	85 c0                	test   %eax,%eax
f010ea5f:	74 0a                	je     f010ea6b <__sys_allocate_page+0x4e>
		return E_INVAL;
f010ea61:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010ea66:	e9 c9 00 00 00       	jmp    f010eb34 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010ea6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea6e:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010ea73:	83 f8 04             	cmp    $0x4,%eax
f010ea76:	74 0a                	je     f010ea82 <__sys_allocate_page+0x65>
		return E_INVAL;
f010ea78:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010ea7d:	e9 b2 00 00 00       	jmp    f010eb34 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010ea82:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ea85:	83 ec 0c             	sub    $0xc,%esp
f010ea88:	50                   	push   %eax
f010ea89:	e8 a5 fe ff ff       	call   f010e933 <to_physical_address>
f010ea8e:	83 c4 10             	add    $0x10,%esp
f010ea91:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010ea94:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ea97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea9a:	8b 40 64             	mov    0x64(%eax),%eax
f010ea9d:	6a 02                	push   $0x2
f010ea9f:	68 00 00 80 ef       	push   $0xef800000
f010eaa4:	52                   	push   %edx
f010eaa5:	50                   	push   %eax
f010eaa6:	e8 ff 9e ff ff       	call   f01089aa <map_frame>
f010eaab:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010eaae:	83 ec 04             	sub    $0x4,%esp
f010eab1:	68 00 10 00 00       	push   $0x1000
f010eab6:	6a 00                	push   $0x0
f010eab8:	68 00 00 80 ef       	push   $0xef800000
f010eabd:	e8 d8 15 01 00       	call   f012009a <memset>
f010eac2:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010eac5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eac8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eacb:	8b 40 08             	mov    0x8(%eax),%eax
f010eace:	40                   	inc    %eax
f010eacf:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010ead3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ead6:	8b 40 64             	mov    0x64(%eax),%eax
f010ead9:	83 ec 08             	sub    $0x8,%esp
f010eadc:	68 00 00 80 ef       	push   $0xef800000
f010eae1:	50                   	push   %eax
f010eae2:	e8 23 a0 ff ff       	call   f0108b0a <unmap_frame>
f010eae7:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010eaea:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eaed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eaf0:	8b 40 08             	mov    0x8(%eax),%eax
f010eaf3:	48                   	dec    %eax
f010eaf4:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010eaf8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010eafb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eafe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb01:	8b 40 64             	mov    0x64(%eax),%eax
f010eb04:	ff 75 0c             	pushl  0xc(%ebp)
f010eb07:	51                   	push   %ecx
f010eb08:	52                   	push   %edx
f010eb09:	50                   	push   %eax
f010eb0a:	e8 9b 9e ff ff       	call   f01089aa <map_frame>
f010eb0f:	83 c4 10             	add    $0x10,%esp
f010eb12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010eb15:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010eb19:	75 14                	jne    f010eb2f <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010eb1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eb1e:	83 ec 0c             	sub    $0xc,%esp
f010eb21:	50                   	push   %eax
f010eb22:	e8 c3 9b ff ff       	call   f01086ea <decrement_references>
f010eb27:	83 c4 10             	add    $0x10,%esp
		return r;
f010eb2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb2d:	eb 05                	jmp    f010eb34 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010eb2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010eb34:	c9                   	leave  
f010eb35:	c3                   	ret    

f010eb36 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010eb36:	55                   	push   %ebp
f010eb37:	89 e5                	mov    %esp,%ebp
f010eb39:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010eb3c:	83 ec 04             	sub    $0x4,%esp
f010eb3f:	68 a1 7c 12 f0       	push   $0xf0127ca1
f010eb44:	68 dc 00 00 00       	push   $0xdc
f010eb49:	68 bf 7c 12 f0       	push   $0xf0127cbf
f010eb4e:	e8 e6 17 ff ff       	call   f0100339 <_panic>

f010eb53 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010eb53:	55                   	push   %ebp
f010eb54:	89 e5                	mov    %esp,%ebp
f010eb56:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010eb59:	83 ec 04             	sub    $0x4,%esp
f010eb5c:	68 d4 7c 12 f0       	push   $0xf0127cd4
f010eb61:	68 ed 00 00 00       	push   $0xed
f010eb66:	68 bf 7c 12 f0       	push   $0xf0127cbf
f010eb6b:	e8 c9 17 ff ff       	call   f0100339 <_panic>

f010eb70 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010eb70:	55                   	push   %ebp
f010eb71:	89 e5                	mov    %esp,%ebp
f010eb73:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010eb76:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010eb7b:	8b 40 64             	mov    0x64(%eax),%eax
f010eb7e:	83 ec 04             	sub    $0x4,%esp
f010eb81:	ff 75 0c             	pushl  0xc(%ebp)
f010eb84:	ff 75 08             	pushl  0x8(%ebp)
f010eb87:	50                   	push   %eax
f010eb88:	e8 6a c2 ff ff       	call   f010adf7 <calculate_required_frames>
f010eb8d:	83 c4 10             	add    $0x10,%esp
}
f010eb90:	c9                   	leave  
f010eb91:	c3                   	ret    

f010eb92 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010eb92:	55                   	push   %ebp
f010eb93:	89 e5                	mov    %esp,%ebp
f010eb95:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010eb98:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010eb9b:	83 ec 0c             	sub    $0xc,%esp
f010eb9e:	50                   	push   %eax
f010eb9f:	e8 e8 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010eba4:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010eba7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ebaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebad:	01 d0                	add    %edx,%eax
}
f010ebaf:	c9                   	leave  
f010ebb0:	c3                   	ret    

f010ebb1 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010ebb1:	55                   	push   %ebp
f010ebb2:	89 e5                	mov    %esp,%ebp
f010ebb4:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ebb7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ebba:	83 ec 0c             	sub    $0xc,%esp
f010ebbd:	50                   	push   %eax
f010ebbe:	e8 c9 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ebc3:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010ebc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ebc9:	c9                   	leave  
f010ebca:	c3                   	ret    

f010ebcb <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010ebcb:	55                   	push   %ebp
f010ebcc:	89 e5                	mov    %esp,%ebp
f010ebce:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ebd1:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ebd4:	83 ec 0c             	sub    $0xc,%esp
f010ebd7:	50                   	push   %eax
f010ebd8:	e8 af a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ebdd:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010ebe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010ebe3:	c9                   	leave  
f010ebe4:	c3                   	ret    

f010ebe5 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010ebe5:	55                   	push   %ebp
f010ebe6:	89 e5                	mov    %esp,%ebp
f010ebe8:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010ebeb:	83 ec 0c             	sub    $0xc,%esp
f010ebee:	ff 75 08             	pushl  0x8(%ebp)
f010ebf1:	e8 4d 00 01 00       	call   f011ec43 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ebf6:	83 c4 10             	add    $0x10,%esp
}
f010ebf9:	c9                   	leave  
f010ebfa:	c3                   	ret    

f010ebfb <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010ebfb:	55                   	push   %ebp
f010ebfc:	89 e5                	mov    %esp,%ebp
f010ebfe:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010ec01:	e8 68 ff 00 00       	call   f011eb6e <scarce_memory>
}
f010ec06:	90                   	nop
f010ec07:	c9                   	leave  
f010ec08:	c3                   	ret    

f010ec09 <sys_clearFFL>:

void sys_clearFFL()
{
f010ec09:	55                   	push   %ebp
f010ec0a:	89 e5                	mov    %esp,%ebp
f010ec0c:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010ec0f:	83 ec 0c             	sub    $0xc,%esp
f010ec12:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010ec17:	e8 e2 12 00 00       	call   f010fefe <acquire_spinlock>
f010ec1c:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010ec1f:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010ec24:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ec27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ec2e:	eb 12                	jmp    f010ec42 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ec30:	83 ec 0c             	sub    $0xc,%esp
f010ec33:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec36:	50                   	push   %eax
f010ec37:	e8 a1 98 ff ff       	call   f01084dd <allocate_frame>
f010ec3c:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ec3f:	ff 45 f4             	incl   -0xc(%ebp)
f010ec42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec45:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ec48:	7c e6                	jl     f010ec30 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ec4a:	83 ec 0c             	sub    $0xc,%esp
f010ec4d:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010ec52:	e8 2e 13 00 00       	call   f010ff85 <release_spinlock>
f010ec57:	83 c4 10             	add    $0x10,%esp
}
f010ec5a:	90                   	nop
f010ec5b:	c9                   	leave  
f010ec5c:	c3                   	ret    

f010ec5d <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ec5d:	55                   	push   %ebp
f010ec5e:	89 e5                	mov    %esp,%ebp
f010ec60:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ec63:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ec68:	83 ec 0c             	sub    $0xc,%esp
f010ec6b:	50                   	push   %eax
f010ec6c:	e8 7c 5d ff ff       	call   f01049ed <pf_calculate_allocated_pages>
f010ec71:	83 c4 10             	add    $0x10,%esp
}
f010ec74:	c9                   	leave  
f010ec75:	c3                   	ret    

f010ec76 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010ec76:	55                   	push   %ebp
f010ec77:	89 e5                	mov    %esp,%ebp
f010ec79:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010ec7c:	e8 ed 0c 00 00       	call   f010f96e <isBufferingEnabled>
f010ec81:	84 c0                	test   %al,%al
f010ec83:	74 19                	je     f010ec9e <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ec85:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ec8a:	83 ec 04             	sub    $0x4,%esp
f010ec8d:	ff 75 0c             	pushl  0xc(%ebp)
f010ec90:	ff 75 08             	pushl  0x8(%ebp)
f010ec93:	50                   	push   %eax
f010ec94:	e8 49 c3 ff ff       	call   f010afe2 <__free_user_mem_with_buffering>
f010ec99:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ec9c:	eb 18                	jmp    f010ecb6 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ec9e:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010eca3:	83 ec 04             	sub    $0x4,%esp
f010eca6:	ff 75 0c             	pushl  0xc(%ebp)
f010eca9:	ff 75 08             	pushl  0x8(%ebp)
f010ecac:	50                   	push   %eax
f010ecad:	e8 a4 c2 ff ff       	call   f010af56 <free_user_mem>
f010ecb2:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ecb5:	90                   	nop
}
f010ecb6:	c9                   	leave  
f010ecb7:	c3                   	ret    

f010ecb8 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010ecb8:	55                   	push   %ebp
f010ecb9:	89 e5                	mov    %esp,%ebp
f010ecbb:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010ecbe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ecc2:	75 07                	jne    f010eccb <check_Param+0x13>
	{
		env_exit();
f010ecc4:	e8 65 cf ff ff       	call   f010bc2e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ecc9:	eb 25                	jmp    f010ecf0 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010eccb:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010ecd2:	77 07                	ja     f010ecdb <check_Param+0x23>
f010ecd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecd7:	85 c0                	test   %eax,%eax
f010ecd9:	78 07                	js     f010ece2 <check_Param+0x2a>
	{
		env_exit();
f010ecdb:	e8 4e cf ff ff       	call   f010bc2e <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ece0:	eb 0e                	jmp    f010ecf0 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010ece2:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010ece9:	76 05                	jbe    f010ecf0 <check_Param+0x38>
	{
		env_exit();
f010eceb:	e8 3e cf ff ff       	call   f010bc2e <env_exit>
	}
}
f010ecf0:	90                   	nop
f010ecf1:	c9                   	leave  
f010ecf2:	c3                   	ret    

f010ecf3 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010ecf3:	55                   	push   %ebp
f010ecf4:	89 e5                	mov    %esp,%ebp
f010ecf6:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ecf9:	83 ec 0c             	sub    $0xc,%esp
f010ecfc:	ff 75 08             	pushl  0x8(%ebp)
f010ecff:	e8 b4 ff ff ff       	call   f010ecb8 <check_Param>
f010ed04:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010ed07:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ed0c:	83 ec 04             	sub    $0x4,%esp
f010ed0f:	ff 75 0c             	pushl  0xc(%ebp)
f010ed12:	ff 75 08             	pushl  0x8(%ebp)
f010ed15:	50                   	push   %eax
f010ed16:	e8 80 c1 ff ff       	call   f010ae9b <allocate_user_mem>
f010ed1b:	83 c4 10             	add    $0x10,%esp
	return;
f010ed1e:	90                   	nop
}
f010ed1f:	c9                   	leave  
f010ed20:	c3                   	ret    

f010ed21 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010ed21:	55                   	push   %ebp
f010ed22:	89 e5                	mov    %esp,%ebp
f010ed24:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ed27:	83 ec 0c             	sub    $0xc,%esp
f010ed2a:	ff 75 08             	pushl  0x8(%ebp)
f010ed2d:	e8 86 ff ff ff       	call   f010ecb8 <check_Param>
f010ed32:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010ed35:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ed3a:	8b 40 64             	mov    0x64(%eax),%eax
f010ed3d:	ff 75 10             	pushl  0x10(%ebp)
f010ed40:	ff 75 0c             	pushl  0xc(%ebp)
f010ed43:	ff 75 08             	pushl  0x8(%ebp)
f010ed46:	50                   	push   %eax
f010ed47:	e8 77 c0 ff ff       	call   f010adc3 <allocate_chunk>
f010ed4c:	83 c4 10             	add    $0x10,%esp
	return;
f010ed4f:	90                   	nop
}
f010ed50:	c9                   	leave  
f010ed51:	c3                   	ret    

f010ed52 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ed52:	55                   	push   %ebp
f010ed53:	89 e5                	mov    %esp,%ebp
f010ed55:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010ed58:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ed5d:	ff 75 10             	pushl  0x10(%ebp)
f010ed60:	ff 75 0c             	pushl  0xc(%ebp)
f010ed63:	ff 75 08             	pushl  0x8(%ebp)
f010ed66:	50                   	push   %eax
f010ed67:	e8 93 c2 ff ff       	call   f010afff <move_user_mem>
f010ed6c:	83 c4 10             	add    $0x10,%esp
	return;
f010ed6f:	90                   	nop
}
f010ed70:	c9                   	leave  
f010ed71:	c3                   	ret    

f010ed72 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010ed72:	55                   	push   %ebp
f010ed73:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010ed75:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
}
f010ed7a:	5d                   	pop    %ebp
f010ed7b:	c3                   	ret    

f010ed7c <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010ed7c:	55                   	push   %ebp
f010ed7d:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010ed7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed82:	a3 64 f5 b1 f0       	mov    %eax,0xf0b1f564
}
f010ed87:	90                   	nop
f010ed88:	5d                   	pop    %ebp
f010ed89:	c3                   	ret    

f010ed8a <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010ed8a:	55                   	push   %ebp
f010ed8b:	89 e5                	mov    %esp,%ebp
f010ed8d:	83 ec 18             	sub    $0x18,%esp
f010ed90:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed93:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ed96:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010ed9a:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ed9f:	8b 40 10             	mov    0x10(%eax),%eax
f010eda2:	83 ec 0c             	sub    $0xc,%esp
f010eda5:	ff 75 14             	pushl  0x14(%ebp)
f010eda8:	52                   	push   %edx
f010eda9:	ff 75 0c             	pushl  0xc(%ebp)
f010edac:	ff 75 08             	pushl  0x8(%ebp)
f010edaf:	50                   	push   %eax
f010edb0:	e8 fb a1 ff ff       	call   f0108fb0 <createSharedObject>
f010edb5:	83 c4 20             	add    $0x20,%esp
}
f010edb8:	c9                   	leave  
f010edb9:	c3                   	ret    

f010edba <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010edba:	55                   	push   %ebp
f010edbb:	89 e5                	mov    %esp,%ebp
f010edbd:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010edc0:	83 ec 08             	sub    $0x8,%esp
f010edc3:	ff 75 0c             	pushl  0xc(%ebp)
f010edc6:	ff 75 08             	pushl  0x8(%ebp)
f010edc9:	e8 dd 9f ff ff       	call   f0108dab <getSizeOfSharedObject>
f010edce:	83 c4 10             	add    $0x10,%esp
}
f010edd1:	c9                   	leave  
f010edd2:	c3                   	ret    

f010edd3 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010edd3:	55                   	push   %ebp
f010edd4:	89 e5                	mov    %esp,%ebp
f010edd6:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010edd9:	83 ec 04             	sub    $0x4,%esp
f010eddc:	ff 75 10             	pushl  0x10(%ebp)
f010eddf:	ff 75 0c             	pushl  0xc(%ebp)
f010ede2:	ff 75 08             	pushl  0x8(%ebp)
f010ede5:	e8 59 a3 ff ff       	call   f0109143 <getSharedObject>
f010edea:	83 c4 10             	add    $0x10,%esp
}
f010eded:	c9                   	leave  
f010edee:	c3                   	ret    

f010edef <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010edef:	55                   	push   %ebp
f010edf0:	89 e5                	mov    %esp,%ebp
f010edf2:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010edf5:	83 ec 08             	sub    $0x8,%esp
f010edf8:	ff 75 0c             	pushl  0xc(%ebp)
f010edfb:	ff 75 08             	pushl  0x8(%ebp)
f010edfe:	e8 81 a5 ff ff       	call   f0109384 <freeSharedObject>
f010ee03:	83 c4 10             	add    $0x10,%esp
}
f010ee06:	c9                   	leave  
f010ee07:	c3                   	ret    

f010ee08 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ee08:	55                   	push   %ebp
f010ee09:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010ee0b:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ee10:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ee13:	5d                   	pop    %ebp
f010ee14:	c3                   	ret    

f010ee15 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ee15:	55                   	push   %ebp
f010ee16:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ee18:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ee1d:	89 c2                	mov    %eax,%edx
f010ee1f:	a1 90 65 6f f0       	mov    0xf06f6590,%eax
f010ee24:	29 c2                	sub    %eax,%edx
f010ee26:	89 d0                	mov    %edx,%eax
f010ee28:	c1 f8 02             	sar    $0x2,%eax
f010ee2b:	89 c2                	mov    %eax,%edx
f010ee2d:	89 d0                	mov    %edx,%eax
f010ee2f:	c1 e0 03             	shl    $0x3,%eax
f010ee32:	01 d0                	add    %edx,%eax
f010ee34:	c1 e0 03             	shl    $0x3,%eax
f010ee37:	01 d0                	add    %edx,%eax
f010ee39:	c1 e0 02             	shl    $0x2,%eax
f010ee3c:	01 d0                	add    %edx,%eax
f010ee3e:	01 c0                	add    %eax,%eax
f010ee40:	01 d0                	add    %edx,%eax
f010ee42:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ee49:	01 c8                	add    %ecx,%eax
f010ee4b:	c1 e0 02             	shl    $0x2,%eax
f010ee4e:	01 d0                	add    %edx,%eax
f010ee50:	c1 e0 03             	shl    $0x3,%eax
f010ee53:	01 d0                	add    %edx,%eax
f010ee55:	c1 e0 05             	shl    $0x5,%eax
f010ee58:	29 d0                	sub    %edx,%eax
f010ee5a:	c1 e0 02             	shl    $0x2,%eax
f010ee5d:	01 d0                	add    %edx,%eax
f010ee5f:	01 c0                	add    %eax,%eax
f010ee61:	01 d0                	add    %edx,%eax
f010ee63:	c1 e0 03             	shl    $0x3,%eax
f010ee66:	01 d0                	add    %edx,%eax
f010ee68:	c1 e0 04             	shl    $0x4,%eax
f010ee6b:	29 d0                	sub    %edx,%eax
}
f010ee6d:	5d                   	pop    %ebp
f010ee6e:	c3                   	ret    

f010ee6f <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ee6f:	55                   	push   %ebp
f010ee70:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ee72:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ee77:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ee7a:	5d                   	pop    %ebp
f010ee7b:	c3                   	ret    

f010ee7c <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ee7c:	55                   	push   %ebp
f010ee7d:	89 e5                	mov    %esp,%ebp
f010ee7f:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010ee82:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ee86:	75 0a                	jne    f010ee92 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010ee88:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010ee8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ee90:	eb 22                	jmp    f010eeb4 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ee92:	83 ec 04             	sub    $0x4,%esp
f010ee95:	6a 00                	push   $0x0
f010ee97:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ee9a:	50                   	push   %eax
f010ee9b:	ff 75 08             	pushl  0x8(%ebp)
f010ee9e:	e8 1d ce ff ff       	call   f010bcc0 <envid2env>
f010eea3:	83 c4 10             	add    $0x10,%esp
f010eea6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eea9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eead:	79 05                	jns    f010eeb4 <sys_destroy_env+0x38>
	{
		return r;
f010eeaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eeb2:	eb 5e                	jmp    f010ef12 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010eeb4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eeb7:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010eebc:	39 c2                	cmp    %eax,%edx
f010eebe:	75 1b                	jne    f010eedb <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010eec0:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010eec5:	8b 40 10             	mov    0x10(%eax),%eax
f010eec8:	83 ec 08             	sub    $0x8,%esp
f010eecb:	50                   	push   %eax
f010eecc:	68 f3 7c 12 f0       	push   $0xf0127cf3
f010eed1:	e8 b5 20 ff ff       	call   f0100f8b <cprintf>
f010eed6:	83 c4 10             	add    $0x10,%esp
f010eed9:	eb 20                	jmp    f010eefb <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010eedb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eede:	8b 50 10             	mov    0x10(%eax),%edx
f010eee1:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010eee6:	8b 40 10             	mov    0x10(%eax),%eax
f010eee9:	83 ec 04             	sub    $0x4,%esp
f010eeec:	52                   	push   %edx
f010eeed:	50                   	push   %eax
f010eeee:	68 0e 7d 12 f0       	push   $0xf0127d0e
f010eef3:	e8 93 20 ff ff       	call   f0100f8b <cprintf>
f010eef8:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010eefb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eefe:	8b 40 10             	mov    0x10(%eax),%eax
f010ef01:	83 ec 0c             	sub    $0xc,%esp
f010ef04:	50                   	push   %eax
f010ef05:	e8 19 6e ff ff       	call   f0105d23 <sched_kill_env>
f010ef0a:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ef0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef12:	c9                   	leave  
f010ef13:	c3                   	ret    

f010ef14 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ef14:	55                   	push   %ebp
f010ef15:	89 e5                	mov    %esp,%ebp
f010ef17:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ef1a:	e8 0f cd ff ff       	call   f010bc2e <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ef1f:	90                   	nop
f010ef20:	c9                   	leave  
f010ef21:	c3                   	ret    

f010ef22 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ef22:	55                   	push   %ebp
f010ef23:	89 e5                	mov    %esp,%ebp
f010ef25:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ef28:	ff 75 14             	pushl  0x14(%ebp)
f010ef2b:	ff 75 10             	pushl  0x10(%ebp)
f010ef2e:	ff 75 0c             	pushl  0xc(%ebp)
f010ef31:	ff 75 08             	pushl  0x8(%ebp)
f010ef34:	e8 b9 c2 ff ff       	call   f010b1f2 <env_create>
f010ef39:	83 c4 10             	add    $0x10,%esp
f010ef3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ef3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ef43:	75 07                	jne    f010ef4c <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ef45:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ef4a:	eb 14                	jmp    f010ef60 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ef4c:	83 ec 0c             	sub    $0xc,%esp
f010ef4f:	ff 75 f4             	pushl  -0xc(%ebp)
f010ef52:	e8 30 6a ff ff       	call   f0105987 <sched_new_env>
f010ef57:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ef5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef5d:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ef60:	c9                   	leave  
f010ef61:	c3                   	ret    

f010ef62 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ef62:	55                   	push   %ebp
f010ef63:	89 e5                	mov    %esp,%ebp
f010ef65:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ef68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef6b:	83 ec 0c             	sub    $0xc,%esp
f010ef6e:	50                   	push   %eax
f010ef6f:	e8 69 6a ff ff       	call   f01059dd <sched_run_env>
f010ef74:	83 c4 10             	add    $0x10,%esp
}
f010ef77:	90                   	nop
f010ef78:	c9                   	leave  
f010ef79:	c3                   	ret    

f010ef7a <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ef7a:	55                   	push   %ebp
f010ef7b:	89 e5                	mov    %esp,%ebp
f010ef7d:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ef80:	0f 31                	rdtsc  
f010ef82:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ef85:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ef88:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ef8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ef8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ef91:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ef94:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ef97:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef9a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ef9d:	89 01                	mov    %eax,(%ecx)
f010ef9f:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010efa2:	8b 45 08             	mov    0x8(%ebp),%eax
f010efa5:	c9                   	leave  
f010efa6:	c2 04 00             	ret    $0x4

f010efa9 <sys_rcr2>:

uint32 sys_rcr2()
{
f010efa9:	55                   	push   %ebp
f010efaa:	89 e5                	mov    %esp,%ebp
f010efac:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010efaf:	0f 20 d0             	mov    %cr2,%eax
f010efb2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010efb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010efb8:	90                   	nop
}
f010efb9:	c9                   	leave  
f010efba:	c3                   	ret    

f010efbb <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010efbb:	55                   	push   %ebp
f010efbc:	89 e5                	mov    %esp,%ebp
f010efbe:	83 ec 04             	sub    $0x4,%esp
f010efc1:	8b 45 08             	mov    0x8(%ebp),%eax
f010efc4:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010efc7:	8a 45 fc             	mov    -0x4(%ebp),%al
f010efca:	a2 00 6e 6f f0       	mov    %al,0xf06f6e00
}
f010efcf:	90                   	nop
f010efd0:	c9                   	leave  
f010efd1:	c3                   	ret    

f010efd2 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010efd2:	55                   	push   %ebp
f010efd3:	89 e5                	mov    %esp,%ebp
f010efd5:	56                   	push   %esi
f010efd6:	53                   	push   %ebx
f010efd7:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010efda:	e8 91 cc ff ff       	call   f010bc70 <get_cpu_proc>
f010efdf:	a3 80 dd 6a f2       	mov    %eax,0xf26add80
	assert(cur_env != NULL);
f010efe4:	a1 80 dd 6a f2       	mov    0xf26add80,%eax
f010efe9:	85 c0                	test   %eax,%eax
f010efeb:	75 19                	jne    f010f006 <syscall+0x34>
f010efed:	68 26 7d 12 f0       	push   $0xf0127d26
f010eff2:	68 36 7d 12 f0       	push   $0xf0127d36
f010eff7:	68 05 02 00 00       	push   $0x205
f010effc:	68 bf 7c 12 f0       	push   $0xf0127cbf
f010f001:	e8 33 13 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010f006:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010f00a:	0f 87 06 04 00 00    	ja     f010f416 <syscall+0x444>
f010f010:	8b 45 08             	mov    0x8(%ebp),%eax
f010f013:	c1 e0 02             	shl    $0x2,%eax
f010f016:	05 4c 7d 12 f0       	add    $0xf0127d4c,%eax
f010f01b:	8b 00                	mov    (%eax),%eax
f010f01d:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010f01f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f022:	83 ec 0c             	sub    $0xc,%esp
f010f025:	50                   	push   %eax
f010f026:	e8 e6 bd ff ff       	call   f010ae11 <sys_sbrk>
f010f02b:	83 c4 10             	add    $0x10,%esp
f010f02e:	e9 e8 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010f033:	83 ec 08             	sub    $0x8,%esp
f010f036:	ff 75 10             	pushl  0x10(%ebp)
f010f039:	ff 75 0c             	pushl  0xc(%ebp)
f010f03c:	e8 35 fc ff ff       	call   f010ec76 <sys_free_user_mem>
f010f041:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f044:	b8 00 00 00 00       	mov    $0x0,%eax
f010f049:	e9 cd 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010f04e:	83 ec 08             	sub    $0x8,%esp
f010f051:	ff 75 10             	pushl  0x10(%ebp)
f010f054:	ff 75 0c             	pushl  0xc(%ebp)
f010f057:	e8 97 fc ff ff       	call   f010ecf3 <sys_allocate_user_mem>
f010f05c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f05f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f064:	e9 b2 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010f069:	8b 45 14             	mov    0x14(%ebp),%eax
f010f06c:	0f b6 d0             	movzbl %al,%edx
f010f06f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f072:	83 ec 04             	sub    $0x4,%esp
f010f075:	52                   	push   %edx
f010f076:	ff 75 10             	pushl  0x10(%ebp)
f010f079:	50                   	push   %eax
f010f07a:	e8 c7 f8 ff ff       	call   f010e946 <sys_cputs>
f010f07f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f082:	b8 00 00 00 00       	mov    $0x0,%eax
f010f087:	e9 8f 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010f08c:	e8 31 f9 ff ff       	call   f010e9c2 <sys_cgetc>
f010f091:	e9 85 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f096:	e8 66 f9 ff ff       	call   f010ea01 <sys_lock_cons>
		return 0;
f010f09b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0a0:	e9 76 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f0a5:	e8 65 f9 ff ff       	call   f010ea0f <sys_unlock_cons>
		return 0;
f010f0aa:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0af:	e9 67 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f0b4:	83 ec 08             	sub    $0x8,%esp
f010f0b7:	ff 75 10             	pushl  0x10(%ebp)
f010f0ba:	ff 75 0c             	pushl  0xc(%ebp)
f010f0bd:	e8 ae fa ff ff       	call   f010eb70 <sys_calculate_required_frames>
f010f0c2:	83 c4 10             	add    $0x10,%esp
f010f0c5:	e9 51 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f0ca:	e8 c3 fa ff ff       	call   f010eb92 <sys_calculate_free_frames>
f010f0cf:	e9 47 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f0d4:	e8 d8 fa ff ff       	call   f010ebb1 <sys_calculate_modified_frames>
f010f0d9:	e9 3d 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f0de:	e8 e8 fa ff ff       	call   f010ebcb <sys_calculate_notmod_frames>
f010f0e3:	e9 33 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f0e8:	e8 70 fb ff ff       	call   f010ec5d <sys_pf_calculate_allocated_pages>
f010f0ed:	e9 29 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f0f2:	83 ec 0c             	sub    $0xc,%esp
f010f0f5:	ff 75 0c             	pushl  0xc(%ebp)
f010f0f8:	e8 e8 fa ff ff       	call   f010ebe5 <sys_calculate_pages_tobe_removed_ready_exit>
f010f0fd:	83 c4 10             	add    $0x10,%esp
f010f100:	e9 16 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f105:	e8 f1 fa ff ff       	call   f010ebfb <sys_scarce_memory>
		return 0;
f010f10a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f10f:	e9 07 03 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f114:	83 ec 04             	sub    $0x4,%esp
f010f117:	ff 75 14             	pushl  0x14(%ebp)
f010f11a:	ff 75 10             	pushl  0x10(%ebp)
f010f11d:	ff 75 0c             	pushl  0xc(%ebp)
f010f120:	e8 fc fb ff ff       	call   f010ed21 <sys_allocate_chunk>
f010f125:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f128:	b8 00 00 00 00       	mov    $0x0,%eax
f010f12d:	e9 e9 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010f132:	8b 55 10             	mov    0x10(%ebp),%edx
f010f135:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f138:	83 ec 08             	sub    $0x8,%esp
f010f13b:	52                   	push   %edx
f010f13c:	50                   	push   %eax
f010f13d:	e8 db f8 ff ff       	call   f010ea1d <__sys_allocate_page>
f010f142:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f145:	b8 00 00 00 00       	mov    $0x0,%eax
f010f14a:	e9 cc 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f14f:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f152:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f155:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f158:	8b 55 10             	mov    0x10(%ebp),%edx
f010f15b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f15e:	83 ec 0c             	sub    $0xc,%esp
f010f161:	56                   	push   %esi
f010f162:	53                   	push   %ebx
f010f163:	51                   	push   %ecx
f010f164:	52                   	push   %edx
f010f165:	50                   	push   %eax
f010f166:	e8 cb f9 ff ff       	call   f010eb36 <__sys_map_frame>
f010f16b:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f16e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f173:	e9 a3 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010f178:	8b 55 10             	mov    0x10(%ebp),%edx
f010f17b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f17e:	83 ec 08             	sub    $0x8,%esp
f010f181:	52                   	push   %edx
f010f182:	50                   	push   %eax
f010f183:	e8 cb f9 ff ff       	call   f010eb53 <__sys_unmap_frame>
f010f188:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f18b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f190:	e9 86 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010f195:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f198:	0f be c0             	movsbl %al,%eax
f010f19b:	83 ec 0c             	sub    $0xc,%esp
f010f19e:	50                   	push   %eax
f010f19f:	e8 fa f7 ff ff       	call   f010e99e <sys_cputc>
f010f1a4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1a7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1ac:	e9 6a 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f1b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1b4:	0f be c0             	movsbl %al,%eax
f010f1b7:	83 ec 0c             	sub    $0xc,%esp
f010f1ba:	50                   	push   %eax
f010f1bb:	e8 49 fa ff ff       	call   f010ec09 <sys_clearFFL>
f010f1c0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1c3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1c8:	e9 4e 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010f1cd:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f1d0:	8b 45 14             	mov    0x14(%ebp),%eax
f010f1d3:	0f b6 d0             	movzbl %al,%edx
f010f1d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1d9:	51                   	push   %ecx
f010f1da:	52                   	push   %edx
f010f1db:	ff 75 10             	pushl  0x10(%ebp)
f010f1de:	50                   	push   %eax
f010f1df:	e8 a6 fb ff ff       	call   f010ed8a <sys_createSharedObject>
f010f1e4:	83 c4 10             	add    $0x10,%esp
f010f1e7:	e9 2f 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010f1ec:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f1ef:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1f5:	83 ec 04             	sub    $0x4,%esp
f010f1f8:	51                   	push   %ecx
f010f1f9:	52                   	push   %edx
f010f1fa:	50                   	push   %eax
f010f1fb:	e8 d3 fb ff ff       	call   f010edd3 <sys_getSharedObject>
f010f200:	83 c4 10             	add    $0x10,%esp
f010f203:	e9 13 02 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010f208:	8b 55 10             	mov    0x10(%ebp),%edx
f010f20b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f20e:	83 ec 08             	sub    $0x8,%esp
f010f211:	52                   	push   %edx
f010f212:	50                   	push   %eax
f010f213:	e8 d7 fb ff ff       	call   f010edef <sys_freeSharedObject>
f010f218:	83 c4 10             	add    $0x10,%esp
f010f21b:	e9 fb 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010f220:	8b 55 10             	mov    0x10(%ebp),%edx
f010f223:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f226:	83 ec 08             	sub    $0x8,%esp
f010f229:	52                   	push   %edx
f010f22a:	50                   	push   %eax
f010f22b:	e8 8a fb ff ff       	call   f010edba <sys_getSizeOfSharedObject>
f010f230:	83 c4 10             	add    $0x10,%esp
f010f233:	e9 e3 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f238:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f23b:	ff 75 18             	pushl  0x18(%ebp)
f010f23e:	ff 75 14             	pushl  0x14(%ebp)
f010f241:	ff 75 10             	pushl  0x10(%ebp)
f010f244:	50                   	push   %eax
f010f245:	e8 d8 fc ff ff       	call   f010ef22 <sys_create_env>
f010f24a:	83 c4 10             	add    $0x10,%esp
f010f24d:	e9 c9 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f252:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f255:	83 ec 0c             	sub    $0xc,%esp
f010f258:	50                   	push   %eax
f010f259:	e8 04 fd ff ff       	call   f010ef62 <sys_run_env>
f010f25e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f261:	b8 00 00 00 00       	mov    $0x0,%eax
f010f266:	e9 b0 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f26b:	e8 a5 fb ff ff       	call   f010ee15 <sys_getenvindex>
f010f270:	e9 a6 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f275:	e8 8e fb ff ff       	call   f010ee08 <sys_getenvid>
f010f27a:	e9 9c 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f27f:	e8 eb fb ff ff       	call   f010ee6f <sys_getparentenvid>
f010f284:	e9 92 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f289:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f28c:	83 ec 0c             	sub    $0xc,%esp
f010f28f:	50                   	push   %eax
f010f290:	e8 e7 fb ff ff       	call   f010ee7c <sys_destroy_env>
f010f295:	83 c4 10             	add    $0x10,%esp
f010f298:	e9 7e 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f29d:	e8 72 fc ff ff       	call   f010ef14 <sys_exit_env>
		return 0;
f010f2a2:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2a7:	e9 6f 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f2ac:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f2af:	83 ec 0c             	sub    $0xc,%esp
f010f2b2:	50                   	push   %eax
f010f2b3:	e8 c2 fc ff ff       	call   f010ef7a <sys_get_virtual_time>
f010f2b8:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f2bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2be:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f2c1:	8b 45 10             	mov    0x10(%ebp),%eax
f010f2c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f2c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f2ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f2cd:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f2cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f2d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2d5:	89 10                	mov    %edx,(%eax)
		return 0;
f010f2d7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2dc:	e9 3a 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f2e1:	83 ec 04             	sub    $0x4,%esp
f010f2e4:	ff 75 14             	pushl  0x14(%ebp)
f010f2e7:	ff 75 10             	pushl  0x10(%ebp)
f010f2ea:	ff 75 0c             	pushl  0xc(%ebp)
f010f2ed:	e8 60 fa ff ff       	call   f010ed52 <sys_move_user_mem>
f010f2f2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2f5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2fa:	e9 1c 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f2ff:	e8 a5 fc ff ff       	call   f010efa9 <sys_rcr2>
f010f304:	e9 12 01 00 00       	jmp    f010f41b <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f309:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30c:	0f b6 c0             	movzbl %al,%eax
f010f30f:	83 ec 0c             	sub    $0xc,%esp
f010f312:	50                   	push   %eax
f010f313:	e8 a3 fc ff ff       	call   f010efbb <sys_bypassPageFault>
f010f318:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f31b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f320:	e9 f6 00 00 00       	jmp    f010f41b <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f325:	e8 f8 ee 00 00       	call   f011e222 <rsttst>
		return 0;
f010f32a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f32f:	e9 e7 00 00 00       	jmp    f010f41b <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f334:	e8 31 ef 00 00       	call   f011e26a <inctst>
		return 0;
f010f339:	b8 00 00 00 00       	mov    $0x0,%eax
f010f33e:	e9 d8 00 00 00       	jmp    f010f41b <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f343:	83 ec 0c             	sub    $0xc,%esp
f010f346:	ff 75 0c             	pushl  0xc(%ebp)
f010f349:	e8 5e f0 00 00       	call   f011e3ac <chktst>
f010f34e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f351:	b8 00 00 00 00       	mov    $0x0,%eax
f010f356:	e9 c0 00 00 00       	jmp    f010f41b <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f35b:	e8 3e ef 00 00       	call   f011e29e <gettst>
f010f360:	e9 b6 00 00 00       	jmp    f010f41b <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f365:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f368:	8b 45 18             	mov    0x18(%ebp),%eax
f010f36b:	0f be c0             	movsbl %al,%eax
f010f36e:	83 ec 0c             	sub    $0xc,%esp
f010f371:	52                   	push   %edx
f010f372:	50                   	push   %eax
f010f373:	ff 75 14             	pushl  0x14(%ebp)
f010f376:	ff 75 10             	pushl  0x10(%ebp)
f010f379:	ff 75 0c             	pushl  0xc(%ebp)
f010f37c:	e8 27 ef 00 00       	call   f011e2a8 <tst>
f010f381:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f384:	b8 00 00 00 00       	mov    $0x0,%eax
f010f389:	e9 8d 00 00 00       	jmp    f010f41b <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f38e:	e8 df f9 ff ff       	call   f010ed72 <sys_get_heap_strategy>
f010f393:	e9 83 00 00 00       	jmp    f010f41b <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f398:	83 ec 0c             	sub    $0xc,%esp
f010f39b:	ff 75 0c             	pushl  0xc(%ebp)
f010f39e:	e8 d9 f9 ff ff       	call   f010ed7c <sys_set_uheap_strategy>
f010f3a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3ab:	eb 6e                	jmp    f010f41b <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f3ad:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f3b0:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f3b3:	8b 55 10             	mov    0x10(%ebp),%edx
f010f3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3b9:	53                   	push   %ebx
f010f3ba:	51                   	push   %ecx
f010f3bb:	52                   	push   %edx
f010f3bc:	50                   	push   %eax
f010f3bd:	e8 b3 1d 00 00       	call   f0111175 <sys_check_LRU_lists>
f010f3c2:	83 c4 10             	add    $0x10,%esp
f010f3c5:	eb 54                	jmp    f010f41b <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f3c7:	8b 55 10             	mov    0x10(%ebp),%edx
f010f3ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3cd:	83 ec 08             	sub    $0x8,%esp
f010f3d0:	52                   	push   %edx
f010f3d1:	50                   	push   %eax
f010f3d2:	e8 60 1f 00 00       	call   f0111337 <sys_check_LRU_lists_free>
f010f3d7:	83 c4 10             	add    $0x10,%esp
f010f3da:	eb 3f                	jmp    f010f41b <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f3dc:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f3df:	8b 55 10             	mov    0x10(%ebp),%edx
f010f3e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3e5:	51                   	push   %ecx
f010f3e6:	ff 75 14             	pushl  0x14(%ebp)
f010f3e9:	52                   	push   %edx
f010f3ea:	50                   	push   %eax
f010f3eb:	e8 d4 20 00 00       	call   f01114c4 <sys_check_WS_list>
f010f3f0:	83 c4 10             	add    $0x10,%esp
f010f3f3:	eb 26                	jmp    f010f41b <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f3f5:	8b 55 10             	mov    0x10(%ebp),%edx
f010f3f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3fb:	83 ec 08             	sub    $0x8,%esp
f010f3fe:	52                   	push   %edx
f010f3ff:	50                   	push   %eax
f010f400:	e8 a8 f1 00 00       	call   f011e5ad <sys_utilities>
f010f405:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f408:	b8 00 00 00 00       	mov    $0x0,%eax
f010f40d:	eb 0c                	jmp    f010f41b <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f40f:	b8 03 00 00 00       	mov    $0x3,%eax
f010f414:	eb 05                	jmp    f010f41b <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f416:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f41b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f41e:	5b                   	pop    %ebx
f010f41f:	5e                   	pop    %esi
f010f420:	5d                   	pop    %ebp
f010f421:	c3                   	ret    

f010f422 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f422:	55                   	push   %ebp
f010f423:	89 e5                	mov    %esp,%ebp
f010f425:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f428:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f42b:	8b 00                	mov    (%eax),%eax
f010f42d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f430:	8b 45 10             	mov    0x10(%ebp),%eax
f010f433:	8b 00                	mov    (%eax),%eax
f010f435:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f438:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f43f:	e9 ca 00 00 00       	jmp    f010f50e <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f444:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f447:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f44a:	01 d0                	add    %edx,%eax
f010f44c:	89 c2                	mov    %eax,%edx
f010f44e:	c1 ea 1f             	shr    $0x1f,%edx
f010f451:	01 d0                	add    %edx,%eax
f010f453:	d1 f8                	sar    %eax
f010f455:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f458:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f45b:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f45e:	eb 03                	jmp    f010f463 <stab_binsearch+0x41>
			m--;
f010f460:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f463:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f466:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f469:	7c 1e                	jl     f010f489 <stab_binsearch+0x67>
f010f46b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f46e:	89 d0                	mov    %edx,%eax
f010f470:	01 c0                	add    %eax,%eax
f010f472:	01 d0                	add    %edx,%eax
f010f474:	c1 e0 02             	shl    $0x2,%eax
f010f477:	89 c2                	mov    %eax,%edx
f010f479:	8b 45 08             	mov    0x8(%ebp),%eax
f010f47c:	01 d0                	add    %edx,%eax
f010f47e:	8a 40 04             	mov    0x4(%eax),%al
f010f481:	0f b6 c0             	movzbl %al,%eax
f010f484:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f487:	75 d7                	jne    f010f460 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f489:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f48c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f48f:	7d 09                	jge    f010f49a <stab_binsearch+0x78>
			l = true_m + 1;
f010f491:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f494:	40                   	inc    %eax
f010f495:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f498:	eb 74                	jmp    f010f50e <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f49a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f4a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f4a4:	89 d0                	mov    %edx,%eax
f010f4a6:	01 c0                	add    %eax,%eax
f010f4a8:	01 d0                	add    %edx,%eax
f010f4aa:	c1 e0 02             	shl    $0x2,%eax
f010f4ad:	89 c2                	mov    %eax,%edx
f010f4af:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4b2:	01 d0                	add    %edx,%eax
f010f4b4:	8b 40 08             	mov    0x8(%eax),%eax
f010f4b7:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f4ba:	73 11                	jae    f010f4cd <stab_binsearch+0xab>
			*region_left = m;
f010f4bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f4c2:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f4c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f4c7:	40                   	inc    %eax
f010f4c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f4cb:	eb 41                	jmp    f010f50e <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f4cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f4d0:	89 d0                	mov    %edx,%eax
f010f4d2:	01 c0                	add    %eax,%eax
f010f4d4:	01 d0                	add    %edx,%eax
f010f4d6:	c1 e0 02             	shl    $0x2,%eax
f010f4d9:	89 c2                	mov    %eax,%edx
f010f4db:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4de:	01 d0                	add    %edx,%eax
f010f4e0:	8b 40 08             	mov    0x8(%eax),%eax
f010f4e3:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f4e6:	76 14                	jbe    f010f4fc <stab_binsearch+0xda>
			*region_right = m - 1;
f010f4e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f4eb:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f4ee:	8b 45 10             	mov    0x10(%ebp),%eax
f010f4f1:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f4f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f4f6:	48                   	dec    %eax
f010f4f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f4fa:	eb 12                	jmp    f010f50e <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f4fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f502:	89 10                	mov    %edx,(%eax)
			l = m;
f010f504:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f507:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f50a:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f50e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f511:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f514:	0f 8e 2a ff ff ff    	jle    f010f444 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f51a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f51e:	75 0f                	jne    f010f52f <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f520:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f523:	8b 00                	mov    (%eax),%eax
f010f525:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f528:	8b 45 10             	mov    0x10(%ebp),%eax
f010f52b:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f52d:	eb 3d                	jmp    f010f56c <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f52f:	8b 45 10             	mov    0x10(%ebp),%eax
f010f532:	8b 00                	mov    (%eax),%eax
f010f534:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f537:	eb 03                	jmp    f010f53c <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f539:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f53c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f53f:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f541:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f544:	7d 1e                	jge    f010f564 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f546:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f549:	89 d0                	mov    %edx,%eax
f010f54b:	01 c0                	add    %eax,%eax
f010f54d:	01 d0                	add    %edx,%eax
f010f54f:	c1 e0 02             	shl    $0x2,%eax
f010f552:	89 c2                	mov    %eax,%edx
f010f554:	8b 45 08             	mov    0x8(%ebp),%eax
f010f557:	01 d0                	add    %edx,%eax
f010f559:	8a 40 04             	mov    0x4(%eax),%al
f010f55c:	0f b6 c0             	movzbl %al,%eax
f010f55f:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f562:	75 d5                	jne    f010f539 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f564:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f567:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f56a:	89 10                	mov    %edx,(%eax)
	}
}
f010f56c:	90                   	nop
f010f56d:	c9                   	leave  
f010f56e:	c3                   	ret    

f010f56f <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f56f:	55                   	push   %ebp
f010f570:	89 e5                	mov    %esp,%ebp
f010f572:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f575:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f578:	c7 00 08 7e 12 f0    	movl   $0xf0127e08,(%eax)
	info->eip_line = 0;
f010f57e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f581:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f588:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f58b:	c7 40 08 08 7e 12 f0 	movl   $0xf0127e08,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f592:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f595:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f59c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f59f:	8b 55 08             	mov    0x8(%ebp),%edx
f010f5a2:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f5a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5a8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f5af:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5b2:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f5b7:	76 1e                	jbe    f010f5d7 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f5b9:	c7 45 f4 84 1b 13 f0 	movl   $0xf0131b84,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f5c0:	c7 45 f0 98 58 16 f0 	movl   $0xf0165898,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f5c7:	c7 45 ec 99 58 16 f0 	movl   $0xf0165899,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f5ce:	c7 45 e8 9e 76 17 f0 	movl   $0xf017769e,-0x18(%ebp)
f010f5d5:	eb 2a                	jmp    f010f601 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f5d7:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f5de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f5e1:	8b 00                	mov    (%eax),%eax
f010f5e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f5e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f5e9:	8b 40 04             	mov    0x4(%eax),%eax
f010f5ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f5ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f5f2:	8b 40 08             	mov    0x8(%eax),%eax
f010f5f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f5f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f5fb:	8b 40 0c             	mov    0xc(%eax),%eax
f010f5fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f601:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f604:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f607:	76 0a                	jbe    f010f613 <debuginfo_eip+0xa4>
f010f609:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f60c:	48                   	dec    %eax
f010f60d:	8a 00                	mov    (%eax),%al
f010f60f:	84 c0                	test   %al,%al
f010f611:	74 0a                	je     f010f61d <debuginfo_eip+0xae>
		return -1;
f010f613:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f618:	e9 01 02 00 00       	jmp    f010f81e <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f61d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f624:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f627:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f62a:	29 c2                	sub    %eax,%edx
f010f62c:	89 d0                	mov    %edx,%eax
f010f62e:	c1 f8 02             	sar    $0x2,%eax
f010f631:	89 c2                	mov    %eax,%edx
f010f633:	89 d0                	mov    %edx,%eax
f010f635:	c1 e0 02             	shl    $0x2,%eax
f010f638:	01 d0                	add    %edx,%eax
f010f63a:	c1 e0 02             	shl    $0x2,%eax
f010f63d:	01 d0                	add    %edx,%eax
f010f63f:	c1 e0 02             	shl    $0x2,%eax
f010f642:	01 d0                	add    %edx,%eax
f010f644:	89 c1                	mov    %eax,%ecx
f010f646:	c1 e1 08             	shl    $0x8,%ecx
f010f649:	01 c8                	add    %ecx,%eax
f010f64b:	89 c1                	mov    %eax,%ecx
f010f64d:	c1 e1 10             	shl    $0x10,%ecx
f010f650:	01 c8                	add    %ecx,%eax
f010f652:	01 c0                	add    %eax,%eax
f010f654:	01 d0                	add    %edx,%eax
f010f656:	48                   	dec    %eax
f010f657:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f65a:	ff 75 08             	pushl  0x8(%ebp)
f010f65d:	6a 64                	push   $0x64
f010f65f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f662:	50                   	push   %eax
f010f663:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f666:	50                   	push   %eax
f010f667:	ff 75 f4             	pushl  -0xc(%ebp)
f010f66a:	e8 b3 fd ff ff       	call   f010f422 <stab_binsearch>
f010f66f:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f672:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f675:	85 c0                	test   %eax,%eax
f010f677:	75 0a                	jne    f010f683 <debuginfo_eip+0x114>
		return -1;
f010f679:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f67e:	e9 9b 01 00 00       	jmp    f010f81e <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f683:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f686:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f689:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f68c:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f68f:	ff 75 08             	pushl  0x8(%ebp)
f010f692:	6a 24                	push   $0x24
f010f694:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f697:	50                   	push   %eax
f010f698:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f69b:	50                   	push   %eax
f010f69c:	ff 75 f4             	pushl  -0xc(%ebp)
f010f69f:	e8 7e fd ff ff       	call   f010f422 <stab_binsearch>
f010f6a4:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f6a7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f6aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f6ad:	39 c2                	cmp    %eax,%edx
f010f6af:	0f 8f 86 00 00 00    	jg     f010f73b <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f6b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f6b8:	89 c2                	mov    %eax,%edx
f010f6ba:	89 d0                	mov    %edx,%eax
f010f6bc:	01 c0                	add    %eax,%eax
f010f6be:	01 d0                	add    %edx,%eax
f010f6c0:	c1 e0 02             	shl    $0x2,%eax
f010f6c3:	89 c2                	mov    %eax,%edx
f010f6c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6c8:	01 d0                	add    %edx,%eax
f010f6ca:	8b 00                	mov    (%eax),%eax
f010f6cc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f6cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f6d2:	29 d1                	sub    %edx,%ecx
f010f6d4:	89 ca                	mov    %ecx,%edx
f010f6d6:	39 d0                	cmp    %edx,%eax
f010f6d8:	73 22                	jae    f010f6fc <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f6da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f6dd:	89 c2                	mov    %eax,%edx
f010f6df:	89 d0                	mov    %edx,%eax
f010f6e1:	01 c0                	add    %eax,%eax
f010f6e3:	01 d0                	add    %edx,%eax
f010f6e5:	c1 e0 02             	shl    $0x2,%eax
f010f6e8:	89 c2                	mov    %eax,%edx
f010f6ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6ed:	01 d0                	add    %edx,%eax
f010f6ef:	8b 10                	mov    (%eax),%edx
f010f6f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f6f4:	01 c2                	add    %eax,%edx
f010f6f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6f9:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f6fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f6ff:	89 c2                	mov    %eax,%edx
f010f701:	89 d0                	mov    %edx,%eax
f010f703:	01 c0                	add    %eax,%eax
f010f705:	01 d0                	add    %edx,%eax
f010f707:	c1 e0 02             	shl    $0x2,%eax
f010f70a:	89 c2                	mov    %eax,%edx
f010f70c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f70f:	01 d0                	add    %edx,%eax
f010f711:	8b 50 08             	mov    0x8(%eax),%edx
f010f714:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f717:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f71a:	8b 55 08             	mov    0x8(%ebp),%edx
f010f71d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f720:	8b 40 10             	mov    0x10(%eax),%eax
f010f723:	29 c2                	sub    %eax,%edx
f010f725:	89 d0                	mov    %edx,%eax
f010f727:	c1 f8 02             	sar    $0x2,%eax
f010f72a:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f72d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f730:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f733:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f736:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f739:	eb 15                	jmp    f010f750 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f73b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f73e:	8b 55 08             	mov    0x8(%ebp),%edx
f010f741:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f744:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f747:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f74a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f74d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f750:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f753:	8b 40 08             	mov    0x8(%eax),%eax
f010f756:	83 ec 08             	sub    $0x8,%esp
f010f759:	6a 3a                	push   $0x3a
f010f75b:	50                   	push   %eax
f010f75c:	e8 0d 09 01 00       	call   f012006e <strfind>
f010f761:	83 c4 10             	add    $0x10,%esp
f010f764:	89 c2                	mov    %eax,%edx
f010f766:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f769:	8b 40 08             	mov    0x8(%eax),%eax
f010f76c:	29 c2                	sub    %eax,%edx
f010f76e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f771:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f774:	eb 03                	jmp    f010f779 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f776:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f779:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f77c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f77f:	7c 4e                	jl     f010f7cf <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f781:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f784:	89 d0                	mov    %edx,%eax
f010f786:	01 c0                	add    %eax,%eax
f010f788:	01 d0                	add    %edx,%eax
f010f78a:	c1 e0 02             	shl    $0x2,%eax
f010f78d:	89 c2                	mov    %eax,%edx
f010f78f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f792:	01 d0                	add    %edx,%eax
f010f794:	8a 40 04             	mov    0x4(%eax),%al
f010f797:	3c 84                	cmp    $0x84,%al
f010f799:	74 34                	je     f010f7cf <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f79b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f79e:	89 d0                	mov    %edx,%eax
f010f7a0:	01 c0                	add    %eax,%eax
f010f7a2:	01 d0                	add    %edx,%eax
f010f7a4:	c1 e0 02             	shl    $0x2,%eax
f010f7a7:	89 c2                	mov    %eax,%edx
f010f7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7ac:	01 d0                	add    %edx,%eax
f010f7ae:	8a 40 04             	mov    0x4(%eax),%al
f010f7b1:	3c 64                	cmp    $0x64,%al
f010f7b3:	75 c1                	jne    f010f776 <debuginfo_eip+0x207>
f010f7b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f7b8:	89 d0                	mov    %edx,%eax
f010f7ba:	01 c0                	add    %eax,%eax
f010f7bc:	01 d0                	add    %edx,%eax
f010f7be:	c1 e0 02             	shl    $0x2,%eax
f010f7c1:	89 c2                	mov    %eax,%edx
f010f7c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7c6:	01 d0                	add    %edx,%eax
f010f7c8:	8b 40 08             	mov    0x8(%eax),%eax
f010f7cb:	85 c0                	test   %eax,%eax
f010f7cd:	74 a7                	je     f010f776 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f7cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f7d2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f7d5:	7c 42                	jl     f010f819 <debuginfo_eip+0x2aa>
f010f7d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f7da:	89 d0                	mov    %edx,%eax
f010f7dc:	01 c0                	add    %eax,%eax
f010f7de:	01 d0                	add    %edx,%eax
f010f7e0:	c1 e0 02             	shl    $0x2,%eax
f010f7e3:	89 c2                	mov    %eax,%edx
f010f7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7e8:	01 d0                	add    %edx,%eax
f010f7ea:	8b 00                	mov    (%eax),%eax
f010f7ec:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f7ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f7f2:	29 d1                	sub    %edx,%ecx
f010f7f4:	89 ca                	mov    %ecx,%edx
f010f7f6:	39 d0                	cmp    %edx,%eax
f010f7f8:	73 1f                	jae    f010f819 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f7fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f7fd:	89 d0                	mov    %edx,%eax
f010f7ff:	01 c0                	add    %eax,%eax
f010f801:	01 d0                	add    %edx,%eax
f010f803:	c1 e0 02             	shl    $0x2,%eax
f010f806:	89 c2                	mov    %eax,%edx
f010f808:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f80b:	01 d0                	add    %edx,%eax
f010f80d:	8b 10                	mov    (%eax),%edx
f010f80f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f812:	01 c2                	add    %eax,%edx
f010f814:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f817:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f819:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f81e:	c9                   	leave  
f010f81f:	c3                   	ret    

f010f820 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f820:	55                   	push   %ebp
f010f821:	89 e5                	mov    %esp,%ebp
f010f823:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f826:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f82a:	74 1c                	je     f010f848 <setPageReplacmentAlgorithmLRU+0x28>
f010f82c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f830:	74 16                	je     f010f848 <setPageReplacmentAlgorithmLRU+0x28>
f010f832:	68 14 7e 12 f0       	push   $0xf0127e14
f010f837:	68 5e 7e 12 f0       	push   $0xf0127e5e
f010f83c:	6a 1a                	push   $0x1a
f010f83e:	68 73 7e 12 f0       	push   $0xf0127e73
f010f843:	e8 f1 0a ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f848:	8b 45 08             	mov    0x8(%ebp),%eax
f010f84b:	a3 f0 f7 f1 f0       	mov    %eax,0xf0f1f7f0
}
f010f850:	90                   	nop
f010f851:	c9                   	leave  
f010f852:	c3                   	ret    

f010f853 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f853:	55                   	push   %ebp
f010f854:	89 e5                	mov    %esp,%ebp
f010f856:	c7 05 f0 f7 f1 f0 03 	movl   $0x3,0xf0f1f7f0
f010f85d:	00 00 00 
f010f860:	90                   	nop
f010f861:	5d                   	pop    %ebp
f010f862:	c3                   	ret    

f010f863 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f863:	55                   	push   %ebp
f010f864:	89 e5                	mov    %esp,%ebp
f010f866:	c7 05 f0 f7 f1 f0 04 	movl   $0x4,0xf0f1f7f0
f010f86d:	00 00 00 
f010f870:	90                   	nop
f010f871:	5d                   	pop    %ebp
f010f872:	c3                   	ret    

f010f873 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f873:	55                   	push   %ebp
f010f874:	89 e5                	mov    %esp,%ebp
f010f876:	c7 05 f0 f7 f1 f0 05 	movl   $0x5,0xf0f1f7f0
f010f87d:	00 00 00 
f010f880:	90                   	nop
f010f881:	5d                   	pop    %ebp
f010f882:	c3                   	ret    

f010f883 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f883:	55                   	push   %ebp
f010f884:	89 e5                	mov    %esp,%ebp
f010f886:	c7 05 f0 f7 f1 f0 07 	movl   $0x7,0xf0f1f7f0
f010f88d:	00 00 00 
f010f890:	90                   	nop
f010f891:	5d                   	pop    %ebp
f010f892:	c3                   	ret    

f010f893 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f893:	55                   	push   %ebp
f010f894:	89 e5                	mov    %esp,%ebp
f010f896:	c7 05 f0 f7 f1 f0 06 	movl   $0x6,0xf0f1f7f0
f010f89d:	00 00 00 
f010f8a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8a3:	a3 14 f1 71 f0       	mov    %eax,0xf071f114
f010f8a8:	90                   	nop
f010f8a9:	5d                   	pop    %ebp
f010f8aa:	c3                   	ret    

f010f8ab <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f8ab:	55                   	push   %ebp
f010f8ac:	89 e5                	mov    %esp,%ebp
f010f8ae:	8b 15 f0 f7 f1 f0    	mov    0xf0f1f7f0,%edx
f010f8b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8b7:	39 c2                	cmp    %eax,%edx
f010f8b9:	0f 94 c0             	sete   %al
f010f8bc:	0f b6 c0             	movzbl %al,%eax
f010f8bf:	5d                   	pop    %ebp
f010f8c0:	c3                   	ret    

f010f8c1 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f8c1:	55                   	push   %ebp
f010f8c2:	89 e5                	mov    %esp,%ebp
f010f8c4:	a1 f0 f7 f1 f0       	mov    0xf0f1f7f0,%eax
f010f8c9:	83 f8 03             	cmp    $0x3,%eax
f010f8cc:	75 07                	jne    f010f8d5 <isPageReplacmentAlgorithmCLOCK+0x14>
f010f8ce:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8d3:	eb 05                	jmp    f010f8da <isPageReplacmentAlgorithmCLOCK+0x19>
f010f8d5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8da:	5d                   	pop    %ebp
f010f8db:	c3                   	ret    

f010f8dc <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f8dc:	55                   	push   %ebp
f010f8dd:	89 e5                	mov    %esp,%ebp
f010f8df:	a1 f0 f7 f1 f0       	mov    0xf0f1f7f0,%eax
f010f8e4:	83 f8 04             	cmp    $0x4,%eax
f010f8e7:	75 07                	jne    f010f8f0 <isPageReplacmentAlgorithmFIFO+0x14>
f010f8e9:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8ee:	eb 05                	jmp    f010f8f5 <isPageReplacmentAlgorithmFIFO+0x19>
f010f8f0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8f5:	5d                   	pop    %ebp
f010f8f6:	c3                   	ret    

f010f8f7 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f8f7:	55                   	push   %ebp
f010f8f8:	89 e5                	mov    %esp,%ebp
f010f8fa:	a1 f0 f7 f1 f0       	mov    0xf0f1f7f0,%eax
f010f8ff:	83 f8 05             	cmp    $0x5,%eax
f010f902:	75 07                	jne    f010f90b <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f904:	b8 01 00 00 00       	mov    $0x1,%eax
f010f909:	eb 05                	jmp    f010f910 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f90b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f910:	5d                   	pop    %ebp
f010f911:	c3                   	ret    

f010f912 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f912:	55                   	push   %ebp
f010f913:	89 e5                	mov    %esp,%ebp
f010f915:	a1 f0 f7 f1 f0       	mov    0xf0f1f7f0,%eax
f010f91a:	83 f8 07             	cmp    $0x7,%eax
f010f91d:	75 07                	jne    f010f926 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f91f:	b8 01 00 00 00       	mov    $0x1,%eax
f010f924:	eb 05                	jmp    f010f92b <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f926:	b8 00 00 00 00       	mov    $0x0,%eax
f010f92b:	5d                   	pop    %ebp
f010f92c:	c3                   	ret    

f010f92d <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f92d:	55                   	push   %ebp
f010f92e:	89 e5                	mov    %esp,%ebp
f010f930:	a1 f0 f7 f1 f0       	mov    0xf0f1f7f0,%eax
f010f935:	83 f8 06             	cmp    $0x6,%eax
f010f938:	75 07                	jne    f010f941 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f93a:	b8 01 00 00 00       	mov    $0x1,%eax
f010f93f:	eb 05                	jmp    f010f946 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f941:	b8 00 00 00 00       	mov    $0x0,%eax
f010f946:	5d                   	pop    %ebp
f010f947:	c3                   	ret    

f010f948 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f948:	55                   	push   %ebp
f010f949:	89 e5                	mov    %esp,%ebp
f010f94b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f94e:	a3 78 f5 b1 f0       	mov    %eax,0xf0b1f578
f010f953:	90                   	nop
f010f954:	5d                   	pop    %ebp
f010f955:	c3                   	ret    

f010f956 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f956:	55                   	push   %ebp
f010f957:	89 e5                	mov    %esp,%ebp
f010f959:	a1 78 f5 b1 f0       	mov    0xf0b1f578,%eax
f010f95e:	5d                   	pop    %ebp
f010f95f:	c3                   	ret    

f010f960 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f960:	55                   	push   %ebp
f010f961:	89 e5                	mov    %esp,%ebp
f010f963:	8b 45 08             	mov    0x8(%ebp),%eax
f010f966:	a3 74 f8 f1 f0       	mov    %eax,0xf0f1f874
f010f96b:	90                   	nop
f010f96c:	5d                   	pop    %ebp
f010f96d:	c3                   	ret    

f010f96e <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f96e:	55                   	push   %ebp
f010f96f:	89 e5                	mov    %esp,%ebp
f010f971:	a1 74 f8 f1 f0       	mov    0xf0f1f874,%eax
f010f976:	5d                   	pop    %ebp
f010f977:	c3                   	ret    

f010f978 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f978:	55                   	push   %ebp
f010f979:	89 e5                	mov    %esp,%ebp
f010f97b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f97e:	a3 10 f9 f1 f0       	mov    %eax,0xf0f1f910
f010f983:	90                   	nop
f010f984:	5d                   	pop    %ebp
f010f985:	c3                   	ret    

f010f986 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f986:	55                   	push   %ebp
f010f987:	89 e5                	mov    %esp,%ebp
f010f989:	a1 10 f9 f1 f0       	mov    0xf0f1f910,%eax
f010f98e:	5d                   	pop    %ebp
f010f98f:	c3                   	ret    

f010f990 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f990:	55                   	push   %ebp
f010f991:	89 e5                	mov    %esp,%ebp
f010f993:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f996:	0f 20 d0             	mov    %cr2,%eax
f010f999:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f99c:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f99f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f9a2:	e8 c9 c2 ff ff       	call   f010bc70 <get_cpu_proc>
f010f9a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f9aa:	a1 0c 6e 6f f0       	mov    0xf06f6e0c,%eax
f010f9af:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f9b2:	75 50                	jne    f010fa04 <fault_handler+0x74>
f010f9b4:	a1 18 6e 6f f0       	mov    0xf06f6e18,%eax
f010f9b9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f9bc:	75 46                	jne    f010fa04 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f9be:	a0 14 6e 6f f0       	mov    0xf06f6e14,%al
f010f9c3:	40                   	inc    %eax
f010f9c4:	a2 14 6e 6f f0       	mov    %al,0xf06f6e14
		if (num_repeated_fault == 3)
f010f9c9:	a0 14 6e 6f f0       	mov    0xf06f6e14,%al
f010f9ce:	3c 03                	cmp    $0x3,%al
f010f9d0:	75 4d                	jne    f010fa1f <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f9d2:	83 ec 0c             	sub    $0xc,%esp
f010f9d5:	ff 75 08             	pushl  0x8(%ebp)
f010f9d8:	e8 49 e9 ff ff       	call   f010e326 <print_trapframe>
f010f9dd:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f9e0:	8b 15 08 6e 6f f0    	mov    0xf06f6e08,%edx
f010f9e6:	a1 10 6e 6f f0       	mov    0xf06f6e10,%eax
f010f9eb:	83 ec 08             	sub    $0x8,%esp
f010f9ee:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9f1:	52                   	push   %edx
f010f9f2:	50                   	push   %eax
f010f9f3:	68 90 7e 12 f0       	push   $0xf0127e90
f010f9f8:	6a 58                	push   $0x58
f010f9fa:	68 73 7e 12 f0       	push   $0xf0127e73
f010f9ff:	e8 35 09 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010fa04:	a1 0c 6e 6f f0       	mov    0xf06f6e0c,%eax
f010fa09:	a3 10 6e 6f f0       	mov    %eax,0xf06f6e10
		before_last_eip = last_eip;
f010fa0e:	a1 04 6e 6f f0       	mov    0xf06f6e04,%eax
f010fa13:	a3 08 6e 6f f0       	mov    %eax,0xf06f6e08
		num_repeated_fault = 0;
f010fa18:	c6 05 14 6e 6f f0 00 	movb   $0x0,0xf06f6e14
	}
	last_eip = (uint32)tf->tf_eip;
f010fa1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa22:	8b 40 30             	mov    0x30(%eax),%eax
f010fa25:	a3 04 6e 6f f0       	mov    %eax,0xf06f6e04
	last_fault_va = fault_va ;
f010fa2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fa2d:	a3 0c 6e 6f f0       	mov    %eax,0xf06f6e0c
	last_faulted_env = cur_env;
f010fa32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa35:	a3 18 6e 6f f0       	mov    %eax,0xf06f6e18
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010fa3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fa41:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa44:	8b 40 34             	mov    0x34(%eax),%eax
f010fa47:	0f b7 c0             	movzwl %ax,%eax
f010fa4a:	83 e0 03             	and    $0x3,%eax
f010fa4d:	83 f8 03             	cmp    $0x3,%eax
f010fa50:	75 07                	jne    f010fa59 <fault_handler+0xc9>
		userTrap = 1;
f010fa52:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fa59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa5d:	0f 85 c2 00 00 00    	jne    f010fb25 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010fa63:	e8 cf 79 ff ff       	call   f0107437 <mycpu>
f010fa68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fa6b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fa6f:	74 2f                	je     f010faa0 <fault_handler+0x110>
f010fa71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa74:	8b 40 70             	mov    0x70(%eax),%eax
f010fa77:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa7a:	77 24                	ja     f010faa0 <fault_handler+0x110>
f010fa7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa7f:	8b 40 70             	mov    0x70(%eax),%eax
f010fa82:	05 00 10 00 00       	add    $0x1000,%eax
f010fa87:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa8a:	76 14                	jbe    f010faa0 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010fa8c:	83 ec 04             	sub    $0x4,%esp
f010fa8f:	68 00 7f 12 f0       	push   $0xf0127f00
f010fa94:	6a 6f                	push   $0x6f
f010fa96:	68 73 7e 12 f0       	push   $0xf0127e73
f010fa9b:	e8 99 08 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010faa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010faa3:	8b 40 08             	mov    0x8(%eax),%eax
f010faa6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010faa9:	77 5d                	ja     f010fb08 <fault_handler+0x178>
f010faab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010faae:	8b 40 08             	mov    0x8(%eax),%eax
f010fab1:	05 00 10 00 00       	add    $0x1000,%eax
f010fab6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fab9:	76 4d                	jbe    f010fb08 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fabb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fabe:	ba 60 f2 b1 f0       	mov    $0xf0b1f260,%edx
f010fac3:	29 d0                	sub    %edx,%eax
f010fac5:	c1 f8 03             	sar    $0x3,%eax
f010fac8:	89 c2                	mov    %eax,%edx
f010faca:	89 d0                	mov    %edx,%eax
f010facc:	c1 e0 02             	shl    $0x2,%eax
f010facf:	01 d0                	add    %edx,%eax
f010fad1:	01 c0                	add    %eax,%eax
f010fad3:	01 d0                	add    %edx,%eax
f010fad5:	c1 e0 03             	shl    $0x3,%eax
f010fad8:	01 d0                	add    %edx,%eax
f010fada:	89 c1                	mov    %eax,%ecx
f010fadc:	c1 e1 0b             	shl    $0xb,%ecx
f010fadf:	01 c8                	add    %ecx,%eax
f010fae1:	c1 e0 05             	shl    $0x5,%eax
f010fae4:	01 d0                	add    %edx,%eax
f010fae6:	c1 e0 02             	shl    $0x2,%eax
f010fae9:	01 d0                	add    %edx,%eax
f010faeb:	01 c0                	add    %eax,%eax
f010faed:	01 d0                	add    %edx,%eax
f010faef:	c1 e0 03             	shl    $0x3,%eax
f010faf2:	01 d0                	add    %edx,%eax
f010faf4:	f7 d8                	neg    %eax
f010faf6:	50                   	push   %eax
f010faf7:	68 28 7f 12 f0       	push   $0xf0127f28
f010fafc:	6a 71                	push   $0x71
f010fafe:	68 73 7e 12 f0       	push   $0xf0127e73
f010fb03:	e8 31 08 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010fb08:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fb0f:	76 3a                	jbe    f010fb4b <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010fb11:	83 ec 04             	sub    $0x4,%esp
f010fb14:	68 5c 7f 12 f0       	push   $0xf0127f5c
f010fb19:	6a 74                	push   $0x74
f010fb1b:	68 73 7e 12 f0       	push   $0xf0127e73
f010fb20:	e8 14 08 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010fb25:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010fb2c:	76 1d                	jbe    f010fb4b <fault_handler+0x1bb>
f010fb2e:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010fb35:	77 14                	ja     f010fb4b <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010fb37:	83 ec 04             	sub    $0x4,%esp
f010fb3a:	68 80 7f 12 f0       	push   $0xf0127f80
f010fb3f:	6a 7c                	push   $0x7c
f010fb41:	68 73 7e 12 f0       	push   $0xf0127e73
f010fb46:	e8 ee 07 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fb4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb4e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fb51:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fb55:	75 25                	jne    f010fb7c <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010fb57:	83 ec 0c             	sub    $0xc,%esp
f010fb5a:	ff 75 08             	pushl  0x8(%ebp)
f010fb5d:	e8 c4 e7 ff ff       	call   f010e326 <print_trapframe>
f010fb62:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fb65:	83 ec 04             	sub    $0x4,%esp
f010fb68:	68 a1 7f 12 f0       	push   $0xf0127fa1
f010fb6d:	68 85 00 00 00       	push   $0x85
f010fb72:	68 73 7e 12 f0       	push   $0xf0127e73
f010fb77:	e8 bd 07 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fb7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb7f:	8b 40 64             	mov    0x64(%eax),%eax
f010fb82:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb85:	c1 ea 16             	shr    $0x16,%edx
f010fb88:	c1 e2 02             	shl    $0x2,%edx
f010fb8b:	01 d0                	add    %edx,%eax
f010fb8d:	8b 00                	mov    (%eax),%eax
f010fb8f:	83 e0 01             	and    $0x1,%eax
f010fb92:	85 c0                	test   %eax,%eax
f010fb94:	75 2b                	jne    f010fbc1 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010fb96:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb99:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010fb9f:	8d 50 01             	lea    0x1(%eax),%edx
f010fba2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fba5:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010fbab:	83 ec 08             	sub    $0x8,%esp
f010fbae:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbb1:	ff 75 e0             	pushl  -0x20(%ebp)
f010fbb4:	e8 1e 01 00 00       	call   f010fcd7 <table_fault_handler>
f010fbb9:	83 c4 10             	add    $0x10,%esp
f010fbbc:	e9 07 01 00 00       	jmp    f010fcc8 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010fbc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fbc5:	0f 84 82 00 00 00    	je     f010fc4d <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010fbcb:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010fbd2:	76 07                	jbe    f010fbdb <fault_handler+0x24b>
			{
				env_exit();
f010fbd4:	e8 55 c0 ff ff       	call   f010bc2e <env_exit>
f010fbd9:	eb 72                	jmp    f010fc4d <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010fbdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fbde:	8b 40 64             	mov    0x64(%eax),%eax
f010fbe1:	83 ec 08             	sub    $0x8,%esp
f010fbe4:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbe7:	50                   	push   %eax
f010fbe8:	e8 cb a3 ff ff       	call   f0109fb8 <pt_get_page_permissions>
f010fbed:	83 c4 10             	add    $0x10,%esp
f010fbf0:	25 00 02 00 00       	and    $0x200,%eax
f010fbf5:	85 c0                	test   %eax,%eax
f010fbf7:	75 17                	jne    f010fc10 <fault_handler+0x280>
f010fbf9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fbfc:	85 c0                	test   %eax,%eax
f010fbfe:	79 10                	jns    f010fc10 <fault_handler+0x280>
f010fc00:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010fc07:	77 07                	ja     f010fc10 <fault_handler+0x280>
			{
				env_exit();
f010fc09:	e8 20 c0 ff ff       	call   f010bc2e <env_exit>
f010fc0e:	eb 3d                	jmp    f010fc4d <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010fc10:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc13:	8b 40 64             	mov    0x64(%eax),%eax
f010fc16:	83 ec 08             	sub    $0x8,%esp
f010fc19:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc1c:	50                   	push   %eax
f010fc1d:	e8 96 a3 ff ff       	call   f0109fb8 <pt_get_page_permissions>
f010fc22:	83 c4 10             	add    $0x10,%esp
f010fc25:	83 e0 01             	and    $0x1,%eax
f010fc28:	85 c0                	test   %eax,%eax
f010fc2a:	74 21                	je     f010fc4d <fault_handler+0x2bd>
f010fc2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc2f:	8b 40 64             	mov    0x64(%eax),%eax
f010fc32:	83 ec 08             	sub    $0x8,%esp
f010fc35:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc38:	50                   	push   %eax
f010fc39:	e8 7a a3 ff ff       	call   f0109fb8 <pt_get_page_permissions>
f010fc3e:	83 c4 10             	add    $0x10,%esp
f010fc41:	83 e0 02             	and    $0x2,%eax
f010fc44:	85 c0                	test   %eax,%eax
f010fc46:	75 05                	jne    f010fc4d <fault_handler+0x2bd>
			{
				env_exit();
f010fc48:	e8 e1 bf ff ff       	call   f010bc2e <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fc4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc50:	8b 40 64             	mov    0x64(%eax),%eax
f010fc53:	83 ec 08             	sub    $0x8,%esp
f010fc56:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc59:	50                   	push   %eax
f010fc5a:	e8 59 a3 ff ff       	call   f0109fb8 <pt_get_page_permissions>
f010fc5f:	83 c4 10             	add    $0x10,%esp
f010fc62:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fc65:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc68:	83 e0 01             	and    $0x1,%eax
f010fc6b:	85 c0                	test   %eax,%eax
f010fc6d:	74 17                	je     f010fc86 <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fc6f:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc72:	68 b8 7f 12 f0       	push   $0xf0127fb8
f010fc77:	68 ad 00 00 00       	push   $0xad
f010fc7c:	68 73 7e 12 f0       	push   $0xf0127e73
f010fc81:	e8 b3 06 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fc86:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc89:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010fc8f:	8d 50 01             	lea    0x1(%eax),%edx
f010fc92:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc95:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fc9b:	e8 ce fc ff ff       	call   f010f96e <isBufferingEnabled>
f010fca0:	84 c0                	test   %al,%al
f010fca2:	74 13                	je     f010fcb7 <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fca4:	83 ec 08             	sub    $0x8,%esp
f010fca7:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcaa:	ff 75 e0             	pushl  -0x20(%ebp)
f010fcad:	e8 fe 01 00 00       	call   f010feb0 <__page_fault_handler_with_buffering>
f010fcb2:	83 c4 10             	add    $0x10,%esp
f010fcb5:	eb 11                	jmp    f010fcc8 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fcb7:	83 ec 08             	sub    $0x8,%esp
f010fcba:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcbd:	ff 75 e0             	pushl  -0x20(%ebp)
f010fcc0:	e8 33 00 00 00       	call   f010fcf8 <page_fault_handler>
f010fcc5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fcc8:	0f 20 d8             	mov    %cr3,%eax
f010fccb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fcce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fcd1:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fcd4:	90                   	nop
f010fcd5:	c9                   	leave  
f010fcd6:	c3                   	ret    

f010fcd7 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fcd7:	55                   	push   %ebp
f010fcd8:	89 e5                	mov    %esp,%ebp
f010fcda:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fcdd:	8b 45 08             	mov    0x8(%ebp),%eax
f010fce0:	8b 40 64             	mov    0x64(%eax),%eax
f010fce3:	83 ec 08             	sub    $0x8,%esp
f010fce6:	ff 75 0c             	pushl  0xc(%ebp)
f010fce9:	50                   	push   %eax
f010fcea:	e8 81 8b ff ff       	call   f0108870 <create_page_table>
f010fcef:	83 c4 10             	add    $0x10,%esp
f010fcf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fcf5:	90                   	nop
f010fcf6:	c9                   	leave  
f010fcf7:	c3                   	ret    

f010fcf8 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fcf8:	55                   	push   %ebp
f010fcf9:	89 e5                	mov    %esp,%ebp
f010fcfb:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fcfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fd05:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd08:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fd0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fd11:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd14:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fd1a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fd1d:	0f 86 74 01 00 00    	jbe    f010fe97 <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010fd23:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd26:	83 ec 08             	sub    $0x8,%esp
f010fd29:	50                   	push   %eax
f010fd2a:	ff 75 08             	pushl  0x8(%ebp)
f010fd2d:	e8 9d 49 ff ff       	call   f01046cf <pf_read_env_page>
f010fd32:	83 c4 10             	add    $0x10,%esp
f010fd35:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fd38:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fd3c:	75 45                	jne    f010fd83 <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fd3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd41:	85 c0                	test   %eax,%eax
f010fd43:	79 09                	jns    f010fd4e <page_fault_handler+0x56>
f010fd45:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fd4c:	76 35                	jbe    f010fd83 <page_fault_handler+0x8b>
f010fd4e:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fd55:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fd58:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fd5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fd60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd63:	ba 00 00 00 00       	mov    $0x0,%edx
f010fd68:	f7 75 e8             	divl   -0x18(%ebp)
f010fd6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd6e:	29 d0                	sub    %edx,%eax
f010fd70:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fd73:	77 09                	ja     f010fd7e <page_fault_handler+0x86>
f010fd75:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010fd7c:	76 05                	jbe    f010fd83 <page_fault_handler+0x8b>
			{
				env_exit();
f010fd7e:	e8 ab be ff ff       	call   f010bc2e <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010fd83:	83 ec 0c             	sub    $0xc,%esp
f010fd86:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010fd89:	50                   	push   %eax
f010fd8a:	e8 4e 87 ff ff       	call   f01084dd <allocate_frame>
f010fd8f:	83 c4 10             	add    $0x10,%esp
f010fd92:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fd95:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fd99:	74 34                	je     f010fdcf <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fd9b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010fd9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fda1:	8b 40 64             	mov    0x64(%eax),%eax
f010fda4:	6a 06                	push   $0x6
f010fda6:	ff 75 0c             	pushl  0xc(%ebp)
f010fda9:	52                   	push   %edx
f010fdaa:	50                   	push   %eax
f010fdab:	e8 fa 8b ff ff       	call   f01089aa <map_frame>
f010fdb0:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010fdb3:	83 ec 08             	sub    $0x8,%esp
f010fdb6:	ff 75 0c             	pushl  0xc(%ebp)
f010fdb9:	ff 75 08             	pushl  0x8(%ebp)
f010fdbc:	e8 69 a3 ff ff       	call   f010a12a <env_page_ws_list_create_element>
f010fdc1:	83 c4 10             	add    $0x10,%esp
f010fdc4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fdc7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fdcb:	75 30                	jne    f010fdfd <page_fault_handler+0x105>
f010fdcd:	eb 17                	jmp    f010fde6 <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010fdcf:	83 ec 04             	sub    $0x4,%esp
f010fdd2:	68 fc 7f 12 f0       	push   $0xf0127ffc
f010fdd7:	68 03 01 00 00       	push   $0x103
f010fddc:	68 73 7e 12 f0       	push   $0xf0127e73
f010fde1:	e8 53 05 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fde6:	83 ec 04             	sub    $0x4,%esp
f010fde9:	68 14 80 12 f0       	push   $0xf0128014
f010fdee:	68 05 01 00 00       	push   $0x105
f010fdf3:	68 73 7e 12 f0       	push   $0xf0127e73
f010fdf8:	e8 3c 05 ff ff       	call   f0100339 <_panic>
f010fdfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe00:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010fe06:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fe09:	89 50 14             	mov    %edx,0x14(%eax)
f010fe0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fe0f:	8b 40 14             	mov    0x14(%eax),%eax
f010fe12:	85 c0                	test   %eax,%eax
f010fe14:	74 11                	je     f010fe27 <page_fault_handler+0x12f>
f010fe16:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe19:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fe1f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fe22:	89 50 10             	mov    %edx,0x10(%eax)
f010fe25:	eb 0c                	jmp    f010fe33 <page_fault_handler+0x13b>
f010fe27:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe2a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fe2d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fe33:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe36:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fe39:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fe3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fe42:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010fe49:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe4c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fe52:	8d 50 01             	lea    0x1(%eax),%edx
f010fe55:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe58:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010fe5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe61:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010fe67:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe6a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fe70:	39 c2                	cmp    %eax,%edx
f010fe72:	75 14                	jne    f010fe88 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fe74:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe77:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fe7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe80:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fe86:	eb 26                	jmp    f010feae <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010fe88:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe8b:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010fe92:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fe95:	eb 17                	jmp    f010feae <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010fe97:	83 ec 04             	sub    $0x4,%esp
f010fe9a:	68 38 80 12 f0       	push   $0xf0128038
f010fe9f:	68 15 01 00 00       	push   $0x115
f010fea4:	68 73 7e 12 f0       	push   $0xf0127e73
f010fea9:	e8 8b 04 ff ff       	call   f0100339 <_panic>
	}
}
f010feae:	c9                   	leave  
f010feaf:	c3                   	ret    

f010feb0 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010feb0:	55                   	push   %ebp
f010feb1:	89 e5                	mov    %esp,%ebp
f010feb3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010feb6:	83 ec 04             	sub    $0x4,%esp
f010feb9:	68 78 80 12 f0       	push   $0xf0128078
f010febe:	68 1d 01 00 00       	push   $0x11d
f010fec3:	68 73 7e 12 f0       	push   $0xf0127e73
f010fec8:	e8 6c 04 ff ff       	call   f0100339 <_panic>

f010fecd <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010fecd:	55                   	push   %ebp
f010fece:	89 e5                	mov    %esp,%ebp
f010fed0:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fed3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fed6:	83 c0 04             	add    $0x4,%eax
f010fed9:	83 ec 08             	sub    $0x8,%esp
f010fedc:	ff 75 0c             	pushl  0xc(%ebp)
f010fedf:	50                   	push   %eax
f010fee0:	e8 16 00 01 00       	call   f011fefb <strcpy>
f010fee5:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fee8:	8b 45 08             	mov    0x8(%ebp),%eax
f010feeb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fef1:	8b 45 08             	mov    0x8(%ebp),%eax
f010fef4:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fefb:	90                   	nop
f010fefc:	c9                   	leave  
f010fefd:	c3                   	ret    

f010fefe <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010fefe:	55                   	push   %ebp
f010feff:	89 e5                	mov    %esp,%ebp
f010ff01:	53                   	push   %ebx
f010ff02:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010ff05:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff08:	83 ec 0c             	sub    $0xc,%esp
f010ff0b:	50                   	push   %eax
f010ff0c:	e8 06 02 00 00       	call   f0110117 <holding_spinlock>
f010ff11:	83 c4 10             	add    $0x10,%esp
f010ff14:	85 c0                	test   %eax,%eax
f010ff16:	74 18                	je     f010ff30 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010ff18:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff1b:	83 c0 04             	add    $0x4,%eax
f010ff1e:	50                   	push   %eax
f010ff1f:	68 bc 80 12 f0       	push   $0xf01280bc
f010ff24:	6a 1f                	push   $0x1f
f010ff26:	68 f9 80 12 f0       	push   $0xf01280f9
f010ff2b:	e8 09 04 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010ff30:	e8 c5 75 ff ff       	call   f01074fa <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010ff35:	90                   	nop
f010ff36:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff39:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ff3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010ff43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ff46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff49:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010ff4c:	f0 87 02             	lock xchg %eax,(%edx)
f010ff4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010ff52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff55:	85 c0                	test   %eax,%eax
f010ff57:	75 dd                	jne    f010ff36 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010ff59:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010ff5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ff61:	e8 d1 74 ff ff       	call   f0107437 <mycpu>
f010ff66:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010ff69:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff6c:	83 c0 48             	add    $0x48,%eax
f010ff6f:	83 ec 08             	sub    $0x8,%esp
f010ff72:	50                   	push   %eax
f010ff73:	8d 45 08             	lea    0x8(%ebp),%eax
f010ff76:	50                   	push   %eax
f010ff77:	e8 74 00 00 00       	call   f010fff0 <getcallerpcs>
f010ff7c:	83 c4 10             	add    $0x10,%esp

}
f010ff7f:	90                   	nop
f010ff80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ff83:	c9                   	leave  
f010ff84:	c3                   	ret    

f010ff85 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010ff85:	55                   	push   %ebp
f010ff86:	89 e5                	mov    %esp,%ebp
f010ff88:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010ff8b:	83 ec 0c             	sub    $0xc,%esp
f010ff8e:	ff 75 08             	pushl  0x8(%ebp)
f010ff91:	e8 81 01 00 00       	call   f0110117 <holding_spinlock>
f010ff96:	83 c4 10             	add    $0x10,%esp
f010ff99:	85 c0                	test   %eax,%eax
f010ff9b:	75 26                	jne    f010ffc3 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010ff9d:	83 ec 0c             	sub    $0xc,%esp
f010ffa0:	ff 75 08             	pushl  0x8(%ebp)
f010ffa3:	e8 08 01 00 00       	call   f01100b0 <printcallstack>
f010ffa8:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010ffab:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffae:	83 c0 04             	add    $0x4,%eax
f010ffb1:	50                   	push   %eax
f010ffb2:	68 10 81 12 f0       	push   $0xf0128110
f010ffb7:	6a 3c                	push   $0x3c
f010ffb9:	68 f9 80 12 f0       	push   $0xf01280f9
f010ffbe:	e8 76 03 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010ffc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffc6:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ffcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd0:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ffd7:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ffdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffdf:	8b 55 08             	mov    0x8(%ebp),%edx
f010ffe2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010ffe8:	e8 5f 75 ff ff       	call   f010754c <popcli>
}
f010ffed:	90                   	nop
f010ffee:	c9                   	leave  
f010ffef:	c3                   	ret    

f010fff0 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fff0:	55                   	push   %ebp
f010fff1:	89 e5                	mov    %esp,%ebp
f010fff3:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010fff6:	e8 75 bc ff ff       	call   f010bc70 <get_cpu_proc>
f010fffb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010fffe:	e8 34 74 ff ff       	call   f0107437 <mycpu>
f0110003:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f0110006:	8b 45 08             	mov    0x8(%ebp),%eax
f0110009:	83 e8 08             	sub    $0x8,%eax
f011000c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f011000f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110016:	eb 67                	jmp    f011007f <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f0110018:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011001c:	74 67                	je     f0110085 <getcallerpcs+0x95>
f011001e:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f0110025:	76 5e                	jbe    f0110085 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f0110027:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011002a:	8b 40 08             	mov    0x8(%eax),%eax
f011002d:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f0110032:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110035:	77 10                	ja     f0110047 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f0110037:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011003a:	8b 40 08             	mov    0x8(%eax),%eax
f011003d:	05 00 90 00 00       	add    $0x9000,%eax
f0110042:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110045:	77 3e                	ja     f0110085 <getcallerpcs+0x95>
f0110047:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011004b:	74 10                	je     f011005d <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f011004d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110050:	8b 40 70             	mov    0x70(%eax),%eax
f0110053:	05 00 80 00 00       	add    $0x8000,%eax
f0110058:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011005b:	76 28                	jbe    f0110085 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f011005d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110060:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110067:	8b 45 0c             	mov    0xc(%ebp),%eax
f011006a:	01 c2                	add    %eax,%edx
f011006c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011006f:	8b 40 04             	mov    0x4(%eax),%eax
f0110072:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f0110074:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110077:	8b 00                	mov    (%eax),%eax
f0110079:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f011007c:	ff 45 f0             	incl   -0x10(%ebp)
f011007f:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0110083:	7e 93                	jle    f0110018 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f0110085:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110088:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f011008b:	eb 18                	jmp    f01100a5 <getcallerpcs+0xb5>
		pcs[i] = 0;
f011008d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110090:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110097:	8b 45 0c             	mov    0xc(%ebp),%eax
f011009a:	01 d0                	add    %edx,%eax
f011009c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f01100a2:	ff 45 f0             	incl   -0x10(%ebp)
f01100a5:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f01100a9:	7e e2                	jle    f011008d <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f01100ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f01100ae:	c9                   	leave  
f01100af:	c3                   	ret    

f01100b0 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f01100b0:	55                   	push   %ebp
f01100b1:	89 e5                	mov    %esp,%ebp
f01100b3:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f01100b6:	83 ec 0c             	sub    $0xc,%esp
f01100b9:	68 4e 81 12 f0       	push   $0xf012814e
f01100be:	e8 c8 0e ff ff       	call   f0100f8b <cprintf>
f01100c3:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f01100c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01100c9:	83 c0 48             	add    $0x48,%eax
f01100cc:	83 ec 08             	sub    $0x8,%esp
f01100cf:	50                   	push   %eax
f01100d0:	8d 45 08             	lea    0x8(%ebp),%eax
f01100d3:	50                   	push   %eax
f01100d4:	e8 17 ff ff ff       	call   f010fff0 <getcallerpcs>
f01100d9:	83 c4 10             	add    $0x10,%esp
f01100dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f01100df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01100e6:	eb 24                	jmp    f011010c <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f01100e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01100eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01100ee:	83 c2 10             	add    $0x10,%edx
f01100f1:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f01100f5:	83 ec 04             	sub    $0x4,%esp
f01100f8:	50                   	push   %eax
f01100f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01100fc:	68 5e 81 12 f0       	push   $0xf012815e
f0110101:	e8 85 0e ff ff       	call   f0100f8b <cprintf>
f0110106:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f0110109:	ff 45 f4             	incl   -0xc(%ebp)
f011010c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011010f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0110112:	7c d4                	jl     f01100e8 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f0110114:	90                   	nop
f0110115:	c9                   	leave  
f0110116:	c3                   	ret    

f0110117 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f0110117:	55                   	push   %ebp
f0110118:	89 e5                	mov    %esp,%ebp
f011011a:	53                   	push   %ebx
f011011b:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f011011e:	e8 d7 73 ff ff       	call   f01074fa <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f0110123:	8b 45 08             	mov    0x8(%ebp),%eax
f0110126:	8b 00                	mov    (%eax),%eax
f0110128:	85 c0                	test   %eax,%eax
f011012a:	74 16                	je     f0110142 <holding_spinlock+0x2b>
f011012c:	8b 45 08             	mov    0x8(%ebp),%eax
f011012f:	8b 58 44             	mov    0x44(%eax),%ebx
f0110132:	e8 00 73 ff ff       	call   f0107437 <mycpu>
f0110137:	39 c3                	cmp    %eax,%ebx
f0110139:	75 07                	jne    f0110142 <holding_spinlock+0x2b>
f011013b:	b8 01 00 00 00       	mov    $0x1,%eax
f0110140:	eb 05                	jmp    f0110147 <holding_spinlock+0x30>
f0110142:	b8 00 00 00 00       	mov    $0x0,%eax
f0110147:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f011014a:	e8 fd 73 ff ff       	call   f010754c <popcli>
	return r;
f011014f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110152:	83 c4 14             	add    $0x14,%esp
f0110155:	5b                   	pop    %ebx
f0110156:	5d                   	pop    %ebp
f0110157:	c3                   	ret    

f0110158 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f0110158:	55                   	push   %ebp
f0110159:	89 e5                	mov    %esp,%ebp
f011015b:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f011015e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110161:	83 c0 74             	add    $0x74,%eax
f0110164:	83 ec 08             	sub    $0x8,%esp
f0110167:	68 6d 81 12 f0       	push   $0xf012816d
f011016c:	50                   	push   %eax
f011016d:	e8 4c 01 00 00       	call   f01102be <init_channel>
f0110172:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f0110175:	8b 45 08             	mov    0x8(%ebp),%eax
f0110178:	83 c0 04             	add    $0x4,%eax
f011017b:	83 ec 08             	sub    $0x8,%esp
f011017e:	68 80 81 12 f0       	push   $0xf0128180
f0110183:	50                   	push   %eax
f0110184:	e8 44 fd ff ff       	call   f010fecd <init_spinlock>
f0110189:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f011018c:	8b 45 08             	mov    0x8(%ebp),%eax
f011018f:	05 c4 00 00 00       	add    $0xc4,%eax
f0110194:	83 ec 08             	sub    $0x8,%esp
f0110197:	ff 75 0c             	pushl  0xc(%ebp)
f011019a:	50                   	push   %eax
f011019b:	e8 5b fd 00 00       	call   f011fefb <strcpy>
f01101a0:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f01101a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01101a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f01101ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01101af:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f01101b6:	00 00 00 
}
f01101b9:	90                   	nop
f01101ba:	c9                   	leave  
f01101bb:	c3                   	ret    

f01101bc <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f01101bc:	55                   	push   %ebp
f01101bd:	89 e5                	mov    %esp,%ebp
f01101bf:	53                   	push   %ebx
f01101c0:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f01101c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01101c6:	83 c0 04             	add    $0x4,%eax
f01101c9:	83 ec 0c             	sub    $0xc,%esp
f01101cc:	50                   	push   %eax
f01101cd:	e8 2c fd ff ff       	call   f010fefe <acquire_spinlock>
f01101d2:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f01101d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01101d8:	8b 00                	mov    (%eax),%eax
f01101da:	85 c0                	test   %eax,%eax
f01101dc:	74 1c                	je     f01101fa <holding_sleeplock+0x3e>
f01101de:	8b 45 08             	mov    0x8(%ebp),%eax
f01101e1:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f01101e7:	e8 84 ba ff ff       	call   f010bc70 <get_cpu_proc>
f01101ec:	8b 40 10             	mov    0x10(%eax),%eax
f01101ef:	39 c3                	cmp    %eax,%ebx
f01101f1:	75 07                	jne    f01101fa <holding_sleeplock+0x3e>
f01101f3:	b8 01 00 00 00       	mov    $0x1,%eax
f01101f8:	eb 05                	jmp    f01101ff <holding_sleeplock+0x43>
f01101fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01101ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f0110202:	8b 45 08             	mov    0x8(%ebp),%eax
f0110205:	83 c0 04             	add    $0x4,%eax
f0110208:	83 ec 0c             	sub    $0xc,%esp
f011020b:	50                   	push   %eax
f011020c:	e8 74 fd ff ff       	call   f010ff85 <release_spinlock>
f0110211:	83 c4 10             	add    $0x10,%esp
	return r;
f0110214:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110217:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011021a:	c9                   	leave  
f011021b:	c3                   	ret    

f011021c <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f011021c:	55                   	push   %ebp
f011021d:	89 e5                	mov    %esp,%ebp
f011021f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f0110222:	8b 45 08             	mov    0x8(%ebp),%eax
f0110225:	83 c0 04             	add    $0x4,%eax
f0110228:	83 ec 0c             	sub    $0xc,%esp
f011022b:	50                   	push   %eax
f011022c:	e8 cd fc ff ff       	call   f010fefe <acquire_spinlock>
f0110231:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f0110234:	eb 19                	jmp    f011024f <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f0110236:	8b 45 08             	mov    0x8(%ebp),%eax
f0110239:	8d 50 04             	lea    0x4(%eax),%edx
f011023c:	8b 45 08             	mov    0x8(%ebp),%eax
f011023f:	83 c0 74             	add    $0x74,%eax
f0110242:	83 ec 08             	sub    $0x8,%esp
f0110245:	52                   	push   %edx
f0110246:	50                   	push   %eax
f0110247:	e8 9f 00 00 00       	call   f01102eb <sleep>
f011024c:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f011024f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110252:	8b 00                	mov    (%eax),%eax
f0110254:	85 c0                	test   %eax,%eax
f0110256:	75 de                	jne    f0110236 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f0110258:	8b 45 08             	mov    0x8(%ebp),%eax
f011025b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f0110261:	8b 45 08             	mov    0x8(%ebp),%eax
f0110264:	83 c0 04             	add    $0x4,%eax
f0110267:	83 ec 0c             	sub    $0xc,%esp
f011026a:	50                   	push   %eax
f011026b:	e8 15 fd ff ff       	call   f010ff85 <release_spinlock>
f0110270:	83 c4 10             	add    $0x10,%esp

}
f0110273:	90                   	nop
f0110274:	c9                   	leave  
f0110275:	c3                   	ret    

f0110276 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f0110276:	55                   	push   %ebp
f0110277:	89 e5                	mov    %esp,%ebp
f0110279:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f011027c:	8b 45 08             	mov    0x8(%ebp),%eax
f011027f:	83 c0 04             	add    $0x4,%eax
f0110282:	83 ec 0c             	sub    $0xc,%esp
f0110285:	50                   	push   %eax
f0110286:	e8 73 fc ff ff       	call   f010fefe <acquire_spinlock>
f011028b:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f011028e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110291:	83 c0 74             	add    $0x74,%eax
f0110294:	83 ec 0c             	sub    $0xc,%esp
f0110297:	50                   	push   %eax
f0110298:	e8 3f 01 00 00       	call   f01103dc <wakeup_all>
f011029d:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f01102a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01102a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f01102a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01102ac:	83 c0 04             	add    $0x4,%eax
f01102af:	83 ec 0c             	sub    $0xc,%esp
f01102b2:	50                   	push   %eax
f01102b3:	e8 cd fc ff ff       	call   f010ff85 <release_spinlock>
f01102b8:	83 c4 10             	add    $0x10,%esp
}
f01102bb:	90                   	nop
f01102bc:	c9                   	leave  
f01102bd:	c3                   	ret    

f01102be <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f01102be:	55                   	push   %ebp
f01102bf:	89 e5                	mov    %esp,%ebp
f01102c1:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f01102c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01102c7:	83 c0 10             	add    $0x10,%eax
f01102ca:	83 ec 08             	sub    $0x8,%esp
f01102cd:	ff 75 0c             	pushl  0xc(%ebp)
f01102d0:	50                   	push   %eax
f01102d1:	e8 25 fc 00 00       	call   f011fefb <strcpy>
f01102d6:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f01102d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01102dc:	83 ec 0c             	sub    $0xc,%esp
f01102df:	50                   	push   %eax
f01102e0:	e8 72 4e ff ff       	call   f0105157 <init_queue>
f01102e5:	83 c4 10             	add    $0x10,%esp
}
f01102e8:	90                   	nop
f01102e9:	c9                   	leave  
f01102ea:	c3                   	ret    

f01102eb <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f01102eb:	55                   	push   %ebp
f01102ec:	89 e5                	mov    %esp,%ebp
f01102ee:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f01102f1:	83 ec 0c             	sub    $0xc,%esp
f01102f4:	68 80 f0 71 f0       	push   $0xf071f080
f01102f9:	e8 00 fc ff ff       	call   f010fefe <acquire_spinlock>
f01102fe:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f0110301:	e8 6a b9 ff ff       	call   f010bc70 <get_cpu_proc>
f0110306:	89 c2                	mov    %eax,%edx
f0110308:	8b 45 08             	mov    0x8(%ebp),%eax
f011030b:	83 ec 08             	sub    $0x8,%esp
f011030e:	52                   	push   %edx
f011030f:	50                   	push   %eax
f0110310:	e8 83 4e ff ff       	call   f0105198 <enqueue>
f0110315:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f0110318:	e8 53 b9 ff ff       	call   f010bc70 <get_cpu_proc>
f011031d:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f0110324:	83 ec 0c             	sub    $0xc,%esp
f0110327:	ff 75 0c             	pushl  0xc(%ebp)
f011032a:	e8 56 fc ff ff       	call   f010ff85 <release_spinlock>
f011032f:	83 c4 10             	add    $0x10,%esp
	sched();
f0110332:	e8 ba ba ff ff       	call   f010bdf1 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f0110337:	83 ec 0c             	sub    $0xc,%esp
f011033a:	68 80 f0 71 f0       	push   $0xf071f080
f011033f:	e8 41 fc ff ff       	call   f010ff85 <release_spinlock>
f0110344:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f0110347:	83 ec 0c             	sub    $0xc,%esp
f011034a:	ff 75 0c             	pushl  0xc(%ebp)
f011034d:	e8 ac fb ff ff       	call   f010fefe <acquire_spinlock>
f0110352:	83 c4 10             	add    $0x10,%esp
}
f0110355:	90                   	nop
f0110356:	c9                   	leave  
f0110357:	c3                   	ret    

f0110358 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f0110358:	55                   	push   %ebp
f0110359:	89 e5                	mov    %esp,%ebp
f011035b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f011035e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110361:	83 ec 0c             	sub    $0xc,%esp
f0110364:	50                   	push   %eax
f0110365:	e8 16 4e ff ff       	call   f0105180 <queue_size>
f011036a:	83 c4 10             	add    $0x10,%esp
f011036d:	85 c0                	test   %eax,%eax
f011036f:	74 68                	je     f01103d9 <wakeup_one+0x81>
		bool locked_by_me = 0;
f0110371:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f0110378:	83 ec 0c             	sub    $0xc,%esp
f011037b:	68 80 f0 71 f0       	push   $0xf071f080
f0110380:	e8 92 fd ff ff       	call   f0110117 <holding_spinlock>
f0110385:	83 c4 10             	add    $0x10,%esp
f0110388:	85 c0                	test   %eax,%eax
f011038a:	75 17                	jne    f01103a3 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f011038c:	83 ec 0c             	sub    $0xc,%esp
f011038f:	68 80 f0 71 f0       	push   $0xf071f080
f0110394:	e8 65 fb ff ff       	call   f010fefe <acquire_spinlock>
f0110399:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f011039c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f01103a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01103a6:	83 ec 0c             	sub    $0xc,%esp
f01103a9:	50                   	push   %eax
f01103aa:	e8 7a 4e ff ff       	call   f0105229 <dequeue>
f01103af:	83 c4 10             	add    $0x10,%esp
f01103b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f01103b5:	83 ec 0c             	sub    $0xc,%esp
f01103b8:	ff 75 f0             	pushl  -0x10(%ebp)
f01103bb:	e8 a4 50 ff ff       	call   f0105464 <sched_insert_ready0>
f01103c0:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f01103c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01103c7:	74 10                	je     f01103d9 <wakeup_one+0x81>
f01103c9:	83 ec 0c             	sub    $0xc,%esp
f01103cc:	68 80 f0 71 f0       	push   $0xf071f080
f01103d1:	e8 af fb ff ff       	call   f010ff85 <release_spinlock>
f01103d6:	83 c4 10             	add    $0x10,%esp
	}
}
f01103d9:	90                   	nop
f01103da:	c9                   	leave  
f01103db:	c3                   	ret    

f01103dc <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01103dc:	55                   	push   %ebp
f01103dd:	89 e5                	mov    %esp,%ebp
f01103df:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f01103e2:	83 ec 0c             	sub    $0xc,%esp
f01103e5:	68 80 f0 71 f0       	push   $0xf071f080
f01103ea:	e8 0f fb ff ff       	call   f010fefe <acquire_spinlock>
f01103ef:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f01103f2:	eb 0e                	jmp    f0110402 <wakeup_all+0x26>
		wakeup_one(chan);
f01103f4:	83 ec 0c             	sub    $0xc,%esp
f01103f7:	ff 75 08             	pushl  0x8(%ebp)
f01103fa:	e8 59 ff ff ff       	call   f0110358 <wakeup_one>
f01103ff:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f0110402:	8b 45 08             	mov    0x8(%ebp),%eax
f0110405:	83 ec 0c             	sub    $0xc,%esp
f0110408:	50                   	push   %eax
f0110409:	e8 72 4d ff ff       	call   f0105180 <queue_size>
f011040e:	83 c4 10             	add    $0x10,%esp
f0110411:	85 c0                	test   %eax,%eax
f0110413:	75 df                	jne    f01103f4 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f0110415:	83 ec 0c             	sub    $0xc,%esp
f0110418:	68 80 f0 71 f0       	push   $0xf071f080
f011041d:	e8 63 fb ff ff       	call   f010ff85 <release_spinlock>
f0110422:	83 c4 10             	add    $0x10,%esp
}
f0110425:	90                   	nop
f0110426:	c9                   	leave  
f0110427:	c3                   	ret    

f0110428 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110428:	55                   	push   %ebp
f0110429:	89 e5                	mov    %esp,%ebp
f011042b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f011042e:	83 ec 04             	sub    $0x4,%esp
f0110431:	68 94 81 12 f0       	push   $0xf0128194
f0110436:	6a 13                	push   $0x13
f0110438:	68 bb 81 12 f0       	push   $0xf01281bb
f011043d:	e8 f7 fe fe ff       	call   f0100339 <_panic>

f0110442 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110442:	55                   	push   %ebp
f0110443:	89 e5                	mov    %esp,%ebp
f0110445:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f0110448:	83 ec 04             	sub    $0x4,%esp
f011044b:	68 d4 81 12 f0       	push   $0xf01281d4
f0110450:	6a 1b                	push   $0x1b
f0110452:	68 bb 81 12 f0       	push   $0xf01281bb
f0110457:	e8 dd fe fe ff       	call   f0100339 <_panic>

f011045c <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f011045c:	55                   	push   %ebp
f011045d:	89 e5                	mov    %esp,%ebp
f011045f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f0110462:	83 ec 04             	sub    $0x4,%esp
f0110465:	68 fc 81 12 f0       	push   $0xf01281fc
f011046a:	6a 24                	push   $0x24
f011046c:	68 bb 81 12 f0       	push   $0xf01281bb
f0110471:	e8 c3 fe fe ff       	call   f0100339 <_panic>

f0110476 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0110476:	55                   	push   %ebp
f0110477:	89 e5                	mov    %esp,%ebp
f0110479:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0110480:	00 00 00 
f0110483:	90                   	nop
f0110484:	5d                   	pop    %ebp
f0110485:	c3                   	ret    

f0110486 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0110486:	55                   	push   %ebp
f0110487:	89 e5                	mov    %esp,%ebp
f0110489:	c7 05 18 f6 b1 f0 02 	movl   $0x2,0xf0b1f618
f0110490:	00 00 00 
f0110493:	90                   	nop
f0110494:	5d                   	pop    %ebp
f0110495:	c3                   	ret    

f0110496 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0110496:	55                   	push   %ebp
f0110497:	89 e5                	mov    %esp,%ebp
f0110499:	c7 05 18 f6 b1 f0 03 	movl   $0x3,0xf0b1f618
f01104a0:	00 00 00 
f01104a3:	90                   	nop
f01104a4:	5d                   	pop    %ebp
f01104a5:	c3                   	ret    

f01104a6 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01104a6:	55                   	push   %ebp
f01104a7:	89 e5                	mov    %esp,%ebp
f01104a9:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f01104ae:	83 f8 01             	cmp    $0x1,%eax
f01104b1:	75 04                	jne    f01104b7 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01104b3:	b0 01                	mov    $0x1,%al
f01104b5:	eb 02                	jmp    f01104b9 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01104b7:	b0 00                	mov    $0x0,%al
f01104b9:	5d                   	pop    %ebp
f01104ba:	c3                   	ret    

f01104bb <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01104bb:	55                   	push   %ebp
f01104bc:	89 e5                	mov    %esp,%ebp
f01104be:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f01104c3:	83 f8 02             	cmp    $0x2,%eax
f01104c6:	75 04                	jne    f01104cc <isKHeapPlacementStrategyBESTFIT+0x11>
f01104c8:	b0 01                	mov    $0x1,%al
f01104ca:	eb 02                	jmp    f01104ce <isKHeapPlacementStrategyBESTFIT+0x13>
f01104cc:	b0 00                	mov    $0x0,%al
f01104ce:	5d                   	pop    %ebp
f01104cf:	c3                   	ret    

f01104d0 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01104d0:	55                   	push   %ebp
f01104d1:	89 e5                	mov    %esp,%ebp
f01104d3:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f01104d8:	83 f8 03             	cmp    $0x3,%eax
f01104db:	75 04                	jne    f01104e1 <isKHeapPlacementStrategyNEXTFIT+0x11>
f01104dd:	b0 01                	mov    $0x1,%al
f01104df:	eb 02                	jmp    f01104e3 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01104e1:	b0 00                	mov    $0x0,%al
f01104e3:	5d                   	pop    %ebp
f01104e4:	c3                   	ret    

f01104e5 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f01104e5:	55                   	push   %ebp
f01104e6:	89 e5                	mov    %esp,%ebp
f01104e8:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f01104eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01104f2:	eb 26                	jmp    f011051a <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f01104f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01104fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110501:	01 c2                	add    %eax,%edx
f0110503:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110506:	40                   	inc    %eax
f0110507:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011050e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110511:	01 c8                	add    %ecx,%eax
f0110513:	8b 00                	mov    (%eax),%eax
f0110515:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110517:	ff 45 f4             	incl   -0xc(%ebp)
f011051a:	8b 45 08             	mov    0x8(%ebp),%eax
f011051d:	48                   	dec    %eax
f011051e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110521:	7f d1                	jg     f01104f4 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f0110523:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110526:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f011052d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110534:	eb 35                	jmp    f011056b <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f0110536:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110539:	89 d0                	mov    %edx,%eax
f011053b:	01 c0                	add    %eax,%eax
f011053d:	01 d0                	add    %edx,%eax
f011053f:	c1 e0 02             	shl    $0x2,%eax
f0110542:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0110547:	8b 10                	mov    (%eax),%edx
f0110549:	8b 45 0c             	mov    0xc(%ebp),%eax
f011054c:	8b 00                	mov    (%eax),%eax
f011054e:	83 ec 08             	sub    $0x8,%esp
f0110551:	52                   	push   %edx
f0110552:	50                   	push   %eax
f0110553:	e8 60 fa 00 00       	call   f011ffb8 <strcmp>
f0110558:	83 c4 10             	add    $0x10,%esp
f011055b:	85 c0                	test   %eax,%eax
f011055d:	75 09                	jne    f0110568 <tst_handler+0x83>
		{
			test_found = 1;
f011055f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f0110566:	eb 0f                	jmp    f0110577 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110568:	ff 45 ec             	incl   -0x14(%ebp)
f011056b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011056e:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f0110573:	39 c2                	cmp    %eax,%edx
f0110575:	72 bf                	jb     f0110536 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f0110577:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011057b:	74 29                	je     f01105a6 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f011057d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110580:	89 d0                	mov    %edx,%eax
f0110582:	01 c0                	add    %eax,%eax
f0110584:	01 d0                	add    %edx,%eax
f0110586:	c1 e0 02             	shl    $0x2,%eax
f0110589:	05 68 0d 18 f0       	add    $0xf0180d68,%eax
f011058e:	8b 00                	mov    (%eax),%eax
f0110590:	83 ec 08             	sub    $0x8,%esp
f0110593:	ff 75 0c             	pushl  0xc(%ebp)
f0110596:	ff 75 08             	pushl  0x8(%ebp)
f0110599:	ff d0                	call   *%eax
f011059b:	83 c4 10             	add    $0x10,%esp
f011059e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f01105a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01105a4:	eb 1b                	jmp    f01105c1 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f01105a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105a9:	8b 00                	mov    (%eax),%eax
f01105ab:	83 ec 08             	sub    $0x8,%esp
f01105ae:	50                   	push   %eax
f01105af:	68 3c 85 12 f0       	push   $0xf012853c
f01105b4:	e8 d2 09 ff ff       	call   f0100f8b <cprintf>
f01105b9:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105bc:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f01105c1:	c9                   	leave  
f01105c2:	c3                   	ret    

f01105c3 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f01105c3:	55                   	push   %ebp
f01105c4:	89 e5                	mov    %esp,%ebp
f01105c6:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f01105c9:	e8 69 d0 00 00       	call   f011d637 <test_three_creation_functions>
	return 0;
f01105ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105d3:	c9                   	leave  
f01105d4:	c3                   	ret    

f01105d5 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f01105d5:	55                   	push   %ebp
f01105d6:	89 e5                	mov    %esp,%ebp
f01105d8:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f01105db:	e8 03 69 00 00       	call   f0116ee3 <test_priority_normal_and_higher>
	return 0;
f01105e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105e5:	c9                   	leave  
f01105e6:	c3                   	ret    

f01105e7 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f01105e7:	55                   	push   %ebp
f01105e8:	89 e5                	mov    %esp,%ebp
f01105ea:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f01105ed:	e8 0b 69 00 00       	call   f0116efd <test_priority_normal_and_lower>
	return 0;
f01105f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105f7:	c9                   	leave  
f01105f8:	c3                   	ret    

f01105f9 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f01105f9:	55                   	push   %ebp
f01105fa:	89 e5                	mov    %esp,%ebp
f01105fc:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f01105ff:	e8 e6 d1 00 00       	call   f011d7ea <test_kfreeall>
	return 0;
f0110604:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110609:	c9                   	leave  
f011060a:	c3                   	ret    

f011060b <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011060b:	55                   	push   %ebp
f011060c:	89 e5                	mov    %esp,%ebp
f011060e:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110611:	e8 f1 d1 00 00       	call   f011d807 <test_kexpand>
	return 0;
f0110616:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011061b:	c9                   	leave  
f011061c:	c3                   	ret    

f011061d <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f011061d:	55                   	push   %ebp
f011061e:	89 e5                	mov    %esp,%ebp
f0110620:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f0110623:	e8 fc d1 00 00       	call   f011d824 <test_kshrink>
	return 0;
f0110628:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011062d:	c9                   	leave  
f011062e:	c3                   	ret    

f011062f <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f011062f:	55                   	push   %ebp
f0110630:	89 e5                	mov    %esp,%ebp
f0110632:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f0110635:	e8 07 d2 00 00       	call   f011d841 <test_kfreelast>
	return 0;
f011063a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011063f:	c9                   	leave  
f0110640:	c3                   	ret    

f0110641 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f0110641:	55                   	push   %ebp
f0110642:	89 e5                	mov    %esp,%ebp
f0110644:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f0110647:	8b 45 0c             	mov    0xc(%ebp),%eax
f011064a:	83 c0 04             	add    $0x4,%eax
f011064d:	8b 00                	mov    (%eax),%eax
f011064f:	83 ec 04             	sub    $0x4,%esp
f0110652:	6a 0a                	push   $0xa
f0110654:	6a 00                	push   $0x0
f0110656:	50                   	push   %eax
f0110657:	e8 b0 fb 00 00       	call   f012020c <strtol>
f011065c:	83 c4 10             	add    $0x10,%esp
f011065f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f0110662:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f0110669:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f0110670:	83 ec 0c             	sub    $0xc,%esp
f0110673:	68 80 f0 71 f0       	push   $0xf071f080
f0110678:	e8 81 f8 ff ff       	call   f010fefe <acquire_spinlock>
f011067d:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110680:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0110685:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110688:	eb 3b                	jmp    f01106c5 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f011068a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011068d:	83 c0 20             	add    $0x20,%eax
f0110690:	83 ec 08             	sub    $0x8,%esp
f0110693:	68 4f 85 12 f0       	push   $0xf012854f
f0110698:	50                   	push   %eax
f0110699:	e8 1a f9 00 00       	call   f011ffb8 <strcmp>
f011069e:	83 c4 10             	add    $0x10,%esp
f01106a1:	85 c0                	test   %eax,%eax
f01106a3:	75 12                	jne    f01106b7 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f01106a5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01106a9:	74 07                	je     f01106b2 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f01106ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f01106b2:	ff 45 f4             	incl   -0xc(%ebp)
f01106b5:	eb 06                	jmp    f01106bd <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f01106b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01106bb:	74 31                	je     f01106ee <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01106bd:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f01106c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01106c5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01106c9:	74 08                	je     f01106d3 <tst_sc_MLFQ+0x92>
f01106cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01106ce:	8b 40 08             	mov    0x8(%eax),%eax
f01106d1:	eb 05                	jmp    f01106d8 <tst_sc_MLFQ+0x97>
f01106d3:	b8 00 00 00 00       	mov    $0x0,%eax
f01106d8:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f01106dd:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f01106e2:	85 c0                	test   %eax,%eax
f01106e4:	75 a4                	jne    f011068a <tst_sc_MLFQ+0x49>
f01106e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01106ea:	75 9e                	jne    f011068a <tst_sc_MLFQ+0x49>
f01106ec:	eb 01                	jmp    f01106ef <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f01106ee:	90                   	nop
			}
		if(cnt == numOfSlave2)
f01106ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01106f2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01106f5:	75 12                	jne    f0110709 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f01106f7:	83 ec 0c             	sub    $0xc,%esp
f01106fa:	68 58 85 12 f0       	push   $0xf0128558
f01106ff:	e8 87 08 ff ff       	call   f0100f8b <cprintf>
f0110704:	83 c4 10             	add    $0x10,%esp
f0110707:	eb 17                	jmp    f0110720 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0110709:	83 ec 04             	sub    $0x4,%esp
f011070c:	68 91 85 12 f0       	push   $0xf0128591
f0110711:	68 9b 00 00 00       	push   $0x9b
f0110716:	68 a7 85 12 f0       	push   $0xf01285a7
f011071b:	e8 19 fc fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0110720:	83 ec 0c             	sub    $0xc,%esp
f0110723:	68 80 f0 71 f0       	push   $0xf071f080
f0110728:	e8 58 f8 ff ff       	call   f010ff85 <release_spinlock>
f011072d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110730:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110735:	c9                   	leave  
f0110736:	c3                   	ret    

f0110737 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f0110737:	55                   	push   %ebp
f0110738:	89 e5                	mov    %esp,%ebp
f011073a:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f011073d:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110741:	74 17                	je     f011075a <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f0110743:	83 ec 0c             	sub    $0xc,%esp
f0110746:	68 c0 85 12 f0       	push   $0xf01285c0
f011074b:	e8 3b 08 ff ff       	call   f0100f8b <cprintf>
f0110750:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110753:	b8 00 00 00 00       	mov    $0x0,%eax
f0110758:	eb 45                	jmp    f011079f <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f011075a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011075d:	83 c0 04             	add    $0x4,%eax
f0110760:	8b 00                	mov    (%eax),%eax
f0110762:	83 ec 04             	sub    $0x4,%esp
f0110765:	6a 0a                	push   $0xa
f0110767:	6a 00                	push   $0x0
f0110769:	50                   	push   %eax
f011076a:	e8 9d fa 00 00       	call   f012020c <strtol>
f011076f:	83 c4 10             	add    $0x10,%esp
f0110772:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0110775:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110778:	83 f8 01             	cmp    $0x1,%eax
f011077b:	74 10                	je     f011078d <tst_bsd_nice+0x56>
f011077d:	83 f8 02             	cmp    $0x2,%eax
f0110780:	74 12                	je     f0110794 <tst_bsd_nice+0x5d>
f0110782:	85 c0                	test   %eax,%eax
f0110784:	75 14                	jne    f011079a <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f0110786:	e8 b9 d2 00 00       	call   f011da44 <test_bsd_nice_0>
		break;
f011078b:	eb 0d                	jmp    f011079a <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f011078d:	e8 3c d5 00 00       	call   f011dcce <test_bsd_nice_1>
		break;
f0110792:	eb 06                	jmp    f011079a <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110794:	e8 49 d7 00 00       	call   f011dee2 <test_bsd_nice_2>
		break;
f0110799:	90                   	nop
	}
	return 0;
f011079a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011079f:	c9                   	leave  
f01107a0:	c3                   	ret    

f01107a1 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f01107a1:	55                   	push   %ebp
f01107a2:	89 e5                	mov    %esp,%ebp
f01107a4:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f01107a7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01107ab:	74 17                	je     f01107c4 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f01107ad:	83 ec 0c             	sub    $0xc,%esp
f01107b0:	68 00 86 12 f0       	push   $0xf0128600
f01107b5:	e8 d1 07 ff ff       	call   f0100f8b <cprintf>
f01107ba:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01107c2:	eb 0a                	jmp    f01107ce <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01107c4:	e8 3f 15 00 00       	call   f0111d08 <test_str2lower_function>
	return 0;
f01107c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01107ce:	c9                   	leave  
f01107cf:	c3                   	ret    

f01107d0 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01107d0:	55                   	push   %ebp
f01107d1:	89 e5                	mov    %esp,%ebp
f01107d3:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01107d6:	e8 63 11 00 00       	call   f011193e <TestAutoCompleteCommand>
f01107db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01107de:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01107e3:	c9                   	leave  
f01107e4:	c3                   	ret    

f01107e5 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01107e5:	55                   	push   %ebp
f01107e6:	89 e5                	mov    %esp,%ebp
f01107e8:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01107eb:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01107ef:	74 1a                	je     f011080b <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01107f1:	83 ec 0c             	sub    $0xc,%esp
f01107f4:	68 34 86 12 f0       	push   $0xf0128634
f01107f9:	e8 8d 07 ff ff       	call   f0100f8b <cprintf>
f01107fe:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110801:	b8 00 00 00 00       	mov    $0x0,%eax
f0110806:	e9 2f 01 00 00       	jmp    f011093a <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f011080b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011080e:	83 c0 04             	add    $0x4,%eax
f0110811:	8b 00                	mov    (%eax),%eax
f0110813:	83 ec 08             	sub    $0x8,%esp
f0110816:	68 71 86 12 f0       	push   $0xf0128671
f011081b:	50                   	push   %eax
f011081c:	e8 97 f7 00 00       	call   f011ffb8 <strcmp>
f0110821:	83 c4 10             	add    $0x10,%esp
f0110824:	85 c0                	test   %eax,%eax
f0110826:	75 0a                	jne    f0110832 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0110828:	e8 40 08 00 00       	call   f011106d <test_initialize_dynamic_allocator>
f011082d:	e9 03 01 00 00       	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f0110832:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110835:	83 c0 04             	add    $0x4,%eax
f0110838:	8b 00                	mov    (%eax),%eax
f011083a:	83 ec 08             	sub    $0x8,%esp
f011083d:	68 76 86 12 f0       	push   $0xf0128676
f0110842:	50                   	push   %eax
f0110843:	e8 70 f7 00 00       	call   f011ffb8 <strcmp>
f0110848:	83 c4 10             	add    $0x10,%esp
f011084b:	85 c0                	test   %eax,%eax
f011084d:	75 0a                	jne    f0110859 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f011084f:	e8 4d 08 00 00       	call   f01110a1 <test_alloc_block_FF>
f0110854:	e9 dc 00 00 00       	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f0110859:	8b 45 0c             	mov    0xc(%ebp),%eax
f011085c:	83 c0 04             	add    $0x4,%eax
f011085f:	8b 00                	mov    (%eax),%eax
f0110861:	83 ec 08             	sub    $0x8,%esp
f0110864:	68 7e 86 12 f0       	push   $0xf012867e
f0110869:	50                   	push   %eax
f011086a:	e8 49 f7 00 00       	call   f011ffb8 <strcmp>
f011086f:	83 c4 10             	add    $0x10,%esp
f0110872:	85 c0                	test   %eax,%eax
f0110874:	75 0a                	jne    f0110880 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f0110876:	e8 43 08 00 00       	call   f01110be <test_alloc_block_BF>
f011087b:	e9 b5 00 00 00       	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f0110880:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110883:	83 c0 04             	add    $0x4,%eax
f0110886:	8b 00                	mov    (%eax),%eax
f0110888:	83 ec 08             	sub    $0x8,%esp
f011088b:	68 86 86 12 f0       	push   $0xf0128686
f0110890:	50                   	push   %eax
f0110891:	e8 22 f7 00 00       	call   f011ffb8 <strcmp>
f0110896:	83 c4 10             	add    $0x10,%esp
f0110899:	85 c0                	test   %eax,%eax
f011089b:	75 0a                	jne    f01108a7 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f011089d:	e8 3c 08 00 00       	call   f01110de <test_alloc_block_NF>
f01108a2:	e9 8e 00 00 00       	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f01108a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108aa:	83 c0 04             	add    $0x4,%eax
f01108ad:	8b 00                	mov    (%eax),%eax
f01108af:	83 ec 08             	sub    $0x8,%esp
f01108b2:	68 8e 86 12 f0       	push   $0xf012868e
f01108b7:	50                   	push   %eax
f01108b8:	e8 fb f6 00 00       	call   f011ffb8 <strcmp>
f01108bd:	83 c4 10             	add    $0x10,%esp
f01108c0:	85 c0                	test   %eax,%eax
f01108c2:	75 07                	jne    f01108cb <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f01108c4:	e8 1b 08 00 00       	call   f01110e4 <test_free_block_FF>
f01108c9:	eb 6a                	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f01108cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108ce:	83 c0 04             	add    $0x4,%eax
f01108d1:	8b 00                	mov    (%eax),%eax
f01108d3:	83 ec 08             	sub    $0x8,%esp
f01108d6:	68 95 86 12 f0       	push   $0xf0128695
f01108db:	50                   	push   %eax
f01108dc:	e8 d7 f6 00 00       	call   f011ffb8 <strcmp>
f01108e1:	83 c4 10             	add    $0x10,%esp
f01108e4:	85 c0                	test   %eax,%eax
f01108e6:	75 07                	jne    f01108ef <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f01108e8:	e8 14 08 00 00       	call   f0111101 <test_free_block_BF>
f01108ed:	eb 46                	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f01108ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108f2:	83 c0 04             	add    $0x4,%eax
f01108f5:	8b 00                	mov    (%eax),%eax
f01108f7:	83 ec 08             	sub    $0x8,%esp
f01108fa:	68 9c 86 12 f0       	push   $0xf012869c
f01108ff:	50                   	push   %eax
f0110900:	e8 b3 f6 00 00       	call   f011ffb8 <strcmp>
f0110905:	83 c4 10             	add    $0x10,%esp
f0110908:	85 c0                	test   %eax,%eax
f011090a:	75 07                	jne    f0110913 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f011090c:	e8 0d 08 00 00       	call   f011111e <test_free_block_NF>
f0110911:	eb 22                	jmp    f0110935 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f0110913:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110916:	83 c0 04             	add    $0x4,%eax
f0110919:	8b 00                	mov    (%eax),%eax
f011091b:	83 ec 08             	sub    $0x8,%esp
f011091e:	68 a3 86 12 f0       	push   $0xf01286a3
f0110923:	50                   	push   %eax
f0110924:	e8 8f f6 00 00       	call   f011ffb8 <strcmp>
f0110929:	83 c4 10             	add    $0x10,%esp
f011092c:	85 c0                	test   %eax,%eax
f011092e:	75 05                	jne    f0110935 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0110930:	e8 06 08 00 00       	call   f011113b <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f0110935:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011093a:	c9                   	leave  
f011093b:	c3                   	ret    

f011093c <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f011093c:	55                   	push   %ebp
f011093d:	89 e5                	mov    %esp,%ebp
f011093f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110942:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110946:	74 1a                	je     f0110962 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0110948:	83 ec 0c             	sub    $0xc,%esp
f011094b:	68 b0 86 12 f0       	push   $0xf01286b0
f0110950:	e8 36 06 ff ff       	call   f0100f8b <cprintf>
f0110955:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110958:	b8 00 00 00 00       	mov    $0x0,%eax
f011095d:	e9 e1 00 00 00       	jmp    f0110a43 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f0110962:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110965:	83 c0 04             	add    $0x4,%eax
f0110968:	8b 00                	mov    (%eax),%eax
f011096a:	83 ec 08             	sub    $0x8,%esp
f011096d:	68 e9 86 12 f0       	push   $0xf01286e9
f0110972:	50                   	push   %eax
f0110973:	e8 40 f6 00 00       	call   f011ffb8 <strcmp>
f0110978:	83 c4 10             	add    $0x10,%esp
f011097b:	85 c0                	test   %eax,%eax
f011097d:	75 0a                	jne    f0110989 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f011097f:	e8 97 1c 00 00       	call   f011261b <test_cut_paste_pages>
f0110984:	e9 b5 00 00 00       	jmp    f0110a3e <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f0110989:	8b 45 0c             	mov    0xc(%ebp),%eax
f011098c:	83 c0 04             	add    $0x4,%eax
f011098f:	8b 00                	mov    (%eax),%eax
f0110991:	83 ec 08             	sub    $0x8,%esp
f0110994:	68 f2 86 12 f0       	push   $0xf01286f2
f0110999:	50                   	push   %eax
f011099a:	e8 19 f6 00 00       	call   f011ffb8 <strcmp>
f011099f:	83 c4 10             	add    $0x10,%esp
f01109a2:	85 c0                	test   %eax,%eax
f01109a4:	75 0a                	jne    f01109b0 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01109a6:	e8 bb 26 00 00       	call   f0113066 <test_copy_paste_chunk>
f01109ab:	e9 8e 00 00 00       	jmp    f0110a3e <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01109b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109b3:	83 c0 04             	add    $0x4,%eax
f01109b6:	8b 00                	mov    (%eax),%eax
f01109b8:	83 ec 08             	sub    $0x8,%esp
f01109bb:	68 fc 86 12 f0       	push   $0xf01286fc
f01109c0:	50                   	push   %eax
f01109c1:	e8 f2 f5 00 00       	call   f011ffb8 <strcmp>
f01109c6:	83 c4 10             	add    $0x10,%esp
f01109c9:	85 c0                	test   %eax,%eax
f01109cb:	75 07                	jne    f01109d4 <tst_chunks+0x98>
	{
		test_share_chunk();
f01109cd:	e8 92 37 00 00       	call   f0114164 <test_share_chunk>
f01109d2:	eb 6a                	jmp    f0110a3e <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01109d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109d7:	83 c0 04             	add    $0x4,%eax
f01109da:	8b 00                	mov    (%eax),%eax
f01109dc:	83 ec 08             	sub    $0x8,%esp
f01109df:	68 02 87 12 f0       	push   $0xf0128702
f01109e4:	50                   	push   %eax
f01109e5:	e8 ce f5 00 00       	call   f011ffb8 <strcmp>
f01109ea:	83 c4 10             	add    $0x10,%esp
f01109ed:	85 c0                	test   %eax,%eax
f01109ef:	75 07                	jne    f01109f8 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f01109f1:	e8 96 41 00 00       	call   f0114b8c <test_allocate_chunk>
f01109f6:	eb 46                	jmp    f0110a3e <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f01109f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109fb:	83 c0 04             	add    $0x4,%eax
f01109fe:	8b 00                	mov    (%eax),%eax
f0110a00:	83 ec 08             	sub    $0x8,%esp
f0110a03:	68 0b 87 12 f0       	push   $0xf012870b
f0110a08:	50                   	push   %eax
f0110a09:	e8 aa f5 00 00       	call   f011ffb8 <strcmp>
f0110a0e:	83 c4 10             	add    $0x10,%esp
f0110a11:	85 c0                	test   %eax,%eax
f0110a13:	75 07                	jne    f0110a1c <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110a15:	e8 79 4a 00 00       	call   f0115493 <test_calculate_required_frames>
f0110a1a:	eb 22                	jmp    f0110a3e <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a1f:	83 c0 04             	add    $0x4,%eax
f0110a22:	8b 00                	mov    (%eax),%eax
f0110a24:	83 ec 08             	sub    $0x8,%esp
f0110a27:	68 1a 87 12 f0       	push   $0xf012871a
f0110a2c:	50                   	push   %eax
f0110a2d:	e8 86 f5 00 00       	call   f011ffb8 <strcmp>
f0110a32:	83 c4 10             	add    $0x10,%esp
f0110a35:	85 c0                	test   %eax,%eax
f0110a37:	75 05                	jne    f0110a3e <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110a39:	e8 c9 52 00 00       	call   f0115d07 <test_calculate_allocated_space>
	}
	return 0;
f0110a3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110a43:	c9                   	leave  
f0110a44:	c3                   	ret    

f0110a45 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110a45:	55                   	push   %ebp
f0110a46:	89 e5                	mov    %esp,%ebp
f0110a48:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110a4b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110a4f:	74 1a                	je     f0110a6b <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110a51:	83 ec 0c             	sub    $0xc,%esp
f0110a54:	68 2c 87 12 f0       	push   $0xf012872c
f0110a59:	e8 2d 05 ff ff       	call   f0100f8b <cprintf>
f0110a5e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a61:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a66:	e9 ba 00 00 00       	jmp    f0110b25 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a6e:	83 c0 04             	add    $0x4,%eax
f0110a71:	8b 00                	mov    (%eax),%eax
f0110a73:	83 ec 08             	sub    $0x8,%esp
f0110a76:	68 62 87 12 f0       	push   $0xf0128762
f0110a7b:	50                   	push   %eax
f0110a7c:	e8 37 f5 00 00       	call   f011ffb8 <strcmp>
f0110a81:	83 c4 10             	add    $0x10,%esp
f0110a84:	85 c0                	test   %eax,%eax
f0110a86:	75 0a                	jne    f0110a92 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f0110a88:	e8 01 16 00 00       	call   f011208e <test_pt_set_page_permissions>
f0110a8d:	e9 8e 00 00 00       	jmp    f0110b20 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f0110a92:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a95:	83 c0 04             	add    $0x4,%eax
f0110a98:	8b 00                	mov    (%eax),%eax
f0110a9a:	83 ec 08             	sub    $0x8,%esp
f0110a9d:	68 6a 87 12 f0       	push   $0xf012876a
f0110aa2:	50                   	push   %eax
f0110aa3:	e8 10 f5 00 00       	call   f011ffb8 <strcmp>
f0110aa8:	83 c4 10             	add    $0x10,%esp
f0110aab:	85 c0                	test   %eax,%eax
f0110aad:	75 07                	jne    f0110ab6 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f0110aaf:	e8 49 18 00 00       	call   f01122fd <test_pt_set_page_permissions_invalid_va>
f0110ab4:	eb 6a                	jmp    f0110b20 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab9:	83 c0 04             	add    $0x4,%eax
f0110abc:	8b 00                	mov    (%eax),%eax
f0110abe:	83 ec 08             	sub    $0x8,%esp
f0110ac1:	68 72 87 12 f0       	push   $0xf0128772
f0110ac6:	50                   	push   %eax
f0110ac7:	e8 ec f4 00 00       	call   f011ffb8 <strcmp>
f0110acc:	83 c4 10             	add    $0x10,%esp
f0110acf:	85 c0                	test   %eax,%eax
f0110ad1:	75 07                	jne    f0110ada <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f0110ad3:	e8 6e 18 00 00       	call   f0112346 <test_pt_get_page_permissions>
f0110ad8:	eb 46                	jmp    f0110b20 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f0110ada:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110add:	83 c0 04             	add    $0x4,%eax
f0110ae0:	8b 00                	mov    (%eax),%eax
f0110ae2:	83 ec 08             	sub    $0x8,%esp
f0110ae5:	68 7a 87 12 f0       	push   $0xf012877a
f0110aea:	50                   	push   %eax
f0110aeb:	e8 c8 f4 00 00       	call   f011ffb8 <strcmp>
f0110af0:	83 c4 10             	add    $0x10,%esp
f0110af3:	85 c0                	test   %eax,%eax
f0110af5:	75 07                	jne    f0110afe <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110af7:	e8 8e 19 00 00       	call   f011248a <test_pt_clear_page_table_entry>
f0110afc:	eb 22                	jmp    f0110b20 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110afe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b01:	83 c0 04             	add    $0x4,%eax
f0110b04:	8b 00                	mov    (%eax),%eax
f0110b06:	83 ec 08             	sub    $0x8,%esp
f0110b09:	68 81 87 12 f0       	push   $0xf0128781
f0110b0e:	50                   	push   %eax
f0110b0f:	e8 a4 f4 00 00       	call   f011ffb8 <strcmp>
f0110b14:	83 c4 10             	add    $0x10,%esp
f0110b17:	85 c0                	test   %eax,%eax
f0110b19:	75 05                	jne    f0110b20 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110b1b:	e8 c3 1a 00 00       	call   f01125e3 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110b20:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110b25:	c9                   	leave  
f0110b26:	c3                   	ret    

f0110b27 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110b27:	55                   	push   %ebp
f0110b28:	89 e5                	mov    %esp,%ebp
f0110b2a:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b30:	83 c0 08             	add    $0x8,%eax
f0110b33:	8b 00                	mov    (%eax),%eax
f0110b35:	83 ec 08             	sub    $0x8,%esp
f0110b38:	68 88 87 12 f0       	push   $0xf0128788
f0110b3d:	50                   	push   %eax
f0110b3e:	e8 75 f4 00 00       	call   f011ffb8 <strcmp>
f0110b43:	83 c4 10             	add    $0x10,%esp
f0110b46:	85 c0                	test   %eax,%eax
f0110b48:	75 20                	jne    f0110b6a <tst_kheap+0x43>
f0110b4a:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110b4e:	74 1a                	je     f0110b6a <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110b50:	83 ec 0c             	sub    $0xc,%esp
f0110b53:	68 90 87 12 f0       	push   $0xf0128790
f0110b58:	e8 2e 04 ff ff       	call   f0100f8b <cprintf>
f0110b5d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110b60:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b65:	e9 42 04 00 00       	jmp    f0110fac <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110b6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b6d:	83 c0 08             	add    $0x8,%eax
f0110b70:	8b 00                	mov    (%eax),%eax
f0110b72:	83 ec 08             	sub    $0x8,%esp
f0110b75:	68 88 87 12 f0       	push   $0xf0128788
f0110b7a:	50                   	push   %eax
f0110b7b:	e8 38 f4 00 00       	call   f011ffb8 <strcmp>
f0110b80:	83 c4 10             	add    $0x10,%esp
f0110b83:	85 c0                	test   %eax,%eax
f0110b85:	74 43                	je     f0110bca <tst_kheap+0xa3>
f0110b87:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110b8b:	74 3d                	je     f0110bca <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f0110b8d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b90:	83 c0 08             	add    $0x8,%eax
f0110b93:	8b 00                	mov    (%eax),%eax
f0110b95:	83 ec 08             	sub    $0x8,%esp
f0110b98:	68 e0 87 12 f0       	push   $0xf01287e0
f0110b9d:	50                   	push   %eax
f0110b9e:	e8 15 f4 00 00       	call   f011ffb8 <strcmp>
f0110ba3:	83 c4 10             	add    $0x10,%esp
f0110ba6:	85 c0                	test   %eax,%eax
f0110ba8:	74 20                	je     f0110bca <tst_kheap+0xa3>
f0110baa:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f0110bae:	74 1a                	je     f0110bca <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f0110bb0:	83 ec 0c             	sub    $0xc,%esp
f0110bb3:	68 ec 87 12 f0       	push   $0xf01287ec
f0110bb8:	e8 ce 03 ff ff       	call   f0100f8b <cprintf>
f0110bbd:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110bc0:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bc5:	e9 e2 03 00 00       	jmp    f0110fac <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110bca:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bcd:	83 c0 04             	add    $0x4,%eax
f0110bd0:	8b 00                	mov    (%eax),%eax
f0110bd2:	83 ec 08             	sub    $0x8,%esp
f0110bd5:	68 31 88 12 f0       	push   $0xf0128831
f0110bda:	50                   	push   %eax
f0110bdb:	e8 d8 f3 00 00       	call   f011ffb8 <strcmp>
f0110be0:	83 c4 10             	add    $0x10,%esp
f0110be3:	85 c0                	test   %eax,%eax
f0110be5:	74 1d                	je     f0110c04 <tst_kheap+0xdd>
f0110be7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bea:	83 c0 04             	add    $0x4,%eax
f0110bed:	8b 00                	mov    (%eax),%eax
f0110bef:	83 ec 08             	sub    $0x8,%esp
f0110bf2:	68 34 88 12 f0       	push   $0xf0128834
f0110bf7:	50                   	push   %eax
f0110bf8:	e8 bb f3 00 00       	call   f011ffb8 <strcmp>
f0110bfd:	83 c4 10             	add    $0x10,%esp
f0110c00:	85 c0                	test   %eax,%eax
f0110c02:	75 1a                	jne    f0110c1e <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110c04:	e8 6d f8 ff ff       	call   f0110476 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110c09:	83 ec 0c             	sub    $0xc,%esp
f0110c0c:	68 38 88 12 f0       	push   $0xf0128838
f0110c11:	e8 75 03 ff ff       	call   f0100f8b <cprintf>
f0110c16:	83 c4 10             	add    $0x10,%esp
f0110c19:	e9 a0 00 00 00       	jmp    f0110cbe <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c21:	83 c0 04             	add    $0x4,%eax
f0110c24:	8b 00                	mov    (%eax),%eax
f0110c26:	83 ec 08             	sub    $0x8,%esp
f0110c29:	68 65 88 12 f0       	push   $0xf0128865
f0110c2e:	50                   	push   %eax
f0110c2f:	e8 84 f3 00 00       	call   f011ffb8 <strcmp>
f0110c34:	83 c4 10             	add    $0x10,%esp
f0110c37:	85 c0                	test   %eax,%eax
f0110c39:	74 1d                	je     f0110c58 <tst_kheap+0x131>
f0110c3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c3e:	83 c0 04             	add    $0x4,%eax
f0110c41:	8b 00                	mov    (%eax),%eax
f0110c43:	83 ec 08             	sub    $0x8,%esp
f0110c46:	68 68 88 12 f0       	push   $0xf0128868
f0110c4b:	50                   	push   %eax
f0110c4c:	e8 67 f3 00 00       	call   f011ffb8 <strcmp>
f0110c51:	83 c4 10             	add    $0x10,%esp
f0110c54:	85 c0                	test   %eax,%eax
f0110c56:	75 17                	jne    f0110c6f <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110c58:	e8 29 f8 ff ff       	call   f0110486 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110c5d:	83 ec 0c             	sub    $0xc,%esp
f0110c60:	68 6c 88 12 f0       	push   $0xf012886c
f0110c65:	e8 21 03 ff ff       	call   f0100f8b <cprintf>
f0110c6a:	83 c4 10             	add    $0x10,%esp
f0110c6d:	eb 4f                	jmp    f0110cbe <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c72:	83 c0 04             	add    $0x4,%eax
f0110c75:	8b 00                	mov    (%eax),%eax
f0110c77:	83 ec 08             	sub    $0x8,%esp
f0110c7a:	68 98 88 12 f0       	push   $0xf0128898
f0110c7f:	50                   	push   %eax
f0110c80:	e8 33 f3 00 00       	call   f011ffb8 <strcmp>
f0110c85:	83 c4 10             	add    $0x10,%esp
f0110c88:	85 c0                	test   %eax,%eax
f0110c8a:	74 1d                	je     f0110ca9 <tst_kheap+0x182>
f0110c8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c8f:	83 c0 04             	add    $0x4,%eax
f0110c92:	8b 00                	mov    (%eax),%eax
f0110c94:	83 ec 08             	sub    $0x8,%esp
f0110c97:	68 9b 88 12 f0       	push   $0xf012889b
f0110c9c:	50                   	push   %eax
f0110c9d:	e8 16 f3 00 00       	call   f011ffb8 <strcmp>
f0110ca2:	83 c4 10             	add    $0x10,%esp
f0110ca5:	85 c0                	test   %eax,%eax
f0110ca7:	75 15                	jne    f0110cbe <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110ca9:	e8 e8 f7 ff ff       	call   f0110496 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110cae:	83 ec 0c             	sub    $0xc,%esp
f0110cb1:	68 a0 88 12 f0       	push   $0xf01288a0
f0110cb6:	e8 d0 02 ff ff       	call   f0100f8b <cprintf>
f0110cbb:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110cbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cc1:	83 c0 08             	add    $0x8,%eax
f0110cc4:	8b 00                	mov    (%eax),%eax
f0110cc6:	83 ec 08             	sub    $0x8,%esp
f0110cc9:	68 88 87 12 f0       	push   $0xf0128788
f0110cce:	50                   	push   %eax
f0110ccf:	e8 e4 f2 00 00       	call   f011ffb8 <strcmp>
f0110cd4:	83 c4 10             	add    $0x10,%esp
f0110cd7:	85 c0                	test   %eax,%eax
f0110cd9:	0f 85 13 01 00 00    	jne    f0110df2 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110cdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ce2:	83 c0 0c             	add    $0xc,%eax
f0110ce5:	8b 00                	mov    (%eax),%eax
f0110ce7:	83 ec 04             	sub    $0x4,%esp
f0110cea:	6a 0a                	push   $0xa
f0110cec:	6a 00                	push   $0x0
f0110cee:	50                   	push   %eax
f0110cef:	e8 18 f5 00 00       	call   f012020c <strtol>
f0110cf4:	83 c4 10             	add    $0x10,%esp
f0110cf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110cfa:	e8 a7 f7 ff ff       	call   f01104a6 <isKHeapPlacementStrategyFIRSTFIT>
f0110cff:	84 c0                	test   %al,%al
f0110d01:	74 54                	je     f0110d57 <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110d03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110d07:	75 1a                	jne    f0110d23 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110d09:	83 ec 0c             	sub    $0xc,%esp
f0110d0c:	68 cc 88 12 f0       	push   $0xf01288cc
f0110d11:	e8 75 02 ff ff       	call   f0100f8b <cprintf>
f0110d16:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110d19:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d1e:	e9 89 02 00 00       	jmp    f0110fac <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110d23:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110d27:	75 0a                	jne    f0110d33 <tst_kheap+0x20c>
				test_kmalloc();
f0110d29:	e8 ec 61 00 00       	call   f0116f1a <test_kmalloc>
f0110d2e:	e9 b5 00 00 00       	jmp    f0110de8 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110d33:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110d37:	75 0a                	jne    f0110d43 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110d39:	e8 68 6d 00 00       	call   f0117aa6 <test_kmalloc_firstfit1>
f0110d3e:	e9 a5 00 00 00       	jmp    f0110de8 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110d43:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110d47:	0f 85 9b 00 00 00    	jne    f0110de8 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110d4d:	e8 38 78 00 00       	call   f011858a <test_kmalloc_firstfit2>
f0110d52:	e9 91 00 00 00       	jmp    f0110de8 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110d57:	e8 5f f7 ff ff       	call   f01104bb <isKHeapPlacementStrategyBESTFIT>
f0110d5c:	84 c0                	test   %al,%al
f0110d5e:	74 47                	je     f0110da7 <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110d60:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110d64:	75 1a                	jne    f0110d80 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110d66:	83 ec 0c             	sub    $0xc,%esp
f0110d69:	68 1c 89 12 f0       	push   $0xf012891c
f0110d6e:	e8 18 02 ff ff       	call   f0100f8b <cprintf>
f0110d73:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110d76:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d7b:	e9 2c 02 00 00       	jmp    f0110fac <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110d80:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110d84:	75 07                	jne    f0110d8d <tst_kheap+0x266>
				test_kmalloc();
f0110d86:	e8 8f 61 00 00       	call   f0116f1a <test_kmalloc>
f0110d8b:	eb 5b                	jmp    f0110de8 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110d8d:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110d91:	75 07                	jne    f0110d9a <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110d93:	e8 2b c8 00 00       	call   f011d5c3 <test_kmalloc_bestfit1>
f0110d98:	eb 4e                	jmp    f0110de8 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110d9a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110d9e:	75 48                	jne    f0110de8 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110da0:	e8 3b c8 00 00       	call   f011d5e0 <test_kmalloc_bestfit2>
f0110da5:	eb 41                	jmp    f0110de8 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110da7:	e8 24 f7 ff ff       	call   f01104d0 <isKHeapPlacementStrategyNEXTFIT>
f0110dac:	84 c0                	test   %al,%al
f0110dae:	74 38                	je     f0110de8 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110db0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110db4:	75 1a                	jne    f0110dd0 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110db6:	83 ec 0c             	sub    $0xc,%esp
f0110db9:	68 6c 89 12 f0       	push   $0xf012896c
f0110dbe:	e8 c8 01 ff ff       	call   f0100f8b <cprintf>
f0110dc3:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110dc6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dcb:	e9 dc 01 00 00       	jmp    f0110fac <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110dd0:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110dd4:	75 07                	jne    f0110ddd <tst_kheap+0x2b6>
				test_kmalloc();
f0110dd6:	e8 3f 61 00 00       	call   f0116f1a <test_kmalloc>
f0110ddb:	eb 0b                	jmp    f0110de8 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110ddd:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110de1:	75 05                	jne    f0110de8 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110de3:	e8 be c7 00 00       	call   f011d5a6 <test_kmalloc_nextfit>
		}
		return 0;
f0110de8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ded:	e9 ba 01 00 00       	jmp    f0110fac <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110df2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110df5:	83 c0 08             	add    $0x8,%eax
f0110df8:	8b 00                	mov    (%eax),%eax
f0110dfa:	83 ec 08             	sub    $0x8,%esp
f0110dfd:	68 ba 89 12 f0       	push   $0xf01289ba
f0110e02:	50                   	push   %eax
f0110e03:	e8 b0 f1 00 00       	call   f011ffb8 <strcmp>
f0110e08:	83 c4 10             	add    $0x10,%esp
f0110e0b:	85 c0                	test   %eax,%eax
f0110e0d:	75 2f                	jne    f0110e3e <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110e0f:	e8 92 f6 ff ff       	call   f01104a6 <isKHeapPlacementStrategyFIRSTFIT>
f0110e14:	84 c0                	test   %al,%al
f0110e16:	74 0f                	je     f0110e27 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110e18:	e8 74 82 00 00       	call   f0119091 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110e1d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e22:	e9 85 01 00 00       	jmp    f0110fac <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110e27:	83 ec 04             	sub    $0x4,%esp
f0110e2a:	68 c0 89 12 f0       	push   $0xf01289c0
f0110e2f:	68 ac 01 00 00       	push   $0x1ac
f0110e34:	68 a7 85 12 f0       	push   $0xf01285a7
f0110e39:	e8 fb f4 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110e3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e41:	83 c0 08             	add    $0x8,%eax
f0110e44:	8b 00                	mov    (%eax),%eax
f0110e46:	83 ec 08             	sub    $0x8,%esp
f0110e49:	68 01 8a 12 f0       	push   $0xf0128a01
f0110e4e:	50                   	push   %eax
f0110e4f:	e8 64 f1 00 00       	call   f011ffb8 <strcmp>
f0110e54:	83 c4 10             	add    $0x10,%esp
f0110e57:	85 c0                	test   %eax,%eax
f0110e59:	75 28                	jne    f0110e83 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110e5b:	e8 5b f6 ff ff       	call   f01104bb <isKHeapPlacementStrategyBESTFIT>
f0110e60:	84 c0                	test   %al,%al
f0110e62:	75 09                	jne    f0110e6d <tst_kheap+0x346>
f0110e64:	e8 3d f6 ff ff       	call   f01104a6 <isKHeapPlacementStrategyFIRSTFIT>
f0110e69:	84 c0                	test   %al,%al
f0110e6b:	74 07                	je     f0110e74 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110e6d:	e8 ee 8a 00 00       	call   f0119960 <test_kfree_bestfirstfit>
f0110e72:	eb 05                	jmp    f0110e79 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110e74:	e8 a1 c7 00 00       	call   f011d61a <test_kfree>
		}
		return 0;
f0110e79:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e7e:	e9 29 01 00 00       	jmp    f0110fac <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110e83:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e86:	83 c0 08             	add    $0x8,%eax
f0110e89:	8b 00                	mov    (%eax),%eax
f0110e8b:	83 ec 08             	sub    $0x8,%esp
f0110e8e:	68 07 8a 12 f0       	push   $0xf0128a07
f0110e93:	50                   	push   %eax
f0110e94:	e8 1f f1 00 00       	call   f011ffb8 <strcmp>
f0110e99:	83 c4 10             	add    $0x10,%esp
f0110e9c:	85 c0                	test   %eax,%eax
f0110e9e:	75 0f                	jne    f0110eaf <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110ea0:	e8 17 a1 00 00       	call   f011afbc <test_kheap_phys_addr>
		return 0;
f0110ea5:	b8 00 00 00 00       	mov    $0x0,%eax
f0110eaa:	e9 fd 00 00 00       	jmp    f0110fac <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110eb2:	83 c0 08             	add    $0x8,%eax
f0110eb5:	8b 00                	mov    (%eax),%eax
f0110eb7:	83 ec 08             	sub    $0x8,%esp
f0110eba:	68 11 8a 12 f0       	push   $0xf0128a11
f0110ebf:	50                   	push   %eax
f0110ec0:	e8 f3 f0 00 00       	call   f011ffb8 <strcmp>
f0110ec5:	83 c4 10             	add    $0x10,%esp
f0110ec8:	85 c0                	test   %eax,%eax
f0110eca:	75 0f                	jne    f0110edb <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110ecc:	e8 ce ae 00 00       	call   f011bd9f <test_kheap_virt_addr>
		return 0;
f0110ed1:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ed6:	e9 d1 00 00 00       	jmp    f0110fac <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110edb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ede:	83 c0 08             	add    $0x8,%eax
f0110ee1:	8b 00                	mov    (%eax),%eax
f0110ee3:	83 ec 08             	sub    $0x8,%esp
f0110ee6:	68 e0 87 12 f0       	push   $0xf01287e0
f0110eeb:	50                   	push   %eax
f0110eec:	e8 c7 f0 00 00       	call   f011ffb8 <strcmp>
f0110ef1:	83 c4 10             	add    $0x10,%esp
f0110ef4:	85 c0                	test   %eax,%eax
f0110ef6:	0f 85 89 00 00 00    	jne    f0110f85 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110efc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110eff:	83 c0 0c             	add    $0xc,%eax
f0110f02:	8b 00                	mov    (%eax),%eax
f0110f04:	83 ec 04             	sub    $0x4,%esp
f0110f07:	6a 0a                	push   $0xa
f0110f09:	6a 00                	push   $0x0
f0110f0b:	50                   	push   %eax
f0110f0c:	e8 fb f2 00 00       	call   f012020c <strtol>
f0110f11:	83 c4 10             	add    $0x10,%esp
f0110f14:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110f17:	e8 8a f5 ff ff       	call   f01104a6 <isKHeapPlacementStrategyFIRSTFIT>
f0110f1c:	84 c0                	test   %al,%al
f0110f1e:	74 42                	je     f0110f62 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110f20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f24:	75 17                	jne    f0110f3d <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110f26:	83 ec 0c             	sub    $0xc,%esp
f0110f29:	68 cc 88 12 f0       	push   $0xf01288cc
f0110f2e:	e8 58 00 ff ff       	call   f0100f8b <cprintf>
f0110f33:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f3b:	eb 6f                	jmp    f0110fac <tst_kheap+0x485>
			}
			if (testNum==1)
f0110f3d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110f41:	75 07                	jne    f0110f4a <tst_kheap+0x423>
				test_krealloc_FF1();
f0110f43:	e8 50 c9 00 00       	call   f011d898 <test_krealloc_FF1>
f0110f48:	eb 18                	jmp    f0110f62 <tst_kheap+0x43b>
			else if (testNum==2)
f0110f4a:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110f4e:	75 07                	jne    f0110f57 <tst_kheap+0x430>
				test_krealloc_FF2();
f0110f50:	e8 60 c9 00 00       	call   f011d8b5 <test_krealloc_FF2>
f0110f55:	eb 0b                	jmp    f0110f62 <tst_kheap+0x43b>
			else if (testNum==3)
f0110f57:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110f5b:	75 05                	jne    f0110f62 <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110f5d:	e8 70 c9 00 00       	call   f011d8d2 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0110f62:	e8 69 f5 ff ff       	call   f01104d0 <isKHeapPlacementStrategyNEXTFIT>
f0110f67:	84 c0                	test   %al,%al
f0110f69:	74 05                	je     f0110f70 <tst_kheap+0x449>
		{
			test_krealloc();
f0110f6b:	e8 ee c8 00 00       	call   f011d85e <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110f70:	e8 46 f5 ff ff       	call   f01104bb <isKHeapPlacementStrategyBESTFIT>
f0110f75:	84 c0                	test   %al,%al
f0110f77:	74 05                	je     f0110f7e <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110f79:	e8 fd c8 00 00       	call   f011d87b <test_krealloc_BF>
		}
		return 0;
f0110f7e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f83:	eb 27                	jmp    f0110fac <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f0110f85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f88:	83 c0 08             	add    $0x8,%eax
f0110f8b:	8b 00                	mov    (%eax),%eax
f0110f8d:	83 ec 08             	sub    $0x8,%esp
f0110f90:	68 1b 8a 12 f0       	push   $0xf0128a1b
f0110f95:	50                   	push   %eax
f0110f96:	e8 1d f0 00 00       	call   f011ffb8 <strcmp>
f0110f9b:	83 c4 10             	add    $0x10,%esp
f0110f9e:	85 c0                	test   %eax,%eax
f0110fa0:	75 05                	jne    f0110fa7 <tst_kheap+0x480>
	{
		test_ksbrk();
f0110fa2:	e8 1d bb 00 00       	call   f011cac4 <test_ksbrk>
	}
	return 0;
f0110fa7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110fac:	c9                   	leave  
f0110fad:	c3                   	ret    

f0110fae <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0110fae:	55                   	push   %ebp
f0110faf:	89 e5                	mov    %esp,%ebp
f0110fb1:	83 ec 28             	sub    $0x28,%esp
f0110fb4:	8b 45 14             	mov    0x14(%ebp),%eax
f0110fb7:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110fba:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fbd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110fc0:	74 1d                	je     f0110fdf <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110fc2:	83 ec 04             	sub    $0x4,%esp
f0110fc5:	ff 75 08             	pushl  0x8(%ebp)
f0110fc8:	ff 75 0c             	pushl  0xc(%ebp)
f0110fcb:	68 20 8a 12 f0       	push   $0xf0128a20
f0110fd0:	e8 b6 ff fe ff       	call   f0100f8b <cprintf>
f0110fd5:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110fd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fdd:	eb 55                	jmp    f0111034 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110fdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fe2:	8b 40 fc             	mov    -0x4(%eax),%eax
f0110fe5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110fe8:	8b 45 10             	mov    0x10(%ebp),%eax
f0110feb:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110fee:	8b 45 08             	mov    0x8(%ebp),%eax
f0110ff1:	01 d0                	add    %edx,%eax
f0110ff3:	8b 00                	mov    (%eax),%eax
f0110ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110ff8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110ffc:	0b 45 10             	or     0x10(%ebp),%eax
f0110fff:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0111002:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111005:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111008:	75 08                	jne    f0111012 <check_block+0x64>
f011100a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011100d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111010:	74 1d                	je     f011102f <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0111012:	ff 75 f0             	pushl  -0x10(%ebp)
f0111015:	ff 75 f4             	pushl  -0xc(%ebp)
f0111018:	ff 75 ec             	pushl  -0x14(%ebp)
f011101b:	68 50 8a 12 f0       	push   $0xf0128a50
f0111020:	e8 66 ff fe ff       	call   f0100f8b <cprintf>
f0111025:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111028:	b8 00 00 00 00       	mov    $0x0,%eax
f011102d:	eb 05                	jmp    f0111034 <check_block+0x86>
	}
	return 1;
f011102f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111034:	c9                   	leave  
f0111035:	c3                   	ret    

f0111036 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0111036:	55                   	push   %ebp
f0111037:	89 e5                	mov    %esp,%ebp
f0111039:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f011103c:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0111041:	3b 45 08             	cmp    0x8(%ebp),%eax
f0111044:	74 20                	je     f0111066 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0111046:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f011104b:	83 ec 04             	sub    $0x4,%esp
f011104e:	50                   	push   %eax
f011104f:	ff 75 08             	pushl  0x8(%ebp)
f0111052:	68 8c 8a 12 f0       	push   $0xf0128a8c
f0111057:	e8 2f ff fe ff       	call   f0100f8b <cprintf>
f011105c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011105f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111064:	eb 05                	jmp    f011106b <check_list_size+0x35>
	}
	return 1;
f0111066:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011106b:	c9                   	leave  
f011106c:	c3                   	ret    

f011106d <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f011106d:	55                   	push   %ebp
f011106e:	89 e5                	mov    %esp,%ebp
f0111070:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0111073:	83 ec 04             	sub    $0x4,%esp
f0111076:	68 c0 8a 12 f0       	push   $0xf0128ac0
f011107b:	6a 3f                	push   $0x3f
f011107d:	68 20 8b 12 f0       	push   $0xf0128b20
f0111082:	e8 b2 f2 fe ff       	call   f0100339 <_panic>

f0111087 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f0111087:	55                   	push   %ebp
f0111088:	89 e5                	mov    %esp,%ebp
f011108a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011108d:	83 ec 04             	sub    $0x4,%esp
f0111090:	68 44 8b 12 f0       	push   $0xf0128b44
f0111095:	6a 61                	push   $0x61
f0111097:	68 20 8b 12 f0       	push   $0xf0128b20
f011109c:	e8 98 f2 fe ff       	call   f0100339 <_panic>

f01110a1 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f01110a1:	55                   	push   %ebp
f01110a2:	89 e5                	mov    %esp,%ebp
f01110a4:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01110a7:	83 ec 04             	sub    $0x4,%esp
f01110aa:	68 94 8b 12 f0       	push   $0xf0128b94
f01110af:	68 e7 00 00 00       	push   $0xe7
f01110b4:	68 20 8b 12 f0       	push   $0xf0128b20
f01110b9:	e8 7b f2 fe ff       	call   f0100339 <_panic>

f01110be <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f01110be:	55                   	push   %ebp
f01110bf:	89 e5                	mov    %esp,%ebp
f01110c1:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01110c7:	83 ec 04             	sub    $0x4,%esp
f01110ca:	68 e8 8b 12 f0       	push   $0xf0128be8
f01110cf:	68 88 01 00 00       	push   $0x188
f01110d4:	68 20 8b 12 f0       	push   $0xf0128b20
f01110d9:	e8 5b f2 fe ff       	call   f0100339 <_panic>

f01110de <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f01110de:	55                   	push   %ebp
f01110df:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f01110e1:	90                   	nop
f01110e2:	5d                   	pop    %ebp
f01110e3:	c3                   	ret    

f01110e4 <test_free_block_FF>:

void test_free_block_FF()
{
f01110e4:	55                   	push   %ebp
f01110e5:	89 e5                	mov    %esp,%ebp
f01110e7:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01110ea:	83 ec 04             	sub    $0x4,%esp
f01110ed:	68 3c 8c 12 f0       	push   $0xf0128c3c
f01110f2:	68 4e 02 00 00       	push   $0x24e
f01110f7:	68 20 8b 12 f0       	push   $0xf0128b20
f01110fc:	e8 38 f2 fe ff       	call   f0100339 <_panic>

f0111101 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0111101:	55                   	push   %ebp
f0111102:	89 e5                	mov    %esp,%ebp
f0111104:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111107:	83 ec 04             	sub    $0x4,%esp
f011110a:	68 3c 8c 12 f0       	push   $0xf0128c3c
f011110f:	68 9a 03 00 00       	push   $0x39a
f0111114:	68 20 8b 12 f0       	push   $0xf0128b20
f0111119:	e8 1b f2 fe ff       	call   f0100339 <_panic>

f011111e <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f011111e:	55                   	push   %ebp
f011111f:	89 e5                	mov    %esp,%ebp
f0111121:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0111124:	83 ec 04             	sub    $0x4,%esp
f0111127:	68 89 8c 12 f0       	push   $0xf0128c89
f011112c:	68 ba 04 00 00       	push   $0x4ba
f0111131:	68 20 8b 12 f0       	push   $0xf0128b20
f0111136:	e8 fe f1 fe ff       	call   f0100339 <_panic>

f011113b <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f011113b:	55                   	push   %ebp
f011113c:	89 e5                	mov    %esp,%ebp
f011113e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111141:	83 ec 04             	sub    $0x4,%esp
f0111144:	68 3c 8c 12 f0       	push   $0xf0128c3c
f0111149:	68 c0 04 00 00       	push   $0x4c0
f011114e:	68 20 8b 12 f0       	push   $0xf0128b20
f0111153:	e8 e1 f1 fe ff       	call   f0100339 <_panic>

f0111158 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0111158:	55                   	push   %ebp
f0111159:	89 e5                	mov    %esp,%ebp
f011115b:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011115e:	83 ec 04             	sub    $0x4,%esp
f0111161:	68 3c 8c 12 f0       	push   $0xf0128c3c
f0111166:	68 e7 05 00 00       	push   $0x5e7
f011116b:	68 20 8b 12 f0       	push   $0xf0128b20
f0111170:	e8 c4 f1 fe ff       	call   f0100339 <_panic>

f0111175 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111175:	55                   	push   %ebp
f0111176:	89 e5                	mov    %esp,%ebp
f0111178:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011117b:	e8 f0 aa ff ff       	call   f010bc70 <get_cpu_proc>
f0111180:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111183:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111187:	75 16                	jne    f011119f <sys_check_LRU_lists+0x2a>
f0111189:	68 9c 8c 12 f0       	push   $0xf0128c9c
f011118e:	68 ac 8c 12 f0       	push   $0xf0128cac
f0111193:	6a 10                	push   $0x10
f0111195:	68 c1 8c 12 f0       	push   $0xf0128cc1
f011119a:	e8 9a f1 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f011119f:	83 ec 0c             	sub    $0xc,%esp
f01111a2:	68 e0 8c 12 f0       	push   $0xf0128ce0
f01111a7:	e8 df fd fe ff       	call   f0100f8b <cprintf>
f01111ac:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01111af:	83 ec 0c             	sub    $0xc,%esp
f01111b2:	ff 75 e0             	pushl  -0x20(%ebp)
f01111b5:	e8 38 95 ff ff       	call   f010a6f2 <env_page_ws_print>
f01111ba:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01111bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111c0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01111c3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01111ca:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01111d1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01111d5:	0f 84 a5 00 00 00    	je     f0111280 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01111db:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01111e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111e5:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01111eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01111ee:	eb 4a                	jmp    f011123a <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f01111f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111f3:	8b 00                	mov    (%eax),%eax
f01111f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01111f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01111fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111200:	89 c2                	mov    %eax,%edx
f0111202:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111205:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011120c:	8b 45 08             	mov    0x8(%ebp),%eax
f011120f:	01 c8                	add    %ecx,%eax
f0111211:	8b 00                	mov    (%eax),%eax
f0111213:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111216:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111219:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011121e:	39 c2                	cmp    %eax,%edx
f0111220:	74 09                	je     f011122b <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111222:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111229:	eb 3e                	jmp    f0111269 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f011122b:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011122e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111231:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111237:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011123a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011123e:	74 08                	je     f0111248 <sys_check_LRU_lists+0xd3>
f0111240:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111243:	8b 40 10             	mov    0x10(%eax),%eax
f0111246:	eb 05                	jmp    f011124d <sys_check_LRU_lists+0xd8>
f0111248:	b8 00 00 00 00       	mov    $0x0,%eax
f011124d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111250:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0111256:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111259:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011125f:	85 c0                	test   %eax,%eax
f0111261:	75 8d                	jne    f01111f0 <sys_check_LRU_lists+0x7b>
f0111263:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111267:	75 87                	jne    f01111f0 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0111269:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011126c:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f0111272:	8b 45 10             	mov    0x10(%ebp),%eax
f0111275:	39 c2                	cmp    %eax,%edx
f0111277:	74 07                	je     f0111280 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0111279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111280:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111284:	0f 84 a5 00 00 00    	je     f011132f <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011128a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111291:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111294:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011129a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011129d:	eb 4a                	jmp    f01112e9 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f011129f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112a2:	8b 00                	mov    (%eax),%eax
f01112a4:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01112a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01112aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112af:	89 c2                	mov    %eax,%edx
f01112b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01112b4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112be:	01 c8                	add    %ecx,%eax
f01112c0:	8b 00                	mov    (%eax),%eax
f01112c2:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01112c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01112c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112cd:	39 c2                	cmp    %eax,%edx
f01112cf:	74 09                	je     f01112da <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01112d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01112d8:	eb 3e                	jmp    f0111318 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01112da:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01112dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01112e0:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01112e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01112e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01112ed:	74 08                	je     f01112f7 <sys_check_LRU_lists+0x182>
f01112ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112f2:	8b 40 10             	mov    0x10(%eax),%eax
f01112f5:	eb 05                	jmp    f01112fc <sys_check_LRU_lists+0x187>
f01112f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01112fc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01112ff:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111305:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111308:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011130e:	85 c0                	test   %eax,%eax
f0111310:	75 8d                	jne    f011129f <sys_check_LRU_lists+0x12a>
f0111312:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111316:	75 87                	jne    f011129f <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111318:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011131b:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f0111321:	8b 45 14             	mov    0x14(%ebp),%eax
f0111324:	39 c2                	cmp    %eax,%edx
f0111326:	74 07                	je     f011132f <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111328:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f011132f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111332:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111335:	c9                   	leave  
f0111336:	c3                   	ret    

f0111337 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111337:	55                   	push   %ebp
f0111338:	89 e5                	mov    %esp,%ebp
f011133a:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011133d:	e8 2e a9 ff ff       	call   f010bc70 <get_cpu_proc>
f0111342:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111345:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111349:	75 16                	jne    f0111361 <sys_check_LRU_lists_free+0x2a>
f011134b:	68 9c 8c 12 f0       	push   $0xf0128c9c
f0111350:	68 ac 8c 12 f0       	push   $0xf0128cac
f0111355:	6a 45                	push   $0x45
f0111357:	68 c1 8c 12 f0       	push   $0xf0128cc1
f011135c:	e8 d8 ef fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111361:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111364:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111367:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011136e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111371:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0111377:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011137a:	eb 65                	jmp    f01113e1 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f011137c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111383:	eb 3a                	jmp    f01113bf <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111385:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111388:	8b 00                	mov    (%eax),%eax
f011138a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011138d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111390:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111395:	89 c2                	mov    %eax,%edx
f0111397:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011139a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01113a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01113a4:	01 c8                	add    %ecx,%eax
f01113a6:	8b 00                	mov    (%eax),%eax
f01113a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01113ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01113ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113b3:	39 c2                	cmp    %eax,%edx
f01113b5:	75 05                	jne    f01113bc <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01113b7:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01113ba:	eb 0b                	jmp    f01113c7 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01113bc:	ff 45 ec             	incl   -0x14(%ebp)
f01113bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113c2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113c5:	7c be                	jl     f0111385 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01113c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01113cb:	7e 08                	jle    f01113d5 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01113cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113d0:	e9 ed 00 00 00       	jmp    f01114c2 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01113d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113d8:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01113de:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01113e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113e5:	74 08                	je     f01113ef <sys_check_LRU_lists_free+0xb8>
f01113e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113ea:	8b 40 10             	mov    0x10(%eax),%eax
f01113ed:	eb 05                	jmp    f01113f4 <sys_check_LRU_lists_free+0xbd>
f01113ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01113f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01113f7:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f01113fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111400:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111406:	85 c0                	test   %eax,%eax
f0111408:	0f 85 6e ff ff ff    	jne    f011137c <sys_check_LRU_lists_free+0x45>
f011140e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111412:	0f 85 64 ff ff ff    	jne    f011137c <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111418:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011141b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111421:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111424:	eb 62                	jmp    f0111488 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111426:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011142d:	eb 3a                	jmp    f0111469 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011142f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111432:	8b 00                	mov    (%eax),%eax
f0111434:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111437:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011143a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011143f:	89 c2                	mov    %eax,%edx
f0111441:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111444:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011144b:	8b 45 08             	mov    0x8(%ebp),%eax
f011144e:	01 c8                	add    %ecx,%eax
f0111450:	8b 00                	mov    (%eax),%eax
f0111452:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111455:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111458:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011145d:	39 c2                	cmp    %eax,%edx
f011145f:	75 05                	jne    f0111466 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111461:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111464:	eb 0b                	jmp    f0111471 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111466:	ff 45 e8             	incl   -0x18(%ebp)
f0111469:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011146c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011146f:	7c be                	jl     f011142f <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111471:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111475:	7e 05                	jle    f011147c <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111477:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011147a:	eb 46                	jmp    f01114c2 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011147c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011147f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111485:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111488:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011148c:	74 08                	je     f0111496 <sys_check_LRU_lists_free+0x15f>
f011148e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111491:	8b 40 10             	mov    0x10(%eax),%eax
f0111494:	eb 05                	jmp    f011149b <sys_check_LRU_lists_free+0x164>
f0111496:	b8 00 00 00 00       	mov    $0x0,%eax
f011149b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011149e:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f01114a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114a7:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01114ad:	85 c0                	test   %eax,%eax
f01114af:	0f 85 71 ff ff ff    	jne    f0111426 <sys_check_LRU_lists_free+0xef>
f01114b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114b9:	0f 85 67 ff ff ff    	jne    f0111426 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01114bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01114c2:	c9                   	leave  
f01114c3:	c3                   	ret    

f01114c4 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01114c4:	55                   	push   %ebp
f01114c5:	89 e5                	mov    %esp,%ebp
f01114c7:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f01114ca:	e8 a1 a7 ff ff       	call   f010bc70 <get_cpu_proc>
f01114cf:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01114d2:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01114d6:	75 16                	jne    f01114ee <sys_check_WS_list+0x2a>
f01114d8:	68 9c 8c 12 f0       	push   $0xf0128c9c
f01114dd:	68 ac 8c 12 f0       	push   $0xf0128cac
f01114e2:	6a 79                	push   $0x79
f01114e4:	68 c1 8c 12 f0       	push   $0xf0128cc1
f01114e9:	e8 4b ee fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01114ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01114f1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01114f4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01114fb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01114ff:	74 06                	je     f0111507 <sys_check_WS_list+0x43>
f0111501:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111505:	75 1f                	jne    f0111526 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111507:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011150a:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0111510:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111513:	39 c2                	cmp    %eax,%edx
f0111515:	74 0f                	je     f0111526 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111517:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011151e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111521:	e9 15 03 00 00       	jmp    f011183b <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111526:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011152a:	74 39                	je     f0111565 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011152c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011152f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111535:	8b 00                	mov    (%eax),%eax
f0111537:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011153a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011153d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111542:	89 c2                	mov    %eax,%edx
f0111544:	8b 45 10             	mov    0x10(%ebp),%eax
f0111547:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011154a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011154d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111552:	39 c2                	cmp    %eax,%edx
f0111554:	74 0f                	je     f0111565 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111556:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011155d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111560:	e9 d6 02 00 00       	jmp    f011183b <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111565:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111569:	0f 85 3c 01 00 00    	jne    f01116ab <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f011156f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0111576:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011157a:	74 4c                	je     f01115c8 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011157c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111583:	eb 3b                	jmp    f01115c0 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111585:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111588:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011158f:	8b 45 08             	mov    0x8(%ebp),%eax
f0111592:	01 d0                	add    %edx,%eax
f0111594:	8b 00                	mov    (%eax),%eax
f0111596:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0111599:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011159c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115a1:	89 c2                	mov    %eax,%edx
f01115a3:	8b 45 10             	mov    0x10(%ebp),%eax
f01115a6:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01115a9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01115ac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115b1:	39 c2                	cmp    %eax,%edx
f01115b3:	75 08                	jne    f01115bd <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01115b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01115bb:	eb 0b                	jmp    f01115c8 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01115bd:	ff 45 e8             	incl   -0x18(%ebp)
f01115c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115c3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115c6:	7c bd                	jl     f0111585 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f01115c8:	83 ec 08             	sub    $0x8,%esp
f01115cb:	ff 75 ec             	pushl  -0x14(%ebp)
f01115ce:	68 08 8d 12 f0       	push   $0xf0128d08
f01115d3:	e8 b3 f9 fe ff       	call   f0100f8b <cprintf>
f01115d8:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01115db:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115de:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01115e4:	85 c0                	test   %eax,%eax
f01115e6:	74 0e                	je     f01115f6 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f01115e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115eb:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01115f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115f4:	eb 0c                	jmp    f0111602 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01115f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115f9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01115ff:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0111602:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111605:	8b 00                	mov    (%eax),%eax
f0111607:	83 ec 08             	sub    $0x8,%esp
f011160a:	50                   	push   %eax
f011160b:	68 27 8d 12 f0       	push   $0xf0128d27
f0111610:	e8 76 f9 fe ff       	call   f0100f8b <cprintf>
f0111615:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111618:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011161f:	eb 79                	jmp    f011169a <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0111621:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111624:	8b 00                	mov    (%eax),%eax
f0111626:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111629:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011162c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111631:	89 c2                	mov    %eax,%edx
f0111633:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111636:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011163d:	8b 45 08             	mov    0x8(%ebp),%eax
f0111640:	01 c8                	add    %ecx,%eax
f0111642:	8b 00                	mov    (%eax),%eax
f0111644:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111647:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011164a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011164f:	39 c2                	cmp    %eax,%edx
f0111651:	74 0c                	je     f011165f <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0111653:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011165a:	e9 d9 01 00 00       	jmp    f0111838 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f011165f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111662:	40                   	inc    %eax
f0111663:	89 c2                	mov    %eax,%edx
f0111665:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111668:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011166e:	89 d0                	mov    %edx,%eax
f0111670:	ba 00 00 00 00       	mov    $0x0,%edx
f0111675:	f7 f1                	div    %ecx
f0111677:	89 d0                	mov    %edx,%eax
f0111679:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f011167c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011167f:	8b 40 10             	mov    0x10(%eax),%eax
f0111682:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0111685:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111689:	75 0c                	jne    f0111697 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f011168b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011168e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111694:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111697:	ff 45 e4             	incl   -0x1c(%ebp)
f011169a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011169d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01116a0:	0f 8c 7b ff ff ff    	jl     f0111621 <sys_check_WS_list+0x15d>
f01116a6:	e9 8d 01 00 00       	jmp    f0111838 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f01116ab:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01116af:	74 0a                	je     f01116bb <sys_check_WS_list+0x1f7>
f01116b1:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f01116b5:	0f 85 be 00 00 00    	jne    f0111779 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01116bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01116c2:	e9 a1 00 00 00       	jmp    f0111768 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f01116c7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01116ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116d1:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01116d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116da:	eb 47                	jmp    f0111723 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01116dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116df:	8b 00                	mov    (%eax),%eax
f01116e1:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01116e4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01116e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116ec:	89 c2                	mov    %eax,%edx
f01116ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01116f1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01116f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01116fb:	01 c8                	add    %ecx,%eax
f01116fd:	8b 00                	mov    (%eax),%eax
f01116ff:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0111702:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111705:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011170a:	39 c2                	cmp    %eax,%edx
f011170c:	75 09                	jne    f0111717 <sys_check_WS_list+0x253>
				{
					found = 1;
f011170e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0111715:	eb 3b                	jmp    f0111752 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111717:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011171a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111720:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111723:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111727:	74 08                	je     f0111731 <sys_check_WS_list+0x26d>
f0111729:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011172c:	8b 40 10             	mov    0x10(%eax),%eax
f011172f:	eb 05                	jmp    f0111736 <sys_check_WS_list+0x272>
f0111731:	b8 00 00 00 00       	mov    $0x0,%eax
f0111736:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111739:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f011173f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111742:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111748:	85 c0                	test   %eax,%eax
f011174a:	75 90                	jne    f01116dc <sys_check_WS_list+0x218>
f011174c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111750:	75 8a                	jne    f01116dc <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0111752:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111756:	75 0d                	jne    f0111765 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0111758:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011175f:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111760:	e9 d3 00 00 00       	jmp    f0111838 <sys_check_WS_list+0x374>
f0111765:	ff 45 e0             	incl   -0x20(%ebp)
f0111768:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011176b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011176e:	0f 8c 53 ff ff ff    	jl     f01116c7 <sys_check_WS_list+0x203>
f0111774:	e9 bf 00 00 00       	jmp    f0111838 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0111779:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f011177d:	0f 85 b5 00 00 00    	jne    f0111838 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111783:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011178a:	e9 9d 00 00 00       	jmp    f011182c <sys_check_WS_list+0x368>
		{
			bool found = 0;
f011178f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111796:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111799:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011179f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01117a2:	eb 47                	jmp    f01117eb <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01117a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01117a7:	8b 00                	mov    (%eax),%eax
f01117a9:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01117ac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01117af:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117b4:	89 c2                	mov    %eax,%edx
f01117b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01117b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01117c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01117c3:	01 c8                	add    %ecx,%eax
f01117c5:	8b 00                	mov    (%eax),%eax
f01117c7:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01117ca:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01117cd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117d2:	39 c2                	cmp    %eax,%edx
f01117d4:	75 09                	jne    f01117df <sys_check_WS_list+0x31b>
				{
					found = 1;
f01117d6:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01117dd:	eb 3b                	jmp    f011181a <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01117df:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117e2:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01117e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01117eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117ef:	74 08                	je     f01117f9 <sys_check_WS_list+0x335>
f01117f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01117f4:	8b 40 10             	mov    0x10(%eax),%eax
f01117f7:	eb 05                	jmp    f01117fe <sys_check_WS_list+0x33a>
f01117f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01117fe:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111801:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111807:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011180a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111810:	85 c0                	test   %eax,%eax
f0111812:	75 90                	jne    f01117a4 <sys_check_WS_list+0x2e0>
f0111814:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111818:	75 8a                	jne    f01117a4 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f011181a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011181e:	74 09                	je     f0111829 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0111820:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111827:	eb 0f                	jmp    f0111838 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111829:	ff 45 d8             	incl   -0x28(%ebp)
f011182c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011182f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111832:	0f 8c 57 ff ff ff    	jl     f011178f <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0111838:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f011183b:	c9                   	leave  
f011183c:	c3                   	ret    

f011183d <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f011183d:	55                   	push   %ebp
f011183e:	89 e5                	mov    %esp,%ebp
f0111840:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0111843:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f011184a:	8b 15 04 f8 f1 f0    	mov    0xf0f1f804,%edx
f0111850:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111853:	39 c2                	cmp    %eax,%edx
f0111855:	74 0a                	je     f0111861 <hasExpectedCommands+0x24>
		return 0;
f0111857:	b8 00 00 00 00       	mov    $0x0,%eax
f011185c:	e9 8b 00 00 00       	jmp    f01118ec <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0111861:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f0111866:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111869:	eb 55                	jmp    f01118c0 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011186b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0111872:	eb 2a                	jmp    f011189e <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0111874:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111877:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011187e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111881:	01 d0                	add    %edx,%eax
f0111883:	8b 10                	mov    (%eax),%edx
f0111885:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111888:	8b 00                	mov    (%eax),%eax
f011188a:	83 ec 08             	sub    $0x8,%esp
f011188d:	52                   	push   %edx
f011188e:	50                   	push   %eax
f011188f:	e8 24 e7 00 00       	call   f011ffb8 <strcmp>
f0111894:	83 c4 10             	add    $0x10,%esp
f0111897:	85 c0                	test   %eax,%eax
f0111899:	74 0d                	je     f01118a8 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011189b:	ff 45 f0             	incl   -0x10(%ebp)
f011189e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01118a1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01118a4:	7c ce                	jl     f0111874 <hasExpectedCommands+0x37>
f01118a6:	eb 01                	jmp    f01118a9 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01118a8:	90                   	nop
		if (i == commandsCount)
f01118a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01118ac:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01118af:	75 07                	jne    f01118b8 <hasExpectedCommands+0x7b>
			return 0;
f01118b1:	b8 00 00 00 00       	mov    $0x0,%eax
f01118b6:	eb 34                	jmp    f01118ec <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01118b8:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f01118bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01118c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01118c4:	74 08                	je     f01118ce <hasExpectedCommands+0x91>
f01118c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01118c9:	8b 40 10             	mov    0x10(%eax),%eax
f01118cc:	eb 05                	jmp    f01118d3 <hasExpectedCommands+0x96>
f01118ce:	b8 00 00 00 00       	mov    $0x0,%eax
f01118d3:	a3 00 f8 f1 f0       	mov    %eax,0xf0f1f800
f01118d8:	a1 00 f8 f1 f0       	mov    0xf0f1f800,%eax
f01118dd:	85 c0                	test   %eax,%eax
f01118df:	75 8a                	jne    f011186b <hasExpectedCommands+0x2e>
f01118e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01118e5:	75 84                	jne    f011186b <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01118e7:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01118ec:	c9                   	leave  
f01118ed:	c3                   	ret    

f01118ee <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01118ee:	55                   	push   %ebp
f01118ef:	89 e5                	mov    %esp,%ebp
f01118f1:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01118f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01118fb:	eb 2e                	jmp    f011192b <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01118fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111900:	89 d0                	mov    %edx,%eax
f0111902:	01 c0                	add    %eax,%eax
f0111904:	01 d0                	add    %edx,%eax
f0111906:	c1 e0 03             	shl    $0x3,%eax
f0111909:	05 40 05 18 f0       	add    $0xf0180540,%eax
f011190e:	8b 00                	mov    (%eax),%eax
f0111910:	83 ec 08             	sub    $0x8,%esp
f0111913:	ff 75 08             	pushl  0x8(%ebp)
f0111916:	50                   	push   %eax
f0111917:	e8 9c e6 00 00       	call   f011ffb8 <strcmp>
f011191c:	83 c4 10             	add    $0x10,%esp
f011191f:	85 c0                	test   %eax,%eax
f0111921:	75 05                	jne    f0111928 <getIndexOfCommand+0x3a>
			return i;
f0111923:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111926:	eb 14                	jmp    f011193c <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111928:	ff 45 f4             	incl   -0xc(%ebp)
f011192b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011192e:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f0111933:	39 c2                	cmp    %eax,%edx
f0111935:	72 c6                	jb     f01118fd <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111937:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f011193c:	c9                   	leave  
f011193d:	c3                   	ret    

f011193e <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f011193e:	55                   	push   %ebp
f011193f:	89 e5                	mov    %esp,%ebp
f0111941:	57                   	push   %edi
f0111942:	56                   	push   %esi
f0111943:	53                   	push   %ebx
f0111944:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f011194a:	83 ec 0c             	sub    $0xc,%esp
f011194d:	68 60 8d 12 f0       	push   $0xf0128d60
f0111952:	e8 34 f6 fe ff       	call   f0100f8b <cprintf>
f0111957:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f011195a:	83 ec 0c             	sub    $0xc,%esp
f011195d:	68 84 8d 12 f0       	push   $0xf0128d84
f0111962:	e8 24 f6 fe ff       	call   f0100f8b <cprintf>
f0111967:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f011196a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111971:	c7 45 8c 9f 8d 12 f0 	movl   $0xf0128d9f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111978:	83 ec 08             	sub    $0x8,%esp
f011197b:	8d 45 8c             	lea    -0x74(%ebp),%eax
f011197e:	50                   	push   %eax
f011197f:	6a 01                	push   $0x1
f0111981:	e8 4a 08 ff ff       	call   f01021d0 <process_command>
f0111986:	83 c4 10             	add    $0x10,%esp
f0111989:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f011198c:	83 ec 0c             	sub    $0xc,%esp
f011198f:	68 ac 8d 12 f0       	push   $0xf0128dac
f0111994:	e8 f2 f5 fe ff       	call   f0100f8b <cprintf>
f0111999:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f011199c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011199f:	83 ec 0c             	sub    $0xc,%esp
f01119a2:	50                   	push   %eax
f01119a3:	e8 46 ff ff ff       	call   f01118ee <getIndexOfCommand>
f01119a8:	83 c4 10             	add    $0x10,%esp
f01119ab:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01119ae:	75 0f                	jne    f01119bf <TestAutoCompleteCommand+0x81>
f01119b0:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f01119b5:	85 c0                	test   %eax,%eax
f01119b7:	75 06                	jne    f01119bf <TestAutoCompleteCommand+0x81>
		eval += 15;
f01119b9:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01119bd:	eb 10                	jmp    f01119cf <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01119bf:	83 ec 0c             	sub    $0xc,%esp
f01119c2:	68 dc 8d 12 f0       	push   $0xf0128ddc
f01119c7:	e8 bf f5 fe ff       	call   f0100f8b <cprintf>
f01119cc:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01119cf:	83 ec 0c             	sub    $0xc,%esp
f01119d2:	68 2c 8e 12 f0       	push   $0xf0128e2c
f01119d7:	e8 af f5 fe ff       	call   f0100f8b <cprintf>
f01119dc:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01119df:	c7 45 88 52 8e 12 f0 	movl   $0xf0128e52,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01119e6:	83 ec 08             	sub    $0x8,%esp
f01119e9:	8d 45 88             	lea    -0x78(%ebp),%eax
f01119ec:	50                   	push   %eax
f01119ed:	6a 01                	push   $0x1
f01119ef:	e8 dc 07 ff ff       	call   f01021d0 <process_command>
f01119f4:	83 c4 10             	add    $0x10,%esp
f01119f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01119fa:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01119fe:	75 30                	jne    f0111a30 <TestAutoCompleteCommand+0xf2>
f0111a00:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111a03:	bb 30 92 12 f0       	mov    $0xf0129230,%ebx
f0111a08:	ba 03 00 00 00       	mov    $0x3,%edx
f0111a0d:	89 c7                	mov    %eax,%edi
f0111a0f:	89 de                	mov    %ebx,%esi
f0111a11:	89 d1                	mov    %edx,%ecx
f0111a13:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111a15:	83 ec 08             	sub    $0x8,%esp
f0111a18:	6a 03                	push   $0x3
f0111a1a:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111a1d:	50                   	push   %eax
f0111a1e:	e8 1a fe ff ff       	call   f011183d <hasExpectedCommands>
f0111a23:	83 c4 10             	add    $0x10,%esp
f0111a26:	85 c0                	test   %eax,%eax
f0111a28:	74 06                	je     f0111a30 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111a2a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111a2e:	eb 10                	jmp    f0111a40 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a30:	83 ec 0c             	sub    $0xc,%esp
f0111a33:	68 58 8e 12 f0       	push   $0xf0128e58
f0111a38:	e8 4e f5 fe ff       	call   f0100f8b <cprintf>
f0111a3d:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111a40:	83 ec 0c             	sub    $0xc,%esp
f0111a43:	68 a8 8e 12 f0       	push   $0xf0128ea8
f0111a48:	e8 3e f5 fe ff       	call   f0100f8b <cprintf>
f0111a4d:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111a50:	c7 45 84 cd 8e 12 f0 	movl   $0xf0128ecd,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111a57:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111a5a:	83 ec 04             	sub    $0x4,%esp
f0111a5d:	50                   	push   %eax
f0111a5e:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111a61:	50                   	push   %eax
f0111a62:	68 d0 8e 12 f0       	push   $0xf0128ed0
f0111a67:	e8 1f f5 fe ff       	call   f0100f8b <cprintf>
f0111a6c:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111a6f:	83 ec 08             	sub    $0x8,%esp
f0111a72:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111a75:	50                   	push   %eax
f0111a76:	6a 01                	push   $0x1
f0111a78:	e8 53 07 ff ff       	call   f01021d0 <process_command>
f0111a7d:	83 c4 10             	add    $0x10,%esp
f0111a80:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0111a83:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111a87:	75 1b                	jne    f0111aa4 <TestAutoCompleteCommand+0x166>
f0111a89:	83 ec 08             	sub    $0x8,%esp
f0111a8c:	6a 01                	push   $0x1
f0111a8e:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111a91:	50                   	push   %eax
f0111a92:	e8 a6 fd ff ff       	call   f011183d <hasExpectedCommands>
f0111a97:	83 c4 10             	add    $0x10,%esp
f0111a9a:	85 c0                	test   %eax,%eax
f0111a9c:	74 06                	je     f0111aa4 <TestAutoCompleteCommand+0x166>
		eval += 15;
f0111a9e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111aa2:	eb 10                	jmp    f0111ab4 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111aa4:	83 ec 0c             	sub    $0xc,%esp
f0111aa7:	68 f0 8e 12 f0       	push   $0xf0128ef0
f0111aac:	e8 da f4 fe ff       	call   f0100f8b <cprintf>
f0111ab1:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0111ab4:	83 ec 0c             	sub    $0xc,%esp
f0111ab7:	68 48 8f 12 f0       	push   $0xf0128f48
f0111abc:	e8 ca f4 fe ff       	call   f0100f8b <cprintf>
f0111ac1:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0111ac4:	c7 45 80 6e 8f 12 f0 	movl   $0xf0128f6e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111acb:	83 ec 08             	sub    $0x8,%esp
f0111ace:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111ad1:	50                   	push   %eax
f0111ad2:	6a 01                	push   $0x1
f0111ad4:	e8 f7 06 ff ff       	call   f01021d0 <process_command>
f0111ad9:	83 c4 10             	add    $0x10,%esp
f0111adc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111adf:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111ae3:	75 0f                	jne    f0111af4 <TestAutoCompleteCommand+0x1b6>
f0111ae5:	a1 04 f8 f1 f0       	mov    0xf0f1f804,%eax
f0111aea:	85 c0                	test   %eax,%eax
f0111aec:	75 06                	jne    f0111af4 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111aee:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111af2:	eb 10                	jmp    f0111b04 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111af4:	83 ec 0c             	sub    $0xc,%esp
f0111af7:	68 74 8f 12 f0       	push   $0xf0128f74
f0111afc:	e8 8a f4 fe ff       	call   f0100f8b <cprintf>
f0111b01:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111b04:	83 ec 0c             	sub    $0xc,%esp
f0111b07:	68 c4 8f 12 f0       	push   $0xf0128fc4
f0111b0c:	e8 7a f4 fe ff       	call   f0100f8b <cprintf>
f0111b11:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111b14:	c7 85 7c ff ff ff e9 	movl   $0xf0128fe9,-0x84(%ebp)
f0111b1b:	8f 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111b1e:	83 ec 08             	sub    $0x8,%esp
f0111b21:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111b27:	50                   	push   %eax
f0111b28:	6a 01                	push   $0x1
f0111b2a:	e8 a1 06 ff ff       	call   f01021d0 <process_command>
f0111b2f:	83 c4 10             	add    $0x10,%esp
f0111b32:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111b35:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111b39:	75 30                	jne    f0111b6b <TestAutoCompleteCommand+0x22d>
f0111b3b:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111b3e:	bb c0 92 12 f0       	mov    $0xf01292c0,%ebx
f0111b43:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111b48:	89 c7                	mov    %eax,%edi
f0111b4a:	89 de                	mov    %ebx,%esi
f0111b4c:	89 d1                	mov    %edx,%ecx
f0111b4e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111b50:	83 ec 08             	sub    $0x8,%esp
f0111b53:	6a 0c                	push   $0xc
f0111b55:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111b58:	50                   	push   %eax
f0111b59:	e8 df fc ff ff       	call   f011183d <hasExpectedCommands>
f0111b5e:	83 c4 10             	add    $0x10,%esp
f0111b61:	85 c0                	test   %eax,%eax
f0111b63:	74 06                	je     f0111b6b <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0111b65:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111b69:	eb 10                	jmp    f0111b7b <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111b6b:	83 ec 0c             	sub    $0xc,%esp
f0111b6e:	68 ec 8f 12 f0       	push   $0xf0128fec
f0111b73:	e8 13 f4 fe ff       	call   f0100f8b <cprintf>
f0111b78:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111b7b:	83 ec 0c             	sub    $0xc,%esp
f0111b7e:	68 44 90 12 f0       	push   $0xf0129044
f0111b83:	e8 03 f4 fe ff       	call   f0100f8b <cprintf>
f0111b88:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111b8b:	c7 85 78 ff ff ff 69 	movl   $0xf0129069,-0x88(%ebp)
f0111b92:	90 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111b95:	83 ec 08             	sub    $0x8,%esp
f0111b98:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111b9e:	50                   	push   %eax
f0111b9f:	6a 01                	push   $0x1
f0111ba1:	e8 2a 06 ff ff       	call   f01021d0 <process_command>
f0111ba6:	83 c4 10             	add    $0x10,%esp
f0111ba9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111bac:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111bb0:	75 30                	jne    f0111be2 <TestAutoCompleteCommand+0x2a4>
f0111bb2:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111bb5:	bb 08 93 12 f0       	mov    $0xf0129308,%ebx
f0111bba:	ba 05 00 00 00       	mov    $0x5,%edx
f0111bbf:	89 c7                	mov    %eax,%edi
f0111bc1:	89 de                	mov    %ebx,%esi
f0111bc3:	89 d1                	mov    %edx,%ecx
f0111bc5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111bc7:	83 ec 08             	sub    $0x8,%esp
f0111bca:	6a 05                	push   $0x5
f0111bcc:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111bcf:	50                   	push   %eax
f0111bd0:	e8 68 fc ff ff       	call   f011183d <hasExpectedCommands>
f0111bd5:	83 c4 10             	add    $0x10,%esp
f0111bd8:	85 c0                	test   %eax,%eax
f0111bda:	74 06                	je     f0111be2 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111bdc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111be0:	eb 10                	jmp    f0111bf2 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111be2:	83 ec 0c             	sub    $0xc,%esp
f0111be5:	68 6c 90 12 f0       	push   $0xf012906c
f0111bea:	e8 9c f3 fe ff       	call   f0100f8b <cprintf>
f0111bef:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111bf2:	83 ec 0c             	sub    $0xc,%esp
f0111bf5:	68 c4 90 12 f0       	push   $0xf01290c4
f0111bfa:	e8 8c f3 fe ff       	call   f0100f8b <cprintf>
f0111bff:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111c02:	c7 85 70 ff ff ff f0 	movl   $0xf01290f0,-0x90(%ebp)
f0111c09:	90 12 f0 
f0111c0c:	c7 85 74 ff ff ff f5 	movl   $0xf01290f5,-0x8c(%ebp)
f0111c13:	90 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111c16:	83 ec 08             	sub    $0x8,%esp
f0111c19:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111c1f:	50                   	push   %eax
f0111c20:	6a 02                	push   $0x2
f0111c22:	e8 a9 05 ff ff       	call   f01021d0 <process_command>
f0111c27:	83 c4 10             	add    $0x10,%esp
f0111c2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111c2d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111c33:	83 ec 0c             	sub    $0xc,%esp
f0111c36:	50                   	push   %eax
f0111c37:	e8 b2 fc ff ff       	call   f01118ee <getIndexOfCommand>
f0111c3c:	83 c4 10             	add    $0x10,%esp
f0111c3f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111c42:	75 0f                	jne    f0111c53 <TestAutoCompleteCommand+0x315>
f0111c44:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f0111c49:	85 c0                	test   %eax,%eax
f0111c4b:	75 06                	jne    f0111c53 <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111c4d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c51:	eb 10                	jmp    f0111c63 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111c53:	83 ec 0c             	sub    $0xc,%esp
f0111c56:	68 fc 90 12 f0       	push   $0xf01290fc
f0111c5b:	e8 2b f3 fe ff       	call   f0100f8b <cprintf>
f0111c60:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111c63:	83 ec 0c             	sub    $0xc,%esp
f0111c66:	68 4c 91 12 f0       	push   $0xf012914c
f0111c6b:	e8 1b f3 fe ff       	call   f0100f8b <cprintf>
f0111c70:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111c73:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111c79:	bb 30 93 12 f0       	mov    $0xf0129330,%ebx
f0111c7e:	ba 03 00 00 00       	mov    $0x3,%edx
f0111c83:	89 c7                	mov    %eax,%edi
f0111c85:	89 de                	mov    %ebx,%esi
f0111c87:	89 d1                	mov    %edx,%ecx
f0111c89:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111c8b:	83 ec 08             	sub    $0x8,%esp
f0111c8e:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111c94:	50                   	push   %eax
f0111c95:	6a 03                	push   $0x3
f0111c97:	e8 34 05 ff ff       	call   f01021d0 <process_command>
f0111c9c:	83 c4 10             	add    $0x10,%esp
f0111c9f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111ca2:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111ca8:	83 ec 0c             	sub    $0xc,%esp
f0111cab:	50                   	push   %eax
f0111cac:	e8 3d fc ff ff       	call   f01118ee <getIndexOfCommand>
f0111cb1:	83 c4 10             	add    $0x10,%esp
f0111cb4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111cb7:	75 0f                	jne    f0111cc8 <TestAutoCompleteCommand+0x38a>
f0111cb9:	a1 f8 f7 f1 f0       	mov    0xf0f1f7f8,%eax
f0111cbe:	85 c0                	test   %eax,%eax
f0111cc0:	75 06                	jne    f0111cc8 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111cc2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111cc6:	eb 10                	jmp    f0111cd8 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111cc8:	83 ec 0c             	sub    $0xc,%esp
f0111ccb:	68 80 91 12 f0       	push   $0xf0129180
f0111cd0:	e8 b6 f2 fe ff       	call   f0100f8b <cprintf>
f0111cd5:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111cd8:	83 ec 08             	sub    $0x8,%esp
f0111cdb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111cde:	68 d0 91 12 f0       	push   $0xf01291d0
f0111ce3:	e8 a3 f2 fe ff       	call   f0100f8b <cprintf>
f0111ce8:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111ceb:	83 ec 0c             	sub    $0xc,%esp
f0111cee:	68 00 92 12 f0       	push   $0xf0129200
f0111cf3:	e8 93 f2 fe ff       	call   f0100f8b <cprintf>
f0111cf8:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111cfb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111d00:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111d03:	5b                   	pop    %ebx
f0111d04:	5e                   	pop    %esi
f0111d05:	5f                   	pop    %edi
f0111d06:	5d                   	pop    %ebp
f0111d07:	c3                   	ret    

f0111d08 <test_str2lower_function>:

int test_str2lower_function()
{
f0111d08:	55                   	push   %ebp
f0111d09:	89 e5                	mov    %esp,%ebp
f0111d0b:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111d11:	83 ec 0c             	sub    $0xc,%esp
f0111d14:	68 3c 93 12 f0       	push   $0xf012933c
f0111d19:	e8 6d f2 fe ff       	call   f0100f8b <cprintf>
f0111d1e:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111d21:	83 ec 0c             	sub    $0xc,%esp
f0111d24:	68 5d 93 12 f0       	push   $0xf012935d
f0111d29:	e8 5d f2 fe ff       	call   f0100f8b <cprintf>
f0111d2e:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111d31:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111d38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111d3f:	c7 45 ec 77 93 12 f0 	movl   $0xf0129377,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111d46:	83 ec 08             	sub    $0x8,%esp
f0111d49:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d4c:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111d52:	50                   	push   %eax
f0111d53:	e8 3d e8 00 00       	call   f0120595 <str2lower>
f0111d58:	83 c4 10             	add    $0x10,%esp
f0111d5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111d5e:	83 ec 0c             	sub    $0xc,%esp
f0111d61:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d64:	e8 43 e1 00 00       	call   f011feac <strlen>
f0111d69:	83 c4 10             	add    $0x10,%esp
f0111d6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111d6f:	83 ec 08             	sub    $0x8,%esp
f0111d72:	68 82 93 12 f0       	push   $0xf0129382
f0111d77:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d7a:	e8 39 e2 00 00       	call   f011ffb8 <strcmp>
f0111d7f:	83 c4 10             	add    $0x10,%esp
f0111d82:	85 c0                	test   %eax,%eax
f0111d84:	75 13                	jne    f0111d99 <test_str2lower_function+0x91>
f0111d86:	83 ec 0c             	sub    $0xc,%esp
f0111d89:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d8c:	e8 1b e1 00 00       	call   f011feac <strlen>
f0111d91:	83 c4 10             	add    $0x10,%esp
f0111d94:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d97:	74 15                	je     f0111dae <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111d99:	83 ec 08             	sub    $0x8,%esp
f0111d9c:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d9f:	68 90 93 12 f0       	push   $0xf0129390
f0111da4:	e8 e2 f1 fe ff       	call   f0100f8b <cprintf>
f0111da9:	83 c4 10             	add    $0x10,%esp
f0111dac:	eb 04                	jmp    f0111db2 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111dae:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111db2:	c7 45 e0 f2 93 12 f0 	movl   $0xf01293f2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111db9:	83 ec 08             	sub    $0x8,%esp
f0111dbc:	ff 75 e0             	pushl  -0x20(%ebp)
f0111dbf:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111dc5:	50                   	push   %eax
f0111dc6:	e8 ca e7 00 00       	call   f0120595 <str2lower>
f0111dcb:	83 c4 10             	add    $0x10,%esp
f0111dce:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111dd1:	83 ec 0c             	sub    $0xc,%esp
f0111dd4:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dd7:	e8 d0 e0 00 00       	call   f011feac <strlen>
f0111ddc:	83 c4 10             	add    $0x10,%esp
f0111ddf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111de2:	83 ec 08             	sub    $0x8,%esp
f0111de5:	68 f2 93 12 f0       	push   $0xf01293f2
f0111dea:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ded:	e8 c6 e1 00 00       	call   f011ffb8 <strcmp>
f0111df2:	83 c4 10             	add    $0x10,%esp
f0111df5:	85 c0                	test   %eax,%eax
f0111df7:	75 13                	jne    f0111e0c <test_str2lower_function+0x104>
f0111df9:	83 ec 0c             	sub    $0xc,%esp
f0111dfc:	ff 75 e0             	pushl  -0x20(%ebp)
f0111dff:	e8 a8 e0 00 00       	call   f011feac <strlen>
f0111e04:	83 c4 10             	add    $0x10,%esp
f0111e07:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e0a:	74 15                	je     f0111e21 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111e0c:	83 ec 08             	sub    $0x8,%esp
f0111e0f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e12:	68 f4 93 12 f0       	push   $0xf01293f4
f0111e17:	e8 6f f1 fe ff       	call   f0100f8b <cprintf>
f0111e1c:	83 c4 10             	add    $0x10,%esp
f0111e1f:	eb 04                	jmp    f0111e25 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111e21:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111e25:	c7 45 dc 4c 94 12 f0 	movl   $0xf012944c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111e2c:	83 ec 08             	sub    $0x8,%esp
f0111e2f:	ff 75 dc             	pushl  -0x24(%ebp)
f0111e32:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111e38:	50                   	push   %eax
f0111e39:	e8 57 e7 00 00       	call   f0120595 <str2lower>
f0111e3e:	83 c4 10             	add    $0x10,%esp
f0111e41:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e44:	83 ec 0c             	sub    $0xc,%esp
f0111e47:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e4a:	e8 5d e0 00 00       	call   f011feac <strlen>
f0111e4f:	83 c4 10             	add    $0x10,%esp
f0111e52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111e55:	83 ec 08             	sub    $0x8,%esp
f0111e58:	68 4c 94 12 f0       	push   $0xf012944c
f0111e5d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e60:	e8 53 e1 00 00       	call   f011ffb8 <strcmp>
f0111e65:	83 c4 10             	add    $0x10,%esp
f0111e68:	85 c0                	test   %eax,%eax
f0111e6a:	75 13                	jne    f0111e7f <test_str2lower_function+0x177>
f0111e6c:	83 ec 0c             	sub    $0xc,%esp
f0111e6f:	ff 75 dc             	pushl  -0x24(%ebp)
f0111e72:	e8 35 e0 00 00       	call   f011feac <strlen>
f0111e77:	83 c4 10             	add    $0x10,%esp
f0111e7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e7d:	74 15                	je     f0111e94 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111e7f:	83 ec 08             	sub    $0x8,%esp
f0111e82:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e85:	68 58 94 12 f0       	push   $0xf0129458
f0111e8a:	e8 fc f0 fe ff       	call   f0100f8b <cprintf>
f0111e8f:	83 c4 10             	add    $0x10,%esp
f0111e92:	eb 04                	jmp    f0111e98 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111e94:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111e98:	c7 45 d8 bb 94 12 f0 	movl   $0xf01294bb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111e9f:	83 ec 08             	sub    $0x8,%esp
f0111ea2:	ff 75 d8             	pushl  -0x28(%ebp)
f0111ea5:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111eab:	50                   	push   %eax
f0111eac:	e8 e4 e6 00 00       	call   f0120595 <str2lower>
f0111eb1:	83 c4 10             	add    $0x10,%esp
f0111eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111eb7:	83 ec 0c             	sub    $0xc,%esp
f0111eba:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ebd:	e8 ea df 00 00       	call   f011feac <strlen>
f0111ec2:	83 c4 10             	add    $0x10,%esp
f0111ec5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111ec8:	83 ec 08             	sub    $0x8,%esp
f0111ecb:	68 bb 94 12 f0       	push   $0xf01294bb
f0111ed0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ed3:	e8 e0 e0 00 00       	call   f011ffb8 <strcmp>
f0111ed8:	83 c4 10             	add    $0x10,%esp
f0111edb:	85 c0                	test   %eax,%eax
f0111edd:	75 13                	jne    f0111ef2 <test_str2lower_function+0x1ea>
f0111edf:	83 ec 0c             	sub    $0xc,%esp
f0111ee2:	ff 75 d8             	pushl  -0x28(%ebp)
f0111ee5:	e8 c2 df 00 00       	call   f011feac <strlen>
f0111eea:	83 c4 10             	add    $0x10,%esp
f0111eed:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111ef0:	74 15                	je     f0111f07 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111ef2:	83 ec 08             	sub    $0x8,%esp
f0111ef5:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ef8:	68 c8 94 12 f0       	push   $0xf01294c8
f0111efd:	e8 89 f0 fe ff       	call   f0100f8b <cprintf>
f0111f02:	83 c4 10             	add    $0x10,%esp
f0111f05:	eb 04                	jmp    f0111f0b <test_str2lower_function+0x203>
	else
		eval += 15;
f0111f07:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111f0b:	c7 45 d4 2a 95 12 f0 	movl   $0xf012952a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111f12:	83 ec 08             	sub    $0x8,%esp
f0111f15:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f18:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111f1e:	50                   	push   %eax
f0111f1f:	e8 71 e6 00 00       	call   f0120595 <str2lower>
f0111f24:	83 c4 10             	add    $0x10,%esp
f0111f27:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f2a:	83 ec 0c             	sub    $0xc,%esp
f0111f2d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f30:	e8 77 df 00 00       	call   f011feac <strlen>
f0111f35:	83 c4 10             	add    $0x10,%esp
f0111f38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111f3b:	83 ec 08             	sub    $0x8,%esp
f0111f3e:	68 40 95 12 f0       	push   $0xf0129540
f0111f43:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f46:	e8 6d e0 00 00       	call   f011ffb8 <strcmp>
f0111f4b:	83 c4 10             	add    $0x10,%esp
f0111f4e:	85 c0                	test   %eax,%eax
f0111f50:	75 13                	jne    f0111f65 <test_str2lower_function+0x25d>
f0111f52:	83 ec 0c             	sub    $0xc,%esp
f0111f55:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f58:	e8 4f df 00 00       	call   f011feac <strlen>
f0111f5d:	83 c4 10             	add    $0x10,%esp
f0111f60:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f63:	74 15                	je     f0111f7a <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111f65:	83 ec 08             	sub    $0x8,%esp
f0111f68:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f6b:	68 58 95 12 f0       	push   $0xf0129558
f0111f70:	e8 16 f0 fe ff       	call   f0100f8b <cprintf>
f0111f75:	83 c4 10             	add    $0x10,%esp
f0111f78:	eb 04                	jmp    f0111f7e <test_str2lower_function+0x276>
	else
		eval += 15;
f0111f7a:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111f7e:	c7 45 d0 c5 95 12 f0 	movl   $0xf01295c5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111f85:	83 ec 08             	sub    $0x8,%esp
f0111f88:	ff 75 d0             	pushl  -0x30(%ebp)
f0111f8b:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111f91:	50                   	push   %eax
f0111f92:	e8 fe e5 00 00       	call   f0120595 <str2lower>
f0111f97:	83 c4 10             	add    $0x10,%esp
f0111f9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f9d:	83 ec 0c             	sub    $0xc,%esp
f0111fa0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fa3:	e8 04 df 00 00       	call   f011feac <strlen>
f0111fa8:	83 c4 10             	add    $0x10,%esp
f0111fab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111fae:	83 ec 08             	sub    $0x8,%esp
f0111fb1:	68 d1 95 12 f0       	push   $0xf01295d1
f0111fb6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fb9:	e8 fa df 00 00       	call   f011ffb8 <strcmp>
f0111fbe:	83 c4 10             	add    $0x10,%esp
f0111fc1:	85 c0                	test   %eax,%eax
f0111fc3:	75 13                	jne    f0111fd8 <test_str2lower_function+0x2d0>
f0111fc5:	83 ec 0c             	sub    $0xc,%esp
f0111fc8:	ff 75 d0             	pushl  -0x30(%ebp)
f0111fcb:	e8 dc de 00 00       	call   f011feac <strlen>
f0111fd0:	83 c4 10             	add    $0x10,%esp
f0111fd3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111fd6:	74 15                	je     f0111fed <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111fd8:	83 ec 08             	sub    $0x8,%esp
f0111fdb:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fde:	68 e0 95 12 f0       	push   $0xf01295e0
f0111fe3:	e8 a3 ef fe ff       	call   f0100f8b <cprintf>
f0111fe8:	83 c4 10             	add    $0x10,%esp
f0111feb:	eb 04                	jmp    f0111ff1 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111fed:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111ff1:	c7 45 cc 43 96 12 f0 	movl   $0xf0129643,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111ff8:	83 ec 08             	sub    $0x8,%esp
f0111ffb:	ff 75 cc             	pushl  -0x34(%ebp)
f0111ffe:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0112004:	50                   	push   %eax
f0112005:	e8 8b e5 00 00       	call   f0120595 <str2lower>
f011200a:	83 c4 10             	add    $0x10,%esp
f011200d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112010:	83 ec 0c             	sub    $0xc,%esp
f0112013:	ff 75 e8             	pushl  -0x18(%ebp)
f0112016:	e8 91 de 00 00       	call   f011feac <strlen>
f011201b:	83 c4 10             	add    $0x10,%esp
f011201e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0112021:	83 ec 08             	sub    $0x8,%esp
f0112024:	68 5e 96 12 f0       	push   $0xf012965e
f0112029:	ff 75 e8             	pushl  -0x18(%ebp)
f011202c:	e8 87 df 00 00       	call   f011ffb8 <strcmp>
f0112031:	83 c4 10             	add    $0x10,%esp
f0112034:	85 c0                	test   %eax,%eax
f0112036:	75 13                	jne    f011204b <test_str2lower_function+0x343>
f0112038:	83 ec 0c             	sub    $0xc,%esp
f011203b:	ff 75 cc             	pushl  -0x34(%ebp)
f011203e:	e8 69 de 00 00       	call   f011feac <strlen>
f0112043:	83 c4 10             	add    $0x10,%esp
f0112046:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112049:	74 15                	je     f0112060 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f011204b:	83 ec 08             	sub    $0x8,%esp
f011204e:	ff 75 e8             	pushl  -0x18(%ebp)
f0112051:	68 7c 96 12 f0       	push   $0xf012967c
f0112056:	e8 30 ef fe ff       	call   f0100f8b <cprintf>
f011205b:	83 c4 10             	add    $0x10,%esp
f011205e:	eb 04                	jmp    f0112064 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0112060:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0112064:	83 ec 08             	sub    $0x8,%esp
f0112067:	ff 75 f4             	pushl  -0xc(%ebp)
f011206a:	68 f0 96 12 f0       	push   $0xf01296f0
f011206f:	e8 17 ef fe ff       	call   f0100f8b <cprintf>
f0112074:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0112077:	83 ec 0c             	sub    $0xc,%esp
f011207a:	68 00 92 12 f0       	push   $0xf0129200
f011207f:	e8 07 ef fe ff       	call   f0100f8b <cprintf>
f0112084:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112087:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011208c:	c9                   	leave  
f011208d:	c3                   	ret    

f011208e <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f011208e:	55                   	push   %ebp
f011208f:	89 e5                	mov    %esp,%ebp
f0112091:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0112094:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011209b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01120a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120a9:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01120ae:	ff 75 ec             	pushl  -0x14(%ebp)
f01120b1:	ff 75 f0             	pushl  -0x10(%ebp)
f01120b4:	ff 75 f4             	pushl  -0xc(%ebp)
f01120b7:	50                   	push   %eax
f01120b8:	e8 37 7e ff ff       	call   f0109ef4 <pt_set_page_permissions>
f01120bd:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120c0:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01120c5:	ff 75 ec             	pushl  -0x14(%ebp)
f01120c8:	ff 75 f0             	pushl  -0x10(%ebp)
f01120cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01120ce:	50                   	push   %eax
f01120cf:	e8 74 4b 00 00       	call   f0116c48 <CP>
f01120d4:	83 c4 10             	add    $0x10,%esp
f01120d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01120da:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01120de:	74 17                	je     f01120f7 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f01120e0:	83 ec 04             	sub    $0x4,%esp
f01120e3:	68 20 97 12 f0       	push   $0xf0129720
f01120e8:	68 23 01 00 00       	push   $0x123
f01120ed:	68 42 97 12 f0       	push   $0xf0129742
f01120f2:	e8 42 e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f01120f7:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f01120fe:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0112105:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011210c:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112111:	ff 75 ec             	pushl  -0x14(%ebp)
f0112114:	ff 75 f0             	pushl  -0x10(%ebp)
f0112117:	ff 75 f4             	pushl  -0xc(%ebp)
f011211a:	50                   	push   %eax
f011211b:	e8 d4 7d ff ff       	call   f0109ef4 <pt_set_page_permissions>
f0112120:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112123:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112128:	ff 75 ec             	pushl  -0x14(%ebp)
f011212b:	ff 75 f0             	pushl  -0x10(%ebp)
f011212e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112131:	50                   	push   %eax
f0112132:	e8 11 4b 00 00       	call   f0116c48 <CP>
f0112137:	83 c4 10             	add    $0x10,%esp
f011213a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011213d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112141:	74 17                	je     f011215a <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0112143:	83 ec 04             	sub    $0x4,%esp
f0112146:	68 60 97 12 f0       	push   $0xf0129760
f011214b:	68 2f 01 00 00       	push   $0x12f
f0112150:	68 42 97 12 f0       	push   $0xf0129742
f0112155:	e8 df e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f011215a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0112161:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0112168:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011216f:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112174:	ff 75 ec             	pushl  -0x14(%ebp)
f0112177:	ff 75 f0             	pushl  -0x10(%ebp)
f011217a:	ff 75 f4             	pushl  -0xc(%ebp)
f011217d:	50                   	push   %eax
f011217e:	e8 71 7d ff ff       	call   f0109ef4 <pt_set_page_permissions>
f0112183:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112186:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011218b:	ff 75 ec             	pushl  -0x14(%ebp)
f011218e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112191:	ff 75 f4             	pushl  -0xc(%ebp)
f0112194:	50                   	push   %eax
f0112195:	e8 ae 4a 00 00       	call   f0116c48 <CP>
f011219a:	83 c4 10             	add    $0x10,%esp
f011219d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01121a0:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01121a4:	74 17                	je     f01121bd <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01121a6:	83 ec 04             	sub    $0x4,%esp
f01121a9:	68 84 97 12 f0       	push   $0xf0129784
f01121ae:	68 3a 01 00 00       	push   $0x13a
f01121b3:	68 42 97 12 f0       	push   $0xf0129742
f01121b8:	e8 7c e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01121bd:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01121c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01121cb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121d2:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01121d7:	ff 75 ec             	pushl  -0x14(%ebp)
f01121da:	ff 75 f0             	pushl  -0x10(%ebp)
f01121dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01121e0:	50                   	push   %eax
f01121e1:	e8 0e 7d ff ff       	call   f0109ef4 <pt_set_page_permissions>
f01121e6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121e9:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01121ee:	ff 75 ec             	pushl  -0x14(%ebp)
f01121f1:	ff 75 f0             	pushl  -0x10(%ebp)
f01121f4:	ff 75 f4             	pushl  -0xc(%ebp)
f01121f7:	50                   	push   %eax
f01121f8:	e8 4b 4a 00 00       	call   f0116c48 <CP>
f01121fd:	83 c4 10             	add    $0x10,%esp
f0112200:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112203:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112207:	74 17                	je     f0112220 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112209:	83 ec 04             	sub    $0x4,%esp
f011220c:	68 a8 97 12 f0       	push   $0xf01297a8
f0112211:	68 46 01 00 00       	push   $0x146
f0112216:	68 42 97 12 f0       	push   $0xf0129742
f011221b:	e8 19 e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0112220:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112227:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f011222e:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112235:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011223a:	ff 75 ec             	pushl  -0x14(%ebp)
f011223d:	ff 75 f0             	pushl  -0x10(%ebp)
f0112240:	ff 75 f4             	pushl  -0xc(%ebp)
f0112243:	50                   	push   %eax
f0112244:	e8 ab 7c ff ff       	call   f0109ef4 <pt_set_page_permissions>
f0112249:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011224c:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112251:	ff 75 ec             	pushl  -0x14(%ebp)
f0112254:	ff 75 f0             	pushl  -0x10(%ebp)
f0112257:	ff 75 f4             	pushl  -0xc(%ebp)
f011225a:	50                   	push   %eax
f011225b:	e8 e8 49 00 00       	call   f0116c48 <CP>
f0112260:	83 c4 10             	add    $0x10,%esp
f0112263:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112266:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011226a:	74 17                	je     f0112283 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f011226c:	83 ec 04             	sub    $0x4,%esp
f011226f:	68 cc 97 12 f0       	push   $0xf01297cc
f0112274:	68 52 01 00 00       	push   $0x152
f0112279:	68 42 97 12 f0       	push   $0xf0129742
f011227e:	e8 b6 e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0112283:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f011228a:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112291:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112298:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011229d:	ff 75 ec             	pushl  -0x14(%ebp)
f01122a0:	ff 75 f0             	pushl  -0x10(%ebp)
f01122a3:	ff 75 f4             	pushl  -0xc(%ebp)
f01122a6:	50                   	push   %eax
f01122a7:	e8 48 7c ff ff       	call   f0109ef4 <pt_set_page_permissions>
f01122ac:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122af:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01122b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01122b7:	ff 75 f0             	pushl  -0x10(%ebp)
f01122ba:	ff 75 f4             	pushl  -0xc(%ebp)
f01122bd:	50                   	push   %eax
f01122be:	e8 85 49 00 00       	call   f0116c48 <CP>
f01122c3:	83 c4 10             	add    $0x10,%esp
f01122c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01122c9:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01122cd:	74 17                	je     f01122e6 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01122cf:	83 ec 04             	sub    $0x4,%esp
f01122d2:	68 f0 97 12 f0       	push   $0xf01297f0
f01122d7:	68 5e 01 00 00       	push   $0x15e
f01122dc:	68 42 97 12 f0       	push   $0xf0129742
f01122e1:	e8 53 e0 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f01122e6:	83 ec 0c             	sub    $0xc,%esp
f01122e9:	68 1c 98 12 f0       	push   $0xf012981c
f01122ee:	e8 98 ec fe ff       	call   f0100f8b <cprintf>
f01122f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01122f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01122fb:	c9                   	leave  
f01122fc:	c3                   	ret    

f01122fd <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f01122fd:	55                   	push   %ebp
f01122fe:	89 e5                	mov    %esp,%ebp
f0112300:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0112303:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011230a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112311:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112318:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011231d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112320:	ff 75 f0             	pushl  -0x10(%ebp)
f0112323:	ff 75 f4             	pushl  -0xc(%ebp)
f0112326:	50                   	push   %eax
f0112327:	e8 c8 7b ff ff       	call   f0109ef4 <pt_set_page_permissions>
f011232c:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f011232f:	83 ec 04             	sub    $0x4,%esp
f0112332:	68 6c 98 12 f0       	push   $0xf012986c
f0112337:	68 6b 01 00 00       	push   $0x16b
f011233c:	68 42 97 12 f0       	push   $0xf0129742
f0112341:	e8 f3 df fe ff       	call   f0100339 <_panic>

f0112346 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112346:	55                   	push   %ebp
f0112347:	89 e5                	mov    %esp,%ebp
f0112349:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f011234c:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0112353:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112358:	83 ec 08             	sub    $0x8,%esp
f011235b:	ff 75 f4             	pushl  -0xc(%ebp)
f011235e:	50                   	push   %eax
f011235f:	e8 54 7c ff ff       	call   f0109fb8 <pt_get_page_permissions>
f0112364:	83 c4 10             	add    $0x10,%esp
f0112367:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f011236a:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f011236e:	74 17                	je     f0112387 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0112370:	83 ec 04             	sub    $0x4,%esp
f0112373:	68 08 99 12 f0       	push   $0xf0129908
f0112378:	68 79 01 00 00       	push   $0x179
f011237d:	68 42 97 12 f0       	push   $0xf0129742
f0112382:	e8 b2 df fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0112387:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011238e:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112393:	83 ec 08             	sub    $0x8,%esp
f0112396:	ff 75 f4             	pushl  -0xc(%ebp)
f0112399:	50                   	push   %eax
f011239a:	e8 19 7c ff ff       	call   f0109fb8 <pt_get_page_permissions>
f011239f:	83 c4 10             	add    $0x10,%esp
f01123a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01123a5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01123a9:	74 17                	je     f01123c2 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01123ab:	83 ec 04             	sub    $0x4,%esp
f01123ae:	68 2c 99 12 f0       	push   $0xf012992c
f01123b3:	68 81 01 00 00       	push   $0x181
f01123b8:	68 42 97 12 f0       	push   $0xf0129742
f01123bd:	e8 77 df fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01123c2:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01123c9:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01123ce:	83 ec 08             	sub    $0x8,%esp
f01123d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01123d4:	50                   	push   %eax
f01123d5:	e8 de 7b ff ff       	call   f0109fb8 <pt_get_page_permissions>
f01123da:	83 c4 10             	add    $0x10,%esp
f01123dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01123e0:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01123e4:	74 17                	je     f01123fd <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f01123e6:	83 ec 04             	sub    $0x4,%esp
f01123e9:	68 50 99 12 f0       	push   $0xf0129950
f01123ee:	68 89 01 00 00       	push   $0x189
f01123f3:	68 42 97 12 f0       	push   $0xf0129742
f01123f8:	e8 3c df fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f01123fd:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112404:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112409:	83 ec 08             	sub    $0x8,%esp
f011240c:	ff 75 f4             	pushl  -0xc(%ebp)
f011240f:	50                   	push   %eax
f0112410:	e8 a3 7b ff ff       	call   f0109fb8 <pt_get_page_permissions>
f0112415:	83 c4 10             	add    $0x10,%esp
f0112418:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011241b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011241f:	74 17                	je     f0112438 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0112421:	83 ec 04             	sub    $0x4,%esp
f0112424:	68 74 99 12 f0       	push   $0xf0129974
f0112429:	68 90 01 00 00       	push   $0x190
f011242e:	68 42 97 12 f0       	push   $0xf0129742
f0112433:	e8 01 df fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112438:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011243f:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112444:	83 ec 08             	sub    $0x8,%esp
f0112447:	ff 75 f4             	pushl  -0xc(%ebp)
f011244a:	50                   	push   %eax
f011244b:	e8 68 7b ff ff       	call   f0109fb8 <pt_get_page_permissions>
f0112450:	83 c4 10             	add    $0x10,%esp
f0112453:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112456:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f011245a:	74 17                	je     f0112473 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f011245c:	83 ec 04             	sub    $0x4,%esp
f011245f:	68 98 99 12 f0       	push   $0xf0129998
f0112464:	68 97 01 00 00       	push   $0x197
f0112469:	68 42 97 12 f0       	push   $0xf0129742
f011246e:	e8 c6 de fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0112473:	83 ec 0c             	sub    $0xc,%esp
f0112476:	68 bc 99 12 f0       	push   $0xf01299bc
f011247b:	e8 0b eb fe ff       	call   f0100f8b <cprintf>
f0112480:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112483:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112488:	c9                   	leave  
f0112489:	c3                   	ret    

f011248a <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f011248a:	55                   	push   %ebp
f011248b:	89 e5                	mov    %esp,%ebp
f011248d:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112490:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112497:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011249c:	83 ec 08             	sub    $0x8,%esp
f011249f:	ff 75 f4             	pushl  -0xc(%ebp)
f01124a2:	50                   	push   %eax
f01124a3:	e8 59 7b ff ff       	call   f010a001 <pt_clear_page_table_entry>
f01124a8:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01124ab:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01124b0:	83 ec 08             	sub    $0x8,%esp
f01124b3:	ff 75 f4             	pushl  -0xc(%ebp)
f01124b6:	50                   	push   %eax
f01124b7:	e8 e8 46 00 00       	call   f0116ba4 <CE>
f01124bc:	83 c4 10             	add    $0x10,%esp
f01124bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01124c2:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01124c6:	74 17                	je     f01124df <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01124c8:	83 ec 04             	sub    $0x4,%esp
f01124cb:	68 04 9a 12 f0       	push   $0xf0129a04
f01124d0:	68 a7 01 00 00       	push   $0x1a7
f01124d5:	68 42 97 12 f0       	push   $0xf0129742
f01124da:	e8 5a de fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01124df:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01124e6:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01124eb:	83 ec 08             	sub    $0x8,%esp
f01124ee:	ff 75 f4             	pushl  -0xc(%ebp)
f01124f1:	50                   	push   %eax
f01124f2:	e8 0a 7b ff ff       	call   f010a001 <pt_clear_page_table_entry>
f01124f7:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01124fa:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01124ff:	83 ec 08             	sub    $0x8,%esp
f0112502:	ff 75 f4             	pushl  -0xc(%ebp)
f0112505:	50                   	push   %eax
f0112506:	e8 99 46 00 00       	call   f0116ba4 <CE>
f011250b:	83 c4 10             	add    $0x10,%esp
f011250e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112511:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112515:	74 17                	je     f011252e <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112517:	83 ec 04             	sub    $0x4,%esp
f011251a:	68 30 9a 12 f0       	push   $0xf0129a30
f011251f:	68 af 01 00 00       	push   $0x1af
f0112524:	68 42 97 12 f0       	push   $0xf0129742
f0112529:	e8 0b de fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f011252e:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112535:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011253a:	83 ec 08             	sub    $0x8,%esp
f011253d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112540:	50                   	push   %eax
f0112541:	e8 bb 7a ff ff       	call   f010a001 <pt_clear_page_table_entry>
f0112546:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112549:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011254e:	83 ec 08             	sub    $0x8,%esp
f0112551:	ff 75 f4             	pushl  -0xc(%ebp)
f0112554:	50                   	push   %eax
f0112555:	e8 4a 46 00 00       	call   f0116ba4 <CE>
f011255a:	83 c4 10             	add    $0x10,%esp
f011255d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112560:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112564:	74 17                	je     f011257d <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112566:	83 ec 04             	sub    $0x4,%esp
f0112569:	68 5c 9a 12 f0       	push   $0xf0129a5c
f011256e:	68 b7 01 00 00       	push   $0x1b7
f0112573:	68 42 97 12 f0       	push   $0xf0129742
f0112578:	e8 bc dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f011257d:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112584:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0112589:	83 ec 08             	sub    $0x8,%esp
f011258c:	ff 75 f4             	pushl  -0xc(%ebp)
f011258f:	50                   	push   %eax
f0112590:	e8 6c 7a ff ff       	call   f010a001 <pt_clear_page_table_entry>
f0112595:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112598:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011259d:	83 ec 08             	sub    $0x8,%esp
f01125a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01125a3:	50                   	push   %eax
f01125a4:	e8 fb 45 00 00       	call   f0116ba4 <CE>
f01125a9:	83 c4 10             	add    $0x10,%esp
f01125ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01125af:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01125b3:	74 17                	je     f01125cc <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01125b5:	83 ec 04             	sub    $0x4,%esp
f01125b8:	68 88 9a 12 f0       	push   $0xf0129a88
f01125bd:	68 bf 01 00 00       	push   $0x1bf
f01125c2:	68 42 97 12 f0       	push   $0xf0129742
f01125c7:	e8 6d dd fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01125cc:	83 ec 0c             	sub    $0xc,%esp
f01125cf:	68 b4 9a 12 f0       	push   $0xf0129ab4
f01125d4:	e8 b2 e9 fe ff       	call   f0100f8b <cprintf>
f01125d9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01125dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01125e1:	c9                   	leave  
f01125e2:	c3                   	ret    

f01125e3 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f01125e3:	55                   	push   %ebp
f01125e4:	89 e5                	mov    %esp,%ebp
f01125e6:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f01125e9:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01125f0:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f01125f5:	83 ec 08             	sub    $0x8,%esp
f01125f8:	ff 75 f4             	pushl  -0xc(%ebp)
f01125fb:	50                   	push   %eax
f01125fc:	e8 00 7a ff ff       	call   f010a001 <pt_clear_page_table_entry>
f0112601:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112604:	83 ec 04             	sub    $0x4,%esp
f0112607:	68 00 9b 12 f0       	push   $0xf0129b00
f011260c:	68 ca 01 00 00       	push   $0x1ca
f0112611:	68 42 97 12 f0       	push   $0xf0129742
f0112616:	e8 1e dd fe ff       	call   f0100339 <_panic>

f011261b <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f011261b:	55                   	push   %ebp
f011261c:	89 e5                	mov    %esp,%ebp
f011261e:	57                   	push   %edi
f011261f:	56                   	push   %esi
f0112620:	53                   	push   %ebx
f0112621:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112627:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011262d:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f0112632:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112637:	89 c7                	mov    %eax,%edi
f0112639:	89 de                	mov    %ebx,%esi
f011263b:	89 d1                	mov    %edx,%ecx
f011263d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011263f:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0112645:	b9 23 00 00 00       	mov    $0x23,%ecx
f011264a:	b0 00                	mov    $0x0,%al
f011264c:	89 d7                	mov    %edx,%edi
f011264e:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112650:	6a 00                	push   $0x0
f0112652:	6a 0a                	push   $0xa
f0112654:	6a 14                	push   $0x14
f0112656:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011265c:	50                   	push   %eax
f011265d:	e8 90 8b ff ff       	call   f010b1f2 <env_create>
f0112662:	83 c4 10             	add    $0x10,%esp
f0112665:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112668:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011266b:	8b 40 64             	mov    0x64(%eax),%eax
f011266e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112671:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112674:	8b 40 68             	mov    0x68(%eax),%eax
f0112677:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f011267a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011267d:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112680:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0112687:	75 70 20 
f011268a:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112691:	00 00 00 
f0112694:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f011269a:	b9 03 00 00 00       	mov    $0x3,%ecx
f011269f:	b8 00 00 00 00       	mov    $0x0,%eax
f01126a4:	89 d7                	mov    %edx,%edi
f01126a6:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01126a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01126ab:	8b 40 10             	mov    0x10(%eax),%eax
f01126ae:	83 ec 08             	sub    $0x8,%esp
f01126b1:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01126b7:	52                   	push   %edx
f01126b8:	50                   	push   %eax
f01126b9:	e8 94 dc 00 00       	call   f0120352 <ltostr>
f01126be:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01126c1:	83 ec 04             	sub    $0x4,%esp
f01126c4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126ca:	50                   	push   %eax
f01126cb:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f01126d1:	50                   	push   %eax
f01126d2:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f01126d8:	50                   	push   %eax
f01126d9:	e8 4d dd 00 00       	call   f012042b <strcconcat>
f01126de:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f01126e1:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f01126e8:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01126ef:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01126f6:	83 ec 0c             	sub    $0xc,%esp
f01126f9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126fc:	e8 85 45 00 00       	call   f0116c86 <ClearUserSpace>
f0112701:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112704:	83 ec 04             	sub    $0x4,%esp
f0112707:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011270d:	50                   	push   %eax
f011270e:	68 96 9b 12 f0       	push   $0xf0129b96
f0112713:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112719:	50                   	push   %eax
f011271a:	e8 0c dd 00 00       	call   f012042b <strcconcat>
f011271f:	83 c4 10             	add    $0x10,%esp
f0112722:	83 ec 0c             	sub    $0xc,%esp
f0112725:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011272b:	50                   	push   %eax
f011272c:	e8 ca f7 fe ff       	call   f0101efb <execute_command>
f0112731:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0112734:	83 ec 04             	sub    $0x4,%esp
f0112737:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f011273d:	50                   	push   %eax
f011273e:	68 a1 9b 12 f0       	push   $0xf0129ba1
f0112743:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112749:	50                   	push   %eax
f011274a:	e8 dc dc 00 00       	call   f012042b <strcconcat>
f011274f:	83 c4 10             	add    $0x10,%esp
f0112752:	83 ec 0c             	sub    $0xc,%esp
f0112755:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f011275b:	50                   	push   %eax
f011275c:	e8 9a f7 fe ff       	call   f0101efb <execute_command>
f0112761:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0112764:	83 ec 04             	sub    $0x4,%esp
f0112767:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f011276d:	50                   	push   %eax
f011276e:	68 ac 9b 12 f0       	push   $0xf0129bac
f0112773:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112779:	50                   	push   %eax
f011277a:	e8 ac dc 00 00       	call   f012042b <strcconcat>
f011277f:	83 c4 10             	add    $0x10,%esp
f0112782:	83 ec 0c             	sub    $0xc,%esp
f0112785:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f011278b:	50                   	push   %eax
f011278c:	e8 6a f7 fe ff       	call   f0101efb <execute_command>
f0112791:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112794:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f011279b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011279e:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f01127a1:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01127a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01127ab:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01127ae:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01127b5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01127b8:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f01127bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01127be:	83 ec 08             	sub    $0x8,%esp
f01127c1:	50                   	push   %eax
f01127c2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127c5:	e8 9d 44 00 00       	call   f0116c67 <GP>
f01127ca:	83 c4 10             	add    $0x10,%esp
f01127cd:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01127d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f01127d7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f01127de:	e8 af c3 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01127e3:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f01127e6:	83 ec 0c             	sub    $0xc,%esp
f01127e9:	68 b8 9b 12 f0       	push   $0xf0129bb8
f01127ee:	e8 98 e7 fe ff       	call   f0100f8b <cprintf>
f01127f3:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01127f6:	6a 03                	push   $0x3
f01127f8:	68 00 00 90 02       	push   $0x2900000
f01127fd:	68 00 00 80 02       	push   $0x2800000
f0112802:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112805:	e8 6b 85 ff ff       	call   f010ad75 <cut_paste_pages>
f011280a:	83 c4 10             	add    $0x10,%esp
f011280d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112810:	e8 7d c3 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112815:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112818:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f011281f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112823:	75 08                	jne    f011282d <test_cut_paste_pages+0x212>
f0112825:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112828:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011282b:	74 2b                	je     f0112858 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011282d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112830:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112833:	83 ec 0c             	sub    $0xc,%esp
f0112836:	50                   	push   %eax
f0112837:	ff 75 b4             	pushl  -0x4c(%ebp)
f011283a:	68 e8 9b 12 f0       	push   $0xf0129be8
f011283f:	68 04 02 00 00       	push   $0x204
f0112844:	68 42 97 12 f0       	push   $0xf0129742
f0112849:	e8 88 dc fe ff       	call   f01004d6 <_warn>
f011284e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112851:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112858:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011285c:	74 04                	je     f0112862 <test_cut_paste_pages+0x247>
f011285e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112862:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112869:	83 ec 08             	sub    $0x8,%esp
f011286c:	6a 00                	push   $0x0
f011286e:	6a 01                	push   $0x1
f0112870:	6a 00                	push   $0x0
f0112872:	68 ff 0f 00 00       	push   $0xfff
f0112877:	ff 75 bc             	pushl  -0x44(%ebp)
f011287a:	6a 01                	push   $0x1
f011287c:	68 00 30 00 00       	push   $0x3000
f0112881:	68 00 00 90 02       	push   $0x2900000
f0112886:	68 00 00 80 02       	push   $0x2800000
f011288b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011288e:	e8 27 44 00 00       	call   f0116cba <CCP>
f0112893:	83 c4 30             	add    $0x30,%esp
f0112896:	83 f8 01             	cmp    $0x1,%eax
f0112899:	74 21                	je     f01128bc <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011289b:	83 ec 04             	sub    $0x4,%esp
f011289e:	68 3c 9c 12 f0       	push   $0xf0129c3c
f01128a3:	68 0c 02 00 00       	push   $0x20c
f01128a8:	68 42 97 12 f0       	push   $0xf0129742
f01128ad:	e8 24 dc fe ff       	call   f01004d6 <_warn>
f01128b2:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01128b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f01128bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128c0:	74 04                	je     f01128c6 <test_cut_paste_pages+0x2ab>
f01128c2:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f01128c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01128cd:	83 ec 04             	sub    $0x4,%esp
f01128d0:	6a 00                	push   $0x0
f01128d2:	68 00 00 90 02       	push   $0x2900000
f01128d7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128da:	e8 b7 41 00 00       	call   f0116a96 <CB>
f01128df:	83 c4 10             	add    $0x10,%esp
f01128e2:	85 c0                	test   %eax,%eax
f01128e4:	0f 84 f6 00 00 00    	je     f01129e0 <test_cut_paste_pages+0x3c5>
f01128ea:	83 ec 04             	sub    $0x4,%esp
f01128ed:	6a 00                	push   $0x0
f01128ef:	68 00 10 90 02       	push   $0x2901000
f01128f4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128f7:	e8 9a 41 00 00       	call   f0116a96 <CB>
f01128fc:	83 c4 10             	add    $0x10,%esp
f01128ff:	85 c0                	test   %eax,%eax
f0112901:	0f 84 d9 00 00 00    	je     f01129e0 <test_cut_paste_pages+0x3c5>
f0112907:	83 ec 04             	sub    $0x4,%esp
f011290a:	6a 00                	push   $0x0
f011290c:	68 00 20 90 02       	push   $0x2902000
f0112911:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112914:	e8 7d 41 00 00       	call   f0116a96 <CB>
f0112919:	83 c4 10             	add    $0x10,%esp
f011291c:	85 c0                	test   %eax,%eax
f011291e:	0f 84 bc 00 00 00    	je     f01129e0 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112924:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f011292b:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112932:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112939:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011293c:	8a 00                	mov    (%eax),%al
f011293e:	3c 61                	cmp    $0x61,%al
f0112940:	75 12                	jne    f0112954 <test_cut_paste_pages+0x339>
f0112942:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112945:	8a 00                	mov    (%eax),%al
f0112947:	3c 62                	cmp    $0x62,%al
f0112949:	75 09                	jne    f0112954 <test_cut_paste_pages+0x339>
f011294b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011294e:	8a 00                	mov    (%eax),%al
f0112950:	3c 63                	cmp    $0x63,%al
f0112952:	74 21                	je     f0112975 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112954:	83 ec 04             	sub    $0x4,%esp
f0112957:	68 88 9c 12 f0       	push   $0xf0129c88
f011295c:	68 19 02 00 00       	push   $0x219
f0112961:	68 42 97 12 f0       	push   $0xf0129742
f0112966:	e8 6b db fe ff       	call   f01004d6 <_warn>
f011296b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011296e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112975:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112979:	74 04                	je     f011297f <test_cut_paste_pages+0x364>
f011297b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011297f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112986:	83 ec 04             	sub    $0x4,%esp
f0112989:	6a 01                	push   $0x1
f011298b:	68 00 10 90 02       	push   $0x2901000
f0112990:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112993:	e8 fe 40 00 00       	call   f0116a96 <CB>
f0112998:	83 c4 10             	add    $0x10,%esp
f011299b:	85 c0                	test   %eax,%eax
f011299d:	74 41                	je     f01129e0 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f011299f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01129a2:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01129a5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01129a8:	8a 00                	mov    (%eax),%al
f01129aa:	3c 79                	cmp    $0x79,%al
f01129ac:	74 21                	je     f01129cf <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01129ae:	83 ec 04             	sub    $0x4,%esp
f01129b1:	68 88 9c 12 f0       	push   $0xf0129c88
f01129b6:	68 24 02 00 00       	push   $0x224
f01129bb:	68 42 97 12 f0       	push   $0xf0129742
f01129c0:	e8 11 db fe ff       	call   f01004d6 <_warn>
f01129c5:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01129c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01129cf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01129d3:	74 04                	je     f01129d9 <test_cut_paste_pages+0x3be>
f01129d5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01129d9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01129e0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01129e3:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01129e6:	6a 02                	push   $0x2
f01129e8:	68 00 f0 bf 02       	push   $0x2bff000
f01129ed:	68 00 10 90 02       	push   $0x2901000
f01129f2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129f5:	e8 7b 83 ff ff       	call   f010ad75 <cut_paste_pages>
f01129fa:	83 c4 10             	add    $0x10,%esp
f01129fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112a00:	e8 8d c1 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112a05:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112a08:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112a0c:	75 0b                	jne    f0112a19 <test_cut_paste_pages+0x3fe>
f0112a0e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112a11:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112a14:	83 f8 01             	cmp    $0x1,%eax
f0112a17:	74 2b                	je     f0112a44 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112a19:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112a1c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112a1f:	83 ec 0c             	sub    $0xc,%esp
f0112a22:	50                   	push   %eax
f0112a23:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112a26:	68 e8 9b 12 f0       	push   $0xf0129be8
f0112a2b:	68 35 02 00 00       	push   $0x235
f0112a30:	68 42 97 12 f0       	push   $0xf0129742
f0112a35:	e8 9c da fe ff       	call   f01004d6 <_warn>
f0112a3a:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112a3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112a44:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a48:	74 04                	je     f0112a4e <test_cut_paste_pages+0x433>
f0112a4a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112a4e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112a55:	83 ec 08             	sub    $0x8,%esp
f0112a58:	6a 00                	push   $0x0
f0112a5a:	6a 01                	push   $0x1
f0112a5c:	6a 00                	push   $0x0
f0112a5e:	68 ff 0f 00 00       	push   $0xfff
f0112a63:	ff 75 bc             	pushl  -0x44(%ebp)
f0112a66:	6a 01                	push   $0x1
f0112a68:	68 00 20 00 00       	push   $0x2000
f0112a6d:	68 00 f0 bf 02       	push   $0x2bff000
f0112a72:	68 00 10 90 02       	push   $0x2901000
f0112a77:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a7a:	e8 3b 42 00 00       	call   f0116cba <CCP>
f0112a7f:	83 c4 30             	add    $0x30,%esp
f0112a82:	83 f8 01             	cmp    $0x1,%eax
f0112a85:	74 21                	je     f0112aa8 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112a87:	83 ec 04             	sub    $0x4,%esp
f0112a8a:	68 3c 9c 12 f0       	push   $0xf0129c3c
f0112a8f:	68 3d 02 00 00       	push   $0x23d
f0112a94:	68 42 97 12 f0       	push   $0xf0129742
f0112a99:	e8 38 da fe ff       	call   f01004d6 <_warn>
f0112a9e:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112aa1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112aa8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112aac:	74 04                	je     f0112ab2 <test_cut_paste_pages+0x497>
f0112aae:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112ab2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112ab9:	83 ec 04             	sub    $0x4,%esp
f0112abc:	6a 00                	push   $0x0
f0112abe:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112ac3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ac6:	e8 cb 3f 00 00       	call   f0116a96 <CB>
f0112acb:	83 c4 10             	add    $0x10,%esp
f0112ace:	85 c0                	test   %eax,%eax
f0112ad0:	74 6b                	je     f0112b3d <test_cut_paste_pages+0x522>
f0112ad2:	83 ec 04             	sub    $0x4,%esp
f0112ad5:	6a 00                	push   $0x0
f0112ad7:	68 ff 0f c0 02       	push   $0x2c00fff
f0112adc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112adf:	e8 b2 3f 00 00       	call   f0116a96 <CB>
f0112ae4:	83 c4 10             	add    $0x10,%esp
f0112ae7:	85 c0                	test   %eax,%eax
f0112ae9:	74 52                	je     f0112b3d <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112aeb:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112af2:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112af9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112afc:	8a 00                	mov    (%eax),%al
f0112afe:	3c 79                	cmp    $0x79,%al
f0112b00:	75 09                	jne    f0112b0b <test_cut_paste_pages+0x4f0>
f0112b02:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b05:	8a 00                	mov    (%eax),%al
f0112b07:	3c 63                	cmp    $0x63,%al
f0112b09:	74 21                	je     f0112b2c <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b0b:	83 ec 04             	sub    $0x4,%esp
f0112b0e:	68 88 9c 12 f0       	push   $0xf0129c88
f0112b13:	68 49 02 00 00       	push   $0x249
f0112b18:	68 42 97 12 f0       	push   $0xf0129742
f0112b1d:	e8 b4 d9 fe ff       	call   f01004d6 <_warn>
f0112b22:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112b25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112b2c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b30:	74 04                	je     f0112b36 <test_cut_paste_pages+0x51b>
f0112b32:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112b36:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112b3d:	83 ec 0c             	sub    $0xc,%esp
f0112b40:	68 c1 9c 12 f0       	push   $0xf0129cc1
f0112b45:	e8 41 e4 fe ff       	call   f0100f8b <cprintf>
f0112b4a:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112b4d:	83 ec 0c             	sub    $0xc,%esp
f0112b50:	68 d0 9c 12 f0       	push   $0xf0129cd0
f0112b55:	e8 31 e4 fe ff       	call   f0100f8b <cprintf>
f0112b5a:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112b5d:	83 ec 04             	sub    $0x4,%esp
f0112b60:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112b66:	50                   	push   %eax
f0112b67:	68 f9 9c 12 f0       	push   $0xf0129cf9
f0112b6c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112b72:	50                   	push   %eax
f0112b73:	e8 b3 d8 00 00       	call   f012042b <strcconcat>
f0112b78:	83 c4 10             	add    $0x10,%esp
f0112b7b:	83 ec 0c             	sub    $0xc,%esp
f0112b7e:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112b84:	50                   	push   %eax
f0112b85:	e8 71 f3 fe ff       	call   f0101efb <execute_command>
f0112b8a:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112b8d:	83 ec 04             	sub    $0x4,%esp
f0112b90:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112b96:	50                   	push   %eax
f0112b97:	68 04 9d 12 f0       	push   $0xf0129d04
f0112b9c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112ba2:	50                   	push   %eax
f0112ba3:	e8 83 d8 00 00       	call   f012042b <strcconcat>
f0112ba8:	83 c4 10             	add    $0x10,%esp
f0112bab:	83 ec 0c             	sub    $0xc,%esp
f0112bae:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112bb4:	50                   	push   %eax
f0112bb5:	e8 41 f3 fe ff       	call   f0101efb <execute_command>
f0112bba:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112bbd:	83 ec 04             	sub    $0x4,%esp
f0112bc0:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112bc6:	50                   	push   %eax
f0112bc7:	68 0f 9d 12 f0       	push   $0xf0129d0f
f0112bcc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112bd2:	50                   	push   %eax
f0112bd3:	e8 53 d8 00 00       	call   f012042b <strcconcat>
f0112bd8:	83 c4 10             	add    $0x10,%esp
f0112bdb:	83 ec 0c             	sub    $0xc,%esp
f0112bde:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112be4:	50                   	push   %eax
f0112be5:	e8 11 f3 fe ff       	call   f0101efb <execute_command>
f0112bea:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112bed:	83 ec 04             	sub    $0x4,%esp
f0112bf0:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112bf6:	50                   	push   %eax
f0112bf7:	68 1a 9d 12 f0       	push   $0xf0129d1a
f0112bfc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112c02:	50                   	push   %eax
f0112c03:	e8 23 d8 00 00       	call   f012042b <strcconcat>
f0112c08:	83 c4 10             	add    $0x10,%esp
f0112c0b:	83 ec 0c             	sub    $0xc,%esp
f0112c0e:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112c14:	50                   	push   %eax
f0112c15:	e8 e1 f2 fe ff       	call   f0101efb <execute_command>
f0112c1a:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112c1d:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112c24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c27:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112c2a:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112c31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c34:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112c37:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112c3e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c41:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112c44:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112c4b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c4e:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112c51:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112c58:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c5b:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112c5e:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112c65:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c68:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112c6b:	83 ec 08             	sub    $0x8,%esp
f0112c6e:	68 00 00 c0 01       	push   $0x1c00000
f0112c73:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c76:	e8 ec 3f 00 00       	call   f0116c67 <GP>
f0112c7b:	83 c4 10             	add    $0x10,%esp
f0112c7e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112c81:	83 ec 08             	sub    $0x8,%esp
f0112c84:	68 00 00 40 01       	push   $0x1400000
f0112c89:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c8c:	e8 d6 3f 00 00       	call   f0116c67 <GP>
f0112c91:	83 c4 10             	add    $0x10,%esp
f0112c94:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112c97:	e8 f6 be ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112c9c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112c9f:	6a 01                	push   $0x1
f0112ca1:	68 00 00 40 01       	push   $0x1400000
f0112ca6:	68 00 00 c0 01       	push   $0x1c00000
f0112cab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112cae:	e8 c2 80 ff ff       	call   f010ad75 <cut_paste_pages>
f0112cb3:	83 c4 10             	add    $0x10,%esp
f0112cb6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112cb9:	e8 d4 be ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112cbe:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112cc1:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112cc5:	75 08                	jne    f0112ccf <test_cut_paste_pages+0x6b4>
f0112cc7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cca:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112ccd:	74 2b                	je     f0112cfa <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112ccf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cd2:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112cd5:	83 ec 0c             	sub    $0xc,%esp
f0112cd8:	50                   	push   %eax
f0112cd9:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112cdc:	68 28 9d 12 f0       	push   $0xf0129d28
f0112ce1:	68 6c 02 00 00       	push   $0x26c
f0112ce6:	68 42 97 12 f0       	push   $0xf0129742
f0112ceb:	e8 e6 d7 fe ff       	call   f01004d6 <_warn>
f0112cf0:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112cf3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112cfa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cfe:	74 04                	je     f0112d04 <test_cut_paste_pages+0x6e9>
f0112d00:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112d04:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112d0b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112d12:	83 ec 08             	sub    $0x8,%esp
f0112d15:	6a 00                	push   $0x0
f0112d17:	68 ff 0f 00 00       	push   $0xfff
f0112d1c:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112d1f:	68 ff 0f 00 00       	push   $0xfff
f0112d24:	ff 75 a0             	pushl  -0x60(%ebp)
f0112d27:	6a 01                	push   $0x1
f0112d29:	68 00 10 00 00       	push   $0x1000
f0112d2e:	68 00 00 40 01       	push   $0x1400000
f0112d33:	68 00 00 c0 01       	push   $0x1c00000
f0112d38:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d3b:	e8 7a 3f 00 00       	call   f0116cba <CCP>
f0112d40:	83 c4 30             	add    $0x30,%esp
f0112d43:	83 f8 01             	cmp    $0x1,%eax
f0112d46:	74 28                	je     f0112d70 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112d48:	83 ec 04             	sub    $0x4,%esp
f0112d4b:	68 3c 9c 12 f0       	push   $0xf0129c3c
f0112d50:	68 75 02 00 00       	push   $0x275
f0112d55:	68 42 97 12 f0       	push   $0xf0129742
f0112d5a:	e8 77 d7 fe ff       	call   f01004d6 <_warn>
f0112d5f:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112d62:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112d69:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112d70:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d74:	74 04                	je     f0112d7a <test_cut_paste_pages+0x75f>
f0112d76:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112d7a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112d81:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112d85:	0f 84 92 00 00 00    	je     f0112e1d <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112d8b:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112d92:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112d99:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112da0:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112da7:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112dae:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112db5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112db8:	8a 00                	mov    (%eax),%al
f0112dba:	3c 61                	cmp    $0x61,%al
f0112dbc:	75 2d                	jne    f0112deb <test_cut_paste_pages+0x7d0>
f0112dbe:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112dc1:	8a 00                	mov    (%eax),%al
f0112dc3:	3c 78                	cmp    $0x78,%al
f0112dc5:	75 24                	jne    f0112deb <test_cut_paste_pages+0x7d0>
f0112dc7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112dca:	8a 00                	mov    (%eax),%al
f0112dcc:	3c 62                	cmp    $0x62,%al
f0112dce:	75 1b                	jne    f0112deb <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112dd0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112dd3:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112dd5:	3c 79                	cmp    $0x79,%al
f0112dd7:	75 12                	jne    f0112deb <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112dd9:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ddc:	8a 00                	mov    (%eax),%al
f0112dde:	3c 63                	cmp    $0x63,%al
f0112de0:	75 09                	jne    f0112deb <test_cut_paste_pages+0x7d0>
f0112de2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112de5:	8a 00                	mov    (%eax),%al
f0112de7:	3c 7a                	cmp    $0x7a,%al
f0112de9:	74 21                	je     f0112e0c <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112deb:	83 ec 04             	sub    $0x4,%esp
f0112dee:	68 88 9c 12 f0       	push   $0xf0129c88
f0112df3:	68 87 02 00 00       	push   $0x287
f0112df8:	68 42 97 12 f0       	push   $0xf0129742
f0112dfd:	e8 d4 d6 fe ff       	call   f01004d6 <_warn>
f0112e02:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112e05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112e0c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e10:	74 04                	je     f0112e16 <test_cut_paste_pages+0x7fb>
f0112e12:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112e16:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112e1d:	e8 70 bd ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112e22:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112e25:	6a 03                	push   $0x3
f0112e27:	68 00 f0 bf 01       	push   $0x1bff000
f0112e2c:	68 00 00 40 01       	push   $0x1400000
f0112e31:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e34:	e8 3c 7f ff ff       	call   f010ad75 <cut_paste_pages>
f0112e39:	83 c4 10             	add    $0x10,%esp
f0112e3c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112e3f:	e8 4e bd ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0112e44:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112e47:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112e4b:	75 08                	jne    f0112e55 <test_cut_paste_pages+0x83a>
f0112e4d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112e50:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112e53:	74 2b                	je     f0112e80 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112e55:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112e58:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112e5b:	83 ec 0c             	sub    $0xc,%esp
f0112e5e:	50                   	push   %eax
f0112e5f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112e62:	68 28 9d 12 f0       	push   $0xf0129d28
f0112e67:	68 96 02 00 00       	push   $0x296
f0112e6c:	68 42 97 12 f0       	push   $0xf0129742
f0112e71:	e8 60 d6 fe ff       	call   f01004d6 <_warn>
f0112e76:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112e79:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112e80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e84:	74 04                	je     f0112e8a <test_cut_paste_pages+0x86f>
f0112e86:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112e8a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112e91:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112e98:	83 ec 04             	sub    $0x4,%esp
f0112e9b:	6a 00                	push   $0x0
f0112e9d:	68 00 00 40 01       	push   $0x1400000
f0112ea2:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ea5:	e8 ec 3b 00 00       	call   f0116a96 <CB>
f0112eaa:	83 c4 10             	add    $0x10,%esp
f0112ead:	83 f8 01             	cmp    $0x1,%eax
f0112eb0:	0f 85 80 00 00 00    	jne    f0112f36 <test_cut_paste_pages+0x91b>
f0112eb6:	83 ec 04             	sub    $0x4,%esp
f0112eb9:	6a 00                	push   $0x0
f0112ebb:	68 00 10 40 01       	push   $0x1401000
f0112ec0:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ec3:	e8 ce 3b 00 00       	call   f0116a96 <CB>
f0112ec8:	83 c4 10             	add    $0x10,%esp
f0112ecb:	83 f8 01             	cmp    $0x1,%eax
f0112ece:	75 66                	jne    f0112f36 <test_cut_paste_pages+0x91b>
f0112ed0:	83 ec 04             	sub    $0x4,%esp
f0112ed3:	6a 00                	push   $0x0
f0112ed5:	68 00 20 40 01       	push   $0x1402000
f0112eda:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112edd:	e8 b4 3b 00 00       	call   f0116a96 <CB>
f0112ee2:	83 c4 10             	add    $0x10,%esp
f0112ee5:	83 f8 01             	cmp    $0x1,%eax
f0112ee8:	75 4c                	jne    f0112f36 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112eea:	83 ec 04             	sub    $0x4,%esp
f0112eed:	6a 00                	push   $0x0
f0112eef:	68 00 f0 bf 01       	push   $0x1bff000
f0112ef4:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ef7:	e8 9a 3b 00 00       	call   f0116a96 <CB>
f0112efc:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112eff:	85 c0                	test   %eax,%eax
f0112f01:	75 33                	jne    f0112f36 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112f03:	83 ec 04             	sub    $0x4,%esp
f0112f06:	6a 00                	push   $0x0
f0112f08:	68 00 00 c0 01       	push   $0x1c00000
f0112f0d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f10:	e8 81 3b 00 00       	call   f0116a96 <CB>
f0112f15:	83 c4 10             	add    $0x10,%esp
f0112f18:	83 f8 01             	cmp    $0x1,%eax
f0112f1b:	75 19                	jne    f0112f36 <test_cut_paste_pages+0x91b>
f0112f1d:	83 ec 04             	sub    $0x4,%esp
f0112f20:	6a 00                	push   $0x0
f0112f22:	68 00 10 c0 01       	push   $0x1c01000
f0112f27:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f2a:	e8 67 3b 00 00       	call   f0116a96 <CB>
f0112f2f:	83 c4 10             	add    $0x10,%esp
f0112f32:	85 c0                	test   %eax,%eax
f0112f34:	74 28                	je     f0112f5e <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112f36:	83 ec 04             	sub    $0x4,%esp
f0112f39:	68 88 9d 12 f0       	push   $0xf0129d88
f0112f3e:	68 9f 02 00 00       	push   $0x29f
f0112f43:	68 42 97 12 f0       	push   $0xf0129742
f0112f48:	e8 89 d5 fe ff       	call   f01004d6 <_warn>
f0112f4d:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112f50:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112f57:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112f5e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112f62:	74 04                	je     f0112f68 <test_cut_paste_pages+0x94d>
f0112f64:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112f68:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112f6f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112f73:	0f 84 99 00 00 00    	je     f0113012 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112f79:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112f80:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112f87:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112f8e:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112f95:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112f9c:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112fa3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112fa6:	8a 00                	mov    (%eax),%al
f0112fa8:	3c 61                	cmp    $0x61,%al
f0112faa:	75 2d                	jne    f0112fd9 <test_cut_paste_pages+0x9be>
f0112fac:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112faf:	8a 00                	mov    (%eax),%al
f0112fb1:	3c 78                	cmp    $0x78,%al
f0112fb3:	75 24                	jne    f0112fd9 <test_cut_paste_pages+0x9be>
f0112fb5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112fb8:	8a 00                	mov    (%eax),%al
f0112fba:	3c 62                	cmp    $0x62,%al
f0112fbc:	75 1b                	jne    f0112fd9 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112fbe:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112fc1:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112fc3:	3c 79                	cmp    $0x79,%al
f0112fc5:	75 12                	jne    f0112fd9 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112fc7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112fca:	8a 00                	mov    (%eax),%al
f0112fcc:	3c 63                	cmp    $0x63,%al
f0112fce:	75 09                	jne    f0112fd9 <test_cut_paste_pages+0x9be>
f0112fd0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112fd3:	8a 00                	mov    (%eax),%al
f0112fd5:	3c 7a                	cmp    $0x7a,%al
f0112fd7:	74 28                	je     f0113001 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112fd9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112fe0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112fe7:	83 ec 04             	sub    $0x4,%esp
f0112fea:	68 88 9c 12 f0       	push   $0xf0129c88
f0112fef:	68 b3 02 00 00       	push   $0x2b3
f0112ff4:	68 42 97 12 f0       	push   $0xf0129742
f0112ff9:	e8 d8 d4 fe ff       	call   f01004d6 <_warn>
f0112ffe:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0113001:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113005:	74 04                	je     f011300b <test_cut_paste_pages+0x9f0>
f0113007:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011300b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0113012:	83 ec 0c             	sub    $0xc,%esp
f0113015:	68 c1 9d 12 f0       	push   $0xf0129dc1
f011301a:	e8 6c df fe ff       	call   f0100f8b <cprintf>
f011301f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0113022:	83 ec 08             	sub    $0x8,%esp
f0113025:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113028:	68 d0 9d 12 f0       	push   $0xf0129dd0
f011302d:	e8 59 df fe ff       	call   f0100f8b <cprintf>
f0113032:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113035:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113039:	75 10                	jne    f011304b <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f011303b:	83 ec 0c             	sub    $0xc,%esp
f011303e:	68 04 9e 12 f0       	push   $0xf0129e04
f0113043:	e8 43 df fe ff       	call   f0100f8b <cprintf>
f0113048:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011304b:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0113050:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113053:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113056:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113059:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011305e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113061:	5b                   	pop    %ebx
f0113062:	5e                   	pop    %esi
f0113063:	5f                   	pop    %edi
f0113064:	5d                   	pop    %ebp
f0113065:	c3                   	ret    

f0113066 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0113066:	55                   	push   %ebp
f0113067:	89 e5                	mov    %esp,%ebp
f0113069:	57                   	push   %edi
f011306a:	56                   	push   %esi
f011306b:	53                   	push   %ebx
f011306c:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113072:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113078:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f011307d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113082:	89 c7                	mov    %eax,%edi
f0113084:	89 de                	mov    %ebx,%esi
f0113086:	89 d1                	mov    %edx,%ecx
f0113088:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011308a:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113090:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113095:	b0 00                	mov    $0x0,%al
f0113097:	89 d7                	mov    %edx,%edi
f0113099:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011309b:	6a 00                	push   $0x0
f011309d:	6a 0a                	push   $0xa
f011309f:	6a 14                	push   $0x14
f01130a1:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01130a7:	50                   	push   %eax
f01130a8:	e8 45 81 ff ff       	call   f010b1f2 <env_create>
f01130ad:	83 c4 10             	add    $0x10,%esp
f01130b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01130b3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01130b6:	8b 40 64             	mov    0x64(%eax),%eax
f01130b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01130bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01130bf:	8b 40 68             	mov    0x68(%eax),%eax
f01130c2:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01130c8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01130ce:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01130d1:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f01130d8:	75 70 20 
f01130db:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f01130e2:	00 00 00 
f01130e5:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01130eb:	b9 03 00 00 00       	mov    $0x3,%ecx
f01130f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01130f5:	89 d7                	mov    %edx,%edi
f01130f7:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01130f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01130fc:	8b 40 10             	mov    0x10(%eax),%eax
f01130ff:	83 ec 08             	sub    $0x8,%esp
f0113102:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0113108:	52                   	push   %edx
f0113109:	50                   	push   %eax
f011310a:	e8 43 d2 00 00       	call   f0120352 <ltostr>
f011310f:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0113112:	83 ec 04             	sub    $0x4,%esp
f0113115:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011311b:	50                   	push   %eax
f011311c:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0113122:	50                   	push   %eax
f0113123:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0113129:	50                   	push   %eax
f011312a:	e8 fc d2 00 00       	call   f012042b <strcconcat>
f011312f:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0113132:	83 ec 0c             	sub    $0xc,%esp
f0113135:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113138:	e8 49 3b 00 00       	call   f0116c86 <ClearUserSpace>
f011313d:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0113140:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0113147:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f011314e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0113155:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f011315c:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113163:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f011316a:	83 ec 0c             	sub    $0xc,%esp
f011316d:	68 78 9e 12 f0       	push   $0xf0129e78
f0113172:	e8 14 de fe ff       	call   f0100f8b <cprintf>
f0113177:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011317a:	83 ec 04             	sub    $0x4,%esp
f011317d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113183:	50                   	push   %eax
f0113184:	68 ae 9e 12 f0       	push   $0xf0129eae
f0113189:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011318f:	50                   	push   %eax
f0113190:	e8 96 d2 00 00       	call   f012042b <strcconcat>
f0113195:	83 c4 10             	add    $0x10,%esp
f0113198:	83 ec 0c             	sub    $0xc,%esp
f011319b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01131a1:	50                   	push   %eax
f01131a2:	e8 54 ed fe ff       	call   f0101efb <execute_command>
f01131a7:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f01131aa:	83 ec 04             	sub    $0x4,%esp
f01131ad:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01131b3:	50                   	push   %eax
f01131b4:	68 b3 9e 12 f0       	push   $0xf0129eb3
f01131b9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01131bf:	50                   	push   %eax
f01131c0:	e8 66 d2 00 00       	call   f012042b <strcconcat>
f01131c5:	83 c4 10             	add    $0x10,%esp
f01131c8:	83 ec 0c             	sub    $0xc,%esp
f01131cb:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01131d1:	50                   	push   %eax
f01131d2:	e8 24 ed fe ff       	call   f0101efb <execute_command>
f01131d7:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f01131da:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01131e0:	bb b9 a1 12 f0       	mov    $0xf012a1b9,%ebx
f01131e5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131ea:	89 c7                	mov    %eax,%edi
f01131ec:	89 de                	mov    %ebx,%esi
f01131ee:	89 d1                	mov    %edx,%ecx
f01131f0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131f2:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01131f8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131fd:	b0 00                	mov    $0x0,%al
f01131ff:	89 d7                	mov    %edx,%edi
f0113201:	f3 aa                	rep stos %al,%es:(%edi)
f0113203:	83 ec 0c             	sub    $0xc,%esp
f0113206:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011320c:	50                   	push   %eax
f011320d:	e8 e9 ec fe ff       	call   f0101efb <execute_command>
f0113212:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0113215:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011321b:	bb 1d a2 12 f0       	mov    $0xf012a21d,%ebx
f0113220:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113225:	89 c7                	mov    %eax,%edi
f0113227:	89 de                	mov    %ebx,%esi
f0113229:	89 d1                	mov    %edx,%ecx
f011322b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011322d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113233:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113238:	b0 00                	mov    $0x0,%al
f011323a:	89 d7                	mov    %edx,%edi
f011323c:	f3 aa                	rep stos %al,%es:(%edi)
f011323e:	83 ec 0c             	sub    $0xc,%esp
f0113241:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113247:	50                   	push   %eax
f0113248:	e8 ae ec fe ff       	call   f0101efb <execute_command>
f011324d:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113250:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113256:	bb 81 a2 12 f0       	mov    $0xf012a281,%ebx
f011325b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113260:	89 c7                	mov    %eax,%edi
f0113262:	89 de                	mov    %ebx,%esi
f0113264:	89 d1                	mov    %edx,%ecx
f0113266:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113268:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f011326e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113273:	b0 00                	mov    $0x0,%al
f0113275:	89 d7                	mov    %edx,%edi
f0113277:	f3 aa                	rep stos %al,%es:(%edi)
f0113279:	83 ec 0c             	sub    $0xc,%esp
f011327c:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113282:	50                   	push   %eax
f0113283:	e8 73 ec fe ff       	call   f0101efb <execute_command>
f0113288:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f011328b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113291:	bb e5 a2 12 f0       	mov    $0xf012a2e5,%ebx
f0113296:	ba 0f 00 00 00       	mov    $0xf,%edx
f011329b:	89 c7                	mov    %eax,%edi
f011329d:	89 de                	mov    %ebx,%esi
f011329f:	89 d1                	mov    %edx,%ecx
f01132a1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132a3:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01132a9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132ae:	b0 00                	mov    $0x0,%al
f01132b0:	89 d7                	mov    %edx,%edi
f01132b2:	f3 aa                	rep stos %al,%es:(%edi)
f01132b4:	83 ec 0c             	sub    $0xc,%esp
f01132b7:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01132bd:	50                   	push   %eax
f01132be:	e8 38 ec fe ff       	call   f0101efb <execute_command>
f01132c3:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f01132c6:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01132cc:	bb 49 a3 12 f0       	mov    $0xf012a349,%ebx
f01132d1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132d6:	89 c7                	mov    %eax,%edi
f01132d8:	89 de                	mov    %ebx,%esi
f01132da:	89 d1                	mov    %edx,%ecx
f01132dc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132de:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01132e4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132e9:	b0 00                	mov    $0x0,%al
f01132eb:	89 d7                	mov    %edx,%edi
f01132ed:	f3 aa                	rep stos %al,%es:(%edi)
f01132ef:	83 ec 0c             	sub    $0xc,%esp
f01132f2:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01132f8:	50                   	push   %eax
f01132f9:	e8 fd eb fe ff       	call   f0101efb <execute_command>
f01132fe:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0113301:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113307:	bb ad a3 12 f0       	mov    $0xf012a3ad,%ebx
f011330c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113311:	89 c7                	mov    %eax,%edi
f0113313:	89 de                	mov    %ebx,%esi
f0113315:	89 d1                	mov    %edx,%ecx
f0113317:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113319:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011331f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113324:	b0 00                	mov    $0x0,%al
f0113326:	89 d7                	mov    %edx,%edi
f0113328:	f3 aa                	rep stos %al,%es:(%edi)
f011332a:	83 ec 0c             	sub    $0xc,%esp
f011332d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113333:	50                   	push   %eax
f0113334:	e8 c2 eb fe ff       	call   f0101efb <execute_command>
f0113339:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f011333c:	83 ec 04             	sub    $0x4,%esp
f011333f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113345:	50                   	push   %eax
f0113346:	68 bb 9e 12 f0       	push   $0xf0129ebb
f011334b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113351:	50                   	push   %eax
f0113352:	e8 d4 d0 00 00       	call   f012042b <strcconcat>
f0113357:	83 c4 10             	add    $0x10,%esp
f011335a:	83 ec 0c             	sub    $0xc,%esp
f011335d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113363:	50                   	push   %eax
f0113364:	e8 92 eb fe ff       	call   f0101efb <execute_command>
f0113369:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f011336c:	83 ec 04             	sub    $0x4,%esp
f011336f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113375:	50                   	push   %eax
f0113376:	68 c5 9e 12 f0       	push   $0xf0129ec5
f011337b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113381:	50                   	push   %eax
f0113382:	e8 a4 d0 00 00       	call   f012042b <strcconcat>
f0113387:	83 c4 10             	add    $0x10,%esp
f011338a:	83 ec 0c             	sub    $0xc,%esp
f011338d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113393:	50                   	push   %eax
f0113394:	e8 62 eb fe ff       	call   f0101efb <execute_command>
f0113399:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f011339c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01133a2:	bb 11 a4 12 f0       	mov    $0xf012a411,%ebx
f01133a7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133ac:	89 c7                	mov    %eax,%edi
f01133ae:	89 de                	mov    %ebx,%esi
f01133b0:	89 d1                	mov    %edx,%ecx
f01133b2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133b4:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01133ba:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133bf:	b0 00                	mov    $0x0,%al
f01133c1:	89 d7                	mov    %edx,%edi
f01133c3:	f3 aa                	rep stos %al,%es:(%edi)
f01133c5:	83 ec 0c             	sub    $0xc,%esp
f01133c8:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01133ce:	50                   	push   %eax
f01133cf:	e8 27 eb fe ff       	call   f0101efb <execute_command>
f01133d4:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f01133d7:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01133dd:	bb 75 a4 12 f0       	mov    $0xf012a475,%ebx
f01133e2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133e7:	89 c7                	mov    %eax,%edi
f01133e9:	89 de                	mov    %ebx,%esi
f01133eb:	89 d1                	mov    %edx,%ecx
f01133ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133ef:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01133f5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133fa:	b0 00                	mov    $0x0,%al
f01133fc:	89 d7                	mov    %edx,%edi
f01133fe:	f3 aa                	rep stos %al,%es:(%edi)
f0113400:	83 ec 0c             	sub    $0xc,%esp
f0113403:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113409:	50                   	push   %eax
f011340a:	e8 ec ea fe ff       	call   f0101efb <execute_command>
f011340f:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0113412:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113418:	bb d9 a4 12 f0       	mov    $0xf012a4d9,%ebx
f011341d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113422:	89 c7                	mov    %eax,%edi
f0113424:	89 de                	mov    %ebx,%esi
f0113426:	89 d1                	mov    %edx,%ecx
f0113428:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011342a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113430:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113435:	b0 00                	mov    $0x0,%al
f0113437:	89 d7                	mov    %edx,%edi
f0113439:	f3 aa                	rep stos %al,%es:(%edi)
f011343b:	83 ec 0c             	sub    $0xc,%esp
f011343e:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113444:	50                   	push   %eax
f0113445:	e8 b1 ea fe ff       	call   f0101efb <execute_command>
f011344a:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f011344d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0113454:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f011345b:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0113462:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113469:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113470:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0113477:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f011347e:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0113485:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f011348c:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113493:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f011349a:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f01134a1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01134a4:	8a 00                	mov    (%eax),%al
f01134a6:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f01134ac:	8b 45 98             	mov    -0x68(%ebp),%eax
f01134af:	8a 00                	mov    (%eax),%al
f01134b1:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f01134b7:	8b 45 90             	mov    -0x70(%ebp),%eax
f01134ba:	8a 00                	mov    (%eax),%al
f01134bc:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01134c2:	e8 cb b6 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01134c7:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f01134ca:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01134cd:	89 d0                	mov    %edx,%eax
f01134cf:	01 c0                	add    %eax,%eax
f01134d1:	01 d0                	add    %edx,%eax
f01134d3:	01 c0                	add    %eax,%eax
f01134d5:	50                   	push   %eax
f01134d6:	68 00 00 10 00       	push   $0x100000
f01134db:	6a 00                	push   $0x0
f01134dd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01134e0:	e8 aa 78 ff ff       	call   f010ad8f <copy_paste_chunk>
f01134e5:	83 c4 10             	add    $0x10,%esp
f01134e8:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01134eb:	e8 a2 b6 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01134f0:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01134f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01134fa:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01134fe:	75 08                	jne    f0113508 <test_copy_paste_chunk+0x4a2>
f0113500:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113503:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113506:	74 2b                	je     f0113533 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113508:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011350b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011350e:	83 ec 0c             	sub    $0xc,%esp
f0113511:	50                   	push   %eax
f0113512:	ff 75 88             	pushl  -0x78(%ebp)
f0113515:	68 d4 9e 12 f0       	push   $0xf0129ed4
f011351a:	68 06 03 00 00       	push   $0x306
f011351f:	68 42 97 12 f0       	push   $0xf0129742
f0113524:	e8 ad cf fe ff       	call   f01004d6 <_warn>
f0113529:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011352c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113533:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113537:	74 04                	je     f011353d <test_copy_paste_chunk+0x4d7>
f0113539:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011353d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0113544:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113547:	8a 00                	mov    (%eax),%al
f0113549:	3c 61                	cmp    $0x61,%al
f011354b:	75 75                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f011354d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113550:	8a 00                	mov    (%eax),%al
f0113552:	3c 78                	cmp    $0x78,%al
f0113554:	75 6c                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f0113556:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113559:	8a 00                	mov    (%eax),%al
f011355b:	3c 62                	cmp    $0x62,%al
f011355d:	75 63                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f011355f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113562:	8a 00                	mov    (%eax),%al
f0113564:	3c 79                	cmp    $0x79,%al
f0113566:	75 5a                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f0113568:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011356b:	8a 00                	mov    (%eax),%al
f011356d:	3c 63                	cmp    $0x63,%al
f011356f:	75 51                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f0113571:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113574:	8a 00                	mov    (%eax),%al
f0113576:	3c 7a                	cmp    $0x7a,%al
f0113578:	75 48                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f011357a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011357d:	8a 00                	mov    (%eax),%al
f011357f:	3c 64                	cmp    $0x64,%al
f0113581:	75 3f                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f0113583:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113586:	8a 10                	mov    (%eax),%dl
f0113588:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f011358e:	38 c2                	cmp    %al,%dl
f0113590:	75 30                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f0113592:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113595:	8a 00                	mov    (%eax),%al
f0113597:	3c 65                	cmp    $0x65,%al
f0113599:	75 27                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f011359b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011359e:	8a 10                	mov    (%eax),%dl
f01135a0:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f01135a6:	38 c2                	cmp    %al,%dl
f01135a8:	75 18                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f01135aa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01135ad:	8a 00                	mov    (%eax),%al
f01135af:	3c 66                	cmp    $0x66,%al
f01135b1:	75 0f                	jne    f01135c2 <test_copy_paste_chunk+0x55c>
f01135b3:	8b 45 90             	mov    -0x70(%ebp),%eax
f01135b6:	8a 10                	mov    (%eax),%dl
f01135b8:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01135be:	38 c2                	cmp    %al,%dl
f01135c0:	74 21                	je     f01135e3 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01135c2:	83 ec 04             	sub    $0x4,%esp
f01135c5:	68 38 9f 12 f0       	push   $0xf0129f38
f01135ca:	68 0f 03 00 00       	push   $0x30f
f01135cf:	68 42 97 12 f0       	push   $0xf0129742
f01135d4:	e8 fd ce fe ff       	call   f01004d6 <_warn>
f01135d9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01135dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01135e3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01135e7:	74 04                	je     f01135ed <test_copy_paste_chunk+0x587>
f01135e9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01135ed:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01135f4:	83 ec 0c             	sub    $0xc,%esp
f01135f7:	68 72 9f 12 f0       	push   $0xf0129f72
f01135fc:	e8 8a d9 fe ff       	call   f0100f8b <cprintf>
f0113601:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0113604:	83 ec 0c             	sub    $0xc,%esp
f0113607:	68 84 9f 12 f0       	push   $0xf0129f84
f011360c:	e8 7a d9 fe ff       	call   f0100f8b <cprintf>
f0113611:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0113614:	83 ec 04             	sub    $0x4,%esp
f0113617:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011361d:	50                   	push   %eax
f011361e:	68 ba 9f 12 f0       	push   $0xf0129fba
f0113623:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113629:	50                   	push   %eax
f011362a:	e8 fc cd 00 00       	call   f012042b <strcconcat>
f011362f:	83 c4 10             	add    $0x10,%esp
f0113632:	83 ec 0c             	sub    $0xc,%esp
f0113635:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011363b:	50                   	push   %eax
f011363c:	e8 ba e8 fe ff       	call   f0101efb <execute_command>
f0113641:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0113644:	83 ec 04             	sub    $0x4,%esp
f0113647:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011364d:	50                   	push   %eax
f011364e:	68 c4 9f 12 f0       	push   $0xf0129fc4
f0113653:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113659:	50                   	push   %eax
f011365a:	e8 cc cd 00 00       	call   f012042b <strcconcat>
f011365f:	83 c4 10             	add    $0x10,%esp
f0113662:	83 ec 0c             	sub    $0xc,%esp
f0113665:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011366b:	50                   	push   %eax
f011366c:	e8 8a e8 fe ff       	call   f0101efb <execute_command>
f0113671:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0113674:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011367a:	bb 3d a5 12 f0       	mov    $0xf012a53d,%ebx
f011367f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113684:	89 c7                	mov    %eax,%edi
f0113686:	89 de                	mov    %ebx,%esi
f0113688:	89 d1                	mov    %edx,%ecx
f011368a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011368c:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113692:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113697:	b0 00                	mov    $0x0,%al
f0113699:	89 d7                	mov    %edx,%edi
f011369b:	f3 aa                	rep stos %al,%es:(%edi)
f011369d:	83 ec 0c             	sub    $0xc,%esp
f01136a0:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01136a6:	50                   	push   %eax
f01136a7:	e8 4f e8 fe ff       	call   f0101efb <execute_command>
f01136ac:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f01136af:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01136b5:	bb a1 a5 12 f0       	mov    $0xf012a5a1,%ebx
f01136ba:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136bf:	89 c7                	mov    %eax,%edi
f01136c1:	89 de                	mov    %ebx,%esi
f01136c3:	89 d1                	mov    %edx,%ecx
f01136c5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136c7:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01136cd:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136d2:	b0 00                	mov    $0x0,%al
f01136d4:	89 d7                	mov    %edx,%edi
f01136d6:	f3 aa                	rep stos %al,%es:(%edi)
f01136d8:	83 ec 0c             	sub    $0xc,%esp
f01136db:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01136e1:	50                   	push   %eax
f01136e2:	e8 14 e8 fe ff       	call   f0101efb <execute_command>
f01136e7:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01136ea:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01136f0:	bb 05 a6 12 f0       	mov    $0xf012a605,%ebx
f01136f5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136fa:	89 c7                	mov    %eax,%edi
f01136fc:	89 de                	mov    %ebx,%esi
f01136fe:	89 d1                	mov    %edx,%ecx
f0113700:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113702:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113708:	b9 55 00 00 00       	mov    $0x55,%ecx
f011370d:	b0 00                	mov    $0x0,%al
f011370f:	89 d7                	mov    %edx,%edi
f0113711:	f3 aa                	rep stos %al,%es:(%edi)
f0113713:	83 ec 0c             	sub    $0xc,%esp
f0113716:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011371c:	50                   	push   %eax
f011371d:	e8 d9 e7 fe ff       	call   f0101efb <execute_command>
f0113722:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0113725:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011372b:	bb 69 a6 12 f0       	mov    $0xf012a669,%ebx
f0113730:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113735:	89 c7                	mov    %eax,%edi
f0113737:	89 de                	mov    %ebx,%esi
f0113739:	89 d1                	mov    %edx,%ecx
f011373b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011373d:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113743:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113748:	b0 00                	mov    $0x0,%al
f011374a:	89 d7                	mov    %edx,%edi
f011374c:	f3 aa                	rep stos %al,%es:(%edi)
f011374e:	83 ec 0c             	sub    $0xc,%esp
f0113751:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113757:	50                   	push   %eax
f0113758:	e8 9e e7 fe ff       	call   f0101efb <execute_command>
f011375d:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113760:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113766:	bb cd a6 12 f0       	mov    $0xf012a6cd,%ebx
f011376b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113770:	89 c7                	mov    %eax,%edi
f0113772:	89 de                	mov    %ebx,%esi
f0113774:	89 d1                	mov    %edx,%ecx
f0113776:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113778:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011377e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113783:	b0 00                	mov    $0x0,%al
f0113785:	89 d7                	mov    %edx,%edi
f0113787:	f3 aa                	rep stos %al,%es:(%edi)
f0113789:	83 ec 0c             	sub    $0xc,%esp
f011378c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113792:	50                   	push   %eax
f0113793:	e8 63 e7 fe ff       	call   f0101efb <execute_command>
f0113798:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f011379b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01137a1:	bb 31 a7 12 f0       	mov    $0xf012a731,%ebx
f01137a6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01137ab:	89 c7                	mov    %eax,%edi
f01137ad:	89 de                	mov    %ebx,%esi
f01137af:	89 d1                	mov    %edx,%ecx
f01137b1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137b3:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01137b9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01137be:	b0 00                	mov    $0x0,%al
f01137c0:	89 d7                	mov    %edx,%edi
f01137c2:	f3 aa                	rep stos %al,%es:(%edi)
f01137c4:	83 ec 0c             	sub    $0xc,%esp
f01137c7:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01137cd:	50                   	push   %eax
f01137ce:	e8 28 e7 fe ff       	call   f0101efb <execute_command>
f01137d3:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f01137d6:	83 ec 04             	sub    $0x4,%esp
f01137d9:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137df:	50                   	push   %eax
f01137e0:	68 ce 9f 12 f0       	push   $0xf0129fce
f01137e5:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01137eb:	50                   	push   %eax
f01137ec:	e8 3a cc 00 00       	call   f012042b <strcconcat>
f01137f1:	83 c4 10             	add    $0x10,%esp
f01137f4:	83 ec 0c             	sub    $0xc,%esp
f01137f7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137fd:	50                   	push   %eax
f01137fe:	e8 f8 e6 fe ff       	call   f0101efb <execute_command>
f0113803:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113806:	83 ec 04             	sub    $0x4,%esp
f0113809:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011380f:	50                   	push   %eax
f0113810:	68 d8 9f 12 f0       	push   $0xf0129fd8
f0113815:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011381b:	50                   	push   %eax
f011381c:	e8 0a cc 00 00       	call   f012042b <strcconcat>
f0113821:	83 c4 10             	add    $0x10,%esp
f0113824:	83 ec 0c             	sub    $0xc,%esp
f0113827:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011382d:	50                   	push   %eax
f011382e:	e8 c8 e6 fe ff       	call   f0101efb <execute_command>
f0113833:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113836:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011383c:	bb 95 a7 12 f0       	mov    $0xf012a795,%ebx
f0113841:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113846:	89 c7                	mov    %eax,%edi
f0113848:	89 de                	mov    %ebx,%esi
f011384a:	89 d1                	mov    %edx,%ecx
f011384c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011384e:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113854:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113859:	b0 00                	mov    $0x0,%al
f011385b:	89 d7                	mov    %edx,%edi
f011385d:	f3 aa                	rep stos %al,%es:(%edi)
f011385f:	83 ec 0c             	sub    $0xc,%esp
f0113862:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113868:	50                   	push   %eax
f0113869:	e8 8d e6 fe ff       	call   f0101efb <execute_command>
f011386e:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113871:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113877:	bb f9 a7 12 f0       	mov    $0xf012a7f9,%ebx
f011387c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113881:	89 c7                	mov    %eax,%edi
f0113883:	89 de                	mov    %ebx,%esi
f0113885:	89 d1                	mov    %edx,%ecx
f0113887:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113889:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011388f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113894:	b0 00                	mov    $0x0,%al
f0113896:	89 d7                	mov    %edx,%edi
f0113898:	f3 aa                	rep stos %al,%es:(%edi)
f011389a:	83 ec 0c             	sub    $0xc,%esp
f011389d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01138a3:	50                   	push   %eax
f01138a4:	e8 52 e6 fe ff       	call   f0101efb <execute_command>
f01138a9:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01138ac:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01138b2:	bb 5d a8 12 f0       	mov    $0xf012a85d,%ebx
f01138b7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138bc:	89 c7                	mov    %eax,%edi
f01138be:	89 de                	mov    %ebx,%esi
f01138c0:	89 d1                	mov    %edx,%ecx
f01138c2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138c4:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01138ca:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138cf:	b0 00                	mov    $0x0,%al
f01138d1:	89 d7                	mov    %edx,%edi
f01138d3:	f3 aa                	rep stos %al,%es:(%edi)
f01138d5:	83 ec 0c             	sub    $0xc,%esp
f01138d8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01138de:	50                   	push   %eax
f01138df:	e8 17 e6 fe ff       	call   f0101efb <execute_command>
f01138e4:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f01138e7:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01138ee:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01138f5:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01138fc:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113903:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f011390a:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113911:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113918:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f011391f:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113926:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f011392d:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113934:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f011393b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011393e:	8a 00                	mov    (%eax),%al
f0113940:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113946:	e8 47 b2 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011394b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f011394e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113951:	89 d0                	mov    %edx,%eax
f0113953:	01 c0                	add    %eax,%eax
f0113955:	01 d0                	add    %edx,%eax
f0113957:	01 c0                	add    %eax,%eax
f0113959:	50                   	push   %eax
f011395a:	68 00 00 40 00       	push   $0x400000
f011395f:	68 00 00 20 00       	push   $0x200000
f0113964:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113967:	e8 23 74 ff ff       	call   f010ad8f <copy_paste_chunk>
f011396c:	83 c4 10             	add    $0x10,%esp
f011396f:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113972:	e8 1b b2 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113977:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f011397a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113981:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113985:	75 08                	jne    f011398f <test_copy_paste_chunk+0x929>
f0113987:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011398a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011398d:	74 2b                	je     f01139ba <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011398f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113992:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113995:	83 ec 0c             	sub    $0xc,%esp
f0113998:	50                   	push   %eax
f0113999:	ff 75 80             	pushl  -0x80(%ebp)
f011399c:	68 e4 9f 12 f0       	push   $0xf0129fe4
f01139a1:	68 3f 03 00 00       	push   $0x33f
f01139a6:	68 42 97 12 f0       	push   $0xf0129742
f01139ab:	e8 26 cb fe ff       	call   f01004d6 <_warn>
f01139b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01139b3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01139ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139be:	74 04                	je     f01139c4 <test_copy_paste_chunk+0x95e>
f01139c0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139c4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01139cb:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01139d2:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01139d5:	83 ec 08             	sub    $0x8,%esp
f01139d8:	6a 01                	push   $0x1
f01139da:	6a 07                	push   $0x7
f01139dc:	6a 07                	push   $0x7
f01139de:	6a 07                	push   $0x7
f01139e0:	6a 07                	push   $0x7
f01139e2:	6a 01                	push   $0x1
f01139e4:	68 00 20 00 00       	push   $0x2000
f01139e9:	68 00 00 40 00       	push   $0x400000
f01139ee:	68 00 00 20 00       	push   $0x200000
f01139f3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139f6:	e8 bf 32 00 00       	call   f0116cba <CCP>
f01139fb:	83 c4 30             	add    $0x30,%esp
f01139fe:	83 f8 01             	cmp    $0x1,%eax
f0113a01:	74 2b                	je     f0113a2e <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113a03:	83 ec 04             	sub    $0x4,%esp
f0113a06:	68 38 a0 12 f0       	push   $0xf012a038
f0113a0b:	68 48 03 00 00       	push   $0x348
f0113a10:	68 42 97 12 f0       	push   $0xf0129742
f0113a15:	e8 bc ca fe ff       	call   f01004d6 <_warn>
f0113a1a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113a24:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113a2b:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113a2e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a32:	74 04                	je     f0113a38 <test_copy_paste_chunk+0x9d2>
f0113a34:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113a38:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113a3f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a42:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113a45:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a48:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113a4b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113a4e:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113a51:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a54:	8a 00                	mov    (%eax),%al
f0113a56:	3c 61                	cmp    $0x61,%al
f0113a58:	75 69                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a5a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a5d:	8a 00                	mov    (%eax),%al
f0113a5f:	3c 61                	cmp    $0x61,%al
f0113a61:	75 60                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a63:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a66:	8a 00                	mov    (%eax),%al
f0113a68:	3c 79                	cmp    $0x79,%al
f0113a6a:	75 57                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a6c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113a6f:	8a 00                	mov    (%eax),%al
f0113a71:	3c 62                	cmp    $0x62,%al
f0113a73:	75 4e                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a75:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113a78:	8a 00                	mov    (%eax),%al
f0113a7a:	3c 63                	cmp    $0x63,%al
f0113a7c:	75 45                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a7e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a81:	8a 00                	mov    (%eax),%al
f0113a83:	3c 7a                	cmp    $0x7a,%al
f0113a85:	75 3c                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113a87:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113a8a:	8a 00                	mov    (%eax),%al
f0113a8c:	3c 77                	cmp    $0x77,%al
f0113a8e:	75 33                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a90:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113a93:	8a 00                	mov    (%eax),%al
f0113a95:	3c 64                	cmp    $0x64,%al
f0113a97:	75 2a                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113a99:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113a9c:	8a 00                	mov    (%eax),%al
f0113a9e:	3c 65                	cmp    $0x65,%al
f0113aa0:	75 21                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113aa2:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113aa5:	8a 00                	mov    (%eax),%al
f0113aa7:	3c 65                	cmp    $0x65,%al
f0113aa9:	75 18                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113aab:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113aae:	8a 00                	mov    (%eax),%al
f0113ab0:	3c 66                	cmp    $0x66,%al
f0113ab2:	75 0f                	jne    f0113ac3 <test_copy_paste_chunk+0xa5d>
f0113ab4:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113ab7:	8a 10                	mov    (%eax),%dl
f0113ab9:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113abf:	38 c2                	cmp    %al,%dl
f0113ac1:	74 21                	je     f0113ae4 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113ac3:	83 ec 04             	sub    $0x4,%esp
f0113ac6:	68 38 9f 12 f0       	push   $0xf0129f38
f0113acb:	68 56 03 00 00       	push   $0x356
f0113ad0:	68 42 97 12 f0       	push   $0xf0129742
f0113ad5:	e8 fc c9 fe ff       	call   f01004d6 <_warn>
f0113ada:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113add:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113ae4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ae8:	74 04                	je     f0113aee <test_copy_paste_chunk+0xa88>
f0113aea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113aee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113af5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113af8:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113afb:	e8 92 b0 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113b00:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113b03:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113b06:	89 c2                	mov    %eax,%edx
f0113b08:	01 d2                	add    %edx,%edx
f0113b0a:	01 d0                	add    %edx,%eax
f0113b0c:	50                   	push   %eax
f0113b0d:	68 00 08 20 00       	push   $0x200800
f0113b12:	68 00 08 40 00       	push   $0x400800
f0113b17:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b1a:	e8 70 72 ff ff       	call   f010ad8f <copy_paste_chunk>
f0113b1f:	83 c4 10             	add    $0x10,%esp
f0113b22:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b25:	e8 68 b0 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113b2a:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113b2d:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113b31:	75 08                	jne    f0113b3b <test_copy_paste_chunk+0xad5>
f0113b33:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b36:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113b39:	74 2b                	je     f0113b66 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b3b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b3e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b41:	83 ec 0c             	sub    $0xc,%esp
f0113b44:	50                   	push   %eax
f0113b45:	ff 75 80             	pushl  -0x80(%ebp)
f0113b48:	68 e4 9f 12 f0       	push   $0xf0129fe4
f0113b4d:	68 66 03 00 00       	push   $0x366
f0113b52:	68 42 97 12 f0       	push   $0xf0129742
f0113b57:	e8 7a c9 fe ff       	call   f01004d6 <_warn>
f0113b5c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b5f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113b66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b6a:	74 04                	je     f0113b70 <test_copy_paste_chunk+0xb0a>
f0113b6c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b70:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113b77:	83 ec 08             	sub    $0x8,%esp
f0113b7a:	6a 01                	push   $0x1
f0113b7c:	6a 07                	push   $0x7
f0113b7e:	6a 07                	push   $0x7
f0113b80:	6a 07                	push   $0x7
f0113b82:	6a 07                	push   $0x7
f0113b84:	6a 01                	push   $0x1
f0113b86:	68 00 20 00 00       	push   $0x2000
f0113b8b:	68 00 00 20 00       	push   $0x200000
f0113b90:	68 00 00 40 00       	push   $0x400000
f0113b95:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b98:	e8 1d 31 00 00       	call   f0116cba <CCP>
f0113b9d:	83 c4 30             	add    $0x30,%esp
f0113ba0:	83 f8 01             	cmp    $0x1,%eax
f0113ba3:	74 21                	je     f0113bc6 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113ba5:	83 ec 04             	sub    $0x4,%esp
f0113ba8:	68 84 a0 12 f0       	push   $0xf012a084
f0113bad:	68 6e 03 00 00       	push   $0x36e
f0113bb2:	68 42 97 12 f0       	push   $0xf0129742
f0113bb7:	e8 1a c9 fe ff       	call   f01004d6 <_warn>
f0113bbc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113bbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113bc6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113bca:	74 04                	je     f0113bd0 <test_copy_paste_chunk+0xb6a>
f0113bcc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113bd0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113bd7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113bda:	8a 00                	mov    (%eax),%al
f0113bdc:	3c 61                	cmp    $0x61,%al
f0113bde:	75 69                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113be0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113be3:	8a 00                	mov    (%eax),%al
f0113be5:	3c 61                	cmp    $0x61,%al
f0113be7:	75 60                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113be9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113bec:	8a 00                	mov    (%eax),%al
f0113bee:	3c 79                	cmp    $0x79,%al
f0113bf0:	75 57                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113bf2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113bf5:	8a 00                	mov    (%eax),%al
f0113bf7:	3c 62                	cmp    $0x62,%al
f0113bf9:	75 4e                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113bfb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113bfe:	8a 00                	mov    (%eax),%al
f0113c00:	3c 7a                	cmp    $0x7a,%al
f0113c02:	75 45                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113c04:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113c07:	8a 00                	mov    (%eax),%al
f0113c09:	3c 7a                	cmp    $0x7a,%al
f0113c0b:	75 3c                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113c0d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113c10:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113c12:	3c 64                	cmp    $0x64,%al
f0113c14:	75 33                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113c16:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113c19:	8a 00                	mov    (%eax),%al
f0113c1b:	3c 64                	cmp    $0x64,%al
f0113c1d:	75 2a                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113c1f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113c22:	8a 00                	mov    (%eax),%al
f0113c24:	3c 65                	cmp    $0x65,%al
f0113c26:	75 21                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113c28:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113c2b:	8a 00                	mov    (%eax),%al
f0113c2d:	3c 78                	cmp    $0x78,%al
f0113c2f:	75 18                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113c31:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113c34:	8a 00                	mov    (%eax),%al
f0113c36:	3c 66                	cmp    $0x66,%al
f0113c38:	75 0f                	jne    f0113c49 <test_copy_paste_chunk+0xbe3>
f0113c3a:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113c3d:	8a 10                	mov    (%eax),%dl
f0113c3f:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113c45:	38 c2                	cmp    %al,%dl
f0113c47:	74 21                	je     f0113c6a <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113c49:	83 ec 04             	sub    $0x4,%esp
f0113c4c:	68 38 9f 12 f0       	push   $0xf0129f38
f0113c51:	68 77 03 00 00       	push   $0x377
f0113c56:	68 42 97 12 f0       	push   $0xf0129742
f0113c5b:	e8 76 c8 fe ff       	call   f01004d6 <_warn>
f0113c60:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113c6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c6e:	74 04                	je     f0113c74 <test_copy_paste_chunk+0xc0e>
f0113c70:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113c74:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113c7b:	83 ec 0c             	sub    $0xc,%esp
f0113c7e:	68 cf a0 12 f0       	push   $0xf012a0cf
f0113c83:	e8 03 d3 fe ff       	call   f0100f8b <cprintf>
f0113c88:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113c8b:	83 ec 0c             	sub    $0xc,%esp
f0113c8e:	68 e0 a0 12 f0       	push   $0xf012a0e0
f0113c93:	e8 f3 d2 fe ff       	call   f0100f8b <cprintf>
f0113c98:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113c9b:	83 ec 04             	sub    $0x4,%esp
f0113c9e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ca4:	50                   	push   %eax
f0113ca5:	68 14 a1 12 f0       	push   $0xf012a114
f0113caa:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113cb0:	50                   	push   %eax
f0113cb1:	e8 75 c7 00 00       	call   f012042b <strcconcat>
f0113cb6:	83 c4 10             	add    $0x10,%esp
f0113cb9:	83 ec 0c             	sub    $0xc,%esp
f0113cbc:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113cc2:	50                   	push   %eax
f0113cc3:	e8 33 e2 fe ff       	call   f0101efb <execute_command>
f0113cc8:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113ccb:	83 ec 04             	sub    $0x4,%esp
f0113cce:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113cd4:	50                   	push   %eax
f0113cd5:	68 1e a1 12 f0       	push   $0xf012a11e
f0113cda:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ce0:	50                   	push   %eax
f0113ce1:	e8 45 c7 00 00       	call   f012042b <strcconcat>
f0113ce6:	83 c4 10             	add    $0x10,%esp
f0113ce9:	83 ec 0c             	sub    $0xc,%esp
f0113cec:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113cf2:	50                   	push   %eax
f0113cf3:	e8 03 e2 fe ff       	call   f0101efb <execute_command>
f0113cf8:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113cfb:	83 ec 04             	sub    $0x4,%esp
f0113cfe:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113d04:	50                   	push   %eax
f0113d05:	68 28 a1 12 f0       	push   $0xf012a128
f0113d0a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113d10:	50                   	push   %eax
f0113d11:	e8 15 c7 00 00       	call   f012042b <strcconcat>
f0113d16:	83 c4 10             	add    $0x10,%esp
f0113d19:	83 ec 0c             	sub    $0xc,%esp
f0113d1c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113d22:	50                   	push   %eax
f0113d23:	e8 d3 e1 fe ff       	call   f0101efb <execute_command>
f0113d28:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113d2b:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113d31:	bb c1 a8 12 f0       	mov    $0xf012a8c1,%ebx
f0113d36:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113d3b:	89 c7                	mov    %eax,%edi
f0113d3d:	89 de                	mov    %ebx,%esi
f0113d3f:	89 d1                	mov    %edx,%ecx
f0113d41:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113d43:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113d49:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113d4e:	b0 00                	mov    $0x0,%al
f0113d50:	89 d7                	mov    %edx,%edi
f0113d52:	f3 aa                	rep stos %al,%es:(%edi)
f0113d54:	83 ec 0c             	sub    $0xc,%esp
f0113d57:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113d5d:	50                   	push   %eax
f0113d5e:	e8 98 e1 fe ff       	call   f0101efb <execute_command>
f0113d63:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113d66:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113d6c:	bb 25 a9 12 f0       	mov    $0xf012a925,%ebx
f0113d71:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113d76:	89 c7                	mov    %eax,%edi
f0113d78:	89 de                	mov    %ebx,%esi
f0113d7a:	89 d1                	mov    %edx,%ecx
f0113d7c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113d7e:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113d84:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113d89:	b0 00                	mov    $0x0,%al
f0113d8b:	89 d7                	mov    %edx,%edi
f0113d8d:	f3 aa                	rep stos %al,%es:(%edi)
f0113d8f:	83 ec 0c             	sub    $0xc,%esp
f0113d92:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113d98:	50                   	push   %eax
f0113d99:	e8 5d e1 fe ff       	call   f0101efb <execute_command>
f0113d9e:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113da1:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113da7:	bb 89 a9 12 f0       	mov    $0xf012a989,%ebx
f0113dac:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113db1:	89 c7                	mov    %eax,%edi
f0113db3:	89 de                	mov    %ebx,%esi
f0113db5:	89 d1                	mov    %edx,%ecx
f0113db7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113db9:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113dbf:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113dc4:	b0 00                	mov    $0x0,%al
f0113dc6:	89 d7                	mov    %edx,%edi
f0113dc8:	f3 aa                	rep stos %al,%es:(%edi)
f0113dca:	83 ec 0c             	sub    $0xc,%esp
f0113dcd:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113dd3:	50                   	push   %eax
f0113dd4:	e8 22 e1 fe ff       	call   f0101efb <execute_command>
f0113dd9:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ddc:	e8 b1 ad ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113de1:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113de4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113de7:	89 d0                	mov    %edx,%eax
f0113de9:	01 c0                	add    %eax,%eax
f0113deb:	01 d0                	add    %edx,%eax
f0113ded:	c1 e0 02             	shl    $0x2,%eax
f0113df0:	50                   	push   %eax
f0113df1:	68 00 00 90 00       	push   $0x900000
f0113df6:	68 00 00 80 00       	push   $0x800000
f0113dfb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dfe:	e8 8c 6f ff ff       	call   f010ad8f <copy_paste_chunk>
f0113e03:	83 c4 10             	add    $0x10,%esp
f0113e06:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113e0c:	e8 81 ad ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113e11:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113e14:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113e1b:	75 0b                	jne    f0113e28 <test_copy_paste_chunk+0xdc2>
f0113e1d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113e20:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113e23:	83 f8 03             	cmp    $0x3,%eax
f0113e26:	74 2e                	je     f0113e56 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113e28:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113e2b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113e2e:	83 ec 0c             	sub    $0xc,%esp
f0113e31:	50                   	push   %eax
f0113e32:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113e38:	68 e4 9f 12 f0       	push   $0xf0129fe4
f0113e3d:	68 95 03 00 00       	push   $0x395
f0113e42:	68 42 97 12 f0       	push   $0xf0129742
f0113e47:	e8 8a c6 fe ff       	call   f01004d6 <_warn>
f0113e4c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113e4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e56:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e5a:	74 04                	je     f0113e60 <test_copy_paste_chunk+0xdfa>
f0113e5c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e60:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113e67:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113e6e:	83 ec 08             	sub    $0x8,%esp
f0113e71:	6a 01                	push   $0x1
f0113e73:	6a 07                	push   $0x7
f0113e75:	6a 07                	push   $0x7
f0113e77:	6a 07                	push   $0x7
f0113e79:	6a 07                	push   $0x7
f0113e7b:	6a 01                	push   $0x1
f0113e7d:	68 00 30 00 00       	push   $0x3000
f0113e82:	68 00 00 90 00       	push   $0x900000
f0113e87:	68 00 00 80 00       	push   $0x800000
f0113e8c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113e8f:	e8 26 2e 00 00       	call   f0116cba <CCP>
f0113e94:	83 c4 30             	add    $0x30,%esp
f0113e97:	83 f8 01             	cmp    $0x1,%eax
f0113e9a:	74 28                	je     f0113ec4 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113e9c:	83 ec 04             	sub    $0x4,%esp
f0113e9f:	68 84 a0 12 f0       	push   $0xf012a084
f0113ea4:	68 9e 03 00 00       	push   $0x39e
f0113ea9:	68 42 97 12 f0       	push   $0xf0129742
f0113eae:	e8 23 c6 fe ff       	call   f01004d6 <_warn>
f0113eb3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113eb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113ebd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113ec4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ec8:	74 04                	je     f0113ece <test_copy_paste_chunk+0xe68>
f0113eca:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ece:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113ed5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113ed9:	0f 84 9e 00 00 00    	je     f0113f7d <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113edf:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113ee6:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113eed:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113ef4:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113efb:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113f02:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113f09:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f0c:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113f0f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113f12:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113f15:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f18:	8a 00                	mov    (%eax),%al
f0113f1a:	3c 61                	cmp    $0x61,%al
f0113f1c:	75 2d                	jne    f0113f4b <test_copy_paste_chunk+0xee5>
f0113f1e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113f21:	8a 00                	mov    (%eax),%al
f0113f23:	3c 61                	cmp    $0x61,%al
f0113f25:	75 24                	jne    f0113f4b <test_copy_paste_chunk+0xee5>
f0113f27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f2a:	8a 00                	mov    (%eax),%al
f0113f2c:	3c 79                	cmp    $0x79,%al
f0113f2e:	75 1b                	jne    f0113f4b <test_copy_paste_chunk+0xee5>
f0113f30:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113f33:	8a 00                	mov    (%eax),%al
f0113f35:	3c 62                	cmp    $0x62,%al
f0113f37:	75 12                	jne    f0113f4b <test_copy_paste_chunk+0xee5>
f0113f39:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113f3c:	8a 00                	mov    (%eax),%al
f0113f3e:	3c 63                	cmp    $0x63,%al
f0113f40:	75 09                	jne    f0113f4b <test_copy_paste_chunk+0xee5>
f0113f42:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113f45:	8a 00                	mov    (%eax),%al
f0113f47:	3c 7a                	cmp    $0x7a,%al
f0113f49:	74 21                	je     f0113f6c <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113f4b:	83 ec 04             	sub    $0x4,%esp
f0113f4e:	68 38 9f 12 f0       	push   $0xf0129f38
f0113f53:	68 b0 03 00 00       	push   $0x3b0
f0113f58:	68 42 97 12 f0       	push   $0xf0129742
f0113f5d:	e8 74 c5 fe ff       	call   f01004d6 <_warn>
f0113f62:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113f65:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113f6c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f70:	74 04                	je     f0113f76 <test_copy_paste_chunk+0xf10>
f0113f72:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113f76:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113f7d:	e8 10 ac ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113f82:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113f85:	6a 00                	push   $0x0
f0113f87:	6a 02                	push   $0x2
f0113f89:	68 00 10 90 00       	push   $0x901000
f0113f8e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113f91:	e8 b1 2b 00 00       	call   f0116b47 <SB>
f0113f96:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113f99:	6a 00                	push   $0x0
f0113f9b:	6a 02                	push   $0x2
f0113f9d:	68 00 20 90 00       	push   $0x902000
f0113fa2:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113fa5:	e8 9d 2b 00 00       	call   f0116b47 <SB>
f0113faa:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113fad:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113fb0:	c1 e0 03             	shl    $0x3,%eax
f0113fb3:	50                   	push   %eax
f0113fb4:	68 00 f0 bf 00       	push   $0xbff000
f0113fb9:	68 00 10 90 00       	push   $0x901000
f0113fbe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113fc1:	e8 c9 6d ff ff       	call   f010ad8f <copy_paste_chunk>
f0113fc6:	83 c4 10             	add    $0x10,%esp
f0113fc9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113fcf:	e8 be ab ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0113fd4:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113fd7:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113fde:	75 0b                	jne    f0113feb <test_copy_paste_chunk+0xf85>
f0113fe0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113fe3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113fe6:	83 f8 03             	cmp    $0x3,%eax
f0113fe9:	74 2e                	je     f0114019 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113feb:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113fee:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113ff1:	83 ec 0c             	sub    $0xc,%esp
f0113ff4:	50                   	push   %eax
f0113ff5:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113ffb:	68 e4 9f 12 f0       	push   $0xf0129fe4
f0114000:	68 c0 03 00 00       	push   $0x3c0
f0114005:	68 42 97 12 f0       	push   $0xf0129742
f011400a:	e8 c7 c4 fe ff       	call   f01004d6 <_warn>
f011400f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114012:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114019:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011401d:	74 04                	je     f0114023 <test_copy_paste_chunk+0xfbd>
f011401f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114023:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f011402a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0114031:	83 ec 08             	sub    $0x8,%esp
f0114034:	6a 01                	push   $0x1
f0114036:	6a 07                	push   $0x7
f0114038:	6a 03                	push   $0x3
f011403a:	6a 07                	push   $0x7
f011403c:	6a 03                	push   $0x3
f011403e:	6a 01                	push   $0x1
f0114040:	68 00 20 00 00       	push   $0x2000
f0114045:	68 00 f0 bf 00       	push   $0xbff000
f011404a:	68 00 10 90 00       	push   $0x901000
f011404f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114052:	e8 63 2c 00 00       	call   f0116cba <CCP>
f0114057:	83 c4 30             	add    $0x30,%esp
f011405a:	83 f8 01             	cmp    $0x1,%eax
f011405d:	74 28                	je     f0114087 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f011405f:	83 ec 04             	sub    $0x4,%esp
f0114062:	68 84 a0 12 f0       	push   $0xf012a084
f0114067:	68 c9 03 00 00       	push   $0x3c9
f011406c:	68 42 97 12 f0       	push   $0xf0129742
f0114071:	e8 60 c4 fe ff       	call   f01004d6 <_warn>
f0114076:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114079:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114080:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0114087:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011408b:	74 04                	je     f0114091 <test_copy_paste_chunk+0x102b>
f011408d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114091:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114098:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011409c:	74 72                	je     f0114110 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f011409e:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f01140a5:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f01140ac:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f01140b3:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f01140ba:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140bd:	8a 00                	mov    (%eax),%al
f01140bf:	3c 62                	cmp    $0x62,%al
f01140c1:	75 1b                	jne    f01140de <test_copy_paste_chunk+0x1078>
f01140c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140c6:	8a 00                	mov    (%eax),%al
f01140c8:	3c 62                	cmp    $0x62,%al
f01140ca:	75 12                	jne    f01140de <test_copy_paste_chunk+0x1078>
f01140cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01140cf:	8a 00                	mov    (%eax),%al
f01140d1:	3c 7a                	cmp    $0x7a,%al
f01140d3:	75 09                	jne    f01140de <test_copy_paste_chunk+0x1078>
f01140d5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01140d8:	8a 00                	mov    (%eax),%al
f01140da:	3c 7a                	cmp    $0x7a,%al
f01140dc:	74 21                	je     f01140ff <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01140de:	83 ec 04             	sub    $0x4,%esp
f01140e1:	68 38 9f 12 f0       	push   $0xf0129f38
f01140e6:	68 d5 03 00 00       	push   $0x3d5
f01140eb:	68 42 97 12 f0       	push   $0xf0129742
f01140f0:	e8 e1 c3 fe ff       	call   f01004d6 <_warn>
f01140f5:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01140f8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01140ff:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114103:	74 04                	je     f0114109 <test_copy_paste_chunk+0x10a3>
f0114105:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114109:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114110:	83 ec 0c             	sub    $0xc,%esp
f0114113:	68 32 a1 12 f0       	push   $0xf012a132
f0114118:	e8 6e ce fe ff       	call   f0100f8b <cprintf>
f011411d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0114120:	83 ec 08             	sub    $0x8,%esp
f0114123:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114126:	68 44 a1 12 f0       	push   $0xf012a144
f011412b:	e8 5b ce fe ff       	call   f0100f8b <cprintf>
f0114130:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114133:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114137:	75 10                	jne    f0114149 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0114139:	83 ec 0c             	sub    $0xc,%esp
f011413c:	68 78 a1 12 f0       	push   $0xf012a178
f0114141:	e8 45 ce fe ff       	call   f0100f8b <cprintf>
f0114146:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114149:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f011414e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114151:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114154:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114157:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011415c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011415f:	5b                   	pop    %ebx
f0114160:	5e                   	pop    %esi
f0114161:	5f                   	pop    %edi
f0114162:	5d                   	pop    %ebp
f0114163:	c3                   	ret    

f0114164 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0114164:	55                   	push   %ebp
f0114165:	89 e5                	mov    %esp,%ebp
f0114167:	57                   	push   %edi
f0114168:	56                   	push   %esi
f0114169:	53                   	push   %ebx
f011416a:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114170:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0114176:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f011417b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114180:	89 c7                	mov    %eax,%edi
f0114182:	89 de                	mov    %ebx,%esi
f0114184:	89 d1                	mov    %edx,%ecx
f0114186:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114188:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f011418e:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114193:	b0 00                	mov    $0x0,%al
f0114195:	89 d7                	mov    %edx,%edi
f0114197:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114199:	6a 00                	push   $0x0
f011419b:	6a 0a                	push   $0xa
f011419d:	6a 14                	push   $0x14
f011419f:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01141a5:	50                   	push   %eax
f01141a6:	e8 47 70 ff ff       	call   f010b1f2 <env_create>
f01141ab:	83 c4 10             	add    $0x10,%esp
f01141ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01141b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01141b4:	8b 40 64             	mov    0x64(%eax),%eax
f01141b7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01141ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01141bd:	8b 40 68             	mov    0x68(%eax),%eax
f01141c0:	89 45 80             	mov    %eax,-0x80(%ebp)
f01141c3:	8b 45 80             	mov    -0x80(%ebp),%eax
f01141c6:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01141c9:	83 ec 0c             	sub    $0xc,%esp
f01141cc:	ff 75 cc             	pushl  -0x34(%ebp)
f01141cf:	e8 b2 2a 00 00       	call   f0116c86 <ClearUserSpace>
f01141d4:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01141d7:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01141de:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01141e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f01141ec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f01141f0:	83 ec 0c             	sub    $0xc,%esp
f01141f3:	68 f0 a9 12 f0       	push   $0xf012a9f0
f01141f8:	e8 8e cd fe ff       	call   f0100f8b <cprintf>
f01141fd:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0114200:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0114207:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f011420e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114211:	8a 00                	mov    (%eax),%al
f0114213:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0114219:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011421c:	8a 00                	mov    (%eax),%al
f011421e:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114224:	e8 69 a9 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114229:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f011422c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011422f:	89 d0                	mov    %edx,%eax
f0114231:	01 c0                	add    %eax,%eax
f0114233:	01 d0                	add    %edx,%eax
f0114235:	01 c0                	add    %eax,%eax
f0114237:	83 ec 0c             	sub    $0xc,%esp
f011423a:	6a 02                	push   $0x2
f011423c:	50                   	push   %eax
f011423d:	68 00 40 10 f0       	push   $0xf0104000
f0114242:	68 00 00 10 f0       	push   $0xf0100000
f0114247:	ff 75 cc             	pushl  -0x34(%ebp)
f011424a:	e8 5a 6b ff ff       	call   f010ada9 <share_chunk>
f011424f:	83 c4 20             	add    $0x20,%esp
f0114252:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114255:	e8 38 a9 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011425a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011425d:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114261:	75 08                	jne    f011426b <test_share_chunk+0x107>
f0114263:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114266:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114269:	74 28                	je     f0114293 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f011426b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011426e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114271:	83 ec 0c             	sub    $0xc,%esp
f0114274:	50                   	push   %eax
f0114275:	ff 75 b0             	pushl  -0x50(%ebp)
f0114278:	68 1c aa 12 f0       	push   $0xf012aa1c
f011427d:	68 11 04 00 00       	push   $0x411
f0114282:	68 42 97 12 f0       	push   $0xf0129742
f0114287:	e8 4a c2 fe ff       	call   f01004d6 <_warn>
f011428c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011428f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114293:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114297:	74 04                	je     f011429d <test_share_chunk+0x139>
f0114299:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011429d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f01142a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01142a4:	c1 e0 03             	shl    $0x3,%eax
f01142a7:	83 ec 08             	sub    $0x8,%esp
f01142aa:	68 fd 00 00 00       	push   $0xfd
f01142af:	6a 07                	push   $0x7
f01142b1:	6a 03                	push   $0x3
f01142b3:	6a 07                	push   $0x7
f01142b5:	6a 03                	push   $0x3
f01142b7:	6a 01                	push   $0x1
f01142b9:	50                   	push   %eax
f01142ba:	68 00 40 10 f0       	push   $0xf0104000
f01142bf:	68 00 00 10 f0       	push   $0xf0100000
f01142c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01142c7:	e8 ee 29 00 00       	call   f0116cba <CCP>
f01142cc:	83 c4 30             	add    $0x30,%esp
f01142cf:	85 c0                	test   %eax,%eax
f01142d1:	75 1e                	jne    f01142f1 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01142d3:	83 ec 04             	sub    $0x4,%esp
f01142d6:	68 78 aa 12 f0       	push   $0xf012aa78
f01142db:	68 19 04 00 00       	push   $0x419
f01142e0:	68 42 97 12 f0       	push   $0xf0129742
f01142e5:	e8 ec c1 fe ff       	call   f01004d6 <_warn>
f01142ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01142ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142f5:	74 04                	je     f01142fb <test_share_chunk+0x197>
f01142f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01142fb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142fe:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0114301:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114304:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114307:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011430a:	8a 00                	mov    (%eax),%al
f011430c:	3c 41                	cmp    $0x41,%al
f011430e:	75 09                	jne    f0114319 <test_share_chunk+0x1b5>
f0114310:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114313:	8a 00                	mov    (%eax),%al
f0114315:	3c 42                	cmp    $0x42,%al
f0114317:	74 1e                	je     f0114337 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114319:	83 ec 04             	sub    $0x4,%esp
f011431c:	68 c0 aa 12 f0       	push   $0xf012aac0
f0114321:	68 23 04 00 00       	push   $0x423
f0114326:	68 42 97 12 f0       	push   $0xf0129742
f011432b:	e8 a6 c1 fe ff       	call   f01004d6 <_warn>
f0114330:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114333:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114337:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011433b:	74 04                	je     f0114341 <test_share_chunk+0x1dd>
f011433d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114341:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0114345:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f011434b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011434e:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114350:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0114356:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114359:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f011435b:	83 ec 0c             	sub    $0xc,%esp
f011435e:	68 f5 aa 12 f0       	push   $0xf012aaf5
f0114363:	e8 23 cc fe ff       	call   f0100f8b <cprintf>
f0114368:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f011436b:	83 ec 0c             	sub    $0xc,%esp
f011436e:	68 04 ab 12 f0       	push   $0xf012ab04
f0114373:	e8 13 cc fe ff       	call   f0100f8b <cprintf>
f0114378:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011437b:	e8 12 a8 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114380:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114383:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114386:	c1 e0 05             	shl    $0x5,%eax
f0114389:	83 ec 0c             	sub    $0xc,%esp
f011438c:	68 02 0e 00 00       	push   $0xe02
f0114391:	50                   	push   %eax
f0114392:	68 00 00 00 40       	push   $0x40000000
f0114397:	68 00 00 00 f0       	push   $0xf0000000
f011439c:	ff 75 cc             	pushl  -0x34(%ebp)
f011439f:	e8 05 6a ff ff       	call   f010ada9 <share_chunk>
f01143a4:	83 c4 20             	add    $0x20,%esp
f01143a7:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01143aa:	e8 e3 a7 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01143af:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f01143b2:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01143b6:	75 1f                	jne    f01143d7 <test_share_chunk+0x273>
f01143b8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143bb:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01143be:	89 c1                	mov    %eax,%ecx
f01143c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01143c3:	c1 e0 05             	shl    $0x5,%eax
f01143c6:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01143c9:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01143d0:	99                   	cltd   
f01143d1:	f7 fb                	idiv   %ebx
f01143d3:	39 c1                	cmp    %eax,%ecx
f01143d5:	74 28                	je     f01143ff <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01143d7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143da:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01143dd:	83 ec 0c             	sub    $0xc,%esp
f01143e0:	50                   	push   %eax
f01143e1:	ff 75 a8             	pushl  -0x58(%ebp)
f01143e4:	68 40 ab 12 f0       	push   $0xf012ab40
f01143e9:	68 3b 04 00 00       	push   $0x43b
f01143ee:	68 42 97 12 f0       	push   $0xf0129742
f01143f3:	e8 de c0 fe ff       	call   f01004d6 <_warn>
f01143f8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143fb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143ff:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114403:	74 04                	je     f0114409 <test_share_chunk+0x2a5>
f0114405:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114409:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011440d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114414:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114417:	c1 e0 05             	shl    $0x5,%eax
f011441a:	83 ec 08             	sub    $0x8,%esp
f011441d:	6a 02                	push   $0x2
f011441f:	6a 07                	push   $0x7
f0114421:	6a 03                	push   $0x3
f0114423:	68 07 0e 00 00       	push   $0xe07
f0114428:	68 03 0e 00 00       	push   $0xe03
f011442d:	6a ff                	push   $0xffffffff
f011442f:	50                   	push   %eax
f0114430:	68 00 00 00 40       	push   $0x40000000
f0114435:	68 00 00 00 f0       	push   $0xf0000000
f011443a:	ff 75 cc             	pushl  -0x34(%ebp)
f011443d:	e8 78 28 00 00       	call   f0116cba <CCP>
f0114442:	83 c4 30             	add    $0x30,%esp
f0114445:	85 c0                	test   %eax,%eax
f0114447:	75 25                	jne    f011446e <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114449:	83 ec 04             	sub    $0x4,%esp
f011444c:	68 78 aa 12 f0       	push   $0xf012aa78
f0114451:	68 44 04 00 00       	push   $0x444
f0114456:	68 42 97 12 f0       	push   $0xf0129742
f011445b:	e8 76 c0 fe ff       	call   f01004d6 <_warn>
f0114460:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114463:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114467:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011446e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114471:	89 d0                	mov    %edx,%eax
f0114473:	01 c0                	add    %eax,%eax
f0114475:	01 d0                	add    %edx,%eax
f0114477:	c1 e0 02             	shl    $0x2,%eax
f011447a:	83 ec 08             	sub    $0x8,%esp
f011447d:	6a 02                	push   $0x2
f011447f:	6a 07                	push   $0x7
f0114481:	6a 03                	push   $0x3
f0114483:	68 07 0e 00 00       	push   $0xe07
f0114488:	68 03 0e 00 00       	push   $0xe03
f011448d:	6a 02                	push   $0x2
f011448f:	50                   	push   %eax
f0114490:	68 00 00 00 40       	push   $0x40000000
f0114495:	68 00 00 00 f0       	push   $0xf0000000
f011449a:	ff 75 cc             	pushl  -0x34(%ebp)
f011449d:	e8 18 28 00 00       	call   f0116cba <CCP>
f01144a2:	83 c4 30             	add    $0x30,%esp
f01144a5:	85 c0                	test   %eax,%eax
f01144a7:	75 1e                	jne    f01144c7 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144a9:	83 ec 04             	sub    $0x4,%esp
f01144ac:	68 78 aa 12 f0       	push   $0xf012aa78
f01144b1:	68 4b 04 00 00       	push   $0x44b
f01144b6:	68 42 97 12 f0       	push   $0xf0129742
f01144bb:	e8 16 c0 fe ff       	call   f01004d6 <_warn>
f01144c0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144c7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144cb:	74 04                	je     f01144d1 <test_share_chunk+0x36d>
f01144cd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144d1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f01144d5:	b8 70 22 6b f2       	mov    $0xf26b2270,%eax
f01144da:	05 00 00 00 10       	add    $0x10000000,%eax
f01144df:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01144e2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01144e5:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01144ea:	83 ec 08             	sub    $0x8,%esp
f01144ed:	6a 02                	push   $0x2
f01144ef:	6a 07                	push   $0x7
f01144f1:	6a 03                	push   $0x3
f01144f3:	68 07 0e 00 00       	push   $0xe07
f01144f8:	68 03 0e 00 00       	push   $0xe03
f01144fd:	6a 02                	push   $0x2
f01144ff:	50                   	push   %eax
f0114500:	68 00 00 0a 40       	push   $0x400a0000
f0114505:	68 00 00 0a f0       	push   $0xf00a0000
f011450a:	ff 75 cc             	pushl  -0x34(%ebp)
f011450d:	e8 a8 27 00 00       	call   f0116cba <CCP>
f0114512:	83 c4 30             	add    $0x30,%esp
f0114515:	85 c0                	test   %eax,%eax
f0114517:	75 1e                	jne    f0114537 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114519:	83 ec 04             	sub    $0x4,%esp
f011451c:	68 78 aa 12 f0       	push   $0xf012aa78
f0114521:	68 55 04 00 00       	push   $0x455
f0114526:	68 42 97 12 f0       	push   $0xf0129742
f011452b:	e8 a6 bf fe ff       	call   f01004d6 <_warn>
f0114530:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114533:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114537:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011453b:	74 04                	je     f0114541 <test_share_chunk+0x3dd>
f011453d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114541:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114545:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114549:	0f 84 a4 00 00 00    	je     f01145f3 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f011454f:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0114556:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114559:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f011455c:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0114563:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114566:	8a 00                	mov    (%eax),%al
f0114568:	3c 41                	cmp    $0x41,%al
f011456a:	75 09                	jne    f0114575 <test_share_chunk+0x411>
f011456c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011456f:	8a 00                	mov    (%eax),%al
f0114571:	3c 41                	cmp    $0x41,%al
f0114573:	74 1e                	je     f0114593 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114575:	83 ec 04             	sub    $0x4,%esp
f0114578:	68 c0 aa 12 f0       	push   $0xf012aac0
f011457d:	68 62 04 00 00       	push   $0x462
f0114582:	68 42 97 12 f0       	push   $0xf0129742
f0114587:	e8 4a bf fe ff       	call   f01004d6 <_warn>
f011458c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011458f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114593:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114597:	74 04                	je     f011459d <test_share_chunk+0x439>
f0114599:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011459d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f01145a1:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f01145a8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145ab:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f01145ae:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f01145b5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145b8:	8a 00                	mov    (%eax),%al
f01145ba:	3c 43                	cmp    $0x43,%al
f01145bc:	75 09                	jne    f01145c7 <test_share_chunk+0x463>
f01145be:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145c1:	8a 00                	mov    (%eax),%al
f01145c3:	3c 43                	cmp    $0x43,%al
f01145c5:	74 1e                	je     f01145e5 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01145c7:	83 ec 04             	sub    $0x4,%esp
f01145ca:	68 c0 aa 12 f0       	push   $0xf012aac0
f01145cf:	68 6d 04 00 00       	push   $0x46d
f01145d4:	68 42 97 12 f0       	push   $0xf0129742
f01145d9:	e8 f8 be fe ff       	call   f01004d6 <_warn>
f01145de:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01145e1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01145e5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145e9:	74 04                	je     f01145ef <test_share_chunk+0x48b>
f01145eb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01145ef:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01145f3:	83 ec 0c             	sub    $0xc,%esp
f01145f6:	68 cf a0 12 f0       	push   $0xf012a0cf
f01145fb:	e8 8b c9 fe ff       	call   f0100f8b <cprintf>
f0114600:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0114603:	83 ec 0c             	sub    $0xc,%esp
f0114606:	68 90 ab 12 f0       	push   $0xf012ab90
f011460b:	e8 7b c9 fe ff       	call   f0100f8b <cprintf>
f0114610:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114613:	e8 7a a5 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114618:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f011461b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011461e:	89 d0                	mov    %edx,%eax
f0114620:	c1 e0 03             	shl    $0x3,%eax
f0114623:	01 d0                	add    %edx,%eax
f0114625:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011462c:	01 d0                	add    %edx,%eax
f011462e:	c1 e0 03             	shl    $0x3,%eax
f0114631:	83 ec 0c             	sub    $0xc,%esp
f0114634:	6a 06                	push   $0x6
f0114636:	50                   	push   %eax
f0114637:	6a 00                	push   $0x0
f0114639:	68 00 00 00 40       	push   $0x40000000
f011463e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114641:	e8 63 67 ff ff       	call   f010ada9 <share_chunk>
f0114646:	83 c4 20             	add    $0x20,%esp
f0114649:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011464c:	e8 41 a5 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114651:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114654:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114658:	75 0b                	jne    f0114665 <test_share_chunk+0x501>
f011465a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011465d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114660:	83 f8 01             	cmp    $0x1,%eax
f0114663:	74 28                	je     f011468d <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114665:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114668:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011466b:	83 ec 0c             	sub    $0xc,%esp
f011466e:	50                   	push   %eax
f011466f:	ff 75 a0             	pushl  -0x60(%ebp)
f0114672:	68 40 ab 12 f0       	push   $0xf012ab40
f0114677:	68 83 04 00 00       	push   $0x483
f011467c:	68 42 97 12 f0       	push   $0xf0129742
f0114681:	e8 50 be fe ff       	call   f01004d6 <_warn>
f0114686:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114689:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011468d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114691:	74 04                	je     f0114697 <test_share_chunk+0x533>
f0114693:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114697:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011469b:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01146a2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01146a5:	05 00 80 02 00       	add    $0x28000,%eax
f01146aa:	c1 e0 02             	shl    $0x2,%eax
f01146ad:	83 ec 08             	sub    $0x8,%esp
f01146b0:	6a 02                	push   $0x2
f01146b2:	6a 07                	push   $0x7
f01146b4:	6a 03                	push   $0x3
f01146b6:	6a 07                	push   $0x7
f01146b8:	6a 07                	push   $0x7
f01146ba:	6a ff                	push   $0xffffffff
f01146bc:	50                   	push   %eax
f01146bd:	6a 00                	push   $0x0
f01146bf:	68 00 00 00 40       	push   $0x40000000
f01146c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01146c7:	e8 ee 25 00 00       	call   f0116cba <CCP>
f01146cc:	83 c4 30             	add    $0x30,%esp
f01146cf:	85 c0                	test   %eax,%eax
f01146d1:	75 25                	jne    f01146f8 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01146d3:	83 ec 04             	sub    $0x4,%esp
f01146d6:	68 78 aa 12 f0       	push   $0xf012aa78
f01146db:	68 8c 04 00 00       	push   $0x48c
f01146e0:	68 42 97 12 f0       	push   $0xf0129742
f01146e5:	e8 ec bd fe ff       	call   f01004d6 <_warn>
f01146ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01146f1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01146f8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146fb:	89 d0                	mov    %edx,%eax
f01146fd:	01 c0                	add    %eax,%eax
f01146ff:	01 d0                	add    %edx,%eax
f0114701:	c1 e0 02             	shl    $0x2,%eax
f0114704:	83 ec 08             	sub    $0x8,%esp
f0114707:	6a 02                	push   $0x2
f0114709:	6a 07                	push   $0x7
f011470b:	6a 03                	push   $0x3
f011470d:	6a 07                	push   $0x7
f011470f:	6a 07                	push   $0x7
f0114711:	6a 03                	push   $0x3
f0114713:	50                   	push   %eax
f0114714:	6a 00                	push   $0x0
f0114716:	68 00 00 00 40       	push   $0x40000000
f011471b:	ff 75 cc             	pushl  -0x34(%ebp)
f011471e:	e8 97 25 00 00       	call   f0116cba <CCP>
f0114723:	83 c4 30             	add    $0x30,%esp
f0114726:	85 c0                	test   %eax,%eax
f0114728:	75 1e                	jne    f0114748 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011472a:	83 ec 04             	sub    $0x4,%esp
f011472d:	68 78 aa 12 f0       	push   $0xf012aa78
f0114732:	68 93 04 00 00       	push   $0x493
f0114737:	68 42 97 12 f0       	push   $0xf0129742
f011473c:	e8 95 bd fe ff       	call   f01004d6 <_warn>
f0114741:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114744:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114748:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011474c:	74 04                	je     f0114752 <test_share_chunk+0x5ee>
f011474e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114752:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114756:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114759:	89 d0                	mov    %edx,%eax
f011475b:	01 c0                	add    %eax,%eax
f011475d:	01 d0                	add    %edx,%eax
f011475f:	c1 e0 02             	shl    $0x2,%eax
f0114762:	f7 d8                	neg    %eax
f0114764:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114769:	83 ec 08             	sub    $0x8,%esp
f011476c:	6a 02                	push   $0x2
f011476e:	6a 07                	push   $0x7
f0114770:	6a 03                	push   $0x3
f0114772:	6a 07                	push   $0x7
f0114774:	6a 07                	push   $0x7
f0114776:	6a 02                	push   $0x2
f0114778:	50                   	push   %eax
f0114779:	68 00 30 00 00       	push   $0x3000
f011477e:	68 00 30 00 40       	push   $0x40003000
f0114783:	ff 75 cc             	pushl  -0x34(%ebp)
f0114786:	e8 2f 25 00 00       	call   f0116cba <CCP>
f011478b:	83 c4 30             	add    $0x30,%esp
f011478e:	85 c0                	test   %eax,%eax
f0114790:	75 1e                	jne    f01147b0 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114792:	83 ec 04             	sub    $0x4,%esp
f0114795:	68 78 aa 12 f0       	push   $0xf012aa78
f011479a:	68 9b 04 00 00       	push   $0x49b
f011479f:	68 42 97 12 f0       	push   $0xf0129742
f01147a4:	e8 2d bd fe ff       	call   f01004d6 <_warn>
f01147a9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147ac:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147b4:	74 04                	je     f01147ba <test_share_chunk+0x656>
f01147b6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147ba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01147be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01147c1:	c1 e0 02             	shl    $0x2,%eax
f01147c4:	83 ec 08             	sub    $0x8,%esp
f01147c7:	6a 02                	push   $0x2
f01147c9:	6a 07                	push   $0x7
f01147cb:	6a 03                	push   $0x3
f01147cd:	6a 07                	push   $0x7
f01147cf:	6a 07                	push   $0x7
f01147d1:	6a 03                	push   $0x3
f01147d3:	50                   	push   %eax
f01147d4:	68 00 00 0a 00       	push   $0xa0000
f01147d9:	68 00 00 0a 40       	push   $0x400a0000
f01147de:	ff 75 cc             	pushl  -0x34(%ebp)
f01147e1:	e8 d4 24 00 00       	call   f0116cba <CCP>
f01147e6:	83 c4 30             	add    $0x30,%esp
f01147e9:	85 c0                	test   %eax,%eax
f01147eb:	75 1e                	jne    f011480b <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147ed:	83 ec 04             	sub    $0x4,%esp
f01147f0:	68 78 aa 12 f0       	push   $0xf012aa78
f01147f5:	68 a3 04 00 00       	push   $0x4a3
f01147fa:	68 42 97 12 f0       	push   $0xf0129742
f01147ff:	e8 d2 bc fe ff       	call   f01004d6 <_warn>
f0114804:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114807:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011480b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011480f:	74 04                	je     f0114815 <test_share_chunk+0x6b1>
f0114811:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114815:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114819:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011481d:	0f 84 92 00 00 00    	je     f01148b5 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114823:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f011482a:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114831:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114838:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f011483f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114842:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0114845:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f011484c:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114853:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114856:	8a 00                	mov    (%eax),%al
f0114858:	3c 41                	cmp    $0x41,%al
f011485a:	75 2d                	jne    f0114889 <test_share_chunk+0x725>
f011485c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011485f:	8a 00                	mov    (%eax),%al
f0114861:	3c 41                	cmp    $0x41,%al
f0114863:	75 24                	jne    f0114889 <test_share_chunk+0x725>
f0114865:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114868:	8a 00                	mov    (%eax),%al
f011486a:	3c 41                	cmp    $0x41,%al
f011486c:	75 1b                	jne    f0114889 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011486e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114871:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114873:	3c 44                	cmp    $0x44,%al
f0114875:	75 12                	jne    f0114889 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114877:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011487a:	8a 00                	mov    (%eax),%al
f011487c:	3c 44                	cmp    $0x44,%al
f011487e:	75 09                	jne    f0114889 <test_share_chunk+0x725>
f0114880:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114883:	8a 00                	mov    (%eax),%al
f0114885:	3c 44                	cmp    $0x44,%al
f0114887:	74 1e                	je     f01148a7 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114889:	83 ec 04             	sub    $0x4,%esp
f011488c:	68 c0 aa 12 f0       	push   $0xf012aac0
f0114891:	68 b5 04 00 00       	push   $0x4b5
f0114896:	68 42 97 12 f0       	push   $0xf0129742
f011489b:	e8 36 bc fe ff       	call   f01004d6 <_warn>
f01148a0:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01148a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01148a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148ab:	74 04                	je     f01148b1 <test_share_chunk+0x74d>
f01148ad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01148b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01148b5:	83 ec 0c             	sub    $0xc,%esp
f01148b8:	68 32 a1 12 f0       	push   $0xf012a132
f01148bd:	e8 c9 c6 fe ff       	call   f0100f8b <cprintf>
f01148c2:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f01148c5:	83 ec 0c             	sub    $0xc,%esp
f01148c8:	68 cc ab 12 f0       	push   $0xf012abcc
f01148cd:	e8 b9 c6 fe ff       	call   f0100f8b <cprintf>
f01148d2:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01148d5:	e8 b8 a2 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01148da:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f01148dd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148e0:	89 d0                	mov    %edx,%eax
f01148e2:	01 c0                	add    %eax,%eax
f01148e4:	01 d0                	add    %edx,%eax
f01148e6:	01 c0                	add    %eax,%eax
f01148e8:	01 d0                	add    %edx,%eax
f01148ea:	83 ec 0c             	sub    $0xc,%esp
f01148ed:	6a 04                	push   $0x4
f01148ef:	50                   	push   %eax
f01148f0:	68 00 fc 3f 00       	push   $0x3ffc00
f01148f5:	68 00 fc 09 00       	push   $0x9fc00
f01148fa:	ff 75 cc             	pushl  -0x34(%ebp)
f01148fd:	e8 a7 64 ff ff       	call   f010ada9 <share_chunk>
f0114902:	83 c4 20             	add    $0x20,%esp
f0114905:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114908:	e8 85 a2 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011490d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114910:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114914:	75 0b                	jne    f0114921 <test_share_chunk+0x7bd>
f0114916:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114919:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011491c:	83 f8 01             	cmp    $0x1,%eax
f011491f:	74 28                	je     f0114949 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114921:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114924:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114927:	83 ec 0c             	sub    $0xc,%esp
f011492a:	50                   	push   %eax
f011492b:	ff 75 8c             	pushl  -0x74(%ebp)
f011492e:	68 40 ab 12 f0       	push   $0xf012ab40
f0114933:	68 cb 04 00 00       	push   $0x4cb
f0114938:	68 42 97 12 f0       	push   $0xf0129742
f011493d:	e8 94 bb fe ff       	call   f01004d6 <_warn>
f0114942:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114945:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114949:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011494d:	74 04                	je     f0114953 <test_share_chunk+0x7ef>
f011494f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114953:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114957:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011495e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114961:	89 d0                	mov    %edx,%eax
f0114963:	01 c0                	add    %eax,%eax
f0114965:	01 d0                	add    %edx,%eax
f0114967:	c1 e0 02             	shl    $0x2,%eax
f011496a:	83 ec 08             	sub    $0x8,%esp
f011496d:	6a 02                	push   $0x2
f011496f:	6a 07                	push   $0x7
f0114971:	6a 07                	push   $0x7
f0114973:	6a 07                	push   $0x7
f0114975:	6a 05                	push   $0x5
f0114977:	6a ff                	push   $0xffffffff
f0114979:	50                   	push   %eax
f011497a:	68 00 f0 3f 00       	push   $0x3ff000
f011497f:	68 00 f0 09 00       	push   $0x9f000
f0114984:	ff 75 cc             	pushl  -0x34(%ebp)
f0114987:	e8 2e 23 00 00       	call   f0116cba <CCP>
f011498c:	83 c4 30             	add    $0x30,%esp
f011498f:	85 c0                	test   %eax,%eax
f0114991:	75 25                	jne    f01149b8 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114993:	83 ec 04             	sub    $0x4,%esp
f0114996:	68 78 aa 12 f0       	push   $0xf012aa78
f011499b:	68 d4 04 00 00       	push   $0x4d4
f01149a0:	68 42 97 12 f0       	push   $0xf0129742
f01149a5:	e8 2c bb fe ff       	call   f01004d6 <_warn>
f01149aa:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149ad:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01149b1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01149b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01149bc:	74 04                	je     f01149c2 <test_share_chunk+0x85e>
f01149be:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01149c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01149c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01149c9:	c1 e0 02             	shl    $0x2,%eax
f01149cc:	83 ec 08             	sub    $0x8,%esp
f01149cf:	6a 02                	push   $0x2
f01149d1:	6a 07                	push   $0x7
f01149d3:	6a 07                	push   $0x7
f01149d5:	6a 07                	push   $0x7
f01149d7:	6a 05                	push   $0x5
f01149d9:	6a 03                	push   $0x3
f01149db:	50                   	push   %eax
f01149dc:	68 00 f0 3f 00       	push   $0x3ff000
f01149e1:	68 00 f0 09 00       	push   $0x9f000
f01149e6:	ff 75 cc             	pushl  -0x34(%ebp)
f01149e9:	e8 cc 22 00 00       	call   f0116cba <CCP>
f01149ee:	83 c4 30             	add    $0x30,%esp
f01149f1:	85 c0                	test   %eax,%eax
f01149f3:	75 1e                	jne    f0114a13 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01149f5:	83 ec 04             	sub    $0x4,%esp
f01149f8:	68 78 aa 12 f0       	push   $0xf012aa78
f01149fd:	68 dd 04 00 00       	push   $0x4dd
f0114a02:	68 42 97 12 f0       	push   $0xf0129742
f0114a07:	e8 ca ba fe ff       	call   f01004d6 <_warn>
f0114a0c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a0f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a13:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a17:	74 04                	je     f0114a1d <test_share_chunk+0x8b9>
f0114a19:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a1d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114a21:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a24:	c1 e0 03             	shl    $0x3,%eax
f0114a27:	83 ec 08             	sub    $0x8,%esp
f0114a2a:	6a 02                	push   $0x2
f0114a2c:	6a 07                	push   $0x7
f0114a2e:	6a 07                	push   $0x7
f0114a30:	6a 07                	push   $0x7
f0114a32:	6a 05                	push   $0x5
f0114a34:	6a 04                	push   $0x4
f0114a36:	50                   	push   %eax
f0114a37:	68 00 00 40 00       	push   $0x400000
f0114a3c:	68 00 00 0a 00       	push   $0xa0000
f0114a41:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a44:	e8 71 22 00 00       	call   f0116cba <CCP>
f0114a49:	83 c4 30             	add    $0x30,%esp
f0114a4c:	85 c0                	test   %eax,%eax
f0114a4e:	75 1e                	jne    f0114a6e <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114a50:	83 ec 04             	sub    $0x4,%esp
f0114a53:	68 78 aa 12 f0       	push   $0xf012aa78
f0114a58:	68 e5 04 00 00       	push   $0x4e5
f0114a5d:	68 42 97 12 f0       	push   $0xf0129742
f0114a62:	e8 6f ba fe ff       	call   f01004d6 <_warn>
f0114a67:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a6a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a6e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a72:	74 04                	je     f0114a78 <test_share_chunk+0x914>
f0114a74:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a78:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114a7c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114a80:	0f 84 b2 00 00 00    	je     f0114b38 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114a86:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114a8d:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114a94:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114a9b:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114aa2:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114aa9:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114ab0:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114ab7:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114abe:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114ac1:	8a 00                	mov    (%eax),%al
f0114ac3:	3c 44                	cmp    $0x44,%al
f0114ac5:	75 45                	jne    f0114b0c <test_share_chunk+0x9a8>
f0114ac7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114aca:	8a 00                	mov    (%eax),%al
f0114acc:	3c 44                	cmp    $0x44,%al
f0114ace:	75 3c                	jne    f0114b0c <test_share_chunk+0x9a8>
f0114ad0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114ad3:	8a 00                	mov    (%eax),%al
f0114ad5:	3c 44                	cmp    $0x44,%al
f0114ad7:	75 33                	jne    f0114b0c <test_share_chunk+0x9a8>
f0114ad9:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114adc:	8a 00                	mov    (%eax),%al
f0114ade:	3c 44                	cmp    $0x44,%al
f0114ae0:	75 2a                	jne    f0114b0c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114ae2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114ae5:	8a 10                	mov    (%eax),%dl
f0114ae7:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114aea:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114aec:	38 c2                	cmp    %al,%dl
f0114aee:	75 1c                	jne    f0114b0c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114af0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114af3:	8a 10                	mov    (%eax),%dl
f0114af5:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114af8:	8a 00                	mov    (%eax),%al
f0114afa:	38 c2                	cmp    %al,%dl
f0114afc:	75 0e                	jne    f0114b0c <test_share_chunk+0x9a8>
f0114afe:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114b01:	8a 10                	mov    (%eax),%dl
f0114b03:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114b06:	8a 00                	mov    (%eax),%al
f0114b08:	38 c2                	cmp    %al,%dl
f0114b0a:	74 1e                	je     f0114b2a <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114b0c:	83 ec 04             	sub    $0x4,%esp
f0114b0f:	68 c0 aa 12 f0       	push   $0xf012aac0
f0114b14:	68 fa 04 00 00       	push   $0x4fa
f0114b19:	68 42 97 12 f0       	push   $0xf0129742
f0114b1e:	e8 b3 b9 fe ff       	call   f01004d6 <_warn>
f0114b23:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114b26:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114b2a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b2e:	74 04                	je     f0114b34 <test_share_chunk+0x9d0>
f0114b30:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114b34:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114b38:	83 ec 0c             	sub    $0xc,%esp
f0114b3b:	68 04 ac 12 f0       	push   $0xf012ac04
f0114b40:	e8 46 c4 fe ff       	call   f0100f8b <cprintf>
f0114b45:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114b48:	83 ec 08             	sub    $0x8,%esp
f0114b4b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114b4e:	68 14 ac 12 f0       	push   $0xf012ac14
f0114b53:	e8 33 c4 fe ff       	call   f0100f8b <cprintf>
f0114b58:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114b5b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114b5f:	75 10                	jne    f0114b71 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114b61:	83 ec 0c             	sub    $0xc,%esp
f0114b64:	68 44 ac 12 f0       	push   $0xf012ac44
f0114b69:	e8 1d c4 fe ff       	call   f0100f8b <cprintf>
f0114b6e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114b71:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0114b76:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114b79:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114b7c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114b7f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114b84:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114b87:	5b                   	pop    %ebx
f0114b88:	5e                   	pop    %esi
f0114b89:	5f                   	pop    %edi
f0114b8a:	5d                   	pop    %ebp
f0114b8b:	c3                   	ret    

f0114b8c <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114b8c:	55                   	push   %ebp
f0114b8d:	89 e5                	mov    %esp,%ebp
f0114b8f:	57                   	push   %edi
f0114b90:	56                   	push   %esi
f0114b91:	53                   	push   %ebx
f0114b92:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114b98:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114b9e:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f0114ba3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ba8:	89 c7                	mov    %eax,%edi
f0114baa:	89 de                	mov    %ebx,%esi
f0114bac:	89 d1                	mov    %edx,%ecx
f0114bae:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114bb0:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114bb6:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114bbb:	b0 00                	mov    $0x0,%al
f0114bbd:	89 d7                	mov    %edx,%edi
f0114bbf:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114bc1:	6a 00                	push   $0x0
f0114bc3:	6a 0a                	push   $0xa
f0114bc5:	6a 14                	push   $0x14
f0114bc7:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114bcd:	50                   	push   %eax
f0114bce:	e8 1f 66 ff ff       	call   f010b1f2 <env_create>
f0114bd3:	83 c4 10             	add    $0x10,%esp
f0114bd6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114bd9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114bdc:	8b 40 64             	mov    0x64(%eax),%eax
f0114bdf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114be2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114be5:	8b 40 68             	mov    0x68(%eax),%eax
f0114be8:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114beb:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114bee:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114bf1:	83 ec 0c             	sub    $0xc,%esp
f0114bf4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bf7:	e8 8a 20 00 00       	call   f0116c86 <ClearUserSpace>
f0114bfc:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114bff:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114c06:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114c0d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114c14:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114c18:	83 ec 0c             	sub    $0xc,%esp
f0114c1b:	68 80 ac 12 f0       	push   $0xf012ac80
f0114c20:	e8 66 c3 fe ff       	call   f0100f8b <cprintf>
f0114c25:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114c28:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114c2f:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114c36:	eb 03                	jmp    f0114c3b <test_allocate_chunk+0xaf>
f0114c38:	ff 4d e4             	decl   -0x1c(%ebp)
f0114c3b:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114c42:	76 09                	jbe    f0114c4d <test_allocate_chunk+0xc1>
f0114c44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c47:	8a 00                	mov    (%eax),%al
f0114c49:	84 c0                	test   %al,%al
f0114c4b:	74 eb                	je     f0114c38 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114c4d:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114c54:	75 06                	jne    f0114c5c <test_allocate_chunk+0xd0>
f0114c56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c59:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114c5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c5f:	8a 00                	mov    (%eax),%al
f0114c61:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114c67:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c6a:	8a 00                	mov    (%eax),%al
f0114c6c:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114c72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c75:	8a 00                	mov    (%eax),%al
f0114c77:	0f be c0             	movsbl %al,%eax
f0114c7a:	83 ec 08             	sub    $0x8,%esp
f0114c7d:	50                   	push   %eax
f0114c7e:	68 aa ac 12 f0       	push   $0xf012acaa
f0114c83:	e8 03 c3 fe ff       	call   f0100f8b <cprintf>
f0114c88:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114c8b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c8e:	8a 00                	mov    (%eax),%al
f0114c90:	0f be c0             	movsbl %al,%eax
f0114c93:	83 ec 08             	sub    $0x8,%esp
f0114c96:	50                   	push   %eax
f0114c97:	68 b6 ac 12 f0       	push   $0xf012acb6
f0114c9c:	e8 ea c2 fe ff       	call   f0100f8b <cprintf>
f0114ca1:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114ca4:	83 ec 08             	sub    $0x8,%esp
f0114ca7:	68 00 f0 bf ef       	push   $0xefbff000
f0114cac:	ff 75 cc             	pushl  -0x34(%ebp)
f0114caf:	e8 b3 1f 00 00       	call   f0116c67 <GP>
f0114cb4:	83 c4 10             	add    $0x10,%esp
f0114cb7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114cba:	e8 d3 9e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114cbf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114cc2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114cc5:	c1 e0 02             	shl    $0x2,%eax
f0114cc8:	6a 02                	push   $0x2
f0114cca:	50                   	push   %eax
f0114ccb:	68 00 f0 bf ef       	push   $0xefbff000
f0114cd0:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cd3:	e8 eb 60 ff ff       	call   f010adc3 <allocate_chunk>
f0114cd8:	83 c4 10             	add    $0x10,%esp
f0114cdb:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114cde:	e8 af 9e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114ce3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114ce6:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114cea:	75 08                	jne    f0114cf4 <test_allocate_chunk+0x168>
f0114cec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cef:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114cf2:	74 2a                	je     f0114d1e <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114cf4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cf7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cfa:	83 ec 08             	sub    $0x8,%esp
f0114cfd:	6a 00                	push   $0x0
f0114cff:	50                   	push   %eax
f0114d00:	ff 75 b0             	pushl  -0x50(%ebp)
f0114d03:	68 c4 ac 12 f0       	push   $0xf012acc4
f0114d08:	68 3a 05 00 00       	push   $0x53a
f0114d0d:	68 42 97 12 f0       	push   $0xf0129742
f0114d12:	e8 bf b7 fe ff       	call   f01004d6 <_warn>
f0114d17:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d1a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114d1e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d22:	74 04                	je     f0114d28 <test_allocate_chunk+0x19c>
f0114d24:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114d28:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114d2c:	e8 61 9e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114d31:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114d34:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114d37:	01 c0                	add    %eax,%eax
f0114d39:	89 c1                	mov    %eax,%ecx
f0114d3b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d3e:	89 d0                	mov    %edx,%eax
f0114d40:	c1 e0 02             	shl    $0x2,%eax
f0114d43:	01 d0                	add    %edx,%eax
f0114d45:	f7 d8                	neg    %eax
f0114d47:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114d4c:	6a 02                	push   $0x2
f0114d4e:	51                   	push   %ecx
f0114d4f:	50                   	push   %eax
f0114d50:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d53:	e8 6b 60 ff ff       	call   f010adc3 <allocate_chunk>
f0114d58:	83 c4 10             	add    $0x10,%esp
f0114d5b:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114d5e:	e8 2f 9e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114d63:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114d66:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114d6a:	75 08                	jne    f0114d74 <test_allocate_chunk+0x1e8>
f0114d6c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d6f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114d72:	74 2a                	je     f0114d9e <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114d74:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d77:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d7a:	83 ec 08             	sub    $0x8,%esp
f0114d7d:	6a 00                	push   $0x0
f0114d7f:	50                   	push   %eax
f0114d80:	ff 75 b0             	pushl  -0x50(%ebp)
f0114d83:	68 c4 ac 12 f0       	push   $0xf012acc4
f0114d88:	68 48 05 00 00       	push   $0x548
f0114d8d:	68 42 97 12 f0       	push   $0xf0129742
f0114d92:	e8 3f b7 fe ff       	call   f01004d6 <_warn>
f0114d97:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d9a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114d9e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114da2:	74 04                	je     f0114da8 <test_allocate_chunk+0x21c>
f0114da4:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114da8:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114dac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114daf:	c1 e0 02             	shl    $0x2,%eax
f0114db2:	83 ec 08             	sub    $0x8,%esp
f0114db5:	6a 03                	push   $0x3
f0114db7:	6a 00                	push   $0x0
f0114db9:	6a 00                	push   $0x0
f0114dbb:	68 ff 0f 00 00       	push   $0xfff
f0114dc0:	ff 75 b8             	pushl  -0x48(%ebp)
f0114dc3:	6a 01                	push   $0x1
f0114dc5:	50                   	push   %eax
f0114dc6:	68 00 f0 bf ef       	push   $0xefbff000
f0114dcb:	6a 00                	push   $0x0
f0114dcd:	ff 75 cc             	pushl  -0x34(%ebp)
f0114dd0:	e8 e5 1e 00 00       	call   f0116cba <CCP>
f0114dd5:	83 c4 30             	add    $0x30,%esp
f0114dd8:	85 c0                	test   %eax,%eax
f0114dda:	75 1e                	jne    f0114dfa <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114ddc:	83 ec 04             	sub    $0x4,%esp
f0114ddf:	68 2c ad 12 f0       	push   $0xf012ad2c
f0114de4:	68 50 05 00 00       	push   $0x550
f0114de9:	68 42 97 12 f0       	push   $0xf0129742
f0114dee:	e8 e3 b6 fe ff       	call   f01004d6 <_warn>
f0114df3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114df6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114dfa:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114dfe:	74 04                	je     f0114e04 <test_allocate_chunk+0x278>
f0114e00:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114e04:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114e08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114e0b:	8a 10                	mov    (%eax),%dl
f0114e0d:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114e13:	38 c2                	cmp    %al,%dl
f0114e15:	75 0f                	jne    f0114e26 <test_allocate_chunk+0x29a>
f0114e17:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e1a:	8a 10                	mov    (%eax),%dl
f0114e1c:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114e22:	38 c2                	cmp    %al,%dl
f0114e24:	74 1e                	je     f0114e44 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114e26:	83 ec 04             	sub    $0x4,%esp
f0114e29:	68 78 ad 12 f0       	push   $0xf012ad78
f0114e2e:	68 58 05 00 00       	push   $0x558
f0114e33:	68 42 97 12 f0       	push   $0xf0129742
f0114e38:	e8 99 b6 fe ff       	call   f01004d6 <_warn>
f0114e3d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114e40:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114e44:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e48:	74 04                	je     f0114e4e <test_allocate_chunk+0x2c2>
f0114e4a:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114e4e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114e52:	83 ec 0c             	sub    $0xc,%esp
f0114e55:	68 f5 aa 12 f0       	push   $0xf012aaf5
f0114e5a:	e8 2c c1 fe ff       	call   f0100f8b <cprintf>
f0114e5f:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114e62:	83 ec 0c             	sub    $0xc,%esp
f0114e65:	68 b0 ad 12 f0       	push   $0xf012adb0
f0114e6a:	e8 1c c1 fe ff       	call   f0100f8b <cprintf>
f0114e6f:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e72:	e8 1b 9d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114e77:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114e7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e7d:	c1 e0 05             	shl    $0x5,%eax
f0114e80:	68 02 0e 00 00       	push   $0xe02
f0114e85:	50                   	push   %eax
f0114e86:	6a 00                	push   $0x0
f0114e88:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e8b:	e8 33 5f ff ff       	call   f010adc3 <allocate_chunk>
f0114e90:	83 c4 10             	add    $0x10,%esp
f0114e93:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114e96:	e8 f7 9c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0114e9b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114e9e:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114ea2:	75 36                	jne    f0114eda <test_allocate_chunk+0x34e>
f0114ea4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ea7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114eaa:	89 c1                	mov    %eax,%ecx
f0114eac:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114eaf:	c1 e0 05             	shl    $0x5,%eax
f0114eb2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114eb5:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114ebc:	99                   	cltd   
f0114ebd:	f7 fe                	idiv   %esi
f0114ebf:	89 c3                	mov    %eax,%ebx
f0114ec1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ec4:	c1 e0 05             	shl    $0x5,%eax
f0114ec7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114eca:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114ed1:	99                   	cltd   
f0114ed2:	f7 fe                	idiv   %esi
f0114ed4:	01 d8                	add    %ebx,%eax
f0114ed6:	39 c1                	cmp    %eax,%ecx
f0114ed8:	74 54                	je     f0114f2e <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114eda:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114edd:	c1 e0 05             	shl    $0x5,%eax
f0114ee0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114ee3:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114eea:	99                   	cltd   
f0114eeb:	f7 ff                	idiv   %edi
f0114eed:	89 c1                	mov    %eax,%ecx
f0114eef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ef2:	c1 e0 05             	shl    $0x5,%eax
f0114ef5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ef8:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114eff:	99                   	cltd   
f0114f00:	f7 fe                	idiv   %esi
f0114f02:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114f05:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f08:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f0b:	83 ec 08             	sub    $0x8,%esp
f0114f0e:	52                   	push   %edx
f0114f0f:	50                   	push   %eax
f0114f10:	ff 75 a8             	pushl  -0x58(%ebp)
f0114f13:	68 f0 ad 12 f0       	push   $0xf012adf0
f0114f18:	68 6d 05 00 00       	push   $0x56d
f0114f1d:	68 42 97 12 f0       	push   $0xf0129742
f0114f22:	e8 af b5 fe ff       	call   f01004d6 <_warn>
f0114f27:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f2a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114f2e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f32:	74 04                	je     f0114f38 <test_allocate_chunk+0x3ac>
f0114f34:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f38:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114f3c:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114f43:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f46:	c1 e0 05             	shl    $0x5,%eax
f0114f49:	83 ec 08             	sub    $0x8,%esp
f0114f4c:	6a 03                	push   $0x3
f0114f4e:	6a 00                	push   $0x0
f0114f50:	6a 00                	push   $0x0
f0114f52:	68 07 0e 00 00       	push   $0xe07
f0114f57:	68 03 0e 00 00       	push   $0xe03
f0114f5c:	6a 01                	push   $0x1
f0114f5e:	50                   	push   %eax
f0114f5f:	6a 00                	push   $0x0
f0114f61:	6a 00                	push   $0x0
f0114f63:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f66:	e8 4f 1d 00 00       	call   f0116cba <CCP>
f0114f6b:	83 c4 30             	add    $0x30,%esp
f0114f6e:	85 c0                	test   %eax,%eax
f0114f70:	75 25                	jne    f0114f97 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f72:	83 ec 04             	sub    $0x4,%esp
f0114f75:	68 2c ad 12 f0       	push   $0xf012ad2c
f0114f7a:	68 76 05 00 00       	push   $0x576
f0114f7f:	68 42 97 12 f0       	push   $0xf0129742
f0114f84:	e8 4d b5 fe ff       	call   f01004d6 <_warn>
f0114f89:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f8c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114f90:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114f97:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f9b:	74 04                	je     f0114fa1 <test_allocate_chunk+0x415>
f0114f9d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114fa1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114fa5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114fa9:	74 5a                	je     f0115005 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114fab:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114fae:	01 c0                	add    %eax,%eax
f0114fb0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114fb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114fb6:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114fb9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fbc:	01 c0                	add    %eax,%eax
f0114fbe:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114fc1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114fc4:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114fc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114fca:	8a 00                	mov    (%eax),%al
f0114fcc:	3c 4b                	cmp    $0x4b,%al
f0114fce:	75 09                	jne    f0114fd9 <test_allocate_chunk+0x44d>
f0114fd0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114fd3:	8a 00                	mov    (%eax),%al
f0114fd5:	3c 4d                	cmp    $0x4d,%al
f0114fd7:	74 1e                	je     f0114ff7 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114fd9:	83 ec 04             	sub    $0x4,%esp
f0114fdc:	68 78 ad 12 f0       	push   $0xf012ad78
f0114fe1:	68 84 05 00 00       	push   $0x584
f0114fe6:	68 42 97 12 f0       	push   $0xf0129742
f0114feb:	e8 e6 b4 fe ff       	call   f01004d6 <_warn>
f0114ff0:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114ff3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114ff7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ffb:	74 04                	je     f0115001 <test_allocate_chunk+0x475>
f0114ffd:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115001:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0115005:	83 ec 0c             	sub    $0xc,%esp
f0115008:	68 cf a0 12 f0       	push   $0xf012a0cf
f011500d:	e8 79 bf fe ff       	call   f0100f8b <cprintf>
f0115012:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0115015:	83 ec 0c             	sub    $0xc,%esp
f0115018:	68 50 ae 12 f0       	push   $0xf012ae50
f011501d:	e8 69 bf fe ff       	call   f0100f8b <cprintf>
f0115022:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115025:	e8 68 9b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011502a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f011502d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115030:	c1 e0 06             	shl    $0x6,%eax
f0115033:	89 c2                	mov    %eax,%edx
f0115035:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115038:	c1 e0 05             	shl    $0x5,%eax
f011503b:	6a 00                	push   $0x0
f011503d:	52                   	push   %edx
f011503e:	50                   	push   %eax
f011503f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115042:	e8 7c 5d ff ff       	call   f010adc3 <allocate_chunk>
f0115047:	83 c4 10             	add    $0x10,%esp
f011504a:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011504d:	e8 40 9b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0115052:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0115055:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0115059:	75 36                	jne    f0115091 <test_allocate_chunk+0x505>
f011505b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011505e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115061:	89 c1                	mov    %eax,%ecx
f0115063:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115066:	c1 e0 06             	shl    $0x6,%eax
f0115069:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011506c:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115073:	99                   	cltd   
f0115074:	f7 ff                	idiv   %edi
f0115076:	89 c3                	mov    %eax,%ebx
f0115078:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011507b:	c1 e0 06             	shl    $0x6,%eax
f011507e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115081:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115088:	99                   	cltd   
f0115089:	f7 fe                	idiv   %esi
f011508b:	01 d8                	add    %ebx,%eax
f011508d:	39 c1                	cmp    %eax,%ecx
f011508f:	74 54                	je     f01150e5 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115091:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115094:	c1 e0 06             	shl    $0x6,%eax
f0115097:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011509a:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01150a1:	99                   	cltd   
f01150a2:	f7 fb                	idiv   %ebx
f01150a4:	89 c1                	mov    %eax,%ecx
f01150a6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01150a9:	c1 e0 06             	shl    $0x6,%eax
f01150ac:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01150af:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01150b6:	99                   	cltd   
f01150b7:	f7 ff                	idiv   %edi
f01150b9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01150bc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150bf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01150c2:	83 ec 08             	sub    $0x8,%esp
f01150c5:	52                   	push   %edx
f01150c6:	50                   	push   %eax
f01150c7:	ff 75 a4             	pushl  -0x5c(%ebp)
f01150ca:	68 f0 ad 12 f0       	push   $0xf012adf0
f01150cf:	68 9a 05 00 00       	push   $0x59a
f01150d4:	68 42 97 12 f0       	push   $0xf0129742
f01150d9:	e8 f8 b3 fe ff       	call   f01004d6 <_warn>
f01150de:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150e1:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01150e5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150e9:	74 04                	je     f01150ef <test_allocate_chunk+0x563>
f01150eb:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01150ef:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01150f3:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01150fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01150fd:	c1 e0 06             	shl    $0x6,%eax
f0115100:	89 c2                	mov    %eax,%edx
f0115102:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115105:	c1 e0 05             	shl    $0x5,%eax
f0115108:	83 ec 08             	sub    $0x8,%esp
f011510b:	6a 03                	push   $0x3
f011510d:	6a 00                	push   $0x0
f011510f:	6a 00                	push   $0x0
f0115111:	68 07 0e 00 00       	push   $0xe07
f0115116:	6a 01                	push   $0x1
f0115118:	6a 01                	push   $0x1
f011511a:	52                   	push   %edx
f011511b:	50                   	push   %eax
f011511c:	6a 00                	push   $0x0
f011511e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115121:	e8 94 1b 00 00       	call   f0116cba <CCP>
f0115126:	83 c4 30             	add    $0x30,%esp
f0115129:	85 c0                	test   %eax,%eax
f011512b:	75 25                	jne    f0115152 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011512d:	83 ec 04             	sub    $0x4,%esp
f0115130:	68 2c ad 12 f0       	push   $0xf012ad2c
f0115135:	68 a3 05 00 00       	push   $0x5a3
f011513a:	68 42 97 12 f0       	push   $0xf0129742
f011513f:	e8 92 b3 fe ff       	call   f01004d6 <_warn>
f0115144:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115147:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011514b:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0115152:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115156:	74 04                	je     f011515c <test_allocate_chunk+0x5d0>
f0115158:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011515c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0115160:	83 ec 0c             	sub    $0xc,%esp
f0115163:	68 32 a1 12 f0       	push   $0xf012a132
f0115168:	e8 1e be fe ff       	call   f0100f8b <cprintf>
f011516d:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0115170:	83 ec 0c             	sub    $0xc,%esp
f0115173:	68 90 ae 12 f0       	push   $0xf012ae90
f0115178:	e8 0e be fe ff       	call   f0100f8b <cprintf>
f011517d:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115180:	e8 0d 9a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0115185:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0115188:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011518b:	c1 e0 06             	shl    $0x6,%eax
f011518e:	68 06 0e 00 00       	push   $0xe06
f0115193:	50                   	push   %eax
f0115194:	68 00 00 00 80       	push   $0x80000000
f0115199:	ff 75 cc             	pushl  -0x34(%ebp)
f011519c:	e8 22 5c ff ff       	call   f010adc3 <allocate_chunk>
f01151a1:	83 c4 10             	add    $0x10,%esp
f01151a4:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01151a7:	e8 e6 99 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01151ac:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f01151af:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f01151b3:	75 36                	jne    f01151eb <test_allocate_chunk+0x65f>
f01151b5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151b8:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151bb:	89 c1                	mov    %eax,%ecx
f01151bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151c0:	c1 e0 06             	shl    $0x6,%eax
f01151c3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151c6:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01151cd:	99                   	cltd   
f01151ce:	f7 fb                	idiv   %ebx
f01151d0:	89 c3                	mov    %eax,%ebx
f01151d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151d5:	c1 e0 06             	shl    $0x6,%eax
f01151d8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01151db:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151e2:	99                   	cltd   
f01151e3:	f7 fe                	idiv   %esi
f01151e5:	01 d8                	add    %ebx,%eax
f01151e7:	39 c1                	cmp    %eax,%ecx
f01151e9:	74 54                	je     f011523f <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f01151eb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151ee:	c1 e0 06             	shl    $0x6,%eax
f01151f1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151f4:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01151fb:	99                   	cltd   
f01151fc:	f7 ff                	idiv   %edi
f01151fe:	89 c1                	mov    %eax,%ecx
f0115200:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115203:	c1 e0 06             	shl    $0x6,%eax
f0115206:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115209:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115210:	99                   	cltd   
f0115211:	f7 fb                	idiv   %ebx
f0115213:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115216:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115219:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011521c:	83 ec 08             	sub    $0x8,%esp
f011521f:	52                   	push   %edx
f0115220:	50                   	push   %eax
f0115221:	ff 75 9c             	pushl  -0x64(%ebp)
f0115224:	68 f0 ad 12 f0       	push   $0xf012adf0
f0115229:	68 b9 05 00 00       	push   $0x5b9
f011522e:	68 42 97 12 f0       	push   $0xf0129742
f0115233:	e8 9e b2 fe ff       	call   f01004d6 <_warn>
f0115238:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011523b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011523f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115243:	74 04                	je     f0115249 <test_allocate_chunk+0x6bd>
f0115245:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115249:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011524d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0115254:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115257:	c1 e0 06             	shl    $0x6,%eax
f011525a:	83 ec 08             	sub    $0x8,%esp
f011525d:	6a 03                	push   $0x3
f011525f:	6a 00                	push   $0x0
f0115261:	6a 00                	push   $0x0
f0115263:	68 07 0e 00 00       	push   $0xe07
f0115268:	68 07 0e 00 00       	push   $0xe07
f011526d:	6a 01                	push   $0x1
f011526f:	50                   	push   %eax
f0115270:	68 00 00 00 80       	push   $0x80000000
f0115275:	6a 00                	push   $0x0
f0115277:	ff 75 cc             	pushl  -0x34(%ebp)
f011527a:	e8 3b 1a 00 00       	call   f0116cba <CCP>
f011527f:	83 c4 30             	add    $0x30,%esp
f0115282:	85 c0                	test   %eax,%eax
f0115284:	75 25                	jne    f01152ab <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115286:	83 ec 04             	sub    $0x4,%esp
f0115289:	68 2c ad 12 f0       	push   $0xf012ad2c
f011528e:	68 c2 05 00 00       	push   $0x5c2
f0115293:	68 42 97 12 f0       	push   $0xf0129742
f0115298:	e8 39 b2 fe ff       	call   f01004d6 <_warn>
f011529d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01152a0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01152a4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f01152ab:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152af:	74 04                	je     f01152b5 <test_allocate_chunk+0x729>
f01152b1:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01152b5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01152b9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01152bd:	74 6f                	je     f011532e <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f01152bf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01152c2:	01 c0                	add    %eax,%eax
f01152c4:	05 00 00 00 80       	add    $0x80000000,%eax
f01152c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01152cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01152cf:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f01152d2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01152d5:	89 d0                	mov    %edx,%eax
f01152d7:	c1 e0 02             	shl    $0x2,%eax
f01152da:	01 d0                	add    %edx,%eax
f01152dc:	01 c0                	add    %eax,%eax
f01152de:	01 d0                	add    %edx,%eax
f01152e0:	01 c0                	add    %eax,%eax
f01152e2:	05 00 00 00 80       	add    $0x80000000,%eax
f01152e7:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01152ea:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01152ed:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01152f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01152f3:	8a 00                	mov    (%eax),%al
f01152f5:	3c 4b                	cmp    $0x4b,%al
f01152f7:	75 09                	jne    f0115302 <test_allocate_chunk+0x776>
f01152f9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01152fc:	8a 00                	mov    (%eax),%al
f01152fe:	3c 4d                	cmp    $0x4d,%al
f0115300:	74 1e                	je     f0115320 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115302:	83 ec 04             	sub    $0x4,%esp
f0115305:	68 78 ad 12 f0       	push   $0xf012ad78
f011530a:	68 d0 05 00 00       	push   $0x5d0
f011530f:	68 42 97 12 f0       	push   $0xf0129742
f0115314:	e8 bd b1 fe ff       	call   f01004d6 <_warn>
f0115319:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011531c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0115320:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115324:	74 04                	je     f011532a <test_allocate_chunk+0x79e>
f0115326:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f011532a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f011532e:	83 ec 0c             	sub    $0xc,%esp
f0115331:	68 04 ac 12 f0       	push   $0xf012ac04
f0115336:	e8 50 bc fe ff       	call   f0100f8b <cprintf>
f011533b:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f011533e:	83 ec 0c             	sub    $0xc,%esp
f0115341:	68 cc ae 12 f0       	push   $0xf012aecc
f0115346:	e8 40 bc fe ff       	call   f0100f8b <cprintf>
f011534b:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011534e:	e8 3f 98 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0115353:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0115356:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115359:	89 d0                	mov    %edx,%eax
f011535b:	01 c0                	add    %eax,%eax
f011535d:	01 d0                	add    %edx,%eax
f011535f:	01 c0                	add    %eax,%eax
f0115361:	01 d0                	add    %edx,%eax
f0115363:	68 04 0e 00 00       	push   $0xe04
f0115368:	50                   	push   %eax
f0115369:	68 00 fc 3f 40       	push   $0x403ffc00
f011536e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115371:	e8 4d 5a ff ff       	call   f010adc3 <allocate_chunk>
f0115376:	83 c4 10             	add    $0x10,%esp
f0115379:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011537c:	e8 11 98 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0115381:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0115384:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0115388:	75 0b                	jne    f0115395 <test_allocate_chunk+0x809>
f011538a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011538d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115390:	83 f8 05             	cmp    $0x5,%eax
f0115393:	74 2a                	je     f01153bf <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0115395:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115398:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011539b:	83 ec 08             	sub    $0x8,%esp
f011539e:	6a 05                	push   $0x5
f01153a0:	50                   	push   %eax
f01153a1:	ff 75 98             	pushl  -0x68(%ebp)
f01153a4:	68 f0 ad 12 f0       	push   $0xf012adf0
f01153a9:	68 e7 05 00 00       	push   $0x5e7
f01153ae:	68 42 97 12 f0       	push   $0xf0129742
f01153b3:	e8 1e b1 fe ff       	call   f01004d6 <_warn>
f01153b8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153bb:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01153bf:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153c3:	74 04                	je     f01153c9 <test_allocate_chunk+0x83d>
f01153c5:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01153c9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01153cd:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01153d4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01153d7:	89 d0                	mov    %edx,%eax
f01153d9:	01 c0                	add    %eax,%eax
f01153db:	01 d0                	add    %edx,%eax
f01153dd:	c1 e0 02             	shl    $0x2,%eax
f01153e0:	83 ec 08             	sub    $0x8,%esp
f01153e3:	6a 03                	push   $0x3
f01153e5:	6a 00                	push   $0x0
f01153e7:	6a 00                	push   $0x0
f01153e9:	68 07 0e 00 00       	push   $0xe07
f01153ee:	68 05 0e 00 00       	push   $0xe05
f01153f3:	6a 01                	push   $0x1
f01153f5:	50                   	push   %eax
f01153f6:	68 00 f0 3f 40       	push   $0x403ff000
f01153fb:	6a 00                	push   $0x0
f01153fd:	ff 75 cc             	pushl  -0x34(%ebp)
f0115400:	e8 b5 18 00 00       	call   f0116cba <CCP>
f0115405:	83 c4 30             	add    $0x30,%esp
f0115408:	85 c0                	test   %eax,%eax
f011540a:	75 25                	jne    f0115431 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011540c:	83 ec 04             	sub    $0x4,%esp
f011540f:	68 2c ad 12 f0       	push   $0xf012ad2c
f0115414:	68 f0 05 00 00       	push   $0x5f0
f0115419:	68 42 97 12 f0       	push   $0xf0129742
f011541e:	e8 b3 b0 fe ff       	call   f01004d6 <_warn>
f0115423:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115426:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011542a:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0115431:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115435:	74 04                	je     f011543b <test_allocate_chunk+0x8af>
f0115437:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011543b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f011543f:	83 ec 0c             	sub    $0xc,%esp
f0115442:	68 03 af 12 f0       	push   $0xf012af03
f0115447:	e8 3f bb fe ff       	call   f0100f8b <cprintf>
f011544c:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f011544f:	83 ec 08             	sub    $0x8,%esp
f0115452:	ff 75 e0             	pushl  -0x20(%ebp)
f0115455:	68 14 af 12 f0       	push   $0xf012af14
f011545a:	e8 2c bb fe ff       	call   f0100f8b <cprintf>
f011545f:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115462:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0115466:	75 10                	jne    f0115478 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115468:	83 ec 0c             	sub    $0xc,%esp
f011546b:	68 48 af 12 f0       	push   $0xf012af48
f0115470:	e8 16 bb fe ff       	call   f0100f8b <cprintf>
f0115475:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115478:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f011547d:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115480:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115483:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115486:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011548b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011548e:	5b                   	pop    %ebx
f011548f:	5e                   	pop    %esi
f0115490:	5f                   	pop    %edi
f0115491:	5d                   	pop    %ebp
f0115492:	c3                   	ret    

f0115493 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115493:	55                   	push   %ebp
f0115494:	89 e5                	mov    %esp,%ebp
f0115496:	57                   	push   %edi
f0115497:	56                   	push   %esi
f0115498:	53                   	push   %ebx
f0115499:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011549f:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01154a2:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f01154a7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01154ac:	89 c7                	mov    %eax,%edi
f01154ae:	89 de                	mov    %ebx,%esi
f01154b0:	89 d1                	mov    %edx,%ecx
f01154b2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01154b4:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01154b7:	b9 23 00 00 00       	mov    $0x23,%ecx
f01154bc:	b0 00                	mov    $0x0,%al
f01154be:	89 d7                	mov    %edx,%edi
f01154c0:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01154c2:	6a 00                	push   $0x0
f01154c4:	6a 0a                	push   $0xa
f01154c6:	6a 14                	push   $0x14
f01154c8:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01154cb:	50                   	push   %eax
f01154cc:	e8 21 5d ff ff       	call   f010b1f2 <env_create>
f01154d1:	83 c4 10             	add    $0x10,%esp
f01154d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01154d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01154da:	8b 40 64             	mov    0x64(%eax),%eax
f01154dd:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01154e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01154e3:	8b 40 68             	mov    0x68(%eax),%eax
f01154e6:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01154e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154ec:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01154ef:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01154f6:	75 70 20 
f01154f9:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115500:	00 00 00 
f0115503:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115506:	b9 03 00 00 00       	mov    $0x3,%ecx
f011550b:	b8 00 00 00 00       	mov    $0x0,%eax
f0115510:	89 d7                	mov    %edx,%edi
f0115512:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115514:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115517:	8b 40 10             	mov    0x10(%eax),%eax
f011551a:	83 ec 08             	sub    $0x8,%esp
f011551d:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115523:	52                   	push   %edx
f0115524:	50                   	push   %eax
f0115525:	e8 28 ae 00 00       	call   f0120352 <ltostr>
f011552a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011552d:	83 ec 04             	sub    $0x4,%esp
f0115530:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115536:	50                   	push   %eax
f0115537:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f011553d:	50                   	push   %eax
f011553e:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115544:	50                   	push   %eax
f0115545:	e8 e1 ae 00 00       	call   f012042b <strcconcat>
f011554a:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011554d:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115554:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f011555b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0115562:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115569:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f011556d:	83 ec 0c             	sub    $0xc,%esp
f0115570:	ff 75 d8             	pushl  -0x28(%ebp)
f0115573:	e8 0e 17 00 00       	call   f0116c86 <ClearUserSpace>
f0115578:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f011557b:	83 ec 0c             	sub    $0xc,%esp
f011557e:	68 88 af 12 f0       	push   $0xf012af88
f0115583:	e8 03 ba fe ff       	call   f0100f8b <cprintf>
f0115588:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011558b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011558e:	c1 e0 03             	shl    $0x3,%eax
f0115591:	83 ec 04             	sub    $0x4,%esp
f0115594:	50                   	push   %eax
f0115595:	6a 00                	push   $0x0
f0115597:	ff 75 d8             	pushl  -0x28(%ebp)
f011559a:	e8 58 58 ff ff       	call   f010adf7 <calculate_required_frames>
f011559f:	83 c4 10             	add    $0x10,%esp
f01155a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01155a5:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01155a9:	74 23                	je     f01155ce <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01155ab:	83 ec 0c             	sub    $0xc,%esp
f01155ae:	6a 03                	push   $0x3
f01155b0:	ff 75 c8             	pushl  -0x38(%ebp)
f01155b3:	68 bc af 12 f0       	push   $0xf012afbc
f01155b8:	68 29 06 00 00       	push   $0x629
f01155bd:	68 42 97 12 f0       	push   $0xf0129742
f01155c2:	e8 0f af fe ff       	call   f01004d6 <_warn>
f01155c7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155ca:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01155ce:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155d2:	74 04                	je     f01155d8 <test_calculate_required_frames+0x145>
f01155d4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155d8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f01155dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01155df:	c1 e0 02             	shl    $0x2,%eax
f01155e2:	83 ec 04             	sub    $0x4,%esp
f01155e5:	50                   	push   %eax
f01155e6:	6a 00                	push   $0x0
f01155e8:	ff 75 d8             	pushl  -0x28(%ebp)
f01155eb:	e8 07 58 ff ff       	call   f010adf7 <calculate_required_frames>
f01155f0:	83 c4 10             	add    $0x10,%esp
f01155f3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01155f6:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01155fd:	74 26                	je     f0115625 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01155ff:	83 ec 0c             	sub    $0xc,%esp
f0115602:	68 01 04 00 00       	push   $0x401
f0115607:	ff 75 c8             	pushl  -0x38(%ebp)
f011560a:	68 bc af 12 f0       	push   $0xf012afbc
f011560f:	68 33 06 00 00       	push   $0x633
f0115614:	68 42 97 12 f0       	push   $0xf0129742
f0115619:	e8 b8 ae fe ff       	call   f01004d6 <_warn>
f011561e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115621:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115625:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115629:	74 04                	je     f011562f <test_calculate_required_frames+0x19c>
f011562b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011562f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115633:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115636:	c1 e0 0a             	shl    $0xa,%eax
f0115639:	83 ec 04             	sub    $0x4,%esp
f011563c:	50                   	push   %eax
f011563d:	6a 00                	push   $0x0
f011563f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115642:	e8 b0 57 ff ff       	call   f010adf7 <calculate_required_frames>
f0115647:	83 c4 10             	add    $0x10,%esp
f011564a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f011564d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115650:	c1 e0 0a             	shl    $0xa,%eax
f0115653:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115656:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011565d:	99                   	cltd   
f011565e:	f7 fb                	idiv   %ebx
f0115660:	89 c1                	mov    %eax,%ecx
f0115662:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115665:	c1 e0 0a             	shl    $0xa,%eax
f0115668:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011566b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115672:	99                   	cltd   
f0115673:	f7 fe                	idiv   %esi
f0115675:	01 c8                	add    %ecx,%eax
f0115677:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011567a:	74 4c                	je     f01156c8 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f011567c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011567f:	c1 e0 0a             	shl    $0xa,%eax
f0115682:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115685:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011568c:	99                   	cltd   
f011568d:	f7 fb                	idiv   %ebx
f011568f:	89 c1                	mov    %eax,%ecx
f0115691:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115694:	c1 e0 0a             	shl    $0xa,%eax
f0115697:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011569a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01156a1:	99                   	cltd   
f01156a2:	f7 fe                	idiv   %esi
f01156a4:	01 c8                	add    %ecx,%eax
f01156a6:	83 ec 0c             	sub    $0xc,%esp
f01156a9:	50                   	push   %eax
f01156aa:	ff 75 c8             	pushl  -0x38(%ebp)
f01156ad:	68 bc af 12 f0       	push   $0xf012afbc
f01156b2:	68 3d 06 00 00       	push   $0x63d
f01156b7:	68 42 97 12 f0       	push   $0xf0129742
f01156bc:	e8 15 ae fe ff       	call   f01004d6 <_warn>
f01156c1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156c4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01156c8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156cc:	74 04                	je     f01156d2 <test_calculate_required_frames+0x23f>
f01156ce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156d2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f01156d6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01156d9:	89 d0                	mov    %edx,%eax
f01156db:	01 c0                	add    %eax,%eax
f01156dd:	01 d0                	add    %edx,%eax
f01156df:	01 c0                	add    %eax,%eax
f01156e1:	83 ec 04             	sub    $0x4,%esp
f01156e4:	50                   	push   %eax
f01156e5:	68 00 10 00 00       	push   $0x1000
f01156ea:	ff 75 d8             	pushl  -0x28(%ebp)
f01156ed:	e8 05 57 ff ff       	call   f010adf7 <calculate_required_frames>
f01156f2:	83 c4 10             	add    $0x10,%esp
f01156f5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01156f8:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01156fc:	74 23                	je     f0115721 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01156fe:	83 ec 0c             	sub    $0xc,%esp
f0115701:	6a 03                	push   $0x3
f0115703:	ff 75 c8             	pushl  -0x38(%ebp)
f0115706:	68 bc af 12 f0       	push   $0xf012afbc
f011570b:	68 49 06 00 00       	push   $0x649
f0115710:	68 42 97 12 f0       	push   $0xf0129742
f0115715:	e8 bc ad fe ff       	call   f01004d6 <_warn>
f011571a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011571d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115721:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115725:	74 04                	je     f011572b <test_calculate_required_frames+0x298>
f0115727:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011572b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011572f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115732:	89 c2                	mov    %eax,%edx
f0115734:	01 d2                	add    %edx,%edx
f0115736:	01 d0                	add    %edx,%eax
f0115738:	83 ec 04             	sub    $0x4,%esp
f011573b:	50                   	push   %eax
f011573c:	68 00 18 00 00       	push   $0x1800
f0115741:	ff 75 d8             	pushl  -0x28(%ebp)
f0115744:	e8 ae 56 ff ff       	call   f010adf7 <calculate_required_frames>
f0115749:	83 c4 10             	add    $0x10,%esp
f011574c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011574f:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115753:	74 23                	je     f0115778 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115755:	83 ec 0c             	sub    $0xc,%esp
f0115758:	6a 03                	push   $0x3
f011575a:	ff 75 c8             	pushl  -0x38(%ebp)
f011575d:	68 bc af 12 f0       	push   $0xf012afbc
f0115762:	68 53 06 00 00       	push   $0x653
f0115767:	68 42 97 12 f0       	push   $0xf0129742
f011576c:	e8 65 ad fe ff       	call   f01004d6 <_warn>
f0115771:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115774:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115778:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011577c:	74 04                	je     f0115782 <test_calculate_required_frames+0x2ef>
f011577e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115782:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115786:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115789:	89 d0                	mov    %edx,%eax
f011578b:	c1 e0 02             	shl    $0x2,%eax
f011578e:	01 d0                	add    %edx,%eax
f0115790:	01 c0                	add    %eax,%eax
f0115792:	83 ec 04             	sub    $0x4,%esp
f0115795:	50                   	push   %eax
f0115796:	68 00 00 40 00       	push   $0x400000
f011579b:	ff 75 d8             	pushl  -0x28(%ebp)
f011579e:	e8 54 56 ff ff       	call   f010adf7 <calculate_required_frames>
f01157a3:	83 c4 10             	add    $0x10,%esp
f01157a6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01157a9:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01157b0:	74 26                	je     f01157d8 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01157b2:	83 ec 0c             	sub    $0xc,%esp
f01157b5:	68 03 0a 00 00       	push   $0xa03
f01157ba:	ff 75 c8             	pushl  -0x38(%ebp)
f01157bd:	68 bc af 12 f0       	push   $0xf012afbc
f01157c2:	68 5d 06 00 00       	push   $0x65d
f01157c7:	68 42 97 12 f0       	push   $0xf0129742
f01157cc:	e8 05 ad fe ff       	call   f01004d6 <_warn>
f01157d1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157d4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01157d8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157dc:	74 04                	je     f01157e2 <test_calculate_required_frames+0x34f>
f01157de:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01157e2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01157e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157e9:	01 c0                	add    %eax,%eax
f01157eb:	83 ec 04             	sub    $0x4,%esp
f01157ee:	50                   	push   %eax
f01157ef:	68 00 00 70 00       	push   $0x700000
f01157f4:	ff 75 d8             	pushl  -0x28(%ebp)
f01157f7:	e8 fb 55 ff ff       	call   f010adf7 <calculate_required_frames>
f01157fc:	83 c4 10             	add    $0x10,%esp
f01157ff:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115802:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115809:	74 26                	je     f0115831 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f011580b:	83 ec 0c             	sub    $0xc,%esp
f011580e:	68 02 02 00 00       	push   $0x202
f0115813:	ff 75 c8             	pushl  -0x38(%ebp)
f0115816:	68 bc af 12 f0       	push   $0xf012afbc
f011581b:	68 69 06 00 00       	push   $0x669
f0115820:	68 42 97 12 f0       	push   $0xf0129742
f0115825:	e8 ac ac fe ff       	call   f01004d6 <_warn>
f011582a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011582d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115831:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115835:	74 04                	je     f011583b <test_calculate_required_frames+0x3a8>
f0115837:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011583b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f011583f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115842:	83 ec 04             	sub    $0x4,%esp
f0115845:	50                   	push   %eax
f0115846:	68 ff ff 3f 00       	push   $0x3fffff
f011584b:	ff 75 d8             	pushl  -0x28(%ebp)
f011584e:	e8 a4 55 ff ff       	call   f010adf7 <calculate_required_frames>
f0115853:	83 c4 10             	add    $0x10,%esp
f0115856:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115859:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f011585d:	74 23                	je     f0115882 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f011585f:	83 ec 0c             	sub    $0xc,%esp
f0115862:	6a 04                	push   $0x4
f0115864:	ff 75 c8             	pushl  -0x38(%ebp)
f0115867:	68 bc af 12 f0       	push   $0xf012afbc
f011586c:	68 73 06 00 00       	push   $0x673
f0115871:	68 42 97 12 f0       	push   $0xf0129742
f0115876:	e8 5b ac fe ff       	call   f01004d6 <_warn>
f011587b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011587e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115882:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115886:	74 04                	je     f011588c <test_calculate_required_frames+0x3f9>
f0115888:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011588c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115890:	83 ec 0c             	sub    $0xc,%esp
f0115893:	68 f5 aa 12 f0       	push   $0xf012aaf5
f0115898:	e8 ee b6 fe ff       	call   f0100f8b <cprintf>
f011589d:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01158a0:	83 ec 0c             	sub    $0xc,%esp
f01158a3:	68 14 b0 12 f0       	push   $0xf012b014
f01158a8:	e8 de b6 fe ff       	call   f0100f8b <cprintf>
f01158ad:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01158b0:	83 ec 04             	sub    $0x4,%esp
f01158b3:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01158b9:	50                   	push   %eax
f01158ba:	68 ae 9e 12 f0       	push   $0xf0129eae
f01158bf:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158c5:	50                   	push   %eax
f01158c6:	e8 60 ab 00 00       	call   f012042b <strcconcat>
f01158cb:	83 c4 10             	add    $0x10,%esp
f01158ce:	83 ec 0c             	sub    $0xc,%esp
f01158d1:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01158d7:	50                   	push   %eax
f01158d8:	e8 1e c6 fe ff       	call   f0101efb <execute_command>
f01158dd:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01158e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01158e3:	c1 e0 03             	shl    $0x3,%eax
f01158e6:	83 ec 04             	sub    $0x4,%esp
f01158e9:	50                   	push   %eax
f01158ea:	6a 00                	push   $0x0
f01158ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01158ef:	e8 03 55 ff ff       	call   f010adf7 <calculate_required_frames>
f01158f4:	83 c4 10             	add    $0x10,%esp
f01158f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01158fa:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115901:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115904:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115907:	74 24                	je     f011592d <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115909:	83 ec 0c             	sub    $0xc,%esp
f011590c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011590f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115912:	68 bc af 12 f0       	push   $0xf012afbc
f0115917:	68 87 06 00 00       	push   $0x687
f011591c:	68 42 97 12 f0       	push   $0xf0129742
f0115921:	e8 b0 ab fe ff       	call   f01004d6 <_warn>
f0115926:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115929:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011592d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115931:	74 04                	je     f0115937 <test_calculate_required_frames+0x4a4>
f0115933:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115937:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011593b:	83 ec 04             	sub    $0x4,%esp
f011593e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115944:	50                   	push   %eax
f0115945:	68 bb 9e 12 f0       	push   $0xf0129ebb
f011594a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115950:	50                   	push   %eax
f0115951:	e8 d5 aa 00 00       	call   f012042b <strcconcat>
f0115956:	83 c4 10             	add    $0x10,%esp
f0115959:	83 ec 0c             	sub    $0xc,%esp
f011595c:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115962:	50                   	push   %eax
f0115963:	e8 93 c5 fe ff       	call   f0101efb <execute_command>
f0115968:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011596b:	83 ec 04             	sub    $0x4,%esp
f011596e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115974:	50                   	push   %eax
f0115975:	68 48 b0 12 f0       	push   $0xf012b048
f011597a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115980:	50                   	push   %eax
f0115981:	e8 a5 aa 00 00       	call   f012042b <strcconcat>
f0115986:	83 c4 10             	add    $0x10,%esp
f0115989:	83 ec 0c             	sub    $0xc,%esp
f011598c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115992:	50                   	push   %eax
f0115993:	e8 63 c5 fe ff       	call   f0101efb <execute_command>
f0115998:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f011599b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011599e:	c1 e0 03             	shl    $0x3,%eax
f01159a1:	83 ec 04             	sub    $0x4,%esp
f01159a4:	50                   	push   %eax
f01159a5:	6a 00                	push   $0x0
f01159a7:	ff 75 d8             	pushl  -0x28(%ebp)
f01159aa:	e8 48 54 ff ff       	call   f010adf7 <calculate_required_frames>
f01159af:	83 c4 10             	add    $0x10,%esp
f01159b2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01159b5:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01159bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01159bf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01159c2:	74 24                	je     f01159e8 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01159c4:	83 ec 0c             	sub    $0xc,%esp
f01159c7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01159ca:	ff 75 c8             	pushl  -0x38(%ebp)
f01159cd:	68 bc af 12 f0       	push   $0xf012afbc
f01159d2:	68 95 06 00 00       	push   $0x695
f01159d7:	68 42 97 12 f0       	push   $0xf0129742
f01159dc:	e8 f5 aa fe ff       	call   f01004d6 <_warn>
f01159e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159e4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159e8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159ec:	74 04                	je     f01159f2 <test_calculate_required_frames+0x55f>
f01159ee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159f2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01159f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01159f9:	c1 e0 0a             	shl    $0xa,%eax
f01159fc:	83 ec 04             	sub    $0x4,%esp
f01159ff:	50                   	push   %eax
f0115a00:	6a 00                	push   $0x0
f0115a02:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a05:	e8 ed 53 ff ff       	call   f010adf7 <calculate_required_frames>
f0115a0a:	83 c4 10             	add    $0x10,%esp
f0115a0d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115a10:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a13:	c1 e0 0a             	shl    $0xa,%eax
f0115a16:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115a19:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115a20:	99                   	cltd   
f0115a21:	f7 fb                	idiv   %ebx
f0115a23:	89 c1                	mov    %eax,%ecx
f0115a25:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a28:	c1 e0 0a             	shl    $0xa,%eax
f0115a2b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115a2e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115a35:	99                   	cltd   
f0115a36:	f7 fe                	idiv   %esi
f0115a38:	01 c8                	add    %ecx,%eax
f0115a3a:	83 e8 05             	sub    $0x5,%eax
f0115a3d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115a40:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115a43:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a46:	74 24                	je     f0115a6c <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115a48:	83 ec 0c             	sub    $0xc,%esp
f0115a4b:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a4e:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a51:	68 bc af 12 f0       	push   $0xf012afbc
f0115a56:	68 a0 06 00 00       	push   $0x6a0
f0115a5b:	68 42 97 12 f0       	push   $0xf0129742
f0115a60:	e8 71 aa fe ff       	call   f01004d6 <_warn>
f0115a65:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a68:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a6c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a70:	74 04                	je     f0115a76 <test_calculate_required_frames+0x5e3>
f0115a72:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a76:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115a7a:	83 ec 04             	sub    $0x4,%esp
f0115a7d:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115a83:	50                   	push   %eax
f0115a84:	68 54 b0 12 f0       	push   $0xf012b054
f0115a89:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115a8f:	50                   	push   %eax
f0115a90:	e8 96 a9 00 00       	call   f012042b <strcconcat>
f0115a95:	83 c4 10             	add    $0x10,%esp
f0115a98:	83 ec 0c             	sub    $0xc,%esp
f0115a9b:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115aa1:	50                   	push   %eax
f0115aa2:	e8 54 c4 fe ff       	call   f0101efb <execute_command>
f0115aa7:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115aaa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115aad:	89 c2                	mov    %eax,%edx
f0115aaf:	01 d2                	add    %edx,%edx
f0115ab1:	01 d0                	add    %edx,%eax
f0115ab3:	83 ec 04             	sub    $0x4,%esp
f0115ab6:	50                   	push   %eax
f0115ab7:	68 00 18 00 00       	push   $0x1800
f0115abc:	ff 75 d8             	pushl  -0x28(%ebp)
f0115abf:	e8 33 53 ff ff       	call   f010adf7 <calculate_required_frames>
f0115ac4:	83 c4 10             	add    $0x10,%esp
f0115ac7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115aca:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115ad1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115ad4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115ad7:	74 24                	je     f0115afd <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115ad9:	83 ec 0c             	sub    $0xc,%esp
f0115adc:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115adf:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ae2:	68 bc af 12 f0       	push   $0xf012afbc
f0115ae7:	68 af 06 00 00       	push   $0x6af
f0115aec:	68 42 97 12 f0       	push   $0xf0129742
f0115af1:	e8 e0 a9 fe ff       	call   f01004d6 <_warn>
f0115af6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115af9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115afd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b01:	74 04                	je     f0115b07 <test_calculate_required_frames+0x674>
f0115b03:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b07:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115b0b:	83 ec 04             	sub    $0x4,%esp
f0115b0e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115b14:	50                   	push   %eax
f0115b15:	68 14 a1 12 f0       	push   $0xf012a114
f0115b1a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b20:	50                   	push   %eax
f0115b21:	e8 05 a9 00 00       	call   f012042b <strcconcat>
f0115b26:	83 c4 10             	add    $0x10,%esp
f0115b29:	83 ec 0c             	sub    $0xc,%esp
f0115b2c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115b32:	50                   	push   %eax
f0115b33:	e8 c3 c3 fe ff       	call   f0101efb <execute_command>
f0115b38:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115b3b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115b3e:	89 d0                	mov    %edx,%eax
f0115b40:	c1 e0 02             	shl    $0x2,%eax
f0115b43:	01 d0                	add    %edx,%eax
f0115b45:	01 c0                	add    %eax,%eax
f0115b47:	83 ec 04             	sub    $0x4,%esp
f0115b4a:	50                   	push   %eax
f0115b4b:	68 00 00 40 00       	push   $0x400000
f0115b50:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b53:	e8 9f 52 ff ff       	call   f010adf7 <calculate_required_frames>
f0115b58:	83 c4 10             	add    $0x10,%esp
f0115b5b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115b5e:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115b65:	74 26                	je     f0115b8d <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115b67:	83 ec 0c             	sub    $0xc,%esp
f0115b6a:	68 03 0a 00 00       	push   $0xa03
f0115b6f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b72:	68 bc af 12 f0       	push   $0xf012afbc
f0115b77:	68 bb 06 00 00       	push   $0x6bb
f0115b7c:	68 42 97 12 f0       	push   $0xf0129742
f0115b81:	e8 50 a9 fe ff       	call   f01004d6 <_warn>
f0115b86:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b89:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b8d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b91:	74 04                	je     f0115b97 <test_calculate_required_frames+0x704>
f0115b93:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b97:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115b9b:	83 ec 04             	sub    $0x4,%esp
f0115b9e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115ba4:	50                   	push   %eax
f0115ba5:	68 1e a1 12 f0       	push   $0xf012a11e
f0115baa:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bb0:	50                   	push   %eax
f0115bb1:	e8 75 a8 00 00       	call   f012042b <strcconcat>
f0115bb6:	83 c4 10             	add    $0x10,%esp
f0115bb9:	83 ec 0c             	sub    $0xc,%esp
f0115bbc:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115bc2:	50                   	push   %eax
f0115bc3:	e8 33 c3 fe ff       	call   f0101efb <execute_command>
f0115bc8:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115bcb:	83 ec 04             	sub    $0x4,%esp
f0115bce:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115bd4:	50                   	push   %eax
f0115bd5:	68 5c b0 12 f0       	push   $0xf012b05c
f0115bda:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115be0:	50                   	push   %eax
f0115be1:	e8 45 a8 00 00       	call   f012042b <strcconcat>
f0115be6:	83 c4 10             	add    $0x10,%esp
f0115be9:	83 ec 0c             	sub    $0xc,%esp
f0115bec:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115bf2:	50                   	push   %eax
f0115bf3:	e8 03 c3 fe ff       	call   f0101efb <execute_command>
f0115bf8:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115bfb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115bfe:	01 c0                	add    %eax,%eax
f0115c00:	83 ec 04             	sub    $0x4,%esp
f0115c03:	50                   	push   %eax
f0115c04:	68 00 00 70 00       	push   $0x700000
f0115c09:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c0c:	e8 e6 51 ff ff       	call   f010adf7 <calculate_required_frames>
f0115c11:	83 c4 10             	add    $0x10,%esp
f0115c14:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115c17:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115c1e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115c21:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c24:	74 24                	je     f0115c4a <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115c26:	83 ec 0c             	sub    $0xc,%esp
f0115c29:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c2c:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c2f:	68 bc af 12 f0       	push   $0xf012afbc
f0115c34:	68 cb 06 00 00       	push   $0x6cb
f0115c39:	68 42 97 12 f0       	push   $0xf0129742
f0115c3e:	e8 93 a8 fe ff       	call   f01004d6 <_warn>
f0115c43:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c46:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115c4a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c4e:	74 04                	je     f0115c54 <test_calculate_required_frames+0x7c1>
f0115c50:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115c54:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115c58:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c5b:	83 ec 04             	sub    $0x4,%esp
f0115c5e:	50                   	push   %eax
f0115c5f:	68 ff ff 3f 00       	push   $0x3fffff
f0115c64:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c67:	e8 8b 51 ff ff       	call   f010adf7 <calculate_required_frames>
f0115c6c:	83 c4 10             	add    $0x10,%esp
f0115c6f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115c72:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115c79:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115c7c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c7f:	74 24                	je     f0115ca5 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115c81:	83 ec 0c             	sub    $0xc,%esp
f0115c84:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c87:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c8a:	68 bc af 12 f0       	push   $0xf012afbc
f0115c8f:	68 d6 06 00 00       	push   $0x6d6
f0115c94:	68 42 97 12 f0       	push   $0xf0129742
f0115c99:	e8 38 a8 fe ff       	call   f01004d6 <_warn>
f0115c9e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ca1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115ca5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ca9:	74 04                	je     f0115caf <test_calculate_required_frames+0x81c>
f0115cab:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115caf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115cb3:	83 ec 0c             	sub    $0xc,%esp
f0115cb6:	68 cf a0 12 f0       	push   $0xf012a0cf
f0115cbb:	e8 cb b2 fe ff       	call   f0100f8b <cprintf>
f0115cc0:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115cc3:	83 ec 08             	sub    $0x8,%esp
f0115cc6:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115cc9:	68 68 b0 12 f0       	push   $0xf012b068
f0115cce:	e8 b8 b2 fe ff       	call   f0100f8b <cprintf>
f0115cd3:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115cd6:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115cda:	75 10                	jne    f0115cec <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115cdc:	83 ec 0c             	sub    $0xc,%esp
f0115cdf:	68 a8 b0 12 f0       	push   $0xf012b0a8
f0115ce4:	e8 a2 b2 fe ff       	call   f0100f8b <cprintf>
f0115ce9:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115cec:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0115cf1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115cf4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115cf7:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115cfa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115cff:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115d02:	5b                   	pop    %ebx
f0115d03:	5e                   	pop    %esi
f0115d04:	5f                   	pop    %edi
f0115d05:	5d                   	pop    %ebp
f0115d06:	c3                   	ret    

f0115d07 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115d07:	55                   	push   %ebp
f0115d08:	89 e5                	mov    %esp,%ebp
f0115d0a:	57                   	push   %edi
f0115d0b:	56                   	push   %esi
f0115d0c:	53                   	push   %ebx
f0115d0d:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115d13:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115d16:	bb 44 9e 12 f0       	mov    $0xf0129e44,%ebx
f0115d1b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115d20:	89 c7                	mov    %eax,%edi
f0115d22:	89 de                	mov    %ebx,%esi
f0115d24:	89 d1                	mov    %edx,%ecx
f0115d26:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115d28:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115d2b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115d30:	b0 00                	mov    $0x0,%al
f0115d32:	89 d7                	mov    %edx,%edi
f0115d34:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115d36:	6a 00                	push   $0x0
f0115d38:	6a 0a                	push   $0xa
f0115d3a:	6a 14                	push   $0x14
f0115d3c:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115d3f:	50                   	push   %eax
f0115d40:	e8 ad 54 ff ff       	call   f010b1f2 <env_create>
f0115d45:	83 c4 10             	add    $0x10,%esp
f0115d48:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115d4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115d4e:	8b 40 64             	mov    0x64(%eax),%eax
f0115d51:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115d54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115d57:	8b 40 68             	mov    0x68(%eax),%eax
f0115d5a:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115d5d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115d60:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115d63:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115d6a:	75 70 20 
f0115d6d:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115d74:	00 00 00 
f0115d77:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115d7a:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115d7f:	b8 00 00 00 00       	mov    $0x0,%eax
f0115d84:	89 d7                	mov    %edx,%edi
f0115d86:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115d88:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115d8b:	8b 40 10             	mov    0x10(%eax),%eax
f0115d8e:	83 ec 08             	sub    $0x8,%esp
f0115d91:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115d97:	52                   	push   %edx
f0115d98:	50                   	push   %eax
f0115d99:	e8 b4 a5 00 00       	call   f0120352 <ltostr>
f0115d9e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115da1:	83 ec 04             	sub    $0x4,%esp
f0115da4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115daa:	50                   	push   %eax
f0115dab:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115db1:	50                   	push   %eax
f0115db2:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115db8:	50                   	push   %eax
f0115db9:	e8 6d a6 00 00       	call   f012042b <strcconcat>
f0115dbe:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115dc1:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115dc8:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115dcf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115dd6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115dda:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115de1:	00 00 00 
	uint32 num_tables = 0;
f0115de4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115deb:	00 00 00 
	ClearUserSpace(proc_directory);
f0115dee:	83 ec 0c             	sub    $0xc,%esp
f0115df1:	ff 75 d8             	pushl  -0x28(%ebp)
f0115df4:	e8 8d 0e 00 00       	call   f0116c86 <ClearUserSpace>
f0115df9:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115dfc:	83 ec 0c             	sub    $0xc,%esp
f0115dff:	68 88 af 12 f0       	push   $0xf012af88
f0115e04:	e8 82 b1 fe ff       	call   f0100f8b <cprintf>
f0115e09:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115e0c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e0f:	c1 e0 03             	shl    $0x3,%eax
f0115e12:	89 c2                	mov    %eax,%edx
f0115e14:	83 ec 0c             	sub    $0xc,%esp
f0115e17:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e1d:	50                   	push   %eax
f0115e1e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e24:	50                   	push   %eax
f0115e25:	52                   	push   %edx
f0115e26:	6a 00                	push   $0x0
f0115e28:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e2b:	e8 ad 4f ff ff       	call   f010addd <calculate_allocated_space>
f0115e30:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e33:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e39:	85 c0                	test   %eax,%eax
f0115e3b:	74 27                	je     f0115e64 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e3d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e43:	83 ec 0c             	sub    $0xc,%esp
f0115e46:	6a 00                	push   $0x0
f0115e48:	50                   	push   %eax
f0115e49:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0115e4e:	68 0b 07 00 00       	push   $0x70b
f0115e53:	68 42 97 12 f0       	push   $0xf0129742
f0115e58:	e8 79 a6 fe ff       	call   f01004d6 <_warn>
f0115e5d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e60:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e64:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e6a:	85 c0                	test   %eax,%eax
f0115e6c:	74 27                	je     f0115e95 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115e6e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e74:	83 ec 0c             	sub    $0xc,%esp
f0115e77:	6a 00                	push   $0x0
f0115e79:	50                   	push   %eax
f0115e7a:	68 54 b1 12 f0       	push   $0xf012b154
f0115e7f:	68 10 07 00 00       	push   $0x710
f0115e84:	68 42 97 12 f0       	push   $0xf0129742
f0115e89:	e8 48 a6 fe ff       	call   f01004d6 <_warn>
f0115e8e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e91:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e95:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e99:	74 04                	je     f0115e9f <test_calculate_allocated_space+0x198>
f0115e9b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e9f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115ea3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115eaa:	00 00 00 
		num_pages = 0;
f0115ead:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115eb4:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115eb7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115eba:	c1 e0 02             	shl    $0x2,%eax
f0115ebd:	89 c2                	mov    %eax,%edx
f0115ebf:	83 ec 0c             	sub    $0xc,%esp
f0115ec2:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ec8:	50                   	push   %eax
f0115ec9:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ecf:	50                   	push   %eax
f0115ed0:	52                   	push   %edx
f0115ed1:	6a 00                	push   $0x0
f0115ed3:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ed6:	e8 02 4f ff ff       	call   f010addd <calculate_allocated_space>
f0115edb:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ede:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ee4:	85 c0                	test   %eax,%eax
f0115ee6:	74 27                	je     f0115f0f <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ee8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115eee:	83 ec 0c             	sub    $0xc,%esp
f0115ef1:	6a 00                	push   $0x0
f0115ef3:	50                   	push   %eax
f0115ef4:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0115ef9:	68 1c 07 00 00       	push   $0x71c
f0115efe:	68 42 97 12 f0       	push   $0xf0129742
f0115f03:	e8 ce a5 fe ff       	call   f01004d6 <_warn>
f0115f08:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f0b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115f0f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f15:	85 c0                	test   %eax,%eax
f0115f17:	74 27                	je     f0115f40 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f19:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f1f:	83 ec 0c             	sub    $0xc,%esp
f0115f22:	6a 00                	push   $0x0
f0115f24:	50                   	push   %eax
f0115f25:	68 54 b1 12 f0       	push   $0xf012b154
f0115f2a:	68 21 07 00 00       	push   $0x721
f0115f2f:	68 42 97 12 f0       	push   $0xf0129742
f0115f34:	e8 9d a5 fe ff       	call   f01004d6 <_warn>
f0115f39:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f3c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f40:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f44:	74 04                	je     f0115f4a <test_calculate_allocated_space+0x243>
f0115f46:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f4a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115f4e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f55:	00 00 00 
		num_pages = 0;
f0115f58:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f5f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115f62:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f65:	c1 e0 0a             	shl    $0xa,%eax
f0115f68:	89 c2                	mov    %eax,%edx
f0115f6a:	83 ec 0c             	sub    $0xc,%esp
f0115f6d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f73:	50                   	push   %eax
f0115f74:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f7a:	50                   	push   %eax
f0115f7b:	52                   	push   %edx
f0115f7c:	6a 00                	push   $0x0
f0115f7e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f81:	e8 57 4e ff ff       	call   f010addd <calculate_allocated_space>
f0115f86:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f89:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f8f:	85 c0                	test   %eax,%eax
f0115f91:	74 27                	je     f0115fba <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f93:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f99:	83 ec 0c             	sub    $0xc,%esp
f0115f9c:	6a 00                	push   $0x0
f0115f9e:	50                   	push   %eax
f0115f9f:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0115fa4:	68 2d 07 00 00       	push   $0x72d
f0115fa9:	68 42 97 12 f0       	push   $0xf0129742
f0115fae:	e8 23 a5 fe ff       	call   f01004d6 <_warn>
f0115fb3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fb6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115fba:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fc0:	85 c0                	test   %eax,%eax
f0115fc2:	74 27                	je     f0115feb <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115fc4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fca:	83 ec 0c             	sub    $0xc,%esp
f0115fcd:	6a 00                	push   $0x0
f0115fcf:	50                   	push   %eax
f0115fd0:	68 54 b1 12 f0       	push   $0xf012b154
f0115fd5:	68 32 07 00 00       	push   $0x732
f0115fda:	68 42 97 12 f0       	push   $0xf0129742
f0115fdf:	e8 f2 a4 fe ff       	call   f01004d6 <_warn>
f0115fe4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fe7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115feb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fef:	74 04                	je     f0115ff5 <test_calculate_allocated_space+0x2ee>
f0115ff1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ff5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115ff9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116000:	00 00 00 
		num_pages = 0;
f0116003:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011600a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f011600d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116010:	89 d0                	mov    %edx,%eax
f0116012:	01 c0                	add    %eax,%eax
f0116014:	01 d0                	add    %edx,%eax
f0116016:	01 c0                	add    %eax,%eax
f0116018:	05 00 10 00 00       	add    $0x1000,%eax
f011601d:	89 c2                	mov    %eax,%edx
f011601f:	83 ec 0c             	sub    $0xc,%esp
f0116022:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116028:	50                   	push   %eax
f0116029:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011602f:	50                   	push   %eax
f0116030:	52                   	push   %edx
f0116031:	68 00 10 00 00       	push   $0x1000
f0116036:	ff 75 d8             	pushl  -0x28(%ebp)
f0116039:	e8 9f 4d ff ff       	call   f010addd <calculate_allocated_space>
f011603e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116041:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116047:	85 c0                	test   %eax,%eax
f0116049:	74 27                	je     f0116072 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011604b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116051:	83 ec 0c             	sub    $0xc,%esp
f0116054:	6a 00                	push   $0x0
f0116056:	50                   	push   %eax
f0116057:	68 f4 b0 12 f0       	push   $0xf012b0f4
f011605c:	68 3f 07 00 00       	push   $0x73f
f0116061:	68 42 97 12 f0       	push   $0xf0129742
f0116066:	e8 6b a4 fe ff       	call   f01004d6 <_warn>
f011606b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011606e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116072:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116078:	85 c0                	test   %eax,%eax
f011607a:	74 27                	je     f01160a3 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011607c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116082:	83 ec 0c             	sub    $0xc,%esp
f0116085:	6a 00                	push   $0x0
f0116087:	50                   	push   %eax
f0116088:	68 54 b1 12 f0       	push   $0xf012b154
f011608d:	68 44 07 00 00       	push   $0x744
f0116092:	68 42 97 12 f0       	push   $0xf0129742
f0116097:	e8 3a a4 fe ff       	call   f01004d6 <_warn>
f011609c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011609f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160a3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160a7:	74 04                	je     f01160ad <test_calculate_allocated_space+0x3a6>
f01160a9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160ad:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f01160b1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160b8:	00 00 00 
		num_pages = 0;
f01160bb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160c2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01160c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160c8:	89 c2                	mov    %eax,%edx
f01160ca:	01 d2                	add    %edx,%edx
f01160cc:	01 d0                	add    %edx,%eax
f01160ce:	05 00 18 00 00       	add    $0x1800,%eax
f01160d3:	89 c2                	mov    %eax,%edx
f01160d5:	83 ec 0c             	sub    $0xc,%esp
f01160d8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160de:	50                   	push   %eax
f01160df:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160e5:	50                   	push   %eax
f01160e6:	52                   	push   %edx
f01160e7:	68 00 18 00 00       	push   $0x1800
f01160ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ef:	e8 e9 4c ff ff       	call   f010addd <calculate_allocated_space>
f01160f4:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160f7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160fd:	85 c0                	test   %eax,%eax
f01160ff:	74 27                	je     f0116128 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116101:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116107:	83 ec 0c             	sub    $0xc,%esp
f011610a:	6a 00                	push   $0x0
f011610c:	50                   	push   %eax
f011610d:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116112:	68 50 07 00 00       	push   $0x750
f0116117:	68 42 97 12 f0       	push   $0xf0129742
f011611c:	e8 b5 a3 fe ff       	call   f01004d6 <_warn>
f0116121:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116124:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116128:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011612e:	85 c0                	test   %eax,%eax
f0116130:	74 27                	je     f0116159 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116132:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116138:	83 ec 0c             	sub    $0xc,%esp
f011613b:	6a 00                	push   $0x0
f011613d:	50                   	push   %eax
f011613e:	68 54 b1 12 f0       	push   $0xf012b154
f0116143:	68 55 07 00 00       	push   $0x755
f0116148:	68 42 97 12 f0       	push   $0xf0129742
f011614d:	e8 84 a3 fe ff       	call   f01004d6 <_warn>
f0116152:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116155:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116159:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011615d:	74 04                	je     f0116163 <test_calculate_allocated_space+0x45c>
f011615f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116163:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0116167:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011616e:	00 00 00 
		num_pages = 0;
f0116171:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116178:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f011617b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011617e:	89 d0                	mov    %edx,%eax
f0116180:	c1 e0 02             	shl    $0x2,%eax
f0116183:	01 d0                	add    %edx,%eax
f0116185:	01 c0                	add    %eax,%eax
f0116187:	05 00 00 40 00       	add    $0x400000,%eax
f011618c:	89 c2                	mov    %eax,%edx
f011618e:	83 ec 0c             	sub    $0xc,%esp
f0116191:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116197:	50                   	push   %eax
f0116198:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011619e:	50                   	push   %eax
f011619f:	52                   	push   %edx
f01161a0:	68 00 00 40 00       	push   $0x400000
f01161a5:	ff 75 d8             	pushl  -0x28(%ebp)
f01161a8:	e8 30 4c ff ff       	call   f010addd <calculate_allocated_space>
f01161ad:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01161b0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161b6:	85 c0                	test   %eax,%eax
f01161b8:	74 27                	je     f01161e1 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161ba:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161c0:	83 ec 0c             	sub    $0xc,%esp
f01161c3:	6a 00                	push   $0x0
f01161c5:	50                   	push   %eax
f01161c6:	68 f4 b0 12 f0       	push   $0xf012b0f4
f01161cb:	68 61 07 00 00       	push   $0x761
f01161d0:	68 42 97 12 f0       	push   $0xf0129742
f01161d5:	e8 fc a2 fe ff       	call   f01004d6 <_warn>
f01161da:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161dd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01161e1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161e7:	85 c0                	test   %eax,%eax
f01161e9:	74 27                	je     f0116212 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01161eb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161f1:	83 ec 0c             	sub    $0xc,%esp
f01161f4:	6a 00                	push   $0x0
f01161f6:	50                   	push   %eax
f01161f7:	68 54 b1 12 f0       	push   $0xf012b154
f01161fc:	68 66 07 00 00       	push   $0x766
f0116201:	68 42 97 12 f0       	push   $0xf0129742
f0116206:	e8 cb a2 fe ff       	call   f01004d6 <_warn>
f011620b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011620e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116212:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116216:	74 04                	je     f011621c <test_calculate_allocated_space+0x515>
f0116218:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011621c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0116220:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116227:	00 00 00 
		num_pages = 0;
f011622a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116231:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116234:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116237:	05 00 00 38 00       	add    $0x380000,%eax
f011623c:	01 c0                	add    %eax,%eax
f011623e:	89 c2                	mov    %eax,%edx
f0116240:	83 ec 0c             	sub    $0xc,%esp
f0116243:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116249:	50                   	push   %eax
f011624a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116250:	50                   	push   %eax
f0116251:	52                   	push   %edx
f0116252:	68 00 00 70 00       	push   $0x700000
f0116257:	ff 75 d8             	pushl  -0x28(%ebp)
f011625a:	e8 7e 4b ff ff       	call   f010addd <calculate_allocated_space>
f011625f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116262:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116268:	85 c0                	test   %eax,%eax
f011626a:	74 27                	je     f0116293 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011626c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116272:	83 ec 0c             	sub    $0xc,%esp
f0116275:	6a 00                	push   $0x0
f0116277:	50                   	push   %eax
f0116278:	68 f4 b0 12 f0       	push   $0xf012b0f4
f011627d:	68 73 07 00 00       	push   $0x773
f0116282:	68 42 97 12 f0       	push   $0xf0129742
f0116287:	e8 4a a2 fe ff       	call   f01004d6 <_warn>
f011628c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011628f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116293:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116299:	85 c0                	test   %eax,%eax
f011629b:	74 27                	je     f01162c4 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011629d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162a3:	83 ec 0c             	sub    $0xc,%esp
f01162a6:	6a 00                	push   $0x0
f01162a8:	50                   	push   %eax
f01162a9:	68 54 b1 12 f0       	push   $0xf012b154
f01162ae:	68 78 07 00 00       	push   $0x778
f01162b3:	68 42 97 12 f0       	push   $0xf0129742
f01162b8:	e8 19 a2 fe ff       	call   f01004d6 <_warn>
f01162bd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162c0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01162c4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162c8:	74 04                	je     f01162ce <test_calculate_allocated_space+0x5c7>
f01162ca:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01162ce:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f01162d2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162d9:	00 00 00 
		num_pages = 0;
f01162dc:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162e3:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01162e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01162e9:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01162ee:	89 c2                	mov    %eax,%edx
f01162f0:	83 ec 0c             	sub    $0xc,%esp
f01162f3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162f9:	50                   	push   %eax
f01162fa:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116300:	50                   	push   %eax
f0116301:	52                   	push   %edx
f0116302:	68 ff ff 3f 00       	push   $0x3fffff
f0116307:	ff 75 d8             	pushl  -0x28(%ebp)
f011630a:	e8 ce 4a ff ff       	call   f010addd <calculate_allocated_space>
f011630f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116312:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116318:	85 c0                	test   %eax,%eax
f011631a:	74 27                	je     f0116343 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011631c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116322:	83 ec 0c             	sub    $0xc,%esp
f0116325:	6a 00                	push   $0x0
f0116327:	50                   	push   %eax
f0116328:	68 f4 b0 12 f0       	push   $0xf012b0f4
f011632d:	68 84 07 00 00       	push   $0x784
f0116332:	68 42 97 12 f0       	push   $0xf0129742
f0116337:	e8 9a a1 fe ff       	call   f01004d6 <_warn>
f011633c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011633f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116343:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116349:	85 c0                	test   %eax,%eax
f011634b:	74 27                	je     f0116374 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011634d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116353:	83 ec 0c             	sub    $0xc,%esp
f0116356:	6a 00                	push   $0x0
f0116358:	50                   	push   %eax
f0116359:	68 54 b1 12 f0       	push   $0xf012b154
f011635e:	68 89 07 00 00       	push   $0x789
f0116363:	68 42 97 12 f0       	push   $0xf0129742
f0116368:	e8 69 a1 fe ff       	call   f01004d6 <_warn>
f011636d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116370:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116374:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116378:	74 04                	je     f011637e <test_calculate_allocated_space+0x677>
f011637a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011637e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116382:	83 ec 0c             	sub    $0xc,%esp
f0116385:	68 f5 aa 12 f0       	push   $0xf012aaf5
f011638a:	e8 fc ab fe ff       	call   f0100f8b <cprintf>
f011638f:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116392:	83 ec 0c             	sub    $0xc,%esp
f0116395:	68 14 b0 12 f0       	push   $0xf012b014
f011639a:	e8 ec ab fe ff       	call   f0100f8b <cprintf>
f011639f:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01163a2:	83 ec 04             	sub    $0x4,%esp
f01163a5:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01163ab:	50                   	push   %eax
f01163ac:	68 ae 9e 12 f0       	push   $0xf0129eae
f01163b1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01163b7:	50                   	push   %eax
f01163b8:	e8 6e a0 00 00       	call   f012042b <strcconcat>
f01163bd:	83 c4 10             	add    $0x10,%esp
f01163c0:	83 ec 0c             	sub    $0xc,%esp
f01163c3:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01163c9:	50                   	push   %eax
f01163ca:	e8 2c bb fe ff       	call   f0101efb <execute_command>
f01163cf:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f01163d2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01163d9:	00 00 00 
		num_pages = 0;
f01163dc:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163e3:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01163e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01163e9:	c1 e0 03             	shl    $0x3,%eax
f01163ec:	89 c2                	mov    %eax,%edx
f01163ee:	83 ec 0c             	sub    $0xc,%esp
f01163f1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163f7:	50                   	push   %eax
f01163f8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163fe:	50                   	push   %eax
f01163ff:	52                   	push   %edx
f0116400:	6a 00                	push   $0x0
f0116402:	ff 75 d8             	pushl  -0x28(%ebp)
f0116405:	e8 d3 49 ff ff       	call   f010addd <calculate_allocated_space>
f011640a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011640d:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0116414:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011641b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116421:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116424:	74 28                	je     f011644e <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116426:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011642c:	83 ec 0c             	sub    $0xc,%esp
f011642f:	ff 75 c8             	pushl  -0x38(%ebp)
f0116432:	50                   	push   %eax
f0116433:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116438:	68 a0 07 00 00       	push   $0x7a0
f011643d:	68 42 97 12 f0       	push   $0xf0129742
f0116442:	e8 8f a0 fe ff       	call   f01004d6 <_warn>
f0116447:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011644a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011644e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116454:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116457:	74 28                	je     f0116481 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116459:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011645f:	83 ec 0c             	sub    $0xc,%esp
f0116462:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116465:	50                   	push   %eax
f0116466:	68 54 b1 12 f0       	push   $0xf012b154
f011646b:	68 a5 07 00 00       	push   $0x7a5
f0116470:	68 42 97 12 f0       	push   $0xf0129742
f0116475:	e8 5c a0 fe ff       	call   f01004d6 <_warn>
f011647a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011647d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116481:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116485:	74 04                	je     f011648b <test_calculate_allocated_space+0x784>
f0116487:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011648b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011648f:	83 ec 04             	sub    $0x4,%esp
f0116492:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116498:	50                   	push   %eax
f0116499:	68 bb 9e 12 f0       	push   $0xf0129ebb
f011649e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164a4:	50                   	push   %eax
f01164a5:	e8 81 9f 00 00       	call   f012042b <strcconcat>
f01164aa:	83 c4 10             	add    $0x10,%esp
f01164ad:	83 ec 0c             	sub    $0xc,%esp
f01164b0:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01164b6:	50                   	push   %eax
f01164b7:	e8 3f ba fe ff       	call   f0101efb <execute_command>
f01164bc:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01164bf:	83 ec 04             	sub    $0x4,%esp
f01164c2:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01164c8:	50                   	push   %eax
f01164c9:	68 48 b0 12 f0       	push   $0xf012b048
f01164ce:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164d4:	50                   	push   %eax
f01164d5:	e8 51 9f 00 00       	call   f012042b <strcconcat>
f01164da:	83 c4 10             	add    $0x10,%esp
f01164dd:	83 ec 0c             	sub    $0xc,%esp
f01164e0:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01164e6:	50                   	push   %eax
f01164e7:	e8 0f ba fe ff       	call   f0101efb <execute_command>
f01164ec:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01164ef:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164f6:	00 00 00 
		num_pages = 0;
f01164f9:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116500:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0116503:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116506:	c1 e0 03             	shl    $0x3,%eax
f0116509:	89 c2                	mov    %eax,%edx
f011650b:	83 ec 0c             	sub    $0xc,%esp
f011650e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116514:	50                   	push   %eax
f0116515:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011651b:	50                   	push   %eax
f011651c:	52                   	push   %edx
f011651d:	6a 00                	push   $0x0
f011651f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116522:	e8 b6 48 ff ff       	call   f010addd <calculate_allocated_space>
f0116527:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011652a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0116531:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116538:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011653e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116541:	74 28                	je     f011656b <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116543:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116549:	83 ec 0c             	sub    $0xc,%esp
f011654c:	ff 75 c8             	pushl  -0x38(%ebp)
f011654f:	50                   	push   %eax
f0116550:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116555:	68 b6 07 00 00       	push   $0x7b6
f011655a:	68 42 97 12 f0       	push   $0xf0129742
f011655f:	e8 72 9f fe ff       	call   f01004d6 <_warn>
f0116564:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116567:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011656b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116571:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116574:	74 28                	je     f011659e <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116576:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011657c:	83 ec 0c             	sub    $0xc,%esp
f011657f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116582:	50                   	push   %eax
f0116583:	68 54 b1 12 f0       	push   $0xf012b154
f0116588:	68 bb 07 00 00       	push   $0x7bb
f011658d:	68 42 97 12 f0       	push   $0xf0129742
f0116592:	e8 3f 9f fe ff       	call   f01004d6 <_warn>
f0116597:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011659a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011659e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165a2:	74 04                	je     f01165a8 <test_calculate_allocated_space+0x8a1>
f01165a4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01165a8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01165ac:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01165b3:	00 00 00 
		num_pages = 0;
f01165b6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01165bd:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01165c0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01165c3:	c1 e0 0a             	shl    $0xa,%eax
f01165c6:	89 c2                	mov    %eax,%edx
f01165c8:	83 ec 0c             	sub    $0xc,%esp
f01165cb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01165d1:	50                   	push   %eax
f01165d2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01165d8:	50                   	push   %eax
f01165d9:	52                   	push   %edx
f01165da:	6a 00                	push   $0x0
f01165dc:	ff 75 d8             	pushl  -0x28(%ebp)
f01165df:	e8 f9 47 ff ff       	call   f010addd <calculate_allocated_space>
f01165e4:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f01165e7:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01165ee:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01165f5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165fb:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01165fe:	74 28                	je     f0116628 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116600:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116606:	83 ec 0c             	sub    $0xc,%esp
f0116609:	ff 75 c8             	pushl  -0x38(%ebp)
f011660c:	50                   	push   %eax
f011660d:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116612:	68 c9 07 00 00       	push   $0x7c9
f0116617:	68 42 97 12 f0       	push   $0xf0129742
f011661c:	e8 b5 9e fe ff       	call   f01004d6 <_warn>
f0116621:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116624:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116628:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011662e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116631:	74 28                	je     f011665b <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116633:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116639:	83 ec 0c             	sub    $0xc,%esp
f011663c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011663f:	50                   	push   %eax
f0116640:	68 54 b1 12 f0       	push   $0xf012b154
f0116645:	68 ce 07 00 00       	push   $0x7ce
f011664a:	68 42 97 12 f0       	push   $0xf0129742
f011664f:	e8 82 9e fe ff       	call   f01004d6 <_warn>
f0116654:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116657:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011665b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011665f:	74 04                	je     f0116665 <test_calculate_allocated_space+0x95e>
f0116661:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116665:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116669:	83 ec 04             	sub    $0x4,%esp
f011666c:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116672:	50                   	push   %eax
f0116673:	68 54 b0 12 f0       	push   $0xf012b054
f0116678:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011667e:	50                   	push   %eax
f011667f:	e8 a7 9d 00 00       	call   f012042b <strcconcat>
f0116684:	83 c4 10             	add    $0x10,%esp
f0116687:	83 ec 0c             	sub    $0xc,%esp
f011668a:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116690:	50                   	push   %eax
f0116691:	e8 65 b8 fe ff       	call   f0101efb <execute_command>
f0116696:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116699:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01166a0:	00 00 00 
		num_pages = 0;
f01166a3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01166aa:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01166ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01166b0:	89 c2                	mov    %eax,%edx
f01166b2:	01 d2                	add    %edx,%edx
f01166b4:	01 d0                	add    %edx,%eax
f01166b6:	05 00 18 00 00       	add    $0x1800,%eax
f01166bb:	89 c2                	mov    %eax,%edx
f01166bd:	83 ec 0c             	sub    $0xc,%esp
f01166c0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166c6:	50                   	push   %eax
f01166c7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166cd:	50                   	push   %eax
f01166ce:	52                   	push   %edx
f01166cf:	68 00 18 00 00       	push   $0x1800
f01166d4:	ff 75 d8             	pushl  -0x28(%ebp)
f01166d7:	e8 01 47 ff ff       	call   f010addd <calculate_allocated_space>
f01166dc:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01166df:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01166e6:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166ed:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166f3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166f6:	74 28                	je     f0116720 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166f8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166fe:	83 ec 0c             	sub    $0xc,%esp
f0116701:	ff 75 c8             	pushl  -0x38(%ebp)
f0116704:	50                   	push   %eax
f0116705:	68 f4 b0 12 f0       	push   $0xf012b0f4
f011670a:	68 df 07 00 00       	push   $0x7df
f011670f:	68 42 97 12 f0       	push   $0xf0129742
f0116714:	e8 bd 9d fe ff       	call   f01004d6 <_warn>
f0116719:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011671c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116720:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116726:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116729:	74 28                	je     f0116753 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011672b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116731:	83 ec 0c             	sub    $0xc,%esp
f0116734:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116737:	50                   	push   %eax
f0116738:	68 54 b1 12 f0       	push   $0xf012b154
f011673d:	68 e4 07 00 00       	push   $0x7e4
f0116742:	68 42 97 12 f0       	push   $0xf0129742
f0116747:	e8 8a 9d fe ff       	call   f01004d6 <_warn>
f011674c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011674f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116753:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116757:	74 04                	je     f011675d <test_calculate_allocated_space+0xa56>
f0116759:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011675d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116761:	83 ec 04             	sub    $0x4,%esp
f0116764:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011676a:	50                   	push   %eax
f011676b:	68 14 a1 12 f0       	push   $0xf012a114
f0116770:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116776:	50                   	push   %eax
f0116777:	e8 af 9c 00 00       	call   f012042b <strcconcat>
f011677c:	83 c4 10             	add    $0x10,%esp
f011677f:	83 ec 0c             	sub    $0xc,%esp
f0116782:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116788:	50                   	push   %eax
f0116789:	e8 6d b7 fe ff       	call   f0101efb <execute_command>
f011678e:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116791:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116798:	00 00 00 
		num_pages = 0;
f011679b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01167a2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01167a5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01167a8:	89 d0                	mov    %edx,%eax
f01167aa:	c1 e0 02             	shl    $0x2,%eax
f01167ad:	01 d0                	add    %edx,%eax
f01167af:	01 c0                	add    %eax,%eax
f01167b1:	05 00 00 40 00       	add    $0x400000,%eax
f01167b6:	89 c2                	mov    %eax,%edx
f01167b8:	83 ec 0c             	sub    $0xc,%esp
f01167bb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167c1:	50                   	push   %eax
f01167c2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167c8:	50                   	push   %eax
f01167c9:	52                   	push   %edx
f01167ca:	68 00 00 40 00       	push   $0x400000
f01167cf:	ff 75 d8             	pushl  -0x28(%ebp)
f01167d2:	e8 06 46 ff ff       	call   f010addd <calculate_allocated_space>
f01167d7:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01167da:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01167e1:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167e8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167ee:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167f1:	74 28                	je     f011681b <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167f3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167f9:	83 ec 0c             	sub    $0xc,%esp
f01167fc:	ff 75 c8             	pushl  -0x38(%ebp)
f01167ff:	50                   	push   %eax
f0116800:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116805:	68 f4 07 00 00       	push   $0x7f4
f011680a:	68 42 97 12 f0       	push   $0xf0129742
f011680f:	e8 c2 9c fe ff       	call   f01004d6 <_warn>
f0116814:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116817:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011681b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116821:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116824:	74 28                	je     f011684e <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116826:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011682c:	83 ec 0c             	sub    $0xc,%esp
f011682f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116832:	50                   	push   %eax
f0116833:	68 54 b1 12 f0       	push   $0xf012b154
f0116838:	68 f9 07 00 00       	push   $0x7f9
f011683d:	68 42 97 12 f0       	push   $0xf0129742
f0116842:	e8 8f 9c fe ff       	call   f01004d6 <_warn>
f0116847:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011684a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011684e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116852:	74 04                	je     f0116858 <test_calculate_allocated_space+0xb51>
f0116854:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116858:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011685c:	83 ec 04             	sub    $0x4,%esp
f011685f:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116865:	50                   	push   %eax
f0116866:	68 1e a1 12 f0       	push   $0xf012a11e
f011686b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116871:	50                   	push   %eax
f0116872:	e8 b4 9b 00 00       	call   f012042b <strcconcat>
f0116877:	83 c4 10             	add    $0x10,%esp
f011687a:	83 ec 0c             	sub    $0xc,%esp
f011687d:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116883:	50                   	push   %eax
f0116884:	e8 72 b6 fe ff       	call   f0101efb <execute_command>
f0116889:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011688c:	83 ec 04             	sub    $0x4,%esp
f011688f:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116895:	50                   	push   %eax
f0116896:	68 5c b0 12 f0       	push   $0xf012b05c
f011689b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01168a1:	50                   	push   %eax
f01168a2:	e8 84 9b 00 00       	call   f012042b <strcconcat>
f01168a7:	83 c4 10             	add    $0x10,%esp
f01168aa:	83 ec 0c             	sub    $0xc,%esp
f01168ad:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01168b3:	50                   	push   %eax
f01168b4:	e8 42 b6 fe ff       	call   f0101efb <execute_command>
f01168b9:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f01168bc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01168c3:	00 00 00 
		num_pages = 0;
f01168c6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01168cd:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01168d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01168d3:	05 00 00 38 00       	add    $0x380000,%eax
f01168d8:	01 c0                	add    %eax,%eax
f01168da:	89 c2                	mov    %eax,%edx
f01168dc:	83 ec 0c             	sub    $0xc,%esp
f01168df:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01168e5:	50                   	push   %eax
f01168e6:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01168ec:	50                   	push   %eax
f01168ed:	52                   	push   %edx
f01168ee:	68 00 00 70 00       	push   $0x700000
f01168f3:	ff 75 d8             	pushl  -0x28(%ebp)
f01168f6:	e8 e2 44 ff ff       	call   f010addd <calculate_allocated_space>
f01168fb:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01168fe:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116905:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011690c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116912:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116915:	74 28                	je     f011693f <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116917:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011691d:	83 ec 0c             	sub    $0xc,%esp
f0116920:	ff 75 c8             	pushl  -0x38(%ebp)
f0116923:	50                   	push   %eax
f0116924:	68 f4 b0 12 f0       	push   $0xf012b0f4
f0116929:	68 0b 08 00 00       	push   $0x80b
f011692e:	68 42 97 12 f0       	push   $0xf0129742
f0116933:	e8 9e 9b fe ff       	call   f01004d6 <_warn>
f0116938:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011693b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011693f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116945:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116948:	74 28                	je     f0116972 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011694a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116950:	83 ec 0c             	sub    $0xc,%esp
f0116953:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116956:	50                   	push   %eax
f0116957:	68 54 b1 12 f0       	push   $0xf012b154
f011695c:	68 10 08 00 00       	push   $0x810
f0116961:	68 42 97 12 f0       	push   $0xf0129742
f0116966:	e8 6b 9b fe ff       	call   f01004d6 <_warn>
f011696b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011696e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116972:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116976:	74 04                	je     f011697c <test_calculate_allocated_space+0xc75>
f0116978:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011697c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116980:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116987:	00 00 00 
		num_pages = 0;
f011698a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116991:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116994:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116997:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011699c:	89 c2                	mov    %eax,%edx
f011699e:	83 ec 0c             	sub    $0xc,%esp
f01169a1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01169a7:	50                   	push   %eax
f01169a8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01169ae:	50                   	push   %eax
f01169af:	52                   	push   %edx
f01169b0:	68 ff ff 3f 00       	push   $0x3fffff
f01169b5:	ff 75 d8             	pushl  -0x28(%ebp)
f01169b8:	e8 20 44 ff ff       	call   f010addd <calculate_allocated_space>
f01169bd:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01169c0:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01169c7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01169ce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169d4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01169d7:	74 28                	je     f0116a01 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01169d9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169df:	83 ec 0c             	sub    $0xc,%esp
f01169e2:	ff 75 c8             	pushl  -0x38(%ebp)
f01169e5:	50                   	push   %eax
f01169e6:	68 f4 b0 12 f0       	push   $0xf012b0f4
f01169eb:	68 1e 08 00 00       	push   $0x81e
f01169f0:	68 42 97 12 f0       	push   $0xf0129742
f01169f5:	e8 dc 9a fe ff       	call   f01004d6 <_warn>
f01169fa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169fd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116a01:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116a07:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116a0a:	74 28                	je     f0116a34 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116a0c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116a12:	83 ec 0c             	sub    $0xc,%esp
f0116a15:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116a18:	50                   	push   %eax
f0116a19:	68 54 b1 12 f0       	push   $0xf012b154
f0116a1e:	68 23 08 00 00       	push   $0x823
f0116a23:	68 42 97 12 f0       	push   $0xf0129742
f0116a28:	e8 a9 9a fe ff       	call   f01004d6 <_warn>
f0116a2d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a30:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116a34:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a38:	74 04                	je     f0116a3e <test_calculate_allocated_space+0xd37>
f0116a3a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116a3e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116a42:	83 ec 0c             	sub    $0xc,%esp
f0116a45:	68 cf a0 12 f0       	push   $0xf012a0cf
f0116a4a:	e8 3c a5 fe ff       	call   f0100f8b <cprintf>
f0116a4f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116a52:	83 ec 08             	sub    $0x8,%esp
f0116a55:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116a58:	68 b0 b1 12 f0       	push   $0xf012b1b0
f0116a5d:	e8 29 a5 fe ff       	call   f0100f8b <cprintf>
f0116a62:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116a65:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116a69:	75 10                	jne    f0116a7b <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116a6b:	83 ec 0c             	sub    $0xc,%esp
f0116a6e:	68 f0 b1 12 f0       	push   $0xf012b1f0
f0116a73:	e8 13 a5 fe ff       	call   f0100f8b <cprintf>
f0116a78:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116a7b:	a1 84 f8 f1 f0       	mov    0xf0f1f884,%eax
f0116a80:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116a83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116a86:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116a89:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116a8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116a91:	5b                   	pop    %ebx
f0116a92:	5e                   	pop    %esi
f0116a93:	5f                   	pop    %edi
f0116a94:	5d                   	pop    %ebp
f0116a95:	c3                   	ret    

f0116a96 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116a96:	55                   	push   %ebp
f0116a97:	89 e5                	mov    %esp,%ebp
f0116a99:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116a9c:	8b 45 10             	mov    0x10(%ebp),%eax
f0116a9f:	ba 01 00 00 00       	mov    $0x1,%edx
f0116aa4:	88 c1                	mov    %al,%cl
f0116aa6:	d3 e2                	shl    %cl,%edx
f0116aa8:	89 d0                	mov    %edx,%eax
f0116aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116aad:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116ab0:	c1 e8 16             	shr    $0x16,%eax
f0116ab3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116aba:	8b 45 08             	mov    0x8(%ebp),%eax
f0116abd:	01 d0                	add    %edx,%eax
f0116abf:	8b 00                	mov    (%eax),%eax
f0116ac1:	83 e0 01             	and    $0x1,%eax
f0116ac4:	85 c0                	test   %eax,%eax
f0116ac6:	75 07                	jne    f0116acf <CB+0x39>
f0116ac8:	b8 00 00 00 00       	mov    $0x0,%eax
f0116acd:	eb 76                	jmp    f0116b45 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116acf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116ad2:	c1 e8 16             	shr    $0x16,%eax
f0116ad5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116adc:	8b 45 08             	mov    0x8(%ebp),%eax
f0116adf:	01 d0                	add    %edx,%eax
f0116ae1:	8b 00                	mov    (%eax),%eax
f0116ae3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116ae8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116aee:	c1 e8 0c             	shr    $0xc,%eax
f0116af1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116af4:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0116af9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116afc:	72 17                	jb     f0116b15 <CB+0x7f>
f0116afe:	ff 75 f0             	pushl  -0x10(%ebp)
f0116b01:	68 3c b2 12 f0       	push   $0xf012b23c
f0116b06:	68 3e 08 00 00       	push   $0x83e
f0116b0b:	68 42 97 12 f0       	push   $0xf0129742
f0116b10:	e8 24 98 fe ff       	call   f0100339 <_panic>
f0116b15:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116b18:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116b1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116b20:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116b23:	c1 e8 0c             	shr    $0xc,%eax
f0116b26:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116b2b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116b35:	01 d0                	add    %edx,%eax
f0116b37:	8b 00                	mov    (%eax),%eax
f0116b39:	23 45 f4             	and    -0xc(%ebp),%eax
f0116b3c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116b3f:	0f 94 c0             	sete   %al
f0116b42:	0f b6 c0             	movzbl %al,%eax
}
f0116b45:	c9                   	leave  
f0116b46:	c3                   	ret    

f0116b47 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116b47:	55                   	push   %ebp
f0116b48:	89 e5                	mov    %esp,%ebp
f0116b4a:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116b4d:	68 6b b2 12 f0       	push   $0xf012b26b
f0116b52:	68 7a b2 12 f0       	push   $0xf012b27a
f0116b57:	68 43 08 00 00       	push   $0x843
f0116b5c:	68 42 97 12 f0       	push   $0xf0129742
f0116b61:	e8 d3 97 fe ff       	call   f0100339 <_panic>

f0116b66 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116b66:	55                   	push   %ebp
f0116b67:	89 e5                	mov    %esp,%ebp
f0116b69:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116b6c:	68 6b b2 12 f0       	push   $0xf012b26b
f0116b71:	68 7a b2 12 f0       	push   $0xf012b27a
f0116b76:	68 4d 08 00 00       	push   $0x84d
f0116b7b:	68 42 97 12 f0       	push   $0xf0129742
f0116b80:	e8 b4 97 fe ff       	call   f0100339 <_panic>

f0116b85 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116b85:	55                   	push   %ebp
f0116b86:	89 e5                	mov    %esp,%ebp
f0116b88:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116b8b:	68 6b b2 12 f0       	push   $0xf012b26b
f0116b90:	68 7a b2 12 f0       	push   $0xf012b27a
f0116b95:	68 5c 08 00 00       	push   $0x85c
f0116b9a:	68 42 97 12 f0       	push   $0xf0129742
f0116b9f:	e8 95 97 fe ff       	call   f0100339 <_panic>

f0116ba4 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0116ba4:	55                   	push   %ebp
f0116ba5:	89 e5                	mov    %esp,%ebp
f0116ba7:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116baa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116bad:	c1 e8 16             	shr    $0x16,%eax
f0116bb0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116bb7:	8b 45 08             	mov    0x8(%ebp),%eax
f0116bba:	01 d0                	add    %edx,%eax
f0116bbc:	8b 00                	mov    (%eax),%eax
f0116bbe:	83 e0 01             	and    $0x1,%eax
f0116bc1:	85 c0                	test   %eax,%eax
f0116bc3:	75 07                	jne    f0116bcc <CE+0x28>
f0116bc5:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bca:	eb 7a                	jmp    f0116c46 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116bcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116bcf:	c1 e8 16             	shr    $0x16,%eax
f0116bd2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116bd9:	8b 45 08             	mov    0x8(%ebp),%eax
f0116bdc:	01 d0                	add    %edx,%eax
f0116bde:	8b 00                	mov    (%eax),%eax
f0116be0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116be5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116be8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116beb:	c1 e8 0c             	shr    $0xc,%eax
f0116bee:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116bf1:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0116bf6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116bf9:	72 17                	jb     f0116c12 <CE+0x6e>
f0116bfb:	ff 75 f4             	pushl  -0xc(%ebp)
f0116bfe:	68 3c b2 12 f0       	push   $0xf012b23c
f0116c03:	68 65 08 00 00       	push   $0x865
f0116c08:	68 42 97 12 f0       	push   $0xf0129742
f0116c0d:	e8 27 97 fe ff       	call   f0100339 <_panic>
f0116c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116c15:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116c1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c20:	c1 e8 0c             	shr    $0xc,%eax
f0116c23:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116c28:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c32:	01 d0                	add    %edx,%eax
f0116c34:	8b 00                	mov    (%eax),%eax
f0116c36:	85 c0                	test   %eax,%eax
f0116c38:	74 07                	je     f0116c41 <CE+0x9d>
f0116c3a:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c3f:	eb 05                	jmp    f0116c46 <CE+0xa2>
	return 1;
f0116c41:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116c46:	c9                   	leave  
f0116c47:	c3                   	ret    

f0116c48 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116c48:	55                   	push   %ebp
f0116c49:	89 e5                	mov    %esp,%ebp
f0116c4b:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116c4e:	68 6b b2 12 f0       	push   $0xf012b26b
f0116c53:	68 7a b2 12 f0       	push   $0xf012b27a
f0116c58:	68 6c 08 00 00       	push   $0x86c
f0116c5d:	68 42 97 12 f0       	push   $0xf0129742
f0116c62:	e8 d2 96 fe ff       	call   f0100339 <_panic>

f0116c67 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116c67:	55                   	push   %ebp
f0116c68:	89 e5                	mov    %esp,%ebp
f0116c6a:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116c6d:	68 6b b2 12 f0       	push   $0xf012b26b
f0116c72:	68 7a b2 12 f0       	push   $0xf012b27a
f0116c77:	68 7c 08 00 00       	push   $0x87c
f0116c7c:	68 42 97 12 f0       	push   $0xf0129742
f0116c81:	e8 b3 96 fe ff       	call   f0100339 <_panic>

f0116c86 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116c86:	55                   	push   %ebp
f0116c87:	89 e5                	mov    %esp,%ebp
f0116c89:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116c8c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116c93:	eb 18                	jmp    f0116cad <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116c95:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116c98:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c9f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116ca2:	01 d0                	add    %edx,%eax
f0116ca4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116caa:	ff 45 fc             	incl   -0x4(%ebp)
f0116cad:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116cb0:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116cb5:	76 de                	jbe    f0116c95 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116cb7:	90                   	nop
f0116cb8:	c9                   	leave  
f0116cb9:	c3                   	ret    

f0116cba <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116cba:	55                   	push   %ebp
f0116cbb:	89 e5                	mov    %esp,%ebp
f0116cbd:	83 ec 38             	sub    $0x38,%esp
f0116cc0:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116cc3:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116cc9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116cce:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116cd1:	8b 45 10             	mov    0x10(%ebp),%eax
f0116cd4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116cd9:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116cdc:	e9 ea 01 00 00       	jmp    f0116ecb <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116ce1:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116ce5:	74 44                	je     f0116d2b <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116cea:	83 ec 04             	sub    $0x4,%esp
f0116ced:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116cf0:	52                   	push   %edx
f0116cf1:	50                   	push   %eax
f0116cf2:	ff 75 08             	pushl  0x8(%ebp)
f0116cf5:	e8 9a 1d ff ff       	call   f0108a94 <get_frame_info>
f0116cfa:	83 c4 10             	add    $0x10,%esp
f0116cfd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116d00:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116d03:	85 c0                	test   %eax,%eax
f0116d05:	75 24                	jne    f0116d2b <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116d07:	83 ec 04             	sub    $0x4,%esp
f0116d0a:	68 90 b2 12 f0       	push   $0xf012b290
f0116d0f:	68 99 08 00 00       	push   $0x899
f0116d14:	68 42 97 12 f0       	push   $0xf0129742
f0116d19:	e8 b8 97 fe ff       	call   f01004d6 <_warn>
f0116d1e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116d21:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d26:	e9 b6 01 00 00       	jmp    f0116ee1 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116d2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116d2e:	83 ec 04             	sub    $0x4,%esp
f0116d31:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116d34:	52                   	push   %edx
f0116d35:	50                   	push   %eax
f0116d36:	ff 75 08             	pushl  0x8(%ebp)
f0116d39:	e8 56 1d ff ff       	call   f0108a94 <get_frame_info>
f0116d3e:	83 c4 10             	add    $0x10,%esp
f0116d41:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116d44:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116d47:	85 c0                	test   %eax,%eax
f0116d49:	75 24                	jne    f0116d6f <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116d4b:	83 ec 04             	sub    $0x4,%esp
f0116d4e:	68 bc b2 12 f0       	push   $0xf012b2bc
f0116d53:	68 a0 08 00 00       	push   $0x8a0
f0116d58:	68 42 97 12 f0       	push   $0xf0129742
f0116d5d:	e8 74 97 fe ff       	call   f01004d6 <_warn>
f0116d62:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116d65:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d6a:	e9 72 01 00 00       	jmp    f0116ee1 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116d6f:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116d73:	75 70                	jne    f0116de5 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116d75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116d78:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116d7b:	c1 ea 0c             	shr    $0xc,%edx
f0116d7e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116d84:	c1 e2 02             	shl    $0x2,%edx
f0116d87:	01 d0                	add    %edx,%eax
f0116d89:	8b 00                	mov    (%eax),%eax
f0116d8b:	c1 e8 0c             	shr    $0xc,%eax
f0116d8e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116d91:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116d94:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116d97:	c1 ea 0c             	shr    $0xc,%edx
f0116d9a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116da0:	c1 e2 02             	shl    $0x2,%edx
f0116da3:	01 d0                	add    %edx,%eax
f0116da5:	8b 00                	mov    (%eax),%eax
f0116da7:	c1 e8 0c             	shr    $0xc,%eax
f0116daa:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116dad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116db0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116db3:	74 30                	je     f0116de5 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116db5:	83 ec 04             	sub    $0x4,%esp
f0116db8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116dbb:	ff 75 e8             	pushl  -0x18(%ebp)
f0116dbe:	ff 75 f0             	pushl  -0x10(%ebp)
f0116dc1:	ff 75 f4             	pushl  -0xc(%ebp)
f0116dc4:	68 e8 b2 12 f0       	push   $0xf012b2e8
f0116dc9:	68 aa 08 00 00       	push   $0x8aa
f0116dce:	68 42 97 12 f0       	push   $0xf0129742
f0116dd3:	e8 fe 96 fe ff       	call   f01004d6 <_warn>
f0116dd8:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116ddb:	b8 00 00 00 00       	mov    $0x0,%eax
f0116de0:	e9 fc 00 00 00       	jmp    f0116ee1 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116de5:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116de9:	74 52                	je     f0116e3d <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116deb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116def:	74 0e                	je     f0116dff <CCP+0x145>
f0116df1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116df4:	8b 40 08             	mov    0x8(%eax),%eax
f0116df7:	0f b7 c0             	movzwl %ax,%eax
f0116dfa:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116dfd:	74 3e                	je     f0116e3d <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116dff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116e03:	74 0b                	je     f0116e10 <CCP+0x156>
f0116e05:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116e08:	8b 40 08             	mov    0x8(%eax),%eax
f0116e0b:	0f b7 c0             	movzwl %ax,%eax
f0116e0e:	eb 05                	jmp    f0116e15 <CCP+0x15b>
f0116e10:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e15:	83 ec 0c             	sub    $0xc,%esp
f0116e18:	50                   	push   %eax
f0116e19:	ff 75 f0             	pushl  -0x10(%ebp)
f0116e1c:	68 44 b3 12 f0       	push   $0xf012b344
f0116e21:	68 b2 08 00 00       	push   $0x8b2
f0116e26:	68 42 97 12 f0       	push   $0xf0129742
f0116e2b:	e8 a6 96 fe ff       	call   f01004d6 <_warn>
f0116e30:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116e33:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e38:	e9 a4 00 00 00       	jmp    f0116ee1 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116e3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116e40:	ff 75 20             	pushl  0x20(%ebp)
f0116e43:	ff 75 1c             	pushl  0x1c(%ebp)
f0116e46:	50                   	push   %eax
f0116e47:	ff 75 08             	pushl  0x8(%ebp)
f0116e4a:	e8 17 fd ff ff       	call   f0116b66 <CPs>
f0116e4f:	83 c4 10             	add    $0x10,%esp
f0116e52:	85 c0                	test   %eax,%eax
f0116e54:	7f 21                	jg     f0116e77 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116e56:	83 ec 04             	sub    $0x4,%esp
f0116e59:	68 b4 b3 12 f0       	push   $0xf012b3b4
f0116e5e:	68 b8 08 00 00       	push   $0x8b8
f0116e63:	68 42 97 12 f0       	push   $0xf0129742
f0116e68:	e8 69 96 fe ff       	call   f01004d6 <_warn>
f0116e6d:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116e70:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e75:	eb 6a                	jmp    f0116ee1 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116e77:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116e7b:	74 3a                	je     f0116eb7 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116e7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116e80:	ff 75 28             	pushl  0x28(%ebp)
f0116e83:	ff 75 24             	pushl  0x24(%ebp)
f0116e86:	50                   	push   %eax
f0116e87:	ff 75 08             	pushl  0x8(%ebp)
f0116e8a:	e8 d7 fc ff ff       	call   f0116b66 <CPs>
f0116e8f:	83 c4 10             	add    $0x10,%esp
f0116e92:	85 c0                	test   %eax,%eax
f0116e94:	7f 21                	jg     f0116eb7 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116e96:	83 ec 04             	sub    $0x4,%esp
f0116e99:	68 fc b3 12 f0       	push   $0xf012b3fc
f0116e9e:	68 bf 08 00 00       	push   $0x8bf
f0116ea3:	68 42 97 12 f0       	push   $0xf0129742
f0116ea8:	e8 29 96 fe ff       	call   f01004d6 <_warn>
f0116ead:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116eb0:	b8 00 00 00 00       	mov    $0x0,%eax
f0116eb5:	eb 2a                	jmp    f0116ee1 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116eb7:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116ebb:	74 07                	je     f0116ec4 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116ebd:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116ec4:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116ecb:	8b 55 10             	mov    0x10(%ebp),%edx
f0116ece:	8b 45 14             	mov    0x14(%ebp),%eax
f0116ed1:	01 d0                	add    %edx,%eax
f0116ed3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116ed6:	0f 87 05 fe ff ff    	ja     f0116ce1 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116edc:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116ee1:	c9                   	leave  
f0116ee2:	c3                   	ret    

f0116ee3 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116ee3:	55                   	push   %ebp
f0116ee4:	89 e5                	mov    %esp,%ebp
f0116ee6:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116ee9:	83 ec 04             	sub    $0x4,%esp
f0116eec:	68 3c b4 12 f0       	push   $0xf012b43c
f0116ef1:	6a 0e                	push   $0xe
f0116ef3:	68 4c b4 12 f0       	push   $0xf012b44c
f0116ef8:	e8 3c 94 fe ff       	call   f0100339 <_panic>

f0116efd <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116efd:	55                   	push   %ebp
f0116efe:	89 e5                	mov    %esp,%ebp
f0116f00:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116f03:	83 ec 04             	sub    $0x4,%esp
f0116f06:	68 3c b4 12 f0       	push   $0xf012b43c
f0116f0b:	68 d7 00 00 00       	push   $0xd7
f0116f10:	68 4c b4 12 f0       	push   $0xf012b44c
f0116f15:	e8 1f 94 fe ff       	call   f0100339 <_panic>

f0116f1a <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116f1a:	55                   	push   %ebp
f0116f1b:	89 e5                	mov    %esp,%ebp
f0116f1d:	57                   	push   %edi
f0116f1e:	53                   	push   %ebx
f0116f1f:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116f25:	83 ec 0c             	sub    $0xc,%esp
f0116f28:	68 68 b4 12 f0       	push   $0xf012b468
f0116f2d:	e8 59 a0 fe ff       	call   f0100f8b <cprintf>
f0116f32:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116f35:	83 ec 0c             	sub    $0xc,%esp
f0116f38:	68 98 b4 12 f0       	push   $0xf012b498
f0116f3d:	e8 49 a0 fe ff       	call   f0100f8b <cprintf>
f0116f42:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116f45:	83 ec 0c             	sub    $0xc,%esp
f0116f48:	68 68 b4 12 f0       	push   $0xf012b468
f0116f4d:	e8 39 a0 fe ff       	call   f0100f8b <cprintf>
f0116f52:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0116f55:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116f59:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116f5d:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0116f63:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116f69:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116f70:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116f77:	e8 16 7c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0116f7c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116f7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116f86:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0116f8d:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0116f93:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116f98:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f9d:	89 d7                	mov    %edx,%edi
f0116f9f:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0116fa1:	83 ec 0c             	sub    $0xc,%esp
f0116fa4:	68 f1 b4 12 f0       	push   $0xf012b4f1
f0116fa9:	e8 dd 9f fe ff       	call   f0100f8b <cprintf>
f0116fae:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116fb1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0116fb8:	e8 d5 7b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0116fbd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116fc0:	e8 ce da fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0116fc5:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0116fc8:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116fcf:	83 ec 0c             	sub    $0xc,%esp
f0116fd2:	ff 75 cc             	pushl  -0x34(%ebp)
f0116fd5:	e8 e0 27 ff ff       	call   f01097ba <kmalloc>
f0116fda:	83 c4 10             	add    $0x10,%esp
f0116fdd:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0116fe3:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116fe9:	85 c0                	test   %eax,%eax
f0116feb:	74 17                	je     f0117004 <test_kmalloc+0xea>
f0116fed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ff4:	83 ec 0c             	sub    $0xc,%esp
f0116ff7:	68 10 b5 12 f0       	push   $0xf012b510
f0116ffc:	e8 8a 9f fe ff       	call   f0100f8b <cprintf>
f0117001:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117004:	e8 8a da fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117009:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011700c:	74 17                	je     f0117025 <test_kmalloc+0x10b>
f011700e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117015:	83 ec 0c             	sub    $0xc,%esp
f0117018:	68 44 b5 12 f0       	push   $0xf012b544
f011701d:	e8 69 9f fe ff       	call   f0100f8b <cprintf>
f0117022:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117025:	e8 68 7b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011702a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011702d:	74 17                	je     f0117046 <test_kmalloc+0x12c>
f011702f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117036:	83 ec 0c             	sub    $0xc,%esp
f0117039:	68 b0 b5 12 f0       	push   $0xf012b5b0
f011703e:	e8 48 9f fe ff       	call   f0100f8b <cprintf>
f0117043:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117046:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011704a:	74 04                	je     f0117050 <test_kmalloc+0x136>
f011704c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0117050:	83 ec 0c             	sub    $0xc,%esp
f0117053:	68 f4 b5 12 f0       	push   $0xf012b5f4
f0117058:	e8 2e 9f fe ff       	call   f0100f8b <cprintf>
f011705d:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117060:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117067:	e8 26 7b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011706c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011706f:	e8 1f da fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117074:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0117077:	83 ec 0c             	sub    $0xc,%esp
f011707a:	68 00 fc 1f 00       	push   $0x1ffc00
f011707f:	e8 36 27 ff ff       	call   f01097ba <kmalloc>
f0117084:	83 c4 10             	add    $0x10,%esp
f0117087:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011708d:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117093:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117098:	74 17                	je     f01170b1 <test_kmalloc+0x197>
f011709a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170a1:	83 ec 0c             	sub    $0xc,%esp
f01170a4:	68 38 b6 12 f0       	push   $0xf012b638
f01170a9:	e8 dd 9e fe ff       	call   f0100f8b <cprintf>
f01170ae:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170b1:	e8 dd d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01170b6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170b9:	74 17                	je     f01170d2 <test_kmalloc+0x1b8>
f01170bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170c2:	83 ec 0c             	sub    $0xc,%esp
f01170c5:	68 8c b6 12 f0       	push   $0xf012b68c
f01170ca:	e8 bc 9e fe ff       	call   f0100f8b <cprintf>
f01170cf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01170d2:	e8 bb 7a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01170d7:	89 c2                	mov    %eax,%edx
f01170d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01170dc:	29 d0                	sub    %edx,%eax
f01170de:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01170e3:	7f 17                	jg     f01170fc <test_kmalloc+0x1e2>
f01170e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170ec:	83 ec 0c             	sub    $0xc,%esp
f01170ef:	68 f8 b6 12 f0       	push   $0xf012b6f8
f01170f4:	e8 92 9e fe ff       	call   f0100f8b <cprintf>
f01170f9:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01170fc:	e8 91 7a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117101:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117104:	e8 8a d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117109:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011710c:	83 ec 0c             	sub    $0xc,%esp
f011710f:	68 00 fc 1f 00       	push   $0x1ffc00
f0117114:	e8 a1 26 ff ff       	call   f01097ba <kmalloc>
f0117119:	83 c4 10             	add    $0x10,%esp
f011711c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117122:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117128:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011712d:	74 17                	je     f0117146 <test_kmalloc+0x22c>
f011712f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117136:	83 ec 0c             	sub    $0xc,%esp
f0117139:	68 3c b7 12 f0       	push   $0xf012b73c
f011713e:	e8 48 9e fe ff       	call   f0100f8b <cprintf>
f0117143:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117146:	e8 48 d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011714b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011714e:	74 17                	je     f0117167 <test_kmalloc+0x24d>
f0117150:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117157:	83 ec 0c             	sub    $0xc,%esp
f011715a:	68 90 b7 12 f0       	push   $0xf012b790
f011715f:	e8 27 9e fe ff       	call   f0100f8b <cprintf>
f0117164:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117167:	e8 26 7a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011716c:	89 c2                	mov    %eax,%edx
f011716e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117171:	29 d0                	sub    %edx,%eax
f0117173:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117178:	7f 17                	jg     f0117191 <test_kmalloc+0x277>
f011717a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117181:	83 ec 0c             	sub    $0xc,%esp
f0117184:	68 fc b7 12 f0       	push   $0xf012b7fc
f0117189:	e8 fd 9d fe ff       	call   f0100f8b <cprintf>
f011718e:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0117191:	e8 fc 79 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117196:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117199:	e8 f5 d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011719e:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f01171a1:	83 ec 0c             	sub    $0xc,%esp
f01171a4:	68 ff 07 00 00       	push   $0x7ff
f01171a9:	e8 0c 26 ff ff       	call   f01097ba <kmalloc>
f01171ae:	83 c4 10             	add    $0x10,%esp
f01171b1:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01171b7:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01171bd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01171c2:	76 28                	jbe    f01171ec <test_kmalloc+0x2d2>
f01171c4:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f01171ca:	83 ec 0c             	sub    $0xc,%esp
f01171cd:	6a 00                	push   $0x0
f01171cf:	e8 b3 24 ff ff       	call   f0109687 <sbrk>
f01171d4:	83 c4 10             	add    $0x10,%esp
f01171d7:	39 c3                	cmp    %eax,%ebx
f01171d9:	73 11                	jae    f01171ec <test_kmalloc+0x2d2>
f01171db:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01171e1:	89 c2                	mov    %eax,%edx
f01171e3:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f01171e8:	39 c2                	cmp    %eax,%edx
f01171ea:	72 17                	jb     f0117203 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01171ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171f3:	83 ec 0c             	sub    $0xc,%esp
f01171f6:	68 40 b8 12 f0       	push   $0xf012b840
f01171fb:	e8 8b 9d fe ff       	call   f0100f8b <cprintf>
f0117200:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117203:	e8 8b d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117208:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011720b:	74 17                	je     f0117224 <test_kmalloc+0x30a>
f011720d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117214:	83 ec 0c             	sub    $0xc,%esp
f0117217:	68 cc b8 12 f0       	push   $0xf012b8cc
f011721c:	e8 6a 9d fe ff       	call   f0100f8b <cprintf>
f0117221:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117224:	e8 6a d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117229:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f011722c:	83 ec 0c             	sub    $0xc,%esp
f011722f:	68 ff 07 00 00       	push   $0x7ff
f0117234:	e8 81 25 ff ff       	call   f01097ba <kmalloc>
f0117239:	83 c4 10             	add    $0x10,%esp
f011723c:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0117242:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117248:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011724d:	76 28                	jbe    f0117277 <test_kmalloc+0x35d>
f011724f:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0117255:	83 ec 0c             	sub    $0xc,%esp
f0117258:	6a 00                	push   $0x0
f011725a:	e8 28 24 ff ff       	call   f0109687 <sbrk>
f011725f:	83 c4 10             	add    $0x10,%esp
f0117262:	39 c3                	cmp    %eax,%ebx
f0117264:	73 11                	jae    f0117277 <test_kmalloc+0x35d>
f0117266:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011726c:	89 c2                	mov    %eax,%edx
f011726e:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0117273:	39 c2                	cmp    %eax,%edx
f0117275:	72 17                	jb     f011728e <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117277:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011727e:	83 ec 0c             	sub    $0xc,%esp
f0117281:	68 38 b9 12 f0       	push   $0xf012b938
f0117286:	e8 00 9d fe ff       	call   f0100f8b <cprintf>
f011728b:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011728e:	e8 00 d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117293:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117296:	74 17                	je     f01172af <test_kmalloc+0x395>
f0117298:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011729f:	83 ec 0c             	sub    $0xc,%esp
f01172a2:	68 c4 b9 12 f0       	push   $0xf012b9c4
f01172a7:	e8 df 9c fe ff       	call   f0100f8b <cprintf>
f01172ac:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f01172af:	e8 de 78 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01172b4:	89 c2                	mov    %eax,%edx
f01172b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01172b9:	29 d0                	sub    %edx,%eax
f01172bb:	83 f8 01             	cmp    $0x1,%eax
f01172be:	74 17                	je     f01172d7 <test_kmalloc+0x3bd>
f01172c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172c7:	83 ec 0c             	sub    $0xc,%esp
f01172ca:	68 30 ba 12 f0       	push   $0xf012ba30
f01172cf:	e8 b7 9c fe ff       	call   f0100f8b <cprintf>
f01172d4:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172d7:	e8 b6 78 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01172dc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172df:	e8 af d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01172e4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f01172e7:	83 ec 0c             	sub    $0xc,%esp
f01172ea:	68 00 1c 00 00       	push   $0x1c00
f01172ef:	e8 c6 24 ff ff       	call   f01097ba <kmalloc>
f01172f4:	83 c4 10             	add    $0x10,%esp
f01172f7:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01172fd:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117303:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117308:	74 17                	je     f0117321 <test_kmalloc+0x407>
f011730a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117311:	83 ec 0c             	sub    $0xc,%esp
f0117314:	68 50 ba 12 f0       	push   $0xf012ba50
f0117319:	e8 6d 9c fe ff       	call   f0100f8b <cprintf>
f011731e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117321:	e8 6d d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117326:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117329:	74 17                	je     f0117342 <test_kmalloc+0x428>
f011732b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117332:	83 ec 0c             	sub    $0xc,%esp
f0117335:	68 a4 ba 12 f0       	push   $0xf012baa4
f011733a:	e8 4c 9c fe ff       	call   f0100f8b <cprintf>
f011733f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117342:	e8 4b 78 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117347:	89 c2                	mov    %eax,%edx
f0117349:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011734c:	29 d0                	sub    %edx,%eax
f011734e:	83 f8 01             	cmp    $0x1,%eax
f0117351:	7f 17                	jg     f011736a <test_kmalloc+0x450>
f0117353:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011735a:	83 ec 0c             	sub    $0xc,%esp
f011735d:	68 10 bb 12 f0       	push   $0xf012bb10
f0117362:	e8 24 9c fe ff       	call   f0100f8b <cprintf>
f0117367:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011736a:	e8 23 78 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011736f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117372:	e8 1c d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117377:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011737a:	83 ec 0c             	sub    $0xc,%esp
f011737d:	68 00 fc 2f 00       	push   $0x2ffc00
f0117382:	e8 33 24 ff ff       	call   f01097ba <kmalloc>
f0117387:	83 c4 10             	add    $0x10,%esp
f011738a:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117390:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0117396:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011739b:	74 17                	je     f01173b4 <test_kmalloc+0x49a>
f011739d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173a4:	83 ec 0c             	sub    $0xc,%esp
f01173a7:	68 54 bb 12 f0       	push   $0xf012bb54
f01173ac:	e8 da 9b fe ff       	call   f0100f8b <cprintf>
f01173b1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173b4:	e8 da d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01173b9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01173bc:	74 17                	je     f01173d5 <test_kmalloc+0x4bb>
f01173be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173c5:	83 ec 0c             	sub    $0xc,%esp
f01173c8:	68 a8 bb 12 f0       	push   $0xf012bba8
f01173cd:	e8 b9 9b fe ff       	call   f0100f8b <cprintf>
f01173d2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01173d5:	e8 b8 77 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01173da:	89 c2                	mov    %eax,%edx
f01173dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01173df:	29 d0                	sub    %edx,%eax
f01173e1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01173e6:	7f 17                	jg     f01173ff <test_kmalloc+0x4e5>
f01173e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173ef:	83 ec 0c             	sub    $0xc,%esp
f01173f2:	68 14 bc 12 f0       	push   $0xf012bc14
f01173f7:	e8 8f 9b fe ff       	call   f0100f8b <cprintf>
f01173fc:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01173ff:	e8 8e 77 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117404:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117407:	e8 87 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011740c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011740f:	83 ec 0c             	sub    $0xc,%esp
f0117412:	68 00 fc 5f 00       	push   $0x5ffc00
f0117417:	e8 9e 23 ff ff       	call   f01097ba <kmalloc>
f011741c:	83 c4 10             	add    $0x10,%esp
f011741f:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117425:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011742b:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0117430:	74 17                	je     f0117449 <test_kmalloc+0x52f>
f0117432:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117439:	83 ec 0c             	sub    $0xc,%esp
f011743c:	68 58 bc 12 f0       	push   $0xf012bc58
f0117441:	e8 45 9b fe ff       	call   f0100f8b <cprintf>
f0117446:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117449:	e8 45 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011744e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117451:	74 17                	je     f011746a <test_kmalloc+0x550>
f0117453:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011745a:	83 ec 0c             	sub    $0xc,%esp
f011745d:	68 ac bc 12 f0       	push   $0xf012bcac
f0117462:	e8 24 9b fe ff       	call   f0100f8b <cprintf>
f0117467:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011746a:	e8 23 77 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011746f:	89 c2                	mov    %eax,%edx
f0117471:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117474:	29 d0                	sub    %edx,%eax
f0117476:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011747b:	7f 17                	jg     f0117494 <test_kmalloc+0x57a>
f011747d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117484:	83 ec 0c             	sub    $0xc,%esp
f0117487:	68 18 bd 12 f0       	push   $0xf012bd18
f011748c:	e8 fa 9a fe ff       	call   f0100f8b <cprintf>
f0117491:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117494:	e8 f9 76 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117499:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011749c:	e8 f2 d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01174a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f01174a4:	83 ec 0c             	sub    $0xc,%esp
f01174a7:	68 00 38 00 00       	push   $0x3800
f01174ac:	e8 09 23 ff ff       	call   f01097ba <kmalloc>
f01174b1:	83 c4 10             	add    $0x10,%esp
f01174b4:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01174ba:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01174c0:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f01174c5:	74 17                	je     f01174de <test_kmalloc+0x5c4>
f01174c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ce:	83 ec 0c             	sub    $0xc,%esp
f01174d1:	68 5c bd 12 f0       	push   $0xf012bd5c
f01174d6:	e8 b0 9a fe ff       	call   f0100f8b <cprintf>
f01174db:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174de:	e8 b0 d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01174e3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01174e6:	74 17                	je     f01174ff <test_kmalloc+0x5e5>
f01174e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ef:	83 ec 0c             	sub    $0xc,%esp
f01174f2:	68 b0 bd 12 f0       	push   $0xf012bdb0
f01174f7:	e8 8f 9a fe ff       	call   f0100f8b <cprintf>
f01174fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01174ff:	e8 8e 76 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117504:	89 c2                	mov    %eax,%edx
f0117506:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117509:	29 d0                	sub    %edx,%eax
f011750b:	83 f8 03             	cmp    $0x3,%eax
f011750e:	7f 17                	jg     f0117527 <test_kmalloc+0x60d>
f0117510:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117517:	83 ec 0c             	sub    $0xc,%esp
f011751a:	68 1c be 12 f0       	push   $0xf012be1c
f011751f:	e8 67 9a fe ff       	call   f0100f8b <cprintf>
f0117524:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117527:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011752b:	74 04                	je     f0117531 <test_kmalloc+0x617>
f011752d:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117531:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0117538:	83 ec 0c             	sub    $0xc,%esp
f011753b:	68 60 be 12 f0       	push   $0xf012be60
f0117540:	e8 46 9a fe ff       	call   f0100f8b <cprintf>
f0117545:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117548:	e8 45 76 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011754d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117550:	e8 3e d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117555:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0117558:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f011755f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117565:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0117568:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011756b:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011756e:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0117570:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117573:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117576:	01 c2                	add    %eax,%edx
f0117578:	8a 45 ea             	mov    -0x16(%ebp),%al
f011757b:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f011757d:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117583:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0117586:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f011758d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117590:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117593:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0117596:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117599:	01 c0                	add    %eax,%eax
f011759b:	89 c2                	mov    %eax,%edx
f011759d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01175a0:	01 c2                	add    %eax,%edx
f01175a2:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01175a6:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f01175a9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01175af:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f01175b2:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f01175b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01175bc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01175bf:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f01175c1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01175c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01175cb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01175ce:	01 c2                	add    %eax,%edx
f01175d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01175d3:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f01175d5:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01175db:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f01175de:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f01175e5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175e8:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01175eb:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f01175ed:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01175f0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175f3:	01 c2                	add    %eax,%edx
f01175f5:	8a 45 ea             	mov    -0x16(%ebp),%al
f01175f8:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f01175fa:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117600:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0117603:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f011760a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011760d:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117610:	88 10                	mov    %dl,(%eax)
f0117612:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0117615:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117618:	66 89 42 02          	mov    %ax,0x2(%edx)
f011761c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011761f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117622:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0117625:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117628:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011762f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117632:	01 c2                	add    %eax,%edx
f0117634:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117637:	88 02                	mov    %al,(%edx)
f0117639:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011763c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117643:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117646:	01 c2                	add    %eax,%edx
f0117648:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011764c:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117650:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117653:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011765a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011765d:	01 c2                	add    %eax,%edx
f011765f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117662:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0117665:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011766c:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117672:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0117675:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117678:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011767b:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f011767d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117680:	89 c2                	mov    %eax,%edx
f0117682:	c1 ea 1f             	shr    $0x1f,%edx
f0117685:	01 d0                	add    %edx,%eax
f0117687:	d1 f8                	sar    %eax
f0117689:	89 c2                	mov    %eax,%edx
f011768b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011768e:	01 c2                	add    %eax,%edx
f0117690:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117693:	88 c1                	mov    %al,%cl
f0117695:	c0 e9 07             	shr    $0x7,%cl
f0117698:	01 c8                	add    %ecx,%eax
f011769a:	d0 f8                	sar    %al
f011769c:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011769e:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01176a1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01176a4:	01 c2                	add    %eax,%edx
f01176a6:	8a 45 ea             	mov    -0x16(%ebp),%al
f01176a9:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f01176ab:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01176b1:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f01176b4:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f01176bb:	8b 55 98             	mov    -0x68(%ebp),%edx
f01176be:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01176c1:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f01176c4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01176c7:	01 c0                	add    %eax,%eax
f01176c9:	89 c2                	mov    %eax,%edx
f01176cb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01176ce:	01 c2                	add    %eax,%edx
f01176d0:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01176d4:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f01176d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01176da:	8a 00                	mov    (%eax),%al
f01176dc:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01176df:	75 0f                	jne    f01176f0 <test_kmalloc+0x7d6>
f01176e1:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01176e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01176e7:	01 d0                	add    %edx,%eax
f01176e9:	8a 00                	mov    (%eax),%al
f01176eb:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01176ee:	74 17                	je     f0117707 <test_kmalloc+0x7ed>
f01176f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176f7:	83 ec 0c             	sub    $0xc,%esp
f01176fa:	68 98 be 12 f0       	push   $0xf012be98
f01176ff:	e8 87 98 fe ff       	call   f0100f8b <cprintf>
f0117704:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117707:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011770a:	66 8b 00             	mov    (%eax),%ax
f011770d:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117711:	75 15                	jne    f0117728 <test_kmalloc+0x80e>
f0117713:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117716:	01 c0                	add    %eax,%eax
f0117718:	89 c2                	mov    %eax,%edx
f011771a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011771d:	01 d0                	add    %edx,%eax
f011771f:	66 8b 00             	mov    (%eax),%ax
f0117722:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117726:	74 17                	je     f011773f <test_kmalloc+0x825>
f0117728:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011772f:	83 ec 0c             	sub    $0xc,%esp
f0117732:	68 d0 be 12 f0       	push   $0xf012bed0
f0117737:	e8 4f 98 fe ff       	call   f0100f8b <cprintf>
f011773c:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f011773f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117742:	8b 00                	mov    (%eax),%eax
f0117744:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117747:	75 16                	jne    f011775f <test_kmalloc+0x845>
f0117749:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011774c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117753:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117756:	01 d0                	add    %edx,%eax
f0117758:	8b 00                	mov    (%eax),%eax
f011775a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011775d:	74 17                	je     f0117776 <test_kmalloc+0x85c>
f011775f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117766:	83 ec 0c             	sub    $0xc,%esp
f0117769:	68 0c bf 12 f0       	push   $0xf012bf0c
f011776e:	e8 18 98 fe ff       	call   f0100f8b <cprintf>
f0117773:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0117776:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117779:	8a 00                	mov    (%eax),%al
f011777b:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011777e:	75 0f                	jne    f011778f <test_kmalloc+0x875>
f0117780:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117783:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117786:	01 d0                	add    %edx,%eax
f0117788:	8a 00                	mov    (%eax),%al
f011778a:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011778d:	74 17                	je     f01177a6 <test_kmalloc+0x88c>
f011778f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117796:	83 ec 0c             	sub    $0xc,%esp
f0117799:	68 48 bf 12 f0       	push   $0xf012bf48
f011779e:	e8 e8 97 fe ff       	call   f0100f8b <cprintf>
f01177a3:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f01177a6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177a9:	8a 00                	mov    (%eax),%al
f01177ab:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01177ae:	75 16                	jne    f01177c6 <test_kmalloc+0x8ac>
f01177b0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01177b3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01177ba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177bd:	01 d0                	add    %edx,%eax
f01177bf:	8a 00                	mov    (%eax),%al
f01177c1:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01177c4:	74 17                	je     f01177dd <test_kmalloc+0x8c3>
f01177c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177cd:	83 ec 0c             	sub    $0xc,%esp
f01177d0:	68 84 bf 12 f0       	push   $0xf012bf84
f01177d5:	e8 b1 97 fe ff       	call   f0100f8b <cprintf>
f01177da:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f01177dd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177e0:	66 8b 40 02          	mov    0x2(%eax),%ax
f01177e4:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01177e8:	75 19                	jne    f0117803 <test_kmalloc+0x8e9>
f01177ea:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01177ed:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01177f4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177f7:	01 d0                	add    %edx,%eax
f01177f9:	66 8b 40 02          	mov    0x2(%eax),%ax
f01177fd:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117801:	74 17                	je     f011781a <test_kmalloc+0x900>
f0117803:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011780a:	83 ec 0c             	sub    $0xc,%esp
f011780d:	68 c0 bf 12 f0       	push   $0xf012bfc0
f0117812:	e8 74 97 fe ff       	call   f0100f8b <cprintf>
f0117817:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f011781a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011781d:	8b 40 04             	mov    0x4(%eax),%eax
f0117820:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117823:	75 17                	jne    f011783c <test_kmalloc+0x922>
f0117825:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117828:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011782f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117832:	01 d0                	add    %edx,%eax
f0117834:	8b 40 04             	mov    0x4(%eax),%eax
f0117837:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011783a:	74 17                	je     f0117853 <test_kmalloc+0x939>
f011783c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117843:	83 ec 0c             	sub    $0xc,%esp
f0117846:	68 fc bf 12 f0       	push   $0xf012bffc
f011784b:	e8 3b 97 fe ff       	call   f0100f8b <cprintf>
f0117850:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0117853:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117856:	8a 00                	mov    (%eax),%al
f0117858:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011785b:	75 34                	jne    f0117891 <test_kmalloc+0x977>
f011785d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117860:	89 c2                	mov    %eax,%edx
f0117862:	c1 ea 1f             	shr    $0x1f,%edx
f0117865:	01 d0                	add    %edx,%eax
f0117867:	d1 f8                	sar    %eax
f0117869:	89 c2                	mov    %eax,%edx
f011786b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011786e:	01 d0                	add    %edx,%eax
f0117870:	8a 10                	mov    (%eax),%dl
f0117872:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117875:	88 c1                	mov    %al,%cl
f0117877:	c0 e9 07             	shr    $0x7,%cl
f011787a:	01 c8                	add    %ecx,%eax
f011787c:	d0 f8                	sar    %al
f011787e:	38 c2                	cmp    %al,%dl
f0117880:	75 0f                	jne    f0117891 <test_kmalloc+0x977>
f0117882:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117885:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117888:	01 d0                	add    %edx,%eax
f011788a:	8a 00                	mov    (%eax),%al
f011788c:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011788f:	74 17                	je     f01178a8 <test_kmalloc+0x98e>
f0117891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117898:	83 ec 0c             	sub    $0xc,%esp
f011789b:	68 38 c0 12 f0       	push   $0xf012c038
f01178a0:	e8 e6 96 fe ff       	call   f0100f8b <cprintf>
f01178a5:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f01178a8:	8b 45 98             	mov    -0x68(%ebp),%eax
f01178ab:	66 8b 00             	mov    (%eax),%ax
f01178ae:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01178b2:	75 15                	jne    f01178c9 <test_kmalloc+0x9af>
f01178b4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01178b7:	01 c0                	add    %eax,%eax
f01178b9:	89 c2                	mov    %eax,%edx
f01178bb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01178be:	01 d0                	add    %edx,%eax
f01178c0:	66 8b 00             	mov    (%eax),%ax
f01178c3:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01178c7:	74 17                	je     f01178e0 <test_kmalloc+0x9c6>
f01178c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178d0:	83 ec 0c             	sub    $0xc,%esp
f01178d3:	68 70 c0 12 f0       	push   $0xf012c070
f01178d8:	e8 ae 96 fe ff       	call   f0100f8b <cprintf>
f01178dd:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01178e0:	e8 ad 72 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01178e5:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01178e8:	74 17                	je     f0117901 <test_kmalloc+0x9e7>
f01178ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178f1:	83 ec 0c             	sub    $0xc,%esp
f01178f4:	68 ac c0 12 f0       	push   $0xf012c0ac
f01178f9:	e8 8d 96 fe ff       	call   f0100f8b <cprintf>
f01178fe:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117901:	e8 8d d1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117906:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117909:	74 17                	je     f0117922 <test_kmalloc+0xa08>
f011790b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117912:	83 ec 0c             	sub    $0xc,%esp
f0117915:	68 f0 c0 12 f0       	push   $0xf012c0f0
f011791a:	e8 6c 96 fe ff       	call   f0100f8b <cprintf>
f011791f:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0117922:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117926:	74 04                	je     f011792c <test_kmalloc+0xa12>
f0117928:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f011792c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0117933:	83 ec 0c             	sub    $0xc,%esp
f0117936:	68 5c c1 12 f0       	push   $0xf012c15c
f011793b:	e8 4b 96 fe ff       	call   f0100f8b <cprintf>
f0117940:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117943:	e8 4a 72 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117948:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011794b:	e8 43 d1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117950:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f0117953:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f011795a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011795d:	40                   	inc    %eax
f011795e:	83 ec 0c             	sub    $0xc,%esp
f0117961:	50                   	push   %eax
f0117962:	e8 53 1e ff ff       	call   f01097ba <kmalloc>
f0117967:	83 c4 10             	add    $0x10,%esp
f011796a:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0117970:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0117976:	85 c0                	test   %eax,%eax
f0117978:	74 17                	je     f0117991 <test_kmalloc+0xa77>
f011797a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117981:	83 ec 0c             	sub    $0xc,%esp
f0117984:	68 80 c1 12 f0       	push   $0xf012c180
f0117989:	e8 fd 95 fe ff       	call   f0100f8b <cprintf>
f011798e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117991:	e8 fd d0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117996:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117999:	74 17                	je     f01179b2 <test_kmalloc+0xa98>
f011799b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179a2:	83 ec 0c             	sub    $0xc,%esp
f01179a5:	68 b8 c1 12 f0       	push   $0xf012c1b8
f01179aa:	e8 dc 95 fe ff       	call   f0100f8b <cprintf>
f01179af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01179b2:	e8 db 71 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01179b7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01179ba:	74 17                	je     f01179d3 <test_kmalloc+0xab9>
f01179bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179c3:	83 ec 0c             	sub    $0xc,%esp
f01179c6:	68 24 c2 12 f0       	push   $0xf012c224
f01179cb:	e8 bb 95 fe ff       	call   f0100f8b <cprintf>
f01179d0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01179d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01179d7:	74 04                	je     f01179dd <test_kmalloc+0xac3>
f01179d9:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01179dd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f01179e4:	83 ec 0c             	sub    $0xc,%esp
f01179e7:	68 68 c2 12 f0       	push   $0xf012c268
f01179ec:	e8 9a 95 fe ff       	call   f0100f8b <cprintf>
f01179f1:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f01179f4:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01179fa:	05 00 40 00 00       	add    $0x4000,%eax
f01179ff:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117a02:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117a09:	eb 6a                	jmp    f0117a75 <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117a0b:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f0117a10:	83 ec 04             	sub    $0x4,%esp
f0117a13:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117a19:	52                   	push   %edx
f0117a1a:	ff 75 ec             	pushl  -0x14(%ebp)
f0117a1d:	50                   	push   %eax
f0117a1e:	e8 f7 0c ff ff       	call   f010871a <get_page_table>
f0117a23:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117a26:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117a2c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117a2f:	c1 ea 0c             	shr    $0xc,%edx
f0117a32:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117a38:	c1 e2 02             	shl    $0x2,%edx
f0117a3b:	01 d0                	add    %edx,%eax
f0117a3d:	8b 00                	mov    (%eax),%eax
f0117a3f:	25 ff 0f 00 00       	and    $0xfff,%eax
f0117a44:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117a47:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117a4a:	83 e0 04             	and    $0x4,%eax
f0117a4d:	85 c0                	test   %eax,%eax
f0117a4f:	74 1d                	je     f0117a6e <test_kmalloc+0xb54>
			{
				if (correct)
f0117a51:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a55:	74 17                	je     f0117a6e <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117a57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a5e:	83 ec 0c             	sub    $0xc,%esp
f0117a61:	68 ac c2 12 f0       	push   $0xf012c2ac
f0117a66:	e8 20 95 fe ff       	call   f0100f8b <cprintf>
f0117a6b:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117a6e:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0117a75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a78:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117a7b:	72 8e                	jb     f0117a0b <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117a7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a81:	74 04                	je     f0117a87 <test_kmalloc+0xb6d>
f0117a83:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0117a87:	83 ec 08             	sub    $0x8,%esp
f0117a8a:	ff 75 f4             	pushl  -0xc(%ebp)
f0117a8d:	68 fc c2 12 f0       	push   $0xf012c2fc
f0117a92:	e8 f4 94 fe ff       	call   f0100f8b <cprintf>
f0117a97:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117a9a:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0117a9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117aa2:	5b                   	pop    %ebx
f0117aa3:	5f                   	pop    %edi
f0117aa4:	5d                   	pop    %ebp
f0117aa5:	c3                   	ret    

f0117aa6 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0117aa6:	55                   	push   %ebp
f0117aa7:	89 e5                	mov    %esp,%ebp
f0117aa9:	57                   	push   %edi
f0117aaa:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117aad:	83 ec 0c             	sub    $0xc,%esp
f0117ab0:	68 68 b4 12 f0       	push   $0xf012b468
f0117ab5:	e8 d1 94 fe ff       	call   f0100f8b <cprintf>
f0117aba:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117abd:	83 ec 0c             	sub    $0xc,%esp
f0117ac0:	68 98 b4 12 f0       	push   $0xf012b498
f0117ac5:	e8 c1 94 fe ff       	call   f0100f8b <cprintf>
f0117aca:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117acd:	83 ec 0c             	sub    $0xc,%esp
f0117ad0:	68 68 b4 12 f0       	push   $0xf012b468
f0117ad5:	e8 b1 94 fe ff       	call   f0100f8b <cprintf>
f0117ada:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117add:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117ae0:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117ae5:	b8 00 00 00 00       	mov    $0x0,%eax
f0117aea:	89 d7                	mov    %edx,%edi
f0117aec:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117aee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117af5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117afc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0117b03:	83 ec 0c             	sub    $0xc,%esp
f0117b06:	68 28 c3 12 f0       	push   $0xf012c328
f0117b0b:	e8 7b 94 fe ff       	call   f0100f8b <cprintf>
f0117b10:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b13:	e8 7a 70 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b1b:	e8 73 cf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117b20:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0117b23:	83 ec 0c             	sub    $0xc,%esp
f0117b26:	68 00 fc 0f 00       	push   $0xffc00
f0117b2b:	e8 8a 1c ff ff       	call   f01097ba <kmalloc>
f0117b30:	83 c4 10             	add    $0x10,%esp
f0117b33:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117b36:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117b39:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117b3e:	74 17                	je     f0117b57 <test_kmalloc_firstfit1+0xb1>
f0117b40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b47:	83 ec 0c             	sub    $0xc,%esp
f0117b4a:	68 68 c3 12 f0       	push   $0xf012c368
f0117b4f:	e8 37 94 fe ff       	call   f0100f8b <cprintf>
f0117b54:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b57:	e8 37 cf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117b5c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b5f:	74 17                	je     f0117b78 <test_kmalloc_firstfit1+0xd2>
f0117b61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b68:	83 ec 0c             	sub    $0xc,%esp
f0117b6b:	68 8c b6 12 f0       	push   $0xf012b68c
f0117b70:	e8 16 94 fe ff       	call   f0100f8b <cprintf>
f0117b75:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0117b78:	e8 15 70 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117b7d:	89 c2                	mov    %eax,%edx
f0117b7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b82:	29 d0                	sub    %edx,%eax
f0117b84:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b89:	7f 17                	jg     f0117ba2 <test_kmalloc_firstfit1+0xfc>
f0117b8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b92:	83 ec 0c             	sub    $0xc,%esp
f0117b95:	68 9b c3 12 f0       	push   $0xf012c39b
f0117b9a:	e8 ec 93 fe ff       	call   f0100f8b <cprintf>
f0117b9f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ba2:	e8 eb 6f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117ba7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117baa:	e8 e4 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117baf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0117bb2:	83 ec 0c             	sub    $0xc,%esp
f0117bb5:	68 00 fc 0f 00       	push   $0xffc00
f0117bba:	e8 fb 1b ff ff       	call   f01097ba <kmalloc>
f0117bbf:	83 c4 10             	add    $0x10,%esp
f0117bc2:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117bc5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117bc8:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117bcd:	74 17                	je     f0117be6 <test_kmalloc_firstfit1+0x140>
f0117bcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bd6:	83 ec 0c             	sub    $0xc,%esp
f0117bd9:	68 b4 c3 12 f0       	push   $0xf012c3b4
f0117bde:	e8 a8 93 fe ff       	call   f0100f8b <cprintf>
f0117be3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117be6:	e8 a8 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117beb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117bee:	74 17                	je     f0117c07 <test_kmalloc_firstfit1+0x161>
f0117bf0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bf7:	83 ec 0c             	sub    $0xc,%esp
f0117bfa:	68 90 b7 12 f0       	push   $0xf012b790
f0117bff:	e8 87 93 fe ff       	call   f0100f8b <cprintf>
f0117c04:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117c07:	e8 86 6f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117c0c:	89 c2                	mov    %eax,%edx
f0117c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c11:	29 d0                	sub    %edx,%eax
f0117c13:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117c18:	7f 17                	jg     f0117c31 <test_kmalloc_firstfit1+0x18b>
f0117c1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c21:	83 ec 0c             	sub    $0xc,%esp
f0117c24:	68 e7 c3 12 f0       	push   $0xf012c3e7
f0117c29:	e8 5d 93 fe ff       	call   f0100f8b <cprintf>
f0117c2e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c31:	e8 5c 6f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117c36:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c39:	e8 55 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117c3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117c41:	83 ec 0c             	sub    $0xc,%esp
f0117c44:	68 00 fc 0f 00       	push   $0xffc00
f0117c49:	e8 6c 1b ff ff       	call   f01097ba <kmalloc>
f0117c4e:	83 c4 10             	add    $0x10,%esp
f0117c51:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117c54:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117c57:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117c5c:	74 17                	je     f0117c75 <test_kmalloc_firstfit1+0x1cf>
f0117c5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c65:	83 ec 0c             	sub    $0xc,%esp
f0117c68:	68 00 c4 12 f0       	push   $0xf012c400
f0117c6d:	e8 19 93 fe ff       	call   f0100f8b <cprintf>
f0117c72:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c75:	e8 19 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117c7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c7d:	74 17                	je     f0117c96 <test_kmalloc_firstfit1+0x1f0>
f0117c7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c86:	83 ec 0c             	sub    $0xc,%esp
f0117c89:	68 cc b8 12 f0       	push   $0xf012b8cc
f0117c8e:	e8 f8 92 fe ff       	call   f0100f8b <cprintf>
f0117c93:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117c96:	e8 f7 6e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117c9b:	89 c2                	mov    %eax,%edx
f0117c9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ca0:	29 d0                	sub    %edx,%eax
f0117ca2:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ca7:	7f 17                	jg     f0117cc0 <test_kmalloc_firstfit1+0x21a>
f0117ca9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cb0:	83 ec 0c             	sub    $0xc,%esp
f0117cb3:	68 33 c4 12 f0       	push   $0xf012c433
f0117cb8:	e8 ce 92 fe ff       	call   f0100f8b <cprintf>
f0117cbd:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117cc0:	e8 cd 6e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117cc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117cc8:	e8 c6 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ccd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117cd0:	83 ec 0c             	sub    $0xc,%esp
f0117cd3:	68 00 fc 0f 00       	push   $0xffc00
f0117cd8:	e8 dd 1a ff ff       	call   f01097ba <kmalloc>
f0117cdd:	83 c4 10             	add    $0x10,%esp
f0117ce0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117ce3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117ce6:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117ceb:	74 17                	je     f0117d04 <test_kmalloc_firstfit1+0x25e>
f0117ced:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cf4:	83 ec 0c             	sub    $0xc,%esp
f0117cf7:	68 4c c4 12 f0       	push   $0xf012c44c
f0117cfc:	e8 8a 92 fe ff       	call   f0100f8b <cprintf>
f0117d01:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d04:	e8 8a cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d0c:	74 17                	je     f0117d25 <test_kmalloc_firstfit1+0x27f>
f0117d0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d15:	83 ec 0c             	sub    $0xc,%esp
f0117d18:	68 c4 b9 12 f0       	push   $0xf012b9c4
f0117d1d:	e8 69 92 fe ff       	call   f0100f8b <cprintf>
f0117d22:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117d25:	e8 68 6e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117d2a:	89 c2                	mov    %eax,%edx
f0117d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d2f:	29 d0                	sub    %edx,%eax
f0117d31:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117d36:	7f 17                	jg     f0117d4f <test_kmalloc_firstfit1+0x2a9>
f0117d38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d3f:	83 ec 0c             	sub    $0xc,%esp
f0117d42:	68 7f c4 12 f0       	push   $0xf012c47f
f0117d47:	e8 3f 92 fe ff       	call   f0100f8b <cprintf>
f0117d4c:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d4f:	e8 3e 6e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117d54:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d57:	e8 37 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117d5f:	83 ec 0c             	sub    $0xc,%esp
f0117d62:	68 00 fc 1f 00       	push   $0x1ffc00
f0117d67:	e8 4e 1a ff ff       	call   f01097ba <kmalloc>
f0117d6c:	83 c4 10             	add    $0x10,%esp
f0117d6f:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117d72:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117d75:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117d7a:	74 17                	je     f0117d93 <test_kmalloc_firstfit1+0x2ed>
f0117d7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d83:	83 ec 0c             	sub    $0xc,%esp
f0117d86:	68 98 c4 12 f0       	push   $0xf012c498
f0117d8b:	e8 fb 91 fe ff       	call   f0100f8b <cprintf>
f0117d90:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d93:	e8 fb cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d98:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d9b:	74 17                	je     f0117db4 <test_kmalloc_firstfit1+0x30e>
f0117d9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117da4:	83 ec 0c             	sub    $0xc,%esp
f0117da7:	68 a4 ba 12 f0       	push   $0xf012baa4
f0117dac:	e8 da 91 fe ff       	call   f0100f8b <cprintf>
f0117db1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117db4:	e8 d9 6d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117db9:	89 c2                	mov    %eax,%edx
f0117dbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117dbe:	29 d0                	sub    %edx,%eax
f0117dc0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117dc5:	7f 17                	jg     f0117dde <test_kmalloc_firstfit1+0x338>
f0117dc7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dce:	83 ec 0c             	sub    $0xc,%esp
f0117dd1:	68 cb c4 12 f0       	push   $0xf012c4cb
f0117dd6:	e8 b0 91 fe ff       	call   f0100f8b <cprintf>
f0117ddb:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117dde:	e8 af 6d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117de3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117de6:	e8 a8 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117deb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117dee:	83 ec 0c             	sub    $0xc,%esp
f0117df1:	68 00 fc 1f 00       	push   $0x1ffc00
f0117df6:	e8 bf 19 ff ff       	call   f01097ba <kmalloc>
f0117dfb:	83 c4 10             	add    $0x10,%esp
f0117dfe:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117e01:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117e04:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117e09:	74 17                	je     f0117e22 <test_kmalloc_firstfit1+0x37c>
f0117e0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e12:	83 ec 0c             	sub    $0xc,%esp
f0117e15:	68 e4 c4 12 f0       	push   $0xf012c4e4
f0117e1a:	e8 6c 91 fe ff       	call   f0100f8b <cprintf>
f0117e1f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e22:	e8 6c cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e27:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e2a:	74 17                	je     f0117e43 <test_kmalloc_firstfit1+0x39d>
f0117e2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e33:	83 ec 0c             	sub    $0xc,%esp
f0117e36:	68 a8 bb 12 f0       	push   $0xf012bba8
f0117e3b:	e8 4b 91 fe ff       	call   f0100f8b <cprintf>
f0117e40:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117e43:	e8 4a 6d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117e48:	89 c2                	mov    %eax,%edx
f0117e4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e4d:	29 d0                	sub    %edx,%eax
f0117e4f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e54:	7f 17                	jg     f0117e6d <test_kmalloc_firstfit1+0x3c7>
f0117e56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e5d:	83 ec 0c             	sub    $0xc,%esp
f0117e60:	68 17 c5 12 f0       	push   $0xf012c517
f0117e65:	e8 21 91 fe ff       	call   f0100f8b <cprintf>
f0117e6a:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e6d:	e8 20 6d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117e72:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e75:	e8 19 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117e7d:	83 ec 0c             	sub    $0xc,%esp
f0117e80:	68 00 fc 2f 00       	push   $0x2ffc00
f0117e85:	e8 30 19 ff ff       	call   f01097ba <kmalloc>
f0117e8a:	83 c4 10             	add    $0x10,%esp
f0117e8d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117e90:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117e93:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117e98:	74 17                	je     f0117eb1 <test_kmalloc_firstfit1+0x40b>
f0117e9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ea1:	83 ec 0c             	sub    $0xc,%esp
f0117ea4:	68 30 c5 12 f0       	push   $0xf012c530
f0117ea9:	e8 dd 90 fe ff       	call   f0100f8b <cprintf>
f0117eae:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117eb1:	e8 dd cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117eb6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117eb9:	74 17                	je     f0117ed2 <test_kmalloc_firstfit1+0x42c>
f0117ebb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ec2:	83 ec 0c             	sub    $0xc,%esp
f0117ec5:	68 ac bc 12 f0       	push   $0xf012bcac
f0117eca:	e8 bc 90 fe ff       	call   f0100f8b <cprintf>
f0117ecf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117ed2:	e8 bb 6c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117ed7:	89 c2                	mov    %eax,%edx
f0117ed9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117edc:	29 d0                	sub    %edx,%eax
f0117ede:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117ee3:	7f 17                	jg     f0117efc <test_kmalloc_firstfit1+0x456>
f0117ee5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117eec:	83 ec 0c             	sub    $0xc,%esp
f0117eef:	68 63 c5 12 f0       	push   $0xf012c563
f0117ef4:	e8 92 90 fe ff       	call   f0100f8b <cprintf>
f0117ef9:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117efc:	e8 91 6c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117f01:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f04:	e8 8a cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f09:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117f0c:	83 ec 0c             	sub    $0xc,%esp
f0117f0f:	68 00 fc 2f 00       	push   $0x2ffc00
f0117f14:	e8 a1 18 ff ff       	call   f01097ba <kmalloc>
f0117f19:	83 c4 10             	add    $0x10,%esp
f0117f1c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117f1f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117f22:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117f27:	74 17                	je     f0117f40 <test_kmalloc_firstfit1+0x49a>
f0117f29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f30:	83 ec 0c             	sub    $0xc,%esp
f0117f33:	68 7c c5 12 f0       	push   $0xf012c57c
f0117f38:	e8 4e 90 fe ff       	call   f0100f8b <cprintf>
f0117f3d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f40:	e8 4e cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f48:	74 17                	je     f0117f61 <test_kmalloc_firstfit1+0x4bb>
f0117f4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f51:	83 ec 0c             	sub    $0xc,%esp
f0117f54:	68 b0 bd 12 f0       	push   $0xf012bdb0
f0117f59:	e8 2d 90 fe ff       	call   f0100f8b <cprintf>
f0117f5e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117f61:	e8 2c 6c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117f66:	89 c2                	mov    %eax,%edx
f0117f68:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f6b:	29 d0                	sub    %edx,%eax
f0117f6d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117f72:	7f 17                	jg     f0117f8b <test_kmalloc_firstfit1+0x4e5>
f0117f74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f7b:	83 ec 0c             	sub    $0xc,%esp
f0117f7e:	68 af c5 12 f0       	push   $0xf012c5af
f0117f83:	e8 03 90 fe ff       	call   f0100f8b <cprintf>
f0117f88:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117f8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117f8f:	74 04                	je     f0117f95 <test_kmalloc_firstfit1+0x4ef>
f0117f91:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117f95:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0117f9c:	83 ec 0c             	sub    $0xc,%esp
f0117f9f:	68 c8 c5 12 f0       	push   $0xf012c5c8
f0117fa4:	e8 e2 8f fe ff       	call   f0100f8b <cprintf>
f0117fa9:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fac:	e8 e1 6b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117fb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fb4:	e8 da ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117fb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117fbc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117fbf:	83 ec 0c             	sub    $0xc,%esp
f0117fc2:	50                   	push   %eax
f0117fc3:	e8 52 1a ff ff       	call   f0109a1a <kfree>
f0117fc8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117fcb:	e8 c3 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117fd0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fd3:	74 17                	je     f0117fec <test_kmalloc_firstfit1+0x546>
f0117fd5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fdc:	83 ec 0c             	sub    $0xc,%esp
f0117fdf:	68 f0 c5 12 f0       	push   $0xf012c5f0
f0117fe4:	e8 a2 8f fe ff       	call   f0100f8b <cprintf>
f0117fe9:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117fec:	e8 a1 6b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0117ff1:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117ff4:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ff9:	7f 17                	jg     f0118012 <test_kmalloc_firstfit1+0x56c>
f0117ffb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118002:	83 ec 0c             	sub    $0xc,%esp
f0118005:	68 5b c6 12 f0       	push   $0xf012c65b
f011800a:	e8 7c 8f fe ff       	call   f0100f8b <cprintf>
f011800f:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118012:	e8 7b 6b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118017:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011801a:	e8 74 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011801f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0118022:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118025:	83 ec 0c             	sub    $0xc,%esp
f0118028:	50                   	push   %eax
f0118029:	e8 ec 19 ff ff       	call   f0109a1a <kfree>
f011802e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118031:	e8 5d ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118036:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118039:	74 17                	je     f0118052 <test_kmalloc_firstfit1+0x5ac>
f011803b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118042:	83 ec 0c             	sub    $0xc,%esp
f0118045:	68 6c c6 12 f0       	push   $0xf012c66c
f011804a:	e8 3c 8f fe ff       	call   f0100f8b <cprintf>
f011804f:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0118052:	e8 3b 6b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118057:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011805a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011805f:	7f 17                	jg     f0118078 <test_kmalloc_firstfit1+0x5d2>
f0118061:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118068:	83 ec 0c             	sub    $0xc,%esp
f011806b:	68 d8 c6 12 f0       	push   $0xf012c6d8
f0118070:	e8 16 8f fe ff       	call   f0100f8b <cprintf>
f0118075:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118078:	e8 15 6b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011807d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118080:	e8 0e ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118085:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0118088:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011808b:	83 ec 0c             	sub    $0xc,%esp
f011808e:	50                   	push   %eax
f011808f:	e8 86 19 ff ff       	call   f0109a1a <kfree>
f0118094:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118097:	e8 f7 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011809c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011809f:	74 17                	je     f01180b8 <test_kmalloc_firstfit1+0x612>
f01180a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180a8:	83 ec 0c             	sub    $0xc,%esp
f01180ab:	68 ec c6 12 f0       	push   $0xf012c6ec
f01180b0:	e8 d6 8e fe ff       	call   f0100f8b <cprintf>
f01180b5:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f01180b8:	e8 d5 6a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01180bd:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01180c0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01180c5:	7f 17                	jg     f01180de <test_kmalloc_firstfit1+0x638>
f01180c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180ce:	83 ec 0c             	sub    $0xc,%esp
f01180d1:	68 58 c7 12 f0       	push   $0xf012c758
f01180d6:	e8 b0 8e fe ff       	call   f0100f8b <cprintf>
f01180db:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01180de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01180e2:	74 04                	je     f01180e8 <test_kmalloc_firstfit1+0x642>
f01180e4:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01180e8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f01180ef:	83 ec 0c             	sub    $0xc,%esp
f01180f2:	68 6c c7 12 f0       	push   $0xf012c76c
f01180f7:	e8 8f 8e fe ff       	call   f0100f8b <cprintf>
f01180fc:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01180ff:	e8 8e 6a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118104:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118107:	e8 87 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011810c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011810f:	83 ec 0c             	sub    $0xc,%esp
f0118112:	68 00 fc 07 00       	push   $0x7fc00
f0118117:	e8 9e 16 ff ff       	call   f01097ba <kmalloc>
f011811c:	83 c4 10             	add    $0x10,%esp
f011811f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0118122:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118125:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011812a:	74 17                	je     f0118143 <test_kmalloc_firstfit1+0x69d>
f011812c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118133:	83 ec 0c             	sub    $0xc,%esp
f0118136:	68 98 c7 12 f0       	push   $0xf012c798
f011813b:	e8 4b 8e fe ff       	call   f0100f8b <cprintf>
f0118140:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118143:	e8 4b c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118148:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011814b:	74 17                	je     f0118164 <test_kmalloc_firstfit1+0x6be>
f011814d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118154:	83 ec 0c             	sub    $0xc,%esp
f0118157:	68 cc c7 12 f0       	push   $0xf012c7cc
f011815c:	e8 2a 8e fe ff       	call   f0100f8b <cprintf>
f0118161:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0118164:	e8 29 6a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118169:	89 c2                	mov    %eax,%edx
f011816b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011816e:	29 d0                	sub    %edx,%eax
f0118170:	83 f8 7f             	cmp    $0x7f,%eax
f0118173:	7f 17                	jg     f011818c <test_kmalloc_firstfit1+0x6e6>
f0118175:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011817c:	83 ec 0c             	sub    $0xc,%esp
f011817f:	68 38 c8 12 f0       	push   $0xf012c838
f0118184:	e8 02 8e fe ff       	call   f0100f8b <cprintf>
f0118189:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011818c:	e8 01 6a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118191:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118194:	e8 fa c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118199:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f011819c:	83 ec 0c             	sub    $0xc,%esp
f011819f:	68 00 fc 0f 00       	push   $0xffc00
f01181a4:	e8 11 16 ff ff       	call   f01097ba <kmalloc>
f01181a9:	83 c4 10             	add    $0x10,%esp
f01181ac:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f01181af:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01181b2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01181b7:	74 17                	je     f01181d0 <test_kmalloc_firstfit1+0x72a>
f01181b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181c0:	83 ec 0c             	sub    $0xc,%esp
f01181c3:	68 50 c8 12 f0       	push   $0xf012c850
f01181c8:	e8 be 8d fe ff       	call   f0100f8b <cprintf>
f01181cd:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181d0:	e8 be c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01181d5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181d8:	74 17                	je     f01181f1 <test_kmalloc_firstfit1+0x74b>
f01181da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181e1:	83 ec 0c             	sub    $0xc,%esp
f01181e4:	68 84 c8 12 f0       	push   $0xf012c884
f01181e9:	e8 9d 8d fe ff       	call   f0100f8b <cprintf>
f01181ee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f01181f1:	e8 9c 69 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01181f6:	89 c2                	mov    %eax,%edx
f01181f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01181fb:	29 d0                	sub    %edx,%eax
f01181fd:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118202:	7f 17                	jg     f011821b <test_kmalloc_firstfit1+0x775>
f0118204:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011820b:	83 ec 0c             	sub    $0xc,%esp
f011820e:	68 f0 c8 12 f0       	push   $0xf012c8f0
f0118213:	e8 73 8d fe ff       	call   f0100f8b <cprintf>
f0118218:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011821b:	e8 72 69 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118220:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118223:	e8 6b c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118228:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011822b:	83 ec 0c             	sub    $0xc,%esp
f011822e:	68 00 fc 03 00       	push   $0x3fc00
f0118233:	e8 82 15 ff ff       	call   f01097ba <kmalloc>
f0118238:	83 c4 10             	add    $0x10,%esp
f011823b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f011823e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118241:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0118246:	74 17                	je     f011825f <test_kmalloc_firstfit1+0x7b9>
f0118248:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011824f:	83 ec 0c             	sub    $0xc,%esp
f0118252:	68 08 c9 12 f0       	push   $0xf012c908
f0118257:	e8 2f 8d fe ff       	call   f0100f8b <cprintf>
f011825c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011825f:	e8 2f c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118264:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118267:	74 17                	je     f0118280 <test_kmalloc_firstfit1+0x7da>
f0118269:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118270:	83 ec 0c             	sub    $0xc,%esp
f0118273:	68 3c c9 12 f0       	push   $0xf012c93c
f0118278:	e8 0e 8d fe ff       	call   f0100f8b <cprintf>
f011827d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0118280:	e8 0d 69 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118285:	89 c2                	mov    %eax,%edx
f0118287:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011828a:	29 d0                	sub    %edx,%eax
f011828c:	83 f8 3f             	cmp    $0x3f,%eax
f011828f:	7f 17                	jg     f01182a8 <test_kmalloc_firstfit1+0x802>
f0118291:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118298:	83 ec 0c             	sub    $0xc,%esp
f011829b:	68 a8 c9 12 f0       	push   $0xf012c9a8
f01182a0:	e8 e6 8c fe ff       	call   f0100f8b <cprintf>
f01182a5:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01182a8:	e8 e5 68 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01182ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182b0:	e8 de c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01182b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f01182b8:	83 ec 0c             	sub    $0xc,%esp
f01182bb:	68 00 00 20 00       	push   $0x200000
f01182c0:	e8 f5 14 ff ff       	call   f01097ba <kmalloc>
f01182c5:	83 c4 10             	add    $0x10,%esp
f01182c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f01182cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01182ce:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01182d3:	74 17                	je     f01182ec <test_kmalloc_firstfit1+0x846>
f01182d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182dc:	83 ec 0c             	sub    $0xc,%esp
f01182df:	68 c0 c9 12 f0       	push   $0xf012c9c0
f01182e4:	e8 a2 8c fe ff       	call   f0100f8b <cprintf>
f01182e9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f01182ec:	e8 a1 68 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01182f1:	89 c2                	mov    %eax,%edx
f01182f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182f6:	29 d0                	sub    %edx,%eax
f01182f8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01182fd:	7f 17                	jg     f0118316 <test_kmalloc_firstfit1+0x870>
f01182ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118306:	83 ec 0c             	sub    $0xc,%esp
f0118309:	68 f4 c9 12 f0       	push   $0xf012c9f4
f011830e:	e8 78 8c fe ff       	call   f0100f8b <cprintf>
f0118313:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118316:	e8 78 c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011831b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011831e:	74 17                	je     f0118337 <test_kmalloc_firstfit1+0x891>
f0118320:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118327:	83 ec 0c             	sub    $0xc,%esp
f011832a:	68 0c ca 12 f0       	push   $0xf012ca0c
f011832f:	e8 57 8c fe ff       	call   f0100f8b <cprintf>
f0118334:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0118337:	e8 56 68 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011833c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011833f:	e8 4f c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118344:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0118347:	83 ec 0c             	sub    $0xc,%esp
f011834a:	68 00 fc 3f 00       	push   $0x3ffc00
f011834f:	e8 66 14 ff ff       	call   f01097ba <kmalloc>
f0118354:	83 c4 10             	add    $0x10,%esp
f0118357:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f011835a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011835d:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0118362:	74 17                	je     f011837b <test_kmalloc_firstfit1+0x8d5>
f0118364:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011836b:	83 ec 0c             	sub    $0xc,%esp
f011836e:	68 78 ca 12 f0       	push   $0xf012ca78
f0118373:	e8 13 8c fe ff       	call   f0100f8b <cprintf>
f0118378:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011837b:	e8 13 c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118380:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118383:	74 17                	je     f011839c <test_kmalloc_firstfit1+0x8f6>
f0118385:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011838c:	83 ec 0c             	sub    $0xc,%esp
f011838f:	68 ac ca 12 f0       	push   $0xf012caac
f0118394:	e8 f2 8b fe ff       	call   f0100f8b <cprintf>
f0118399:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f011839c:	e8 f1 67 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01183a1:	89 c2                	mov    %eax,%edx
f01183a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183a6:	29 d0                	sub    %edx,%eax
f01183a8:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f01183ad:	7f 17                	jg     f01183c6 <test_kmalloc_firstfit1+0x920>
f01183af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183b6:	83 ec 0c             	sub    $0xc,%esp
f01183b9:	68 18 cb 12 f0       	push   $0xf012cb18
f01183be:	e8 c8 8b fe ff       	call   f0100f8b <cprintf>
f01183c3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01183c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01183ca:	74 04                	je     f01183d0 <test_kmalloc_firstfit1+0x92a>
f01183cc:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01183d0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f01183d7:	83 ec 0c             	sub    $0xc,%esp
f01183da:	68 30 cb 12 f0       	push   $0xf012cb30
f01183df:	e8 a7 8b fe ff       	call   f0100f8b <cprintf>
f01183e4:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01183e7:	e8 a6 67 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01183ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183ef:	e8 9f c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01183f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f01183f7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01183fa:	83 ec 0c             	sub    $0xc,%esp
f01183fd:	50                   	push   %eax
f01183fe:	e8 17 16 ff ff       	call   f0109a1a <kfree>
f0118403:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118406:	e8 88 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011840b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011840e:	74 17                	je     f0118427 <test_kmalloc_firstfit1+0x981>
f0118410:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118417:	83 ec 0c             	sub    $0xc,%esp
f011841a:	68 f0 c0 12 f0       	push   $0xf012c0f0
f011841f:	e8 67 8b fe ff       	call   f0100f8b <cprintf>
f0118424:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118427:	e8 66 67 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011842c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011842f:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118434:	7f 17                	jg     f011844d <test_kmalloc_firstfit1+0x9a7>
f0118436:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011843d:	83 ec 0c             	sub    $0xc,%esp
f0118440:	68 64 cb 12 f0       	push   $0xf012cb64
f0118445:	e8 41 8b fe ff       	call   f0100f8b <cprintf>
f011844a:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f011844d:	e8 40 67 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118452:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118455:	e8 39 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011845a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011845d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118460:	83 ec 0c             	sub    $0xc,%esp
f0118463:	50                   	push   %eax
f0118464:	e8 b1 15 ff ff       	call   f0109a1a <kfree>
f0118469:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011846c:	e8 22 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118471:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118474:	74 17                	je     f011848d <test_kmalloc_firstfit1+0x9e7>
f0118476:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011847d:	83 ec 0c             	sub    $0xc,%esp
f0118480:	68 b8 c1 12 f0       	push   $0xf012c1b8
f0118485:	e8 01 8b fe ff       	call   f0100f8b <cprintf>
f011848a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f011848d:	e8 00 67 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118492:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118495:	3d ff 00 00 00       	cmp    $0xff,%eax
f011849a:	7f 17                	jg     f01184b3 <test_kmalloc_firstfit1+0xa0d>
f011849c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184a3:	83 ec 0c             	sub    $0xc,%esp
f01184a6:	68 75 cb 12 f0       	push   $0xf012cb75
f01184ab:	e8 db 8a fe ff       	call   f0100f8b <cprintf>
f01184b0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01184b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01184b7:	74 04                	je     f01184bd <test_kmalloc_firstfit1+0xa17>
f01184b9:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01184bd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f01184c4:	83 ec 0c             	sub    $0xc,%esp
f01184c7:	68 88 cb 12 f0       	push   $0xf012cb88
f01184cc:	e8 ba 8a fe ff       	call   f0100f8b <cprintf>
f01184d1:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f01184d4:	e8 b9 66 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01184d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184dc:	e8 b2 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01184e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f01184e4:	83 ec 0c             	sub    $0xc,%esp
f01184e7:	68 00 00 10 00       	push   $0x100000
f01184ec:	e8 c9 12 ff ff       	call   f01097ba <kmalloc>
f01184f1:	83 c4 10             	add    $0x10,%esp
f01184f4:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f01184f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01184fa:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f01184ff:	74 17                	je     f0118518 <test_kmalloc_firstfit1+0xa72>
f0118501:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118508:	83 ec 0c             	sub    $0xc,%esp
f011850b:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0118510:	e8 76 8a fe ff       	call   f0100f8b <cprintf>
f0118515:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118518:	e8 76 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011851d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118520:	74 17                	je     f0118539 <test_kmalloc_firstfit1+0xa93>
f0118522:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118529:	83 ec 0c             	sub    $0xc,%esp
f011852c:	68 fc cb 12 f0       	push   $0xf012cbfc
f0118531:	e8 55 8a fe ff       	call   f0100f8b <cprintf>
f0118536:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118539:	e8 54 66 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011853e:	89 c2                	mov    %eax,%edx
f0118540:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118543:	29 d0                	sub    %edx,%eax
f0118545:	3d ff 00 00 00       	cmp    $0xff,%eax
f011854a:	7f 17                	jg     f0118563 <test_kmalloc_firstfit1+0xabd>
f011854c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118553:	83 ec 0c             	sub    $0xc,%esp
f0118556:	68 68 cc 12 f0       	push   $0xf012cc68
f011855b:	e8 2b 8a fe ff       	call   f0100f8b <cprintf>
f0118560:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0118563:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118567:	74 04                	je     f011856d <test_kmalloc_firstfit1+0xac7>
f0118569:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f011856d:	83 ec 08             	sub    $0x8,%esp
f0118570:	ff 75 f4             	pushl  -0xc(%ebp)
f0118573:	68 80 cc 12 f0       	push   $0xf012cc80
f0118578:	e8 0e 8a fe ff       	call   f0100f8b <cprintf>
f011857d:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118580:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118585:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0118588:	c9                   	leave  
f0118589:	c3                   	ret    

f011858a <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f011858a:	55                   	push   %ebp
f011858b:	89 e5                	mov    %esp,%ebp
f011858d:	57                   	push   %edi
f011858e:	53                   	push   %ebx
f011858f:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118592:	83 ec 0c             	sub    $0xc,%esp
f0118595:	68 68 b4 12 f0       	push   $0xf012b468
f011859a:	e8 ec 89 fe ff       	call   f0100f8b <cprintf>
f011859f:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01185a2:	83 ec 0c             	sub    $0xc,%esp
f01185a5:	68 98 b4 12 f0       	push   $0xf012b498
f01185aa:	e8 dc 89 fe ff       	call   f0100f8b <cprintf>
f01185af:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01185b2:	83 ec 0c             	sub    $0xc,%esp
f01185b5:	68 68 b4 12 f0       	push   $0xf012b468
f01185ba:	e8 cc 89 fe ff       	call   f0100f8b <cprintf>
f01185bf:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01185c2:	8d 55 98             	lea    -0x68(%ebp),%edx
f01185c5:	b9 14 00 00 00       	mov    $0x14,%ecx
f01185ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01185cf:	89 d7                	mov    %edx,%edi
f01185d1:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01185d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01185da:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01185e1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f01185e8:	83 ec 0c             	sub    $0xc,%esp
f01185eb:	68 b8 cc 12 f0       	push   $0xf012ccb8
f01185f0:	e8 96 89 fe ff       	call   f0100f8b <cprintf>
f01185f5:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f01185f8:	83 ec 0c             	sub    $0xc,%esp
f01185fb:	68 01 e0 ff 07       	push   $0x7ffe001
f0118600:	e8 b5 11 ff ff       	call   f01097ba <kmalloc>
f0118605:	83 c4 10             	add    $0x10,%esp
f0118608:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011860b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011860e:	85 c0                	test   %eax,%eax
f0118610:	74 17                	je     f0118629 <test_kmalloc_firstfit2+0x9f>
f0118612:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118619:	83 ec 0c             	sub    $0xc,%esp
f011861c:	68 ec cc 12 f0       	push   $0xf012ccec
f0118621:	e8 65 89 fe ff       	call   f0100f8b <cprintf>
f0118626:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118629:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011862d:	74 04                	je     f0118633 <test_kmalloc_firstfit2+0xa9>
f011862f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118633:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f011863a:	83 ec 0c             	sub    $0xc,%esp
f011863d:	68 34 cd 12 f0       	push   $0xf012cd34
f0118642:	e8 44 89 fe ff       	call   f0100f8b <cprintf>
f0118647:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011864a:	e8 43 65 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011864f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118652:	e8 3c c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118657:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011865a:	83 ec 0c             	sub    $0xc,%esp
f011865d:	68 00 fc 1f 00       	push   $0x1ffc00
f0118662:	e8 53 11 ff ff       	call   f01097ba <kmalloc>
f0118667:	83 c4 10             	add    $0x10,%esp
f011866a:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f011866d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118670:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118675:	74 17                	je     f011868e <test_kmalloc_firstfit2+0x104>
f0118677:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011867e:	83 ec 0c             	sub    $0xc,%esp
f0118681:	68 b4 c3 12 f0       	push   $0xf012c3b4
f0118686:	e8 00 89 fe ff       	call   f0100f8b <cprintf>
f011868b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011868e:	e8 00 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118693:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118696:	74 17                	je     f01186af <test_kmalloc_firstfit2+0x125>
f0118698:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011869f:	83 ec 0c             	sub    $0xc,%esp
f01186a2:	68 90 b7 12 f0       	push   $0xf012b790
f01186a7:	e8 df 88 fe ff       	call   f0100f8b <cprintf>
f01186ac:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01186af:	e8 de 64 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01186b4:	89 c2                	mov    %eax,%edx
f01186b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186b9:	29 d0                	sub    %edx,%eax
f01186bb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01186c0:	7f 17                	jg     f01186d9 <test_kmalloc_firstfit2+0x14f>
f01186c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186c9:	83 ec 0c             	sub    $0xc,%esp
f01186cc:	68 e7 c3 12 f0       	push   $0xf012c3e7
f01186d1:	e8 b5 88 fe ff       	call   f0100f8b <cprintf>
f01186d6:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186d9:	e8 b4 64 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01186de:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186e1:	e8 ad c3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01186e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01186e9:	83 ec 0c             	sub    $0xc,%esp
f01186ec:	68 00 fc 1f 00       	push   $0x1ffc00
f01186f1:	e8 c4 10 ff ff       	call   f01097ba <kmalloc>
f01186f6:	83 c4 10             	add    $0x10,%esp
f01186f9:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01186fc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01186ff:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118704:	74 17                	je     f011871d <test_kmalloc_firstfit2+0x193>
f0118706:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011870d:	83 ec 0c             	sub    $0xc,%esp
f0118710:	68 00 c4 12 f0       	push   $0xf012c400
f0118715:	e8 71 88 fe ff       	call   f0100f8b <cprintf>
f011871a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011871d:	e8 71 c3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118722:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118725:	74 17                	je     f011873e <test_kmalloc_firstfit2+0x1b4>
f0118727:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011872e:	83 ec 0c             	sub    $0xc,%esp
f0118731:	68 cc b8 12 f0       	push   $0xf012b8cc
f0118736:	e8 50 88 fe ff       	call   f0100f8b <cprintf>
f011873b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f011873e:	e8 4f 64 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118743:	89 c2                	mov    %eax,%edx
f0118745:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118748:	29 d0                	sub    %edx,%eax
f011874a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011874f:	7f 17                	jg     f0118768 <test_kmalloc_firstfit2+0x1de>
f0118751:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118758:	83 ec 0c             	sub    $0xc,%esp
f011875b:	68 33 c4 12 f0       	push   $0xf012c433
f0118760:	e8 26 88 fe ff       	call   f0100f8b <cprintf>
f0118765:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118768:	e8 25 64 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011876d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118770:	e8 1e c3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118775:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0118778:	83 ec 0c             	sub    $0xc,%esp
f011877b:	68 00 1c 00 00       	push   $0x1c00
f0118780:	e8 35 10 ff ff       	call   f01097ba <kmalloc>
f0118785:	83 c4 10             	add    $0x10,%esp
f0118788:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f011878b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011878e:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118793:	74 17                	je     f01187ac <test_kmalloc_firstfit2+0x222>
f0118795:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011879c:	83 ec 0c             	sub    $0xc,%esp
f011879f:	68 4c c4 12 f0       	push   $0xf012c44c
f01187a4:	e8 e2 87 fe ff       	call   f0100f8b <cprintf>
f01187a9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187ac:	e8 e2 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01187b1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01187b4:	74 17                	je     f01187cd <test_kmalloc_firstfit2+0x243>
f01187b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187bd:	83 ec 0c             	sub    $0xc,%esp
f01187c0:	68 c4 b9 12 f0       	push   $0xf012b9c4
f01187c5:	e8 c1 87 fe ff       	call   f0100f8b <cprintf>
f01187ca:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01187cd:	e8 c0 63 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01187d2:	89 c2                	mov    %eax,%edx
f01187d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01187d7:	29 d0                	sub    %edx,%eax
f01187d9:	83 f8 01             	cmp    $0x1,%eax
f01187dc:	7f 17                	jg     f01187f5 <test_kmalloc_firstfit2+0x26b>
f01187de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e5:	83 ec 0c             	sub    $0xc,%esp
f01187e8:	68 7f c4 12 f0       	push   $0xf012c47f
f01187ed:	e8 99 87 fe ff       	call   f0100f8b <cprintf>
f01187f2:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01187f5:	e8 98 63 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01187fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187fd:	e8 91 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118802:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0118805:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118808:	83 ec 0c             	sub    $0xc,%esp
f011880b:	50                   	push   %eax
f011880c:	e8 09 12 ff ff       	call   f0109a1a <kfree>
f0118811:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118814:	e8 7a c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118819:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011881c:	74 17                	je     f0118835 <test_kmalloc_firstfit2+0x2ab>
f011881e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118825:	83 ec 0c             	sub    $0xc,%esp
f0118828:	68 a4 ba 12 f0       	push   $0xf012baa4
f011882d:	e8 59 87 fe ff       	call   f0100f8b <cprintf>
f0118832:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0118835:	e8 58 63 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011883a:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011883d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118842:	7f 17                	jg     f011885b <test_kmalloc_firstfit2+0x2d1>
f0118844:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011884b:	83 ec 0c             	sub    $0xc,%esp
f011884e:	68 7a cd 12 f0       	push   $0xf012cd7a
f0118853:	e8 33 87 fe ff       	call   f0100f8b <cprintf>
f0118858:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011885b:	e8 32 63 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118860:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118863:	e8 2b c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118868:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011886b:	83 ec 0c             	sub    $0xc,%esp
f011886e:	68 00 fc 2f 00       	push   $0x2ffc00
f0118873:	e8 42 0f ff ff       	call   f01097ba <kmalloc>
f0118878:	83 c4 10             	add    $0x10,%esp
f011887b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f011887e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118881:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0118886:	74 17                	je     f011889f <test_kmalloc_firstfit2+0x315>
f0118888:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011888f:	83 ec 0c             	sub    $0xc,%esp
f0118892:	68 e4 c4 12 f0       	push   $0xf012c4e4
f0118897:	e8 ef 86 fe ff       	call   f0100f8b <cprintf>
f011889c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011889f:	e8 ef c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01188a4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188a7:	74 17                	je     f01188c0 <test_kmalloc_firstfit2+0x336>
f01188a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188b0:	83 ec 0c             	sub    $0xc,%esp
f01188b3:	68 a8 bb 12 f0       	push   $0xf012bba8
f01188b8:	e8 ce 86 fe ff       	call   f0100f8b <cprintf>
f01188bd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f01188c0:	e8 cd 62 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01188c5:	89 c2                	mov    %eax,%edx
f01188c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01188ca:	29 d0                	sub    %edx,%eax
f01188cc:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01188d1:	7f 17                	jg     f01188ea <test_kmalloc_firstfit2+0x360>
f01188d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188da:	83 ec 0c             	sub    $0xc,%esp
f01188dd:	68 17 c5 12 f0       	push   $0xf012c517
f01188e2:	e8 a4 86 fe ff       	call   f0100f8b <cprintf>
f01188e7:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01188ea:	e8 a3 62 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01188ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188f2:	e8 9c c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01188f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f01188fa:	83 ec 0c             	sub    $0xc,%esp
f01188fd:	68 00 18 20 00       	push   $0x201800
f0118902:	e8 b3 0e ff ff       	call   f01097ba <kmalloc>
f0118907:	83 c4 10             	add    $0x10,%esp
f011890a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f011890d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118910:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0118915:	74 17                	je     f011892e <test_kmalloc_firstfit2+0x3a4>
f0118917:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011891e:	83 ec 0c             	sub    $0xc,%esp
f0118921:	68 30 c5 12 f0       	push   $0xf012c530
f0118926:	e8 60 86 fe ff       	call   f0100f8b <cprintf>
f011892b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011892e:	e8 60 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118933:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118936:	74 17                	je     f011894f <test_kmalloc_firstfit2+0x3c5>
f0118938:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011893f:	83 ec 0c             	sub    $0xc,%esp
f0118942:	68 ac bc 12 f0       	push   $0xf012bcac
f0118947:	e8 3f 86 fe ff       	call   f0100f8b <cprintf>
f011894c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f011894f:	e8 3e 62 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118954:	89 c2                	mov    %eax,%edx
f0118956:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118959:	29 d0                	sub    %edx,%eax
f011895b:	3d 01 02 00 00       	cmp    $0x201,%eax
f0118960:	7f 17                	jg     f0118979 <test_kmalloc_firstfit2+0x3ef>
f0118962:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118969:	83 ec 0c             	sub    $0xc,%esp
f011896c:	68 63 c5 12 f0       	push   $0xf012c563
f0118971:	e8 15 86 fe ff       	call   f0100f8b <cprintf>
f0118976:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118979:	e8 14 62 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011897e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118981:	e8 0d c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118986:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0118989:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011898c:	83 ec 0c             	sub    $0xc,%esp
f011898f:	50                   	push   %eax
f0118990:	e8 85 10 ff ff       	call   f0109a1a <kfree>
f0118995:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118998:	e8 f6 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011899d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01189a0:	74 17                	je     f01189b9 <test_kmalloc_firstfit2+0x42f>
f01189a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189a9:	83 ec 0c             	sub    $0xc,%esp
f01189ac:	68 b0 bd 12 f0       	push   $0xf012bdb0
f01189b1:	e8 d5 85 fe ff       	call   f0100f8b <cprintf>
f01189b6:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f01189b9:	e8 d4 61 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01189be:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01189c1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01189c6:	7f 17                	jg     f01189df <test_kmalloc_firstfit2+0x455>
f01189c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189cf:	83 ec 0c             	sub    $0xc,%esp
f01189d2:	68 8a cd 12 f0       	push   $0xf012cd8a
f01189d7:	e8 af 85 fe ff       	call   f0100f8b <cprintf>
f01189dc:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01189df:	e8 ae 61 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01189e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189e7:	e8 a7 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01189ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01189ef:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01189f2:	83 ec 0c             	sub    $0xc,%esp
f01189f5:	50                   	push   %eax
f01189f6:	e8 1f 10 ff ff       	call   f0109a1a <kfree>
f01189fb:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f01189fe:	e8 8f 61 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118a03:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118a06:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118a0b:	7f 17                	jg     f0118a24 <test_kmalloc_firstfit2+0x49a>
f0118a0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a14:	83 ec 0c             	sub    $0xc,%esp
f0118a17:	68 5b c6 12 f0       	push   $0xf012c65b
f0118a1c:	e8 6a 85 fe ff       	call   f0100f8b <cprintf>
f0118a21:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a24:	e8 6a c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a29:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a2c:	74 17                	je     f0118a45 <test_kmalloc_firstfit2+0x4bb>
f0118a2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a35:	83 ec 0c             	sub    $0xc,%esp
f0118a38:	68 f0 c5 12 f0       	push   $0xf012c5f0
f0118a3d:	e8 49 85 fe ff       	call   f0100f8b <cprintf>
f0118a42:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118a45:	e8 48 61 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118a4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a4d:	e8 41 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a52:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0118a55:	83 ec 0c             	sub    $0xc,%esp
f0118a58:	68 00 fc 4f 00       	push   $0x4ffc00
f0118a5d:	e8 58 0d ff ff       	call   f01097ba <kmalloc>
f0118a62:	83 c4 10             	add    $0x10,%esp
f0118a65:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118a68:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118a6b:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0118a70:	74 17                	je     f0118a89 <test_kmalloc_firstfit2+0x4ff>
f0118a72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a79:	83 ec 0c             	sub    $0xc,%esp
f0118a7c:	68 9c cd 12 f0       	push   $0xf012cd9c
f0118a81:	e8 05 85 fe ff       	call   f0100f8b <cprintf>
f0118a86:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a89:	e8 05 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a8e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a91:	74 17                	je     f0118aaa <test_kmalloc_firstfit2+0x520>
f0118a93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a9a:	83 ec 0c             	sub    $0xc,%esp
f0118a9d:	68 6c c6 12 f0       	push   $0xf012c66c
f0118aa2:	e8 e4 84 fe ff       	call   f0100f8b <cprintf>
f0118aa7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f0118aaa:	e8 e3 60 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118aaf:	89 c2                	mov    %eax,%edx
f0118ab1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118ab4:	29 d0                	sub    %edx,%eax
f0118ab6:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0118abb:	7f 17                	jg     f0118ad4 <test_kmalloc_firstfit2+0x54a>
f0118abd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ac4:	83 ec 0c             	sub    $0xc,%esp
f0118ac7:	68 d0 cd 12 f0       	push   $0xf012cdd0
f0118acc:	e8 ba 84 fe ff       	call   f0100f8b <cprintf>
f0118ad1:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ad4:	e8 b9 60 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118ad9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118adc:	e8 b2 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ae1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118ae4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118ae7:	83 ec 0c             	sub    $0xc,%esp
f0118aea:	50                   	push   %eax
f0118aeb:	e8 2a 0f ff ff       	call   f0109a1a <kfree>
f0118af0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118af3:	e8 9b bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118af8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118afb:	74 17                	je     f0118b14 <test_kmalloc_firstfit2+0x58a>
f0118afd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b04:	83 ec 0c             	sub    $0xc,%esp
f0118b07:	68 ec c6 12 f0       	push   $0xf012c6ec
f0118b0c:	e8 7a 84 fe ff       	call   f0100f8b <cprintf>
f0118b11:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118b14:	e8 79 60 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118b19:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118b1c:	83 f8 01             	cmp    $0x1,%eax
f0118b1f:	7f 17                	jg     f0118b38 <test_kmalloc_firstfit2+0x5ae>
f0118b21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b28:	83 ec 0c             	sub    $0xc,%esp
f0118b2b:	68 58 c7 12 f0       	push   $0xf012c758
f0118b30:	e8 56 84 fe ff       	call   f0100f8b <cprintf>
f0118b35:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b38:	e8 55 60 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118b3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b40:	e8 4e bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b45:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118b48:	83 ec 0c             	sub    $0xc,%esp
f0118b4b:	68 00 04 00 00       	push   $0x400
f0118b50:	e8 65 0c ff ff       	call   f01097ba <kmalloc>
f0118b55:	83 c4 10             	add    $0x10,%esp
f0118b58:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118b5b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b5e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118b63:	76 22                	jbe    f0118b87 <test_kmalloc_firstfit2+0x5fd>
f0118b65:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118b68:	83 ec 0c             	sub    $0xc,%esp
f0118b6b:	6a 00                	push   $0x0
f0118b6d:	e8 15 0b ff ff       	call   f0109687 <sbrk>
f0118b72:	83 c4 10             	add    $0x10,%esp
f0118b75:	39 c3                	cmp    %eax,%ebx
f0118b77:	73 0e                	jae    f0118b87 <test_kmalloc_firstfit2+0x5fd>
f0118b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b7c:	89 c2                	mov    %eax,%edx
f0118b7e:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118b83:	39 c2                	cmp    %eax,%edx
f0118b85:	72 17                	jb     f0118b9e <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118b87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b8e:	83 ec 0c             	sub    $0xc,%esp
f0118b91:	68 e8 cd 12 f0       	push   $0xf012cde8
f0118b96:	e8 f0 83 fe ff       	call   f0100f8b <cprintf>
f0118b9b:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b9e:	e8 f0 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ba3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ba6:	74 17                	je     f0118bbf <test_kmalloc_firstfit2+0x635>
f0118ba8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118baf:	83 ec 0c             	sub    $0xc,%esp
f0118bb2:	68 cc c7 12 f0       	push   $0xf012c7cc
f0118bb7:	e8 cf 83 fe ff       	call   f0100f8b <cprintf>
f0118bbc:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bbf:	e8 cf be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118bc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118bc7:	83 ec 0c             	sub    $0xc,%esp
f0118bca:	68 00 08 00 00       	push   $0x800
f0118bcf:	e8 e6 0b ff ff       	call   f01097ba <kmalloc>
f0118bd4:	83 c4 10             	add    $0x10,%esp
f0118bd7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118bda:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118bdd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118be2:	76 22                	jbe    f0118c06 <test_kmalloc_firstfit2+0x67c>
f0118be4:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118be7:	83 ec 0c             	sub    $0xc,%esp
f0118bea:	6a 00                	push   $0x0
f0118bec:	e8 96 0a ff ff       	call   f0109687 <sbrk>
f0118bf1:	83 c4 10             	add    $0x10,%esp
f0118bf4:	39 c3                	cmp    %eax,%ebx
f0118bf6:	73 0e                	jae    f0118c06 <test_kmalloc_firstfit2+0x67c>
f0118bf8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118bfb:	89 c2                	mov    %eax,%edx
f0118bfd:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118c02:	39 c2                	cmp    %eax,%edx
f0118c04:	72 17                	jb     f0118c1d <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118c06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c0d:	83 ec 0c             	sub    $0xc,%esp
f0118c10:	68 74 ce 12 f0       	push   $0xf012ce74
f0118c15:	e8 71 83 fe ff       	call   f0100f8b <cprintf>
f0118c1a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c1d:	e8 71 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c22:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c25:	74 17                	je     f0118c3e <test_kmalloc_firstfit2+0x6b4>
f0118c27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c2e:	83 ec 0c             	sub    $0xc,%esp
f0118c31:	68 84 c8 12 f0       	push   $0xf012c884
f0118c36:	e8 50 83 fe ff       	call   f0100f8b <cprintf>
f0118c3b:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c3e:	e8 50 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c43:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118c46:	83 ec 0c             	sub    $0xc,%esp
f0118c49:	68 00 04 00 00       	push   $0x400
f0118c4e:	e8 67 0b ff ff       	call   f01097ba <kmalloc>
f0118c53:	83 c4 10             	add    $0x10,%esp
f0118c56:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118c59:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118c5c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118c61:	76 22                	jbe    f0118c85 <test_kmalloc_firstfit2+0x6fb>
f0118c63:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118c66:	83 ec 0c             	sub    $0xc,%esp
f0118c69:	6a 00                	push   $0x0
f0118c6b:	e8 17 0a ff ff       	call   f0109687 <sbrk>
f0118c70:	83 c4 10             	add    $0x10,%esp
f0118c73:	39 c3                	cmp    %eax,%ebx
f0118c75:	73 0e                	jae    f0118c85 <test_kmalloc_firstfit2+0x6fb>
f0118c77:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118c7a:	89 c2                	mov    %eax,%edx
f0118c7c:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118c81:	39 c2                	cmp    %eax,%edx
f0118c83:	72 17                	jb     f0118c9c <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118c85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c8c:	83 ec 0c             	sub    $0xc,%esp
f0118c8f:	68 00 cf 12 f0       	push   $0xf012cf00
f0118c94:	e8 f2 82 fe ff       	call   f0100f8b <cprintf>
f0118c99:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c9c:	e8 f2 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ca1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ca4:	74 17                	je     f0118cbd <test_kmalloc_firstfit2+0x733>
f0118ca6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cad:	83 ec 0c             	sub    $0xc,%esp
f0118cb0:	68 3c c9 12 f0       	push   $0xf012c93c
f0118cb5:	e8 d1 82 fe ff       	call   f0100f8b <cprintf>
f0118cba:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118cbd:	e8 d0 5e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118cc2:	89 c2                	mov    %eax,%edx
f0118cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118cc7:	29 d0                	sub    %edx,%eax
f0118cc9:	83 f8 01             	cmp    $0x1,%eax
f0118ccc:	74 17                	je     f0118ce5 <test_kmalloc_firstfit2+0x75b>
f0118cce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cd5:	83 ec 0c             	sub    $0xc,%esp
f0118cd8:	68 8c cf 12 f0       	push   $0xf012cf8c
f0118cdd:	e8 a9 82 fe ff       	call   f0100f8b <cprintf>
f0118ce2:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118ce5:	e8 a8 5e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118cea:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ced:	e8 a1 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118cf2:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118cf5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118cf8:	83 ec 0c             	sub    $0xc,%esp
f0118cfb:	50                   	push   %eax
f0118cfc:	e8 19 0d ff ff       	call   f0109a1a <kfree>
f0118d01:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d04:	e8 8a bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d0c:	74 17                	je     f0118d25 <test_kmalloc_firstfit2+0x79b>
f0118d0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d15:	83 ec 0c             	sub    $0xc,%esp
f0118d18:	68 0c ca 12 f0       	push   $0xf012ca0c
f0118d1d:	e8 69 82 fe ff       	call   f0100f8b <cprintf>
f0118d22:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118d25:	e8 68 5e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118d2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118d2d:	74 17                	je     f0118d46 <test_kmalloc_firstfit2+0x7bc>
f0118d2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d36:	83 ec 0c             	sub    $0xc,%esp
f0118d39:	68 b0 cf 12 f0       	push   $0xf012cfb0
f0118d3e:	e8 48 82 fe ff       	call   f0100f8b <cprintf>
f0118d43:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118d46:	e8 47 5e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118d4b:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d4e:	e8 40 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d53:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118d56:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118d59:	83 ec 0c             	sub    $0xc,%esp
f0118d5c:	50                   	push   %eax
f0118d5d:	e8 b8 0c ff ff       	call   f0109a1a <kfree>
f0118d62:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d65:	e8 29 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d6a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d6d:	74 17                	je     f0118d86 <test_kmalloc_firstfit2+0x7fc>
f0118d6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d76:	83 ec 0c             	sub    $0xc,%esp
f0118d79:	68 ac ca 12 f0       	push   $0xf012caac
f0118d7e:	e8 08 82 fe ff       	call   f0100f8b <cprintf>
f0118d83:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118d86:	e8 07 5e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118d8b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118d8e:	74 17                	je     f0118da7 <test_kmalloc_firstfit2+0x81d>
f0118d90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d97:	83 ec 0c             	sub    $0xc,%esp
f0118d9a:	68 10 d0 12 f0       	push   $0xf012d010
f0118d9f:	e8 e7 81 fe ff       	call   f0100f8b <cprintf>
f0118da4:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118da7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118dab:	74 04                	je     f0118db1 <test_kmalloc_firstfit2+0x827>
f0118dad:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118db1:	83 ec 0c             	sub    $0xc,%esp
f0118db4:	68 70 d0 12 f0       	push   $0xf012d070
f0118db9:	e8 cd 81 fe ff       	call   f0100f8b <cprintf>
f0118dbe:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118dc1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118dc8:	e8 c5 5d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118dcd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118dd0:	e8 be bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118dd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118dd8:	83 ec 0c             	sub    $0xc,%esp
f0118ddb:	68 00 08 00 00       	push   $0x800
f0118de0:	e8 d5 09 ff ff       	call   f01097ba <kmalloc>
f0118de5:	83 c4 10             	add    $0x10,%esp
f0118de8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118deb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118dee:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118df1:	39 c2                	cmp    %eax,%edx
f0118df3:	74 17                	je     f0118e0c <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118df5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dfc:	83 ec 0c             	sub    $0xc,%esp
f0118dff:	68 a8 d0 12 f0       	push   $0xf012d0a8
f0118e04:	e8 82 81 fe ff       	call   f0100f8b <cprintf>
f0118e09:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e0c:	e8 82 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e11:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e14:	74 17                	je     f0118e2d <test_kmalloc_firstfit2+0x8a3>
f0118e16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e1d:	83 ec 0c             	sub    $0xc,%esp
f0118e20:	68 f0 c0 12 f0       	push   $0xf012c0f0
f0118e25:	e8 61 81 fe ff       	call   f0100f8b <cprintf>
f0118e2a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118e2d:	e8 60 5d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118e32:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118e35:	74 17                	je     f0118e4e <test_kmalloc_firstfit2+0x8c4>
f0118e37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e3e:	83 ec 0c             	sub    $0xc,%esp
f0118e41:	68 dc d0 12 f0       	push   $0xf012d0dc
f0118e46:	e8 40 81 fe ff       	call   f0100f8b <cprintf>
f0118e4b:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118e4e:	e8 3f 5d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118e53:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e56:	e8 38 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118e5e:	83 ec 0c             	sub    $0xc,%esp
f0118e61:	68 00 04 00 00       	push   $0x400
f0118e66:	e8 4f 09 ff ff       	call   f01097ba <kmalloc>
f0118e6b:	83 c4 10             	add    $0x10,%esp
f0118e6e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118e71:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118e74:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118e77:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118e7d:	39 d0                	cmp    %edx,%eax
f0118e7f:	74 17                	je     f0118e98 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118e81:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e88:	83 ec 0c             	sub    $0xc,%esp
f0118e8b:	68 f4 d0 12 f0       	push   $0xf012d0f4
f0118e90:	e8 f6 80 fe ff       	call   f0100f8b <cprintf>
f0118e95:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e98:	e8 f6 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e9d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ea0:	74 17                	je     f0118eb9 <test_kmalloc_firstfit2+0x92f>
f0118ea2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ea9:	83 ec 0c             	sub    $0xc,%esp
f0118eac:	68 b8 c1 12 f0       	push   $0xf012c1b8
f0118eb1:	e8 d5 80 fe ff       	call   f0100f8b <cprintf>
f0118eb6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118eb9:	e8 d4 5c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118ebe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118ec1:	74 17                	je     f0118eda <test_kmalloc_firstfit2+0x950>
f0118ec3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118eca:	83 ec 0c             	sub    $0xc,%esp
f0118ecd:	68 28 d1 12 f0       	push   $0xf012d128
f0118ed2:	e8 b4 80 fe ff       	call   f0100f8b <cprintf>
f0118ed7:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118eda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118ede:	74 04                	je     f0118ee4 <test_kmalloc_firstfit2+0x95a>
f0118ee0:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118ee4:	83 ec 0c             	sub    $0xc,%esp
f0118ee7:	68 40 d1 12 f0       	push   $0xf012d140
f0118eec:	e8 9a 80 fe ff       	call   f0100f8b <cprintf>
f0118ef1:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118ef4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118efb:	e8 92 5c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118f00:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f03:	e8 8b bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f08:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118f0b:	83 ec 0c             	sub    $0xc,%esp
f0118f0e:	68 00 04 70 00       	push   $0x700400
f0118f13:	e8 a2 08 ff ff       	call   f01097ba <kmalloc>
f0118f18:	83 c4 10             	add    $0x10,%esp
f0118f1b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118f1e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118f21:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118f26:	74 17                	je     f0118f3f <test_kmalloc_firstfit2+0x9b5>
f0118f28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f2f:	83 ec 0c             	sub    $0xc,%esp
f0118f32:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0118f37:	e8 4f 80 fe ff       	call   f0100f8b <cprintf>
f0118f3c:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f3f:	e8 4f bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f47:	74 17                	je     f0118f60 <test_kmalloc_firstfit2+0x9d6>
f0118f49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f50:	83 ec 0c             	sub    $0xc,%esp
f0118f53:	68 fc cb 12 f0       	push   $0xf012cbfc
f0118f58:	e8 2e 80 fe ff       	call   f0100f8b <cprintf>
f0118f5d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118f60:	e8 2d 5c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118f65:	89 c2                	mov    %eax,%edx
f0118f67:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118f6a:	29 d0                	sub    %edx,%eax
f0118f6c:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118f71:	7f 17                	jg     f0118f8a <test_kmalloc_firstfit2+0xa00>
f0118f73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f7a:	83 ec 0c             	sub    $0xc,%esp
f0118f7d:	68 68 cc 12 f0       	push   $0xf012cc68
f0118f82:	e8 04 80 fe ff       	call   f0100f8b <cprintf>
f0118f87:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f8a:	e8 03 5c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118f8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f92:	e8 fc ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f97:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0118f9a:	83 ec 0c             	sub    $0xc,%esp
f0118f9d:	68 00 0c 00 00       	push   $0xc00
f0118fa2:	e8 13 08 ff ff       	call   f01097ba <kmalloc>
f0118fa7:	83 c4 10             	add    $0x10,%esp
f0118faa:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118fad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118fb0:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0118fb5:	74 17                	je     f0118fce <test_kmalloc_firstfit2+0xa44>
f0118fb7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fbe:	83 ec 0c             	sub    $0xc,%esp
f0118fc1:	68 74 d1 12 f0       	push   $0xf012d174
f0118fc6:	e8 c0 7f fe ff       	call   f0100f8b <cprintf>
f0118fcb:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118fce:	e8 c0 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118fd3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118fd6:	74 17                	je     f0118fef <test_kmalloc_firstfit2+0xa65>
f0118fd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fdf:	83 ec 0c             	sub    $0xc,%esp
f0118fe2:	68 a8 d1 12 f0       	push   $0xf012d1a8
f0118fe7:	e8 9f 7f fe ff       	call   f0100f8b <cprintf>
f0118fec:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118fef:	e8 9e 5b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0118ff4:	89 c2                	mov    %eax,%edx
f0118ff6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118ff9:	29 d0                	sub    %edx,%eax
f0118ffb:	85 c0                	test   %eax,%eax
f0118ffd:	7f 17                	jg     f0119016 <test_kmalloc_firstfit2+0xa8c>
f0118fff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119006:	83 ec 0c             	sub    $0xc,%esp
f0119009:	68 14 d2 12 f0       	push   $0xf012d214
f011900e:	e8 78 7f fe ff       	call   f0100f8b <cprintf>
f0119013:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0119016:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011901a:	74 04                	je     f0119020 <test_kmalloc_firstfit2+0xa96>
f011901c:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0119020:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0119027:	83 ec 0c             	sub    $0xc,%esp
f011902a:	68 2c d2 12 f0       	push   $0xf012d22c
f011902f:	e8 57 7f fe ff       	call   f0100f8b <cprintf>
f0119034:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0119037:	83 ec 0c             	sub    $0xc,%esp
f011903a:	68 00 e0 1f 07       	push   $0x71fe000
f011903f:	e8 76 07 ff ff       	call   f01097ba <kmalloc>
f0119044:	83 c4 10             	add    $0x10,%esp
f0119047:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f011904a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011904d:	85 c0                	test   %eax,%eax
f011904f:	74 17                	je     f0119068 <test_kmalloc_firstfit2+0xade>
f0119051:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119058:	83 ec 0c             	sub    $0xc,%esp
f011905b:	68 80 d2 12 f0       	push   $0xf012d280
f0119060:	e8 26 7f fe ff       	call   f0100f8b <cprintf>
f0119065:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0119068:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011906c:	74 04                	je     f0119072 <test_kmalloc_firstfit2+0xae8>
f011906e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0119072:	83 ec 08             	sub    $0x8,%esp
f0119075:	ff 75 f4             	pushl  -0xc(%ebp)
f0119078:	68 e8 d2 12 f0       	push   $0xf012d2e8
f011907d:	e8 09 7f fe ff       	call   f0100f8b <cprintf>
f0119082:	83 c4 10             	add    $0x10,%esp

	return 1;
f0119085:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011908a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011908d:	5b                   	pop    %ebx
f011908e:	5f                   	pop    %edi
f011908f:	5d                   	pop    %ebp
f0119090:	c3                   	ret    

f0119091 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0119091:	55                   	push   %ebp
f0119092:	89 e5                	mov    %esp,%ebp
f0119094:	53                   	push   %ebx
f0119095:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119098:	83 ec 0c             	sub    $0xc,%esp
f011909b:	68 68 b4 12 f0       	push   $0xf012b468
f01190a0:	e8 e6 7e fe ff       	call   f0100f8b <cprintf>
f01190a5:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01190a8:	83 ec 0c             	sub    $0xc,%esp
f01190ab:	68 98 b4 12 f0       	push   $0xf012b498
f01190b0:	e8 d6 7e fe ff       	call   f0100f8b <cprintf>
f01190b5:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01190b8:	83 ec 0c             	sub    $0xc,%esp
f01190bb:	68 68 b4 12 f0       	push   $0xf012b468
f01190c0:	e8 c6 7e fe ff       	call   f0100f8b <cprintf>
f01190c5:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f01190c8:	e8 c5 5a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01190cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f01190d0:	e8 be b9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01190d5:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f01190d8:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f01190df:	83 ec 0c             	sub    $0xc,%esp
f01190e2:	68 1d d3 12 f0       	push   $0xf012d31d
f01190e7:	e8 9f 7e fe ff       	call   f0100f8b <cprintf>
f01190ec:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f01190ef:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f01190f4:	ba 00 00 00 00       	mov    $0x0,%edx
f01190f9:	f7 75 e4             	divl   -0x1c(%ebp)
f01190fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f01190ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119106:	eb 1d                	jmp    f0119125 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0119108:	83 ec 0c             	sub    $0xc,%esp
f011910b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011910e:	e8 a7 06 ff ff       	call   f01097ba <kmalloc>
f0119113:	83 c4 10             	add    $0x10,%esp
f0119116:	89 c2                	mov    %eax,%edx
f0119118:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011911b:	89 14 85 20 6e 6f f0 	mov    %edx,-0xf9091e0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0119122:	ff 45 f4             	incl   -0xc(%ebp)
f0119125:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119128:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011912b:	7c db                	jl     f0119108 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f011912d:	83 ec 0c             	sub    $0xc,%esp
f0119130:	68 21 d3 12 f0       	push   $0xf012d321
f0119135:	e8 51 7e fe ff       	call   f0100f8b <cprintf>
f011913a:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f011913d:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0119142:	ba 00 00 00 00       	mov    $0x0,%edx
f0119147:	f7 75 e4             	divl   -0x1c(%ebp)
f011914a:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f011914d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0119151:	74 1e                	je     f0119171 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0119153:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0119156:	8d 43 01             	lea    0x1(%ebx),%eax
f0119159:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011915c:	83 ec 0c             	sub    $0xc,%esp
f011915f:	ff 75 e0             	pushl  -0x20(%ebp)
f0119162:	e8 53 06 ff ff       	call   f01097ba <kmalloc>
f0119167:	83 c4 10             	add    $0x10,%esp
f011916a:	89 04 9d 20 6e 6f f0 	mov    %eax,-0xf9091e0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0119171:	83 ec 04             	sub    $0x4,%esp
f0119174:	ff 75 f0             	pushl  -0x10(%ebp)
f0119177:	ff 75 e4             	pushl  -0x1c(%ebp)
f011917a:	68 28 d3 12 f0       	push   $0xf012d328
f011917f:	e8 07 7e fe ff       	call   f0100f8b <cprintf>
f0119184:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0119187:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011918e:	eb 36                	jmp    f01191c6 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0119190:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119193:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f011919a:	89 c2                	mov    %eax,%edx
f011919c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011919f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01191a3:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f01191a8:	39 c2                	cmp    %eax,%edx
f01191aa:	74 17                	je     f01191c3 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f01191ac:	83 ec 04             	sub    $0x4,%esp
f01191af:	68 70 d3 12 f0       	push   $0xf012d370
f01191b4:	68 e3 02 00 00       	push   $0x2e3
f01191b9:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01191be:	e8 76 71 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01191c3:	ff 45 f4             	incl   -0xc(%ebp)
f01191c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01191c9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01191cc:	7c c2                	jl     f0119190 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01191ce:	e8 c0 b8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01191d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01191d6:	74 17                	je     f01191ef <test_fastfirstfit+0x15e>
f01191d8:	83 ec 04             	sub    $0x4,%esp
f01191db:	68 cc d3 12 f0       	push   $0xf012d3cc
f01191e0:	68 e6 02 00 00       	push   $0x2e6
f01191e5:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01191ea:	e8 4a 71 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f01191ef:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01191f2:	e8 9b 59 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01191f7:	29 c3                	sub    %eax,%ebx
f01191f9:	89 d8                	mov    %ebx,%eax
f01191fb:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0119200:	77 17                	ja     f0119219 <test_fastfirstfit+0x188>
f0119202:	83 ec 04             	sub    $0x4,%esp
f0119205:	68 34 d4 12 f0       	push   $0xf012d434
f011920a:	68 e7 02 00 00       	push   $0x2e7
f011920f:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119214:	e8 20 71 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0119219:	e8 75 b8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011921e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0119221:	e8 6c 59 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119226:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0119229:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f011922d:	7f 17                	jg     f0119246 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f011922f:	83 ec 04             	sub    $0x4,%esp
f0119232:	68 48 d4 12 f0       	push   $0xf012d448
f0119237:	68 ee 02 00 00       	push   $0x2ee
f011923c:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119241:	e8 f3 70 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0119246:	a1 20 6e 6f f0       	mov    0xf06f6e20,%eax
f011924b:	83 ec 0c             	sub    $0xc,%esp
f011924e:	50                   	push   %eax
f011924f:	e8 c6 07 ff ff       	call   f0109a1a <kfree>
f0119254:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0119257:	a1 28 6e 6f f0       	mov    0xf06f6e28,%eax
f011925c:	83 ec 0c             	sub    $0xc,%esp
f011925f:	50                   	push   %eax
f0119260:	e8 b5 07 ff ff       	call   f0109a1a <kfree>
f0119265:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0119268:	a1 2c 6e 6f f0       	mov    0xf06f6e2c,%eax
f011926d:	83 ec 0c             	sub    $0xc,%esp
f0119270:	50                   	push   %eax
f0119271:	e8 a4 07 ff ff       	call   f0109a1a <kfree>
f0119276:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0119279:	a1 34 6e 6f f0       	mov    0xf06f6e34,%eax
f011927e:	83 ec 0c             	sub    $0xc,%esp
f0119281:	50                   	push   %eax
f0119282:	e8 93 07 ff ff       	call   f0109a1a <kfree>
f0119287:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f011928a:	a1 48 6e 6f f0       	mov    0xf06f6e48,%eax
f011928f:	83 ec 0c             	sub    $0xc,%esp
f0119292:	50                   	push   %eax
f0119293:	e8 82 07 ff ff       	call   f0109a1a <kfree>
f0119298:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f011929b:	a1 50 6e 6f f0       	mov    0xf06f6e50,%eax
f01192a0:	83 ec 0c             	sub    $0xc,%esp
f01192a3:	50                   	push   %eax
f01192a4:	e8 71 07 ff ff       	call   f0109a1a <kfree>
f01192a9:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f01192ac:	a1 4c 6e 6f f0       	mov    0xf06f6e4c,%eax
f01192b1:	83 ec 0c             	sub    $0xc,%esp
f01192b4:	50                   	push   %eax
f01192b5:	e8 60 07 ff ff       	call   f0109a1a <kfree>
f01192ba:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f01192bd:	a1 70 6e 6f f0       	mov    0xf06f6e70,%eax
f01192c2:	83 ec 0c             	sub    $0xc,%esp
f01192c5:	50                   	push   %eax
f01192c6:	e8 4f 07 ff ff       	call   f0109a1a <kfree>
f01192cb:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f01192ce:	a1 84 6e 6f f0       	mov    0xf06f6e84,%eax
f01192d3:	83 ec 0c             	sub    $0xc,%esp
f01192d6:	50                   	push   %eax
f01192d7:	e8 3e 07 ff ff       	call   f0109a1a <kfree>
f01192dc:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f01192df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01192e2:	83 e8 02             	sub    $0x2,%eax
f01192e5:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f01192ec:	83 ec 0c             	sub    $0xc,%esp
f01192ef:	50                   	push   %eax
f01192f0:	e8 25 07 ff ff       	call   f0109a1a <kfree>
f01192f5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f01192f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01192fb:	83 e8 03             	sub    $0x3,%eax
f01192fe:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f0119305:	83 ec 0c             	sub    $0xc,%esp
f0119308:	50                   	push   %eax
f0119309:	e8 0c 07 ff ff       	call   f0109a1a <kfree>
f011930e:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119311:	e8 7d b7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119316:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119319:	74 17                	je     f0119332 <test_fastfirstfit+0x2a1>
f011931b:	83 ec 04             	sub    $0x4,%esp
f011931e:	68 cc d3 12 f0       	push   $0xf012d3cc
f0119323:	68 fb 02 00 00       	push   $0x2fb
f0119328:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011932d:	e8 07 70 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0119332:	e8 5b 58 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119337:	89 c2                	mov    %eax,%edx
f0119339:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011933c:	89 d1                	mov    %edx,%ecx
f011933e:	29 c1                	sub    %eax,%ecx
f0119340:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119343:	89 d0                	mov    %edx,%eax
f0119345:	c1 e0 02             	shl    $0x2,%eax
f0119348:	01 d0                	add    %edx,%eax
f011934a:	01 c0                	add    %eax,%eax
f011934c:	01 d0                	add    %edx,%eax
f011934e:	c1 e8 0c             	shr    $0xc,%eax
f0119351:	39 c1                	cmp    %eax,%ecx
f0119353:	74 17                	je     f011936c <test_fastfirstfit+0x2db>
f0119355:	83 ec 04             	sub    $0x4,%esp
f0119358:	68 84 d4 12 f0       	push   $0xf012d484
f011935d:	68 fc 02 00 00       	push   $0x2fc
f0119362:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119367:	e8 cd 6f fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f011936c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011936f:	01 c0                	add    %eax,%eax
f0119371:	89 c2                	mov    %eax,%edx
f0119373:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119376:	d1 e8                	shr    %eax
f0119378:	01 d0                	add    %edx,%eax
f011937a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011937d:	e8 11 b7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119382:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119385:	e8 08 58 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011938a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011938d:	83 ec 0c             	sub    $0xc,%esp
f0119390:	ff 75 dc             	pushl  -0x24(%ebp)
f0119393:	e8 22 04 ff ff       	call   f01097ba <kmalloc>
f0119398:	83 c4 10             	add    $0x10,%esp
f011939b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f011939e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01193a1:	89 d0                	mov    %edx,%eax
f01193a3:	c1 e0 02             	shl    $0x2,%eax
f01193a6:	01 d0                	add    %edx,%eax
f01193a8:	01 c0                	add    %eax,%eax
f01193aa:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01193b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01193b3:	39 c2                	cmp    %eax,%edx
f01193b5:	74 17                	je     f01193ce <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f01193b7:	83 ec 04             	sub    $0x4,%esp
f01193ba:	68 c4 d4 12 f0       	push   $0xf012d4c4
f01193bf:	68 07 03 00 00       	push   $0x307
f01193c4:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01193c9:	e8 6b 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01193ce:	e8 c0 b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01193d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193d6:	74 17                	je     f01193ef <test_fastfirstfit+0x35e>
f01193d8:	83 ec 04             	sub    $0x4,%esp
f01193db:	68 cc d3 12 f0       	push   $0xf012d3cc
f01193e0:	68 08 03 00 00       	push   $0x308
f01193e5:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01193ea:	e8 4a 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01193ef:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01193f2:	e8 9b 57 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01193f7:	29 c3                	sub    %eax,%ebx
f01193f9:	89 da                	mov    %ebx,%edx
f01193fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01193fe:	c1 e8 0c             	shr    $0xc,%eax
f0119401:	39 c2                	cmp    %eax,%edx
f0119403:	73 17                	jae    f011941c <test_fastfirstfit+0x38b>
f0119405:	83 ec 04             	sub    $0x4,%esp
f0119408:	68 34 d4 12 f0       	push   $0xf012d434
f011940d:	68 09 03 00 00       	push   $0x309
f0119412:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119417:	e8 1d 6f fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f011941c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011941f:	01 c0                	add    %eax,%eax
f0119421:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119424:	e8 6a b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119429:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011942c:	e8 61 57 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119431:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119434:	83 ec 0c             	sub    $0xc,%esp
f0119437:	ff 75 dc             	pushl  -0x24(%ebp)
f011943a:	e8 7b 03 ff ff       	call   f01097ba <kmalloc>
f011943f:	83 c4 10             	add    $0x10,%esp
f0119442:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0119445:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119448:	05 00 08 00 7c       	add    $0x7c000800,%eax
f011944d:	01 c0                	add    %eax,%eax
f011944f:	89 c2                	mov    %eax,%edx
f0119451:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119454:	39 c2                	cmp    %eax,%edx
f0119456:	74 17                	je     f011946f <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0119458:	83 ec 04             	sub    $0x4,%esp
f011945b:	68 c4 d4 12 f0       	push   $0xf012d4c4
f0119460:	68 13 03 00 00       	push   $0x313
f0119465:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011946a:	e8 ca 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011946f:	e8 1f b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119474:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119477:	74 17                	je     f0119490 <test_fastfirstfit+0x3ff>
f0119479:	83 ec 04             	sub    $0x4,%esp
f011947c:	68 cc d3 12 f0       	push   $0xf012d3cc
f0119481:	68 14 03 00 00       	push   $0x314
f0119486:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011948b:	e8 a9 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119490:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119493:	e8 fa 56 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119498:	29 c3                	sub    %eax,%ebx
f011949a:	89 da                	mov    %ebx,%edx
f011949c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011949f:	c1 e8 0c             	shr    $0xc,%eax
f01194a2:	39 c2                	cmp    %eax,%edx
f01194a4:	73 17                	jae    f01194bd <test_fastfirstfit+0x42c>
f01194a6:	83 ec 04             	sub    $0x4,%esp
f01194a9:	68 34 d4 12 f0       	push   $0xf012d434
f01194ae:	68 15 03 00 00       	push   $0x315
f01194b3:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01194b8:	e8 7c 6e fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f01194bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194c0:	89 c2                	mov    %eax,%edx
f01194c2:	01 d2                	add    %edx,%edx
f01194c4:	01 d0                	add    %edx,%eax
f01194c6:	d1 e8                	shr    %eax
f01194c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01194cb:	e8 c3 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01194d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01194d3:	e8 ba 56 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01194d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01194db:	83 ec 0c             	sub    $0xc,%esp
f01194de:	ff 75 dc             	pushl  -0x24(%ebp)
f01194e1:	e8 d4 02 ff ff       	call   f01097ba <kmalloc>
f01194e6:	83 c4 10             	add    $0x10,%esp
f01194e9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f01194ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01194ef:	83 e8 03             	sub    $0x3,%eax
f01194f2:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01194f6:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01194fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01194ff:	39 c2                	cmp    %eax,%edx
f0119501:	74 17                	je     f011951a <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0119503:	83 ec 04             	sub    $0x4,%esp
f0119506:	68 c4 d4 12 f0       	push   $0xf012d4c4
f011950b:	68 1f 03 00 00       	push   $0x31f
f0119510:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119515:	e8 1f 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011951a:	e8 74 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011951f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119522:	74 17                	je     f011953b <test_fastfirstfit+0x4aa>
f0119524:	83 ec 04             	sub    $0x4,%esp
f0119527:	68 cc d3 12 f0       	push   $0xf012d3cc
f011952c:	68 20 03 00 00       	push   $0x320
f0119531:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119536:	e8 fe 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011953b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011953e:	e8 4f 56 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119543:	29 c3                	sub    %eax,%ebx
f0119545:	89 da                	mov    %ebx,%edx
f0119547:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011954a:	c1 e8 0c             	shr    $0xc,%eax
f011954d:	39 c2                	cmp    %eax,%edx
f011954f:	73 17                	jae    f0119568 <test_fastfirstfit+0x4d7>
f0119551:	83 ec 04             	sub    $0x4,%esp
f0119554:	68 34 d4 12 f0       	push   $0xf012d434
f0119559:	68 21 03 00 00       	push   $0x321
f011955e:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119563:	e8 d1 6d fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119568:	e8 26 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011956d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119570:	e8 1d 56 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119575:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119578:	83 ec 0c             	sub    $0xc,%esp
f011957b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011957e:	e8 37 02 ff ff       	call   f01097ba <kmalloc>
f0119583:	83 c4 10             	add    $0x10,%esp
f0119586:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0119589:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011958c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119591:	74 17                	je     f01195aa <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119593:	83 ec 04             	sub    $0x4,%esp
f0119596:	68 c4 d4 12 f0       	push   $0xf012d4c4
f011959b:	68 2a 03 00 00       	push   $0x32a
f01195a0:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01195a5:	e8 8f 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01195aa:	e8 e4 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01195af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195b2:	74 17                	je     f01195cb <test_fastfirstfit+0x53a>
f01195b4:	83 ec 04             	sub    $0x4,%esp
f01195b7:	68 cc d3 12 f0       	push   $0xf012d3cc
f01195bc:	68 2b 03 00 00       	push   $0x32b
f01195c1:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01195c6:	e8 6e 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01195cb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01195ce:	e8 bf 55 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01195d3:	29 c3                	sub    %eax,%ebx
f01195d5:	89 da                	mov    %ebx,%edx
f01195d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195da:	c1 e8 0c             	shr    $0xc,%eax
f01195dd:	39 c2                	cmp    %eax,%edx
f01195df:	73 17                	jae    f01195f8 <test_fastfirstfit+0x567>
f01195e1:	83 ec 04             	sub    $0x4,%esp
f01195e4:	68 34 d4 12 f0       	push   $0xf012d434
f01195e9:	68 2c 03 00 00       	push   $0x32c
f01195ee:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01195f3:	e8 41 6d fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01195f8:	e8 96 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01195fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119600:	e8 8d 55 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119605:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119608:	83 ec 0c             	sub    $0xc,%esp
f011960b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011960e:	e8 a7 01 ff ff       	call   f01097ba <kmalloc>
f0119613:	83 c4 10             	add    $0x10,%esp
f0119616:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119619:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011961c:	89 d0                	mov    %edx,%eax
f011961e:	c1 e0 02             	shl    $0x2,%eax
f0119621:	01 d0                	add    %edx,%eax
f0119623:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119629:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011962c:	39 c2                	cmp    %eax,%edx
f011962e:	74 17                	je     f0119647 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0119630:	83 ec 04             	sub    $0x4,%esp
f0119633:	68 c4 d4 12 f0       	push   $0xf012d4c4
f0119638:	68 35 03 00 00       	push   $0x335
f011963d:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119642:	e8 f2 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119647:	e8 47 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011964c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011964f:	74 17                	je     f0119668 <test_fastfirstfit+0x5d7>
f0119651:	83 ec 04             	sub    $0x4,%esp
f0119654:	68 cc d3 12 f0       	push   $0xf012d3cc
f0119659:	68 36 03 00 00       	push   $0x336
f011965e:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119663:	e8 d1 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119668:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011966b:	e8 22 55 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119670:	29 c3                	sub    %eax,%ebx
f0119672:	89 da                	mov    %ebx,%edx
f0119674:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119677:	c1 e8 0c             	shr    $0xc,%eax
f011967a:	39 c2                	cmp    %eax,%edx
f011967c:	73 17                	jae    f0119695 <test_fastfirstfit+0x604>
f011967e:	83 ec 04             	sub    $0x4,%esp
f0119681:	68 34 d4 12 f0       	push   $0xf012d434
f0119686:	68 37 03 00 00       	push   $0x337
f011968b:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119690:	e8 a4 6c fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119695:	e8 f9 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011969a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011969d:	e8 f0 54 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01196a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01196a5:	83 ec 0c             	sub    $0xc,%esp
f01196a8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01196ab:	e8 0a 01 ff ff       	call   f01097ba <kmalloc>
f01196b0:	83 c4 10             	add    $0x10,%esp
f01196b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f01196b6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01196b9:	89 d0                	mov    %edx,%eax
f01196bb:	c1 e0 02             	shl    $0x2,%eax
f01196be:	01 d0                	add    %edx,%eax
f01196c0:	c1 e0 02             	shl    $0x2,%eax
f01196c3:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01196c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01196cc:	39 c2                	cmp    %eax,%edx
f01196ce:	74 17                	je     f01196e7 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f01196d0:	83 ec 04             	sub    $0x4,%esp
f01196d3:	68 c4 d4 12 f0       	push   $0xf012d4c4
f01196d8:	68 40 03 00 00       	push   $0x340
f01196dd:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01196e2:	e8 52 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01196e7:	e8 a7 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01196ec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01196ef:	74 17                	je     f0119708 <test_fastfirstfit+0x677>
f01196f1:	83 ec 04             	sub    $0x4,%esp
f01196f4:	68 cc d3 12 f0       	push   $0xf012d3cc
f01196f9:	68 41 03 00 00       	push   $0x341
f01196fe:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119703:	e8 31 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119708:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011970b:	e8 82 54 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119710:	29 c3                	sub    %eax,%ebx
f0119712:	89 da                	mov    %ebx,%edx
f0119714:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119717:	c1 e8 0c             	shr    $0xc,%eax
f011971a:	39 c2                	cmp    %eax,%edx
f011971c:	73 17                	jae    f0119735 <test_fastfirstfit+0x6a4>
f011971e:	83 ec 04             	sub    $0x4,%esp
f0119721:	68 34 d4 12 f0       	push   $0xf012d434
f0119726:	68 42 03 00 00       	push   $0x342
f011972b:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119730:	e8 04 6c fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119735:	e8 59 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011973a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011973d:	e8 50 54 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119742:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119745:	83 ec 0c             	sub    $0xc,%esp
f0119748:	ff 75 e4             	pushl  -0x1c(%ebp)
f011974b:	e8 6a 00 ff ff       	call   f01097ba <kmalloc>
f0119750:	83 c4 10             	add    $0x10,%esp
f0119753:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0119756:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119759:	89 d0                	mov    %edx,%eax
f011975b:	c1 e0 02             	shl    $0x2,%eax
f011975e:	01 d0                	add    %edx,%eax
f0119760:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119767:	01 d0                	add    %edx,%eax
f0119769:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011976f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119772:	39 c2                	cmp    %eax,%edx
f0119774:	74 17                	je     f011978d <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0119776:	83 ec 04             	sub    $0x4,%esp
f0119779:	68 c4 d4 12 f0       	push   $0xf012d4c4
f011977e:	68 4b 03 00 00       	push   $0x34b
f0119783:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119788:	e8 ac 6b fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011978d:	e8 01 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119792:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119795:	74 17                	je     f01197ae <test_fastfirstfit+0x71d>
f0119797:	83 ec 04             	sub    $0x4,%esp
f011979a:	68 cc d3 12 f0       	push   $0xf012d3cc
f011979f:	68 4c 03 00 00       	push   $0x34c
f01197a4:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01197a9:	e8 8b 6b fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01197ae:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01197b1:	e8 dc 53 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01197b6:	29 c3                	sub    %eax,%ebx
f01197b8:	89 da                	mov    %ebx,%edx
f01197ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197bd:	c1 e8 0c             	shr    $0xc,%eax
f01197c0:	39 c2                	cmp    %eax,%edx
f01197c2:	73 17                	jae    f01197db <test_fastfirstfit+0x74a>
f01197c4:	83 ec 04             	sub    $0x4,%esp
f01197c7:	68 34 d4 12 f0       	push   $0xf012d434
f01197cc:	68 4d 03 00 00       	push   $0x34d
f01197d1:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01197d6:	e8 5e 6b fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01197db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197de:	d1 e8                	shr    %eax
f01197e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01197e3:	e8 ab b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01197e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01197eb:	e8 a2 53 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01197f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01197f3:	83 ec 0c             	sub    $0xc,%esp
f01197f6:	ff 75 dc             	pushl  -0x24(%ebp)
f01197f9:	e8 bc ff fe ff       	call   f01097ba <kmalloc>
f01197fe:	83 c4 10             	add    $0x10,%esp
f0119801:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0119804:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119807:	89 d0                	mov    %edx,%eax
f0119809:	c1 e0 02             	shl    $0x2,%eax
f011980c:	01 d0                	add    %edx,%eax
f011980e:	01 c0                	add    %eax,%eax
f0119810:	89 c1                	mov    %eax,%ecx
f0119812:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119815:	89 d0                	mov    %edx,%eax
f0119817:	c1 e0 02             	shl    $0x2,%eax
f011981a:	01 d0                	add    %edx,%eax
f011981c:	d1 e8                	shr    %eax
f011981e:	01 c8                	add    %ecx,%eax
f0119820:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119826:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119829:	39 c2                	cmp    %eax,%edx
f011982b:	74 17                	je     f0119844 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f011982d:	83 ec 04             	sub    $0x4,%esp
f0119830:	68 c4 d4 12 f0       	push   $0xf012d4c4
f0119835:	68 57 03 00 00       	push   $0x357
f011983a:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011983f:	e8 f5 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119844:	e8 4a b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119849:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011984c:	74 17                	je     f0119865 <test_fastfirstfit+0x7d4>
f011984e:	83 ec 04             	sub    $0x4,%esp
f0119851:	68 cc d3 12 f0       	push   $0xf012d3cc
f0119856:	68 58 03 00 00       	push   $0x358
f011985b:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119860:	e8 d4 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119865:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119868:	e8 25 53 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011986d:	29 c3                	sub    %eax,%ebx
f011986f:	89 da                	mov    %ebx,%edx
f0119871:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119874:	c1 e8 0c             	shr    $0xc,%eax
f0119877:	39 c2                	cmp    %eax,%edx
f0119879:	73 17                	jae    f0119892 <test_fastfirstfit+0x801>
f011987b:	83 ec 04             	sub    $0x4,%esp
f011987e:	68 34 d4 12 f0       	push   $0xf012d434
f0119883:	68 59 03 00 00       	push   $0x359
f0119888:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011988d:	e8 a7 6a fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119892:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119895:	d1 e8                	shr    %eax
f0119897:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011989a:	e8 f4 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011989f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01198a2:	e8 eb 52 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01198a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01198aa:	83 ec 0c             	sub    $0xc,%esp
f01198ad:	ff 75 dc             	pushl  -0x24(%ebp)
f01198b0:	e8 05 ff fe ff       	call   f01097ba <kmalloc>
f01198b5:	83 c4 10             	add    $0x10,%esp
f01198b8:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f01198bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01198be:	83 e8 03             	sub    $0x3,%eax
f01198c1:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01198c5:	89 c2                	mov    %eax,%edx
f01198c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01198ca:	89 c1                	mov    %eax,%ecx
f01198cc:	01 c9                	add    %ecx,%ecx
f01198ce:	01 c8                	add    %ecx,%eax
f01198d0:	d1 e8                	shr    %eax
f01198d2:	01 d0                	add    %edx,%eax
f01198d4:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01198da:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01198dd:	39 c2                	cmp    %eax,%edx
f01198df:	74 17                	je     f01198f8 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f01198e1:	83 ec 04             	sub    $0x4,%esp
f01198e4:	68 c4 d4 12 f0       	push   $0xf012d4c4
f01198e9:	68 63 03 00 00       	push   $0x363
f01198ee:	68 b3 d3 12 f0       	push   $0xf012d3b3
f01198f3:	e8 41 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01198f8:	e8 96 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01198fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119900:	74 17                	je     f0119919 <test_fastfirstfit+0x888>
f0119902:	83 ec 04             	sub    $0x4,%esp
f0119905:	68 cc d3 12 f0       	push   $0xf012d3cc
f011990a:	68 64 03 00 00       	push   $0x364
f011990f:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119914:	e8 20 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119919:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011991c:	e8 71 52 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119921:	29 c3                	sub    %eax,%ebx
f0119923:	89 da                	mov    %ebx,%edx
f0119925:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119928:	c1 e8 0c             	shr    $0xc,%eax
f011992b:	39 c2                	cmp    %eax,%edx
f011992d:	73 17                	jae    f0119946 <test_fastfirstfit+0x8b5>
f011992f:	83 ec 04             	sub    $0x4,%esp
f0119932:	68 34 d4 12 f0       	push   $0xf012d434
f0119937:	68 65 03 00 00       	push   $0x365
f011993c:	68 b3 d3 12 f0       	push   $0xf012d3b3
f0119941:	e8 f3 69 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0119946:	83 ec 0c             	sub    $0xc,%esp
f0119949:	68 e4 d4 12 f0       	push   $0xf012d4e4
f011994e:	e8 38 76 fe ff       	call   f0100f8b <cprintf>
f0119953:	83 c4 10             	add    $0x10,%esp
	return 1;
f0119956:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011995b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011995e:	c9                   	leave  
f011995f:	c3                   	ret    

f0119960 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0119960:	55                   	push   %ebp
f0119961:	89 e5                	mov    %esp,%ebp
f0119963:	57                   	push   %edi
f0119964:	53                   	push   %ebx
f0119965:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011996b:	83 ec 0c             	sub    $0xc,%esp
f011996e:	68 68 b4 12 f0       	push   $0xf012b468
f0119973:	e8 13 76 fe ff       	call   f0100f8b <cprintf>
f0119978:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011997b:	83 ec 0c             	sub    $0xc,%esp
f011997e:	68 98 b4 12 f0       	push   $0xf012b498
f0119983:	e8 03 76 fe ff       	call   f0100f8b <cprintf>
f0119988:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011998b:	83 ec 0c             	sub    $0xc,%esp
f011998e:	68 68 b4 12 f0       	push   $0xf012b468
f0119993:	e8 f3 75 fe ff       	call   f0100f8b <cprintf>
f0119998:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011999b:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011999f:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f01199a3:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f01199a9:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f01199af:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f01199b6:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f01199bd:	e8 d0 51 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f01199c2:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f01199c5:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f01199cb:	b9 14 00 00 00       	mov    $0x14,%ecx
f01199d0:	b8 00 00 00 00       	mov    $0x0,%eax
f01199d5:	89 d7                	mov    %edx,%edi
f01199d7:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01199d9:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f01199df:	b9 14 00 00 00       	mov    $0x14,%ecx
f01199e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01199e9:	89 d7                	mov    %edx,%edi
f01199eb:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f01199ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f01199f4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f01199fb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119a02:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119a08:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119a0d:	b8 00 00 00 00       	mov    $0x0,%eax
f0119a12:	89 d7                	mov    %edx,%edi
f0119a14:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119a16:	83 ec 0c             	sub    $0xc,%esp
f0119a19:	68 28 d5 12 f0       	push   $0xf012d528
f0119a1e:	e8 68 75 fe ff       	call   f0100f8b <cprintf>
f0119a23:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119a26:	e8 67 51 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119a2b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119a2e:	e8 60 b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119a33:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119a36:	83 ec 0c             	sub    $0xc,%esp
f0119a39:	68 00 fc 1f 00       	push   $0x1ffc00
f0119a3e:	e8 77 fd fe ff       	call   f01097ba <kmalloc>
f0119a43:	83 c4 10             	add    $0x10,%esp
f0119a46:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a4c:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119a52:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119a57:	74 17                	je     f0119a70 <test_kfree_bestfirstfit+0x110>
f0119a59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a60:	83 ec 0c             	sub    $0xc,%esp
f0119a63:	68 60 d5 12 f0       	push   $0xf012d560
f0119a68:	e8 1e 75 fe ff       	call   f0100f8b <cprintf>
f0119a6d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a70:	e8 1e b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119a75:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a78:	74 17                	je     f0119a91 <test_kfree_bestfirstfit+0x131>
f0119a7a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a81:	83 ec 0c             	sub    $0xc,%esp
f0119a84:	68 b4 d5 12 f0       	push   $0xf012d5b4
f0119a89:	e8 fd 74 fe ff       	call   f0100f8b <cprintf>
f0119a8e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a91:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119a94:	e8 f9 50 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119a99:	29 c3                	sub    %eax,%ebx
f0119a9b:	89 d8                	mov    %ebx,%eax
f0119a9d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119aa2:	77 17                	ja     f0119abb <test_kfree_bestfirstfit+0x15b>
f0119aa4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aab:	83 ec 0c             	sub    $0xc,%esp
f0119aae:	68 24 d6 12 f0       	push   $0xf012d624
f0119ab3:	e8 d3 74 fe ff       	call   f0100f8b <cprintf>
f0119ab8:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f0119abb:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0119ac2:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119ac5:	e8 c8 50 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119aca:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119acd:	e8 c1 af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119ad2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119ad5:	83 ec 0c             	sub    $0xc,%esp
f0119ad8:	68 00 fc 1f 00       	push   $0x1ffc00
f0119add:	e8 d8 fc fe ff       	call   f01097ba <kmalloc>
f0119ae2:	83 c4 10             	add    $0x10,%esp
f0119ae5:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119aeb:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119af1:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119af6:	74 17                	je     f0119b0f <test_kfree_bestfirstfit+0x1af>
f0119af8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aff:	83 ec 0c             	sub    $0xc,%esp
f0119b02:	68 6c d6 12 f0       	push   $0xf012d66c
f0119b07:	e8 7f 74 fe ff       	call   f0100f8b <cprintf>
f0119b0c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b0f:	e8 7f af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119b14:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b17:	74 17                	je     f0119b30 <test_kfree_bestfirstfit+0x1d0>
f0119b19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b20:	83 ec 0c             	sub    $0xc,%esp
f0119b23:	68 c0 d6 12 f0       	push   $0xf012d6c0
f0119b28:	e8 5e 74 fe ff       	call   f0100f8b <cprintf>
f0119b2d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b30:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b33:	e8 5a 50 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119b38:	29 c3                	sub    %eax,%ebx
f0119b3a:	89 d8                	mov    %ebx,%eax
f0119b3c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119b41:	77 17                	ja     f0119b5a <test_kfree_bestfirstfit+0x1fa>
f0119b43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b4a:	83 ec 0c             	sub    $0xc,%esp
f0119b4d:	68 30 d7 12 f0       	push   $0xf012d730
f0119b52:	e8 34 74 fe ff       	call   f0100f8b <cprintf>
f0119b57:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119b5a:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0119b61:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0119b64:	e8 29 50 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119b69:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b6c:	e8 22 af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119b71:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0119b74:	83 ec 0c             	sub    $0xc,%esp
f0119b77:	68 00 1c 00 00       	push   $0x1c00
f0119b7c:	e8 39 fc fe ff       	call   f01097ba <kmalloc>
f0119b81:	83 c4 10             	add    $0x10,%esp
f0119b84:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b8a:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119b90:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119b95:	74 17                	je     f0119bae <test_kfree_bestfirstfit+0x24e>
f0119b97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b9e:	83 ec 0c             	sub    $0xc,%esp
f0119ba1:	68 78 d7 12 f0       	push   $0xf012d778
f0119ba6:	e8 e0 73 fe ff       	call   f0100f8b <cprintf>
f0119bab:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bae:	e8 e0 ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119bb3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119bb6:	74 17                	je     f0119bcf <test_kfree_bestfirstfit+0x26f>
f0119bb8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bbf:	83 ec 0c             	sub    $0xc,%esp
f0119bc2:	68 cc d7 12 f0       	push   $0xf012d7cc
f0119bc7:	e8 bf 73 fe ff       	call   f0100f8b <cprintf>
f0119bcc:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119bcf:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119bd2:	e8 bb 4f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119bd7:	29 c3                	sub    %eax,%ebx
f0119bd9:	89 d8                	mov    %ebx,%eax
f0119bdb:	83 f8 01             	cmp    $0x1,%eax
f0119bde:	77 17                	ja     f0119bf7 <test_kfree_bestfirstfit+0x297>
f0119be0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119be7:	83 ec 0c             	sub    $0xc,%esp
f0119bea:	68 3c d8 12 f0       	push   $0xf012d83c
f0119bef:	e8 97 73 fe ff       	call   f0100f8b <cprintf>
f0119bf4:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119bf7:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119bfe:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119c01:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119c07:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119c0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c11:	eb 0e                	jmp    f0119c21 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119c13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c16:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c19:	01 d0                	add    %edx,%eax
f0119c1b:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119c1e:	ff 45 f4             	incl   -0xc(%ebp)
f0119c21:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119c27:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c2a:	7f e7                	jg     f0119c13 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119c2c:	e8 61 4f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119c31:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c34:	e8 5a ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c39:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119c3c:	83 ec 0c             	sub    $0xc,%esp
f0119c3f:	68 00 fc 2f 00       	push   $0x2ffc00
f0119c44:	e8 71 fb fe ff       	call   f01097ba <kmalloc>
f0119c49:	83 c4 10             	add    $0x10,%esp
f0119c4c:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119c52:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119c58:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119c5d:	74 17                	je     f0119c76 <test_kfree_bestfirstfit+0x316>
f0119c5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c66:	83 ec 0c             	sub    $0xc,%esp
f0119c69:	68 84 d8 12 f0       	push   $0xf012d884
f0119c6e:	e8 18 73 fe ff       	call   f0100f8b <cprintf>
f0119c73:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c76:	e8 18 ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c7b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c7e:	74 17                	je     f0119c97 <test_kfree_bestfirstfit+0x337>
f0119c80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c87:	83 ec 0c             	sub    $0xc,%esp
f0119c8a:	68 d8 d8 12 f0       	push   $0xf012d8d8
f0119c8f:	e8 f7 72 fe ff       	call   f0100f8b <cprintf>
f0119c94:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119c97:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119c9a:	e8 f3 4e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119c9f:	29 c3                	sub    %eax,%ebx
f0119ca1:	89 d8                	mov    %ebx,%eax
f0119ca3:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119ca8:	77 17                	ja     f0119cc1 <test_kfree_bestfirstfit+0x361>
f0119caa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cb1:	83 ec 0c             	sub    $0xc,%esp
f0119cb4:	68 48 d9 12 f0       	push   $0xf012d948
f0119cb9:	e8 cd 72 fe ff       	call   f0100f8b <cprintf>
f0119cbe:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119cc1:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119cc8:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119ccb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119cd1:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119cd4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119cdb:	eb 0e                	jmp    f0119ceb <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119cdd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119ce0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ce3:	01 d0                	add    %edx,%eax
f0119ce5:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119ce8:	ff 45 f4             	incl   -0xc(%ebp)
f0119ceb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119cf1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119cf4:	7f e7                	jg     f0119cdd <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119cf6:	e8 97 4e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119cfb:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119cfe:	e8 90 ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119d03:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119d06:	83 ec 0c             	sub    $0xc,%esp
f0119d09:	68 00 fc 5f 00       	push   $0x5ffc00
f0119d0e:	e8 a7 fa fe ff       	call   f01097ba <kmalloc>
f0119d13:	83 c4 10             	add    $0x10,%esp
f0119d16:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119d1c:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119d22:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119d27:	74 17                	je     f0119d40 <test_kfree_bestfirstfit+0x3e0>
f0119d29:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d30:	83 ec 0c             	sub    $0xc,%esp
f0119d33:	68 90 d9 12 f0       	push   $0xf012d990
f0119d38:	e8 4e 72 fe ff       	call   f0100f8b <cprintf>
f0119d3d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d40:	e8 4e ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119d45:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d48:	74 17                	je     f0119d61 <test_kfree_bestfirstfit+0x401>
f0119d4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d51:	83 ec 0c             	sub    $0xc,%esp
f0119d54:	68 e4 d9 12 f0       	push   $0xf012d9e4
f0119d59:	e8 2d 72 fe ff       	call   f0100f8b <cprintf>
f0119d5e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119d61:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119d64:	e8 29 4e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119d69:	29 c3                	sub    %eax,%ebx
f0119d6b:	89 d8                	mov    %ebx,%eax
f0119d6d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119d72:	77 17                	ja     f0119d8b <test_kfree_bestfirstfit+0x42b>
f0119d74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d7b:	83 ec 0c             	sub    $0xc,%esp
f0119d7e:	68 54 da 12 f0       	push   $0xf012da54
f0119d83:	e8 03 72 fe ff       	call   f0100f8b <cprintf>
f0119d88:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119d8b:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119d92:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119d95:	e8 f8 4d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119d9a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d9d:	e8 f1 ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119da2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119da5:	83 ec 0c             	sub    $0xc,%esp
f0119da8:	68 00 38 00 00       	push   $0x3800
f0119dad:	e8 08 fa fe ff       	call   f01097ba <kmalloc>
f0119db2:	83 c4 10             	add    $0x10,%esp
f0119db5:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119dbb:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119dc1:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119dc6:	74 17                	je     f0119ddf <test_kfree_bestfirstfit+0x47f>
f0119dc8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dcf:	83 ec 0c             	sub    $0xc,%esp
f0119dd2:	68 9c da 12 f0       	push   $0xf012da9c
f0119dd7:	e8 af 71 fe ff       	call   f0100f8b <cprintf>
f0119ddc:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ddf:	e8 af ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119de4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119de7:	74 17                	je     f0119e00 <test_kfree_bestfirstfit+0x4a0>
f0119de9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119df0:	83 ec 0c             	sub    $0xc,%esp
f0119df3:	68 f0 da 12 f0       	push   $0xf012daf0
f0119df8:	e8 8e 71 fe ff       	call   f0100f8b <cprintf>
f0119dfd:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e00:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119e03:	e8 8a 4d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119e08:	29 c3                	sub    %eax,%ebx
f0119e0a:	89 d8                	mov    %ebx,%eax
f0119e0c:	83 f8 03             	cmp    $0x3,%eax
f0119e0f:	77 17                	ja     f0119e28 <test_kfree_bestfirstfit+0x4c8>
f0119e11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e18:	83 ec 0c             	sub    $0xc,%esp
f0119e1b:	68 60 db 12 f0       	push   $0xf012db60
f0119e20:	e8 66 71 fe ff       	call   f0100f8b <cprintf>
f0119e25:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119e28:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119e2f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119e35:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119e38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119e3f:	eb 0e                	jmp    f0119e4f <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119e41:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119e44:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119e47:	01 d0                	add    %edx,%eax
f0119e49:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119e4c:	ff 45 f4             	incl   -0xc(%ebp)
f0119e4f:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119e52:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119e55:	7f ea                	jg     f0119e41 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119e57:	e8 36 4d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119e5c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e5f:	e8 2f ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119e64:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119e67:	83 ec 0c             	sub    $0xc,%esp
f0119e6a:	68 00 08 00 00       	push   $0x800
f0119e6f:	e8 46 f9 fe ff       	call   f01097ba <kmalloc>
f0119e74:	83 c4 10             	add    $0x10,%esp
f0119e77:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119e7d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119e83:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119e88:	76 28                	jbe    f0119eb2 <test_kfree_bestfirstfit+0x552>
f0119e8a:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119e90:	83 ec 0c             	sub    $0xc,%esp
f0119e93:	6a 00                	push   $0x0
f0119e95:	e8 ed f7 fe ff       	call   f0109687 <sbrk>
f0119e9a:	83 c4 10             	add    $0x10,%esp
f0119e9d:	39 c3                	cmp    %eax,%ebx
f0119e9f:	73 11                	jae    f0119eb2 <test_kfree_bestfirstfit+0x552>
f0119ea1:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119ea7:	89 c2                	mov    %eax,%edx
f0119ea9:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0119eae:	39 c2                	cmp    %eax,%edx
f0119eb0:	72 17                	jb     f0119ec9 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119eb2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eb9:	83 ec 0c             	sub    $0xc,%esp
f0119ebc:	68 a8 db 12 f0       	push   $0xf012dba8
f0119ec1:	e8 c5 70 fe ff       	call   f0100f8b <cprintf>
f0119ec6:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ec9:	e8 c5 ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119ece:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119ed1:	74 17                	je     f0119eea <test_kfree_bestfirstfit+0x58a>
f0119ed3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eda:	83 ec 0c             	sub    $0xc,%esp
f0119edd:	68 34 dc 12 f0       	push   $0xf012dc34
f0119ee2:	e8 a4 70 fe ff       	call   f0100f8b <cprintf>
f0119ee7:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119eea:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119ef1:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119ef4:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119efa:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119efd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f04:	eb 0e                	jmp    f0119f14 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119f06:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119f09:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119f0c:	01 d0                	add    %edx,%eax
f0119f0e:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119f11:	ff 45 f4             	incl   -0xc(%ebp)
f0119f14:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119f1a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f1d:	7f e7                	jg     f0119f06 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f1f:	e8 6f ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f24:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119f27:	83 ec 0c             	sub    $0xc,%esp
f0119f2a:	68 00 08 00 00       	push   $0x800
f0119f2f:	e8 86 f8 fe ff       	call   f01097ba <kmalloc>
f0119f34:	83 c4 10             	add    $0x10,%esp
f0119f37:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119f3d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119f43:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119f48:	76 28                	jbe    f0119f72 <test_kfree_bestfirstfit+0x612>
f0119f4a:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119f50:	83 ec 0c             	sub    $0xc,%esp
f0119f53:	6a 00                	push   $0x0
f0119f55:	e8 2d f7 fe ff       	call   f0109687 <sbrk>
f0119f5a:	83 c4 10             	add    $0x10,%esp
f0119f5d:	39 c3                	cmp    %eax,%ebx
f0119f5f:	73 11                	jae    f0119f72 <test_kfree_bestfirstfit+0x612>
f0119f61:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119f67:	89 c2                	mov    %eax,%edx
f0119f69:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0119f6e:	39 c2                	cmp    %eax,%edx
f0119f70:	72 17                	jb     f0119f89 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119f72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f79:	83 ec 0c             	sub    $0xc,%esp
f0119f7c:	68 a4 dc 12 f0       	push   $0xf012dca4
f0119f81:	e8 05 70 fe ff       	call   f0100f8b <cprintf>
f0119f86:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f89:	e8 05 ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f8e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f91:	74 17                	je     f0119faa <test_kfree_bestfirstfit+0x64a>
f0119f93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f9a:	83 ec 0c             	sub    $0xc,%esp
f0119f9d:	68 30 dd 12 f0       	push   $0xf012dd30
f0119fa2:	e8 e4 6f fe ff       	call   f0100f8b <cprintf>
f0119fa7:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119faa:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0119fb1:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0119fb4:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119fba:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119fbd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119fc4:	eb 0e                	jmp    f0119fd4 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119fc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119fc9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fcc:	01 d0                	add    %edx,%eax
f0119fce:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0119fd1:	ff 45 f4             	incl   -0xc(%ebp)
f0119fd4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119fda:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119fdd:	7f e7                	jg     f0119fc6 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119fdf:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119fe2:	e8 ab 4b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f0119fe7:	29 c3                	sub    %eax,%ebx
f0119fe9:	89 d8                	mov    %ebx,%eax
f0119feb:	83 f8 01             	cmp    $0x1,%eax
f0119fee:	74 17                	je     f011a007 <test_kfree_bestfirstfit+0x6a7>
f0119ff0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ff7:	83 ec 0c             	sub    $0xc,%esp
f0119ffa:	68 a0 dd 12 f0       	push   $0xf012dda0
f0119fff:	e8 87 6f fe ff       	call   f0100f8b <cprintf>
f011a004:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011a007:	83 ec 0c             	sub    $0xc,%esp
f011a00a:	68 c4 dd 12 f0       	push   $0xf012ddc4
f011a00f:	e8 77 6f fe ff       	call   f0100f8b <cprintf>
f011a014:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a017:	e8 76 4b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a01c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a01f:	e8 6f aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a024:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a027:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011a02d:	83 ec 0c             	sub    $0xc,%esp
f011a030:	50                   	push   %eax
f011a031:	e8 e4 f9 fe ff       	call   f0109a1a <kfree>
f011a036:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a039:	e8 55 aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a03e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a041:	74 17                	je     f011a05a <test_kfree_bestfirstfit+0x6fa>
f011a043:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a04a:	83 ec 0c             	sub    $0xc,%esp
f011a04d:	68 f4 dd 12 f0       	push   $0xf012ddf4
f011a052:	e8 34 6f fe ff       	call   f0100f8b <cprintf>
f011a057:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a05a:	e8 33 4b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a05f:	89 c2                	mov    %eax,%edx
f011a061:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a064:	29 c2                	sub    %eax,%edx
f011a066:	89 d0                	mov    %edx,%eax
f011a068:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a06d:	77 17                	ja     f011a086 <test_kfree_bestfirstfit+0x726>
f011a06f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a076:	83 ec 0c             	sub    $0xc,%esp
f011a079:	68 64 de 12 f0       	push   $0xf012de64
f011a07e:	e8 08 6f fe ff       	call   f0100f8b <cprintf>
f011a083:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f011a086:	e8 07 4b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a08b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a08e:	e8 00 aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a093:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a096:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a09c:	83 ec 0c             	sub    $0xc,%esp
f011a09f:	50                   	push   %eax
f011a0a0:	e8 75 f9 fe ff       	call   f0109a1a <kfree>
f011a0a5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0a8:	e8 e6 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a0ad:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a0b0:	74 17                	je     f011a0c9 <test_kfree_bestfirstfit+0x769>
f011a0b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0b9:	83 ec 0c             	sub    $0xc,%esp
f011a0bc:	68 a0 de 12 f0       	push   $0xf012dea0
f011a0c1:	e8 c5 6e fe ff       	call   f0100f8b <cprintf>
f011a0c6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a0c9:	e8 c4 4a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a0ce:	89 c2                	mov    %eax,%edx
f011a0d0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a0d3:	39 c2                	cmp    %eax,%edx
f011a0d5:	74 17                	je     f011a0ee <test_kfree_bestfirstfit+0x78e>
f011a0d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0de:	83 ec 0c             	sub    $0xc,%esp
f011a0e1:	68 10 df 12 f0       	push   $0xf012df10
f011a0e6:	e8 a0 6e fe ff       	call   f0100f8b <cprintf>
f011a0eb:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a0ee:	e8 9f 4a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a0f3:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a0f6:	e8 98 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a0fb:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a0fe:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a104:	83 ec 0c             	sub    $0xc,%esp
f011a107:	50                   	push   %eax
f011a108:	e8 0d f9 fe ff       	call   f0109a1a <kfree>
f011a10d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a110:	e8 7e a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a115:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a118:	74 17                	je     f011a131 <test_kfree_bestfirstfit+0x7d1>
f011a11a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a121:	83 ec 0c             	sub    $0xc,%esp
f011a124:	68 70 df 12 f0       	push   $0xf012df70
f011a129:	e8 5d 6e fe ff       	call   f0100f8b <cprintf>
f011a12e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a131:	e8 5c 4a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a136:	89 c2                	mov    %eax,%edx
f011a138:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a13b:	29 c2                	sub    %eax,%edx
f011a13d:	89 d0                	mov    %edx,%eax
f011a13f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a144:	77 17                	ja     f011a15d <test_kfree_bestfirstfit+0x7fd>
f011a146:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a14d:	83 ec 0c             	sub    $0xc,%esp
f011a150:	68 e0 df 12 f0       	push   $0xf012dfe0
f011a155:	e8 31 6e fe ff       	call   f0100f8b <cprintf>
f011a15a:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a15d:	e8 30 4a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a162:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a165:	e8 29 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a16a:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011a16d:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a173:	83 ec 0c             	sub    $0xc,%esp
f011a176:	50                   	push   %eax
f011a177:	e8 9e f8 fe ff       	call   f0109a1a <kfree>
f011a17c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a17f:	e8 0f a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a184:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a187:	74 17                	je     f011a1a0 <test_kfree_bestfirstfit+0x840>
f011a189:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a190:	83 ec 0c             	sub    $0xc,%esp
f011a193:	68 1c e0 12 f0       	push   $0xf012e01c
f011a198:	e8 ee 6d fe ff       	call   f0100f8b <cprintf>
f011a19d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a1a0:	e8 ed 49 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a1a5:	89 c2                	mov    %eax,%edx
f011a1a7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a1aa:	29 c2                	sub    %eax,%edx
f011a1ac:	89 d0                	mov    %edx,%eax
f011a1ae:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a1b3:	77 17                	ja     f011a1cc <test_kfree_bestfirstfit+0x86c>
f011a1b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1bc:	83 ec 0c             	sub    $0xc,%esp
f011a1bf:	68 8c e0 12 f0       	push   $0xf012e08c
f011a1c4:	e8 c2 6d fe ff       	call   f0100f8b <cprintf>
f011a1c9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a1cc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a1d0:	74 04                	je     f011a1d6 <test_kfree_bestfirstfit+0x876>
f011a1d2:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a1d6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011a1dd:	83 ec 0c             	sub    $0xc,%esp
f011a1e0:	68 c8 e0 12 f0       	push   $0xf012e0c8
f011a1e5:	e8 a1 6d fe ff       	call   f0100f8b <cprintf>
f011a1ea:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011a1ed:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a1f3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011a1f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1fd:	eb 1e                	jmp    f011a21d <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011a1ff:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a205:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a208:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a20b:	01 c8                	add    %ecx,%eax
f011a20d:	8a 00                	mov    (%eax),%al
f011a20f:	0f be c0             	movsbl %al,%eax
f011a212:	01 d0                	add    %edx,%eax
f011a214:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011a21a:	ff 45 f4             	incl   -0xc(%ebp)
f011a21d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a223:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a226:	7f d7                	jg     f011a1ff <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f011a228:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a22e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a234:	89 c1                	mov    %eax,%ecx
f011a236:	01 c9                	add    %ecx,%ecx
f011a238:	01 c8                	add    %ecx,%eax
f011a23a:	39 c2                	cmp    %eax,%edx
f011a23c:	74 17                	je     f011a255 <test_kfree_bestfirstfit+0x8f5>
f011a23e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a245:	83 ec 0c             	sub    $0xc,%esp
f011a248:	68 10 e1 12 f0       	push   $0xf012e110
f011a24d:	e8 39 6d fe ff       	call   f0100f8b <cprintf>
f011a252:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011a255:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a25b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011a25e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a265:	eb 1e                	jmp    f011a285 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011a267:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011a26d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a270:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a273:	01 c8                	add    %ecx,%eax
f011a275:	8a 00                	mov    (%eax),%al
f011a277:	0f be c0             	movsbl %al,%eax
f011a27a:	01 d0                	add    %edx,%eax
f011a27c:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011a282:	ff 45 f4             	incl   -0xc(%ebp)
f011a285:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a28b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a28e:	7f d7                	jg     f011a267 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a290:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a296:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a29c:	c1 e2 02             	shl    $0x2,%edx
f011a29f:	39 d0                	cmp    %edx,%eax
f011a2a1:	74 17                	je     f011a2ba <test_kfree_bestfirstfit+0x95a>
f011a2a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2aa:	83 ec 0c             	sub    $0xc,%esp
f011a2ad:	68 48 e1 12 f0       	push   $0xf012e148
f011a2b2:	e8 d4 6c fe ff       	call   f0100f8b <cprintf>
f011a2b7:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a2ba:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a2c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a2c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2ca:	eb 1e                	jmp    f011a2ea <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a2cc:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a2d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a2d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a2d8:	01 c8                	add    %ecx,%eax
f011a2da:	8a 00                	mov    (%eax),%al
f011a2dc:	0f be c0             	movsbl %al,%eax
f011a2df:	01 d0                	add    %edx,%eax
f011a2e1:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a2e7:	ff 45 f4             	incl   -0xc(%ebp)
f011a2ea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a2f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a2f3:	7f d7                	jg     f011a2cc <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a2f5:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a2fb:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a301:	89 d0                	mov    %edx,%eax
f011a303:	c1 e0 02             	shl    $0x2,%eax
f011a306:	01 d0                	add    %edx,%eax
f011a308:	39 c1                	cmp    %eax,%ecx
f011a30a:	74 17                	je     f011a323 <test_kfree_bestfirstfit+0x9c3>
f011a30c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a313:	83 ec 0c             	sub    $0xc,%esp
f011a316:	68 80 e1 12 f0       	push   $0xf012e180
f011a31b:	e8 6b 6c fe ff       	call   f0100f8b <cprintf>
f011a320:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a323:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a329:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a32c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a333:	eb 1e                	jmp    f011a353 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a335:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a33b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a33e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a341:	01 c8                	add    %ecx,%eax
f011a343:	8a 00                	mov    (%eax),%al
f011a345:	0f be c0             	movsbl %al,%eax
f011a348:	01 d0                	add    %edx,%eax
f011a34a:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a350:	ff 45 f4             	incl   -0xc(%ebp)
f011a353:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a356:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a359:	7f da                	jg     f011a335 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a35b:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a361:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a364:	89 d0                	mov    %edx,%eax
f011a366:	01 c0                	add    %eax,%eax
f011a368:	01 d0                	add    %edx,%eax
f011a36a:	01 c0                	add    %eax,%eax
f011a36c:	01 d0                	add    %edx,%eax
f011a36e:	39 c1                	cmp    %eax,%ecx
f011a370:	74 17                	je     f011a389 <test_kfree_bestfirstfit+0xa29>
f011a372:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a379:	83 ec 0c             	sub    $0xc,%esp
f011a37c:	68 b8 e1 12 f0       	push   $0xf012e1b8
f011a381:	e8 05 6c fe ff       	call   f0100f8b <cprintf>
f011a386:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a389:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a38d:	74 04                	je     f011a393 <test_kfree_bestfirstfit+0xa33>
f011a38f:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a393:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a39a:	83 ec 0c             	sub    $0xc,%esp
f011a39d:	68 f0 e1 12 f0       	push   $0xf012e1f0
f011a3a2:	e8 e4 6b fe ff       	call   f0100f8b <cprintf>
f011a3a7:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a3aa:	e8 e3 47 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a3af:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a3b2:	e8 dc a6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a3b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a3ba:	83 ec 0c             	sub    $0xc,%esp
f011a3bd:	68 00 04 00 00       	push   $0x400
f011a3c2:	e8 f3 f3 fe ff       	call   f01097ba <kmalloc>
f011a3c7:	83 c4 10             	add    $0x10,%esp
f011a3ca:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a3d0:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a3d6:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a3dc:	39 c2                	cmp    %eax,%edx
f011a3de:	74 17                	je     f011a3f7 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a3e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3e7:	83 ec 0c             	sub    $0xc,%esp
f011a3ea:	68 10 e2 12 f0       	push   $0xf012e210
f011a3ef:	e8 97 6b fe ff       	call   f0100f8b <cprintf>
f011a3f4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a3f7:	e8 97 a6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a3fc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3ff:	74 17                	je     f011a418 <test_kfree_bestfirstfit+0xab8>
f011a401:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a408:	83 ec 0c             	sub    $0xc,%esp
f011a40b:	68 64 e2 12 f0       	push   $0xf012e264
f011a410:	e8 76 6b fe ff       	call   f0100f8b <cprintf>
f011a415:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a418:	e8 75 47 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a41d:	89 c2                	mov    %eax,%edx
f011a41f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a422:	39 c2                	cmp    %eax,%edx
f011a424:	74 17                	je     f011a43d <test_kfree_bestfirstfit+0xadd>
f011a426:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a42d:	83 ec 0c             	sub    $0xc,%esp
f011a430:	68 d4 e2 12 f0       	push   $0xf012e2d4
f011a435:	e8 51 6b fe ff       	call   f0100f8b <cprintf>
f011a43a:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a43d:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a444:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a44a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a44d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a454:	eb 0e                	jmp    f011a464 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a456:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a459:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a45c:	01 d0                	add    %edx,%eax
f011a45e:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a461:	ff 45 f4             	incl   -0xc(%ebp)
f011a464:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a467:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a46a:	7f ea                	jg     f011a456 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a46c:	e8 21 47 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a471:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a474:	e8 1a a6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a479:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a47c:	83 ec 0c             	sub    $0xc,%esp
f011a47f:	68 00 00 30 00       	push   $0x300000
f011a484:	e8 31 f3 fe ff       	call   f01097ba <kmalloc>
f011a489:	83 c4 10             	add    $0x10,%esp
f011a48c:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a492:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a498:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a49d:	74 17                	je     f011a4b6 <test_kfree_bestfirstfit+0xb56>
f011a49f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4a6:	83 ec 0c             	sub    $0xc,%esp
f011a4a9:	68 50 e3 12 f0       	push   $0xf012e350
f011a4ae:	e8 d8 6a fe ff       	call   f0100f8b <cprintf>
f011a4b3:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4b6:	e8 d8 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a4bb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4be:	74 17                	je     f011a4d7 <test_kfree_bestfirstfit+0xb77>
f011a4c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4c7:	83 ec 0c             	sub    $0xc,%esp
f011a4ca:	68 a4 e3 12 f0       	push   $0xf012e3a4
f011a4cf:	e8 b7 6a fe ff       	call   f0100f8b <cprintf>
f011a4d4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a4d7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a4da:	e8 b3 46 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a4df:	29 c3                	sub    %eax,%ebx
f011a4e1:	89 d8                	mov    %ebx,%eax
f011a4e3:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a4e8:	77 17                	ja     f011a501 <test_kfree_bestfirstfit+0xba1>
f011a4ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4f1:	83 ec 0c             	sub    $0xc,%esp
f011a4f4:	68 14 e4 12 f0       	push   $0xf012e414
f011a4f9:	e8 8d 6a fe ff       	call   f0100f8b <cprintf>
f011a4fe:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a501:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a508:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a50e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a511:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a518:	eb 0e                	jmp    f011a528 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a51a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a51d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a520:	01 d0                	add    %edx,%eax
f011a522:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a525:	ff 45 f4             	incl   -0xc(%ebp)
f011a528:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a52b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a52e:	7f ea                	jg     f011a51a <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a530:	e8 5d 46 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a535:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a538:	e8 56 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a53d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a540:	83 ec 0c             	sub    $0xc,%esp
f011a543:	68 00 00 10 00       	push   $0x100000
f011a548:	e8 6d f2 fe ff       	call   f01097ba <kmalloc>
f011a54d:	83 c4 10             	add    $0x10,%esp
f011a550:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a556:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a55c:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a561:	74 17                	je     f011a57a <test_kfree_bestfirstfit+0xc1a>
f011a563:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a56a:	83 ec 0c             	sub    $0xc,%esp
f011a56d:	68 5c e4 12 f0       	push   $0xf012e45c
f011a572:	e8 14 6a fe ff       	call   f0100f8b <cprintf>
f011a577:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a57a:	e8 14 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a57f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a582:	74 17                	je     f011a59b <test_kfree_bestfirstfit+0xc3b>
f011a584:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a58b:	83 ec 0c             	sub    $0xc,%esp
f011a58e:	68 b0 e4 12 f0       	push   $0xf012e4b0
f011a593:	e8 f3 69 fe ff       	call   f0100f8b <cprintf>
f011a598:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a59b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a59e:	e8 ef 45 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a5a3:	29 c3                	sub    %eax,%ebx
f011a5a5:	89 d8                	mov    %ebx,%eax
f011a5a7:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a5ac:	77 17                	ja     f011a5c5 <test_kfree_bestfirstfit+0xc65>
f011a5ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5b5:	83 ec 0c             	sub    $0xc,%esp
f011a5b8:	68 20 e5 12 f0       	push   $0xf012e520
f011a5bd:	e8 c9 69 fe ff       	call   f0100f8b <cprintf>
f011a5c2:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a5c5:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a5cc:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a5d2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a5d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a5dc:	eb 0e                	jmp    f011a5ec <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a5de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a5e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5e4:	01 d0                	add    %edx,%eax
f011a5e6:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a5e9:	ff 45 f4             	incl   -0xc(%ebp)
f011a5ec:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a5ef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5f2:	7f ea                	jg     f011a5de <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a5f4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a5f8:	74 04                	je     f011a5fe <test_kfree_bestfirstfit+0xc9e>
f011a5fa:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a5fe:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a605:	83 ec 0c             	sub    $0xc,%esp
f011a608:	68 68 e5 12 f0       	push   $0xf012e568
f011a60d:	e8 79 69 fe ff       	call   f0100f8b <cprintf>
f011a612:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a615:	e8 78 45 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a61a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a61d:	e8 71 a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a622:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a625:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a62b:	83 ec 0c             	sub    $0xc,%esp
f011a62e:	50                   	push   %eax
f011a62f:	e8 e6 f3 fe ff       	call   f0109a1a <kfree>
f011a634:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a637:	e8 57 a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a63c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a63f:	74 17                	je     f011a658 <test_kfree_bestfirstfit+0xcf8>
f011a641:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a648:	83 ec 0c             	sub    $0xc,%esp
f011a64b:	68 94 e5 12 f0       	push   $0xf012e594
f011a650:	e8 36 69 fe ff       	call   f0100f8b <cprintf>
f011a655:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a658:	e8 35 45 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a65d:	89 c2                	mov    %eax,%edx
f011a65f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a662:	29 c2                	sub    %eax,%edx
f011a664:	89 d0                	mov    %edx,%eax
f011a666:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a66b:	77 17                	ja     f011a684 <test_kfree_bestfirstfit+0xd24>
f011a66d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a674:	83 ec 0c             	sub    $0xc,%esp
f011a677:	68 04 e6 12 f0       	push   $0xf012e604
f011a67c:	e8 0a 69 fe ff       	call   f0100f8b <cprintf>
f011a681:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a684:	e8 09 45 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a689:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a68c:	e8 02 a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a691:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a694:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a69a:	83 ec 0c             	sub    $0xc,%esp
f011a69d:	50                   	push   %eax
f011a69e:	e8 77 f3 fe ff       	call   f0109a1a <kfree>
f011a6a3:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6a6:	e8 e8 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6ab:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6ae:	74 17                	je     f011a6c7 <test_kfree_bestfirstfit+0xd67>
f011a6b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6b7:	83 ec 0c             	sub    $0xc,%esp
f011a6ba:	68 40 e6 12 f0       	push   $0xf012e640
f011a6bf:	e8 c7 68 fe ff       	call   f0100f8b <cprintf>
f011a6c4:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a6c7:	e8 c6 44 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a6cc:	89 c2                	mov    %eax,%edx
f011a6ce:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a6d1:	29 c2                	sub    %eax,%edx
f011a6d3:	89 d0                	mov    %edx,%eax
f011a6d5:	83 f8 01             	cmp    $0x1,%eax
f011a6d8:	77 17                	ja     f011a6f1 <test_kfree_bestfirstfit+0xd91>
f011a6da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6e1:	83 ec 0c             	sub    $0xc,%esp
f011a6e4:	68 b0 e6 12 f0       	push   $0xf012e6b0
f011a6e9:	e8 9d 68 fe ff       	call   f0100f8b <cprintf>
f011a6ee:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a6f1:	e8 9c 44 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a6f6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a6f9:	e8 95 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6fe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a701:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a707:	83 ec 0c             	sub    $0xc,%esp
f011a70a:	50                   	push   %eax
f011a70b:	e8 0a f3 fe ff       	call   f0109a1a <kfree>
f011a710:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a713:	e8 7b a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a718:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a71b:	74 17                	je     f011a734 <test_kfree_bestfirstfit+0xdd4>
f011a71d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a724:	83 ec 0c             	sub    $0xc,%esp
f011a727:	68 ec e6 12 f0       	push   $0xf012e6ec
f011a72c:	e8 5a 68 fe ff       	call   f0100f8b <cprintf>
f011a731:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a734:	e8 59 44 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a739:	89 c2                	mov    %eax,%edx
f011a73b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a73e:	29 c2                	sub    %eax,%edx
f011a740:	89 d0                	mov    %edx,%eax
f011a742:	83 f8 03             	cmp    $0x3,%eax
f011a745:	77 17                	ja     f011a75e <test_kfree_bestfirstfit+0xdfe>
f011a747:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a74e:	83 ec 0c             	sub    $0xc,%esp
f011a751:	68 5c e7 12 f0       	push   $0xf012e75c
f011a756:	e8 30 68 fe ff       	call   f0100f8b <cprintf>
f011a75b:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a75e:	e8 2f 44 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a763:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a766:	e8 28 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a76b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a76e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a774:	83 ec 0c             	sub    $0xc,%esp
f011a777:	50                   	push   %eax
f011a778:	e8 9d f2 fe ff       	call   f0109a1a <kfree>
f011a77d:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a780:	e8 0e a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a785:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a788:	74 17                	je     f011a7a1 <test_kfree_bestfirstfit+0xe41>
f011a78a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a791:	83 ec 0c             	sub    $0xc,%esp
f011a794:	68 98 e7 12 f0       	push   $0xf012e798
f011a799:	e8 ed 67 fe ff       	call   f0100f8b <cprintf>
f011a79e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a7a1:	e8 ec 43 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a7a6:	89 c2                	mov    %eax,%edx
f011a7a8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a7ab:	29 c2                	sub    %eax,%edx
f011a7ad:	89 d0                	mov    %edx,%eax
f011a7af:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a7b4:	77 17                	ja     f011a7cd <test_kfree_bestfirstfit+0xe6d>
f011a7b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7bd:	83 ec 0c             	sub    $0xc,%esp
f011a7c0:	68 08 e8 12 f0       	push   $0xf012e808
f011a7c5:	e8 c1 67 fe ff       	call   f0100f8b <cprintf>
f011a7ca:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a7cd:	e8 c0 43 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a7d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7d5:	e8 b9 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a7da:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a7dd:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a7e3:	83 ec 0c             	sub    $0xc,%esp
f011a7e6:	50                   	push   %eax
f011a7e7:	e8 2e f2 fe ff       	call   f0109a1a <kfree>
f011a7ec:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7ef:	e8 9f a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a7f4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7f7:	74 17                	je     f011a810 <test_kfree_bestfirstfit+0xeb0>
f011a7f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a800:	83 ec 0c             	sub    $0xc,%esp
f011a803:	68 44 e8 12 f0       	push   $0xf012e844
f011a808:	e8 7e 67 fe ff       	call   f0100f8b <cprintf>
f011a80d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a810:	e8 7d 43 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a815:	89 c2                	mov    %eax,%edx
f011a817:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a81a:	29 c2                	sub    %eax,%edx
f011a81c:	89 d0                	mov    %edx,%eax
f011a81e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a823:	77 17                	ja     f011a83c <test_kfree_bestfirstfit+0xedc>
f011a825:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a82c:	83 ec 0c             	sub    $0xc,%esp
f011a82f:	68 b4 e8 12 f0       	push   $0xf012e8b4
f011a834:	e8 52 67 fe ff       	call   f0100f8b <cprintf>
f011a839:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a83c:	e8 51 43 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a841:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a844:	e8 4a a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a849:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a84c:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a852:	83 ec 0c             	sub    $0xc,%esp
f011a855:	50                   	push   %eax
f011a856:	e8 bf f1 fe ff       	call   f0109a1a <kfree>
f011a85b:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a85e:	e8 30 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a863:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a866:	74 17                	je     f011a87f <test_kfree_bestfirstfit+0xf1f>
f011a868:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a86f:	83 ec 0c             	sub    $0xc,%esp
f011a872:	68 f0 e8 12 f0       	push   $0xf012e8f0
f011a877:	e8 0f 67 fe ff       	call   f0100f8b <cprintf>
f011a87c:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a87f:	e8 0e 43 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a884:	89 c2                	mov    %eax,%edx
f011a886:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a889:	39 c2                	cmp    %eax,%edx
f011a88b:	74 17                	je     f011a8a4 <test_kfree_bestfirstfit+0xf44>
f011a88d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a894:	83 ec 0c             	sub    $0xc,%esp
f011a897:	68 60 e9 12 f0       	push   $0xf012e960
f011a89c:	e8 ea 66 fe ff       	call   f0100f8b <cprintf>
f011a8a1:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a8a4:	e8 e9 42 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a8a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8ac:	e8 e2 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8b1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a8b4:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a8ba:	83 ec 0c             	sub    $0xc,%esp
f011a8bd:	50                   	push   %eax
f011a8be:	e8 57 f1 fe ff       	call   f0109a1a <kfree>
f011a8c3:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8c6:	e8 c8 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8cb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a8ce:	74 17                	je     f011a8e7 <test_kfree_bestfirstfit+0xf87>
f011a8d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8d7:	83 ec 0c             	sub    $0xc,%esp
f011a8da:	68 9c e9 12 f0       	push   $0xf012e99c
f011a8df:	e8 a7 66 fe ff       	call   f0100f8b <cprintf>
f011a8e4:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a8e7:	e8 a6 42 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011a8ec:	89 c2                	mov    %eax,%edx
f011a8ee:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8f1:	39 c2                	cmp    %eax,%edx
f011a8f3:	74 17                	je     f011a90c <test_kfree_bestfirstfit+0xfac>
f011a8f5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8fc:	83 ec 0c             	sub    $0xc,%esp
f011a8ff:	68 0c ea 12 f0       	push   $0xf012ea0c
f011a904:	e8 82 66 fe ff       	call   f0100f8b <cprintf>
f011a909:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a90c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a910:	74 04                	je     f011a916 <test_kfree_bestfirstfit+0xfb6>
f011a912:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a916:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a91d:	83 ec 0c             	sub    $0xc,%esp
f011a920:	68 6c ea 12 f0       	push   $0xf012ea6c
f011a925:	e8 61 66 fe ff       	call   f0100f8b <cprintf>
f011a92a:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a92d:	83 ec 0c             	sub    $0xc,%esp
f011a930:	6a 03                	push   $0x3
f011a932:	e8 84 46 ff ff       	call   f010efbb <sys_bypassPageFault>
f011a937:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a93a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a941:	e9 af 00 00 00       	jmp    f011a9f5 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a946:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a94a:	0f 84 a1 00 00 00    	je     f011a9f1 <test_kfree_bestfirstfit+0x1091>
f011a950:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a954:	0f 84 97 00 00 00    	je     f011a9f1 <test_kfree_bestfirstfit+0x1091>
f011a95a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a95e:	0f 84 8d 00 00 00    	je     f011a9f1 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a967:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a96e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a971:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a974:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a977:	e8 2d 46 ff ff       	call   f010efa9 <sys_rcr2>
f011a97c:	89 c2                	mov    %eax,%edx
f011a97e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a981:	39 c2                	cmp    %eax,%edx
f011a983:	74 1d                	je     f011a9a2 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a985:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a989:	74 17                	je     f011a9a2 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a98b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a992:	83 ec 0c             	sub    $0xc,%esp
f011a995:	68 ac ea 12 f0       	push   $0xf012eaac
f011a99a:	e8 ec 65 fe ff       	call   f0100f8b <cprintf>
f011a99f:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a9a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a9a5:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a9ac:	89 c2                	mov    %eax,%edx
f011a9ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a9b1:	01 d0                	add    %edx,%eax
f011a9b3:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a9b6:	e8 ee 45 ff ff       	call   f010efa9 <sys_rcr2>
f011a9bb:	89 c2                	mov    %eax,%edx
f011a9bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a9c0:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a9c7:	89 c1                	mov    %eax,%ecx
f011a9c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a9cc:	01 c8                	add    %ecx,%eax
f011a9ce:	39 c2                	cmp    %eax,%edx
f011a9d0:	74 20                	je     f011a9f2 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a9d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9d6:	74 1a                	je     f011a9f2 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a9d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9df:	83 ec 0c             	sub    $0xc,%esp
f011a9e2:	68 f8 ea 12 f0       	push   $0xf012eaf8
f011a9e7:	e8 9f 65 fe ff       	call   f0100f8b <cprintf>
f011a9ec:	83 c4 10             	add    $0x10,%esp
f011a9ef:	eb 01                	jmp    f011a9f2 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a9f1:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a9f2:	ff 45 f4             	incl   -0xc(%ebp)
f011a9f5:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a9f9:	0f 8e 47 ff ff ff    	jle    f011a946 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a9ff:	83 ec 0c             	sub    $0xc,%esp
f011aa02:	6a 00                	push   $0x0
f011aa04:	e8 b2 45 ff ff       	call   f010efbb <sys_bypassPageFault>
f011aa09:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011aa0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa10:	74 04                	je     f011aa16 <test_kfree_bestfirstfit+0x10b6>
f011aa12:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aa16:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011aa1d:	83 ec 0c             	sub    $0xc,%esp
f011aa20:	68 44 eb 12 f0       	push   $0xf012eb44
f011aa25:	e8 61 65 fe ff       	call   f0100f8b <cprintf>
f011aa2a:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011aa2d:	e8 60 41 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011aa32:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa35:	e8 59 a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aa3a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011aa3d:	83 ec 0c             	sub    $0xc,%esp
f011aa40:	68 00 04 00 00       	push   $0x400
f011aa45:	e8 70 ed fe ff       	call   f01097ba <kmalloc>
f011aa4a:	83 c4 10             	add    $0x10,%esp
f011aa4d:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011aa53:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011aa59:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011aa5f:	39 c2                	cmp    %eax,%edx
f011aa61:	74 17                	je     f011aa7a <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa6a:	83 ec 0c             	sub    $0xc,%esp
f011aa6d:	68 68 eb 12 f0       	push   $0xf012eb68
f011aa72:	e8 14 65 fe ff       	call   f0100f8b <cprintf>
f011aa77:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa7a:	e8 14 a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aa7f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa82:	74 17                	je     f011aa9b <test_kfree_bestfirstfit+0x113b>
f011aa84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa8b:	83 ec 0c             	sub    $0xc,%esp
f011aa8e:	68 bc eb 12 f0       	push   $0xf012ebbc
f011aa93:	e8 f3 64 fe ff       	call   f0100f8b <cprintf>
f011aa98:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011aa9b:	e8 f2 40 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011aaa0:	89 c2                	mov    %eax,%edx
f011aaa2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011aaa5:	39 c2                	cmp    %eax,%edx
f011aaa7:	74 17                	je     f011aac0 <test_kfree_bestfirstfit+0x1160>
f011aaa9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aab0:	83 ec 0c             	sub    $0xc,%esp
f011aab3:	68 2c ec 12 f0       	push   $0xf012ec2c
f011aab8:	e8 ce 64 fe ff       	call   f0100f8b <cprintf>
f011aabd:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011aac0:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011aac7:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011aacd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011aad0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aad7:	eb 0e                	jmp    f011aae7 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011aad9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aadc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aadf:	01 d0                	add    %edx,%eax
f011aae1:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011aae4:	ff 45 f4             	incl   -0xc(%ebp)
f011aae7:	8b 45 90             	mov    -0x70(%ebp),%eax
f011aaea:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aaed:	7f ea                	jg     f011aad9 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011aaef:	e8 9e 40 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011aaf4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aaf7:	e8 97 9f fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aafc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011aaff:	83 ec 0c             	sub    $0xc,%esp
f011ab02:	68 00 08 00 00       	push   $0x800
f011ab07:	e8 ae ec fe ff       	call   f01097ba <kmalloc>
f011ab0c:	83 c4 10             	add    $0x10,%esp
f011ab0f:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011ab15:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011ab1b:	05 08 04 00 00       	add    $0x408,%eax
f011ab20:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011ab23:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ab29:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ab2c:	74 35                	je     f011ab63 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011ab2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011ab35:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ab3b:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011ab41:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011ab47:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011ab4d:	81 c2 00 04 00 00    	add    $0x400,%edx
f011ab53:	50                   	push   %eax
f011ab54:	51                   	push   %ecx
f011ab55:	52                   	push   %edx
f011ab56:	68 a8 ec 12 f0       	push   $0xf012eca8
f011ab5b:	e8 2b 64 fe ff       	call   f0100f8b <cprintf>
f011ab60:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab63:	e8 2b 9f fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ab68:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ab6b:	74 17                	je     f011ab84 <test_kfree_bestfirstfit+0x1224>
f011ab6d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab74:	83 ec 0c             	sub    $0xc,%esp
f011ab77:	68 1c ed 12 f0       	push   $0xf012ed1c
f011ab7c:	e8 0a 64 fe ff       	call   f0100f8b <cprintf>
f011ab81:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ab84:	e8 09 40 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ab89:	89 c2                	mov    %eax,%edx
f011ab8b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ab8e:	39 c2                	cmp    %eax,%edx
f011ab90:	74 17                	je     f011aba9 <test_kfree_bestfirstfit+0x1249>
f011ab92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab99:	83 ec 0c             	sub    $0xc,%esp
f011ab9c:	68 8c ed 12 f0       	push   $0xf012ed8c
f011aba1:	e8 e5 63 fe ff       	call   f0100f8b <cprintf>
f011aba6:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011aba9:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011abb0:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011abb6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011abb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abc0:	eb 0e                	jmp    f011abd0 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011abc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011abc5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abc8:	01 d0                	add    %edx,%eax
f011abca:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011abcd:	ff 45 f4             	incl   -0xc(%ebp)
f011abd0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011abd3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abd6:	7f ea                	jg     f011abc2 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011abd8:	e8 b5 3f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011abdd:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011abe0:	e8 ae 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011abe5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011abe8:	83 ec 0c             	sub    $0xc,%esp
f011abeb:	68 00 06 00 00       	push   $0x600
f011abf0:	e8 c5 eb fe ff       	call   f01097ba <kmalloc>
f011abf5:	83 c4 10             	add    $0x10,%esp
f011abf8:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011abfe:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011ac04:	05 10 0c 00 00       	add    $0xc10,%eax
f011ac09:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011ac0c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ac12:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ac15:	74 17                	je     f011ac2e <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac1e:	83 ec 0c             	sub    $0xc,%esp
f011ac21:	68 08 ee 12 f0       	push   $0xf012ee08
f011ac26:	e8 60 63 fe ff       	call   f0100f8b <cprintf>
f011ac2b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac2e:	e8 60 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ac33:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ac36:	74 17                	je     f011ac4f <test_kfree_bestfirstfit+0x12ef>
f011ac38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac3f:	83 ec 0c             	sub    $0xc,%esp
f011ac42:	68 5c ee 12 f0       	push   $0xf012ee5c
f011ac47:	e8 3f 63 fe ff       	call   f0100f8b <cprintf>
f011ac4c:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ac4f:	e8 3e 3f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ac54:	89 c2                	mov    %eax,%edx
f011ac56:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ac59:	39 c2                	cmp    %eax,%edx
f011ac5b:	74 17                	je     f011ac74 <test_kfree_bestfirstfit+0x1314>
f011ac5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac64:	83 ec 0c             	sub    $0xc,%esp
f011ac67:	68 cc ee 12 f0       	push   $0xf012eecc
f011ac6c:	e8 1a 63 fe ff       	call   f0100f8b <cprintf>
f011ac71:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011ac74:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011ac7b:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ac81:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011ac84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac8b:	eb 0e                	jmp    f011ac9b <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011ac8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac90:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac93:	01 d0                	add    %edx,%eax
f011ac95:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011ac98:	ff 45 f4             	incl   -0xc(%ebp)
f011ac9b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ac9e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aca1:	7f ea                	jg     f011ac8d <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011aca3:	e8 ea 3e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011aca8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011acab:	e8 e3 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011acb0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011acb3:	83 ec 0c             	sub    $0xc,%esp
f011acb6:	68 00 00 e0 01       	push   $0x1e00000
f011acbb:	e8 fa ea fe ff       	call   f01097ba <kmalloc>
f011acc0:	83 c4 10             	add    $0x10,%esp
f011acc3:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011acc9:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011accf:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011acd4:	74 17                	je     f011aced <test_kfree_bestfirstfit+0x138d>
f011acd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acdd:	83 ec 0c             	sub    $0xc,%esp
f011ace0:	68 48 ef 12 f0       	push   $0xf012ef48
f011ace5:	e8 a1 62 fe ff       	call   f0100f8b <cprintf>
f011acea:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aced:	e8 a1 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011acf2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011acf5:	74 17                	je     f011ad0e <test_kfree_bestfirstfit+0x13ae>
f011acf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acfe:	83 ec 0c             	sub    $0xc,%esp
f011ad01:	68 9c ef 12 f0       	push   $0xf012ef9c
f011ad06:	e8 80 62 fe ff       	call   f0100f8b <cprintf>
f011ad0b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ad0e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ad11:	e8 7c 3e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ad16:	29 c3                	sub    %eax,%ebx
f011ad18:	89 d8                	mov    %ebx,%eax
f011ad1a:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011ad1f:	77 17                	ja     f011ad38 <test_kfree_bestfirstfit+0x13d8>
f011ad21:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad28:	83 ec 0c             	sub    $0xc,%esp
f011ad2b:	68 0c f0 12 f0       	push   $0xf012f00c
f011ad30:	e8 56 62 fe ff       	call   f0100f8b <cprintf>
f011ad35:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011ad38:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011ad3f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ad45:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ad48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad4f:	eb 0e                	jmp    f011ad5f <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011ad51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad54:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad57:	01 d0                	add    %edx,%eax
f011ad59:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ad5c:	ff 45 f4             	incl   -0xc(%ebp)
f011ad5f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ad62:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad65:	7f ea                	jg     f011ad51 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011ad67:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ad6d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ad70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad77:	eb 1e                	jmp    f011ad97 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011ad79:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011ad7f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ad82:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad85:	01 c8                	add    %ecx,%eax
f011ad87:	8a 00                	mov    (%eax),%al
f011ad89:	0f be c0             	movsbl %al,%eax
f011ad8c:	01 d0                	add    %edx,%eax
f011ad8e:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ad94:	ff 45 f4             	incl   -0xc(%ebp)
f011ad97:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ad9a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad9d:	7f da                	jg     f011ad79 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011ad9f:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011ada5:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011ada8:	89 d0                	mov    %edx,%eax
f011adaa:	c1 e0 02             	shl    $0x2,%eax
f011adad:	01 d0                	add    %edx,%eax
f011adaf:	01 c0                	add    %eax,%eax
f011adb1:	39 c1                	cmp    %eax,%ecx
f011adb3:	74 17                	je     f011adcc <test_kfree_bestfirstfit+0x146c>
f011adb5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adbc:	83 ec 0c             	sub    $0xc,%esp
f011adbf:	68 54 f0 12 f0       	push   $0xf012f054
f011adc4:	e8 c2 61 fe ff       	call   f0100f8b <cprintf>
f011adc9:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011adcc:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011add2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011add5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011addc:	eb 1e                	jmp    f011adfc <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011adde:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011ade4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ade7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011adea:	01 c8                	add    %ecx,%eax
f011adec:	8a 00                	mov    (%eax),%al
f011adee:	0f be c0             	movsbl %al,%eax
f011adf1:	01 d0                	add    %edx,%eax
f011adf3:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011adf9:	ff 45 f4             	incl   -0xc(%ebp)
f011adfc:	8b 45 90             	mov    -0x70(%ebp),%eax
f011adff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae02:	7f da                	jg     f011adde <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011ae04:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011ae0a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ae0d:	89 d0                	mov    %edx,%eax
f011ae0f:	c1 e0 02             	shl    $0x2,%eax
f011ae12:	01 d0                	add    %edx,%eax
f011ae14:	01 c0                	add    %eax,%eax
f011ae16:	01 d0                	add    %edx,%eax
f011ae18:	39 c1                	cmp    %eax,%ecx
f011ae1a:	74 17                	je     f011ae33 <test_kfree_bestfirstfit+0x14d3>
f011ae1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae23:	83 ec 0c             	sub    $0xc,%esp
f011ae26:	68 84 f0 12 f0       	push   $0xf012f084
f011ae2b:	e8 5b 61 fe ff       	call   f0100f8b <cprintf>
f011ae30:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011ae33:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ae39:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ae3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ae43:	eb 1e                	jmp    f011ae63 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011ae45:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011ae4b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ae4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ae51:	01 c8                	add    %ecx,%eax
f011ae53:	8a 00                	mov    (%eax),%al
f011ae55:	0f be c0             	movsbl %al,%eax
f011ae58:	01 d0                	add    %edx,%eax
f011ae5a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ae60:	ff 45 f4             	incl   -0xc(%ebp)
f011ae63:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ae66:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae69:	7f da                	jg     f011ae45 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011ae6b:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011ae71:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011ae74:	89 d0                	mov    %edx,%eax
f011ae76:	01 c0                	add    %eax,%eax
f011ae78:	01 d0                	add    %edx,%eax
f011ae7a:	c1 e0 02             	shl    $0x2,%eax
f011ae7d:	39 c1                	cmp    %eax,%ecx
f011ae7f:	74 17                	je     f011ae98 <test_kfree_bestfirstfit+0x1538>
f011ae81:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae88:	83 ec 0c             	sub    $0xc,%esp
f011ae8b:	68 b4 f0 12 f0       	push   $0xf012f0b4
f011ae90:	e8 f6 60 fe ff       	call   f0100f8b <cprintf>
f011ae95:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011ae98:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ae9e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011aea1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aea8:	eb 1e                	jmp    f011aec8 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011aeaa:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011aeb0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aeb3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aeb6:	01 c8                	add    %ecx,%eax
f011aeb8:	8a 00                	mov    (%eax),%al
f011aeba:	0f be c0             	movsbl %al,%eax
f011aebd:	01 d0                	add    %edx,%eax
f011aebf:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011aec5:	ff 45 f4             	incl   -0xc(%ebp)
f011aec8:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aecb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aece:	7f da                	jg     f011aeaa <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011aed0:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011aed6:	8b 55 98             	mov    -0x68(%ebp),%edx
f011aed9:	89 d0                	mov    %edx,%eax
f011aedb:	01 c0                	add    %eax,%eax
f011aedd:	01 d0                	add    %edx,%eax
f011aedf:	c1 e0 02             	shl    $0x2,%eax
f011aee2:	01 d0                	add    %edx,%eax
f011aee4:	39 c1                	cmp    %eax,%ecx
f011aee6:	74 17                	je     f011aeff <test_kfree_bestfirstfit+0x159f>
f011aee8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aeef:	83 ec 0c             	sub    $0xc,%esp
f011aef2:	68 e4 f0 12 f0       	push   $0xf012f0e4
f011aef7:	e8 8f 60 fe ff       	call   f0100f8b <cprintf>
f011aefc:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011aeff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af03:	74 04                	je     f011af09 <test_kfree_bestfirstfit+0x15a9>
f011af05:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011af09:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011af10:	83 ec 0c             	sub    $0xc,%esp
f011af13:	68 11 f1 12 f0       	push   $0xf012f111
f011af18:	e8 6e 60 fe ff       	call   f0100f8b <cprintf>
f011af1d:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011af20:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011af27:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011af2e:	eb 4e                	jmp    f011af7e <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011af30:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011af33:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011af38:	83 ec 04             	sub    $0x4,%esp
f011af3b:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011af41:	51                   	push   %ecx
f011af42:	52                   	push   %edx
f011af43:	50                   	push   %eax
f011af44:	e8 d1 d7 fe ff       	call   f010871a <get_page_table>
f011af49:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011af4c:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011af52:	85 c0                	test   %eax,%eax
f011af54:	75 1d                	jne    f011af73 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011af56:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af5a:	74 17                	je     f011af73 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011af5c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af63:	83 ec 0c             	sub    $0xc,%esp
f011af66:	68 30 f1 12 f0       	push   $0xf012f130
f011af6b:	e8 1b 60 fe ff       	call   f0100f8b <cprintf>
f011af70:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011af73:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011af7a:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011af7e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011af82:	78 ac                	js     f011af30 <test_kfree_bestfirstfit+0x15d0>
f011af84:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011af88:	7f 09                	jg     f011af93 <test_kfree_bestfirstfit+0x1633>
f011af8a:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011af91:	76 9d                	jbe    f011af30 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011af93:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af97:	74 04                	je     f011af9d <test_kfree_bestfirstfit+0x163d>
f011af99:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011af9d:	83 ec 08             	sub    $0x8,%esp
f011afa0:	ff 75 f0             	pushl  -0x10(%ebp)
f011afa3:	68 98 f1 12 f0       	push   $0xf012f198
f011afa8:	e8 de 5f fe ff       	call   f0100f8b <cprintf>
f011afad:	83 c4 10             	add    $0x10,%esp

	return 1;
f011afb0:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011afb5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011afb8:	5b                   	pop    %ebx
f011afb9:	5f                   	pop    %edi
f011afba:	5d                   	pop    %ebp
f011afbb:	c3                   	ret    

f011afbc <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011afbc:	55                   	push   %ebp
f011afbd:	89 e5                	mov    %esp,%ebp
f011afbf:	57                   	push   %edi
f011afc0:	53                   	push   %ebx
f011afc1:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011afc7:	83 ec 0c             	sub    $0xc,%esp
f011afca:	68 68 b4 12 f0       	push   $0xf012b468
f011afcf:	e8 b7 5f fe ff       	call   f0100f8b <cprintf>
f011afd4:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011afd7:	83 ec 0c             	sub    $0xc,%esp
f011afda:	68 98 b4 12 f0       	push   $0xf012b498
f011afdf:	e8 a7 5f fe ff       	call   f0100f8b <cprintf>
f011afe4:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011afe7:	83 ec 0c             	sub    $0xc,%esp
f011afea:	68 68 b4 12 f0       	push   $0xf012b468
f011afef:	e8 97 5f fe ff       	call   f0100f8b <cprintf>
f011aff4:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011aff7:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011affb:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011afff:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b005:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b00b:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b012:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b019:	e8 74 3b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b01e:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b021:	83 ec 0c             	sub    $0xc,%esp
f011b024:	68 bc f1 12 f0       	push   $0xf012f1bc
f011b029:	e8 5d 5f fe ff       	call   f0100f8b <cprintf>
f011b02e:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b031:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011b037:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b03c:	b8 00 00 00 00       	mov    $0x0,%eax
f011b041:	89 d7                	mov    %edx,%edi
f011b043:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b045:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011b04b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b050:	b8 00 00 00 00       	mov    $0x0,%eax
f011b055:	89 d7                	mov    %edx,%edi
f011b057:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b059:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b060:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b067:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011b06d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b072:	b8 00 00 00 00       	mov    $0x0,%eax
f011b077:	89 d7                	mov    %edx,%edi
f011b079:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b07b:	e8 12 3b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b080:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b083:	e8 0b 9a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b088:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b08b:	83 ec 0c             	sub    $0xc,%esp
f011b08e:	68 00 fc 1f 00       	push   $0x1ffc00
f011b093:	e8 22 e7 fe ff       	call   f01097ba <kmalloc>
f011b098:	83 c4 10             	add    $0x10,%esp
f011b09b:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b0a1:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b0a7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b0ac:	74 17                	je     f011b0c5 <test_kheap_phys_addr+0x109>
f011b0ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0b5:	83 ec 0c             	sub    $0xc,%esp
f011b0b8:	68 60 d5 12 f0       	push   $0xf012d560
f011b0bd:	e8 c9 5e fe ff       	call   f0100f8b <cprintf>
f011b0c2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0c5:	e8 c9 99 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b0ca:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b0cd:	74 17                	je     f011b0e6 <test_kheap_phys_addr+0x12a>
f011b0cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0d6:	83 ec 0c             	sub    $0xc,%esp
f011b0d9:	68 b4 d5 12 f0       	push   $0xf012d5b4
f011b0de:	e8 a8 5e fe ff       	call   f0100f8b <cprintf>
f011b0e3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b0e6:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b0e9:	e8 a4 3a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b0ee:	29 c3                	sub    %eax,%ebx
f011b0f0:	89 d8                	mov    %ebx,%eax
f011b0f2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b0f7:	77 17                	ja     f011b110 <test_kheap_phys_addr+0x154>
f011b0f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b100:	83 ec 0c             	sub    $0xc,%esp
f011b103:	68 24 d6 12 f0       	push   $0xf012d624
f011b108:	e8 7e 5e fe ff       	call   f0100f8b <cprintf>
f011b10d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b110:	e8 7d 3a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b115:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b118:	e8 76 99 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b11d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b120:	83 ec 0c             	sub    $0xc,%esp
f011b123:	68 00 fc 1f 00       	push   $0x1ffc00
f011b128:	e8 8d e6 fe ff       	call   f01097ba <kmalloc>
f011b12d:	83 c4 10             	add    $0x10,%esp
f011b130:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b136:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b13c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b141:	74 17                	je     f011b15a <test_kheap_phys_addr+0x19e>
f011b143:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b14a:	83 ec 0c             	sub    $0xc,%esp
f011b14d:	68 6c d6 12 f0       	push   $0xf012d66c
f011b152:	e8 34 5e fe ff       	call   f0100f8b <cprintf>
f011b157:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b15a:	e8 34 99 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b15f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b162:	74 17                	je     f011b17b <test_kheap_phys_addr+0x1bf>
f011b164:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b16b:	83 ec 0c             	sub    $0xc,%esp
f011b16e:	68 c0 d6 12 f0       	push   $0xf012d6c0
f011b173:	e8 13 5e fe ff       	call   f0100f8b <cprintf>
f011b178:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b17b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b17e:	e8 0f 3a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b183:	29 c3                	sub    %eax,%ebx
f011b185:	89 d8                	mov    %ebx,%eax
f011b187:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b18c:	77 17                	ja     f011b1a5 <test_kheap_phys_addr+0x1e9>
f011b18e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b195:	83 ec 0c             	sub    $0xc,%esp
f011b198:	68 30 d7 12 f0       	push   $0xf012d730
f011b19d:	e8 e9 5d fe ff       	call   f0100f8b <cprintf>
f011b1a2:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b1a5:	e8 e8 39 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b1aa:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b1ad:	e8 e1 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b1b2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b1b5:	83 ec 0c             	sub    $0xc,%esp
f011b1b8:	68 00 04 00 00       	push   $0x400
f011b1bd:	e8 f8 e5 fe ff       	call   f01097ba <kmalloc>
f011b1c2:	83 c4 10             	add    $0x10,%esp
f011b1c5:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b1cb:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b1d1:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b1d6:	76 28                	jbe    f011b200 <test_kheap_phys_addr+0x244>
f011b1d8:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b1de:	83 ec 0c             	sub    $0xc,%esp
f011b1e1:	6a 00                	push   $0x0
f011b1e3:	e8 9f e4 fe ff       	call   f0109687 <sbrk>
f011b1e8:	83 c4 10             	add    $0x10,%esp
f011b1eb:	39 c3                	cmp    %eax,%ebx
f011b1ed:	73 11                	jae    f011b200 <test_kheap_phys_addr+0x244>
f011b1ef:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b1f5:	89 c2                	mov    %eax,%edx
f011b1f7:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b1fc:	39 c2                	cmp    %eax,%edx
f011b1fe:	72 17                	jb     f011b217 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b200:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b207:	83 ec 0c             	sub    $0xc,%esp
f011b20a:	68 ec f1 12 f0       	push   $0xf012f1ec
f011b20f:	e8 77 5d fe ff       	call   f0100f8b <cprintf>
f011b214:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b217:	e8 77 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b21c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b21f:	74 17                	je     f011b238 <test_kheap_phys_addr+0x27c>
f011b221:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b228:	83 ec 0c             	sub    $0xc,%esp
f011b22b:	68 cc d7 12 f0       	push   $0xf012d7cc
f011b230:	e8 56 5d fe ff       	call   f0100f8b <cprintf>
f011b235:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b238:	e8 55 39 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b23d:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b240:	e8 4e 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b245:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b248:	83 ec 0c             	sub    $0xc,%esp
f011b24b:	68 00 08 00 00       	push   $0x800
f011b250:	e8 65 e5 fe ff       	call   f01097ba <kmalloc>
f011b255:	83 c4 10             	add    $0x10,%esp
f011b258:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b25e:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b264:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b269:	76 28                	jbe    f011b293 <test_kheap_phys_addr+0x2d7>
f011b26b:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b271:	83 ec 0c             	sub    $0xc,%esp
f011b274:	6a 00                	push   $0x0
f011b276:	e8 0c e4 fe ff       	call   f0109687 <sbrk>
f011b27b:	83 c4 10             	add    $0x10,%esp
f011b27e:	39 c3                	cmp    %eax,%ebx
f011b280:	73 11                	jae    f011b293 <test_kheap_phys_addr+0x2d7>
f011b282:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b288:	89 c2                	mov    %eax,%edx
f011b28a:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b28f:	39 c2                	cmp    %eax,%edx
f011b291:	72 17                	jb     f011b2aa <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b293:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b29a:	83 ec 0c             	sub    $0xc,%esp
f011b29d:	68 78 f2 12 f0       	push   $0xf012f278
f011b2a2:	e8 e4 5c fe ff       	call   f0100f8b <cprintf>
f011b2a7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2aa:	e8 e4 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b2af:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b2b2:	74 17                	je     f011b2cb <test_kheap_phys_addr+0x30f>
f011b2b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2bb:	83 ec 0c             	sub    $0xc,%esp
f011b2be:	68 d8 d8 12 f0       	push   $0xf012d8d8
f011b2c3:	e8 c3 5c fe ff       	call   f0100f8b <cprintf>
f011b2c8:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b2cb:	e8 c2 38 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b2d0:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b2d3:	e8 bb 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b2d8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b2db:	83 ec 0c             	sub    $0xc,%esp
f011b2de:	68 00 06 00 00       	push   $0x600
f011b2e3:	e8 d2 e4 fe ff       	call   f01097ba <kmalloc>
f011b2e8:	83 c4 10             	add    $0x10,%esp
f011b2eb:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b2f1:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b2f7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b2fc:	76 28                	jbe    f011b326 <test_kheap_phys_addr+0x36a>
f011b2fe:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b304:	83 ec 0c             	sub    $0xc,%esp
f011b307:	6a 00                	push   $0x0
f011b309:	e8 79 e3 fe ff       	call   f0109687 <sbrk>
f011b30e:	83 c4 10             	add    $0x10,%esp
f011b311:	39 c3                	cmp    %eax,%ebx
f011b313:	73 11                	jae    f011b326 <test_kheap_phys_addr+0x36a>
f011b315:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b31b:	89 c2                	mov    %eax,%edx
f011b31d:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b322:	39 c2                	cmp    %eax,%edx
f011b324:	72 17                	jb     f011b33d <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b326:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b32d:	83 ec 0c             	sub    $0xc,%esp
f011b330:	68 04 f3 12 f0       	push   $0xf012f304
f011b335:	e8 51 5c fe ff       	call   f0100f8b <cprintf>
f011b33a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b33d:	e8 51 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b342:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b345:	74 17                	je     f011b35e <test_kheap_phys_addr+0x3a2>
f011b347:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b34e:	83 ec 0c             	sub    $0xc,%esp
f011b351:	68 e4 d9 12 f0       	push   $0xf012d9e4
f011b356:	e8 30 5c fe ff       	call   f0100f8b <cprintf>
f011b35b:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b35e:	e8 2f 38 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b363:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b366:	e8 28 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b36b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b36e:	83 ec 0c             	sub    $0xc,%esp
f011b371:	68 00 1c 00 00       	push   $0x1c00
f011b376:	e8 3f e4 fe ff       	call   f01097ba <kmalloc>
f011b37b:	83 c4 10             	add    $0x10,%esp
f011b37e:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b384:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b38a:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b38f:	74 17                	je     f011b3a8 <test_kheap_phys_addr+0x3ec>
f011b391:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b398:	83 ec 0c             	sub    $0xc,%esp
f011b39b:	68 9c da 12 f0       	push   $0xf012da9c
f011b3a0:	e8 e6 5b fe ff       	call   f0100f8b <cprintf>
f011b3a5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b3a8:	e8 e6 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b3ad:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b3b0:	74 17                	je     f011b3c9 <test_kheap_phys_addr+0x40d>
f011b3b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3b9:	83 ec 0c             	sub    $0xc,%esp
f011b3bc:	68 f0 da 12 f0       	push   $0xf012daf0
f011b3c1:	e8 c5 5b fe ff       	call   f0100f8b <cprintf>
f011b3c6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b3c9:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b3cc:	e8 c1 37 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b3d1:	29 c3                	sub    %eax,%ebx
f011b3d3:	89 d8                	mov    %ebx,%eax
f011b3d5:	83 f8 01             	cmp    $0x1,%eax
f011b3d8:	77 17                	ja     f011b3f1 <test_kheap_phys_addr+0x435>
f011b3da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3e1:	83 ec 0c             	sub    $0xc,%esp
f011b3e4:	68 60 db 12 f0       	push   $0xf012db60
f011b3e9:	e8 9d 5b fe ff       	call   f0100f8b <cprintf>
f011b3ee:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b3f1:	e8 9c 37 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b3f6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b3f9:	e8 95 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b3fe:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b401:	83 ec 0c             	sub    $0xc,%esp
f011b404:	68 00 fc 2f 00       	push   $0x2ffc00
f011b409:	e8 ac e3 fe ff       	call   f01097ba <kmalloc>
f011b40e:	83 c4 10             	add    $0x10,%esp
f011b411:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b417:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b41d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b422:	74 17                	je     f011b43b <test_kheap_phys_addr+0x47f>
f011b424:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b42b:	83 ec 0c             	sub    $0xc,%esp
f011b42e:	68 90 f3 12 f0       	push   $0xf012f390
f011b433:	e8 53 5b fe ff       	call   f0100f8b <cprintf>
f011b438:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b43b:	e8 53 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b440:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b443:	74 17                	je     f011b45c <test_kheap_phys_addr+0x4a0>
f011b445:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b44c:	83 ec 0c             	sub    $0xc,%esp
f011b44f:	68 34 dc 12 f0       	push   $0xf012dc34
f011b454:	e8 32 5b fe ff       	call   f0100f8b <cprintf>
f011b459:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b45c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b45f:	e8 2e 37 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b464:	29 c3                	sub    %eax,%ebx
f011b466:	89 d8                	mov    %ebx,%eax
f011b468:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b46d:	77 17                	ja     f011b486 <test_kheap_phys_addr+0x4ca>
f011b46f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b476:	83 ec 0c             	sub    $0xc,%esp
f011b479:	68 e4 f3 12 f0       	push   $0xf012f3e4
f011b47e:	e8 08 5b fe ff       	call   f0100f8b <cprintf>
f011b483:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b486:	e8 07 37 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b48b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b48e:	e8 00 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b493:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b496:	83 ec 0c             	sub    $0xc,%esp
f011b499:	68 00 fc 5f 00       	push   $0x5ffc00
f011b49e:	e8 17 e3 fe ff       	call   f01097ba <kmalloc>
f011b4a3:	83 c4 10             	add    $0x10,%esp
f011b4a6:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b4ac:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b4b2:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b4b7:	74 17                	je     f011b4d0 <test_kheap_phys_addr+0x514>
f011b4b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4c0:	83 ec 0c             	sub    $0xc,%esp
f011b4c3:	68 2c f4 12 f0       	push   $0xf012f42c
f011b4c8:	e8 be 5a fe ff       	call   f0100f8b <cprintf>
f011b4cd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4d0:	e8 be 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b4d5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b4d8:	74 17                	je     f011b4f1 <test_kheap_phys_addr+0x535>
f011b4da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4e1:	83 ec 0c             	sub    $0xc,%esp
f011b4e4:	68 30 dd 12 f0       	push   $0xf012dd30
f011b4e9:	e8 9d 5a fe ff       	call   f0100f8b <cprintf>
f011b4ee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b4f1:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b4f4:	e8 99 36 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b4f9:	29 c3                	sub    %eax,%ebx
f011b4fb:	89 d8                	mov    %ebx,%eax
f011b4fd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b502:	77 17                	ja     f011b51b <test_kheap_phys_addr+0x55f>
f011b504:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b50b:	83 ec 0c             	sub    $0xc,%esp
f011b50e:	68 80 f4 12 f0       	push   $0xf012f480
f011b513:	e8 73 5a fe ff       	call   f0100f8b <cprintf>
f011b518:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b51b:	e8 72 36 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b520:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b523:	e8 6b 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b528:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b52b:	83 ec 0c             	sub    $0xc,%esp
f011b52e:	68 00 38 00 00       	push   $0x3800
f011b533:	e8 82 e2 fe ff       	call   f01097ba <kmalloc>
f011b538:	83 c4 10             	add    $0x10,%esp
f011b53b:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b541:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b547:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b54c:	74 17                	je     f011b565 <test_kheap_phys_addr+0x5a9>
f011b54e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b555:	83 ec 0c             	sub    $0xc,%esp
f011b558:	68 c8 f4 12 f0       	push   $0xf012f4c8
f011b55d:	e8 29 5a fe ff       	call   f0100f8b <cprintf>
f011b562:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b565:	e8 29 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b56a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b56d:	74 17                	je     f011b586 <test_kheap_phys_addr+0x5ca>
f011b56f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b576:	83 ec 0c             	sub    $0xc,%esp
f011b579:	68 1c f5 12 f0       	push   $0xf012f51c
f011b57e:	e8 08 5a fe ff       	call   f0100f8b <cprintf>
f011b583:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b586:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b589:	e8 04 36 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b58e:	29 c3                	sub    %eax,%ebx
f011b590:	89 d8                	mov    %ebx,%eax
f011b592:	83 f8 03             	cmp    $0x3,%eax
f011b595:	77 17                	ja     f011b5ae <test_kheap_phys_addr+0x5f2>
f011b597:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b59e:	83 ec 0c             	sub    $0xc,%esp
f011b5a1:	68 8c f5 12 f0       	push   $0xf012f58c
f011b5a6:	e8 e0 59 fe ff       	call   f0100f8b <cprintf>
f011b5ab:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b5ae:	83 ec 0c             	sub    $0xc,%esp
f011b5b1:	68 d4 f5 12 f0       	push   $0xf012f5d4
f011b5b6:	e8 d0 59 fe ff       	call   f0100f8b <cprintf>
f011b5bb:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b5be:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b5c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b5cc:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b5d3:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b5d8:	05 00 10 00 00       	add    $0x1000,%eax
f011b5dd:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b5e0:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b5e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b5e6:	eb 2e                	jmp    f011b616 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b5e8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b5eb:	8d 43 01             	lea    0x1(%ebx),%eax
f011b5ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b5f1:	83 ec 0c             	sub    $0xc,%esp
f011b5f4:	ff 75 e8             	pushl  -0x18(%ebp)
f011b5f7:	e8 04 e5 fe ff       	call   f0109b00 <kheap_physical_address>
f011b5fc:	83 c4 10             	add    $0x10,%esp
f011b5ff:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b606:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b609:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b60c:	01 d0                	add    %edx,%eax
f011b60e:	05 00 10 00 00       	add    $0x1000,%eax
f011b613:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b616:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b619:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b61c:	72 ca                	jb     f011b5e8 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b61e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b621:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b624:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b62b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b62e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b631:	e9 ce 00 00 00       	jmp    f011b704 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b636:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011b63b:	83 ec 04             	sub    $0x4,%esp
f011b63e:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b644:	52                   	push   %edx
f011b645:	ff 75 e8             	pushl  -0x18(%ebp)
f011b648:	50                   	push   %eax
f011b649:	e8 cc d0 fe ff       	call   f010871a <get_page_table>
f011b64e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b651:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b657:	85 c0                	test   %eax,%eax
f011b659:	75 1e                	jne    f011b679 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b65b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b662:	83 ec 04             	sub    $0x4,%esp
f011b665:	68 20 f6 12 f0       	push   $0xf012f620
f011b66a:	68 e7 05 00 00       	push   $0x5e7
f011b66f:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011b674:	e8 c0 4c fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b679:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b67c:	c1 e8 0c             	shr    $0xc,%eax
f011b67f:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b684:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b687:	eb 62                	jmp    f011b6eb <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b689:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b68f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b692:	c1 e2 02             	shl    $0x2,%edx
f011b695:	01 d0                	add    %edx,%eax
f011b697:	8b 00                	mov    (%eax),%eax
f011b699:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b69e:	89 c2                	mov    %eax,%edx
f011b6a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b6a3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b6a8:	01 c2                	add    %eax,%edx
f011b6aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b6ad:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b6b4:	39 c2                	cmp    %eax,%edx
f011b6b6:	74 1d                	je     f011b6d5 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b6b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b6bc:	74 17                	je     f011b6d5 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b6be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6c5:	83 ec 0c             	sub    $0xc,%esp
f011b6c8:	68 80 f6 12 f0       	push   $0xf012f680
f011b6cd:	e8 b9 58 fe ff       	call   f0100f8b <cprintf>
f011b6d2:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b6d5:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b6d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b6db:	01 d0                	add    %edx,%eax
f011b6dd:	05 00 10 00 00       	add    $0x1000,%eax
f011b6e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b6e5:	ff 45 e4             	incl   -0x1c(%ebp)
f011b6e8:	ff 45 f4             	incl   -0xc(%ebp)
f011b6eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b6ee:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b6f1:	7d 11                	jge    f011b704 <test_kheap_phys_addr+0x748>
f011b6f3:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b6fa:	7f 08                	jg     f011b704 <test_kheap_phys_addr+0x748>
f011b6fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b6ff:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b702:	72 85                	jb     f011b689 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b704:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b707:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b70a:	0f 82 26 ff ff ff    	jb     f011b636 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b710:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b714:	74 04                	je     f011b71a <test_kheap_phys_addr+0x75e>
f011b716:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b71a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b721:	83 ec 0c             	sub    $0xc,%esp
f011b724:	68 a4 f6 12 f0       	push   $0xf012f6a4
f011b729:	e8 5d 58 fe ff       	call   f0100f8b <cprintf>
f011b72e:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b731:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b738:	e9 b0 00 00 00       	jmp    f011b7ed <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b73d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b740:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b747:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b74a:	83 ec 0c             	sub    $0xc,%esp
f011b74d:	ff 75 90             	pushl  -0x70(%ebp)
f011b750:	e8 ab e3 fe ff       	call   f0109b00 <kheap_physical_address>
f011b755:	83 c4 10             	add    $0x10,%esp
f011b758:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b75b:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011b760:	83 ec 04             	sub    $0x4,%esp
f011b763:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b769:	52                   	push   %edx
f011b76a:	ff 75 90             	pushl  -0x70(%ebp)
f011b76d:	50                   	push   %eax
f011b76e:	e8 a7 cf fe ff       	call   f010871a <get_page_table>
f011b773:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b776:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b77c:	85 c0                	test   %eax,%eax
f011b77e:	75 1e                	jne    f011b79e <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b780:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b787:	83 ec 04             	sub    $0x4,%esp
f011b78a:	68 f4 f6 12 f0       	push   $0xf012f6f4
f011b78f:	68 04 06 00 00       	push   $0x604
f011b794:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011b799:	e8 9b 4b fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b79e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b7a4:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b7a7:	c1 ea 0c             	shr    $0xc,%edx
f011b7aa:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b7b0:	c1 e2 02             	shl    $0x2,%edx
f011b7b3:	01 d0                	add    %edx,%eax
f011b7b5:	8b 00                	mov    (%eax),%eax
f011b7b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b7bc:	89 c2                	mov    %eax,%edx
f011b7be:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b7c1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b7c6:	01 d0                	add    %edx,%eax
f011b7c8:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b7cb:	74 1d                	je     f011b7ea <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b7cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7d1:	74 17                	je     f011b7ea <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b7d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7da:	83 ec 0c             	sub    $0xc,%esp
f011b7dd:	68 54 f7 12 f0       	push   $0xf012f754
f011b7e2:	e8 a4 57 fe ff       	call   f0100f8b <cprintf>
f011b7e7:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b7ea:	ff 45 e0             	incl   -0x20(%ebp)
f011b7ed:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b7f1:	0f 8e 46 ff ff ff    	jle    f011b73d <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b7f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7fb:	74 04                	je     f011b801 <test_kheap_phys_addr+0x845>
f011b7fd:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b801:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b808:	83 ec 0c             	sub    $0xc,%esp
f011b80b:	68 78 f7 12 f0       	push   $0xf012f778
f011b810:	e8 76 57 fe ff       	call   f0100f8b <cprintf>
f011b815:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b818:	e8 75 33 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b81d:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b820:	e8 6e 92 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b825:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b828:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b82e:	83 ec 0c             	sub    $0xc,%esp
f011b831:	50                   	push   %eax
f011b832:	e8 e3 e1 fe ff       	call   f0109a1a <kfree>
f011b837:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b83a:	e8 54 92 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b83f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b842:	74 17                	je     f011b85b <test_kheap_phys_addr+0x89f>
f011b844:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b84b:	83 ec 0c             	sub    $0xc,%esp
f011b84e:	68 64 e2 12 f0       	push   $0xf012e264
f011b853:	e8 33 57 fe ff       	call   f0100f8b <cprintf>
f011b858:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b85b:	e8 32 33 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b860:	89 c2                	mov    %eax,%edx
f011b862:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b865:	29 c2                	sub    %eax,%edx
f011b867:	89 d0                	mov    %edx,%eax
f011b869:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b86e:	77 17                	ja     f011b887 <test_kheap_phys_addr+0x8cb>
f011b870:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b877:	83 ec 0c             	sub    $0xc,%esp
f011b87a:	68 a0 f7 12 f0       	push   $0xf012f7a0
f011b87f:	e8 07 57 fe ff       	call   f0100f8b <cprintf>
f011b884:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b887:	e8 06 33 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b88c:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b88f:	e8 ff 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b894:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b897:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b89d:	83 ec 0c             	sub    $0xc,%esp
f011b8a0:	50                   	push   %eax
f011b8a1:	e8 74 e1 fe ff       	call   f0109a1a <kfree>
f011b8a6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8a9:	e8 e5 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b8ae:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b8b1:	74 17                	je     f011b8ca <test_kheap_phys_addr+0x90e>
f011b8b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b8ba:	83 ec 0c             	sub    $0xc,%esp
f011b8bd:	68 a4 e3 12 f0       	push   $0xf012e3a4
f011b8c2:	e8 c4 56 fe ff       	call   f0100f8b <cprintf>
f011b8c7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b8ca:	e8 c3 32 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b8cf:	89 c2                	mov    %eax,%edx
f011b8d1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b8d4:	29 c2                	sub    %eax,%edx
f011b8d6:	89 d0                	mov    %edx,%eax
f011b8d8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b8dd:	77 17                	ja     f011b8f6 <test_kheap_phys_addr+0x93a>
f011b8df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b8e6:	83 ec 0c             	sub    $0xc,%esp
f011b8e9:	68 dc f7 12 f0       	push   $0xf012f7dc
f011b8ee:	e8 98 56 fe ff       	call   f0100f8b <cprintf>
f011b8f3:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b8f6:	e8 97 32 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b8fb:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b8fe:	e8 90 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b903:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b906:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b90c:	83 ec 0c             	sub    $0xc,%esp
f011b90f:	50                   	push   %eax
f011b910:	e8 05 e1 fe ff       	call   f0109a1a <kfree>
f011b915:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b918:	e8 76 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b91d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b920:	74 17                	je     f011b939 <test_kheap_phys_addr+0x97d>
f011b922:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b929:	83 ec 0c             	sub    $0xc,%esp
f011b92c:	68 b0 e4 12 f0       	push   $0xf012e4b0
f011b931:	e8 55 56 fe ff       	call   f0100f8b <cprintf>
f011b936:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b939:	e8 54 32 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011b93e:	89 c2                	mov    %eax,%edx
f011b940:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b943:	29 c2                	sub    %eax,%edx
f011b945:	89 d0                	mov    %edx,%eax
f011b947:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b94c:	77 17                	ja     f011b965 <test_kheap_phys_addr+0x9a9>
f011b94e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b955:	83 ec 0c             	sub    $0xc,%esp
f011b958:	68 18 f8 12 f0       	push   $0xf012f818
f011b95d:	e8 29 56 fe ff       	call   f0100f8b <cprintf>
f011b962:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b965:	83 ec 0c             	sub    $0xc,%esp
f011b968:	68 54 f8 12 f0       	push   $0xf012f854
f011b96d:	e8 19 56 fe ff       	call   f0100f8b <cprintf>
f011b972:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b975:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b97c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b983:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b98a:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b98d:	8b 15 38 0e 18 f0    	mov    0xf0180e38,%edx
f011b993:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b999:	01 d0                	add    %edx,%eax
f011b99b:	05 00 10 00 00       	add    $0x1000,%eax
f011b9a0:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b9a6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b9ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b9af:	eb 25                	jmp    f011b9d6 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b9b1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b9b4:	8d 43 01             	lea    0x1(%ebx),%eax
f011b9b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b9ba:	83 ec 0c             	sub    $0xc,%esp
f011b9bd:	ff 75 d8             	pushl  -0x28(%ebp)
f011b9c0:	e8 3b e1 fe ff       	call   f0109b00 <kheap_physical_address>
f011b9c5:	83 c4 10             	add    $0x10,%esp
f011b9c8:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b9cf:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b9d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b9d9:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b9dc:	72 d3                	jb     f011b9b1 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b9de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b9e1:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b9e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b9ee:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b9f4:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b9f7:	e9 f4 00 00 00       	jmp    f011baf0 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b9fc:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011ba01:	83 ec 04             	sub    $0x4,%esp
f011ba04:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011ba0a:	52                   	push   %edx
f011ba0b:	ff 75 d8             	pushl  -0x28(%ebp)
f011ba0e:	50                   	push   %eax
f011ba0f:	e8 06 cd fe ff       	call   f010871a <get_page_table>
f011ba14:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ba17:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011ba1d:	85 c0                	test   %eax,%eax
f011ba1f:	75 24                	jne    f011ba45 <test_kheap_phys_addr+0xa89>
				if (correct)
f011ba21:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba25:	74 1e                	je     f011ba45 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ba27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba2e:	83 ec 04             	sub    $0x4,%esp
f011ba31:	68 a4 f8 12 f0       	push   $0xf012f8a4
f011ba36:	68 42 06 00 00       	push   $0x642
f011ba3b:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011ba40:	e8 f4 48 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011ba45:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ba48:	c1 e8 0c             	shr    $0xc,%eax
f011ba4b:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ba50:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ba53:	eb 7b                	jmp    f011bad0 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011ba55:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011ba5c:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011ba62:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ba65:	c1 e2 02             	shl    $0x2,%edx
f011ba68:	01 d0                	add    %edx,%eax
f011ba6a:	8b 00                	mov    (%eax),%eax
f011ba6c:	83 e0 01             	and    $0x1,%eax
f011ba6f:	85 c0                	test   %eax,%eax
f011ba71:	74 24                	je     f011ba97 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011ba73:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011ba79:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ba7c:	c1 e2 02             	shl    $0x2,%edx
f011ba7f:	01 d0                	add    %edx,%eax
f011ba81:	8b 00                	mov    (%eax),%eax
f011ba83:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ba88:	89 c2                	mov    %eax,%edx
f011ba8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ba8d:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ba92:	01 d0                	add    %edx,%eax
f011ba94:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011ba97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba9a:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011baa1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011baa4:	74 1d                	je     f011bac3 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011baa6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011baaa:	74 17                	je     f011bac3 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011baac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bab3:	83 ec 0c             	sub    $0xc,%esp
f011bab6:	68 04 f9 12 f0       	push   $0xf012f904
f011babb:	e8 cb 54 fe ff       	call   f0100f8b <cprintf>
f011bac0:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011bac3:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011baca:	ff 45 d4             	incl   -0x2c(%ebp)
f011bacd:	ff 45 f4             	incl   -0xc(%ebp)
f011bad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bad3:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011bad9:	7d 15                	jge    f011baf0 <test_kheap_phys_addr+0xb34>
f011badb:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bae2:	7f 0c                	jg     f011baf0 <test_kheap_phys_addr+0xb34>
f011bae4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bae7:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011baea:	0f 82 65 ff ff ff    	jb     f011ba55 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011baf0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011baf3:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011baf6:	0f 82 00 ff ff ff    	jb     f011b9fc <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bafc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb00:	74 04                	je     f011bb06 <test_kheap_phys_addr+0xb4a>
f011bb02:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011bb06:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011bb0d:	83 ec 0c             	sub    $0xc,%esp
f011bb10:	68 28 f9 12 f0       	push   $0xf012f928
f011bb15:	e8 71 54 fe ff       	call   f0100f8b <cprintf>
f011bb1a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011bb1d:	83 ec 0c             	sub    $0xc,%esp
f011bb20:	6a 00                	push   $0x0
f011bb22:	e8 60 db fe ff       	call   f0109687 <sbrk>
f011bb27:	83 c4 10             	add    $0x10,%esp
f011bb2a:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011bb2f:	77 17                	ja     f011bb48 <test_kheap_phys_addr+0xb8c>
f011bb31:	83 ec 04             	sub    $0x4,%esp
f011bb34:	68 80 f9 12 f0       	push   $0xf012f980
f011bb39:	68 5d 06 00 00       	push   $0x65d
f011bb3e:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011bb43:	e8 f1 47 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bb48:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011bb4f:	e9 af 00 00 00       	jmp    f011bc03 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011bb54:	83 ec 0c             	sub    $0xc,%esp
f011bb57:	ff 75 d0             	pushl  -0x30(%ebp)
f011bb5a:	e8 a1 df fe ff       	call   f0109b00 <kheap_physical_address>
f011bb5f:	83 c4 10             	add    $0x10,%esp
f011bb62:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bb68:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011bb6d:	83 ec 04             	sub    $0x4,%esp
f011bb70:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011bb76:	52                   	push   %edx
f011bb77:	ff 75 d0             	pushl  -0x30(%ebp)
f011bb7a:	50                   	push   %eax
f011bb7b:	e8 9a cb fe ff       	call   f010871a <get_page_table>
f011bb80:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bb83:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bb89:	85 c0                	test   %eax,%eax
f011bb8b:	75 24                	jne    f011bbb1 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011bb8d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb91:	74 1e                	je     f011bbb1 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bb93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb9a:	83 ec 04             	sub    $0x4,%esp
f011bb9d:	68 9c f9 12 f0       	push   $0xf012f99c
f011bba2:	68 65 06 00 00       	push   $0x665
f011bba7:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011bbac:	e8 88 47 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011bbb1:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bbb7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bbba:	c1 ea 0c             	shr    $0xc,%edx
f011bbbd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011bbc3:	c1 e2 02             	shl    $0x2,%edx
f011bbc6:	01 d0                	add    %edx,%eax
f011bbc8:	8b 00                	mov    (%eax),%eax
f011bbca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bbcf:	89 c2                	mov    %eax,%edx
f011bbd1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bbd4:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bbd9:	01 d0                	add    %edx,%eax
f011bbdb:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bbe1:	74 1d                	je     f011bc00 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011bbe3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bbe7:	74 17                	je     f011bc00 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011bbe9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bbf0:	83 ec 0c             	sub    $0xc,%esp
f011bbf3:	68 fc f9 12 f0       	push   $0xf012f9fc
f011bbf8:	e8 8e 53 fe ff       	call   f0100f8b <cprintf>
f011bbfd:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bc00:	ff 45 d0             	incl   -0x30(%ebp)
f011bc03:	83 ec 0c             	sub    $0xc,%esp
f011bc06:	6a 00                	push   $0x0
f011bc08:	e8 7a da fe ff       	call   f0109687 <sbrk>
f011bc0d:	83 c4 10             	add    $0x10,%esp
f011bc10:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011bc13:	0f 87 3b ff ff ff    	ja     f011bb54 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011bc19:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bc1d:	74 04                	je     f011bc23 <test_kheap_phys_addr+0xc67>
f011bc1f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011bc23:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011bc2a:	83 ec 0c             	sub    $0xc,%esp
f011bc2d:	68 20 fa 12 f0       	push   $0xf012fa20
f011bc32:	e8 54 53 fe ff       	call   f0100f8b <cprintf>
f011bc37:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011bc3a:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011bc41:	10 00 f9 
		i = 0;
f011bc44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bc4b:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bc51:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011bc54:	eb 0a                	jmp    f011bc60 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011bc56:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bc59:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011bc60:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011bc67:	76 ed                	jbe    f011bc56 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011bc69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bc6c:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011bc72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bc79:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bc7f:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011bc82:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011bc89:	e9 cb 00 00 00       	jmp    f011bd59 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011bc8e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011bc91:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011bc96:	83 ec 04             	sub    $0x4,%esp
f011bc99:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011bc9f:	51                   	push   %ecx
f011bca0:	52                   	push   %edx
f011bca1:	50                   	push   %eax
f011bca2:	e8 73 ca fe ff       	call   f010871a <get_page_table>
f011bca7:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bcaa:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011bcb0:	85 c0                	test   %eax,%eax
f011bcb2:	75 24                	jne    f011bcd8 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011bcb4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bcb8:	74 1e                	je     f011bcd8 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bcba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcc1:	83 ec 04             	sub    $0x4,%esp
f011bcc4:	68 5c fa 12 f0       	push   $0xf012fa5c
f011bcc9:	68 87 06 00 00       	push   $0x687
f011bcce:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011bcd3:	e8 61 46 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bcd8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011bcdf:	eb 59                	jmp    f011bd3a <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011bce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bce4:	c1 e0 0c             	shl    $0xc,%eax
f011bce7:	89 c2                	mov    %eax,%edx
f011bce9:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bcef:	01 d0                	add    %edx,%eax
f011bcf1:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011bcf7:	83 ec 0c             	sub    $0xc,%esp
f011bcfa:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bd00:	e8 fb dd fe ff       	call   f0109b00 <kheap_physical_address>
f011bd05:	83 c4 10             	add    $0x10,%esp
f011bd08:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011bd0e:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011bd15:	74 1d                	je     f011bd34 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bd17:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd1b:	74 17                	je     f011bd34 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011bd1d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd24:	83 ec 0c             	sub    $0xc,%esp
f011bd27:	68 bc fa 12 f0       	push   $0xf012fabc
f011bd2c:	e8 5a 52 fe ff       	call   f0100f8b <cprintf>
f011bd31:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bd34:	ff 45 c8             	incl   -0x38(%ebp)
f011bd37:	ff 45 f4             	incl   -0xc(%ebp)
f011bd3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bd3d:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bd43:	7d 09                	jge    f011bd4e <test_kheap_phys_addr+0xd92>
f011bd45:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011bd4c:	7e 93                	jle    f011bce1 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bd4e:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011bd55:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011bd59:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bd5d:	0f 88 2b ff ff ff    	js     f011bc8e <test_kheap_phys_addr+0xcd2>
f011bd63:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bd67:	7f 0d                	jg     f011bd76 <test_kheap_phys_addr+0xdba>
f011bd69:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011bd70:	0f 86 18 ff ff ff    	jbe    f011bc8e <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011bd76:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd7a:	74 04                	je     f011bd80 <test_kheap_phys_addr+0xdc4>
f011bd7c:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011bd80:	83 ec 08             	sub    $0x8,%esp
f011bd83:	ff 75 f0             	pushl  -0x10(%ebp)
f011bd86:	68 e0 fa 12 f0       	push   $0xf012fae0
f011bd8b:	e8 fb 51 fe ff       	call   f0100f8b <cprintf>
f011bd90:	83 c4 10             	add    $0x10,%esp

	return 1;
f011bd93:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bd98:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bd9b:	5b                   	pop    %ebx
f011bd9c:	5f                   	pop    %edi
f011bd9d:	5d                   	pop    %ebp
f011bd9e:	c3                   	ret    

f011bd9f <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011bd9f:	55                   	push   %ebp
f011bda0:	89 e5                	mov    %esp,%ebp
f011bda2:	57                   	push   %edi
f011bda3:	56                   	push   %esi
f011bda4:	53                   	push   %ebx
f011bda5:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bdab:	89 e0                	mov    %esp,%eax
f011bdad:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bdaf:	83 ec 0c             	sub    $0xc,%esp
f011bdb2:	68 68 b4 12 f0       	push   $0xf012b468
f011bdb7:	e8 cf 51 fe ff       	call   f0100f8b <cprintf>
f011bdbc:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bdbf:	83 ec 0c             	sub    $0xc,%esp
f011bdc2:	68 98 b4 12 f0       	push   $0xf012b498
f011bdc7:	e8 bf 51 fe ff       	call   f0100f8b <cprintf>
f011bdcc:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011bdcf:	83 ec 0c             	sub    $0xc,%esp
f011bdd2:	68 68 b4 12 f0       	push   $0xf012b468
f011bdd7:	e8 af 51 fe ff       	call   f0100f8b <cprintf>
f011bddc:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bddf:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011bde3:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bde7:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bded:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bdf3:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bdfa:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011be01:	e8 8c 2d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011be06:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011be09:	83 ec 0c             	sub    $0xc,%esp
f011be0c:	68 bc f1 12 f0       	push   $0xf012f1bc
f011be11:	e8 75 51 fe ff       	call   f0100f8b <cprintf>
f011be16:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011be19:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011be1f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011be24:	b8 00 00 00 00       	mov    $0x0,%eax
f011be29:	89 d7                	mov    %edx,%edi
f011be2b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011be2d:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011be33:	b9 14 00 00 00       	mov    $0x14,%ecx
f011be38:	b8 00 00 00 00       	mov    $0x0,%eax
f011be3d:	89 d7                	mov    %edx,%edi
f011be3f:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011be41:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011be48:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011be4f:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011be55:	b9 14 00 00 00       	mov    $0x14,%ecx
f011be5a:	b8 00 00 00 00       	mov    $0x0,%eax
f011be5f:	89 d7                	mov    %edx,%edi
f011be61:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011be63:	e8 2a 2d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011be68:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011be6b:	e8 23 8c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011be70:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011be73:	83 ec 0c             	sub    $0xc,%esp
f011be76:	68 00 fc 1f 00       	push   $0x1ffc00
f011be7b:	e8 3a d9 fe ff       	call   f01097ba <kmalloc>
f011be80:	83 c4 10             	add    $0x10,%esp
f011be83:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011be89:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011be8f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011be94:	74 17                	je     f011bead <test_kheap_virt_addr+0x10e>
f011be96:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be9d:	83 ec 0c             	sub    $0xc,%esp
f011bea0:	68 60 d5 12 f0       	push   $0xf012d560
f011bea5:	e8 e1 50 fe ff       	call   f0100f8b <cprintf>
f011beaa:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bead:	e8 e1 8b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011beb2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011beb5:	74 17                	je     f011bece <test_kheap_virt_addr+0x12f>
f011beb7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bebe:	83 ec 0c             	sub    $0xc,%esp
f011bec1:	68 b4 d5 12 f0       	push   $0xf012d5b4
f011bec6:	e8 c0 50 fe ff       	call   f0100f8b <cprintf>
f011becb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bece:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bed1:	e8 bc 2c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011bed6:	29 c3                	sub    %eax,%ebx
f011bed8:	89 d8                	mov    %ebx,%eax
f011beda:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bedf:	77 17                	ja     f011bef8 <test_kheap_virt_addr+0x159>
f011bee1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bee8:	83 ec 0c             	sub    $0xc,%esp
f011beeb:	68 24 d6 12 f0       	push   $0xf012d624
f011bef0:	e8 96 50 fe ff       	call   f0100f8b <cprintf>
f011bef5:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bef8:	e8 95 2c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011befd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf00:	e8 8e 8b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bf05:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bf08:	83 ec 0c             	sub    $0xc,%esp
f011bf0b:	68 00 fc 1f 00       	push   $0x1ffc00
f011bf10:	e8 a5 d8 fe ff       	call   f01097ba <kmalloc>
f011bf15:	83 c4 10             	add    $0x10,%esp
f011bf18:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf1e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bf24:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bf29:	74 17                	je     f011bf42 <test_kheap_virt_addr+0x1a3>
f011bf2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf32:	83 ec 0c             	sub    $0xc,%esp
f011bf35:	68 6c d6 12 f0       	push   $0xf012d66c
f011bf3a:	e8 4c 50 fe ff       	call   f0100f8b <cprintf>
f011bf3f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf42:	e8 4c 8b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bf47:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf4a:	74 17                	je     f011bf63 <test_kheap_virt_addr+0x1c4>
f011bf4c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf53:	83 ec 0c             	sub    $0xc,%esp
f011bf56:	68 c0 d6 12 f0       	push   $0xf012d6c0
f011bf5b:	e8 2b 50 fe ff       	call   f0100f8b <cprintf>
f011bf60:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bf63:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bf66:	e8 27 2c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011bf6b:	29 c3                	sub    %eax,%ebx
f011bf6d:	89 d8                	mov    %ebx,%eax
f011bf6f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bf74:	77 17                	ja     f011bf8d <test_kheap_virt_addr+0x1ee>
f011bf76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf7d:	83 ec 0c             	sub    $0xc,%esp
f011bf80:	68 30 d7 12 f0       	push   $0xf012d730
f011bf85:	e8 01 50 fe ff       	call   f0100f8b <cprintf>
f011bf8a:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011bf8d:	e8 00 2c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011bf92:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bf95:	e8 f9 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bf9a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011bf9d:	83 ec 0c             	sub    $0xc,%esp
f011bfa0:	68 00 04 00 00       	push   $0x400
f011bfa5:	e8 10 d8 fe ff       	call   f01097ba <kmalloc>
f011bfaa:	83 c4 10             	add    $0x10,%esp
f011bfad:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bfb3:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bfb9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bfbe:	76 28                	jbe    f011bfe8 <test_kheap_virt_addr+0x249>
f011bfc0:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011bfc6:	83 ec 0c             	sub    $0xc,%esp
f011bfc9:	6a 00                	push   $0x0
f011bfcb:	e8 b7 d6 fe ff       	call   f0109687 <sbrk>
f011bfd0:	83 c4 10             	add    $0x10,%esp
f011bfd3:	39 c3                	cmp    %eax,%ebx
f011bfd5:	73 11                	jae    f011bfe8 <test_kheap_virt_addr+0x249>
f011bfd7:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bfdd:	89 c2                	mov    %eax,%edx
f011bfdf:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011bfe4:	39 c2                	cmp    %eax,%edx
f011bfe6:	72 17                	jb     f011bfff <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bfe8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfef:	83 ec 0c             	sub    $0xc,%esp
f011bff2:	68 ec f1 12 f0       	push   $0xf012f1ec
f011bff7:	e8 8f 4f fe ff       	call   f0100f8b <cprintf>
f011bffc:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bfff:	e8 8f 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c004:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c007:	74 17                	je     f011c020 <test_kheap_virt_addr+0x281>
f011c009:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c010:	83 ec 0c             	sub    $0xc,%esp
f011c013:	68 cc d7 12 f0       	push   $0xf012d7cc
f011c018:	e8 6e 4f fe ff       	call   f0100f8b <cprintf>
f011c01d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c020:	e8 6d 2b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c025:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c028:	e8 66 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c02d:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c030:	83 ec 0c             	sub    $0xc,%esp
f011c033:	68 00 08 00 00       	push   $0x800
f011c038:	e8 7d d7 fe ff       	call   f01097ba <kmalloc>
f011c03d:	83 c4 10             	add    $0x10,%esp
f011c040:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c046:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c04c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c051:	76 28                	jbe    f011c07b <test_kheap_virt_addr+0x2dc>
f011c053:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c059:	83 ec 0c             	sub    $0xc,%esp
f011c05c:	6a 00                	push   $0x0
f011c05e:	e8 24 d6 fe ff       	call   f0109687 <sbrk>
f011c063:	83 c4 10             	add    $0x10,%esp
f011c066:	39 c3                	cmp    %eax,%ebx
f011c068:	73 11                	jae    f011c07b <test_kheap_virt_addr+0x2dc>
f011c06a:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c070:	89 c2                	mov    %eax,%edx
f011c072:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c077:	39 c2                	cmp    %eax,%edx
f011c079:	72 17                	jb     f011c092 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c07b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c082:	83 ec 0c             	sub    $0xc,%esp
f011c085:	68 78 f2 12 f0       	push   $0xf012f278
f011c08a:	e8 fc 4e fe ff       	call   f0100f8b <cprintf>
f011c08f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c092:	e8 fc 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c097:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c09a:	74 17                	je     f011c0b3 <test_kheap_virt_addr+0x314>
f011c09c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a3:	83 ec 0c             	sub    $0xc,%esp
f011c0a6:	68 d8 d8 12 f0       	push   $0xf012d8d8
f011c0ab:	e8 db 4e fe ff       	call   f0100f8b <cprintf>
f011c0b0:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c0b3:	e8 da 2a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c0b8:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c0bb:	e8 d3 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c0c0:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c0c3:	83 ec 0c             	sub    $0xc,%esp
f011c0c6:	68 00 06 00 00       	push   $0x600
f011c0cb:	e8 ea d6 fe ff       	call   f01097ba <kmalloc>
f011c0d0:	83 c4 10             	add    $0x10,%esp
f011c0d3:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c0d9:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c0df:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c0e4:	76 28                	jbe    f011c10e <test_kheap_virt_addr+0x36f>
f011c0e6:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c0ec:	83 ec 0c             	sub    $0xc,%esp
f011c0ef:	6a 00                	push   $0x0
f011c0f1:	e8 91 d5 fe ff       	call   f0109687 <sbrk>
f011c0f6:	83 c4 10             	add    $0x10,%esp
f011c0f9:	39 c3                	cmp    %eax,%ebx
f011c0fb:	73 11                	jae    f011c10e <test_kheap_virt_addr+0x36f>
f011c0fd:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c103:	89 c2                	mov    %eax,%edx
f011c105:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c10a:	39 c2                	cmp    %eax,%edx
f011c10c:	72 17                	jb     f011c125 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c10e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c115:	83 ec 0c             	sub    $0xc,%esp
f011c118:	68 04 f3 12 f0       	push   $0xf012f304
f011c11d:	e8 69 4e fe ff       	call   f0100f8b <cprintf>
f011c122:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c125:	e8 69 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c12a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c12d:	74 17                	je     f011c146 <test_kheap_virt_addr+0x3a7>
f011c12f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c136:	83 ec 0c             	sub    $0xc,%esp
f011c139:	68 e4 d9 12 f0       	push   $0xf012d9e4
f011c13e:	e8 48 4e fe ff       	call   f0100f8b <cprintf>
f011c143:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011c146:	e8 47 2a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c14b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c14e:	e8 40 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c153:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011c156:	83 ec 0c             	sub    $0xc,%esp
f011c159:	68 00 1c 00 00       	push   $0x1c00
f011c15e:	e8 57 d6 fe ff       	call   f01097ba <kmalloc>
f011c163:	83 c4 10             	add    $0x10,%esp
f011c166:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c16c:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011c172:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c177:	74 17                	je     f011c190 <test_kheap_virt_addr+0x3f1>
f011c179:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c180:	83 ec 0c             	sub    $0xc,%esp
f011c183:	68 9c da 12 f0       	push   $0xf012da9c
f011c188:	e8 fe 4d fe ff       	call   f0100f8b <cprintf>
f011c18d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c190:	e8 fe 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c195:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c198:	74 17                	je     f011c1b1 <test_kheap_virt_addr+0x412>
f011c19a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1a1:	83 ec 0c             	sub    $0xc,%esp
f011c1a4:	68 f0 da 12 f0       	push   $0xf012daf0
f011c1a9:	e8 dd 4d fe ff       	call   f0100f8b <cprintf>
f011c1ae:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c1b1:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c1b4:	e8 d9 29 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c1b9:	29 c3                	sub    %eax,%ebx
f011c1bb:	89 d8                	mov    %ebx,%eax
f011c1bd:	83 f8 01             	cmp    $0x1,%eax
f011c1c0:	77 17                	ja     f011c1d9 <test_kheap_virt_addr+0x43a>
f011c1c2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1c9:	83 ec 0c             	sub    $0xc,%esp
f011c1cc:	68 60 db 12 f0       	push   $0xf012db60
f011c1d1:	e8 b5 4d fe ff       	call   f0100f8b <cprintf>
f011c1d6:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011c1d9:	e8 b4 29 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c1de:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c1e1:	e8 ad 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c1e6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011c1e9:	83 ec 0c             	sub    $0xc,%esp
f011c1ec:	68 00 fc 2f 00       	push   $0x2ffc00
f011c1f1:	e8 c4 d5 fe ff       	call   f01097ba <kmalloc>
f011c1f6:	83 c4 10             	add    $0x10,%esp
f011c1f9:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c1ff:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011c205:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c20a:	74 17                	je     f011c223 <test_kheap_virt_addr+0x484>
f011c20c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c213:	83 ec 0c             	sub    $0xc,%esp
f011c216:	68 90 f3 12 f0       	push   $0xf012f390
f011c21b:	e8 6b 4d fe ff       	call   f0100f8b <cprintf>
f011c220:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c223:	e8 6b 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c228:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c22b:	74 17                	je     f011c244 <test_kheap_virt_addr+0x4a5>
f011c22d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c234:	83 ec 0c             	sub    $0xc,%esp
f011c237:	68 34 dc 12 f0       	push   $0xf012dc34
f011c23c:	e8 4a 4d fe ff       	call   f0100f8b <cprintf>
f011c241:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c244:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c247:	e8 46 29 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c24c:	29 c3                	sub    %eax,%ebx
f011c24e:	89 d8                	mov    %ebx,%eax
f011c250:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c255:	77 17                	ja     f011c26e <test_kheap_virt_addr+0x4cf>
f011c257:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c25e:	83 ec 0c             	sub    $0xc,%esp
f011c261:	68 e4 f3 12 f0       	push   $0xf012f3e4
f011c266:	e8 20 4d fe ff       	call   f0100f8b <cprintf>
f011c26b:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c26e:	e8 1f 29 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c273:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c276:	e8 18 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c27b:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011c27e:	83 ec 0c             	sub    $0xc,%esp
f011c281:	68 00 fc 5f 00       	push   $0x5ffc00
f011c286:	e8 2f d5 fe ff       	call   f01097ba <kmalloc>
f011c28b:	83 c4 10             	add    $0x10,%esp
f011c28e:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c294:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c29a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c29f:	74 17                	je     f011c2b8 <test_kheap_virt_addr+0x519>
f011c2a1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2a8:	83 ec 0c             	sub    $0xc,%esp
f011c2ab:	68 2c f4 12 f0       	push   $0xf012f42c
f011c2b0:	e8 d6 4c fe ff       	call   f0100f8b <cprintf>
f011c2b5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c2b8:	e8 d6 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c2bd:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c2c0:	74 17                	je     f011c2d9 <test_kheap_virt_addr+0x53a>
f011c2c2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2c9:	83 ec 0c             	sub    $0xc,%esp
f011c2cc:	68 30 dd 12 f0       	push   $0xf012dd30
f011c2d1:	e8 b5 4c fe ff       	call   f0100f8b <cprintf>
f011c2d6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c2d9:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c2dc:	e8 b1 28 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c2e1:	29 c3                	sub    %eax,%ebx
f011c2e3:	89 d8                	mov    %ebx,%eax
f011c2e5:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c2ea:	77 17                	ja     f011c303 <test_kheap_virt_addr+0x564>
f011c2ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2f3:	83 ec 0c             	sub    $0xc,%esp
f011c2f6:	68 80 f4 12 f0       	push   $0xf012f480
f011c2fb:	e8 8b 4c fe ff       	call   f0100f8b <cprintf>
f011c300:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c303:	e8 8a 28 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c308:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c30b:	e8 83 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c310:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c313:	83 ec 0c             	sub    $0xc,%esp
f011c316:	68 00 38 00 00       	push   $0x3800
f011c31b:	e8 9a d4 fe ff       	call   f01097ba <kmalloc>
f011c320:	83 c4 10             	add    $0x10,%esp
f011c323:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c329:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c32f:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c334:	74 17                	je     f011c34d <test_kheap_virt_addr+0x5ae>
f011c336:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c33d:	83 ec 0c             	sub    $0xc,%esp
f011c340:	68 c8 f4 12 f0       	push   $0xf012f4c8
f011c345:	e8 41 4c fe ff       	call   f0100f8b <cprintf>
f011c34a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c34d:	e8 41 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c352:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c355:	74 17                	je     f011c36e <test_kheap_virt_addr+0x5cf>
f011c357:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c35e:	83 ec 0c             	sub    $0xc,%esp
f011c361:	68 1c f5 12 f0       	push   $0xf012f51c
f011c366:	e8 20 4c fe ff       	call   f0100f8b <cprintf>
f011c36b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c36e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c371:	e8 1c 28 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c376:	29 c3                	sub    %eax,%ebx
f011c378:	89 d8                	mov    %ebx,%eax
f011c37a:	83 f8 03             	cmp    $0x3,%eax
f011c37d:	77 17                	ja     f011c396 <test_kheap_virt_addr+0x5f7>
f011c37f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c386:	83 ec 0c             	sub    $0xc,%esp
f011c389:	68 8c f5 12 f0       	push   $0xf012f58c
f011c38e:	e8 f8 4b fe ff       	call   f0100f8b <cprintf>
f011c393:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c396:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c39d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c3a0:	c1 e8 0c             	shr    $0xc,%eax
f011c3a3:	89 c2                	mov    %eax,%edx
f011c3a5:	4a                   	dec    %edx
f011c3a6:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c3a9:	c1 e0 02             	shl    $0x2,%eax
f011c3ac:	8d 50 03             	lea    0x3(%eax),%edx
f011c3af:	b8 10 00 00 00       	mov    $0x10,%eax
f011c3b4:	48                   	dec    %eax
f011c3b5:	01 d0                	add    %edx,%eax
f011c3b7:	bf 10 00 00 00       	mov    $0x10,%edi
f011c3bc:	ba 00 00 00 00       	mov    $0x0,%edx
f011c3c1:	f7 f7                	div    %edi
f011c3c3:	6b c0 10             	imul   $0x10,%eax,%eax
f011c3c6:	29 c4                	sub    %eax,%esp
f011c3c8:	89 e0                	mov    %esp,%eax
f011c3ca:	83 c0 03             	add    $0x3,%eax
f011c3cd:	c1 e8 02             	shr    $0x2,%eax
f011c3d0:	c1 e0 02             	shl    $0x2,%eax
f011c3d3:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c3d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c3d9:	c1 e8 0c             	shr    $0xc,%eax
f011c3dc:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c3df:	83 ec 0c             	sub    $0xc,%esp
f011c3e2:	68 14 fb 12 f0       	push   $0xf012fb14
f011c3e7:	e8 9f 4b fe ff       	call   f0100f8b <cprintf>
f011c3ec:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c3ef:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c3f6:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c3fb:	05 00 10 00 00       	add    $0x1000,%eax
f011c400:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c403:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c40a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c40d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c410:	e9 2d 01 00 00       	jmp    f011c542 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c415:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011c41a:	83 ec 04             	sub    $0x4,%esp
f011c41d:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c423:	52                   	push   %edx
f011c424:	ff 75 dc             	pushl  -0x24(%ebp)
f011c427:	50                   	push   %eax
f011c428:	e8 ed c2 fe ff       	call   f010871a <get_page_table>
f011c42d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c430:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c436:	85 c0                	test   %eax,%eax
f011c438:	75 1e                	jne    f011c458 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c43a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c441:	83 ec 04             	sub    $0x4,%esp
f011c444:	68 20 f6 12 f0       	push   $0xf012f620
f011c449:	68 26 07 00 00       	push   $0x726
f011c44e:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011c453:	e8 e1 3e fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c458:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c45b:	c1 e8 0c             	shr    $0xc,%eax
f011c45e:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c463:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c466:	e9 ba 00 00 00       	jmp    f011c525 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c46b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c46e:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c471:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c477:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c47a:	c1 e2 02             	shl    $0x2,%edx
f011c47d:	01 d0                	add    %edx,%eax
f011c47f:	8b 00                	mov    (%eax),%eax
f011c481:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c486:	89 c2                	mov    %eax,%edx
f011c488:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c48b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c48e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c491:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c494:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c497:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c49a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c49d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c4a0:	83 ec 0c             	sub    $0xc,%esp
f011c4a3:	50                   	push   %eax
f011c4a4:	e8 b4 d6 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c4a9:	83 c4 10             	add    $0x10,%esp
f011c4ac:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c4af:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c4b2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c4b5:	01 d0                	add    %edx,%eax
f011c4b7:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c4ba:	74 5c                	je     f011c518 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c4bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c4c0:	74 56                	je     f011c518 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c4c2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4c5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c4c8:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c4cb:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c4d1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c4d4:	c1 e1 02             	shl    $0x2,%ecx
f011c4d7:	01 ca                	add    %ecx,%edx
f011c4d9:	8b 12                	mov    (%edx),%edx
f011c4db:	89 d1                	mov    %edx,%ecx
f011c4dd:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c4e3:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c4e6:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c4e9:	01 da                	add    %ebx,%edx
f011c4eb:	83 ec 0c             	sub    $0xc,%esp
f011c4ee:	50                   	push   %eax
f011c4ef:	51                   	push   %ecx
f011c4f0:	52                   	push   %edx
f011c4f1:	ff 75 8c             	pushl  -0x74(%ebp)
f011c4f4:	68 60 fb 12 f0       	push   $0xf012fb60
f011c4f9:	e8 8d 4a fe ff       	call   f0100f8b <cprintf>
f011c4fe:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c501:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c508:	83 ec 0c             	sub    $0xc,%esp
f011c50b:	68 a4 fb 12 f0       	push   $0xf012fba4
f011c510:	e8 76 4a fe ff       	call   f0100f8b <cprintf>
f011c515:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c518:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c51f:	ff 45 d4             	incl   -0x2c(%ebp)
f011c522:	ff 45 d8             	incl   -0x28(%ebp)
f011c525:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c528:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c52b:	7d 15                	jge    f011c542 <test_kheap_virt_addr+0x7a3>
f011c52d:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c534:	7f 0c                	jg     f011c542 <test_kheap_virt_addr+0x7a3>
f011c536:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c539:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c53c:	0f 82 29 ff ff ff    	jb     f011c46b <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c542:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c545:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c548:	0f 82 c7 fe ff ff    	jb     f011c415 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c54e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c552:	74 04                	je     f011c558 <test_kheap_virt_addr+0x7b9>
f011c554:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c558:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c55f:	83 ec 0c             	sub    $0xc,%esp
f011c562:	68 c8 fb 12 f0       	push   $0xf012fbc8
f011c567:	e8 1f 4a fe ff       	call   f0100f8b <cprintf>
f011c56c:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c56f:	e8 1e 26 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c574:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c577:	e8 17 85 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c57c:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c57f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c585:	83 ec 0c             	sub    $0xc,%esp
f011c588:	50                   	push   %eax
f011c589:	e8 8c d4 fe ff       	call   f0109a1a <kfree>
f011c58e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c591:	e8 fd 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c596:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c599:	74 17                	je     f011c5b2 <test_kheap_virt_addr+0x813>
f011c59b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5a2:	83 ec 0c             	sub    $0xc,%esp
f011c5a5:	68 f0 fb 12 f0       	push   $0xf012fbf0
f011c5aa:	e8 dc 49 fe ff       	call   f0100f8b <cprintf>
f011c5af:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c5b2:	e8 db 25 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c5b7:	89 c2                	mov    %eax,%edx
f011c5b9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c5bc:	29 c2                	sub    %eax,%edx
f011c5be:	89 d0                	mov    %edx,%eax
f011c5c0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c5c5:	77 17                	ja     f011c5de <test_kheap_virt_addr+0x83f>
f011c5c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5ce:	83 ec 0c             	sub    $0xc,%esp
f011c5d1:	68 60 fc 12 f0       	push   $0xf012fc60
f011c5d6:	e8 b0 49 fe ff       	call   f0100f8b <cprintf>
f011c5db:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c5de:	e8 af 25 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c5e3:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c5e6:	e8 a8 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c5eb:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c5ee:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c5f4:	83 ec 0c             	sub    $0xc,%esp
f011c5f7:	50                   	push   %eax
f011c5f8:	e8 1d d4 fe ff       	call   f0109a1a <kfree>
f011c5fd:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c600:	e8 8e 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c605:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c608:	74 17                	je     f011c621 <test_kheap_virt_addr+0x882>
f011c60a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c611:	83 ec 0c             	sub    $0xc,%esp
f011c614:	68 9c fc 12 f0       	push   $0xf012fc9c
f011c619:	e8 6d 49 fe ff       	call   f0100f8b <cprintf>
f011c61e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c621:	e8 6c 25 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c626:	89 c2                	mov    %eax,%edx
f011c628:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c62b:	29 c2                	sub    %eax,%edx
f011c62d:	89 d0                	mov    %edx,%eax
f011c62f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c634:	77 17                	ja     f011c64d <test_kheap_virt_addr+0x8ae>
f011c636:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c63d:	83 ec 0c             	sub    $0xc,%esp
f011c640:	68 0c fd 12 f0       	push   $0xf012fd0c
f011c645:	e8 41 49 fe ff       	call   f0100f8b <cprintf>
f011c64a:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c64d:	e8 40 25 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c652:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c655:	e8 39 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c65a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c65d:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c663:	83 ec 0c             	sub    $0xc,%esp
f011c666:	50                   	push   %eax
f011c667:	e8 ae d3 fe ff       	call   f0109a1a <kfree>
f011c66c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c66f:	e8 1f 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c674:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c677:	74 17                	je     f011c690 <test_kheap_virt_addr+0x8f1>
f011c679:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c680:	83 ec 0c             	sub    $0xc,%esp
f011c683:	68 48 fd 12 f0       	push   $0xf012fd48
f011c688:	e8 fe 48 fe ff       	call   f0100f8b <cprintf>
f011c68d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c690:	e8 fd 24 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011c695:	89 c2                	mov    %eax,%edx
f011c697:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c69a:	29 c2                	sub    %eax,%edx
f011c69c:	89 d0                	mov    %edx,%eax
f011c69e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c6a3:	77 17                	ja     f011c6bc <test_kheap_virt_addr+0x91d>
f011c6a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6ac:	83 ec 0c             	sub    $0xc,%esp
f011c6af:	68 b8 fd 12 f0       	push   $0xf012fdb8
f011c6b4:	e8 d2 48 fe ff       	call   f0100f8b <cprintf>
f011c6b9:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c6bc:	83 ec 0c             	sub    $0xc,%esp
f011c6bf:	68 f4 fd 12 f0       	push   $0xf012fdf4
f011c6c4:	e8 c2 48 fe ff       	call   f0100f8b <cprintf>
f011c6c9:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c6cc:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c6d3:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c6d8:	05 00 10 00 00       	add    $0x1000,%eax
f011c6dd:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c6e3:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c6ea:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c6f1:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c6f4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c6fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c6fd:	eb 44                	jmp    f011c743 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c6ff:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c702:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c705:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c708:	83 ec 0c             	sub    $0xc,%esp
f011c70b:	50                   	push   %eax
f011c70c:	e8 4c d4 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c711:	83 c4 10             	add    $0x10,%esp
f011c714:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c71a:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c721:	74 1d                	je     f011c740 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c723:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c727:	74 17                	je     f011c740 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c729:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c730:	83 ec 0c             	sub    $0xc,%esp
f011c733:	68 44 fe 12 f0       	push   $0xf012fe44
f011c738:	e8 4e 48 fe ff       	call   f0100f8b <cprintf>
f011c73d:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c740:	ff 45 d0             	incl   -0x30(%ebp)
f011c743:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c749:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c74f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c752:	39 c2                	cmp    %eax,%edx
f011c754:	77 a9                	ja     f011c6ff <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c756:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c75c:	05 00 04 00 00       	add    $0x400,%eax
f011c761:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c764:	eb 64                	jmp    f011c7ca <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c766:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c769:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c76c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c76f:	83 ec 0c             	sub    $0xc,%esp
f011c772:	50                   	push   %eax
f011c773:	e8 e5 d3 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c778:	83 c4 10             	add    $0x10,%esp
f011c77b:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c781:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c784:	c1 e0 0c             	shl    $0xc,%eax
f011c787:	89 c2                	mov    %eax,%edx
f011c789:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c78f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c792:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c795:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c798:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c79b:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c7a0:	01 c8                	add    %ecx,%eax
f011c7a2:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c7a8:	74 1d                	je     f011c7c7 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c7aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7ae:	74 17                	je     f011c7c7 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c7b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7b7:	83 ec 0c             	sub    $0xc,%esp
f011c7ba:	68 68 fe 12 f0       	push   $0xf012fe68
f011c7bf:	e8 c7 47 fe ff       	call   f0100f8b <cprintf>
f011c7c4:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c7c7:	ff 45 d0             	incl   -0x30(%ebp)
f011c7ca:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c7d0:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c7d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c7d9:	39 c2                	cmp    %eax,%edx
f011c7db:	77 89                	ja     f011c766 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c7dd:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c7e3:	05 02 07 00 00       	add    $0x702,%eax
f011c7e8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c7eb:	eb 44                	jmp    f011c831 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c7ed:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c7f0:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c7f3:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c7f6:	83 ec 0c             	sub    $0xc,%esp
f011c7f9:	50                   	push   %eax
f011c7fa:	e8 5e d3 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c7ff:	83 c4 10             	add    $0x10,%esp
f011c802:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c808:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c80f:	74 1d                	je     f011c82e <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c811:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c815:	74 17                	je     f011c82e <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c817:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c81e:	83 ec 0c             	sub    $0xc,%esp
f011c821:	68 8c fe 12 f0       	push   $0xf012fe8c
f011c826:	e8 60 47 fe ff       	call   f0100f8b <cprintf>
f011c82b:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c82e:	ff 45 d0             	incl   -0x30(%ebp)
f011c831:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c837:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c83d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c840:	39 c2                	cmp    %eax,%edx
f011c842:	77 a9                	ja     f011c7ed <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c844:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c84a:	05 02 0d 00 00       	add    $0xd02,%eax
f011c84f:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c852:	eb 64                	jmp    f011c8b8 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c854:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c857:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c85a:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c85d:	83 ec 0c             	sub    $0xc,%esp
f011c860:	50                   	push   %eax
f011c861:	e8 f7 d2 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c866:	83 c4 10             	add    $0x10,%esp
f011c869:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c86f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c872:	c1 e0 0c             	shl    $0xc,%eax
f011c875:	89 c2                	mov    %eax,%edx
f011c877:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c87d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c880:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c883:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c886:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c889:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c88e:	01 c8                	add    %ecx,%eax
f011c890:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c896:	74 1d                	je     f011c8b5 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c898:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c89c:	74 17                	je     f011c8b5 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c89e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8a5:	83 ec 0c             	sub    $0xc,%esp
f011c8a8:	68 b0 fe 12 f0       	push   $0xf012feb0
f011c8ad:	e8 d9 46 fe ff       	call   f0100f8b <cprintf>
f011c8b2:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c8b5:	ff 45 d0             	incl   -0x30(%ebp)
f011c8b8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c8be:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c8c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8c7:	39 c2                	cmp    %eax,%edx
f011c8c9:	77 89                	ja     f011c854 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c8cb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c8cf:	74 04                	je     f011c8d5 <test_kheap_virt_addr+0xb36>
f011c8d1:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c8d5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c8dc:	83 ec 0c             	sub    $0xc,%esp
f011c8df:	68 d4 fe 12 f0       	push   $0xf012fed4
f011c8e4:	e8 a2 46 fe ff       	call   f0100f8b <cprintf>
f011c8e9:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c8ec:	83 ec 0c             	sub    $0xc,%esp
f011c8ef:	6a 00                	push   $0x0
f011c8f1:	e8 91 cd fe ff       	call   f0109687 <sbrk>
f011c8f6:	83 c4 10             	add    $0x10,%esp
f011c8f9:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c8fe:	77 17                	ja     f011c917 <test_kheap_virt_addr+0xb78>
f011c900:	83 ec 04             	sub    $0x4,%esp
f011c903:	68 1b ff 12 f0       	push   $0xf012ff1b
f011c908:	68 91 07 00 00       	push   $0x791
f011c90d:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011c912:	e8 22 3a fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c917:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c91e:	e9 d1 00 00 00       	jmp    f011c9f4 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c923:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011c928:	83 ec 04             	sub    $0x4,%esp
f011c92b:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c931:	52                   	push   %edx
f011c932:	ff 75 cc             	pushl  -0x34(%ebp)
f011c935:	50                   	push   %eax
f011c936:	e8 df bd fe ff       	call   f010871a <get_page_table>
f011c93b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c93e:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c944:	85 c0                	test   %eax,%eax
f011c946:	75 1e                	jne    f011c966 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c948:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c94f:	83 ec 04             	sub    $0x4,%esp
f011c952:	68 a4 f8 12 f0       	push   $0xf012f8a4
f011c957:	68 97 07 00 00       	push   $0x797
f011c95c:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011c961:	e8 d3 39 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c966:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c96c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c96f:	c1 ea 0c             	shr    $0xc,%edx
f011c972:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c978:	c1 e2 02             	shl    $0x2,%edx
f011c97b:	01 d0                	add    %edx,%eax
f011c97d:	8b 00                	mov    (%eax),%eax
f011c97f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c984:	89 c2                	mov    %eax,%edx
f011c986:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c989:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c98e:	01 d0                	add    %edx,%eax
f011c990:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c996:	83 ec 0c             	sub    $0xc,%esp
f011c999:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c99f:	e8 b9 d1 fe ff       	call   f0109b5d <kheap_virtual_address>
f011c9a4:	83 c4 10             	add    $0x10,%esp
f011c9a7:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c9ad:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c9b3:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c9b6:	74 39                	je     f011c9f1 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c9b8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c9bc:	74 33                	je     f011c9f1 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c9be:	ff 75 cc             	pushl  -0x34(%ebp)
f011c9c1:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c9c7:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c9cd:	68 34 ff 12 f0       	push   $0xf012ff34
f011c9d2:	e8 b4 45 fe ff       	call   f0100f8b <cprintf>
f011c9d7:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c9da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9e1:	83 ec 0c             	sub    $0xc,%esp
f011c9e4:	68 60 ff 12 f0       	push   $0xf012ff60
f011c9e9:	e8 9d 45 fe ff       	call   f0100f8b <cprintf>
f011c9ee:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c9f1:	ff 45 cc             	incl   -0x34(%ebp)
f011c9f4:	83 ec 0c             	sub    $0xc,%esp
f011c9f7:	6a 00                	push   $0x0
f011c9f9:	e8 89 cc fe ff       	call   f0109687 <sbrk>
f011c9fe:	83 c4 10             	add    $0x10,%esp
f011ca01:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011ca04:	0f 87 19 ff ff ff    	ja     f011c923 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011ca0a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca0e:	74 04                	je     f011ca14 <test_kheap_virt_addr+0xc75>
f011ca10:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011ca14:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011ca1b:	83 ec 0c             	sub    $0xc,%esp
f011ca1e:	68 84 ff 12 f0       	push   $0xf012ff84
f011ca23:	e8 63 45 fe ff       	call   f0100f8b <cprintf>
f011ca28:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011ca2b:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011ca32:	eb 5a                	jmp    f011ca8e <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011ca34:	83 ec 0c             	sub    $0xc,%esp
f011ca37:	ff 75 c8             	pushl  -0x38(%ebp)
f011ca3a:	e8 1e d1 fe ff       	call   f0109b5d <kheap_virtual_address>
f011ca3f:	83 c4 10             	add    $0x10,%esp
f011ca42:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011ca48:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011ca4f:	74 36                	je     f011ca87 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011ca51:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca55:	74 30                	je     f011ca87 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011ca57:	83 ec 04             	sub    $0x4,%esp
f011ca5a:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011ca60:	ff 75 c8             	pushl  -0x38(%ebp)
f011ca63:	68 c3 ff 12 f0       	push   $0xf012ffc3
f011ca68:	e8 1e 45 fe ff       	call   f0100f8b <cprintf>
f011ca6d:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011ca70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca77:	83 ec 0c             	sub    $0xc,%esp
f011ca7a:	68 e0 ff 12 f0       	push   $0xf012ffe0
f011ca7f:	e8 07 45 fe ff       	call   f0100f8b <cprintf>
f011ca84:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011ca87:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011ca8e:	b8 70 22 6b 02       	mov    $0x26b2270,%eax
f011ca93:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011ca96:	72 9c                	jb     f011ca34 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011ca98:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca9c:	74 04                	je     f011caa2 <test_kheap_virt_addr+0xd03>
f011ca9e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011caa2:	83 ec 08             	sub    $0x8,%esp
f011caa5:	ff 75 e4             	pushl  -0x1c(%ebp)
f011caa8:	68 04 00 13 f0       	push   $0xf0130004
f011caad:	e8 d9 44 fe ff       	call   f0100f8b <cprintf>
f011cab2:	83 c4 10             	add    $0x10,%esp

	return 1;
f011cab5:	b8 01 00 00 00       	mov    $0x1,%eax
f011caba:	89 f4                	mov    %esi,%esp

}
f011cabc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cabf:	5b                   	pop    %ebx
f011cac0:	5e                   	pop    %esi
f011cac1:	5f                   	pop    %edi
f011cac2:	5d                   	pop    %ebp
f011cac3:	c3                   	ret    

f011cac4 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011cac4:	55                   	push   %ebp
f011cac5:	89 e5                	mov    %esp,%ebp
f011cac7:	57                   	push   %edi
f011cac8:	56                   	push   %esi
f011cac9:	53                   	push   %ebx
f011caca:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011cad0:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011cad6:	b9 14 00 00 00       	mov    $0x14,%ecx
f011cadb:	b8 00 00 00 00       	mov    $0x0,%eax
f011cae0:	89 d7                	mov    %edx,%edi
f011cae2:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011cae4:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011caeb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011caf2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011caf9:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011cafe:	0f b6 c0             	movzbl %al,%eax
f011cb01:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011cb04:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011cb0b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cb0e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011cb11:	39 c2                	cmp    %eax,%edx
f011cb13:	73 02                	jae    f011cb17 <test_ksbrk+0x53>
f011cb15:	89 c2                	mov    %eax,%edx
f011cb17:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011cb1c:	0f b6 c0             	movzbl %al,%eax
f011cb1f:	c1 e0 04             	shl    $0x4,%eax
f011cb22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011cb25:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011cb2c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011cb2f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011cb32:	39 c8                	cmp    %ecx,%eax
f011cb34:	73 02                	jae    f011cb38 <test_ksbrk+0x74>
f011cb36:	89 c8                	mov    %ecx,%eax
f011cb38:	01 d0                	add    %edx,%eax
f011cb3a:	83 c0 10             	add    $0x10,%eax
f011cb3d:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011cb42:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011cb45:	83 ec 0c             	sub    $0xc,%esp
f011cb48:	68 38 00 13 f0       	push   $0xf0130038
f011cb4d:	e8 39 44 fe ff       	call   f0100f8b <cprintf>
f011cb52:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011cb55:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cb5c:	e8 31 20 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cb61:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cb64:	e8 2a 7f fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cb69:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011cb6c:	83 ec 10             	sub    $0x10,%esp
f011cb6f:	89 e0                	mov    %esp,%eax
f011cb71:	89 c2                	mov    %eax,%edx
f011cb73:	bb b0 f1 b1 f0       	mov    $0xf0b1f1b0,%ebx
f011cb78:	b8 04 00 00 00       	mov    $0x4,%eax
f011cb7d:	89 d7                	mov    %edx,%edi
f011cb7f:	89 de                	mov    %ebx,%esi
f011cb81:	89 c1                	mov    %eax,%ecx
f011cb83:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011cb85:	e8 53 3e 00 00       	call   f01209dd <print_blocks_list>
f011cb8a:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011cb8d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cb90:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cb93:	29 c2                	sub    %eax,%edx
f011cb95:	89 d0                	mov    %edx,%eax
f011cb97:	83 ec 0c             	sub    $0xc,%esp
f011cb9a:	50                   	push   %eax
f011cb9b:	e8 1a cc fe ff       	call   f01097ba <kmalloc>
f011cba0:	83 c4 10             	add    $0x10,%esp
f011cba3:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011cba9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cbac:	89 c2                	mov    %eax,%edx
f011cbae:	c1 ea 1f             	shr    $0x1f,%edx
f011cbb1:	01 d0                	add    %edx,%eax
f011cbb3:	d1 f8                	sar    %eax
f011cbb5:	89 c2                	mov    %eax,%edx
f011cbb7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011cbba:	01 d0                	add    %edx,%eax
f011cbbc:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cbbf:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cbc5:	6a 01                	push   $0x1
f011cbc7:	ff 75 b8             	pushl  -0x48(%ebp)
f011cbca:	ff 75 ac             	pushl  -0x54(%ebp)
f011cbcd:	50                   	push   %eax
f011cbce:	e8 db 43 ff ff       	call   f0110fae <check_block>
f011cbd3:	83 c4 10             	add    $0x10,%esp
f011cbd6:	85 c0                	test   %eax,%eax
f011cbd8:	75 17                	jne    f011cbf1 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011cbda:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbe1:	83 ec 0c             	sub    $0xc,%esp
f011cbe4:	68 89 00 13 f0       	push   $0xf0130089
f011cbe9:	e8 9d 43 fe ff       	call   f0100f8b <cprintf>
f011cbee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cbf1:	e8 9c 1f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cbf6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cbf9:	74 17                	je     f011cc12 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011cbfb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc02:	83 ec 0c             	sub    $0xc,%esp
f011cc05:	68 a0 00 13 f0       	push   $0xf01300a0
f011cc0a:	e8 7c 43 fe ff       	call   f0100f8b <cprintf>
f011cc0f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cc12:	e8 7c 7e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cc17:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cc1a:	74 17                	je     f011cc33 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc1c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc23:	83 ec 0c             	sub    $0xc,%esp
f011cc26:	68 c0 00 13 f0       	push   $0xf01300c0
f011cc2b:	e8 5b 43 fe ff       	call   f0100f8b <cprintf>
f011cc30:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011cc33:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011cc38:	0f b6 c0             	movzbl %al,%eax
f011cc3b:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011cc3e:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011cc45:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011cc48:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011cc4b:	39 c2                	cmp    %eax,%edx
f011cc4d:	73 02                	jae    f011cc51 <test_ksbrk+0x18d>
f011cc4f:	89 c2                	mov    %eax,%edx
f011cc51:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011cc56:	0f b6 c0             	movzbl %al,%eax
f011cc59:	c1 e0 04             	shl    $0x4,%eax
f011cc5c:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011cc5f:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011cc66:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011cc69:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cc6c:	39 c8                	cmp    %ecx,%eax
f011cc6e:	73 02                	jae    f011cc72 <test_ksbrk+0x1ae>
f011cc70:	89 c8                	mov    %ecx,%eax
f011cc72:	01 d0                	add    %edx,%eax
f011cc74:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011cc79:	29 c2                	sub    %eax,%edx
f011cc7b:	89 d0                	mov    %edx,%eax
f011cc7d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cc80:	e8 0d 1f ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cc85:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cc88:	e8 06 7e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cc8d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011cc90:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc93:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cc96:	29 c2                	sub    %eax,%edx
f011cc98:	89 d0                	mov    %edx,%eax
f011cc9a:	83 ec 0c             	sub    $0xc,%esp
f011cc9d:	50                   	push   %eax
f011cc9e:	e8 17 cb fe ff       	call   f01097ba <kmalloc>
f011cca3:	83 c4 10             	add    $0x10,%esp
f011cca6:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011ccac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ccaf:	89 c2                	mov    %eax,%edx
f011ccb1:	c1 ea 1f             	shr    $0x1f,%edx
f011ccb4:	01 d0                	add    %edx,%eax
f011ccb6:	d1 f8                	sar    %eax
f011ccb8:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011ccbe:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011ccc1:	01 d0                	add    %edx,%eax
f011ccc3:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011ccc6:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011cccc:	6a 01                	push   $0x1
f011ccce:	ff 75 b8             	pushl  -0x48(%ebp)
f011ccd1:	ff 75 ac             	pushl  -0x54(%ebp)
f011ccd4:	50                   	push   %eax
f011ccd5:	e8 d4 42 ff ff       	call   f0110fae <check_block>
f011ccda:	83 c4 10             	add    $0x10,%esp
f011ccdd:	85 c0                	test   %eax,%eax
f011ccdf:	75 17                	jne    f011ccf8 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011cce1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cce8:	83 ec 0c             	sub    $0xc,%esp
f011cceb:	68 2e 01 13 f0       	push   $0xf013012e
f011ccf0:	e8 96 42 fe ff       	call   f0100f8b <cprintf>
f011ccf5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ccf8:	e8 95 1e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ccfd:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cd00:	74 17                	je     f011cd19 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011cd02:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd09:	83 ec 0c             	sub    $0xc,%esp
f011cd0c:	68 48 01 13 f0       	push   $0xf0130148
f011cd11:	e8 75 42 fe ff       	call   f0100f8b <cprintf>
f011cd16:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd19:	e8 75 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cd1e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd21:	74 17                	je     f011cd3a <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd23:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd2a:	83 ec 0c             	sub    $0xc,%esp
f011cd2d:	68 68 01 13 f0       	push   $0xf0130168
f011cd32:	e8 54 42 fe ff       	call   f0100f8b <cprintf>
f011cd37:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011cd3a:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cd41:	e8 4c 1e ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cd46:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cd49:	e8 45 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cd4e:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cd51:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd54:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd57:	29 c2                	sub    %eax,%edx
f011cd59:	89 d0                	mov    %edx,%eax
f011cd5b:	83 ec 0c             	sub    $0xc,%esp
f011cd5e:	50                   	push   %eax
f011cd5f:	e8 56 ca fe ff       	call   f01097ba <kmalloc>
f011cd64:	83 c4 10             	add    $0x10,%esp
f011cd67:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cd6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd70:	89 c2                	mov    %eax,%edx
f011cd72:	c1 ea 1f             	shr    $0x1f,%edx
f011cd75:	01 d0                	add    %edx,%eax
f011cd77:	d1 f8                	sar    %eax
f011cd79:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011cd7e:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cd81:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cd87:	6a 01                	push   $0x1
f011cd89:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd8c:	ff 75 ac             	pushl  -0x54(%ebp)
f011cd8f:	50                   	push   %eax
f011cd90:	e8 19 42 ff ff       	call   f0110fae <check_block>
f011cd95:	83 c4 10             	add    $0x10,%esp
f011cd98:	85 c0                	test   %eax,%eax
f011cd9a:	75 17                	jne    f011cdb3 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cd9c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cda3:	83 ec 0c             	sub    $0xc,%esp
f011cda6:	68 d6 01 13 f0       	push   $0xf01301d6
f011cdab:	e8 db 41 fe ff       	call   f0100f8b <cprintf>
f011cdb0:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cdb3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cdb6:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cdb9:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cdbe:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cdc1:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cdc4:	6a 00                	push   $0x0
f011cdc6:	ff 75 98             	pushl  -0x68(%ebp)
f011cdc9:	ff 75 ac             	pushl  -0x54(%ebp)
f011cdcc:	ff 75 ac             	pushl  -0x54(%ebp)
f011cdcf:	e8 da 41 ff ff       	call   f0110fae <check_block>
f011cdd4:	83 c4 10             	add    $0x10,%esp
f011cdd7:	85 c0                	test   %eax,%eax
f011cdd9:	75 17                	jne    f011cdf2 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011cddb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cde2:	83 ec 0c             	sub    $0xc,%esp
f011cde5:	68 ed 01 13 f0       	push   $0xf01301ed
f011cdea:	e8 9c 41 fe ff       	call   f0100f8b <cprintf>
f011cdef:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cdf2:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cdf9:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cdfc:	8b 00                	mov    (%eax),%eax
f011cdfe:	83 f8 01             	cmp    $0x1,%eax
f011ce01:	74 17                	je     f011ce1a <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011ce03:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce0a:	83 ec 0c             	sub    $0xc,%esp
f011ce0d:	68 04 02 13 f0       	push   $0xf0130204
f011ce12:	e8 74 41 fe ff       	call   f0100f8b <cprintf>
f011ce17:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011ce1a:	83 ec 0c             	sub    $0xc,%esp
f011ce1d:	6a 00                	push   $0x0
f011ce1f:	e8 63 c8 fe ff       	call   f0109687 <sbrk>
f011ce24:	83 c4 10             	add    $0x10,%esp
f011ce27:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011ce2a:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011ce31:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ce34:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ce37:	74 1d                	je     f011ce56 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011ce39:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce40:	83 ec 04             	sub    $0x4,%esp
f011ce43:	ff 75 90             	pushl  -0x70(%ebp)
f011ce46:	ff 75 8c             	pushl  -0x74(%ebp)
f011ce49:	68 30 02 13 f0       	push   $0xf0130230
f011ce4e:	e8 38 41 fe ff       	call   f0100f8b <cprintf>
f011ce53:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011ce56:	e8 37 1d ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ce5b:	89 c2                	mov    %eax,%edx
f011ce5d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011ce60:	29 d0                	sub    %edx,%eax
f011ce62:	83 f8 01             	cmp    $0x1,%eax
f011ce65:	74 17                	je     f011ce7e <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011ce67:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce6e:	83 ec 0c             	sub    $0xc,%esp
f011ce71:	68 64 02 13 f0       	push   $0xf0130264
f011ce76:	e8 10 41 fe ff       	call   f0100f8b <cprintf>
f011ce7b:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ce7e:	e8 10 7c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ce83:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ce86:	74 17                	je     f011ce9f <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce8f:	83 ec 0c             	sub    $0xc,%esp
f011ce92:	68 84 02 13 f0       	push   $0xf0130284
f011ce97:	e8 ef 40 fe ff       	call   f0100f8b <cprintf>
f011ce9c:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011ce9f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cea6:	e8 e7 1c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011ceab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ceae:	e8 e0 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ceb3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011ceb6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ceb9:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cebc:	29 c2                	sub    %eax,%edx
f011cebe:	89 d0                	mov    %edx,%eax
f011cec0:	83 ec 0c             	sub    $0xc,%esp
f011cec3:	50                   	push   %eax
f011cec4:	e8 f1 c8 fe ff       	call   f01097ba <kmalloc>
f011cec9:	83 c4 10             	add    $0x10,%esp
f011cecc:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011ced2:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011ced9:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011cedf:	6a 01                	push   $0x1
f011cee1:	ff 75 b8             	pushl  -0x48(%ebp)
f011cee4:	ff 75 ac             	pushl  -0x54(%ebp)
f011cee7:	50                   	push   %eax
f011cee8:	e8 c1 40 ff ff       	call   f0110fae <check_block>
f011ceed:	83 c4 10             	add    $0x10,%esp
f011cef0:	85 c0                	test   %eax,%eax
f011cef2:	75 17                	jne    f011cf0b <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011cef4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cefb:	83 ec 0c             	sub    $0xc,%esp
f011cefe:	68 f3 02 13 f0       	push   $0xf01302f3
f011cf03:	e8 83 40 fe ff       	call   f0100f8b <cprintf>
f011cf08:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cf0b:	e8 82 1c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cf10:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cf13:	74 17                	je     f011cf2c <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cf15:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf1c:	83 ec 0c             	sub    $0xc,%esp
f011cf1f:	68 0c 03 13 f0       	push   $0xf013030c
f011cf24:	e8 62 40 fe ff       	call   f0100f8b <cprintf>
f011cf29:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cf2c:	e8 62 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cf31:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cf34:	74 17                	je     f011cf4d <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf36:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf3d:	83 ec 0c             	sub    $0xc,%esp
f011cf40:	68 2c 03 13 f0       	push   $0xf013032c
f011cf45:	e8 41 40 fe ff       	call   f0100f8b <cprintf>
f011cf4a:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011cf4d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cf51:	74 04                	je     f011cf57 <test_ksbrk+0x493>
		eval += 25;
f011cf53:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011cf57:	83 ec 0c             	sub    $0xc,%esp
f011cf5a:	68 9c 03 13 f0       	push   $0xf013039c
f011cf5f:	e8 27 40 fe ff       	call   f0100f8b <cprintf>
f011cf64:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011cf67:	83 ec 0c             	sub    $0xc,%esp
f011cf6a:	6a 00                	push   $0x0
f011cf6c:	e8 16 c7 fe ff       	call   f0109687 <sbrk>
f011cf71:	83 c4 10             	add    $0x10,%esp
f011cf74:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011cf77:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cf7e:	e8 0f 1c ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cf83:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cf86:	e8 08 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cf8b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011cf8e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf91:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cf94:	29 c2                	sub    %eax,%edx
f011cf96:	89 d0                	mov    %edx,%eax
f011cf98:	83 ec 0c             	sub    $0xc,%esp
f011cf9b:	50                   	push   %eax
f011cf9c:	e8 19 c8 fe ff       	call   f01097ba <kmalloc>
f011cfa1:	83 c4 10             	add    $0x10,%esp
f011cfa4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cfaa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cfad:	89 c2                	mov    %eax,%edx
f011cfaf:	c1 ea 1f             	shr    $0x1f,%edx
f011cfb2:	01 d0                	add    %edx,%eax
f011cfb4:	d1 f8                	sar    %eax
f011cfb6:	89 c2                	mov    %eax,%edx
f011cfb8:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cfbb:	01 d0                	add    %edx,%eax
f011cfbd:	83 e8 04             	sub    $0x4,%eax
f011cfc0:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cfc3:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cfc9:	6a 01                	push   $0x1
f011cfcb:	ff 75 b8             	pushl  -0x48(%ebp)
f011cfce:	ff 75 ac             	pushl  -0x54(%ebp)
f011cfd1:	50                   	push   %eax
f011cfd2:	e8 d7 3f ff ff       	call   f0110fae <check_block>
f011cfd7:	83 c4 10             	add    $0x10,%esp
f011cfda:	85 c0                	test   %eax,%eax
f011cfdc:	75 17                	jne    f011cff5 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011cfde:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfe5:	83 ec 0c             	sub    $0xc,%esp
f011cfe8:	68 ff 03 13 f0       	push   $0xf01303ff
f011cfed:	e8 99 3f fe ff       	call   f0100f8b <cprintf>
f011cff2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cff5:	e8 98 1b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011cffa:	89 c2                	mov    %eax,%edx
f011cffc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cfff:	29 d0                	sub    %edx,%eax
f011d001:	83 f8 01             	cmp    $0x1,%eax
f011d004:	74 17                	je     f011d01d <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011d006:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d00d:	83 ec 0c             	sub    $0xc,%esp
f011d010:	68 18 04 13 f0       	push   $0xf0130418
f011d015:	e8 71 3f fe ff       	call   f0100f8b <cprintf>
f011d01a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d01d:	e8 71 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d022:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d025:	74 17                	je     f011d03e <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d027:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d02e:	83 ec 0c             	sub    $0xc,%esp
f011d031:	68 38 04 13 f0       	push   $0xf0130438
f011d036:	e8 50 3f fe ff       	call   f0100f8b <cprintf>
f011d03b:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011d03e:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d045:	e8 48 1b ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d04a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d04d:	e8 41 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d052:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011d055:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d058:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d05b:	29 c2                	sub    %eax,%edx
f011d05d:	89 d0                	mov    %edx,%eax
f011d05f:	83 ec 0c             	sub    $0xc,%esp
f011d062:	50                   	push   %eax
f011d063:	e8 52 c7 fe ff       	call   f01097ba <kmalloc>
f011d068:	83 c4 10             	add    $0x10,%esp
f011d06b:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011d071:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011d078:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d07e:	6a 01                	push   $0x1
f011d080:	ff 75 b8             	pushl  -0x48(%ebp)
f011d083:	ff 75 ac             	pushl  -0x54(%ebp)
f011d086:	50                   	push   %eax
f011d087:	e8 22 3f ff ff       	call   f0110fae <check_block>
f011d08c:	83 c4 10             	add    $0x10,%esp
f011d08f:	85 c0                	test   %eax,%eax
f011d091:	75 17                	jne    f011d0aa <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011d093:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d09a:	83 ec 0c             	sub    $0xc,%esp
f011d09d:	68 a6 04 13 f0       	push   $0xf01304a6
f011d0a2:	e8 e4 3e fe ff       	call   f0100f8b <cprintf>
f011d0a7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d0aa:	e8 e3 1a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d0af:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d0b2:	74 17                	je     f011d0cb <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011d0b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0bb:	83 ec 0c             	sub    $0xc,%esp
f011d0be:	68 c0 04 13 f0       	push   $0xf01304c0
f011d0c3:	e8 c3 3e fe ff       	call   f0100f8b <cprintf>
f011d0c8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d0cb:	e8 c3 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d0d0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d0d3:	74 17                	je     f011d0ec <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d0d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0dc:	83 ec 0c             	sub    $0xc,%esp
f011d0df:	68 e0 04 13 f0       	push   $0xf01304e0
f011d0e4:	e8 a2 3e fe ff       	call   f0100f8b <cprintf>
f011d0e9:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011d0ec:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011d0f3:	e8 9a 1a ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d0f8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d0fb:	e8 93 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d100:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011d103:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d106:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d109:	29 c2                	sub    %eax,%edx
f011d10b:	89 d0                	mov    %edx,%eax
f011d10d:	83 ec 0c             	sub    $0xc,%esp
f011d110:	50                   	push   %eax
f011d111:	e8 a4 c6 fe ff       	call   f01097ba <kmalloc>
f011d116:	83 c4 10             	add    $0x10,%esp
f011d119:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011d11f:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011d126:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d12c:	6a 01                	push   $0x1
f011d12e:	ff 75 b8             	pushl  -0x48(%ebp)
f011d131:	ff 75 ac             	pushl  -0x54(%ebp)
f011d134:	50                   	push   %eax
f011d135:	e8 74 3e ff ff       	call   f0110fae <check_block>
f011d13a:	83 c4 10             	add    $0x10,%esp
f011d13d:	85 c0                	test   %eax,%eax
f011d13f:	75 17                	jne    f011d158 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011d141:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d148:	83 ec 0c             	sub    $0xc,%esp
f011d14b:	68 4e 05 13 f0       	push   $0xf013054e
f011d150:	e8 36 3e fe ff       	call   f0100f8b <cprintf>
f011d155:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011d158:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d15b:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011d15e:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011d165:	6a 00                	push   $0x0
f011d167:	ff 75 98             	pushl  -0x68(%ebp)
f011d16a:	ff 75 ac             	pushl  -0x54(%ebp)
f011d16d:	ff 75 ac             	pushl  -0x54(%ebp)
f011d170:	e8 39 3e ff ff       	call   f0110fae <check_block>
f011d175:	83 c4 10             	add    $0x10,%esp
f011d178:	85 c0                	test   %eax,%eax
f011d17a:	75 17                	jne    f011d193 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011d17c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d183:	83 ec 0c             	sub    $0xc,%esp
f011d186:	68 65 05 13 f0       	push   $0xf0130565
f011d18b:	e8 fb 3d fe ff       	call   f0100f8b <cprintf>
f011d190:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011d193:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d196:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011d19b:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011d19e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d1a1:	8b 00                	mov    (%eax),%eax
f011d1a3:	83 f8 01             	cmp    $0x1,%eax
f011d1a6:	74 17                	je     f011d1bf <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011d1a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d1af:	83 ec 0c             	sub    $0xc,%esp
f011d1b2:	68 7c 05 13 f0       	push   $0xf013057c
f011d1b7:	e8 cf 3d fe ff       	call   f0100f8b <cprintf>
f011d1bc:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011d1bf:	83 ec 0c             	sub    $0xc,%esp
f011d1c2:	6a 00                	push   $0x0
f011d1c4:	e8 be c4 fe ff       	call   f0109687 <sbrk>
f011d1c9:	83 c4 10             	add    $0x10,%esp
f011d1cc:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011d1cf:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d1d2:	05 00 20 00 00       	add    $0x2000,%eax
f011d1d7:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011d1da:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d1dd:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011d1e0:	74 1d                	je     f011d1ff <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011d1e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d1e9:	83 ec 04             	sub    $0x4,%esp
f011d1ec:	ff 75 90             	pushl  -0x70(%ebp)
f011d1ef:	ff 75 8c             	pushl  -0x74(%ebp)
f011d1f2:	68 a8 05 13 f0       	push   $0xf01305a8
f011d1f7:	e8 8f 3d fe ff       	call   f0100f8b <cprintf>
f011d1fc:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d1ff:	e8 8e 19 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d204:	89 c2                	mov    %eax,%edx
f011d206:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d209:	29 d0                	sub    %edx,%eax
f011d20b:	83 f8 01             	cmp    $0x1,%eax
f011d20e:	74 17                	je     f011d227 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011d210:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d217:	83 ec 0c             	sub    $0xc,%esp
f011d21a:	68 dc 05 13 f0       	push   $0xf01305dc
f011d21f:	e8 67 3d fe ff       	call   f0100f8b <cprintf>
f011d224:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d227:	e8 67 78 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d22c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d22f:	74 17                	je     f011d248 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d231:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d238:	83 ec 0c             	sub    $0xc,%esp
f011d23b:	68 fc 05 13 f0       	push   $0xf01305fc
f011d240:	e8 46 3d fe ff       	call   f0100f8b <cprintf>
f011d245:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011d248:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d24c:	74 04                	je     f011d252 <test_ksbrk+0x78e>
		eval += 25;
f011d24e:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011d252:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011d259:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011d25f:	bb 38 09 13 f0       	mov    $0xf0130938,%ebx
f011d264:	ba 05 00 00 00       	mov    $0x5,%edx
f011d269:	89 c7                	mov    %eax,%edi
f011d26b:	89 de                	mov    %ebx,%esi
f011d26d:	89 d1                	mov    %edx,%ecx
f011d26f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011d271:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d277:	bb 4c 09 13 f0       	mov    $0xf013094c,%ebx
f011d27c:	ba 05 00 00 00       	mov    $0x5,%edx
f011d281:	89 c7                	mov    %eax,%edi
f011d283:	89 de                	mov    %ebx,%esi
f011d285:	89 d1                	mov    %edx,%ecx
f011d287:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011d289:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011d28f:	bb 60 09 13 f0       	mov    $0xf0130960,%ebx
f011d294:	ba 05 00 00 00       	mov    $0x5,%edx
f011d299:	89 c7                	mov    %eax,%edi
f011d29b:	89 de                	mov    %ebx,%esi
f011d29d:	89 d1                	mov    %edx,%ecx
f011d29f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d2a1:	83 ec 04             	sub    $0x4,%esp
f011d2a4:	68 00 00 00 f8       	push   $0xf8000000
f011d2a9:	68 00 10 00 00       	push   $0x1000
f011d2ae:	68 00 00 00 f6       	push   $0xf6000000
f011d2b3:	e8 b8 c2 fe ff       	call   f0109570 <initialize_kheap_dynamic_allocator>
f011d2b8:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d2bb:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d2c2:	eb 1b                	jmp    f011d2df <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d2c4:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011d2c9:	83 ec 08             	sub    $0x8,%esp
f011d2cc:	ff 75 dc             	pushl  -0x24(%ebp)
f011d2cf:	50                   	push   %eax
f011d2d0:	e8 35 b8 fe ff       	call   f0108b0a <unmap_frame>
f011d2d5:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d2d8:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d2df:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d2e6:	76 dc                	jbe    f011d2c4 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d2e8:	83 ec 0c             	sub    $0xc,%esp
f011d2eb:	68 6c 06 13 f0       	push   $0xf013066c
f011d2f0:	e8 96 3c fe ff       	call   f0100f8b <cprintf>
f011d2f5:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d2f8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d2ff:	e9 21 01 00 00       	jmp    f011d425 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d304:	e8 89 18 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d309:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d30c:	e8 82 77 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d311:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d314:	83 ec 0c             	sub    $0xc,%esp
f011d317:	6a 00                	push   $0x0
f011d319:	e8 69 c3 fe ff       	call   f0109687 <sbrk>
f011d31e:	83 c4 10             	add    $0x10,%esp
f011d321:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d324:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d327:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d32e:	83 ec 0c             	sub    $0xc,%esp
f011d331:	50                   	push   %eax
f011d332:	e8 50 c3 fe ff       	call   f0109687 <sbrk>
f011d337:	83 c4 10             	add    $0x10,%esp
f011d33a:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d33d:	83 ec 0c             	sub    $0xc,%esp
f011d340:	6a 00                	push   $0x0
f011d342:	e8 40 c3 fe ff       	call   f0109687 <sbrk>
f011d347:	83 c4 10             	add    $0x10,%esp
f011d34a:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d34d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d354:	e8 3a 77 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d359:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d35c:	74 1a                	je     f011d378 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d35e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d365:	83 ec 08             	sub    $0x8,%esp
f011d368:	ff 75 d8             	pushl  -0x28(%ebp)
f011d36b:	68 b0 06 13 f0       	push   $0xf01306b0
f011d370:	e8 16 3c fe ff       	call   f0100f8b <cprintf>
f011d375:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d378:	e8 15 18 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d37d:	89 c2                	mov    %eax,%edx
f011d37f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d382:	29 d0                	sub    %edx,%eax
f011d384:	89 c2                	mov    %eax,%edx
f011d386:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d389:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d390:	39 c2                	cmp    %eax,%edx
f011d392:	74 1a                	je     f011d3ae <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d394:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d39b:	83 ec 08             	sub    $0x8,%esp
f011d39e:	ff 75 d8             	pushl  -0x28(%ebp)
f011d3a1:	68 20 07 13 f0       	push   $0xf0130720
f011d3a6:	e8 e0 3b fe ff       	call   f0100f8b <cprintf>
f011d3ab:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d3ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d3b1:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d3b8:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d3bb:	39 c2                	cmp    %eax,%edx
f011d3bd:	74 25                	je     f011d3e4 <test_ksbrk+0x920>
			{
				correct = 0;
f011d3bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d3c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d3c9:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d3d0:	ff 75 80             	pushl  -0x80(%ebp)
f011d3d3:	50                   	push   %eax
f011d3d4:	ff 75 d8             	pushl  -0x28(%ebp)
f011d3d7:	68 40 07 13 f0       	push   $0xf0130740
f011d3dc:	e8 aa 3b fe ff       	call   f0100f8b <cprintf>
f011d3e1:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d3e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d3e7:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d3ee:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d3f1:	74 25                	je     f011d418 <test_ksbrk+0x954>
			{
				correct = 0;
f011d3f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d3fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d3fd:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d404:	ff 75 90             	pushl  -0x70(%ebp)
f011d407:	50                   	push   %eax
f011d408:	ff 75 d8             	pushl  -0x28(%ebp)
f011d40b:	68 78 07 13 f0       	push   $0xf0130778
f011d410:	e8 76 3b fe ff       	call   f0100f8b <cprintf>
f011d415:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d418:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d41c:	74 04                	je     f011d422 <test_ksbrk+0x95e>
				eval += 10;
f011d41e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d422:	ff 45 d8             	incl   -0x28(%ebp)
f011d425:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d428:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d42b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d42e:	39 c2                	cmp    %eax,%edx
f011d430:	0f 87 ce fe ff ff    	ja     f011d304 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d436:	83 ec 0c             	sub    $0xc,%esp
f011d439:	68 ac 07 13 f0       	push   $0xf01307ac
f011d43e:	e8 48 3b fe ff       	call   f0100f8b <cprintf>
f011d443:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d446:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d449:	48                   	dec    %eax
f011d44a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d44d:	e9 18 01 00 00       	jmp    f011d56a <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d452:	e8 3b 17 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d457:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d45a:	e8 34 76 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d45f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d462:	83 ec 0c             	sub    $0xc,%esp
f011d465:	6a 00                	push   $0x0
f011d467:	e8 1b c2 fe ff       	call   f0109687 <sbrk>
f011d46c:	83 c4 10             	add    $0x10,%esp
f011d46f:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d472:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d475:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d47c:	83 ec 0c             	sub    $0xc,%esp
f011d47f:	50                   	push   %eax
f011d480:	e8 02 c2 fe ff       	call   f0109687 <sbrk>
f011d485:	83 c4 10             	add    $0x10,%esp
f011d488:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d48e:	83 ec 0c             	sub    $0xc,%esp
f011d491:	6a 00                	push   $0x0
f011d493:	e8 ef c1 fe ff       	call   f0109687 <sbrk>
f011d498:	83 c4 10             	add    $0x10,%esp
f011d49b:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d49e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d4a5:	e8 e9 75 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d4aa:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d4ad:	74 1a                	je     f011d4c9 <test_ksbrk+0xa05>
			{
				correct = 0;
f011d4af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d4b6:	83 ec 08             	sub    $0x8,%esp
f011d4b9:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d4bc:	68 fc 07 13 f0       	push   $0xf01307fc
f011d4c1:	e8 c5 3a fe ff       	call   f0100f8b <cprintf>
f011d4c6:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d4c9:	e8 c4 16 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d4ce:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d4d1:	74 1a                	je     f011d4ed <test_ksbrk+0xa29>
			{
				correct = 0;
f011d4d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d4da:	83 ec 08             	sub    $0x8,%esp
f011d4dd:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d4e0:	68 6c 08 13 f0       	push   $0xf013086c
f011d4e5:	e8 a1 3a fe ff       	call   f0100f8b <cprintf>
f011d4ea:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d4ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d4f0:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d4f7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d4fd:	39 c2                	cmp    %eax,%edx
f011d4ff:	74 28                	je     f011d529 <test_ksbrk+0xa65>
			{
				correct = 0;
f011d501:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d508:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d50b:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d512:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d518:	50                   	push   %eax
f011d519:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d51c:	68 8c 08 13 f0       	push   $0xf013088c
f011d521:	e8 65 3a fe ff       	call   f0100f8b <cprintf>
f011d526:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d529:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d52c:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d533:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d536:	74 25                	je     f011d55d <test_ksbrk+0xa99>
			{
				correct = 0;
f011d538:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d53f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d542:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d549:	ff 75 90             	pushl  -0x70(%ebp)
f011d54c:	50                   	push   %eax
f011d54d:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d550:	68 c4 08 13 f0       	push   $0xf01308c4
f011d555:	e8 31 3a fe ff       	call   f0100f8b <cprintf>
f011d55a:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d55d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d561:	74 04                	je     f011d567 <test_ksbrk+0xaa3>
				eval += 10;
f011d563:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d567:	ff 45 d4             	incl   -0x2c(%ebp)
f011d56a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d56d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d570:	0f 82 dc fe ff ff    	jb     f011d452 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d576:	83 ec 08             	sub    $0x8,%esp
f011d579:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d57c:	68 f8 08 13 f0       	push   $0xf01308f8
f011d581:	e8 05 3a fe ff       	call   f0100f8b <cprintf>
f011d586:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d589:	83 ec 0c             	sub    $0xc,%esp
f011d58c:	68 22 09 13 f0       	push   $0xf0130922
f011d591:	e8 f5 39 fe ff       	call   f0100f8b <cprintf>
f011d596:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d599:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d59e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d5a1:	5b                   	pop    %ebx
f011d5a2:	5e                   	pop    %esi
f011d5a3:	5f                   	pop    %edi
f011d5a4:	5d                   	pop    %ebp
f011d5a5:	c3                   	ret    

f011d5a6 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d5a6:	55                   	push   %ebp
f011d5a7:	89 e5                	mov    %esp,%ebp
f011d5a9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5ac:	83 ec 04             	sub    $0x4,%esp
f011d5af:	68 74 09 13 f0       	push   $0xf0130974
f011d5b4:	68 c2 08 00 00       	push   $0x8c2
f011d5b9:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d5be:	e8 76 2d fe ff       	call   f0100339 <_panic>

f011d5c3 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d5c3:	55                   	push   %ebp
f011d5c4:	89 e5                	mov    %esp,%ebp
f011d5c6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5c9:	83 ec 04             	sub    $0x4,%esp
f011d5cc:	68 74 09 13 f0       	push   $0xf0130974
f011d5d1:	68 c7 08 00 00       	push   $0x8c7
f011d5d6:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d5db:	e8 59 2d fe ff       	call   f0100339 <_panic>

f011d5e0 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d5e0:	55                   	push   %ebp
f011d5e1:	89 e5                	mov    %esp,%ebp
f011d5e3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5e6:	83 ec 04             	sub    $0x4,%esp
f011d5e9:	68 74 09 13 f0       	push   $0xf0130974
f011d5ee:	68 cc 08 00 00       	push   $0x8cc
f011d5f3:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d5f8:	e8 3c 2d fe ff       	call   f0100339 <_panic>

f011d5fd <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d5fd:	55                   	push   %ebp
f011d5fe:	89 e5                	mov    %esp,%ebp
f011d600:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d603:	83 ec 04             	sub    $0x4,%esp
f011d606:	68 74 09 13 f0       	push   $0xf0130974
f011d60b:	68 d1 08 00 00       	push   $0x8d1
f011d610:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d615:	e8 1f 2d fe ff       	call   f0100339 <_panic>

f011d61a <test_kfree>:
}

int test_kfree()
{
f011d61a:	55                   	push   %ebp
f011d61b:	89 e5                	mov    %esp,%ebp
f011d61d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d620:	83 ec 04             	sub    $0x4,%esp
f011d623:	68 74 09 13 f0       	push   $0xf0130974
f011d628:	68 d6 08 00 00       	push   $0x8d6
f011d62d:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d632:	e8 02 2d fe ff       	call   f0100339 <_panic>

f011d637 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d637:	55                   	push   %ebp
f011d638:	89 e5                	mov    %esp,%ebp
f011d63a:	57                   	push   %edi
f011d63b:	56                   	push   %esi
f011d63c:	53                   	push   %ebx
f011d63d:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d643:	a0 3c 0e 18 f0       	mov    0xf0180e3c,%al
f011d648:	84 c0                	test   %al,%al
f011d64a:	74 56                	je     f011d6a2 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d64c:	c6 05 3c 0e 18 f0 00 	movb   $0x0,0xf0180e3c
		initFreeFrames = sys_calculate_free_frames() ;
f011d653:	e8 3a 15 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d658:	a3 88 1f 6b f2       	mov    %eax,0xf26b1f88
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d65d:	e8 31 74 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d662:	a3 84 1f 6b f2       	mov    %eax,0xf26b1f84
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d667:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d66d:	bb d9 0a 13 f0       	mov    $0xf0130ad9,%ebx
f011d672:	ba 11 00 00 00       	mov    $0x11,%edx
f011d677:	89 c7                	mov    %eax,%edi
f011d679:	89 de                	mov    %ebx,%esi
f011d67b:	89 d1                	mov    %edx,%ecx
f011d67d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d67f:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d685:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d68a:	b0 00                	mov    $0x0,%al
f011d68c:	89 d7                	mov    %edx,%edi
f011d68e:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d690:	83 ec 0c             	sub    $0xc,%esp
f011d693:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d699:	50                   	push   %eax
f011d69a:	e8 5c 48 fe ff       	call   f0101efb <execute_command>
f011d69f:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d6a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d6a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d6b0:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f011d6b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d6b8:	eb 2b                	jmp    f011d6e5 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d6ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d6bd:	83 c0 20             	add    $0x20,%eax
f011d6c0:	83 ec 08             	sub    $0x8,%esp
f011d6c3:	68 84 09 13 f0       	push   $0xf0130984
f011d6c8:	50                   	push   %eax
f011d6c9:	e8 ea 28 00 00       	call   f011ffb8 <strcmp>
f011d6ce:	83 c4 10             	add    $0x10,%esp
f011d6d1:	85 c0                	test   %eax,%eax
f011d6d3:	75 08                	jne    f011d6dd <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d6d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d6d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d6db:	eb 2f                	jmp    f011d70c <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d6dd:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011d6e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d6e5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d6e9:	74 08                	je     f011d6f3 <test_three_creation_functions+0xbc>
f011d6eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d6ee:	8b 40 08             	mov    0x8(%eax),%eax
f011d6f1:	eb 05                	jmp    f011d6f8 <test_three_creation_functions+0xc1>
f011d6f3:	b8 00 00 00 00       	mov    $0x0,%eax
f011d6f8:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f011d6fd:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011d702:	85 c0                	test   %eax,%eax
f011d704:	75 b4                	jne    f011d6ba <test_three_creation_functions+0x83>
f011d706:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d70a:	75 ae                	jne    f011d6ba <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d70c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d70f:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d715:	85 c0                	test   %eax,%eax
f011d717:	74 17                	je     f011d730 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d719:	83 ec 04             	sub    $0x4,%esp
f011d71c:	68 8c 09 13 f0       	push   $0xf013098c
f011d721:	68 f7 08 00 00       	push   $0x8f7
f011d726:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d72b:	e8 09 2c fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d730:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d733:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d739:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d73c:	e8 51 14 ff ff       	call   f010eb92 <sys_calculate_free_frames>
f011d741:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d744:	e8 4a 73 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d749:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d74c:	a1 84 1f 6b f2       	mov    0xf26b1f84,%eax
f011d751:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d754:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d757:	74 17                	je     f011d770 <test_three_creation_functions+0x139>
f011d759:	83 ec 04             	sub    $0x4,%esp
f011d75c:	68 cc d3 12 f0       	push   $0xf012d3cc
f011d761:	68 01 09 00 00       	push   $0x901
f011d766:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d76b:	e8 c9 2b fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d770:	a1 88 1f 6b f2       	mov    0xf26b1f88,%eax
f011d775:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d778:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d77b:	83 c2 15             	add    $0x15,%edx
f011d77e:	39 d0                	cmp    %edx,%eax
f011d780:	74 17                	je     f011d799 <test_three_creation_functions+0x162>
f011d782:	83 ec 04             	sub    $0x4,%esp
f011d785:	68 dc 09 13 f0       	push   $0xf01309dc
f011d78a:	68 03 09 00 00       	push   $0x903
f011d78f:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d794:	e8 a0 2b fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d799:	83 ec 0c             	sub    $0xc,%esp
f011d79c:	68 00 10 00 00       	push   $0x1000
f011d7a1:	e8 14 c0 fe ff       	call   f01097ba <kmalloc>
f011d7a6:	83 c4 10             	add    $0x10,%esp
f011d7a9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d7ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d7af:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d7b4:	74 17                	je     f011d7cd <test_three_creation_functions+0x196>
f011d7b6:	83 ec 04             	sub    $0x4,%esp
f011d7b9:	68 1c 0a 13 f0       	push   $0xf0130a1c
f011d7be:	68 07 09 00 00       	push   $0x907
f011d7c3:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d7c8:	e8 6c 2b fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d7cd:	83 ec 0c             	sub    $0xc,%esp
f011d7d0:	68 8c 0a 13 f0       	push   $0xf0130a8c
f011d7d5:	e8 b1 37 fe ff       	call   f0100f8b <cprintf>
f011d7da:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d7dd:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d7e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d7e5:	5b                   	pop    %ebx
f011d7e6:	5e                   	pop    %esi
f011d7e7:	5f                   	pop    %edi
f011d7e8:	5d                   	pop    %ebp
f011d7e9:	c3                   	ret    

f011d7ea <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d7ea:	55                   	push   %ebp
f011d7eb:	89 e5                	mov    %esp,%ebp
f011d7ed:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d7f0:	83 ec 04             	sub    $0x4,%esp
f011d7f3:	68 74 09 13 f0       	push   $0xf0130974
f011d7f8:	68 15 09 00 00       	push   $0x915
f011d7fd:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d802:	e8 32 2b fe ff       	call   f0100339 <_panic>

f011d807 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d807:	55                   	push   %ebp
f011d808:	89 e5                	mov    %esp,%ebp
f011d80a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d80d:	83 ec 04             	sub    $0x4,%esp
f011d810:	68 74 09 13 f0       	push   $0xf0130974
f011d815:	68 1d 09 00 00       	push   $0x91d
f011d81a:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d81f:	e8 15 2b fe ff       	call   f0100339 <_panic>

f011d824 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d824:	55                   	push   %ebp
f011d825:	89 e5                	mov    %esp,%ebp
f011d827:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d82a:	83 ec 04             	sub    $0x4,%esp
f011d82d:	68 74 09 13 f0       	push   $0xf0130974
f011d832:	68 24 09 00 00       	push   $0x924
f011d837:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d83c:	e8 f8 2a fe ff       	call   f0100339 <_panic>

f011d841 <test_kfreelast>:

}


int test_kfreelast()
{
f011d841:	55                   	push   %ebp
f011d842:	89 e5                	mov    %esp,%ebp
f011d844:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d847:	83 ec 04             	sub    $0x4,%esp
f011d84a:	68 74 09 13 f0       	push   $0xf0130974
f011d84f:	68 2b 09 00 00       	push   $0x92b
f011d854:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d859:	e8 db 2a fe ff       	call   f0100339 <_panic>

f011d85e <test_krealloc>:

}

int test_krealloc() {
f011d85e:	55                   	push   %ebp
f011d85f:	89 e5                	mov    %esp,%ebp
f011d861:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d864:	83 ec 04             	sub    $0x4,%esp
f011d867:	68 74 09 13 f0       	push   $0xf0130974
f011d86c:	68 30 09 00 00       	push   $0x930
f011d871:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d876:	e8 be 2a fe ff       	call   f0100339 <_panic>

f011d87b <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d87b:	55                   	push   %ebp
f011d87c:	89 e5                	mov    %esp,%ebp
f011d87e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d881:	83 ec 04             	sub    $0x4,%esp
f011d884:	68 74 09 13 f0       	push   $0xf0130974
f011d889:	68 35 09 00 00       	push   $0x935
f011d88e:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d893:	e8 a1 2a fe ff       	call   f0100339 <_panic>

f011d898 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d898:	55                   	push   %ebp
f011d899:	89 e5                	mov    %esp,%ebp
f011d89b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d89e:	83 ec 04             	sub    $0x4,%esp
f011d8a1:	68 74 09 13 f0       	push   $0xf0130974
f011d8a6:	68 3b 09 00 00       	push   $0x93b
f011d8ab:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d8b0:	e8 84 2a fe ff       	call   f0100339 <_panic>

f011d8b5 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d8b5:	55                   	push   %ebp
f011d8b6:	89 e5                	mov    %esp,%ebp
f011d8b8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8bb:	83 ec 04             	sub    $0x4,%esp
f011d8be:	68 74 09 13 f0       	push   $0xf0130974
f011d8c3:	68 40 09 00 00       	push   $0x940
f011d8c8:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d8cd:	e8 67 2a fe ff       	call   f0100339 <_panic>

f011d8d2 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d8d2:	55                   	push   %ebp
f011d8d3:	89 e5                	mov    %esp,%ebp
f011d8d5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8d8:	83 ec 04             	sub    $0x4,%esp
f011d8db:	68 74 09 13 f0       	push   $0xf0130974
f011d8e0:	68 46 09 00 00       	push   $0x946
f011d8e5:	68 b3 d3 12 f0       	push   $0xf012d3b3
f011d8ea:	e8 4a 2a fe ff       	call   f0100339 <_panic>

f011d8ef <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d8ef:	55                   	push   %ebp
f011d8f0:	89 e5                	mov    %esp,%ebp
f011d8f2:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d8f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d8fc:	e9 84 00 00 00       	jmp    f011d985 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d901:	83 ec 08             	sub    $0x8,%esp
f011d904:	ff 75 f4             	pushl  -0xc(%ebp)
f011d907:	68 40 0b 13 f0       	push   $0xf0130b40
f011d90c:	e8 7a 36 fe ff       	call   f0100f8b <cprintf>
f011d911:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d914:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d91b:	eb 4c                	jmp    f011d969 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d91d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d920:	89 d0                	mov    %edx,%eax
f011d922:	c1 e0 02             	shl    $0x2,%eax
f011d925:	01 d0                	add    %edx,%eax
f011d927:	c1 e0 03             	shl    $0x3,%eax
f011d92a:	89 c2                	mov    %eax,%edx
f011d92c:	8b 45 08             	mov    0x8(%ebp),%eax
f011d92f:	01 c2                	add    %eax,%edx
f011d931:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d934:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d937:	85 c0                	test   %eax,%eax
f011d939:	74 36                	je     f011d971 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d93b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d93e:	89 d0                	mov    %edx,%eax
f011d940:	c1 e0 02             	shl    $0x2,%eax
f011d943:	01 d0                	add    %edx,%eax
f011d945:	c1 e0 03             	shl    $0x3,%eax
f011d948:	89 c2                	mov    %eax,%edx
f011d94a:	8b 45 08             	mov    0x8(%ebp),%eax
f011d94d:	01 c2                	add    %eax,%edx
f011d94f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d952:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d955:	83 ec 08             	sub    $0x8,%esp
f011d958:	50                   	push   %eax
f011d959:	68 48 0b 13 f0       	push   $0xf0130b48
f011d95e:	e8 28 36 fe ff       	call   f0100f8b <cprintf>
f011d963:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d966:	ff 45 f0             	incl   -0x10(%ebp)
f011d969:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d96d:	7e ae                	jle    f011d91d <print_order+0x2e>
f011d96f:	eb 01                	jmp    f011d972 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d971:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d972:	83 ec 0c             	sub    $0xc,%esp
f011d975:	68 4d 0b 13 f0       	push   $0xf0130b4d
f011d97a:	e8 0c 36 fe ff       	call   f0100f8b <cprintf>
f011d97f:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d982:	ff 45 f4             	incl   -0xc(%ebp)
f011d985:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d989:	0f 8e 72 ff ff ff    	jle    f011d901 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d98f:	90                   	nop
f011d990:	c9                   	leave  
f011d991:	c3                   	ret    

f011d992 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d992:	55                   	push   %ebp
f011d993:	89 e5                	mov    %esp,%ebp
f011d995:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d998:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d99f:	83 ec 0c             	sub    $0xc,%esp
f011d9a2:	68 80 f0 71 f0       	push   $0xf071f080
f011d9a7:	e8 52 25 ff ff       	call   f010fefe <acquire_spinlock>
f011d9ac:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d9af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d9b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d9bd:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d9c0:	8b 45 10             	mov    0x10(%ebp),%eax
f011d9c3:	01 d0                	add    %edx,%eax
f011d9c5:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d9c8:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011d9cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d9d0:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011d9d5:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d9d8:	ff 75 e8             	pushl  -0x18(%ebp)
f011d9db:	ff 75 0c             	pushl  0xc(%ebp)
f011d9de:	ff 75 08             	pushl  0x8(%ebp)
f011d9e1:	68 50 0b 13 f0       	push   $0xf0130b50
f011d9e6:	e8 a0 35 fe ff       	call   f0100f8b <cprintf>
f011d9eb:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d9ee:	eb 34                	jmp    f011da24 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d9f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d9f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d9f6:	7d 05                	jge    f011d9fd <find_in_range+0x6b>
			{
				i++;
f011d9f8:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d9fb:	eb 1e                	jmp    f011da1b <find_in_range+0x89>
			}
			if (i >= end)
f011d9fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011da00:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011da03:	7d 29                	jge    f011da2e <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011da05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011da08:	8b 40 10             	mov    0x10(%eax),%eax
f011da0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f011da0e:	75 08                	jne    f011da18 <find_in_range+0x86>
			{
				ret = i;
f011da10:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011da13:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011da16:	eb 17                	jmp    f011da2f <find_in_range+0x9d>
			}
			i++;
f011da18:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011da1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011da1e:	8b 40 0c             	mov    0xc(%eax),%eax
f011da21:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011da24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011da27:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011da2a:	7c c4                	jl     f011d9f0 <find_in_range+0x5e>
f011da2c:	eb 01                	jmp    f011da2f <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011da2e:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011da2f:	83 ec 0c             	sub    $0xc,%esp
f011da32:	68 80 f0 71 f0       	push   $0xf071f080
f011da37:	e8 49 25 ff ff       	call   f010ff85 <release_spinlock>
f011da3c:	83 c4 10             	add    $0x10,%esp
	return ret;
f011da3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011da42:	c9                   	leave  
f011da43:	c3                   	ret    

f011da44 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011da44:	55                   	push   %ebp
f011da45:	89 e5                	mov    %esp,%ebp
f011da47:	57                   	push   %edi
f011da48:	56                   	push   %esi
f011da49:	53                   	push   %ebx
f011da4a:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011da4d:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011da52:	84 c0                	test   %al,%al
f011da54:	0f 84 9b 01 00 00    	je     f011dbf5 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011da5a:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011da61:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011da64:	bb c8 0c 13 f0       	mov    $0xf0130cc8,%ebx
f011da69:	ba 05 00 00 00       	mov    $0x5,%edx
f011da6e:	89 c7                	mov    %eax,%edi
f011da70:	89 de                	mov    %ebx,%esi
f011da72:	89 d1                	mov    %edx,%ecx
f011da74:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011da76:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011da7d:	e9 44 01 00 00       	jmp    f011dbc6 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011da82:	6a 00                	push   $0x0
f011da84:	6a 00                	push   $0x0
f011da86:	68 f4 01 00 00       	push   $0x1f4
f011da8b:	68 81 0b 13 f0       	push   $0xf0130b81
f011da90:	e8 5d d7 fe ff       	call   f010b1f2 <env_create>
f011da95:	83 c4 10             	add    $0x10,%esp
f011da98:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011da9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011da9e:	b9 05 00 00 00       	mov    $0x5,%ecx
f011daa3:	99                   	cltd   
f011daa4:	f7 f9                	idiv   %ecx
f011daa6:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011daa9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011daac:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dab0:	83 ec 08             	sub    $0x8,%esp
f011dab3:	50                   	push   %eax
f011dab4:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dab7:	e8 35 8e fe ff       	call   f01068f1 <env_set_nice>
f011dabc:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dabf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dac3:	75 14                	jne    f011dad9 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011dac5:	83 ec 04             	sub    $0x4,%esp
f011dac8:	68 89 0b 13 f0       	push   $0xf0130b89
f011dacd:	6a 53                	push   $0x53
f011dacf:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011dad4:	e8 60 28 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011dad9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dadc:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dae2:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dae7:	74 14                	je     f011dafd <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011dae9:	83 ec 04             	sub    $0x4,%esp
f011daec:	68 c0 0b 13 f0       	push   $0xf0130bc0
f011daf1:	6a 55                	push   $0x55
f011daf3:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011daf8:	e8 3c 28 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dafd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db00:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011db04:	83 c0 0a             	add    $0xa,%eax
f011db07:	83 f8 14             	cmp    $0x14,%eax
f011db0a:	0f 87 a5 00 00 00    	ja     f011dbb5 <test_bsd_nice_0+0x171>
f011db10:	8b 04 85 dc 0c 13 f0 	mov    -0xfecf324(,%eax,4),%eax
f011db17:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011db19:	a1 1c ee 71 f0       	mov    0xf071ee1c,%eax
f011db1e:	8d 50 01             	lea    0x1(%eax),%edx
f011db21:	89 15 1c ee 71 f0    	mov    %edx,0xf071ee1c
f011db27:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011db2a:	8b 52 10             	mov    0x10(%edx),%edx
f011db2d:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011db34:	eb 7f                	jmp    f011dbb5 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011db36:	a1 20 ee 71 f0       	mov    0xf071ee20,%eax
f011db3b:	8d 50 01             	lea    0x1(%eax),%edx
f011db3e:	89 15 20 ee 71 f0    	mov    %edx,0xf071ee20
f011db44:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011db47:	8b 52 10             	mov    0x10(%edx),%edx
f011db4a:	83 c0 0a             	add    $0xa,%eax
f011db4d:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011db54:	eb 5f                	jmp    f011dbb5 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011db56:	a1 24 ee 71 f0       	mov    0xf071ee24,%eax
f011db5b:	8d 50 01             	lea    0x1(%eax),%edx
f011db5e:	89 15 24 ee 71 f0    	mov    %edx,0xf071ee24
f011db64:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011db67:	8b 52 10             	mov    0x10(%edx),%edx
f011db6a:	83 c0 14             	add    $0x14,%eax
f011db6d:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011db74:	eb 3f                	jmp    f011dbb5 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011db76:	a1 28 ee 71 f0       	mov    0xf071ee28,%eax
f011db7b:	8d 50 01             	lea    0x1(%eax),%edx
f011db7e:	89 15 28 ee 71 f0    	mov    %edx,0xf071ee28
f011db84:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011db87:	8b 52 10             	mov    0x10(%edx),%edx
f011db8a:	83 c0 1e             	add    $0x1e,%eax
f011db8d:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011db94:	eb 1f                	jmp    f011dbb5 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011db96:	a1 2c ee 71 f0       	mov    0xf071ee2c,%eax
f011db9b:	8d 50 01             	lea    0x1(%eax),%edx
f011db9e:	89 15 2c ee 71 f0    	mov    %edx,0xf071ee2c
f011dba4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dba7:	8b 52 10             	mov    0x10(%edx),%edx
f011dbaa:	83 c0 28             	add    $0x28,%eax
f011dbad:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011dbb4:	90                   	nop
			}
			sched_new_env(env);
f011dbb5:	83 ec 0c             	sub    $0xc,%esp
f011dbb8:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dbbb:	e8 c7 7d fe ff       	call   f0105987 <sched_new_env>
f011dbc0:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011dbc3:	ff 45 e4             	incl   -0x1c(%ebp)
f011dbc6:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011dbca:	0f 8e b2 fe ff ff    	jle    f011da82 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dbd0:	83 ec 0c             	sub    $0xc,%esp
f011dbd3:	68 f0 0b 13 f0       	push   $0xf0130bf0
f011dbd8:	e8 ae 33 fe ff       	call   f0100f8b <cprintf>
f011dbdd:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011dbe0:	83 ec 0c             	sub    $0xc,%esp
f011dbe3:	68 3f 0c 13 f0       	push   $0xf0130c3f
f011dbe8:	e8 0e 43 fe ff       	call   f0101efb <execute_command>
f011dbed:	83 c4 10             	add    $0x10,%esp
f011dbf0:	e9 c0 00 00 00       	jmp    f011dcb5 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011dbf5:	83 ec 0c             	sub    $0xc,%esp
f011dbf8:	68 46 0c 13 f0       	push   $0xf0130c46
f011dbfd:	e8 89 33 fe ff       	call   f0100f8b <cprintf>
f011dc02:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dc05:	e8 b5 84 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011dc0a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dc11:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011dc18:	e9 87 00 00 00       	jmp    f011dca4 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dc1d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011dc24:	eb 52                	jmp    f011dc78 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011dc26:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dc29:	8b 14 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%edx
f011dc30:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011dc33:	89 c8                	mov    %ecx,%eax
f011dc35:	c1 e0 02             	shl    $0x2,%eax
f011dc38:	01 c8                	add    %ecx,%eax
f011dc3a:	01 c0                	add    %eax,%eax
f011dc3c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011dc3f:	01 c8                	add    %ecx,%eax
f011dc41:	8b 04 85 a0 1f 6b f2 	mov    -0xd94e060(,%eax,4),%eax
f011dc48:	83 ec 04             	sub    $0x4,%esp
f011dc4b:	52                   	push   %edx
f011dc4c:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc4f:	50                   	push   %eax
f011dc50:	e8 3d fd ff ff       	call   f011d992 <find_in_range>
f011dc55:	83 c4 10             	add    $0x10,%esp
f011dc58:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011dc5b:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011dc5f:	75 14                	jne    f011dc75 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011dc61:	83 ec 04             	sub    $0x4,%esp
f011dc64:	68 58 0c 13 f0       	push   $0xf0130c58
f011dc69:	6a 7b                	push   $0x7b
f011dc6b:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011dc70:	e8 c4 26 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dc75:	ff 45 d8             	incl   -0x28(%ebp)
f011dc78:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011dc7b:	89 d0                	mov    %edx,%eax
f011dc7d:	c1 e0 02             	shl    $0x2,%eax
f011dc80:	01 d0                	add    %edx,%eax
f011dc82:	01 c0                	add    %eax,%eax
f011dc84:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011dc87:	01 d0                	add    %edx,%eax
f011dc89:	8b 04 85 a0 1f 6b f2 	mov    -0xd94e060(,%eax,4),%eax
f011dc90:	85 c0                	test   %eax,%eax
f011dc92:	75 92                	jne    f011dc26 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011dc94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dc97:	8b 04 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%eax
f011dc9e:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dca1:	ff 45 dc             	incl   -0x24(%ebp)
f011dca4:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011dca8:	0f 8e 6f ff ff ff    	jle    f011dc1d <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011dcae:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011dcb5:	83 ec 0c             	sub    $0xc,%esp
f011dcb8:	68 8c 0c 13 f0       	push   $0xf0130c8c
f011dcbd:	e8 c9 32 fe ff       	call   f0100f8b <cprintf>
f011dcc2:	83 c4 10             	add    $0x10,%esp
}
f011dcc5:	90                   	nop
f011dcc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dcc9:	5b                   	pop    %ebx
f011dcca:	5e                   	pop    %esi
f011dccb:	5f                   	pop    %edi
f011dccc:	5d                   	pop    %ebp
f011dccd:	c3                   	ret    

f011dcce <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011dcce:	55                   	push   %ebp
f011dccf:	89 e5                	mov    %esp,%ebp
f011dcd1:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011dcd4:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011dcd9:	84 c0                	test   %al,%al
f011dcdb:	0f 84 50 01 00 00    	je     f011de31 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011dce1:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011dce8:	6a 00                	push   $0x0
f011dcea:	6a 00                	push   $0x0
f011dcec:	68 f4 01 00 00       	push   $0x1f4
f011dcf1:	68 81 0b 13 f0       	push   $0xf0130b81
f011dcf6:	e8 f7 d4 fe ff       	call   f010b1f2 <env_create>
f011dcfb:	83 c4 10             	add    $0x10,%esp
f011dcfe:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011dd01:	6a 00                	push   $0x0
f011dd03:	6a 00                	push   $0x0
f011dd05:	68 f4 01 00 00       	push   $0x1f4
f011dd0a:	68 30 0d 13 f0       	push   $0xf0130d30
f011dd0f:	e8 de d4 fe ff       	call   f010b1f2 <env_create>
f011dd14:	83 c4 10             	add    $0x10,%esp
f011dd17:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011dd1a:	6a 00                	push   $0x0
f011dd1c:	6a 00                	push   $0x0
f011dd1e:	68 f4 01 00 00       	push   $0x1f4
f011dd23:	68 3d 0d 13 f0       	push   $0xf0130d3d
f011dd28:	e8 c5 d4 fe ff       	call   f010b1f2 <env_create>
f011dd2d:	83 c4 10             	add    $0x10,%esp
f011dd30:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011dd33:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dd37:	74 0c                	je     f011dd45 <test_bsd_nice_1+0x77>
f011dd39:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011dd3d:	74 06                	je     f011dd45 <test_bsd_nice_1+0x77>
f011dd3f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011dd43:	75 17                	jne    f011dd5c <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011dd45:	83 ec 04             	sub    $0x4,%esp
f011dd48:	68 89 0b 13 f0       	push   $0xf0130b89
f011dd4d:	68 8e 00 00 00       	push   $0x8e
f011dd52:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011dd57:	e8 dd 25 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011dd5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dd5f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dd65:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dd6a:	75 20                	jne    f011dd8c <test_bsd_nice_1+0xbe>
f011dd6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd6f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dd75:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dd7a:	75 10                	jne    f011dd8c <test_bsd_nice_1+0xbe>
f011dd7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dd7f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dd85:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dd8a:	74 35                	je     f011ddc1 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011dd8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dd8f:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011dd95:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd98:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011dd9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dda1:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dda7:	83 ec 08             	sub    $0x8,%esp
f011ddaa:	51                   	push   %ecx
f011ddab:	52                   	push   %edx
f011ddac:	50                   	push   %eax
f011ddad:	68 4c 0d 13 f0       	push   $0xf0130d4c
f011ddb2:	68 90 00 00 00       	push   $0x90
f011ddb7:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011ddbc:	e8 78 25 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011ddc1:	83 ec 0c             	sub    $0xc,%esp
f011ddc4:	ff 75 ec             	pushl  -0x14(%ebp)
f011ddc7:	e8 bb 7b fe ff       	call   f0105987 <sched_new_env>
f011ddcc:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011ddcf:	83 ec 0c             	sub    $0xc,%esp
f011ddd2:	ff 75 e8             	pushl  -0x18(%ebp)
f011ddd5:	e8 ad 7b fe ff       	call   f0105987 <sched_new_env>
f011ddda:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011dddd:	83 ec 0c             	sub    $0xc,%esp
f011dde0:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dde3:	e8 9f 7b fe ff       	call   f0105987 <sched_new_env>
f011dde8:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011ddeb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ddee:	8b 40 10             	mov    0x10(%eax),%eax
f011ddf1:	a3 a0 1f 6b f2       	mov    %eax,0xf26b1fa0
		prog_orders[1][0] = fibEnv->env_id;
f011ddf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ddf9:	8b 40 10             	mov    0x10(%eax),%eax
f011ddfc:	a3 c8 1f 6b f2       	mov    %eax,0xf26b1fc8
		prog_orders[2][0] = fibposnEnv->env_id;
f011de01:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de04:	8b 40 10             	mov    0x10(%eax),%eax
f011de07:	a3 f0 1f 6b f2       	mov    %eax,0xf26b1ff0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011de0c:	83 ec 0c             	sub    $0xc,%esp
f011de0f:	68 f0 0b 13 f0       	push   $0xf0130bf0
f011de14:	e8 72 31 fe ff       	call   f0100f8b <cprintf>
f011de19:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011de1c:	83 ec 0c             	sub    $0xc,%esp
f011de1f:	68 3f 0c 13 f0       	push   $0xf0130c3f
f011de24:	e8 d2 40 fe ff       	call   f0101efb <execute_command>
f011de29:	83 c4 10             	add    $0x10,%esp
f011de2c:	e9 9e 00 00 00       	jmp    f011decf <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011de31:	83 ec 0c             	sub    $0xc,%esp
f011de34:	68 46 0c 13 f0       	push   $0xf0130c46
f011de39:	e8 4d 31 fe ff       	call   f0100f8b <cprintf>
f011de3e:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011de41:	e8 79 82 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011de46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011de4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011de54:	83 ec 0c             	sub    $0xc,%esp
f011de57:	68 80 f0 71 f0       	push   $0xf071f080
f011de5c:	e8 9d 20 ff ff       	call   f010fefe <acquire_spinlock>
f011de61:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011de64:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011de69:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011de6c:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011de71:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011de74:	eb 41                	jmp    f011deb7 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011de76:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011de79:	89 d0                	mov    %edx,%eax
f011de7b:	c1 e0 02             	shl    $0x2,%eax
f011de7e:	01 d0                	add    %edx,%eax
f011de80:	c1 e0 03             	shl    $0x3,%eax
f011de83:	05 a0 1f 6b f2       	add    $0xf26b1fa0,%eax
f011de88:	8b 10                	mov    (%eax),%edx
f011de8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011de8d:	8b 40 10             	mov    0x10(%eax),%eax
f011de90:	39 c2                	cmp    %eax,%edx
f011de92:	74 17                	je     f011deab <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011de94:	83 ec 04             	sub    $0x4,%esp
f011de97:	68 58 0c 13 f0       	push   $0xf0130c58
f011de9c:	68 ab 00 00 00       	push   $0xab
f011dea1:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011dea6:	e8 8e 24 fe ff       	call   f0100339 <_panic>
				i++;
f011deab:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011deae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011deb1:	8b 40 0c             	mov    0xc(%eax),%eax
f011deb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011deb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011deba:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011debd:	7c b7                	jl     f011de76 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011debf:	83 ec 0c             	sub    $0xc,%esp
f011dec2:	68 80 f0 71 f0       	push   $0xf071f080
f011dec7:	e8 b9 20 ff ff       	call   f010ff85 <release_spinlock>
f011decc:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011decf:	83 ec 0c             	sub    $0xc,%esp
f011ded2:	68 b8 0d 13 f0       	push   $0xf0130db8
f011ded7:	e8 af 30 fe ff       	call   f0100f8b <cprintf>
f011dedc:	83 c4 10             	add    $0x10,%esp
}
f011dedf:	90                   	nop
f011dee0:	c9                   	leave  
f011dee1:	c3                   	ret    

f011dee2 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011dee2:	55                   	push   %ebp
f011dee3:	89 e5                	mov    %esp,%ebp
f011dee5:	57                   	push   %edi
f011dee6:	56                   	push   %esi
f011dee7:	53                   	push   %ebx
f011dee8:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011deeb:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011def0:	84 c0                	test   %al,%al
f011def2:	0f 84 ae 01 00 00    	je     f011e0a6 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011def8:	83 ec 0c             	sub    $0xc,%esp
f011defb:	6a 01                	push   $0x1
f011defd:	e8 fe 10 00 00       	call   f011f000 <chksch>
f011df02:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011df05:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {15, 5, 0, -5, -15};
f011df0c:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011df0f:	bb 3c 0e 13 f0       	mov    $0xf0130e3c,%ebx
f011df14:	ba 05 00 00 00       	mov    $0x5,%edx
f011df19:	89 c7                	mov    %eax,%edi
f011df1b:	89 de                	mov    %ebx,%esi
f011df1d:	89 d1                	mov    %edx,%ecx
f011df1f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011df21:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011df28:	e9 4a 01 00 00       	jmp    f011e077 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011df2d:	6a 00                	push   $0x0
f011df2f:	6a 00                	push   $0x0
f011df31:	68 10 27 00 00       	push   $0x2710
f011df36:	68 f4 0d 13 f0       	push   $0xf0130df4
f011df3b:	e8 b2 d2 fe ff       	call   f010b1f2 <env_create>
f011df40:	83 c4 10             	add    $0x10,%esp
f011df43:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011df46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011df49:	b9 05 00 00 00       	mov    $0x5,%ecx
f011df4e:	99                   	cltd   
f011df4f:	f7 f9                	idiv   %ecx
f011df51:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011df54:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011df57:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011df5b:	83 ec 08             	sub    $0x8,%esp
f011df5e:	50                   	push   %eax
f011df5f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011df62:	e8 8a 89 fe ff       	call   f01068f1 <env_set_nice>
f011df67:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011df6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011df6e:	75 17                	jne    f011df87 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011df70:	83 ec 04             	sub    $0x4,%esp
f011df73:	68 89 0b 13 f0       	push   $0xf0130b89
f011df78:	68 c1 00 00 00       	push   $0xc1
f011df7d:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011df82:	e8 b2 23 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011df87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011df8a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011df90:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011df95:	74 17                	je     f011dfae <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011df97:	83 ec 04             	sub    $0x4,%esp
f011df9a:	68 c0 0b 13 f0       	push   $0xf0130bc0
f011df9f:	68 c3 00 00 00       	push   $0xc3
f011dfa4:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011dfa9:	e8 8b 23 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dfae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dfb1:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dfb5:	83 c0 0f             	add    $0xf,%eax
f011dfb8:	83 f8 1e             	cmp    $0x1e,%eax
f011dfbb:	0f 87 a5 00 00 00    	ja     f011e066 <test_bsd_nice_2+0x184>
f011dfc1:	8b 04 85 50 0e 13 f0 	mov    -0xfecf1b0(,%eax,4),%eax
f011dfc8:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dfca:	a1 1c ee 71 f0       	mov    0xf071ee1c,%eax
f011dfcf:	8d 50 01             	lea    0x1(%eax),%edx
f011dfd2:	89 15 1c ee 71 f0    	mov    %edx,0xf071ee1c
f011dfd8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dfdb:	8b 52 10             	mov    0x10(%edx),%edx
f011dfde:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011dfe5:	eb 7f                	jmp    f011e066 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011dfe7:	a1 20 ee 71 f0       	mov    0xf071ee20,%eax
f011dfec:	8d 50 01             	lea    0x1(%eax),%edx
f011dfef:	89 15 20 ee 71 f0    	mov    %edx,0xf071ee20
f011dff5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dff8:	8b 52 10             	mov    0x10(%edx),%edx
f011dffb:	83 c0 0a             	add    $0xa,%eax
f011dffe:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011e005:	eb 5f                	jmp    f011e066 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e007:	a1 24 ee 71 f0       	mov    0xf071ee24,%eax
f011e00c:	8d 50 01             	lea    0x1(%eax),%edx
f011e00f:	89 15 24 ee 71 f0    	mov    %edx,0xf071ee24
f011e015:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e018:	8b 52 10             	mov    0x10(%edx),%edx
f011e01b:	83 c0 14             	add    $0x14,%eax
f011e01e:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011e025:	eb 3f                	jmp    f011e066 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e027:	a1 28 ee 71 f0       	mov    0xf071ee28,%eax
f011e02c:	8d 50 01             	lea    0x1(%eax),%edx
f011e02f:	89 15 28 ee 71 f0    	mov    %edx,0xf071ee28
f011e035:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e038:	8b 52 10             	mov    0x10(%edx),%edx
f011e03b:	83 c0 1e             	add    $0x1e,%eax
f011e03e:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011e045:	eb 1f                	jmp    f011e066 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e047:	a1 2c ee 71 f0       	mov    0xf071ee2c,%eax
f011e04c:	8d 50 01             	lea    0x1(%eax),%edx
f011e04f:	89 15 2c ee 71 f0    	mov    %edx,0xf071ee2c
f011e055:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e058:	8b 52 10             	mov    0x10(%edx),%edx
f011e05b:	83 c0 28             	add    $0x28,%eax
f011e05e:	89 14 85 a0 1f 6b f2 	mov    %edx,-0xd94e060(,%eax,4)
				break;
f011e065:	90                   	nop
			}
			sched_new_env(env);
f011e066:	83 ec 0c             	sub    $0xc,%esp
f011e069:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e06c:	e8 16 79 fe ff       	call   f0105987 <sched_new_env>
f011e071:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e074:	ff 45 e4             	incl   -0x1c(%ebp)
f011e077:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011e07b:	0f 8e ac fe ff ff    	jle    f011df2d <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e081:	83 ec 0c             	sub    $0xc,%esp
f011e084:	68 f0 0b 13 f0       	push   $0xf0130bf0
f011e089:	e8 fd 2e fe ff       	call   f0100f8b <cprintf>
f011e08e:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e091:	83 ec 0c             	sub    $0xc,%esp
f011e094:	68 3f 0c 13 f0       	push   $0xf0130c3f
f011e099:	e8 5d 3e fe ff       	call   f0101efb <execute_command>
f011e09e:	83 c4 10             	add    $0x10,%esp
f011e0a1:	e9 d0 00 00 00       	jmp    f011e176 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011e0a6:	83 ec 0c             	sub    $0xc,%esp
f011e0a9:	6a 00                	push   $0x0
f011e0ab:	e8 50 0f 00 00       	call   f011f000 <chksch>
f011e0b0:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011e0b3:	83 ec 0c             	sub    $0xc,%esp
f011e0b6:	68 46 0c 13 f0       	push   $0xf0130c46
f011e0bb:	e8 cb 2e fe ff       	call   f0100f8b <cprintf>
f011e0c0:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e0c3:	e8 f7 7f fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e0c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e0cf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e0d6:	e9 8a 00 00 00       	jmp    f011e165 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e0db:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e0e2:	eb 55                	jmp    f011e139 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e0e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e0e7:	8b 14 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%edx
f011e0ee:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e0f1:	89 c8                	mov    %ecx,%eax
f011e0f3:	c1 e0 02             	shl    $0x2,%eax
f011e0f6:	01 c8                	add    %ecx,%eax
f011e0f8:	01 c0                	add    %eax,%eax
f011e0fa:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e0fd:	01 c8                	add    %ecx,%eax
f011e0ff:	8b 04 85 a0 1f 6b f2 	mov    -0xd94e060(,%eax,4),%eax
f011e106:	83 ec 04             	sub    $0x4,%esp
f011e109:	52                   	push   %edx
f011e10a:	ff 75 e0             	pushl  -0x20(%ebp)
f011e10d:	50                   	push   %eax
f011e10e:	e8 7f f8 ff ff       	call   f011d992 <find_in_range>
f011e113:	83 c4 10             	add    $0x10,%esp
f011e116:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e119:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e11d:	75 17                	jne    f011e136 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011e11f:	83 ec 04             	sub    $0x4,%esp
f011e122:	68 58 0c 13 f0       	push   $0xf0130c58
f011e127:	68 ea 00 00 00       	push   $0xea
f011e12c:	68 a2 0b 13 f0       	push   $0xf0130ba2
f011e131:	e8 03 22 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e136:	ff 45 d8             	incl   -0x28(%ebp)
f011e139:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e13c:	89 d0                	mov    %edx,%eax
f011e13e:	c1 e0 02             	shl    $0x2,%eax
f011e141:	01 d0                	add    %edx,%eax
f011e143:	01 c0                	add    %eax,%eax
f011e145:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e148:	01 d0                	add    %edx,%eax
f011e14a:	8b 04 85 a0 1f 6b f2 	mov    -0xd94e060(,%eax,4),%eax
f011e151:	85 c0                	test   %eax,%eax
f011e153:	75 8f                	jne    f011e0e4 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011e155:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e158:	8b 04 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%eax
f011e15f:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e162:	ff 45 dc             	incl   -0x24(%ebp)
f011e165:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011e169:	0f 8e 6c ff ff ff    	jle    f011e0db <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011e16f:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011e176:	83 ec 0c             	sub    $0xc,%esp
f011e179:	68 00 0e 13 f0       	push   $0xf0130e00
f011e17e:	e8 08 2e fe ff       	call   f0100f8b <cprintf>
f011e183:	83 c4 10             	add    $0x10,%esp
}
f011e186:	90                   	nop
f011e187:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e18a:	5b                   	pop    %ebx
f011e18b:	5e                   	pop    %esi
f011e18c:	5f                   	pop    %edi
f011e18d:	5d                   	pop    %ebp
f011e18e:	c3                   	ret    

f011e18f <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011e18f:	55                   	push   %ebp
f011e190:	89 e5                	mov    %esp,%ebp
f011e192:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011e195:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e198:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011e19b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e19e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011e1a1:	89 10                	mov    %edx,(%eax)
}
f011e1a3:	8b 45 08             	mov    0x8(%ebp),%eax
f011e1a6:	c9                   	leave  
f011e1a7:	c2 04 00             	ret    $0x4

f011e1aa <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011e1aa:	55                   	push   %ebp
f011e1ab:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011e1ad:	8b 45 08             	mov    0x8(%ebp),%eax
f011e1b0:	85 c0                	test   %eax,%eax
f011e1b2:	78 16                	js     f011e1ca <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011e1b4:	8b 45 08             	mov    0x8(%ebp),%eax
f011e1b7:	05 00 20 00 00       	add    $0x2000,%eax
f011e1bc:	85 c0                	test   %eax,%eax
f011e1be:	79 05                	jns    f011e1c5 <fix_round+0x1b>
f011e1c0:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e1c5:	c1 f8 0e             	sar    $0xe,%eax
f011e1c8:	eb 14                	jmp    f011e1de <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011e1ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011e1cd:	2d 00 20 00 00       	sub    $0x2000,%eax
f011e1d2:	85 c0                	test   %eax,%eax
f011e1d4:	79 05                	jns    f011e1db <fix_round+0x31>
f011e1d6:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e1db:	c1 f8 0e             	sar    $0xe,%eax
}
f011e1de:	5d                   	pop    %ebp
f011e1df:	c3                   	ret    

f011e1e0 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011e1e0:	55                   	push   %ebp
f011e1e1:	89 e5                	mov    %esp,%ebp
f011e1e3:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011e1e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e1ea:	79 16                	jns    f011e202 <fix_scale+0x22>
f011e1ec:	68 cc 0e 13 f0       	push   $0xf0130ecc
f011e1f1:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011e1f6:	6a 5a                	push   $0x5a
f011e1f8:	68 e8 0e 13 f0       	push   $0xf0130ee8
f011e1fd:	e8 37 21 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011e202:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e205:	0f af 45 10          	imul   0x10(%ebp),%eax
f011e209:	89 c2                	mov    %eax,%edx
f011e20b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e20e:	83 ec 08             	sub    $0x8,%esp
f011e211:	52                   	push   %edx
f011e212:	50                   	push   %eax
f011e213:	e8 77 ff ff ff       	call   f011e18f <__mk_fix>
f011e218:	83 c4 0c             	add    $0xc,%esp
}
f011e21b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e21e:	c9                   	leave  
f011e21f:	c2 04 00             	ret    $0x4

f011e222 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011e222:	55                   	push   %ebp
f011e223:	89 e5                	mov    %esp,%ebp
f011e225:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011e228:	83 ec 08             	sub    $0x8,%esp
f011e22b:	68 fc 0e 13 f0       	push   $0xf0130efc
f011e230:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e235:	e8 93 1c ff ff       	call   f010fecd <init_spinlock>
f011e23a:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011e23d:	83 ec 0c             	sub    $0xc,%esp
f011e240:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e245:	e8 b4 1c ff ff       	call   f010fefe <acquire_spinlock>
f011e24a:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011e24d:	c7 05 68 ef 71 f0 00 	movl   $0x0,0xf071ef68
f011e254:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011e257:	83 ec 0c             	sub    $0xc,%esp
f011e25a:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e25f:	e8 21 1d ff ff       	call   f010ff85 <release_spinlock>
f011e264:	83 c4 10             	add    $0x10,%esp
}
f011e267:	90                   	nop
f011e268:	c9                   	leave  
f011e269:	c3                   	ret    

f011e26a <inctst>:
void inctst()
{
f011e26a:	55                   	push   %ebp
f011e26b:	89 e5                	mov    %esp,%ebp
f011e26d:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011e270:	83 ec 0c             	sub    $0xc,%esp
f011e273:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e278:	e8 81 1c ff ff       	call   f010fefe <acquire_spinlock>
f011e27d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011e280:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e285:	40                   	inc    %eax
f011e286:	a3 68 ef 71 f0       	mov    %eax,0xf071ef68
	}
	release_spinlock(&tstcntlock);
f011e28b:	83 ec 0c             	sub    $0xc,%esp
f011e28e:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e293:	e8 ed 1c ff ff       	call   f010ff85 <release_spinlock>
f011e298:	83 c4 10             	add    $0x10,%esp
}
f011e29b:	90                   	nop
f011e29c:	c9                   	leave  
f011e29d:	c3                   	ret    

f011e29e <gettst>:
uint32 gettst()
{
f011e29e:	55                   	push   %ebp
f011e29f:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e2a1:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
}
f011e2a6:	5d                   	pop    %ebp
f011e2a7:	c3                   	ret    

f011e2a8 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e2a8:	55                   	push   %ebp
f011e2a9:	89 e5                	mov    %esp,%ebp
f011e2ab:	83 ec 28             	sub    $0x28,%esp
f011e2ae:	8b 45 14             	mov    0x14(%ebp),%eax
f011e2b1:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e2b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e2bb:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e2bf:	83 f8 65             	cmp    $0x65,%eax
f011e2c2:	74 5d                	je     f011e321 <tst+0x79>
f011e2c4:	83 f8 65             	cmp    $0x65,%eax
f011e2c7:	7f 0a                	jg     f011e2d3 <tst+0x2b>
f011e2c9:	83 f8 62             	cmp    $0x62,%eax
f011e2cc:	74 73                	je     f011e341 <tst+0x99>
f011e2ce:	e9 91 00 00 00       	jmp    f011e364 <tst+0xbc>
f011e2d3:	83 f8 67             	cmp    $0x67,%eax
f011e2d6:	74 29                	je     f011e301 <tst+0x59>
f011e2d8:	83 f8 6c             	cmp    $0x6c,%eax
f011e2db:	0f 85 83 00 00 00    	jne    f011e364 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e2e1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e2e4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e2e7:	73 09                	jae    f011e2f2 <tst+0x4a>
			chk = 1;
f011e2e9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e2f0:	eb 68                	jmp    f011e35a <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e2f2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e2f6:	74 62                	je     f011e35a <tst+0xb2>
			chk = 1;
f011e2f8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e2ff:	eb 59                	jmp    f011e35a <tst+0xb2>
	case 'g':
		if (n > v1)
f011e301:	8b 45 08             	mov    0x8(%ebp),%eax
f011e304:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e307:	76 09                	jbe    f011e312 <tst+0x6a>
			chk = 1;
f011e309:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e310:	eb 4b                	jmp    f011e35d <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e312:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e316:	74 45                	je     f011e35d <tst+0xb5>
			chk = 1;
f011e318:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e31f:	eb 3c                	jmp    f011e35d <tst+0xb5>
	case 'e':
		if (n == v1)
f011e321:	8b 45 08             	mov    0x8(%ebp),%eax
f011e324:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e327:	75 09                	jne    f011e332 <tst+0x8a>
			chk = 1;
f011e329:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e330:	eb 2e                	jmp    f011e360 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e332:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e336:	74 28                	je     f011e360 <tst+0xb8>
			chk = 1;
f011e338:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e33f:	eb 1f                	jmp    f011e360 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e341:	8b 45 08             	mov    0x8(%ebp),%eax
f011e344:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e347:	72 1a                	jb     f011e363 <tst+0xbb>
f011e349:	8b 45 08             	mov    0x8(%ebp),%eax
f011e34c:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e34f:	77 12                	ja     f011e363 <tst+0xbb>
			chk = 1;
f011e351:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e358:	eb 09                	jmp    f011e363 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e35a:	90                   	nop
f011e35b:	eb 07                	jmp    f011e364 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e35d:	90                   	nop
f011e35e:	eb 04                	jmp    f011e364 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e360:	90                   	nop
f011e361:	eb 01                	jmp    f011e364 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e363:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e364:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e368:	75 14                	jne    f011e37e <tst+0xd6>
f011e36a:	83 ec 04             	sub    $0x4,%esp
f011e36d:	68 08 0f 13 f0       	push   $0xf0130f08
f011e372:	6a 48                	push   $0x48
f011e374:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011e379:	e8 bb 1f fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e37e:	83 ec 0c             	sub    $0xc,%esp
f011e381:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e386:	e8 73 1b ff ff       	call   f010fefe <acquire_spinlock>
f011e38b:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e38e:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e393:	40                   	inc    %eax
f011e394:	a3 68 ef 71 f0       	mov    %eax,0xf071ef68
	}
	release_spinlock(&tstcntlock);
f011e399:	83 ec 0c             	sub    $0xc,%esp
f011e39c:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e3a1:	e8 df 1b ff ff       	call   f010ff85 <release_spinlock>
f011e3a6:	83 c4 10             	add    $0x10,%esp

	return;
f011e3a9:	90                   	nop
}
f011e3aa:	c9                   	leave  
f011e3ab:	c3                   	ret    

f011e3ac <chktst>:

void chktst(uint32 n)
{
f011e3ac:	55                   	push   %ebp
f011e3ad:	89 e5                	mov    %esp,%ebp
f011e3af:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e3b2:	83 ec 0c             	sub    $0xc,%esp
f011e3b5:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e3ba:	e8 3f 1b ff ff       	call   f010fefe <acquire_spinlock>
f011e3bf:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e3c2:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e3c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e3ca:	83 ec 0c             	sub    $0xc,%esp
f011e3cd:	68 a0 f8 f1 f0       	push   $0xf0f1f8a0
f011e3d2:	e8 ae 1b ff ff       	call   f010ff85 <release_spinlock>
f011e3d7:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e3da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e3dd:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e3e0:	75 12                	jne    f011e3f4 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e3e2:	83 ec 0c             	sub    $0xc,%esp
f011e3e5:	68 34 0f 13 f0       	push   $0xf0130f34
f011e3ea:	e8 9c 2b fe ff       	call   f0100f8b <cprintf>
f011e3ef:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e3f2:	eb 14                	jmp    f011e408 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e3f4:	83 ec 04             	sub    $0x4,%esp
f011e3f7:	68 60 0f 13 f0       	push   $0xf0130f60
f011e3fc:	6a 5e                	push   $0x5e
f011e3fe:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011e403:	e8 31 1f fe ff       	call   f0100339 <_panic>
}
f011e408:	c9                   	leave  
f011e409:	c3                   	ret    

f011e40a <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e40a:	55                   	push   %ebp
f011e40b:	89 e5                	mov    %esp,%ebp
f011e40d:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e410:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e414:	77 07                	ja     f011e41d <nearest_pow2_ceil+0x13>
f011e416:	b8 01 00 00 00       	mov    $0x1,%eax
f011e41b:	eb 20                	jmp    f011e43d <nearest_pow2_ceil+0x33>
	int power = 2;
f011e41d:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e424:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e427:	eb 08                	jmp    f011e431 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e429:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e42c:	01 c0                	add    %eax,%eax
f011e42e:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e431:	d1 6d 08             	shrl   0x8(%ebp)
f011e434:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e438:	75 ef                	jne    f011e429 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e43a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e43d:	c9                   	leave  
f011e43e:	c3                   	ret    

f011e43f <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e43f:	55                   	push   %ebp
f011e440:	89 e5                	mov    %esp,%ebp
f011e442:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e445:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e449:	77 07                	ja     f011e452 <log2_ceil+0x13>
f011e44b:	b8 01 00 00 00       	mov    $0x1,%eax
f011e450:	eb 1b                	jmp    f011e46d <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e452:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e459:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e45c:	eb 03                	jmp    f011e461 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e45e:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e461:	d1 6d 08             	shrl   0x8(%ebp)
f011e464:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e468:	75 f4                	jne    f011e45e <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e46a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e46d:	c9                   	leave  
f011e46e:	c3                   	ret    

f011e46f <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e46f:	55                   	push   %ebp
f011e470:	89 e5                	mov    %esp,%ebp
f011e472:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e475:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e47c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e483:	eb 12                	jmp    f011e497 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e485:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e488:	89 d0                	mov    %edx,%eax
f011e48a:	c1 e0 02             	shl    $0x2,%eax
f011e48d:	01 d0                	add    %edx,%eax
f011e48f:	01 c0                	add    %eax,%eax
f011e491:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e494:	ff 45 f0             	incl   -0x10(%ebp)
f011e497:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e49a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e49d:	7c e6                	jl     f011e485 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e49f:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e4a2:	83 ec 04             	sub    $0x4,%esp
f011e4a5:	ff 75 f4             	pushl  -0xc(%ebp)
f011e4a8:	ff 75 08             	pushl  0x8(%ebp)
f011e4ab:	50                   	push   %eax
f011e4ac:	e8 2f fd ff ff       	call   f011e1e0 <fix_scale>
f011e4b1:	83 c4 0c             	add    $0xc,%esp
f011e4b4:	83 ec 0c             	sub    $0xc,%esp
f011e4b7:	ff 75 dc             	pushl  -0x24(%ebp)
f011e4ba:	e8 eb fc ff ff       	call   f011e1aa <fix_round>
f011e4bf:	83 c4 10             	add    $0x10,%esp
f011e4c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e4c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e4c8:	99                   	cltd   
f011e4c9:	f7 7d f4             	idivl  -0xc(%ebp)
f011e4cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e4cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e4d2:	99                   	cltd   
f011e4d3:	f7 7d f4             	idivl  -0xc(%ebp)
f011e4d6:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e4d9:	83 ec 08             	sub    $0x8,%esp
f011e4dc:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e4df:	50                   	push   %eax
f011e4e0:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e4e3:	e8 6a 1e 00 00       	call   f0120352 <ltostr>
f011e4e8:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e4eb:	83 ec 08             	sub    $0x8,%esp
f011e4ee:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e4f1:	50                   	push   %eax
f011e4f2:	ff 75 e0             	pushl  -0x20(%ebp)
f011e4f5:	e8 58 1e 00 00       	call   f0120352 <ltostr>
f011e4fa:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e4fd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e500:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e505:	f7 e9                	imul   %ecx
f011e507:	c1 fa 02             	sar    $0x2,%edx
f011e50a:	89 c8                	mov    %ecx,%eax
f011e50c:	c1 f8 1f             	sar    $0x1f,%eax
f011e50f:	29 c2                	sub    %eax,%edx
f011e511:	89 d0                	mov    %edx,%eax
f011e513:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e516:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e51d:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e524:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e52a:	eb 31                	jmp    f011e55d <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e52c:	83 ec 04             	sub    $0x4,%esp
f011e52f:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e532:	50                   	push   %eax
f011e533:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e536:	50                   	push   %eax
f011e537:	68 7c 0f 13 f0       	push   $0xf0130f7c
f011e53c:	e8 ea 1e 00 00       	call   f012042b <strcconcat>
f011e541:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e544:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e547:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e54c:	f7 e9                	imul   %ecx
f011e54e:	c1 fa 02             	sar    $0x2,%edx
f011e551:	89 c8                	mov    %ecx,%eax
f011e553:	c1 f8 1f             	sar    $0x1f,%eax
f011e556:	29 c2                	sub    %eax,%edx
f011e558:	89 d0                	mov    %edx,%eax
f011e55a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e55d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e560:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e563:	7c c7                	jl     f011e52c <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e565:	83 ec 04             	sub    $0x4,%esp
f011e568:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e56b:	50                   	push   %eax
f011e56c:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e56f:	50                   	push   %eax
f011e570:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e573:	50                   	push   %eax
f011e574:	e8 b2 1e 00 00       	call   f012042b <strcconcat>
f011e579:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e57c:	83 ec 04             	sub    $0x4,%esp
f011e57f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e582:	50                   	push   %eax
f011e583:	68 7e 0f 13 f0       	push   $0xf0130f7e
f011e588:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e58b:	50                   	push   %eax
f011e58c:	e8 9a 1e 00 00       	call   f012042b <strcconcat>
f011e591:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e594:	83 ec 04             	sub    $0x4,%esp
f011e597:	ff 75 10             	pushl  0x10(%ebp)
f011e59a:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e59d:	50                   	push   %eax
f011e59e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e5a1:	50                   	push   %eax
f011e5a2:	e8 84 1e 00 00       	call   f012042b <strcconcat>
f011e5a7:	83 c4 10             	add    $0x10,%esp

}
f011e5aa:	90                   	nop
f011e5ab:	c9                   	leave  
f011e5ac:	c3                   	ret    

f011e5ad <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e5ad:	55                   	push   %ebp
f011e5ae:	89 e5                	mov    %esp,%ebp
f011e5b0:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e5b6:	83 ec 0c             	sub    $0xc,%esp
f011e5b9:	68 80 0f 13 f0       	push   $0xf0130f80
f011e5be:	e8 e9 18 00 00       	call   f011feac <strlen>
f011e5c3:	83 c4 10             	add    $0x10,%esp
f011e5c6:	83 ec 04             	sub    $0x4,%esp
f011e5c9:	50                   	push   %eax
f011e5ca:	68 80 0f 13 f0       	push   $0xf0130f80
f011e5cf:	ff 75 08             	pushl  0x8(%ebp)
f011e5d2:	e8 19 1a 00 00       	call   f011fff0 <strncmp>
f011e5d7:	83 c4 10             	add    $0x10,%esp
f011e5da:	85 c0                	test   %eax,%eax
f011e5dc:	0f 85 8a 00 00 00    	jne    f011e66c <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e5e2:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e5e5:	50                   	push   %eax
f011e5e6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e5ec:	50                   	push   %eax
f011e5ed:	68 8e 0f 13 f0       	push   $0xf0130f8e
f011e5f2:	ff 75 08             	pushl  0x8(%ebp)
f011e5f5:	e8 c7 1e 00 00       	call   f01204c1 <strsplit>
f011e5fa:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e5fd:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e603:	83 ec 04             	sub    $0x4,%esp
f011e606:	6a 0a                	push   $0xa
f011e608:	6a 00                	push   $0x0
f011e60a:	50                   	push   %eax
f011e60b:	e8 fc 1b 00 00       	call   f012020c <strtol>
f011e610:	83 c4 10             	add    $0x10,%esp
f011e613:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e616:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e61d:	83 ec 04             	sub    $0x4,%esp
f011e620:	6a 00                	push   $0x0
f011e622:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e625:	50                   	push   %eax
f011e626:	ff 75 e0             	pushl  -0x20(%ebp)
f011e629:	e8 92 d6 fe ff       	call   f010bcc0 <envid2env>
f011e62e:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e631:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e634:	8b 40 10             	mov    0x10(%eax),%eax
f011e637:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e63a:	74 19                	je     f011e655 <sys_utilities+0xa8>
f011e63c:	68 90 0f 13 f0       	push   $0xf0130f90
f011e641:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011e646:	68 a4 00 00 00       	push   $0xa4
f011e64b:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011e650:	e8 e4 1c fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e655:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e658:	83 ec 08             	sub    $0x8,%esp
f011e65b:	ff 75 0c             	pushl  0xc(%ebp)
f011e65e:	50                   	push   %eax
f011e65f:	e8 8d 82 fe ff       	call   f01068f1 <env_set_nice>
f011e664:	83 c4 10             	add    $0x10,%esp
f011e667:	e9 12 04 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e66c:	83 ec 0c             	sub    $0xc,%esp
f011e66f:	68 a5 0f 13 f0       	push   $0xf0130fa5
f011e674:	e8 33 18 00 00       	call   f011feac <strlen>
f011e679:	83 c4 10             	add    $0x10,%esp
f011e67c:	83 ec 04             	sub    $0x4,%esp
f011e67f:	50                   	push   %eax
f011e680:	68 a5 0f 13 f0       	push   $0xf0130fa5
f011e685:	ff 75 08             	pushl  0x8(%ebp)
f011e688:	e8 63 19 00 00       	call   f011fff0 <strncmp>
f011e68d:	83 c4 10             	add    $0x10,%esp
f011e690:	85 c0                	test   %eax,%eax
f011e692:	0f 85 a6 01 00 00    	jne    f011e83e <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e698:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e69b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e69e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e6a1:	50                   	push   %eax
f011e6a2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e6a8:	50                   	push   %eax
f011e6a9:	68 8e 0f 13 f0       	push   $0xf0130f8e
f011e6ae:	ff 75 08             	pushl  0x8(%ebp)
f011e6b1:	e8 0b 1e 00 00       	call   f01204c1 <strsplit>
f011e6b6:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e6b9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e6bf:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e6c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e6c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e6d0:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e6d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e6da:	8b 00                	mov    (%eax),%eax
f011e6dc:	85 c0                	test   %eax,%eax
f011e6de:	79 1c                	jns    f011e6fc <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e6e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e6e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e6ea:	8b 00                	mov    (%eax),%eax
f011e6ec:	f7 d8                	neg    %eax
f011e6ee:	89 c2                	mov    %eax,%edx
f011e6f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e6f3:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e6f5:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e6fc:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e703:	83 ec 0c             	sub    $0xc,%esp
f011e706:	68 80 f0 71 f0       	push   $0xf071f080
f011e70b:	e8 ee 17 ff ff       	call   f010fefe <acquire_spinlock>
f011e710:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e713:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011e718:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e71b:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011e720:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e723:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e726:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e729:	eb 6c                	jmp    f011e797 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e72b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e72e:	83 c0 20             	add    $0x20,%eax
f011e731:	83 ec 08             	sub    $0x8,%esp
f011e734:	ff 75 d8             	pushl  -0x28(%ebp)
f011e737:	50                   	push   %eax
f011e738:	e8 7b 18 00 00       	call   f011ffb8 <strcmp>
f011e73d:	83 c4 10             	add    $0x10,%esp
f011e740:	85 c0                	test   %eax,%eax
f011e742:	75 46                	jne    f011e78a <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e744:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e747:	8b 00                	mov    (%eax),%eax
f011e749:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e74c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e74f:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e751:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e755:	74 14                	je     f011e76b <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e757:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e75a:	8b 40 10             	mov    0x10(%eax),%eax
f011e75d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e760:	7d 1d                	jge    f011e77f <sys_utilities+0x1d2>
					{
						success = 0;
f011e762:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e769:	eb 32                	jmp    f011e79d <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e76b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e76e:	8b 40 10             	mov    0x10(%eax),%eax
f011e771:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e774:	7e 09                	jle    f011e77f <sys_utilities+0x1d2>
					{
						success = 0;
f011e776:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e77d:	eb 1e                	jmp    f011e79d <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e77f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e782:	8b 40 10             	mov    0x10(%eax),%eax
f011e785:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e788:	eb 01                	jmp    f011e78b <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e78a:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e78b:	ff 4d e4             	decl   -0x1c(%ebp)
f011e78e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e791:	8b 40 0c             	mov    0xc(%eax),%eax
f011e794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e797:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e79b:	7f 8e                	jg     f011e72b <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e79d:	83 ec 0c             	sub    $0xc,%esp
f011e7a0:	68 80 f0 71 f0       	push   $0xf071f080
f011e7a5:	e8 db 17 ff ff       	call   f010ff85 <release_spinlock>
f011e7aa:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e7ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e7b0:	8b 00                	mov    (%eax),%eax
f011e7b2:	85 c0                	test   %eax,%eax
f011e7b4:	75 06                	jne    f011e7bc <sys_utilities+0x20f>
f011e7b6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e7ba:	75 41                	jne    f011e7fd <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e7bc:	83 ec 0c             	sub    $0xc,%esp
f011e7bf:	68 b8 0f 13 f0       	push   $0xf0130fb8
f011e7c4:	e8 c2 27 fe ff       	call   f0100f8b <cprintf>
f011e7c9:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e7cc:	83 ec 08             	sub    $0x8,%esp
f011e7cf:	ff 75 d8             	pushl  -0x28(%ebp)
f011e7d2:	68 e8 0f 13 f0       	push   $0xf0130fe8
f011e7d7:	e8 af 27 fe ff       	call   f0100f8b <cprintf>
f011e7dc:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e7df:	83 ec 0c             	sub    $0xc,%esp
f011e7e2:	68 b8 0f 13 f0       	push   $0xf0130fb8
f011e7e7:	e8 9f 27 fe ff       	call   f0100f8b <cprintf>
f011e7ec:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e7ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e7f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e7f8:	e9 81 02 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e7fd:	83 ec 0c             	sub    $0xc,%esp
f011e800:	68 08 10 13 f0       	push   $0xf0131008
f011e805:	e8 81 27 fe ff       	call   f0100f8b <cprintf>
f011e80a:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e80d:	83 ec 08             	sub    $0x8,%esp
f011e810:	ff 75 d8             	pushl  -0x28(%ebp)
f011e813:	68 40 10 13 f0       	push   $0xf0131040
f011e818:	e8 6e 27 fe ff       	call   f0100f8b <cprintf>
f011e81d:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e820:	83 ec 0c             	sub    $0xc,%esp
f011e823:	68 08 10 13 f0       	push   $0xf0131008
f011e828:	e8 5e 27 fe ff       	call   f0100f8b <cprintf>
f011e82d:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e833:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e839:	e9 40 02 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e83e:	83 ec 08             	sub    $0x8,%esp
f011e841:	68 63 10 13 f0       	push   $0xf0131063
f011e846:	ff 75 08             	pushl  0x8(%ebp)
f011e849:	e8 6a 17 00 00       	call   f011ffb8 <strcmp>
f011e84e:	83 c4 10             	add    $0x10,%esp
f011e851:	85 c0                	test   %eax,%eax
f011e853:	75 77                	jne    f011e8cc <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e855:	a1 40 0e 18 f0       	mov    0xf0180e40,%eax
f011e85a:	85 c0                	test   %eax,%eax
f011e85c:	74 34                	je     f011e892 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e85e:	c7 05 40 0e 18 f0 00 	movl   $0x0,0xf0180e40
f011e865:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e868:	83 ec 08             	sub    $0x8,%esp
f011e86b:	68 6d 10 13 f0       	push   $0xf013106d
f011e870:	68 80 20 6b f2       	push   $0xf26b2080
f011e875:	e8 44 1a ff ff       	call   f01102be <init_channel>
f011e87a:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e87d:	83 ec 08             	sub    $0x8,%esp
f011e880:	68 7a 10 13 f0       	push   $0xf013107a
f011e885:	68 00 22 6b f2       	push   $0xf26b2200
f011e88a:	e8 3e 16 ff ff       	call   f010fecd <init_spinlock>
f011e88f:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e892:	83 ec 0c             	sub    $0xc,%esp
f011e895:	68 00 22 6b f2       	push   $0xf26b2200
f011e89a:	e8 5f 16 ff ff       	call   f010fefe <acquire_spinlock>
f011e89f:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e8a2:	83 ec 08             	sub    $0x8,%esp
f011e8a5:	68 00 22 6b f2       	push   $0xf26b2200
f011e8aa:	68 80 20 6b f2       	push   $0xf26b2080
f011e8af:	e8 37 1a ff ff       	call   f01102eb <sleep>
f011e8b4:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e8b7:	83 ec 0c             	sub    $0xc,%esp
f011e8ba:	68 00 22 6b f2       	push   $0xf26b2200
f011e8bf:	e8 c1 16 ff ff       	call   f010ff85 <release_spinlock>
f011e8c4:	83 c4 10             	add    $0x10,%esp
f011e8c7:	e9 b2 01 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e8cc:	83 ec 08             	sub    $0x8,%esp
f011e8cf:	68 8c 10 13 f0       	push   $0xf013108c
f011e8d4:	ff 75 08             	pushl  0x8(%ebp)
f011e8d7:	e8 dc 16 00 00       	call   f011ffb8 <strcmp>
f011e8dc:	83 c4 10             	add    $0x10,%esp
f011e8df:	85 c0                	test   %eax,%eax
f011e8e1:	75 15                	jne    f011e8f8 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e8e3:	83 ec 0c             	sub    $0xc,%esp
f011e8e6:	68 80 20 6b f2       	push   $0xf26b2080
f011e8eb:	e8 68 1a ff ff       	call   f0110358 <wakeup_one>
f011e8f0:	83 c4 10             	add    $0x10,%esp
f011e8f3:	e9 86 01 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e8f8:	83 ec 08             	sub    $0x8,%esp
f011e8fb:	68 9a 10 13 f0       	push   $0xf013109a
f011e900:	ff 75 08             	pushl  0x8(%ebp)
f011e903:	e8 b0 16 00 00       	call   f011ffb8 <strcmp>
f011e908:	83 c4 10             	add    $0x10,%esp
f011e90b:	85 c0                	test   %eax,%eax
f011e90d:	75 15                	jne    f011e924 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e90f:	83 ec 0c             	sub    $0xc,%esp
f011e912:	68 80 20 6b f2       	push   $0xf26b2080
f011e917:	e8 c0 1a ff ff       	call   f01103dc <wakeup_all>
f011e91c:	83 c4 10             	add    $0x10,%esp
f011e91f:	e9 5a 01 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e924:	83 ec 08             	sub    $0x8,%esp
f011e927:	68 a8 10 13 f0       	push   $0xf01310a8
f011e92c:	ff 75 08             	pushl  0x8(%ebp)
f011e92f:	e8 84 16 00 00       	call   f011ffb8 <strcmp>
f011e934:	83 c4 10             	add    $0x10,%esp
f011e937:	85 c0                	test   %eax,%eax
f011e939:	75 17                	jne    f011e952 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e93b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e93e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e941:	a1 8c 20 6b f2       	mov    0xf26b208c,%eax
f011e946:	89 c2                	mov    %eax,%edx
f011e948:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e94b:	89 10                	mov    %edx,(%eax)
f011e94d:	e9 2c 01 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e952:	83 ec 08             	sub    $0x8,%esp
f011e955:	68 bd 10 13 f0       	push   $0xf01310bd
f011e95a:	ff 75 08             	pushl  0x8(%ebp)
f011e95d:	e8 56 16 00 00       	call   f011ffb8 <strcmp>
f011e962:	83 c4 10             	add    $0x10,%esp
f011e965:	85 c0                	test   %eax,%eax
f011e967:	75 1a                	jne    f011e983 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e969:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e96c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e96f:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011e974:	8b 40 0c             	mov    0xc(%eax),%eax
f011e977:	89 c2                	mov    %eax,%edx
f011e979:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e97c:	89 10                	mov    %edx,(%eax)
f011e97e:	e9 fb 00 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e983:	83 ec 08             	sub    $0x8,%esp
f011e986:	68 d3 10 13 f0       	push   $0xf01310d3
f011e98b:	ff 75 08             	pushl  0x8(%ebp)
f011e98e:	e8 25 16 00 00       	call   f011ffb8 <strcmp>
f011e993:	83 c4 10             	add    $0x10,%esp
f011e996:	85 c0                	test   %eax,%eax
f011e998:	75 3d                	jne    f011e9d7 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e99a:	a1 44 0e 18 f0       	mov    0xf0180e44,%eax
f011e99f:	85 c0                	test   %eax,%eax
f011e9a1:	74 1f                	je     f011e9c2 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e9a3:	c7 05 44 0e 18 f0 00 	movl   $0x0,0xf0180e44
f011e9aa:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e9ad:	83 ec 08             	sub    $0x8,%esp
f011e9b0:	68 e8 10 13 f0       	push   $0xf01310e8
f011e9b5:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e9ba:	e8 99 17 ff ff       	call   f0110158 <init_sleeplock>
f011e9bf:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e9c2:	83 ec 0c             	sub    $0xc,%esp
f011e9c5:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e9ca:	e8 4d 18 ff ff       	call   f011021c <acquire_sleeplock>
f011e9cf:	83 c4 10             	add    $0x10,%esp
f011e9d2:	e9 a7 00 00 00       	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e9d7:	83 ec 08             	sub    $0x8,%esp
f011e9da:	68 f8 10 13 f0       	push   $0xf01310f8
f011e9df:	ff 75 08             	pushl  0x8(%ebp)
f011e9e2:	e8 d1 15 00 00       	call   f011ffb8 <strcmp>
f011e9e7:	83 c4 10             	add    $0x10,%esp
f011e9ea:	85 c0                	test   %eax,%eax
f011e9ec:	75 12                	jne    f011ea00 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e9ee:	83 ec 0c             	sub    $0xc,%esp
f011e9f1:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e9f6:	e8 7b 18 ff ff       	call   f0110276 <release_sleeplock>
f011e9fb:	83 c4 10             	add    $0x10,%esp
f011e9fe:	eb 7e                	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011ea00:	83 ec 08             	sub    $0x8,%esp
f011ea03:	68 0d 11 13 f0       	push   $0xf013110d
f011ea08:	ff 75 08             	pushl  0x8(%ebp)
f011ea0b:	e8 a8 15 00 00       	call   f011ffb8 <strcmp>
f011ea10:	83 c4 10             	add    $0x10,%esp
f011ea13:	85 c0                	test   %eax,%eax
f011ea15:	75 14                	jne    f011ea2b <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011ea17:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea1a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011ea1d:	a1 60 21 6b f2       	mov    0xf26b2160,%eax
f011ea22:	89 c2                	mov    %eax,%edx
f011ea24:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ea27:	89 10                	mov    %edx,(%eax)
f011ea29:	eb 53                	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011ea2b:	83 ec 08             	sub    $0x8,%esp
f011ea2e:	68 22 11 13 f0       	push   $0xf0131122
f011ea33:	ff 75 08             	pushl  0x8(%ebp)
f011ea36:	e8 7d 15 00 00       	call   f011ffb8 <strcmp>
f011ea3b:	83 c4 10             	add    $0x10,%esp
f011ea3e:	85 c0                	test   %eax,%eax
f011ea40:	75 13                	jne    f011ea55 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011ea42:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea45:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011ea48:	8b 15 e0 20 6b f2    	mov    0xf26b20e0,%edx
f011ea4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ea51:	89 10                	mov    %edx,(%eax)
f011ea53:	eb 29                	jmp    f011ea7e <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011ea55:	83 ec 08             	sub    $0x8,%esp
f011ea58:	68 33 11 13 f0       	push   $0xf0131133
f011ea5d:	ff 75 08             	pushl  0x8(%ebp)
f011ea60:	e8 53 15 00 00       	call   f011ffb8 <strcmp>
f011ea65:	83 c4 10             	add    $0x10,%esp
f011ea68:	85 c0                	test   %eax,%eax
f011ea6a:	75 12                	jne    f011ea7e <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011ea6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea6f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011ea72:	a1 e4 21 6b f2       	mov    0xf26b21e4,%eax
f011ea77:	89 c2                	mov    %eax,%edx
f011ea79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ea7c:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011ea7e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ea82:	79 5b                	jns    f011eadf <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011ea84:	83 ec 08             	sub    $0x8,%esp
f011ea87:	68 44 11 13 f0       	push   $0xf0131144
f011ea8c:	ff 75 08             	pushl  0x8(%ebp)
f011ea8f:	e8 24 15 00 00       	call   f011ffb8 <strcmp>
f011ea94:	83 c4 10             	add    $0x10,%esp
f011ea97:	85 c0                	test   %eax,%eax
f011ea99:	75 44                	jne    f011eadf <sys_utilities+0x532>
		{
			switch (value)
f011ea9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea9e:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011eaa1:	74 07                	je     f011eaaa <sys_utilities+0x4fd>
f011eaa3:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011eaa6:	74 19                	je     f011eac1 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011eaa8:	eb 35                	jmp    f011eadf <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011eaaa:	83 ec 0c             	sub    $0xc,%esp
f011eaad:	68 54 11 13 f0       	push   $0xf0131154
f011eab2:	e8 d4 24 fe ff       	call   f0100f8b <cprintf>
f011eab7:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011eaba:	e8 a4 0d ff ff       	call   f010f863 <setPageReplacmentAlgorithmFIFO>
				break;
f011eabf:	eb 1e                	jmp    f011eadf <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011eac1:	83 ec 0c             	sub    $0xc,%esp
f011eac4:	68 c4 11 13 f0       	push   $0xf01311c4
f011eac9:	e8 bd 24 fe ff       	call   f0100f8b <cprintf>
f011eace:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011ead1:	83 ec 0c             	sub    $0xc,%esp
f011ead4:	6a 02                	push   $0x2
f011ead6:	e8 45 0d ff ff       	call   f010f820 <setPageReplacmentAlgorithmLRU>
f011eadb:	83 c4 10             	add    $0x10,%esp
				break;
f011eade:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011eadf:	90                   	nop
f011eae0:	c9                   	leave  
f011eae1:	c3                   	ret    

f011eae2 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011eae2:	55                   	push   %ebp
f011eae3:	89 e5                	mov    %esp,%ebp
f011eae5:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011eae8:	8b 45 08             	mov    0x8(%ebp),%eax
f011eaeb:	8b 00                	mov    (%eax),%eax
f011eaed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011eaf0:	8b 45 08             	mov    0x8(%ebp),%eax
f011eaf3:	8b 00                	mov    (%eax),%eax
f011eaf5:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011eaf8:	eb 52                	jmp    f011eb4c <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011eafa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eafd:	8b 00                	mov    (%eax),%eax
f011eaff:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011eb02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eb05:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011eb08:	75 12                	jne    f011eb1c <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011eb0a:	83 ec 0c             	sub    $0xc,%esp
f011eb0d:	68 38 12 13 f0       	push   $0xf0131238
f011eb12:	e8 74 24 fe ff       	call   f0100f8b <cprintf>
f011eb17:	83 c4 10             	add    $0x10,%esp
			break;
f011eb1a:	eb 3f                	jmp    f011eb5b <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011eb1c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eb20:	74 38                	je     f011eb5a <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011eb22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eb25:	8b 00                	mov    (%eax),%eax
f011eb27:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011eb2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eb2d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011eb30:	75 12                	jne    f011eb44 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011eb32:	83 ec 0c             	sub    $0xc,%esp
f011eb35:	68 54 12 13 f0       	push   $0xf0131254
f011eb3a:	e8 4c 24 fe ff       	call   f0100f8b <cprintf>
f011eb3f:	83 c4 10             	add    $0x10,%esp
			break;
f011eb42:	eb 17                	jmp    f011eb5b <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011eb44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb47:	8b 00                	mov    (%eax),%eax
f011eb49:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011eb4c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011eb50:	74 09                	je     f011eb5b <detect_loop_in_FrameInfo_list+0x79>
f011eb52:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eb56:	75 a2                	jne    f011eafa <detect_loop_in_FrameInfo_list+0x18>
f011eb58:	eb 01                	jmp    f011eb5b <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011eb5a:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011eb5b:	83 ec 0c             	sub    $0xc,%esp
f011eb5e:	68 6b 12 13 f0       	push   $0xf013126b
f011eb63:	e8 23 24 fe ff       	call   f0100f8b <cprintf>
f011eb68:	83 c4 10             	add    $0x10,%esp
}
f011eb6b:	90                   	nop
f011eb6c:	c9                   	leave  
f011eb6d:	c3                   	ret    

f011eb6e <scarce_memory>:

void scarce_memory()
{
f011eb6e:	55                   	push   %ebp
f011eb6f:	89 e5                	mov    %esp,%ebp
f011eb71:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011eb74:	a1 50 f2 b1 f0       	mov    0xf0b1f250,%eax
f011eb79:	ba 64 00 00 00       	mov    $0x64,%edx
f011eb7e:	29 c2                	sub    %eax,%edx
f011eb80:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011eb85:	0f af c2             	imul   %edx,%eax
f011eb88:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eb8d:	f7 e2                	mul    %edx
f011eb8f:	89 d0                	mov    %edx,%eax
f011eb91:	c1 e8 05             	shr    $0x5,%eax
f011eb94:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011eb97:	a1 50 f2 b1 f0       	mov    0xf0b1f250,%eax
f011eb9c:	ba 64 00 00 00       	mov    $0x64,%edx
f011eba1:	29 c2                	sub    %eax,%edx
f011eba3:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011eba8:	89 d1                	mov    %edx,%ecx
f011ebaa:	0f af c8             	imul   %eax,%ecx
f011ebad:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ebb2:	f7 e1                	mul    %ecx
f011ebb4:	c1 ea 05             	shr    $0x5,%edx
f011ebb7:	89 d0                	mov    %edx,%eax
f011ebb9:	c1 e0 02             	shl    $0x2,%eax
f011ebbc:	01 d0                	add    %edx,%eax
f011ebbe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ebc5:	01 d0                	add    %edx,%eax
f011ebc7:	c1 e0 02             	shl    $0x2,%eax
f011ebca:	29 c1                	sub    %eax,%ecx
f011ebcc:	89 ca                	mov    %ecx,%edx
f011ebce:	85 d2                	test   %edx,%edx
f011ebd0:	74 03                	je     f011ebd5 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011ebd2:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011ebd5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011ebdc:	83 ec 0c             	sub    $0xc,%esp
f011ebdf:	68 40 f1 b1 f0       	push   $0xf0b1f140
f011ebe4:	e8 15 13 ff ff       	call   f010fefe <acquire_spinlock>
f011ebe9:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011ebec:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f011ebf1:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011ebf4:	8b 15 18 f3 b1 f0    	mov    0xf0b1f318,%edx
f011ebfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ebfd:	29 c2                	sub    %eax,%edx
f011ebff:	89 d0                	mov    %edx,%eax
f011ec01:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011ec04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec07:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011ec0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011ec0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ec14:	eb 12                	jmp    f011ec28 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011ec16:	83 ec 0c             	sub    $0xc,%esp
f011ec19:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011ec1c:	50                   	push   %eax
f011ec1d:	e8 bb 98 fe ff       	call   f01084dd <allocate_frame>
f011ec22:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ec25:	ff 45 f0             	incl   -0x10(%ebp)
f011ec28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec2b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ec2e:	76 e6                	jbe    f011ec16 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011ec30:	83 ec 0c             	sub    $0xc,%esp
f011ec33:	68 40 f1 b1 f0       	push   $0xf0b1f140
f011ec38:	e8 48 13 ff ff       	call   f010ff85 <release_spinlock>
f011ec3d:	83 c4 10             	add    $0x10,%esp

}
f011ec40:	90                   	nop
f011ec41:	c9                   	leave  
f011ec42:	c3                   	ret    

f011ec43 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011ec43:	55                   	push   %ebp
f011ec44:	89 e5                	mov    %esp,%ebp
f011ec46:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011ec49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011ec50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011ec57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011ec5e:	e8 0d d0 fe ff       	call   f010bc70 <get_cpu_proc>
f011ec63:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011ec66:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ec6a:	75 19                	jne    f011ec85 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011ec6c:	68 85 12 13 f0       	push   $0xf0131285
f011ec71:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011ec76:	68 79 01 00 00       	push   $0x179
f011ec7b:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011ec80:	e8 b4 16 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011ec85:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ec89:	0f 85 d6 01 00 00    	jne    f011ee65 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011ec8f:	83 ec 0c             	sub    $0xc,%esp
f011ec92:	68 80 f0 71 f0       	push   $0xf071f080
f011ec97:	e8 62 12 ff ff       	call   f010fefe <acquire_spinlock>
f011ec9c:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ec9f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011eca6:	e9 d2 00 00 00       	jmp    f011ed7d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ecab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ecb2:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ecb7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ecba:	c1 e2 04             	shl    $0x4,%edx
f011ecbd:	01 d0                	add    %edx,%eax
f011ecbf:	8b 00                	mov    (%eax),%eax
f011ecc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ecc4:	eb 7c                	jmp    f011ed42 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011ecc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ecc9:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eccf:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ecd2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ecd5:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ecdb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ecde:	0f af c2             	imul   %edx,%eax
f011ece1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ece6:	f7 e2                	mul    %edx
f011ece8:	89 d0                	mov    %edx,%eax
f011ecea:	c1 e8 05             	shr    $0x5,%eax
f011eced:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ecf0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ecf3:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ecf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ecfc:	89 d1                	mov    %edx,%ecx
f011ecfe:	0f af c8             	imul   %eax,%ecx
f011ed01:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ed06:	f7 e1                	mul    %ecx
f011ed08:	c1 ea 05             	shr    $0x5,%edx
f011ed0b:	89 d0                	mov    %edx,%eax
f011ed0d:	c1 e0 02             	shl    $0x2,%eax
f011ed10:	01 d0                	add    %edx,%eax
f011ed12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed19:	01 d0                	add    %edx,%eax
f011ed1b:	c1 e0 02             	shl    $0x2,%eax
f011ed1e:	29 c1                	sub    %eax,%ecx
f011ed20:	89 ca                	mov    %ecx,%edx
f011ed22:	85 d2                	test   %edx,%edx
f011ed24:	74 03                	je     f011ed29 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011ed26:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011ed29:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ed2c:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ed2f:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ed34:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ed37:	c1 e2 04             	shl    $0x4,%edx
f011ed3a:	01 d0                	add    %edx,%eax
f011ed3c:	8b 40 08             	mov    0x8(%eax),%eax
f011ed3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ed42:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ed47:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ed4a:	c1 e2 04             	shl    $0x4,%edx
f011ed4d:	01 d0                	add    %edx,%eax
f011ed4f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ed53:	74 08                	je     f011ed5d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011ed55:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ed58:	8b 52 08             	mov    0x8(%edx),%edx
f011ed5b:	eb 05                	jmp    f011ed62 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011ed5d:	ba 00 00 00 00       	mov    $0x0,%edx
f011ed62:	89 50 08             	mov    %edx,0x8(%eax)
f011ed65:	8b 40 08             	mov    0x8(%eax),%eax
f011ed68:	85 c0                	test   %eax,%eax
f011ed6a:	0f 85 56 ff ff ff    	jne    f011ecc6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011ed70:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ed74:	0f 85 4c ff ff ff    	jne    f011ecc6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ed7a:	ff 45 e8             	incl   -0x18(%ebp)
f011ed7d:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011ed82:	0f b6 c0             	movzbl %al,%eax
f011ed85:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ed88:	0f 8f 1d ff ff ff    	jg     f011ecab <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011ed8e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ed95:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f011ed9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ed9d:	eb 1a                	jmp    f011edb9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011ed9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eda2:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eda8:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011edab:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011edae:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011edb1:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011edb6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011edb9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011edbd:	74 08                	je     f011edc7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011edbf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011edc2:	8b 40 08             	mov    0x8(%eax),%eax
f011edc5:	eb 05                	jmp    f011edcc <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011edc7:	b8 00 00 00 00       	mov    $0x0,%eax
f011edcc:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f011edd1:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011edd6:	85 c0                	test   %eax,%eax
f011edd8:	75 c5                	jne    f011ed9f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011edda:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011edde:	75 bf                	jne    f011ed9f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ede0:	83 ec 0c             	sub    $0xc,%esp
f011ede3:	68 80 f0 71 f0       	push   $0xf071f080
f011ede8:	e8 98 11 ff ff       	call   f010ff85 <release_spinlock>
f011eded:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011edf0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011edf4:	0f 84 d4 00 00 00    	je     f011eece <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011edfa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011edfd:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ee03:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ee06:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee09:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee0f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ee12:	0f af c2             	imul   %edx,%eax
f011ee15:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ee1a:	f7 e2                	mul    %edx
f011ee1c:	89 d0                	mov    %edx,%eax
f011ee1e:	c1 e8 05             	shr    $0x5,%eax
f011ee21:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ee24:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee27:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee2d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ee30:	89 d1                	mov    %edx,%ecx
f011ee32:	0f af c8             	imul   %eax,%ecx
f011ee35:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ee3a:	f7 e1                	mul    %ecx
f011ee3c:	c1 ea 05             	shr    $0x5,%edx
f011ee3f:	89 d0                	mov    %edx,%eax
f011ee41:	c1 e0 02             	shl    $0x2,%eax
f011ee44:	01 d0                	add    %edx,%eax
f011ee46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ee4d:	01 d0                	add    %edx,%eax
f011ee4f:	c1 e0 02             	shl    $0x2,%eax
f011ee52:	29 c1                	sub    %eax,%ecx
f011ee54:	89 ca                	mov    %ecx,%edx
f011ee56:	85 d2                	test   %edx,%edx
f011ee58:	74 03                	je     f011ee5d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011ee5a:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ee5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ee60:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ee63:	eb 69                	jmp    f011eece <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ee65:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee68:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ee6e:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ee71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee74:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ee7d:	0f af c2             	imul   %edx,%eax
f011ee80:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ee85:	f7 e2                	mul    %edx
f011ee87:	89 d0                	mov    %edx,%eax
f011ee89:	c1 e8 05             	shr    $0x5,%eax
f011ee8c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ee8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee92:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee98:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ee9b:	89 d1                	mov    %edx,%ecx
f011ee9d:	0f af c8             	imul   %eax,%ecx
f011eea0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eea5:	f7 e1                	mul    %ecx
f011eea7:	c1 ea 05             	shr    $0x5,%edx
f011eeaa:	89 d0                	mov    %edx,%eax
f011eeac:	c1 e0 02             	shl    $0x2,%eax
f011eeaf:	01 d0                	add    %edx,%eax
f011eeb1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011eeb8:	01 d0                	add    %edx,%eax
f011eeba:	c1 e0 02             	shl    $0x2,%eax
f011eebd:	29 c1                	sub    %eax,%ecx
f011eebf:	89 ca                	mov    %ecx,%edx
f011eec1:	85 d2                	test   %edx,%edx
f011eec3:	74 03                	je     f011eec8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011eec5:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011eec8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011eecb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011eece:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011eed1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eed4:	01 c2                	add    %eax,%edx
f011eed6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011eed9:	01 d0                	add    %edx,%eax
}
f011eedb:	c9                   	leave  
f011eedc:	c3                   	ret    

f011eedd <schenv>:


void schenv()
{
f011eedd:	55                   	push   %ebp
f011eede:	89 e5                	mov    %esp,%ebp
f011eee0:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011eee3:	c6 05 80 f8 f1 f0 00 	movb   $0x0,0xf0f1f880
	__ne = NULL;
f011eeea:	c7 05 6c f5 b1 f0 00 	movl   $0x0,0xf0b1f56c
f011eef1:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011eef4:	83 ec 0c             	sub    $0xc,%esp
f011eef7:	68 80 f0 71 f0       	push   $0xf071f080
f011eefc:	e8 fd 0f ff ff       	call   f010fefe <acquire_spinlock>
f011ef01:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ef04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ef0b:	eb 3f                	jmp    f011ef4c <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011ef0d:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ef12:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ef15:	c1 e2 04             	shl    $0x4,%edx
f011ef18:	01 d0                	add    %edx,%eax
f011ef1a:	83 ec 0c             	sub    $0xc,%esp
f011ef1d:	50                   	push   %eax
f011ef1e:	e8 5d 62 fe ff       	call   f0105180 <queue_size>
f011ef23:	83 c4 10             	add    $0x10,%esp
f011ef26:	85 c0                	test   %eax,%eax
f011ef28:	74 1f                	je     f011ef49 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011ef2a:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ef2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ef32:	c1 e2 04             	shl    $0x4,%edx
f011ef35:	01 d0                	add    %edx,%eax
f011ef37:	8b 40 04             	mov    0x4(%eax),%eax
f011ef3a:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
				__nl = i;
f011ef3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ef42:	a2 80 f8 f1 f0       	mov    %al,0xf0f1f880
				break;
f011ef47:	eb 10                	jmp    f011ef59 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ef49:	ff 45 f4             	incl   -0xc(%ebp)
f011ef4c:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011ef51:	0f b6 c0             	movzbl %al,%eax
f011ef54:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ef57:	7f b4                	jg     f011ef0d <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011ef59:	83 ec 0c             	sub    $0xc,%esp
f011ef5c:	68 80 f0 71 f0       	push   $0xf071f080
f011ef61:	e8 1f 10 ff ff       	call   f010ff85 <release_spinlock>
f011ef66:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011ef69:	e8 02 cd fe ff       	call   f010bc70 <get_cpu_proc>
f011ef6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011ef71:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ef75:	0f 84 82 00 00 00    	je     f011effd <schenv+0x120>
	{
		if (__ne != NULL)
f011ef7b:	a1 6c f5 b1 f0       	mov    0xf0b1f56c,%eax
f011ef80:	85 c0                	test   %eax,%eax
f011ef82:	74 49                	je     f011efcd <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011ef84:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011ef89:	0f b6 c0             	movzbl %al,%eax
f011ef8c:	8d 50 01             	lea    0x1(%eax),%edx
f011ef8f:	a0 80 f8 f1 f0       	mov    0xf0f1f880,%al
f011ef94:	0f b6 c0             	movzbl %al,%eax
f011ef97:	39 c2                	cmp    %eax,%edx
f011ef99:	7d 62                	jge    f011effd <schenv+0x120>
			{
				__ne = cur_env;
f011ef9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ef9e:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011efa3:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011efa8:	0f b6 c0             	movzbl %al,%eax
f011efab:	8a 15 e4 f7 f1 f0    	mov    0xf0f1f7e4,%dl
f011efb1:	0f b6 d2             	movzbl %dl,%edx
f011efb4:	4a                   	dec    %edx
f011efb5:	39 d0                	cmp    %edx,%eax
f011efb7:	7d 08                	jge    f011efc1 <schenv+0xe4>
f011efb9:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011efbe:	40                   	inc    %eax
f011efbf:	eb 05                	jmp    f011efc6 <schenv+0xe9>
f011efc1:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011efc6:	a2 80 f8 f1 f0       	mov    %al,0xf0f1f880
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011efcb:	eb 30                	jmp    f011effd <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011efcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011efd0:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011efd5:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011efda:	0f b6 c0             	movzbl %al,%eax
f011efdd:	8a 15 e4 f7 f1 f0    	mov    0xf0f1f7e4,%dl
f011efe3:	0f b6 d2             	movzbl %dl,%edx
f011efe6:	4a                   	dec    %edx
f011efe7:	39 d0                	cmp    %edx,%eax
f011efe9:	7d 08                	jge    f011eff3 <schenv+0x116>
f011efeb:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011eff0:	40                   	inc    %eax
f011eff1:	eb 05                	jmp    f011eff8 <schenv+0x11b>
f011eff3:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011eff8:	a2 80 f8 f1 f0       	mov    %al,0xf0f1f880
		}
	}
}
f011effd:	90                   	nop
f011effe:	c9                   	leave  
f011efff:	c3                   	ret    

f011f000 <chksch>:

void chksch(uint8 onoff)
{
f011f000:	55                   	push   %ebp
f011f001:	89 e5                	mov    %esp,%ebp
f011f003:	83 ec 18             	sub    $0x18,%esp
f011f006:	8b 45 08             	mov    0x8(%ebp),%eax
f011f009:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f00c:	e8 aa 79 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f011:	85 c0                	test   %eax,%eax
f011f013:	74 48                	je     f011f05d <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011f015:	e8 11 79 fe ff       	call   f010692b <get_load_average>
f011f01a:	a3 08 f8 f1 f0       	mov    %eax,0xf0f1f808
f011f01f:	a1 08 f8 f1 f0       	mov    0xf0f1f808,%eax
f011f024:	a3 1c f3 b1 f0       	mov    %eax,0xf0b1f31c
		acquire_spinlock(&ProcessQueues.qlock);
f011f029:	83 ec 0c             	sub    $0xc,%esp
f011f02c:	68 80 f0 71 f0       	push   $0xf071f080
f011f031:	e8 c8 0e ff ff       	call   f010fefe <acquire_spinlock>
f011f036:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011f039:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011f03e:	a3 c0 f1 b1 f0       	mov    %eax,0xf0b1f1c0
		}
		release_spinlock(&ProcessQueues.qlock);
f011f043:	83 ec 0c             	sub    $0xc,%esp
f011f046:	68 80 f0 71 f0       	push   $0xf071f080
f011f04b:	e8 35 0f ff ff       	call   f010ff85 <release_spinlock>
f011f050:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011f053:	c7 05 7c f5 b1 f0 01 	movl   $0x1,0xf0b1f57c
f011f05a:	00 00 00 
	}
	__chkstatus = onoff;
f011f05d:	8a 45 f4             	mov    -0xc(%ebp),%al
f011f060:	a2 68 f5 b1 f0       	mov    %al,0xf0b1f568
}
f011f065:	90                   	nop
f011f066:	c9                   	leave  
f011f067:	c3                   	ret    

f011f068 <chk1>:
void chk1()
{
f011f068:	55                   	push   %ebp
f011f069:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011f06b:	90                   	nop
f011f06c:	5d                   	pop    %ebp
f011f06d:	c3                   	ret    

f011f06e <chk2>:
void chk2(struct Env* __se)
{
f011f06e:	55                   	push   %ebp
f011f06f:	89 e5                	mov    %esp,%ebp
f011f071:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011f074:	a0 68 f5 b1 f0       	mov    0xf0b1f568,%al
f011f079:	84 c0                	test   %al,%al
f011f07b:	0f 84 59 03 00 00    	je     f011f3da <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f081:	e8 35 79 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f086:	85 c0                	test   %eax,%eax
f011f088:	0f 84 4d 03 00 00    	je     f011f3db <chk2+0x36d>
	{
		__nla = get_load_average();
f011f08e:	e8 98 78 fe ff       	call   f010692b <get_load_average>
f011f093:	a3 54 f2 b1 f0       	mov    %eax,0xf0b1f254
		acquire_spinlock(&ProcessQueues.qlock);
f011f098:	83 ec 0c             	sub    $0xc,%esp
f011f09b:	68 80 f0 71 f0       	push   $0xf071f080
f011f0a0:	e8 59 0e ff ff       	call   f010fefe <acquire_spinlock>
f011f0a5:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011f0a8:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011f0ad:	a3 70 f5 b1 f0       	mov    %eax,0xf0b1f570
		}
		release_spinlock(&ProcessQueues.qlock);
f011f0b2:	83 ec 0c             	sub    $0xc,%esp
f011f0b5:	68 80 f0 71 f0       	push   $0xf071f080
f011f0ba:	e8 c6 0e ff ff       	call   f010ff85 <release_spinlock>
f011f0bf:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011f0c2:	a1 7c f5 b1 f0       	mov    0xf0b1f57c,%eax
f011f0c7:	85 c0                	test   %eax,%eax
f011f0c9:	74 72                	je     f011f13d <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011f0cb:	83 ec 0c             	sub    $0xc,%esp
f011f0ce:	68 80 f0 71 f0       	push   $0xf071f080
f011f0d3:	e8 26 0e ff ff       	call   f010fefe <acquire_spinlock>
f011f0d8:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011f0db:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f0df:	0f 95 c0             	setne  %al
f011f0e2:	0f b6 c0             	movzbl %al,%eax
f011f0e5:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f0ea:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011f0ef:	0f b6 c0             	movzbl %al,%eax
f011f0f2:	48                   	dec    %eax
f011f0f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f0f6:	eb 20                	jmp    f011f118 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f0f8:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011f0fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f100:	c1 e2 04             	shl    $0x4,%edx
f011f103:	01 d0                	add    %edx,%eax
f011f105:	8b 40 0c             	mov    0xc(%eax),%eax
f011f108:	8b 15 34 f7 b1 f0    	mov    0xf0b1f734,%edx
f011f10e:	01 d0                	add    %edx,%eax
f011f110:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f115:	ff 4d f4             	decl   -0xc(%ebp)
f011f118:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f11c:	79 da                	jns    f011f0f8 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011f11e:	c7 05 7c f5 b1 f0 00 	movl   $0x0,0xf0b1f57c
f011f125:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011f128:	83 ec 0c             	sub    $0xc,%esp
f011f12b:	68 80 f0 71 f0       	push   $0xf071f080
f011f130:	e8 50 0e ff ff       	call   f010ff85 <release_spinlock>
f011f135:	83 c4 10             	add    $0x10,%esp
f011f138:	e9 91 02 00 00       	jmp    f011f3ce <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011f13d:	8b 15 c0 f1 b1 f0    	mov    0xf0b1f1c0,%edx
f011f143:	a1 70 f5 b1 f0       	mov    0xf0b1f570,%eax
f011f148:	39 c2                	cmp    %eax,%edx
f011f14a:	74 63                	je     f011f1af <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011f14c:	83 ec 0c             	sub    $0xc,%esp
f011f14f:	68 80 f0 71 f0       	push   $0xf071f080
f011f154:	e8 a5 0d ff ff       	call   f010fefe <acquire_spinlock>
f011f159:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011f15c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f160:	0f 95 c0             	setne  %al
f011f163:	0f b6 c0             	movzbl %al,%eax
f011f166:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f16b:	a0 e4 f7 f1 f0       	mov    0xf0f1f7e4,%al
f011f170:	0f b6 c0             	movzbl %al,%eax
f011f173:	48                   	dec    %eax
f011f174:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f177:	eb 20                	jmp    f011f199 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f179:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011f17e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f181:	c1 e2 04             	shl    $0x4,%edx
f011f184:	01 d0                	add    %edx,%eax
f011f186:	8b 40 0c             	mov    0xc(%eax),%eax
f011f189:	8b 15 34 f7 b1 f0    	mov    0xf0b1f734,%edx
f011f18f:	01 d0                	add    %edx,%eax
f011f191:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f196:	ff 4d f0             	decl   -0x10(%ebp)
f011f199:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f19d:	79 da                	jns    f011f179 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011f19f:	83 ec 0c             	sub    $0xc,%esp
f011f1a2:	68 80 f0 71 f0       	push   $0xf071f080
f011f1a7:	e8 d9 0d ff ff       	call   f010ff85 <release_spinlock>
f011f1ac:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011f1af:	e8 10 77 fe ff       	call   f01068c4 <timer_ticks>
f011f1b4:	6a 00                	push   $0x0
f011f1b6:	68 e8 03 00 00       	push   $0x3e8
f011f1bb:	52                   	push   %edx
f011f1bc:	50                   	push   %eax
f011f1bd:	e8 be 31 00 00       	call   f0122380 <__moddi3>
f011f1c2:	83 c4 10             	add    $0x10,%esp
f011f1c5:	09 d0                	or     %edx,%eax
f011f1c7:	85 c0                	test   %eax,%eax
f011f1c9:	75 32                	jne    f011f1fd <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011f1cb:	8b 15 1c f3 b1 f0    	mov    0xf0b1f31c,%edx
f011f1d1:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f1d6:	39 c2                	cmp    %eax,%edx
f011f1d8:	75 19                	jne    f011f1f3 <chk2+0x185>
f011f1da:	68 95 12 13 f0       	push   $0xf0131295
f011f1df:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f1e4:	68 35 02 00 00       	push   $0x235
f011f1e9:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f1ee:	e8 d6 11 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011f1f3:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f1f8:	a3 1c f3 b1 f0       	mov    %eax,0xf0b1f31c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f1fd:	e8 c2 76 fe ff       	call   f01068c4 <timer_ticks>
f011f202:	6a 00                	push   $0x0
f011f204:	6a 64                	push   $0x64
f011f206:	52                   	push   %edx
f011f207:	50                   	push   %eax
f011f208:	e8 73 31 00 00       	call   f0122380 <__moddi3>
f011f20d:	83 c4 10             	add    $0x10,%esp
f011f210:	09 d0                	or     %edx,%eax
f011f212:	85 c0                	test   %eax,%eax
f011f214:	0f 85 b4 01 00 00    	jne    f011f3ce <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f21a:	8b 0d 08 f8 f1 f0    	mov    0xf0f1f808,%ecx
f011f220:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f225:	f7 e9                	imul   %ecx
f011f227:	c1 fa 05             	sar    $0x5,%edx
f011f22a:	89 c8                	mov    %ecx,%eax
f011f22c:	c1 f8 1f             	sar    $0x1f,%eax
f011f22f:	29 c2                	sub    %eax,%edx
f011f231:	89 d0                	mov    %edx,%eax
f011f233:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f236:	8b 0d 08 f8 f1 f0    	mov    0xf0f1f808,%ecx
f011f23c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f241:	f7 e9                	imul   %ecx
f011f243:	c1 fa 05             	sar    $0x5,%edx
f011f246:	89 c8                	mov    %ecx,%eax
f011f248:	c1 f8 1f             	sar    $0x1f,%eax
f011f24b:	29 c2                	sub    %eax,%edx
f011f24d:	89 d0                	mov    %edx,%eax
f011f24f:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f252:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f255:	89 d0                	mov    %edx,%eax
f011f257:	c1 e0 02             	shl    $0x2,%eax
f011f25a:	01 d0                	add    %edx,%eax
f011f25c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f263:	01 d0                	add    %edx,%eax
f011f265:	c1 e0 02             	shl    $0x2,%eax
f011f268:	29 c1                	sub    %eax,%ecx
f011f26a:	89 c8                	mov    %ecx,%eax
f011f26c:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f26f:	8b 0d 54 f2 b1 f0    	mov    0xf0b1f254,%ecx
f011f275:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f27a:	f7 e9                	imul   %ecx
f011f27c:	c1 fa 05             	sar    $0x5,%edx
f011f27f:	89 c8                	mov    %ecx,%eax
f011f281:	c1 f8 1f             	sar    $0x1f,%eax
f011f284:	29 c2                	sub    %eax,%edx
f011f286:	89 d0                	mov    %edx,%eax
f011f288:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f28b:	8b 0d 54 f2 b1 f0    	mov    0xf0b1f254,%ecx
f011f291:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f296:	f7 e9                	imul   %ecx
f011f298:	c1 fa 05             	sar    $0x5,%edx
f011f29b:	89 c8                	mov    %ecx,%eax
f011f29d:	c1 f8 1f             	sar    $0x1f,%eax
f011f2a0:	29 c2                	sub    %eax,%edx
f011f2a2:	89 d0                	mov    %edx,%eax
f011f2a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f2a7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f2aa:	89 d0                	mov    %edx,%eax
f011f2ac:	c1 e0 02             	shl    $0x2,%eax
f011f2af:	01 d0                	add    %edx,%eax
f011f2b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f2b8:	01 d0                	add    %edx,%eax
f011f2ba:	c1 e0 02             	shl    $0x2,%eax
f011f2bd:	29 c1                	sub    %eax,%ecx
f011f2bf:	89 c8                	mov    %ecx,%eax
f011f2c1:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f2c4:	8b 15 70 f5 b1 f0    	mov    0xf0b1f570,%edx
f011f2ca:	a1 c0 f1 b1 f0       	mov    0xf0b1f1c0,%eax
f011f2cf:	39 c2                	cmp    %eax,%edx
f011f2d1:	0f 85 ed 00 00 00    	jne    f011f3c4 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f2d7:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f2dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f2df:	7e 5b                	jle    f011f33c <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f2e1:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f2e6:	83 ec 08             	sub    $0x8,%esp
f011f2e9:	ff 75 e0             	pushl  -0x20(%ebp)
f011f2ec:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f2ef:	ff 75 e8             	pushl  -0x18(%ebp)
f011f2f2:	ff 75 ec             	pushl  -0x14(%ebp)
f011f2f5:	50                   	push   %eax
f011f2f6:	68 a8 12 13 f0       	push   $0xf01312a8
f011f2fb:	e8 8b 1c fe ff       	call   f0100f8b <cprintf>
f011f300:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f303:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f306:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f309:	0f 8f b5 00 00 00    	jg     f011f3c4 <chk2+0x356>
f011f30f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f312:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f315:	75 0c                	jne    f011f323 <chk2+0x2b5>
f011f317:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f31a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f31d:	0f 8d a1 00 00 00    	jge    f011f3c4 <chk2+0x356>
f011f323:	68 f0 12 13 f0       	push   $0xf01312f0
f011f328:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f32d:	68 4a 02 00 00       	push   $0x24a
f011f332:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f337:	e8 8d 10 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f33c:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f341:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f344:	7d 53                	jge    f011f399 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f346:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f34b:	83 ec 08             	sub    $0x8,%esp
f011f34e:	ff 75 e0             	pushl  -0x20(%ebp)
f011f351:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f354:	ff 75 e8             	pushl  -0x18(%ebp)
f011f357:	ff 75 ec             	pushl  -0x14(%ebp)
f011f35a:	50                   	push   %eax
f011f35b:	68 30 13 13 f0       	push   $0xf0131330
f011f360:	e8 26 1c fe ff       	call   f0100f8b <cprintf>
f011f365:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f368:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f36b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f36e:	7c 54                	jl     f011f3c4 <chk2+0x356>
f011f370:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f373:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f376:	75 08                	jne    f011f380 <chk2+0x312>
f011f378:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f37b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f37e:	7e 44                	jle    f011f3c4 <chk2+0x356>
f011f380:	68 78 13 13 f0       	push   $0xf0131378
f011f385:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f38a:	68 50 02 00 00       	push   $0x250
f011f38f:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f394:	e8 30 10 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f399:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f39e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f3a1:	75 21                	jne    f011f3c4 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f3a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f3a6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f3a9:	74 19                	je     f011f3c4 <chk2+0x356>
f011f3ab:	68 b8 13 13 f0       	push   $0xf01313b8
f011f3b0:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f3b5:	68 54 02 00 00       	push   $0x254
f011f3ba:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f3bf:	e8 05 10 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f3c4:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f3c9:	a3 08 f8 f1 f0       	mov    %eax,0xf0f1f808
			}
		}
		__pnexit = __nnexit;
f011f3ce:	a1 70 f5 b1 f0       	mov    0xf0b1f570,%eax
f011f3d3:	a3 c0 f1 b1 f0       	mov    %eax,0xf0b1f1c0
f011f3d8:	eb 01                	jmp    f011f3db <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f3da:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f3db:	c9                   	leave  
f011f3dc:	c3                   	ret    

f011f3dd <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f3dd:	55                   	push   %ebp
f011f3de:	89 e5                	mov    %esp,%ebp
f011f3e0:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f3e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f3ea:	eb 40                	jmp    f011f42c <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f3ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f3ef:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f3f5:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011f3fa:	83 ec 08             	sub    $0x8,%esp
f011f3fd:	52                   	push   %edx
f011f3fe:	50                   	push   %eax
f011f3ff:	e8 af 01 00 00       	call   f011f5b3 <check_va2pa>
f011f404:	83 c4 10             	add    $0x10,%esp
f011f407:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f40a:	74 19                	je     f011f425 <check_boot_pgdir+0x48>
f011f40c:	68 cc 13 13 f0       	push   $0xf01313cc
f011f411:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f416:	68 9b 02 00 00       	push   $0x29b
f011f41b:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f420:	e8 14 0f fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f425:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f42c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f42f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f435:	a1 40 f7 f1 f0       	mov    0xf0f1f740,%eax
f011f43a:	39 c2                	cmp    %eax,%edx
f011f43c:	72 ae                	jb     f011f3ec <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f43e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f445:	e9 81 00 00 00       	jmp    f011f4cb <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f44a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f44d:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f452:	85 c0                	test   %eax,%eax
f011f454:	74 6d                	je     f011f4c3 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f456:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f459:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f45f:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011f464:	83 ec 08             	sub    $0x8,%esp
f011f467:	52                   	push   %edx
f011f468:	50                   	push   %eax
f011f469:	e8 45 01 00 00       	call   f011f5b3 <check_va2pa>
f011f46e:	83 c4 10             	add    $0x10,%esp
f011f471:	c7 45 f0 00 80 17 f0 	movl   $0xf0178000,-0x10(%ebp)
f011f478:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f47f:	77 17                	ja     f011f498 <check_boot_pgdir+0xbb>
f011f481:	ff 75 f0             	pushl  -0x10(%ebp)
f011f484:	68 04 14 13 f0       	push   $0xf0131404
f011f489:	68 a9 02 00 00       	push   $0x2a9
f011f48e:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f493:	e8 a1 0e fe ff       	call   f0100339 <_panic>
f011f498:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f49b:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f4a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4a4:	01 ca                	add    %ecx,%edx
f011f4a6:	39 d0                	cmp    %edx,%eax
f011f4a8:	74 1a                	je     f011f4c4 <check_boot_pgdir+0xe7>
f011f4aa:	68 38 14 13 f0       	push   $0xf0131438
f011f4af:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f4b4:	68 a9 02 00 00       	push   $0x2a9
f011f4b9:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f4be:	e8 76 0e fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f4c3:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f4c4:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f4cb:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f4d2:	0f 86 72 ff ff ff    	jbe    f011f44a <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f4d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f4df:	e9 af 00 00 00       	jmp    f011f593 <check_boot_pgdir+0x1b6>
		switch (i) {
f011f4e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f4e7:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f4ec:	74 11                	je     f011f4ff <check_boot_pgdir+0x122>
f011f4ee:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f4f3:	72 36                	jb     f011f52b <check_boot_pgdir+0x14e>
f011f4f5:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f4fa:	83 f8 02             	cmp    $0x2,%eax
f011f4fd:	77 2c                	ja     f011f52b <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f4ff:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011f504:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f507:	c1 e2 02             	shl    $0x2,%edx
f011f50a:	01 d0                	add    %edx,%eax
f011f50c:	8b 00                	mov    (%eax),%eax
f011f50e:	85 c0                	test   %eax,%eax
f011f510:	75 7a                	jne    f011f58c <check_boot_pgdir+0x1af>
f011f512:	68 be 14 13 f0       	push   $0xf01314be
f011f517:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f51c:	68 b4 02 00 00       	push   $0x2b4
f011f521:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f526:	e8 0e 0e fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f52b:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f532:	76 2c                	jbe    f011f560 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f534:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011f539:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f53c:	c1 e2 02             	shl    $0x2,%edx
f011f53f:	01 d0                	add    %edx,%eax
f011f541:	8b 00                	mov    (%eax),%eax
f011f543:	85 c0                	test   %eax,%eax
f011f545:	75 48                	jne    f011f58f <check_boot_pgdir+0x1b2>
f011f547:	68 be 14 13 f0       	push   $0xf01314be
f011f54c:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f551:	68 b8 02 00 00       	push   $0x2b8
f011f556:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f55b:	e8 d9 0d fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f560:	a1 44 f7 f1 f0       	mov    0xf0f1f744,%eax
f011f565:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f568:	c1 e2 02             	shl    $0x2,%edx
f011f56b:	01 d0                	add    %edx,%eax
f011f56d:	8b 00                	mov    (%eax),%eax
f011f56f:	85 c0                	test   %eax,%eax
f011f571:	74 1c                	je     f011f58f <check_boot_pgdir+0x1b2>
f011f573:	68 d4 14 13 f0       	push   $0xf01314d4
f011f578:	68 d3 0e 13 f0       	push   $0xf0130ed3
f011f57d:	68 ba 02 00 00       	push   $0x2ba
f011f582:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f587:	e8 ad 0d fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f58c:	90                   	nop
f011f58d:	eb 01                	jmp    f011f590 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f58f:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f590:	ff 45 f4             	incl   -0xc(%ebp)
f011f593:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f59a:	0f 86 44 ff ff ff    	jbe    f011f4e4 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f5a0:	83 ec 0c             	sub    $0xc,%esp
f011f5a3:	68 f0 14 13 f0       	push   $0xf01314f0
f011f5a8:	e8 de 19 fe ff       	call   f0100f8b <cprintf>
f011f5ad:	83 c4 10             	add    $0x10,%esp
}
f011f5b0:	90                   	nop
f011f5b1:	c9                   	leave  
f011f5b2:	c3                   	ret    

f011f5b3 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f5b3:	55                   	push   %ebp
f011f5b4:	89 e5                	mov    %esp,%ebp
f011f5b6:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f5b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5bc:	c1 e8 16             	shr    $0x16,%eax
f011f5bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f5c6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5c9:	01 d0                	add    %edx,%eax
f011f5cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f5ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5d1:	8b 00                	mov    (%eax),%eax
f011f5d3:	83 e0 01             	and    $0x1,%eax
f011f5d6:	85 c0                	test   %eax,%eax
f011f5d8:	75 0a                	jne    f011f5e4 <check_va2pa+0x31>
		return ~0;
f011f5da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f5df:	e9 87 00 00 00       	jmp    f011f66b <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f5e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5e7:	8b 00                	mov    (%eax),%eax
f011f5e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f5ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f5f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f5f4:	c1 e8 0c             	shr    $0xc,%eax
f011f5f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f5fa:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011f5ff:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f602:	72 17                	jb     f011f61b <check_va2pa+0x68>
f011f604:	ff 75 f0             	pushl  -0x10(%ebp)
f011f607:	68 14 15 13 f0       	push   $0xf0131514
f011f60c:	68 d0 02 00 00       	push   $0x2d0
f011f611:	68 1b 0f 13 f0       	push   $0xf0130f1b
f011f616:	e8 1e 0d fe ff       	call   f0100339 <_panic>
f011f61b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f61e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f623:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f626:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f629:	c1 e8 0c             	shr    $0xc,%eax
f011f62c:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f631:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f638:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f63b:	01 d0                	add    %edx,%eax
f011f63d:	8b 00                	mov    (%eax),%eax
f011f63f:	83 e0 01             	and    $0x1,%eax
f011f642:	85 c0                	test   %eax,%eax
f011f644:	75 07                	jne    f011f64d <check_va2pa+0x9a>
		return ~0;
f011f646:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f64b:	eb 1e                	jmp    f011f66b <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f64d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f650:	c1 e8 0c             	shr    $0xc,%eax
f011f653:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f658:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f65f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f662:	01 d0                	add    %edx,%eax
f011f664:	8b 00                	mov    (%eax),%eax
f011f666:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f66b:	c9                   	leave  
f011f66c:	c3                   	ret    

f011f66d <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f66d:	55                   	push   %ebp
f011f66e:	89 e5                	mov    %esp,%ebp
f011f670:	53                   	push   %ebx
f011f671:	83 ec 14             	sub    $0x14,%esp
f011f674:	8b 45 10             	mov    0x10(%ebp),%eax
f011f677:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f67a:	8b 45 14             	mov    0x14(%ebp),%eax
f011f67d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f680:	8b 45 18             	mov    0x18(%ebp),%eax
f011f683:	ba 00 00 00 00       	mov    $0x0,%edx
f011f688:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f68b:	77 55                	ja     f011f6e2 <printnum+0x75>
f011f68d:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f690:	72 05                	jb     f011f697 <printnum+0x2a>
f011f692:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f695:	77 4b                	ja     f011f6e2 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f697:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f69a:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f69d:	8b 45 18             	mov    0x18(%ebp),%eax
f011f6a0:	ba 00 00 00 00       	mov    $0x0,%edx
f011f6a5:	52                   	push   %edx
f011f6a6:	50                   	push   %eax
f011f6a7:	ff 75 f4             	pushl  -0xc(%ebp)
f011f6aa:	ff 75 f0             	pushl  -0x10(%ebp)
f011f6ad:	e8 66 2e 00 00       	call   f0122518 <__udivdi3>
f011f6b2:	83 c4 10             	add    $0x10,%esp
f011f6b5:	83 ec 04             	sub    $0x4,%esp
f011f6b8:	ff 75 20             	pushl  0x20(%ebp)
f011f6bb:	53                   	push   %ebx
f011f6bc:	ff 75 18             	pushl  0x18(%ebp)
f011f6bf:	52                   	push   %edx
f011f6c0:	50                   	push   %eax
f011f6c1:	ff 75 0c             	pushl  0xc(%ebp)
f011f6c4:	ff 75 08             	pushl  0x8(%ebp)
f011f6c7:	e8 a1 ff ff ff       	call   f011f66d <printnum>
f011f6cc:	83 c4 20             	add    $0x20,%esp
f011f6cf:	eb 1a                	jmp    f011f6eb <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f6d1:	83 ec 08             	sub    $0x8,%esp
f011f6d4:	ff 75 0c             	pushl  0xc(%ebp)
f011f6d7:	ff 75 20             	pushl  0x20(%ebp)
f011f6da:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6dd:	ff d0                	call   *%eax
f011f6df:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f6e2:	ff 4d 1c             	decl   0x1c(%ebp)
f011f6e5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f6e9:	7f e6                	jg     f011f6d1 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f6eb:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f6ee:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f6f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f6f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f6f9:	53                   	push   %ebx
f011f6fa:	51                   	push   %ecx
f011f6fb:	52                   	push   %edx
f011f6fc:	50                   	push   %eax
f011f6fd:	e8 26 2f 00 00       	call   f0122628 <__umoddi3>
f011f702:	83 c4 10             	add    $0x10,%esp
f011f705:	05 74 17 13 f0       	add    $0xf0131774,%eax
f011f70a:	8a 00                	mov    (%eax),%al
f011f70c:	0f be c0             	movsbl %al,%eax
f011f70f:	83 ec 08             	sub    $0x8,%esp
f011f712:	ff 75 0c             	pushl  0xc(%ebp)
f011f715:	50                   	push   %eax
f011f716:	8b 45 08             	mov    0x8(%ebp),%eax
f011f719:	ff d0                	call   *%eax
f011f71b:	83 c4 10             	add    $0x10,%esp
}
f011f71e:	90                   	nop
f011f71f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f722:	c9                   	leave  
f011f723:	c3                   	ret    

f011f724 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f724:	55                   	push   %ebp
f011f725:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f727:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f72b:	7e 1c                	jle    f011f749 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f72d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f730:	8b 00                	mov    (%eax),%eax
f011f732:	8d 50 08             	lea    0x8(%eax),%edx
f011f735:	8b 45 08             	mov    0x8(%ebp),%eax
f011f738:	89 10                	mov    %edx,(%eax)
f011f73a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f73d:	8b 00                	mov    (%eax),%eax
f011f73f:	83 e8 08             	sub    $0x8,%eax
f011f742:	8b 50 04             	mov    0x4(%eax),%edx
f011f745:	8b 00                	mov    (%eax),%eax
f011f747:	eb 40                	jmp    f011f789 <getuint+0x65>
	else if (lflag)
f011f749:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f74d:	74 1e                	je     f011f76d <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f74f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f752:	8b 00                	mov    (%eax),%eax
f011f754:	8d 50 04             	lea    0x4(%eax),%edx
f011f757:	8b 45 08             	mov    0x8(%ebp),%eax
f011f75a:	89 10                	mov    %edx,(%eax)
f011f75c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f75f:	8b 00                	mov    (%eax),%eax
f011f761:	83 e8 04             	sub    $0x4,%eax
f011f764:	8b 00                	mov    (%eax),%eax
f011f766:	ba 00 00 00 00       	mov    $0x0,%edx
f011f76b:	eb 1c                	jmp    f011f789 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f76d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f770:	8b 00                	mov    (%eax),%eax
f011f772:	8d 50 04             	lea    0x4(%eax),%edx
f011f775:	8b 45 08             	mov    0x8(%ebp),%eax
f011f778:	89 10                	mov    %edx,(%eax)
f011f77a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f77d:	8b 00                	mov    (%eax),%eax
f011f77f:	83 e8 04             	sub    $0x4,%eax
f011f782:	8b 00                	mov    (%eax),%eax
f011f784:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f789:	5d                   	pop    %ebp
f011f78a:	c3                   	ret    

f011f78b <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f78b:	55                   	push   %ebp
f011f78c:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f78e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f792:	7e 1c                	jle    f011f7b0 <getint+0x25>
		return va_arg(*ap, long long);
f011f794:	8b 45 08             	mov    0x8(%ebp),%eax
f011f797:	8b 00                	mov    (%eax),%eax
f011f799:	8d 50 08             	lea    0x8(%eax),%edx
f011f79c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f79f:	89 10                	mov    %edx,(%eax)
f011f7a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7a4:	8b 00                	mov    (%eax),%eax
f011f7a6:	83 e8 08             	sub    $0x8,%eax
f011f7a9:	8b 50 04             	mov    0x4(%eax),%edx
f011f7ac:	8b 00                	mov    (%eax),%eax
f011f7ae:	eb 38                	jmp    f011f7e8 <getint+0x5d>
	else if (lflag)
f011f7b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f7b4:	74 1a                	je     f011f7d0 <getint+0x45>
		return va_arg(*ap, long);
f011f7b6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7b9:	8b 00                	mov    (%eax),%eax
f011f7bb:	8d 50 04             	lea    0x4(%eax),%edx
f011f7be:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7c1:	89 10                	mov    %edx,(%eax)
f011f7c3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7c6:	8b 00                	mov    (%eax),%eax
f011f7c8:	83 e8 04             	sub    $0x4,%eax
f011f7cb:	8b 00                	mov    (%eax),%eax
f011f7cd:	99                   	cltd   
f011f7ce:	eb 18                	jmp    f011f7e8 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f7d0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7d3:	8b 00                	mov    (%eax),%eax
f011f7d5:	8d 50 04             	lea    0x4(%eax),%edx
f011f7d8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7db:	89 10                	mov    %edx,(%eax)
f011f7dd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7e0:	8b 00                	mov    (%eax),%eax
f011f7e2:	83 e8 04             	sub    $0x4,%eax
f011f7e5:	8b 00                	mov    (%eax),%eax
f011f7e7:	99                   	cltd   
}
f011f7e8:	5d                   	pop    %ebp
f011f7e9:	c3                   	ret    

f011f7ea <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f7ea:	55                   	push   %ebp
f011f7eb:	89 e5                	mov    %esp,%ebp
f011f7ed:	56                   	push   %esi
f011f7ee:	53                   	push   %ebx
f011f7ef:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f7f2:	eb 17                	jmp    f011f80b <vprintfmt+0x21>
			if (ch == '\0')
f011f7f4:	85 db                	test   %ebx,%ebx
f011f7f6:	0f 84 c1 03 00 00    	je     f011fbbd <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f7fc:	83 ec 08             	sub    $0x8,%esp
f011f7ff:	ff 75 0c             	pushl  0xc(%ebp)
f011f802:	53                   	push   %ebx
f011f803:	8b 45 08             	mov    0x8(%ebp),%eax
f011f806:	ff d0                	call   *%eax
f011f808:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f80b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f80e:	8d 50 01             	lea    0x1(%eax),%edx
f011f811:	89 55 10             	mov    %edx,0x10(%ebp)
f011f814:	8a 00                	mov    (%eax),%al
f011f816:	0f b6 d8             	movzbl %al,%ebx
f011f819:	83 fb 25             	cmp    $0x25,%ebx
f011f81c:	75 d6                	jne    f011f7f4 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f81e:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f822:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f829:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f830:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f837:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f83e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f841:	8d 50 01             	lea    0x1(%eax),%edx
f011f844:	89 55 10             	mov    %edx,0x10(%ebp)
f011f847:	8a 00                	mov    (%eax),%al
f011f849:	0f b6 d8             	movzbl %al,%ebx
f011f84c:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f84f:	83 f8 5b             	cmp    $0x5b,%eax
f011f852:	0f 87 3d 03 00 00    	ja     f011fb95 <vprintfmt+0x3ab>
f011f858:	8b 04 85 98 17 13 f0 	mov    -0xfece868(,%eax,4),%eax
f011f85f:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f861:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f865:	eb d7                	jmp    f011f83e <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f867:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f86b:	eb d1                	jmp    f011f83e <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f86d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f874:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f877:	89 d0                	mov    %edx,%eax
f011f879:	c1 e0 02             	shl    $0x2,%eax
f011f87c:	01 d0                	add    %edx,%eax
f011f87e:	01 c0                	add    %eax,%eax
f011f880:	01 d8                	add    %ebx,%eax
f011f882:	83 e8 30             	sub    $0x30,%eax
f011f885:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f888:	8b 45 10             	mov    0x10(%ebp),%eax
f011f88b:	8a 00                	mov    (%eax),%al
f011f88d:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f890:	83 fb 2f             	cmp    $0x2f,%ebx
f011f893:	7e 3e                	jle    f011f8d3 <vprintfmt+0xe9>
f011f895:	83 fb 39             	cmp    $0x39,%ebx
f011f898:	7f 39                	jg     f011f8d3 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f89a:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f89d:	eb d5                	jmp    f011f874 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f89f:	8b 45 14             	mov    0x14(%ebp),%eax
f011f8a2:	83 c0 04             	add    $0x4,%eax
f011f8a5:	89 45 14             	mov    %eax,0x14(%ebp)
f011f8a8:	8b 45 14             	mov    0x14(%ebp),%eax
f011f8ab:	83 e8 04             	sub    $0x4,%eax
f011f8ae:	8b 00                	mov    (%eax),%eax
f011f8b0:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f8b3:	eb 1f                	jmp    f011f8d4 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f8b5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f8b9:	79 83                	jns    f011f83e <vprintfmt+0x54>
				width = 0;
f011f8bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f8c2:	e9 77 ff ff ff       	jmp    f011f83e <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f8c7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f8ce:	e9 6b ff ff ff       	jmp    f011f83e <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f8d3:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f8d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f8d8:	0f 89 60 ff ff ff    	jns    f011f83e <vprintfmt+0x54>
				width = precision, precision = -1;
f011f8de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f8e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f8e4:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f8eb:	e9 4e ff ff ff       	jmp    f011f83e <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f8f0:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f8f3:	e9 46 ff ff ff       	jmp    f011f83e <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f8f8:	8b 45 14             	mov    0x14(%ebp),%eax
f011f8fb:	83 c0 04             	add    $0x4,%eax
f011f8fe:	89 45 14             	mov    %eax,0x14(%ebp)
f011f901:	8b 45 14             	mov    0x14(%ebp),%eax
f011f904:	83 e8 04             	sub    $0x4,%eax
f011f907:	8b 00                	mov    (%eax),%eax
f011f909:	83 ec 08             	sub    $0x8,%esp
f011f90c:	ff 75 0c             	pushl  0xc(%ebp)
f011f90f:	50                   	push   %eax
f011f910:	8b 45 08             	mov    0x8(%ebp),%eax
f011f913:	ff d0                	call   *%eax
f011f915:	83 c4 10             	add    $0x10,%esp
			break;
f011f918:	e9 9b 02 00 00       	jmp    f011fbb8 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f91d:	8b 45 14             	mov    0x14(%ebp),%eax
f011f920:	83 c0 04             	add    $0x4,%eax
f011f923:	89 45 14             	mov    %eax,0x14(%ebp)
f011f926:	8b 45 14             	mov    0x14(%ebp),%eax
f011f929:	83 e8 04             	sub    $0x4,%eax
f011f92c:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f92e:	85 db                	test   %ebx,%ebx
f011f930:	79 02                	jns    f011f934 <vprintfmt+0x14a>
				err = -err;
f011f932:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f934:	83 fb 64             	cmp    $0x64,%ebx
f011f937:	7f 0b                	jg     f011f944 <vprintfmt+0x15a>
f011f939:	8b 34 9d e0 15 13 f0 	mov    -0xfecea20(,%ebx,4),%esi
f011f940:	85 f6                	test   %esi,%esi
f011f942:	75 19                	jne    f011f95d <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f944:	53                   	push   %ebx
f011f945:	68 85 17 13 f0       	push   $0xf0131785
f011f94a:	ff 75 0c             	pushl  0xc(%ebp)
f011f94d:	ff 75 08             	pushl  0x8(%ebp)
f011f950:	e8 70 02 00 00       	call   f011fbc5 <printfmt>
f011f955:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f958:	e9 5b 02 00 00       	jmp    f011fbb8 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f95d:	56                   	push   %esi
f011f95e:	68 8e 17 13 f0       	push   $0xf013178e
f011f963:	ff 75 0c             	pushl  0xc(%ebp)
f011f966:	ff 75 08             	pushl  0x8(%ebp)
f011f969:	e8 57 02 00 00       	call   f011fbc5 <printfmt>
f011f96e:	83 c4 10             	add    $0x10,%esp
			break;
f011f971:	e9 42 02 00 00       	jmp    f011fbb8 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f976:	8b 45 14             	mov    0x14(%ebp),%eax
f011f979:	83 c0 04             	add    $0x4,%eax
f011f97c:	89 45 14             	mov    %eax,0x14(%ebp)
f011f97f:	8b 45 14             	mov    0x14(%ebp),%eax
f011f982:	83 e8 04             	sub    $0x4,%eax
f011f985:	8b 30                	mov    (%eax),%esi
f011f987:	85 f6                	test   %esi,%esi
f011f989:	75 05                	jne    f011f990 <vprintfmt+0x1a6>
				p = "(null)";
f011f98b:	be 91 17 13 f0       	mov    $0xf0131791,%esi
			if (width > 0 && padc != '-')
f011f990:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f994:	7e 6d                	jle    f011fa03 <vprintfmt+0x219>
f011f996:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f99a:	74 67                	je     f011fa03 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f99c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f99f:	83 ec 08             	sub    $0x8,%esp
f011f9a2:	50                   	push   %eax
f011f9a3:	56                   	push   %esi
f011f9a4:	e8 26 05 00 00       	call   f011fecf <strnlen>
f011f9a9:	83 c4 10             	add    $0x10,%esp
f011f9ac:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f9af:	eb 16                	jmp    f011f9c7 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f9b1:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f9b5:	83 ec 08             	sub    $0x8,%esp
f011f9b8:	ff 75 0c             	pushl  0xc(%ebp)
f011f9bb:	50                   	push   %eax
f011f9bc:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9bf:	ff d0                	call   *%eax
f011f9c1:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f9c4:	ff 4d e4             	decl   -0x1c(%ebp)
f011f9c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f9cb:	7f e4                	jg     f011f9b1 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f9cd:	eb 34                	jmp    f011fa03 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f9cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f9d3:	74 1c                	je     f011f9f1 <vprintfmt+0x207>
f011f9d5:	83 fb 1f             	cmp    $0x1f,%ebx
f011f9d8:	7e 05                	jle    f011f9df <vprintfmt+0x1f5>
f011f9da:	83 fb 7e             	cmp    $0x7e,%ebx
f011f9dd:	7e 12                	jle    f011f9f1 <vprintfmt+0x207>
					putch('?', putdat);
f011f9df:	83 ec 08             	sub    $0x8,%esp
f011f9e2:	ff 75 0c             	pushl  0xc(%ebp)
f011f9e5:	6a 3f                	push   $0x3f
f011f9e7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9ea:	ff d0                	call   *%eax
f011f9ec:	83 c4 10             	add    $0x10,%esp
f011f9ef:	eb 0f                	jmp    f011fa00 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f9f1:	83 ec 08             	sub    $0x8,%esp
f011f9f4:	ff 75 0c             	pushl  0xc(%ebp)
f011f9f7:	53                   	push   %ebx
f011f9f8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9fb:	ff d0                	call   *%eax
f011f9fd:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011fa00:	ff 4d e4             	decl   -0x1c(%ebp)
f011fa03:	89 f0                	mov    %esi,%eax
f011fa05:	8d 70 01             	lea    0x1(%eax),%esi
f011fa08:	8a 00                	mov    (%eax),%al
f011fa0a:	0f be d8             	movsbl %al,%ebx
f011fa0d:	85 db                	test   %ebx,%ebx
f011fa0f:	74 24                	je     f011fa35 <vprintfmt+0x24b>
f011fa11:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fa15:	78 b8                	js     f011f9cf <vprintfmt+0x1e5>
f011fa17:	ff 4d e0             	decl   -0x20(%ebp)
f011fa1a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fa1e:	79 af                	jns    f011f9cf <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fa20:	eb 13                	jmp    f011fa35 <vprintfmt+0x24b>
				putch(' ', putdat);
f011fa22:	83 ec 08             	sub    $0x8,%esp
f011fa25:	ff 75 0c             	pushl  0xc(%ebp)
f011fa28:	6a 20                	push   $0x20
f011fa2a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa2d:	ff d0                	call   *%eax
f011fa2f:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fa32:	ff 4d e4             	decl   -0x1c(%ebp)
f011fa35:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fa39:	7f e7                	jg     f011fa22 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011fa3b:	e9 78 01 00 00       	jmp    f011fbb8 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011fa40:	83 ec 08             	sub    $0x8,%esp
f011fa43:	ff 75 e8             	pushl  -0x18(%ebp)
f011fa46:	8d 45 14             	lea    0x14(%ebp),%eax
f011fa49:	50                   	push   %eax
f011fa4a:	e8 3c fd ff ff       	call   f011f78b <getint>
f011fa4f:	83 c4 10             	add    $0x10,%esp
f011fa52:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fa55:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011fa58:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fa5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa5e:	85 d2                	test   %edx,%edx
f011fa60:	79 23                	jns    f011fa85 <vprintfmt+0x29b>
				putch('-', putdat);
f011fa62:	83 ec 08             	sub    $0x8,%esp
f011fa65:	ff 75 0c             	pushl  0xc(%ebp)
f011fa68:	6a 2d                	push   $0x2d
f011fa6a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa6d:	ff d0                	call   *%eax
f011fa6f:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011fa72:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fa75:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa78:	f7 d8                	neg    %eax
f011fa7a:	83 d2 00             	adc    $0x0,%edx
f011fa7d:	f7 da                	neg    %edx
f011fa7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fa82:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011fa85:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fa8c:	e9 bc 00 00 00       	jmp    f011fb4d <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011fa91:	83 ec 08             	sub    $0x8,%esp
f011fa94:	ff 75 e8             	pushl  -0x18(%ebp)
f011fa97:	8d 45 14             	lea    0x14(%ebp),%eax
f011fa9a:	50                   	push   %eax
f011fa9b:	e8 84 fc ff ff       	call   f011f724 <getuint>
f011faa0:	83 c4 10             	add    $0x10,%esp
f011faa3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011faa6:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011faa9:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fab0:	e9 98 00 00 00       	jmp    f011fb4d <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011fab5:	83 ec 08             	sub    $0x8,%esp
f011fab8:	ff 75 0c             	pushl  0xc(%ebp)
f011fabb:	6a 58                	push   $0x58
f011fabd:	8b 45 08             	mov    0x8(%ebp),%eax
f011fac0:	ff d0                	call   *%eax
f011fac2:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fac5:	83 ec 08             	sub    $0x8,%esp
f011fac8:	ff 75 0c             	pushl  0xc(%ebp)
f011facb:	6a 58                	push   $0x58
f011facd:	8b 45 08             	mov    0x8(%ebp),%eax
f011fad0:	ff d0                	call   *%eax
f011fad2:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fad5:	83 ec 08             	sub    $0x8,%esp
f011fad8:	ff 75 0c             	pushl  0xc(%ebp)
f011fadb:	6a 58                	push   $0x58
f011fadd:	8b 45 08             	mov    0x8(%ebp),%eax
f011fae0:	ff d0                	call   *%eax
f011fae2:	83 c4 10             	add    $0x10,%esp
			break;
f011fae5:	e9 ce 00 00 00       	jmp    f011fbb8 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011faea:	83 ec 08             	sub    $0x8,%esp
f011faed:	ff 75 0c             	pushl  0xc(%ebp)
f011faf0:	6a 30                	push   $0x30
f011faf2:	8b 45 08             	mov    0x8(%ebp),%eax
f011faf5:	ff d0                	call   *%eax
f011faf7:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011fafa:	83 ec 08             	sub    $0x8,%esp
f011fafd:	ff 75 0c             	pushl  0xc(%ebp)
f011fb00:	6a 78                	push   $0x78
f011fb02:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb05:	ff d0                	call   *%eax
f011fb07:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011fb0a:	8b 45 14             	mov    0x14(%ebp),%eax
f011fb0d:	83 c0 04             	add    $0x4,%eax
f011fb10:	89 45 14             	mov    %eax,0x14(%ebp)
f011fb13:	8b 45 14             	mov    0x14(%ebp),%eax
f011fb16:	83 e8 04             	sub    $0x4,%eax
f011fb19:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011fb1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011fb25:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011fb2c:	eb 1f                	jmp    f011fb4d <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011fb2e:	83 ec 08             	sub    $0x8,%esp
f011fb31:	ff 75 e8             	pushl  -0x18(%ebp)
f011fb34:	8d 45 14             	lea    0x14(%ebp),%eax
f011fb37:	50                   	push   %eax
f011fb38:	e8 e7 fb ff ff       	call   f011f724 <getuint>
f011fb3d:	83 c4 10             	add    $0x10,%esp
f011fb40:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb43:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011fb46:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011fb4d:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011fb51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb54:	83 ec 04             	sub    $0x4,%esp
f011fb57:	52                   	push   %edx
f011fb58:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fb5b:	50                   	push   %eax
f011fb5c:	ff 75 f4             	pushl  -0xc(%ebp)
f011fb5f:	ff 75 f0             	pushl  -0x10(%ebp)
f011fb62:	ff 75 0c             	pushl  0xc(%ebp)
f011fb65:	ff 75 08             	pushl  0x8(%ebp)
f011fb68:	e8 00 fb ff ff       	call   f011f66d <printnum>
f011fb6d:	83 c4 20             	add    $0x20,%esp
			break;
f011fb70:	eb 46                	jmp    f011fbb8 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011fb72:	83 ec 08             	sub    $0x8,%esp
f011fb75:	ff 75 0c             	pushl  0xc(%ebp)
f011fb78:	53                   	push   %ebx
f011fb79:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb7c:	ff d0                	call   *%eax
f011fb7e:	83 c4 10             	add    $0x10,%esp
			break;
f011fb81:	eb 35                	jmp    f011fbb8 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011fb83:	c6 05 60 f0 71 f0 00 	movb   $0x0,0xf071f060
			break;
f011fb8a:	eb 2c                	jmp    f011fbb8 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011fb8c:	c6 05 60 f0 71 f0 01 	movb   $0x1,0xf071f060
			break;
f011fb93:	eb 23                	jmp    f011fbb8 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011fb95:	83 ec 08             	sub    $0x8,%esp
f011fb98:	ff 75 0c             	pushl  0xc(%ebp)
f011fb9b:	6a 25                	push   $0x25
f011fb9d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fba0:	ff d0                	call   *%eax
f011fba2:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011fba5:	ff 4d 10             	decl   0x10(%ebp)
f011fba8:	eb 03                	jmp    f011fbad <vprintfmt+0x3c3>
f011fbaa:	ff 4d 10             	decl   0x10(%ebp)
f011fbad:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbb0:	48                   	dec    %eax
f011fbb1:	8a 00                	mov    (%eax),%al
f011fbb3:	3c 25                	cmp    $0x25,%al
f011fbb5:	75 f3                	jne    f011fbaa <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011fbb7:	90                   	nop
		}
	}
f011fbb8:	e9 35 fc ff ff       	jmp    f011f7f2 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011fbbd:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011fbbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011fbc1:	5b                   	pop    %ebx
f011fbc2:	5e                   	pop    %esi
f011fbc3:	5d                   	pop    %ebp
f011fbc4:	c3                   	ret    

f011fbc5 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011fbc5:	55                   	push   %ebp
f011fbc6:	89 e5                	mov    %esp,%ebp
f011fbc8:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011fbcb:	8d 45 10             	lea    0x10(%ebp),%eax
f011fbce:	83 c0 04             	add    $0x4,%eax
f011fbd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011fbd4:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbd7:	ff 75 f4             	pushl  -0xc(%ebp)
f011fbda:	50                   	push   %eax
f011fbdb:	ff 75 0c             	pushl  0xc(%ebp)
f011fbde:	ff 75 08             	pushl  0x8(%ebp)
f011fbe1:	e8 04 fc ff ff       	call   f011f7ea <vprintfmt>
f011fbe6:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011fbe9:	90                   	nop
f011fbea:	c9                   	leave  
f011fbeb:	c3                   	ret    

f011fbec <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011fbec:	55                   	push   %ebp
f011fbed:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011fbef:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbf2:	8b 40 08             	mov    0x8(%eax),%eax
f011fbf5:	8d 50 01             	lea    0x1(%eax),%edx
f011fbf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbfb:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011fbfe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc01:	8b 10                	mov    (%eax),%edx
f011fc03:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc06:	8b 40 04             	mov    0x4(%eax),%eax
f011fc09:	39 c2                	cmp    %eax,%edx
f011fc0b:	73 12                	jae    f011fc1f <sprintputch+0x33>
		*b->buf++ = ch;
f011fc0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc10:	8b 00                	mov    (%eax),%eax
f011fc12:	8d 48 01             	lea    0x1(%eax),%ecx
f011fc15:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fc18:	89 0a                	mov    %ecx,(%edx)
f011fc1a:	8b 55 08             	mov    0x8(%ebp),%edx
f011fc1d:	88 10                	mov    %dl,(%eax)
}
f011fc1f:	90                   	nop
f011fc20:	5d                   	pop    %ebp
f011fc21:	c3                   	ret    

f011fc22 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011fc22:	55                   	push   %ebp
f011fc23:	89 e5                	mov    %esp,%ebp
f011fc25:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011fc28:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fc2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc31:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fc34:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc37:	01 d0                	add    %edx,%eax
f011fc39:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fc3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011fc43:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fc47:	74 06                	je     f011fc4f <vsnprintf+0x2d>
f011fc49:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fc4d:	7f 07                	jg     f011fc56 <vsnprintf+0x34>
		return -E_INVAL;
f011fc4f:	b8 03 00 00 00       	mov    $0x3,%eax
f011fc54:	eb 20                	jmp    f011fc76 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011fc56:	ff 75 14             	pushl  0x14(%ebp)
f011fc59:	ff 75 10             	pushl  0x10(%ebp)
f011fc5c:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011fc5f:	50                   	push   %eax
f011fc60:	68 ec fb 11 f0       	push   $0xf011fbec
f011fc65:	e8 80 fb ff ff       	call   f011f7ea <vprintfmt>
f011fc6a:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011fc6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fc70:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011fc73:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fc76:	c9                   	leave  
f011fc77:	c3                   	ret    

f011fc78 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011fc78:	55                   	push   %ebp
f011fc79:	89 e5                	mov    %esp,%ebp
f011fc7b:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011fc7e:	8d 45 10             	lea    0x10(%ebp),%eax
f011fc81:	83 c0 04             	add    $0x4,%eax
f011fc84:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011fc87:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc8a:	ff 75 f4             	pushl  -0xc(%ebp)
f011fc8d:	50                   	push   %eax
f011fc8e:	ff 75 0c             	pushl  0xc(%ebp)
f011fc91:	ff 75 08             	pushl  0x8(%ebp)
f011fc94:	e8 89 ff ff ff       	call   f011fc22 <vsnprintf>
f011fc99:	83 c4 10             	add    $0x10,%esp
f011fc9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fc9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011fca2:	c9                   	leave  
f011fca3:	c3                   	ret    

f011fca4 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011fca4:	55                   	push   %ebp
f011fca5:	89 e5                	mov    %esp,%ebp
f011fca7:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fcaa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fcae:	74 13                	je     f011fcc3 <readline+0x1f>
		cprintf("%s", prompt);
f011fcb0:	83 ec 08             	sub    $0x8,%esp
f011fcb3:	ff 75 08             	pushl  0x8(%ebp)
f011fcb6:	68 08 19 13 f0       	push   $0xf0131908
f011fcbb:	e8 cb 12 fe ff       	call   f0100f8b <cprintf>
f011fcc0:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011fcc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011fcca:	83 ec 0c             	sub    $0xc,%esp
f011fccd:	6a 00                	push   $0x0
f011fccf:	e8 c4 11 fe ff       	call   f0100e98 <iscons>
f011fcd4:	83 c4 10             	add    $0x10,%esp
f011fcd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fcda:	e8 a0 11 fe ff       	call   f0100e7f <getchar>
f011fcdf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fce2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fce6:	79 22                	jns    f011fd0a <readline+0x66>
			if (c != -E_EOF)
f011fce8:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fcec:	0f 84 ad 00 00 00    	je     f011fd9f <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fcf2:	83 ec 08             	sub    $0x8,%esp
f011fcf5:	ff 75 ec             	pushl  -0x14(%ebp)
f011fcf8:	68 0b 19 13 f0       	push   $0xf013190b
f011fcfd:	e8 89 12 fe ff       	call   f0100f8b <cprintf>
f011fd02:	83 c4 10             	add    $0x10,%esp
			break;
f011fd05:	e9 95 00 00 00       	jmp    f011fd9f <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fd0a:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fd0e:	7e 34                	jle    f011fd44 <readline+0xa0>
f011fd10:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fd17:	7f 2b                	jg     f011fd44 <readline+0xa0>
			if (echoing)
f011fd19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fd1d:	74 0e                	je     f011fd2d <readline+0x89>
				cputchar(c);
f011fd1f:	83 ec 0c             	sub    $0xc,%esp
f011fd22:	ff 75 ec             	pushl  -0x14(%ebp)
f011fd25:	e8 3e 11 fe ff       	call   f0100e68 <cputchar>
f011fd2a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fd2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fd30:	8d 50 01             	lea    0x1(%eax),%edx
f011fd33:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fd36:	89 c2                	mov    %eax,%edx
f011fd38:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd3b:	01 d0                	add    %edx,%eax
f011fd3d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fd40:	88 10                	mov    %dl,(%eax)
f011fd42:	eb 56                	jmp    f011fd9a <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fd44:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fd48:	75 1f                	jne    f011fd69 <readline+0xc5>
f011fd4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fd4e:	7e 19                	jle    f011fd69 <readline+0xc5>
			if (echoing)
f011fd50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fd54:	74 0e                	je     f011fd64 <readline+0xc0>
				cputchar(c);
f011fd56:	83 ec 0c             	sub    $0xc,%esp
f011fd59:	ff 75 ec             	pushl  -0x14(%ebp)
f011fd5c:	e8 07 11 fe ff       	call   f0100e68 <cputchar>
f011fd61:	83 c4 10             	add    $0x10,%esp

			i--;
f011fd64:	ff 4d f4             	decl   -0xc(%ebp)
f011fd67:	eb 31                	jmp    f011fd9a <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fd69:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fd6d:	74 0a                	je     f011fd79 <readline+0xd5>
f011fd6f:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fd73:	0f 85 61 ff ff ff    	jne    f011fcda <readline+0x36>
			if (echoing)
f011fd79:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fd7d:	74 0e                	je     f011fd8d <readline+0xe9>
				cputchar(c);
f011fd7f:	83 ec 0c             	sub    $0xc,%esp
f011fd82:	ff 75 ec             	pushl  -0x14(%ebp)
f011fd85:	e8 de 10 fe ff       	call   f0100e68 <cputchar>
f011fd8a:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fd8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fd90:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd93:	01 d0                	add    %edx,%eax
f011fd95:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fd98:	eb 06                	jmp    f011fda0 <readline+0xfc>
		}
	}
f011fd9a:	e9 3b ff ff ff       	jmp    f011fcda <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fd9f:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fda0:	90                   	nop
f011fda1:	c9                   	leave  
f011fda2:	c3                   	ret    

f011fda3 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fda3:	55                   	push   %ebp
f011fda4:	89 e5                	mov    %esp,%ebp
f011fda6:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fda9:	e8 53 ec fe ff       	call   f010ea01 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011fdae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fdb2:	74 13                	je     f011fdc7 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fdb4:	83 ec 08             	sub    $0x8,%esp
f011fdb7:	ff 75 08             	pushl  0x8(%ebp)
f011fdba:	68 08 19 13 f0       	push   $0xf0131908
f011fdbf:	e8 c7 11 fe ff       	call   f0100f8b <cprintf>
f011fdc4:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fdc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011fdce:	83 ec 0c             	sub    $0xc,%esp
f011fdd1:	6a 00                	push   $0x0
f011fdd3:	e8 c0 10 fe ff       	call   f0100e98 <iscons>
f011fdd8:	83 c4 10             	add    $0x10,%esp
f011fddb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fdde:	e8 9c 10 fe ff       	call   f0100e7f <getchar>
f011fde3:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fde6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fdea:	79 22                	jns    f011fe0e <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fdec:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fdf0:	0f 84 ad 00 00 00    	je     f011fea3 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011fdf6:	83 ec 08             	sub    $0x8,%esp
f011fdf9:	ff 75 ec             	pushl  -0x14(%ebp)
f011fdfc:	68 0b 19 13 f0       	push   $0xf013190b
f011fe01:	e8 85 11 fe ff       	call   f0100f8b <cprintf>
f011fe06:	83 c4 10             	add    $0x10,%esp
				break;
f011fe09:	e9 95 00 00 00       	jmp    f011fea3 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fe0e:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fe12:	7e 34                	jle    f011fe48 <atomic_readline+0xa5>
f011fe14:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fe1b:	7f 2b                	jg     f011fe48 <atomic_readline+0xa5>
				if (echoing)
f011fe1d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe21:	74 0e                	je     f011fe31 <atomic_readline+0x8e>
					cputchar(c);
f011fe23:	83 ec 0c             	sub    $0xc,%esp
f011fe26:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe29:	e8 3a 10 fe ff       	call   f0100e68 <cputchar>
f011fe2e:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fe31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fe34:	8d 50 01             	lea    0x1(%eax),%edx
f011fe37:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fe3a:	89 c2                	mov    %eax,%edx
f011fe3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe3f:	01 d0                	add    %edx,%eax
f011fe41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fe44:	88 10                	mov    %dl,(%eax)
f011fe46:	eb 56                	jmp    f011fe9e <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fe48:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fe4c:	75 1f                	jne    f011fe6d <atomic_readline+0xca>
f011fe4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fe52:	7e 19                	jle    f011fe6d <atomic_readline+0xca>
				if (echoing)
f011fe54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe58:	74 0e                	je     f011fe68 <atomic_readline+0xc5>
					cputchar(c);
f011fe5a:	83 ec 0c             	sub    $0xc,%esp
f011fe5d:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe60:	e8 03 10 fe ff       	call   f0100e68 <cputchar>
f011fe65:	83 c4 10             	add    $0x10,%esp
				i--;
f011fe68:	ff 4d f4             	decl   -0xc(%ebp)
f011fe6b:	eb 31                	jmp    f011fe9e <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011fe6d:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fe71:	74 0a                	je     f011fe7d <atomic_readline+0xda>
f011fe73:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fe77:	0f 85 61 ff ff ff    	jne    f011fdde <atomic_readline+0x3b>
				if (echoing)
f011fe7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe81:	74 0e                	je     f011fe91 <atomic_readline+0xee>
					cputchar(c);
f011fe83:	83 ec 0c             	sub    $0xc,%esp
f011fe86:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe89:	e8 da 0f fe ff       	call   f0100e68 <cputchar>
f011fe8e:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011fe91:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fe94:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe97:	01 d0                	add    %edx,%eax
f011fe99:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011fe9c:	eb 06                	jmp    f011fea4 <atomic_readline+0x101>
			}
		}
f011fe9e:	e9 3b ff ff ff       	jmp    f011fdde <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011fea3:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011fea4:	e8 66 eb fe ff       	call   f010ea0f <sys_unlock_cons>
}
f011fea9:	90                   	nop
f011feaa:	c9                   	leave  
f011feab:	c3                   	ret    

f011feac <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011feac:	55                   	push   %ebp
f011fead:	89 e5                	mov    %esp,%ebp
f011feaf:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011feb2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011feb9:	eb 06                	jmp    f011fec1 <strlen+0x15>
		n++;
f011febb:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011febe:	ff 45 08             	incl   0x8(%ebp)
f011fec1:	8b 45 08             	mov    0x8(%ebp),%eax
f011fec4:	8a 00                	mov    (%eax),%al
f011fec6:	84 c0                	test   %al,%al
f011fec8:	75 f1                	jne    f011febb <strlen+0xf>
		n++;
	return n;
f011feca:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fecd:	c9                   	leave  
f011fece:	c3                   	ret    

f011fecf <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011fecf:	55                   	push   %ebp
f011fed0:	89 e5                	mov    %esp,%ebp
f011fed2:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fed5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fedc:	eb 09                	jmp    f011fee7 <strnlen+0x18>
		n++;
f011fede:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fee1:	ff 45 08             	incl   0x8(%ebp)
f011fee4:	ff 4d 0c             	decl   0xc(%ebp)
f011fee7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011feeb:	74 09                	je     f011fef6 <strnlen+0x27>
f011feed:	8b 45 08             	mov    0x8(%ebp),%eax
f011fef0:	8a 00                	mov    (%eax),%al
f011fef2:	84 c0                	test   %al,%al
f011fef4:	75 e8                	jne    f011fede <strnlen+0xf>
		n++;
	return n;
f011fef6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fef9:	c9                   	leave  
f011fefa:	c3                   	ret    

f011fefb <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011fefb:	55                   	push   %ebp
f011fefc:	89 e5                	mov    %esp,%ebp
f011fefe:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011ff01:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff04:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011ff07:	90                   	nop
f011ff08:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff0b:	8d 50 01             	lea    0x1(%eax),%edx
f011ff0e:	89 55 08             	mov    %edx,0x8(%ebp)
f011ff11:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ff14:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ff17:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ff1a:	8a 12                	mov    (%edx),%dl
f011ff1c:	88 10                	mov    %dl,(%eax)
f011ff1e:	8a 00                	mov    (%eax),%al
f011ff20:	84 c0                	test   %al,%al
f011ff22:	75 e4                	jne    f011ff08 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011ff24:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ff27:	c9                   	leave  
f011ff28:	c3                   	ret    

f011ff29 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011ff29:	55                   	push   %ebp
f011ff2a:	89 e5                	mov    %esp,%ebp
f011ff2c:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011ff2f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff32:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ff35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ff3c:	eb 1f                	jmp    f011ff5d <strncpy+0x34>
		*dst++ = *src;
f011ff3e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff41:	8d 50 01             	lea    0x1(%eax),%edx
f011ff44:	89 55 08             	mov    %edx,0x8(%ebp)
f011ff47:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ff4a:	8a 12                	mov    (%edx),%dl
f011ff4c:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ff4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff51:	8a 00                	mov    (%eax),%al
f011ff53:	84 c0                	test   %al,%al
f011ff55:	74 03                	je     f011ff5a <strncpy+0x31>
			src++;
f011ff57:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ff5a:	ff 45 fc             	incl   -0x4(%ebp)
f011ff5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff60:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ff63:	72 d9                	jb     f011ff3e <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ff65:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ff68:	c9                   	leave  
f011ff69:	c3                   	ret    

f011ff6a <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ff6a:	55                   	push   %ebp
f011ff6b:	89 e5                	mov    %esp,%ebp
f011ff6d:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011ff70:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff73:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011ff76:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ff7a:	74 30                	je     f011ffac <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ff7c:	eb 16                	jmp    f011ff94 <strlcpy+0x2a>
			*dst++ = *src++;
f011ff7e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff81:	8d 50 01             	lea    0x1(%eax),%edx
f011ff84:	89 55 08             	mov    %edx,0x8(%ebp)
f011ff87:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ff8a:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ff8d:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ff90:	8a 12                	mov    (%edx),%dl
f011ff92:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ff94:	ff 4d 10             	decl   0x10(%ebp)
f011ff97:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ff9b:	74 09                	je     f011ffa6 <strlcpy+0x3c>
f011ff9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffa0:	8a 00                	mov    (%eax),%al
f011ffa2:	84 c0                	test   %al,%al
f011ffa4:	75 d8                	jne    f011ff7e <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ffa6:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffa9:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ffac:	8b 55 08             	mov    0x8(%ebp),%edx
f011ffaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ffb2:	29 c2                	sub    %eax,%edx
f011ffb4:	89 d0                	mov    %edx,%eax
}
f011ffb6:	c9                   	leave  
f011ffb7:	c3                   	ret    

f011ffb8 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011ffb8:	55                   	push   %ebp
f011ffb9:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ffbb:	eb 06                	jmp    f011ffc3 <strcmp+0xb>
		p++, q++;
f011ffbd:	ff 45 08             	incl   0x8(%ebp)
f011ffc0:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ffc3:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffc6:	8a 00                	mov    (%eax),%al
f011ffc8:	84 c0                	test   %al,%al
f011ffca:	74 0e                	je     f011ffda <strcmp+0x22>
f011ffcc:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffcf:	8a 10                	mov    (%eax),%dl
f011ffd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffd4:	8a 00                	mov    (%eax),%al
f011ffd6:	38 c2                	cmp    %al,%dl
f011ffd8:	74 e3                	je     f011ffbd <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011ffda:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffdd:	8a 00                	mov    (%eax),%al
f011ffdf:	0f b6 d0             	movzbl %al,%edx
f011ffe2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffe5:	8a 00                	mov    (%eax),%al
f011ffe7:	0f b6 c0             	movzbl %al,%eax
f011ffea:	29 c2                	sub    %eax,%edx
f011ffec:	89 d0                	mov    %edx,%eax
}
f011ffee:	5d                   	pop    %ebp
f011ffef:	c3                   	ret    

f011fff0 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011fff0:	55                   	push   %ebp
f011fff1:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011fff3:	eb 09                	jmp    f011fffe <strncmp+0xe>
		n--, p++, q++;
f011fff5:	ff 4d 10             	decl   0x10(%ebp)
f011fff8:	ff 45 08             	incl   0x8(%ebp)
f011fffb:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011fffe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120002:	74 17                	je     f012001b <strncmp+0x2b>
f0120004:	8b 45 08             	mov    0x8(%ebp),%eax
f0120007:	8a 00                	mov    (%eax),%al
f0120009:	84 c0                	test   %al,%al
f012000b:	74 0e                	je     f012001b <strncmp+0x2b>
f012000d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120010:	8a 10                	mov    (%eax),%dl
f0120012:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120015:	8a 00                	mov    (%eax),%al
f0120017:	38 c2                	cmp    %al,%dl
f0120019:	74 da                	je     f011fff5 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f012001b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012001f:	75 07                	jne    f0120028 <strncmp+0x38>
		return 0;
f0120021:	b8 00 00 00 00       	mov    $0x0,%eax
f0120026:	eb 14                	jmp    f012003c <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f0120028:	8b 45 08             	mov    0x8(%ebp),%eax
f012002b:	8a 00                	mov    (%eax),%al
f012002d:	0f b6 d0             	movzbl %al,%edx
f0120030:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120033:	8a 00                	mov    (%eax),%al
f0120035:	0f b6 c0             	movzbl %al,%eax
f0120038:	29 c2                	sub    %eax,%edx
f012003a:	89 d0                	mov    %edx,%eax
}
f012003c:	5d                   	pop    %ebp
f012003d:	c3                   	ret    

f012003e <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f012003e:	55                   	push   %ebp
f012003f:	89 e5                	mov    %esp,%ebp
f0120041:	83 ec 04             	sub    $0x4,%esp
f0120044:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120047:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f012004a:	eb 12                	jmp    f012005e <strchr+0x20>
		if (*s == c)
f012004c:	8b 45 08             	mov    0x8(%ebp),%eax
f012004f:	8a 00                	mov    (%eax),%al
f0120051:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0120054:	75 05                	jne    f012005b <strchr+0x1d>
			return (char *) s;
f0120056:	8b 45 08             	mov    0x8(%ebp),%eax
f0120059:	eb 11                	jmp    f012006c <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f012005b:	ff 45 08             	incl   0x8(%ebp)
f012005e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120061:	8a 00                	mov    (%eax),%al
f0120063:	84 c0                	test   %al,%al
f0120065:	75 e5                	jne    f012004c <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f0120067:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012006c:	c9                   	leave  
f012006d:	c3                   	ret    

f012006e <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f012006e:	55                   	push   %ebp
f012006f:	89 e5                	mov    %esp,%ebp
f0120071:	83 ec 04             	sub    $0x4,%esp
f0120074:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120077:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f012007a:	eb 0d                	jmp    f0120089 <strfind+0x1b>
		if (*s == c)
f012007c:	8b 45 08             	mov    0x8(%ebp),%eax
f012007f:	8a 00                	mov    (%eax),%al
f0120081:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0120084:	74 0e                	je     f0120094 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f0120086:	ff 45 08             	incl   0x8(%ebp)
f0120089:	8b 45 08             	mov    0x8(%ebp),%eax
f012008c:	8a 00                	mov    (%eax),%al
f012008e:	84 c0                	test   %al,%al
f0120090:	75 ea                	jne    f012007c <strfind+0xe>
f0120092:	eb 01                	jmp    f0120095 <strfind+0x27>
		if (*s == c)
			break;
f0120094:	90                   	nop
	return (char *) s;
f0120095:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120098:	c9                   	leave  
f0120099:	c3                   	ret    

f012009a <memset>:


void *
memset(void *v, int c, uint32 n)
{
f012009a:	55                   	push   %ebp
f012009b:	89 e5                	mov    %esp,%ebp
f012009d:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f01200a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01200a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f01200a6:	8b 45 10             	mov    0x10(%ebp),%eax
f01200a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f01200ac:	eb 0e                	jmp    f01200bc <memset+0x22>
		*p++ = c;
f01200ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01200b1:	8d 50 01             	lea    0x1(%eax),%edx
f01200b4:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01200b7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01200ba:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f01200bc:	ff 4d f8             	decl   -0x8(%ebp)
f01200bf:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f01200c3:	79 e9                	jns    f01200ae <memset+0x14>
		*p++ = c;

	return v;
f01200c5:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01200c8:	c9                   	leave  
f01200c9:	c3                   	ret    

f01200ca <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f01200ca:	55                   	push   %ebp
f01200cb:	89 e5                	mov    %esp,%ebp
f01200cd:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f01200d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f01200d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01200d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f01200dc:	eb 16                	jmp    f01200f4 <memcpy+0x2a>
		*d++ = *s++;
f01200de:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01200e1:	8d 50 01             	lea    0x1(%eax),%edx
f01200e4:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01200e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01200ea:	8d 4a 01             	lea    0x1(%edx),%ecx
f01200ed:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01200f0:	8a 12                	mov    (%edx),%dl
f01200f2:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f01200f4:	8b 45 10             	mov    0x10(%ebp),%eax
f01200f7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01200fa:	89 55 10             	mov    %edx,0x10(%ebp)
f01200fd:	85 c0                	test   %eax,%eax
f01200ff:	75 dd                	jne    f01200de <memcpy+0x14>
		*d++ = *s++;

	return dst;
f0120101:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120104:	c9                   	leave  
f0120105:	c3                   	ret    

f0120106 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f0120106:	55                   	push   %ebp
f0120107:	89 e5                	mov    %esp,%ebp
f0120109:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012010c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012010f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0120112:	8b 45 08             	mov    0x8(%ebp),%eax
f0120115:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f0120118:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012011b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012011e:	73 50                	jae    f0120170 <memmove+0x6a>
f0120120:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120123:	8b 45 10             	mov    0x10(%ebp),%eax
f0120126:	01 d0                	add    %edx,%eax
f0120128:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012012b:	76 43                	jbe    f0120170 <memmove+0x6a>
		s += n;
f012012d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120130:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f0120133:	8b 45 10             	mov    0x10(%ebp),%eax
f0120136:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f0120139:	eb 10                	jmp    f012014b <memmove+0x45>
			*--d = *--s;
f012013b:	ff 4d f8             	decl   -0x8(%ebp)
f012013e:	ff 4d fc             	decl   -0x4(%ebp)
f0120141:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120144:	8a 10                	mov    (%eax),%dl
f0120146:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120149:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f012014b:	8b 45 10             	mov    0x10(%ebp),%eax
f012014e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120151:	89 55 10             	mov    %edx,0x10(%ebp)
f0120154:	85 c0                	test   %eax,%eax
f0120156:	75 e3                	jne    f012013b <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f0120158:	eb 23                	jmp    f012017d <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f012015a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012015d:	8d 50 01             	lea    0x1(%eax),%edx
f0120160:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120163:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120166:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120169:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f012016c:	8a 12                	mov    (%edx),%dl
f012016e:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f0120170:	8b 45 10             	mov    0x10(%ebp),%eax
f0120173:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120176:	89 55 10             	mov    %edx,0x10(%ebp)
f0120179:	85 c0                	test   %eax,%eax
f012017b:	75 dd                	jne    f012015a <memmove+0x54>
			*d++ = *s++;

	return dst;
f012017d:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120180:	c9                   	leave  
f0120181:	c3                   	ret    

f0120182 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f0120182:	55                   	push   %ebp
f0120183:	89 e5                	mov    %esp,%ebp
f0120185:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f0120188:	8b 45 08             	mov    0x8(%ebp),%eax
f012018b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f012018e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120191:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f0120194:	eb 2a                	jmp    f01201c0 <memcmp+0x3e>
		if (*s1 != *s2)
f0120196:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120199:	8a 10                	mov    (%eax),%dl
f012019b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012019e:	8a 00                	mov    (%eax),%al
f01201a0:	38 c2                	cmp    %al,%dl
f01201a2:	74 16                	je     f01201ba <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f01201a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201a7:	8a 00                	mov    (%eax),%al
f01201a9:	0f b6 d0             	movzbl %al,%edx
f01201ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201af:	8a 00                	mov    (%eax),%al
f01201b1:	0f b6 c0             	movzbl %al,%eax
f01201b4:	29 c2                	sub    %eax,%edx
f01201b6:	89 d0                	mov    %edx,%eax
f01201b8:	eb 18                	jmp    f01201d2 <memcmp+0x50>
		s1++, s2++;
f01201ba:	ff 45 fc             	incl   -0x4(%ebp)
f01201bd:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f01201c0:	8b 45 10             	mov    0x10(%ebp),%eax
f01201c3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01201c6:	89 55 10             	mov    %edx,0x10(%ebp)
f01201c9:	85 c0                	test   %eax,%eax
f01201cb:	75 c9                	jne    f0120196 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f01201cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01201d2:	c9                   	leave  
f01201d3:	c3                   	ret    

f01201d4 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f01201d4:	55                   	push   %ebp
f01201d5:	89 e5                	mov    %esp,%ebp
f01201d7:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f01201da:	8b 55 08             	mov    0x8(%ebp),%edx
f01201dd:	8b 45 10             	mov    0x10(%ebp),%eax
f01201e0:	01 d0                	add    %edx,%eax
f01201e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f01201e5:	eb 15                	jmp    f01201fc <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f01201e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01201ea:	8a 00                	mov    (%eax),%al
f01201ec:	0f b6 d0             	movzbl %al,%edx
f01201ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201f2:	0f b6 c0             	movzbl %al,%eax
f01201f5:	39 c2                	cmp    %eax,%edx
f01201f7:	74 0d                	je     f0120206 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f01201f9:	ff 45 08             	incl   0x8(%ebp)
f01201fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01201ff:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0120202:	72 e3                	jb     f01201e7 <memfind+0x13>
f0120204:	eb 01                	jmp    f0120207 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0120206:	90                   	nop
	return (void *) s;
f0120207:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012020a:	c9                   	leave  
f012020b:	c3                   	ret    

f012020c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f012020c:	55                   	push   %ebp
f012020d:	89 e5                	mov    %esp,%ebp
f012020f:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f0120212:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f0120219:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0120220:	eb 03                	jmp    f0120225 <strtol+0x19>
		s++;
f0120222:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0120225:	8b 45 08             	mov    0x8(%ebp),%eax
f0120228:	8a 00                	mov    (%eax),%al
f012022a:	3c 20                	cmp    $0x20,%al
f012022c:	74 f4                	je     f0120222 <strtol+0x16>
f012022e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120231:	8a 00                	mov    (%eax),%al
f0120233:	3c 09                	cmp    $0x9,%al
f0120235:	74 eb                	je     f0120222 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f0120237:	8b 45 08             	mov    0x8(%ebp),%eax
f012023a:	8a 00                	mov    (%eax),%al
f012023c:	3c 2b                	cmp    $0x2b,%al
f012023e:	75 05                	jne    f0120245 <strtol+0x39>
		s++;
f0120240:	ff 45 08             	incl   0x8(%ebp)
f0120243:	eb 13                	jmp    f0120258 <strtol+0x4c>
	else if (*s == '-')
f0120245:	8b 45 08             	mov    0x8(%ebp),%eax
f0120248:	8a 00                	mov    (%eax),%al
f012024a:	3c 2d                	cmp    $0x2d,%al
f012024c:	75 0a                	jne    f0120258 <strtol+0x4c>
		s++, neg = 1;
f012024e:	ff 45 08             	incl   0x8(%ebp)
f0120251:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f0120258:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012025c:	74 06                	je     f0120264 <strtol+0x58>
f012025e:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f0120262:	75 20                	jne    f0120284 <strtol+0x78>
f0120264:	8b 45 08             	mov    0x8(%ebp),%eax
f0120267:	8a 00                	mov    (%eax),%al
f0120269:	3c 30                	cmp    $0x30,%al
f012026b:	75 17                	jne    f0120284 <strtol+0x78>
f012026d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120270:	40                   	inc    %eax
f0120271:	8a 00                	mov    (%eax),%al
f0120273:	3c 78                	cmp    $0x78,%al
f0120275:	75 0d                	jne    f0120284 <strtol+0x78>
		s += 2, base = 16;
f0120277:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f012027b:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0120282:	eb 28                	jmp    f01202ac <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f0120284:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120288:	75 15                	jne    f012029f <strtol+0x93>
f012028a:	8b 45 08             	mov    0x8(%ebp),%eax
f012028d:	8a 00                	mov    (%eax),%al
f012028f:	3c 30                	cmp    $0x30,%al
f0120291:	75 0c                	jne    f012029f <strtol+0x93>
		s++, base = 8;
f0120293:	ff 45 08             	incl   0x8(%ebp)
f0120296:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f012029d:	eb 0d                	jmp    f01202ac <strtol+0xa0>
	else if (base == 0)
f012029f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01202a3:	75 07                	jne    f01202ac <strtol+0xa0>
		base = 10;
f01202a5:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f01202ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01202af:	8a 00                	mov    (%eax),%al
f01202b1:	3c 2f                	cmp    $0x2f,%al
f01202b3:	7e 19                	jle    f01202ce <strtol+0xc2>
f01202b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01202b8:	8a 00                	mov    (%eax),%al
f01202ba:	3c 39                	cmp    $0x39,%al
f01202bc:	7f 10                	jg     f01202ce <strtol+0xc2>
			dig = *s - '0';
f01202be:	8b 45 08             	mov    0x8(%ebp),%eax
f01202c1:	8a 00                	mov    (%eax),%al
f01202c3:	0f be c0             	movsbl %al,%eax
f01202c6:	83 e8 30             	sub    $0x30,%eax
f01202c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01202cc:	eb 42                	jmp    f0120310 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f01202ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01202d1:	8a 00                	mov    (%eax),%al
f01202d3:	3c 60                	cmp    $0x60,%al
f01202d5:	7e 19                	jle    f01202f0 <strtol+0xe4>
f01202d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01202da:	8a 00                	mov    (%eax),%al
f01202dc:	3c 7a                	cmp    $0x7a,%al
f01202de:	7f 10                	jg     f01202f0 <strtol+0xe4>
			dig = *s - 'a' + 10;
f01202e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01202e3:	8a 00                	mov    (%eax),%al
f01202e5:	0f be c0             	movsbl %al,%eax
f01202e8:	83 e8 57             	sub    $0x57,%eax
f01202eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01202ee:	eb 20                	jmp    f0120310 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f01202f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01202f3:	8a 00                	mov    (%eax),%al
f01202f5:	3c 40                	cmp    $0x40,%al
f01202f7:	7e 39                	jle    f0120332 <strtol+0x126>
f01202f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01202fc:	8a 00                	mov    (%eax),%al
f01202fe:	3c 5a                	cmp    $0x5a,%al
f0120300:	7f 30                	jg     f0120332 <strtol+0x126>
			dig = *s - 'A' + 10;
f0120302:	8b 45 08             	mov    0x8(%ebp),%eax
f0120305:	8a 00                	mov    (%eax),%al
f0120307:	0f be c0             	movsbl %al,%eax
f012030a:	83 e8 37             	sub    $0x37,%eax
f012030d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0120310:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120313:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120316:	7d 19                	jge    f0120331 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0120318:	ff 45 08             	incl   0x8(%ebp)
f012031b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012031e:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120322:	89 c2                	mov    %eax,%edx
f0120324:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120327:	01 d0                	add    %edx,%eax
f0120329:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f012032c:	e9 7b ff ff ff       	jmp    f01202ac <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f0120331:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f0120332:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120336:	74 08                	je     f0120340 <strtol+0x134>
		*endptr = (char *) s;
f0120338:	8b 45 0c             	mov    0xc(%ebp),%eax
f012033b:	8b 55 08             	mov    0x8(%ebp),%edx
f012033e:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f0120340:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120344:	74 07                	je     f012034d <strtol+0x141>
f0120346:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120349:	f7 d8                	neg    %eax
f012034b:	eb 03                	jmp    f0120350 <strtol+0x144>
f012034d:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0120350:	c9                   	leave  
f0120351:	c3                   	ret    

f0120352 <ltostr>:

void
ltostr(long value, char *str)
{
f0120352:	55                   	push   %ebp
f0120353:	89 e5                	mov    %esp,%ebp
f0120355:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f0120358:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f012035f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0120366:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012036a:	79 13                	jns    f012037f <ltostr+0x2d>
	{
		neg = 1;
f012036c:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0120373:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120376:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0120379:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f012037c:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f012037f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120382:	b9 0a 00 00 00       	mov    $0xa,%ecx
f0120387:	99                   	cltd   
f0120388:	f7 f9                	idiv   %ecx
f012038a:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f012038d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120390:	8d 50 01             	lea    0x1(%eax),%edx
f0120393:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120396:	89 c2                	mov    %eax,%edx
f0120398:	8b 45 0c             	mov    0xc(%ebp),%eax
f012039b:	01 d0                	add    %edx,%eax
f012039d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01203a0:	83 c2 30             	add    $0x30,%edx
f01203a3:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f01203a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01203a8:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01203ad:	f7 e9                	imul   %ecx
f01203af:	c1 fa 02             	sar    $0x2,%edx
f01203b2:	89 c8                	mov    %ecx,%eax
f01203b4:	c1 f8 1f             	sar    $0x1f,%eax
f01203b7:	29 c2                	sub    %eax,%edx
f01203b9:	89 d0                	mov    %edx,%eax
f01203bb:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f01203be:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01203c2:	75 bb                	jne    f012037f <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f01203c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f01203cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01203ce:	48                   	dec    %eax
f01203cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f01203d2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01203d6:	74 3d                	je     f0120415 <ltostr+0xc3>
		start = 1 ;
f01203d8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f01203df:	eb 34                	jmp    f0120415 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f01203e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01203e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203e7:	01 d0                	add    %edx,%eax
f01203e9:	8a 00                	mov    (%eax),%al
f01203eb:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f01203ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01203f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203f4:	01 c2                	add    %eax,%edx
f01203f6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f01203f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203fc:	01 c8                	add    %ecx,%eax
f01203fe:	8a 00                	mov    (%eax),%al
f0120400:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0120402:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120405:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120408:	01 c2                	add    %eax,%edx
f012040a:	8a 45 eb             	mov    -0x15(%ebp),%al
f012040d:	88 02                	mov    %al,(%edx)
		start++ ;
f012040f:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0120412:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120418:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012041b:	7c c4                	jl     f01203e1 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f012041d:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0120420:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120423:	01 d0                	add    %edx,%eax
f0120425:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120428:	90                   	nop
f0120429:	c9                   	leave  
f012042a:	c3                   	ret    

f012042b <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f012042b:	55                   	push   %ebp
f012042c:	89 e5                	mov    %esp,%ebp
f012042e:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0120431:	ff 75 08             	pushl  0x8(%ebp)
f0120434:	e8 73 fa ff ff       	call   f011feac <strlen>
f0120439:	83 c4 04             	add    $0x4,%esp
f012043c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f012043f:	ff 75 0c             	pushl  0xc(%ebp)
f0120442:	e8 65 fa ff ff       	call   f011feac <strlen>
f0120447:	83 c4 04             	add    $0x4,%esp
f012044a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f012044d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0120454:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012045b:	eb 17                	jmp    f0120474 <strcconcat+0x49>
		final[s] = str1[s] ;
f012045d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120460:	8b 45 10             	mov    0x10(%ebp),%eax
f0120463:	01 c2                	add    %eax,%edx
f0120465:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120468:	8b 45 08             	mov    0x8(%ebp),%eax
f012046b:	01 c8                	add    %ecx,%eax
f012046d:	8a 00                	mov    (%eax),%al
f012046f:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0120471:	ff 45 fc             	incl   -0x4(%ebp)
f0120474:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120477:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f012047a:	7c e1                	jl     f012045d <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f012047c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0120483:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f012048a:	eb 1f                	jmp    f01204ab <strcconcat+0x80>
		final[s++] = str2[i] ;
f012048c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012048f:	8d 50 01             	lea    0x1(%eax),%edx
f0120492:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120495:	89 c2                	mov    %eax,%edx
f0120497:	8b 45 10             	mov    0x10(%ebp),%eax
f012049a:	01 c2                	add    %eax,%edx
f012049c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f012049f:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204a2:	01 c8                	add    %ecx,%eax
f01204a4:	8a 00                	mov    (%eax),%al
f01204a6:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f01204a8:	ff 45 f8             	incl   -0x8(%ebp)
f01204ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01204ae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01204b1:	7c d9                	jl     f012048c <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f01204b3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01204b6:	8b 45 10             	mov    0x10(%ebp),%eax
f01204b9:	01 d0                	add    %edx,%eax
f01204bb:	c6 00 00             	movb   $0x0,(%eax)
}
f01204be:	90                   	nop
f01204bf:	c9                   	leave  
f01204c0:	c3                   	ret    

f01204c1 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f01204c1:	55                   	push   %ebp
f01204c2:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f01204c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01204c7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f01204cd:	8b 45 14             	mov    0x14(%ebp),%eax
f01204d0:	8b 00                	mov    (%eax),%eax
f01204d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01204d9:	8b 45 10             	mov    0x10(%ebp),%eax
f01204dc:	01 d0                	add    %edx,%eax
f01204de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f01204e4:	eb 0c                	jmp    f01204f2 <strsplit+0x31>
			*string++ = 0;
f01204e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01204e9:	8d 50 01             	lea    0x1(%eax),%edx
f01204ec:	89 55 08             	mov    %edx,0x8(%ebp)
f01204ef:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f01204f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01204f5:	8a 00                	mov    (%eax),%al
f01204f7:	84 c0                	test   %al,%al
f01204f9:	74 18                	je     f0120513 <strsplit+0x52>
f01204fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01204fe:	8a 00                	mov    (%eax),%al
f0120500:	0f be c0             	movsbl %al,%eax
f0120503:	50                   	push   %eax
f0120504:	ff 75 0c             	pushl  0xc(%ebp)
f0120507:	e8 32 fb ff ff       	call   f012003e <strchr>
f012050c:	83 c4 08             	add    $0x8,%esp
f012050f:	85 c0                	test   %eax,%eax
f0120511:	75 d3                	jne    f01204e6 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0120513:	8b 45 08             	mov    0x8(%ebp),%eax
f0120516:	8a 00                	mov    (%eax),%al
f0120518:	84 c0                	test   %al,%al
f012051a:	74 5a                	je     f0120576 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f012051c:	8b 45 14             	mov    0x14(%ebp),%eax
f012051f:	8b 00                	mov    (%eax),%eax
f0120521:	83 f8 0f             	cmp    $0xf,%eax
f0120524:	75 07                	jne    f012052d <strsplit+0x6c>
		{
			return 0;
f0120526:	b8 00 00 00 00       	mov    $0x0,%eax
f012052b:	eb 66                	jmp    f0120593 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f012052d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120530:	8b 00                	mov    (%eax),%eax
f0120532:	8d 48 01             	lea    0x1(%eax),%ecx
f0120535:	8b 55 14             	mov    0x14(%ebp),%edx
f0120538:	89 0a                	mov    %ecx,(%edx)
f012053a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120541:	8b 45 10             	mov    0x10(%ebp),%eax
f0120544:	01 c2                	add    %eax,%edx
f0120546:	8b 45 08             	mov    0x8(%ebp),%eax
f0120549:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f012054b:	eb 03                	jmp    f0120550 <strsplit+0x8f>
			string++;
f012054d:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120550:	8b 45 08             	mov    0x8(%ebp),%eax
f0120553:	8a 00                	mov    (%eax),%al
f0120555:	84 c0                	test   %al,%al
f0120557:	74 8b                	je     f01204e4 <strsplit+0x23>
f0120559:	8b 45 08             	mov    0x8(%ebp),%eax
f012055c:	8a 00                	mov    (%eax),%al
f012055e:	0f be c0             	movsbl %al,%eax
f0120561:	50                   	push   %eax
f0120562:	ff 75 0c             	pushl  0xc(%ebp)
f0120565:	e8 d4 fa ff ff       	call   f012003e <strchr>
f012056a:	83 c4 08             	add    $0x8,%esp
f012056d:	85 c0                	test   %eax,%eax
f012056f:	74 dc                	je     f012054d <strsplit+0x8c>
			string++;
	}
f0120571:	e9 6e ff ff ff       	jmp    f01204e4 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0120576:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0120577:	8b 45 14             	mov    0x14(%ebp),%eax
f012057a:	8b 00                	mov    (%eax),%eax
f012057c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120583:	8b 45 10             	mov    0x10(%ebp),%eax
f0120586:	01 d0                	add    %edx,%eax
f0120588:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f012058e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120593:	c9                   	leave  
f0120594:	c3                   	ret    

f0120595 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0120595:	55                   	push   %ebp
f0120596:	89 e5                	mov    %esp,%ebp
f0120598:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f012059b:	83 ec 04             	sub    $0x4,%esp
f012059e:	68 1c 19 13 f0       	push   $0xf013191c
f01205a3:	68 3f 01 00 00       	push   $0x13f
f01205a8:	68 3e 19 13 f0       	push   $0xf013193e
f01205ad:	e8 87 fd fd ff       	call   f0100339 <_panic>

f01205b2 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f01205b2:	55                   	push   %ebp
f01205b3:	89 e5                	mov    %esp,%ebp
f01205b5:	83 ec 18             	sub    $0x18,%esp
f01205b8:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01205bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01205c2:	89 c2                	mov    %eax,%edx
f01205c4:	ec                   	in     (%dx),%al
f01205c5:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01205c8:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01205cb:	0f b6 c0             	movzbl %al,%eax
f01205ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01205d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01205d4:	25 c0 00 00 00       	and    $0xc0,%eax
f01205d9:	83 f8 40             	cmp    $0x40,%eax
f01205dc:	75 10                	jne    f01205ee <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f01205de:	83 ec 0c             	sub    $0xc,%esp
f01205e1:	68 80 ef 71 f0       	push   $0xf071ef80
f01205e6:	e8 6d fd fe ff       	call   f0110358 <wakeup_one>
f01205eb:	83 c4 10             	add    $0x10,%esp
	}

}
f01205ee:	90                   	nop
f01205ef:	c9                   	leave  
f01205f0:	c3                   	ret    

f01205f1 <ide_init>:

void ide_init()
{
f01205f1:	55                   	push   %ebp
f01205f2:	89 e5                	mov    %esp,%ebp
f01205f4:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f01205f7:	83 ec 08             	sub    $0x8,%esp
f01205fa:	68 b2 05 12 f0       	push   $0xf01205b2
f01205ff:	6a 0e                	push   $0xe
f0120601:	e8 03 df fe ff       	call   f010e509 <irq_install_handler>
f0120606:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120609:	83 ec 08             	sub    $0x8,%esp
f012060c:	68 4c 19 13 f0       	push   $0xf013194c
f0120611:	68 80 ef 71 f0       	push   $0xf071ef80
f0120616:	e8 a3 fc fe ff       	call   f01102be <init_channel>
f012061b:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f012061e:	83 ec 08             	sub    $0x8,%esp
f0120621:	68 59 19 13 f0       	push   $0xf0131959
f0120626:	68 a0 f5 b1 f0       	push   $0xf0b1f5a0
f012062b:	e8 9d f8 fe ff       	call   f010fecd <init_spinlock>
f0120630:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0120633:	90                   	nop
f0120634:	c9                   	leave  
f0120635:	c3                   	ret    

f0120636 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0120636:	55                   	push   %ebp
f0120637:	89 e5                	mov    %esp,%ebp
f0120639:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f012063c:	90                   	nop
f012063d:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120644:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120647:	89 c2                	mov    %eax,%edx
f0120649:	ec                   	in     (%dx),%al
f012064a:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f012064d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0120650:	0f b6 c0             	movzbl %al,%eax
f0120653:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120656:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120659:	25 c0 00 00 00       	and    $0xc0,%eax
f012065e:	83 f8 40             	cmp    $0x40,%eax
f0120661:	75 da                	jne    f012063d <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0120663:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120667:	74 24                	je     f012068d <ide_wait_ready+0x57>
f0120669:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012066c:	83 e0 21             	and    $0x21,%eax
f012066f:	85 c0                	test   %eax,%eax
f0120671:	74 1a                	je     f012068d <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0120673:	83 ec 0c             	sub    $0xc,%esp
f0120676:	ff 75 f4             	pushl  -0xc(%ebp)
f0120679:	ff 75 f4             	pushl  -0xc(%ebp)
f012067c:	68 6c 19 13 f0       	push   $0xf013196c
f0120681:	6a 5d                	push   $0x5d
f0120683:	68 8f 19 13 f0       	push   $0xf013198f
f0120688:	e8 ac fc fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f012068d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120692:	c9                   	leave  
f0120693:	c3                   	ret    

f0120694 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0120694:	55                   	push   %ebp
f0120695:	89 e5                	mov    %esp,%ebp
f0120697:	57                   	push   %edi
f0120698:	53                   	push   %ebx
f0120699:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f012069c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01206a3:	76 16                	jbe    f01206bb <ide_read+0x27>
f01206a5:	68 9a 19 13 f0       	push   $0xf013199a
f01206aa:	68 a7 19 13 f0       	push   $0xf01319a7
f01206af:	6a 68                	push   $0x68
f01206b1:	68 8f 19 13 f0       	push   $0xf013198f
f01206b6:	e8 7e fc fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f01206bb:	83 ec 0c             	sub    $0xc,%esp
f01206be:	6a 00                	push   $0x0
f01206c0:	e8 71 ff ff ff       	call   f0120636 <ide_wait_ready>
f01206c5:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f01206c8:	8b 45 10             	mov    0x10(%ebp),%eax
f01206cb:	0f b6 c0             	movzbl %al,%eax
f01206ce:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01206d5:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01206d8:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01206db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01206de:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01206df:	8b 45 08             	mov    0x8(%ebp),%eax
f01206e2:	0f b6 c0             	movzbl %al,%eax
f01206e5:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f01206ec:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01206ef:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01206f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01206f5:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01206f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01206f9:	c1 e8 08             	shr    $0x8,%eax
f01206fc:	0f b6 c0             	movzbl %al,%eax
f01206ff:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120706:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120709:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012070c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012070f:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120710:	8b 45 08             	mov    0x8(%ebp),%eax
f0120713:	c1 e8 10             	shr    $0x10,%eax
f0120716:	0f b6 c0             	movzbl %al,%eax
f0120719:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120720:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120723:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120726:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120729:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f012072a:	a1 30 ee 71 f0       	mov    0xf071ee30,%eax
f012072f:	83 e0 01             	and    $0x1,%eax
f0120732:	c1 e0 04             	shl    $0x4,%eax
f0120735:	88 c2                	mov    %al,%dl
f0120737:	8b 45 08             	mov    0x8(%ebp),%eax
f012073a:	c1 e8 18             	shr    $0x18,%eax
f012073d:	83 e0 0f             	and    $0xf,%eax
f0120740:	09 d0                	or     %edx,%eax
f0120742:	83 c8 e0             	or     $0xffffffe0,%eax
f0120745:	0f b6 c0             	movzbl %al,%eax
f0120748:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f012074f:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120752:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120755:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120758:	ee                   	out    %al,(%dx)
f0120759:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120760:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0120764:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120767:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012076a:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f012076b:	eb 55                	jmp    f01207c2 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f012076d:	83 ec 0c             	sub    $0xc,%esp
f0120770:	6a 01                	push   $0x1
f0120772:	e8 bf fe ff ff       	call   f0120636 <ide_wait_ready>
f0120777:	83 c4 10             	add    $0x10,%esp
f012077a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f012077d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120781:	79 05                	jns    f0120788 <ide_read+0xf4>
			return r;
f0120783:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120786:	eb 45                	jmp    f01207cd <ide_read+0x139>
f0120788:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f012078f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120792:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120795:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f012079c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012079f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f01207a2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01207a5:	89 cb                	mov    %ecx,%ebx
f01207a7:	89 df                	mov    %ebx,%edi
f01207a9:	89 c1                	mov    %eax,%ecx
f01207ab:	fc                   	cld    
f01207ac:	f2 6d                	repnz insl (%dx),%es:(%edi)
f01207ae:	89 c8                	mov    %ecx,%eax
f01207b0:	89 fb                	mov    %edi,%ebx
f01207b2:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01207b5:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01207b8:	ff 4d 10             	decl   0x10(%ebp)
f01207bb:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f01207c2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01207c6:	75 a5                	jne    f012076d <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f01207c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01207cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01207d0:	5b                   	pop    %ebx
f01207d1:	5f                   	pop    %edi
f01207d2:	5d                   	pop    %ebp
f01207d3:	c3                   	ret    

f01207d4 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f01207d4:	55                   	push   %ebp
f01207d5:	89 e5                	mov    %esp,%ebp
f01207d7:	56                   	push   %esi
f01207d8:	53                   	push   %ebx
f01207d9:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f01207dc:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01207e3:	76 19                	jbe    f01207fe <ide_write+0x2a>
f01207e5:	68 9a 19 13 f0       	push   $0xf013199a
f01207ea:	68 a7 19 13 f0       	push   $0xf01319a7
f01207ef:	68 82 00 00 00       	push   $0x82
f01207f4:	68 8f 19 13 f0       	push   $0xf013198f
f01207f9:	e8 3b fb fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f01207fe:	83 ec 0c             	sub    $0xc,%esp
f0120801:	6a 00                	push   $0x0
f0120803:	e8 2e fe ff ff       	call   f0120636 <ide_wait_ready>
f0120808:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f012080b:	8b 45 10             	mov    0x10(%ebp),%eax
f012080e:	0f b6 c0             	movzbl %al,%eax
f0120811:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120818:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012081b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012081e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120821:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120822:	8b 45 08             	mov    0x8(%ebp),%eax
f0120825:	0f b6 c0             	movzbl %al,%eax
f0120828:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012082f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120832:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120835:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120838:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120839:	8b 45 08             	mov    0x8(%ebp),%eax
f012083c:	c1 e8 08             	shr    $0x8,%eax
f012083f:	0f b6 c0             	movzbl %al,%eax
f0120842:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120849:	88 45 d4             	mov    %al,-0x2c(%ebp)
f012084c:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012084f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120852:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120853:	8b 45 08             	mov    0x8(%ebp),%eax
f0120856:	c1 e8 10             	shr    $0x10,%eax
f0120859:	0f b6 c0             	movzbl %al,%eax
f012085c:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120863:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120866:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120869:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012086c:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f012086d:	a1 30 ee 71 f0       	mov    0xf071ee30,%eax
f0120872:	83 e0 01             	and    $0x1,%eax
f0120875:	c1 e0 04             	shl    $0x4,%eax
f0120878:	88 c2                	mov    %al,%dl
f012087a:	8b 45 08             	mov    0x8(%ebp),%eax
f012087d:	c1 e8 18             	shr    $0x18,%eax
f0120880:	83 e0 0f             	and    $0xf,%eax
f0120883:	09 d0                	or     %edx,%eax
f0120885:	83 c8 e0             	or     $0xffffffe0,%eax
f0120888:	0f b6 c0             	movzbl %al,%eax
f012088b:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120892:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120895:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120898:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012089b:	ee                   	out    %al,(%dx)
f012089c:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01208a3:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f01208a7:	8a 45 d7             	mov    -0x29(%ebp),%al
f01208aa:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01208ad:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01208ae:	eb 55                	jmp    f0120905 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f01208b0:	83 ec 0c             	sub    $0xc,%esp
f01208b3:	6a 01                	push   $0x1
f01208b5:	e8 7c fd ff ff       	call   f0120636 <ide_wait_ready>
f01208ba:	83 c4 10             	add    $0x10,%esp
f01208bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01208c0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01208c4:	79 05                	jns    f01208cb <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f01208c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208c9:	eb 45                	jmp    f0120910 <ide_write+0x13c>
f01208cb:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01208d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01208d8:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f01208df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01208e2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f01208e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01208e8:	89 cb                	mov    %ecx,%ebx
f01208ea:	89 de                	mov    %ebx,%esi
f01208ec:	89 c1                	mov    %eax,%ecx
f01208ee:	fc                   	cld    
f01208ef:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f01208f1:	89 c8                	mov    %ecx,%eax
f01208f3:	89 f3                	mov    %esi,%ebx
f01208f5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01208f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01208fb:	ff 4d 10             	decl   0x10(%ebp)
f01208fe:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120905:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120909:	75 a5                	jne    f01208b0 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f012090b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120910:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120913:	5b                   	pop    %ebx
f0120914:	5e                   	pop    %esi
f0120915:	5d                   	pop    %ebp
f0120916:	c3                   	ret    

f0120917 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120917:	55                   	push   %ebp
f0120918:	89 e5                	mov    %esp,%ebp
f012091a:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f012091d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120920:	83 e8 04             	sub    $0x4,%eax
f0120923:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120926:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120929:	8b 00                	mov    (%eax),%eax
f012092b:	83 e0 fe             	and    $0xfffffffe,%eax
}
f012092e:	c9                   	leave  
f012092f:	c3                   	ret    

f0120930 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120930:	55                   	push   %ebp
f0120931:	89 e5                	mov    %esp,%ebp
f0120933:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120936:	8b 45 08             	mov    0x8(%ebp),%eax
f0120939:	83 e8 04             	sub    $0x4,%eax
f012093c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f012093f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120942:	8b 00                	mov    (%eax),%eax
f0120944:	83 e0 01             	and    $0x1,%eax
f0120947:	85 c0                	test   %eax,%eax
f0120949:	0f 94 c0             	sete   %al
}
f012094c:	c9                   	leave  
f012094d:	c3                   	ret    

f012094e <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f012094e:	55                   	push   %ebp
f012094f:	89 e5                	mov    %esp,%ebp
f0120951:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120954:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f012095b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012095e:	83 f8 02             	cmp    $0x2,%eax
f0120961:	74 2b                	je     f012098e <alloc_block+0x40>
f0120963:	83 f8 02             	cmp    $0x2,%eax
f0120966:	7f 07                	jg     f012096f <alloc_block+0x21>
f0120968:	83 f8 01             	cmp    $0x1,%eax
f012096b:	74 0e                	je     f012097b <alloc_block+0x2d>
f012096d:	eb 58                	jmp    f01209c7 <alloc_block+0x79>
f012096f:	83 f8 03             	cmp    $0x3,%eax
f0120972:	74 2d                	je     f01209a1 <alloc_block+0x53>
f0120974:	83 f8 04             	cmp    $0x4,%eax
f0120977:	74 3b                	je     f01209b4 <alloc_block+0x66>
f0120979:	eb 4c                	jmp    f01209c7 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f012097b:	83 ec 0c             	sub    $0xc,%esp
f012097e:	ff 75 08             	pushl  0x8(%ebp)
f0120981:	e8 11 03 00 00       	call   f0120c97 <alloc_block_FF>
f0120986:	83 c4 10             	add    $0x10,%esp
f0120989:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012098c:	eb 4a                	jmp    f01209d8 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f012098e:	83 ec 0c             	sub    $0xc,%esp
f0120991:	ff 75 08             	pushl  0x8(%ebp)
f0120994:	e8 c7 19 00 00       	call   f0122360 <alloc_block_NF>
f0120999:	83 c4 10             	add    $0x10,%esp
f012099c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012099f:	eb 37                	jmp    f01209d8 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01209a1:	83 ec 0c             	sub    $0xc,%esp
f01209a4:	ff 75 08             	pushl  0x8(%ebp)
f01209a7:	e8 a7 07 00 00       	call   f0121153 <alloc_block_BF>
f01209ac:	83 c4 10             	add    $0x10,%esp
f01209af:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01209b2:	eb 24                	jmp    f01209d8 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f01209b4:	83 ec 0c             	sub    $0xc,%esp
f01209b7:	ff 75 08             	pushl  0x8(%ebp)
f01209ba:	e8 84 19 00 00       	call   f0122343 <alloc_block_WF>
f01209bf:	83 c4 10             	add    $0x10,%esp
f01209c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01209c5:	eb 11                	jmp    f01209d8 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f01209c7:	83 ec 0c             	sub    $0xc,%esp
f01209ca:	68 bc 19 13 f0       	push   $0xf01319bc
f01209cf:	e8 b7 05 fe ff       	call   f0100f8b <cprintf>
f01209d4:	83 c4 10             	add    $0x10,%esp
		break;
f01209d7:	90                   	nop
	}
	return va;
f01209d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01209db:	c9                   	leave  
f01209dc:	c3                   	ret    

f01209dd <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f01209dd:	55                   	push   %ebp
f01209de:	89 e5                	mov    %esp,%ebp
f01209e0:	53                   	push   %ebx
f01209e1:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f01209e4:	83 ec 0c             	sub    $0xc,%esp
f01209e7:	68 dc 19 13 f0       	push   $0xf01319dc
f01209ec:	e8 9a 05 fe ff       	call   f0100f8b <cprintf>
f01209f1:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f01209f4:	83 ec 0c             	sub    $0xc,%esp
f01209f7:	68 07 1a 13 f0       	push   $0xf0131a07
f01209fc:	e8 8a 05 fe ff       	call   f0100f8b <cprintf>
f0120a01:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120a04:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a07:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120a0a:	eb 37                	jmp    f0120a43 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120a0c:	83 ec 0c             	sub    $0xc,%esp
f0120a0f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120a12:	e8 19 ff ff ff       	call   f0120930 <is_free_block>
f0120a17:	83 c4 10             	add    $0x10,%esp
f0120a1a:	0f be d8             	movsbl %al,%ebx
f0120a1d:	83 ec 0c             	sub    $0xc,%esp
f0120a20:	ff 75 f4             	pushl  -0xc(%ebp)
f0120a23:	e8 ef fe ff ff       	call   f0120917 <get_block_size>
f0120a28:	83 c4 10             	add    $0x10,%esp
f0120a2b:	83 ec 04             	sub    $0x4,%esp
f0120a2e:	53                   	push   %ebx
f0120a2f:	50                   	push   %eax
f0120a30:	68 1f 1a 13 f0       	push   $0xf0131a1f
f0120a35:	e8 51 05 fe ff       	call   f0100f8b <cprintf>
f0120a3a:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120a3d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120a40:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120a43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120a47:	74 07                	je     f0120a50 <print_blocks_list+0x73>
f0120a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a4c:	8b 00                	mov    (%eax),%eax
f0120a4e:	eb 05                	jmp    f0120a55 <print_blocks_list+0x78>
f0120a50:	b8 00 00 00 00       	mov    $0x0,%eax
f0120a55:	89 45 10             	mov    %eax,0x10(%ebp)
f0120a58:	8b 45 10             	mov    0x10(%ebp),%eax
f0120a5b:	85 c0                	test   %eax,%eax
f0120a5d:	75 ad                	jne    f0120a0c <print_blocks_list+0x2f>
f0120a5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120a63:	75 a7                	jne    f0120a0c <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0120a65:	83 ec 0c             	sub    $0xc,%esp
f0120a68:	68 dc 19 13 f0       	push   $0xf01319dc
f0120a6d:	e8 19 05 fe ff       	call   f0100f8b <cprintf>
f0120a72:	83 c4 10             	add    $0x10,%esp

}
f0120a75:	90                   	nop
f0120a76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120a79:	c9                   	leave  
f0120a7a:	c3                   	ret    

f0120a7b <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120a7b:	55                   	push   %ebp
f0120a7c:	89 e5                	mov    %esp,%ebp
f0120a7e:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0120a81:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a84:	83 e0 01             	and    $0x1,%eax
f0120a87:	85 c0                	test   %eax,%eax
f0120a89:	74 03                	je     f0120a8e <initialize_dynamic_allocator+0x13>
f0120a8b:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f0120a8e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120a92:	0f 84 c7 01 00 00    	je     f0120c5f <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f0120a98:	c7 05 34 ee 71 f0 01 	movl   $0x1,0xf071ee34
f0120a9f:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0120aa2:	8b 55 08             	mov    0x8(%ebp),%edx
f0120aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aa8:	01 d0                	add    %edx,%eax
f0120aaa:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0120aaf:	0f 87 ad 01 00 00    	ja     f0120c62 <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f0120ab5:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ab8:	85 c0                	test   %eax,%eax
f0120aba:	0f 89 a5 01 00 00    	jns    f0120c65 <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f0120ac0:	8b 55 08             	mov    0x8(%ebp),%edx
f0120ac3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ac6:	01 d0                	add    %edx,%eax
f0120ac8:	83 e8 04             	sub    $0x4,%eax
f0120acb:	a3 f4 f7 f1 f0       	mov    %eax,0xf0f1f7f4
     struct BlockElement * element = NULL;
f0120ad0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120ad7:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120adf:	e9 87 00 00 00       	jmp    f0120b6b <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120ae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ae8:	75 14                	jne    f0120afe <initialize_dynamic_allocator+0x83>
f0120aea:	83 ec 04             	sub    $0x4,%esp
f0120aed:	68 37 1a 13 f0       	push   $0xf0131a37
f0120af2:	6a 79                	push   $0x79
f0120af4:	68 55 1a 13 f0       	push   $0xf0131a55
f0120af9:	e8 3b f8 fd ff       	call   f0100339 <_panic>
f0120afe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b01:	8b 00                	mov    (%eax),%eax
f0120b03:	85 c0                	test   %eax,%eax
f0120b05:	74 10                	je     f0120b17 <initialize_dynamic_allocator+0x9c>
f0120b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b0a:	8b 00                	mov    (%eax),%eax
f0120b0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120b0f:	8b 52 04             	mov    0x4(%edx),%edx
f0120b12:	89 50 04             	mov    %edx,0x4(%eax)
f0120b15:	eb 0b                	jmp    f0120b22 <initialize_dynamic_allocator+0xa7>
f0120b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b1a:	8b 40 04             	mov    0x4(%eax),%eax
f0120b1d:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b25:	8b 40 04             	mov    0x4(%eax),%eax
f0120b28:	85 c0                	test   %eax,%eax
f0120b2a:	74 0f                	je     f0120b3b <initialize_dynamic_allocator+0xc0>
f0120b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b2f:	8b 40 04             	mov    0x4(%eax),%eax
f0120b32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120b35:	8b 12                	mov    (%edx),%edx
f0120b37:	89 10                	mov    %edx,(%eax)
f0120b39:	eb 0a                	jmp    f0120b45 <initialize_dynamic_allocator+0xca>
f0120b3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b3e:	8b 00                	mov    (%eax),%eax
f0120b40:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b48:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b51:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b58:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120b5d:	48                   	dec    %eax
f0120b5e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f0120b63:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0120b68:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120b6b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120b6f:	74 07                	je     f0120b78 <initialize_dynamic_allocator+0xfd>
f0120b71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b74:	8b 00                	mov    (%eax),%eax
f0120b76:	eb 05                	jmp    f0120b7d <initialize_dynamic_allocator+0x102>
f0120b78:	b8 00 00 00 00       	mov    $0x0,%eax
f0120b7d:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0120b82:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0120b87:	85 c0                	test   %eax,%eax
f0120b89:	0f 85 55 ff ff ff    	jne    f0120ae4 <initialize_dynamic_allocator+0x69>
f0120b8f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120b93:	0f 85 4b ff ff ff    	jne    f0120ae4 <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f0120b99:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f0120b9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ba2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f0120ba8:	a1 f4 f7 f1 f0       	mov    0xf0f1f7f4,%eax
f0120bad:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
    end_block->info = 1;
f0120bb2:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f0120bb7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0120bbd:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bc0:	83 c0 08             	add    $0x8,%eax
f0120bc3:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120bc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bc9:	83 c0 04             	add    $0x4,%eax
f0120bcc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120bcf:	83 ea 08             	sub    $0x8,%edx
f0120bd2:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120bd4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120bd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bda:	01 d0                	add    %edx,%eax
f0120bdc:	83 e8 08             	sub    $0x8,%eax
f0120bdf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120be2:	83 ea 08             	sub    $0x8,%edx
f0120be5:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120be7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120bea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120bf3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120bfa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120bfe:	75 17                	jne    f0120c17 <initialize_dynamic_allocator+0x19c>
f0120c00:	83 ec 04             	sub    $0x4,%esp
f0120c03:	68 70 1a 13 f0       	push   $0xf0131a70
f0120c08:	68 90 00 00 00       	push   $0x90
f0120c0d:	68 55 1a 13 f0       	push   $0xf0131a55
f0120c12:	e8 22 f7 fd ff       	call   f0100339 <_panic>
f0120c17:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0120c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c20:	89 10                	mov    %edx,(%eax)
f0120c22:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c25:	8b 00                	mov    (%eax),%eax
f0120c27:	85 c0                	test   %eax,%eax
f0120c29:	74 0d                	je     f0120c38 <initialize_dynamic_allocator+0x1bd>
f0120c2b:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120c30:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120c33:	89 50 04             	mov    %edx,0x4(%eax)
f0120c36:	eb 08                	jmp    f0120c40 <initialize_dynamic_allocator+0x1c5>
f0120c38:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c3b:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120c40:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c43:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120c48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c4b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c52:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120c57:	40                   	inc    %eax
f0120c58:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120c5d:	eb 07                	jmp    f0120c66 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120c5f:	90                   	nop
f0120c60:	eb 04                	jmp    f0120c66 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f0120c62:	90                   	nop
f0120c63:	eb 01                	jmp    f0120c66 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120c65:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120c66:	c9                   	leave  
f0120c67:	c3                   	ret    

f0120c68 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120c68:	55                   	push   %ebp
f0120c69:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120c6b:	8b 45 10             	mov    0x10(%ebp),%eax
f0120c6e:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120c71:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c74:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120c77:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120c7a:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120c7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c7f:	83 e8 04             	sub    $0x4,%eax
f0120c82:	8b 00                	mov    (%eax),%eax
f0120c84:	83 e0 fe             	and    $0xfffffffe,%eax
f0120c87:	8d 50 f8             	lea    -0x8(%eax),%edx
f0120c8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c8d:	01 c2                	add    %eax,%edx
f0120c8f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120c92:	89 02                	mov    %eax,(%edx)
}
f0120c94:	90                   	nop
f0120c95:	5d                   	pop    %ebp
f0120c96:	c3                   	ret    

f0120c97 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120c97:	55                   	push   %ebp
f0120c98:	89 e5                	mov    %esp,%ebp
f0120c9a:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120c9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ca0:	83 e0 01             	and    $0x1,%eax
f0120ca3:	85 c0                	test   %eax,%eax
f0120ca5:	74 03                	je     f0120caa <alloc_block_FF+0x13>
f0120ca7:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120caa:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120cae:	77 07                	ja     f0120cb7 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120cb0:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120cb7:	a1 34 ee 71 f0       	mov    0xf071ee34,%eax
f0120cbc:	85 c0                	test   %eax,%eax
f0120cbe:	75 73                	jne    f0120d33 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120cc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0120cc3:	83 c0 10             	add    $0x10,%eax
f0120cc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120cc9:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120cd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120cd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120cd6:	01 d0                	add    %edx,%eax
f0120cd8:	48                   	dec    %eax
f0120cd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120cdc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120cdf:	ba 00 00 00 00       	mov    $0x0,%edx
f0120ce4:	f7 75 ec             	divl   -0x14(%ebp)
f0120ce7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120cea:	29 d0                	sub    %edx,%eax
f0120cec:	c1 e8 0c             	shr    $0xc,%eax
f0120cef:	83 ec 0c             	sub    $0xc,%esp
f0120cf2:	50                   	push   %eax
f0120cf3:	e8 8f 89 fe ff       	call   f0109687 <sbrk>
f0120cf8:	83 c4 10             	add    $0x10,%esp
f0120cfb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120cfe:	83 ec 0c             	sub    $0xc,%esp
f0120d01:	6a 00                	push   $0x0
f0120d03:	e8 7f 89 fe ff       	call   f0109687 <sbrk>
f0120d08:	83 c4 10             	add    $0x10,%esp
f0120d0b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120d0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120d11:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120d14:	83 ec 08             	sub    $0x8,%esp
f0120d17:	50                   	push   %eax
f0120d18:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120d1b:	e8 5b fd ff ff       	call   f0120a7b <initialize_dynamic_allocator>
f0120d20:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120d23:	83 ec 0c             	sub    $0xc,%esp
f0120d26:	68 93 1a 13 f0       	push   $0xf0131a93
f0120d2b:	e8 5b 02 fe ff       	call   f0100f8b <cprintf>
f0120d30:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120d33:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120d37:	75 0a                	jne    f0120d43 <alloc_block_FF+0xac>
	        return NULL;
f0120d39:	b8 00 00 00 00       	mov    $0x0,%eax
f0120d3e:	e9 0e 04 00 00       	jmp    f0121151 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120d43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120d4a:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120d4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120d52:	e9 f3 02 00 00       	jmp    f012104a <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d5a:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120d5d:	83 ec 0c             	sub    $0xc,%esp
f0120d60:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d63:	e8 af fb ff ff       	call   f0120917 <get_block_size>
f0120d68:	83 c4 10             	add    $0x10,%esp
f0120d6b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120d6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d71:	83 c0 08             	add    $0x8,%eax
f0120d74:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120d77:	0f 87 c5 02 00 00    	ja     f0121042 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120d7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d80:	83 c0 18             	add    $0x18,%eax
f0120d83:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120d86:	0f 87 19 02 00 00    	ja     f0120fa5 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120d8c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120d8f:	2b 45 08             	sub    0x8(%ebp),%eax
f0120d92:	83 e8 08             	sub    $0x8,%eax
f0120d95:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120d98:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d9b:	8d 50 08             	lea    0x8(%eax),%edx
f0120d9e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120da1:	01 d0                	add    %edx,%eax
f0120da3:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120da6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120da9:	83 c0 08             	add    $0x8,%eax
f0120dac:	83 ec 04             	sub    $0x4,%esp
f0120daf:	6a 01                	push   $0x1
f0120db1:	50                   	push   %eax
f0120db2:	ff 75 bc             	pushl  -0x44(%ebp)
f0120db5:	e8 ae fe ff ff       	call   f0120c68 <set_block_data>
f0120dba:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dc0:	8b 40 04             	mov    0x4(%eax),%eax
f0120dc3:	85 c0                	test   %eax,%eax
f0120dc5:	75 68                	jne    f0120e2f <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120dc7:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120dcb:	75 17                	jne    f0120de4 <alloc_block_FF+0x14d>
f0120dcd:	83 ec 04             	sub    $0x4,%esp
f0120dd0:	68 70 1a 13 f0       	push   $0xf0131a70
f0120dd5:	68 d7 00 00 00       	push   $0xd7
f0120dda:	68 55 1a 13 f0       	push   $0xf0131a55
f0120ddf:	e8 55 f5 fd ff       	call   f0100339 <_panic>
f0120de4:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0120dea:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ded:	89 10                	mov    %edx,(%eax)
f0120def:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120df2:	8b 00                	mov    (%eax),%eax
f0120df4:	85 c0                	test   %eax,%eax
f0120df6:	74 0d                	je     f0120e05 <alloc_block_FF+0x16e>
f0120df8:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120dfd:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120e00:	89 50 04             	mov    %edx,0x4(%eax)
f0120e03:	eb 08                	jmp    f0120e0d <alloc_block_FF+0x176>
f0120e05:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e08:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120e0d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e10:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120e15:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e18:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120e1f:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120e24:	40                   	inc    %eax
f0120e25:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120e2a:	e9 dc 00 00 00       	jmp    f0120f0b <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e32:	8b 00                	mov    (%eax),%eax
f0120e34:	85 c0                	test   %eax,%eax
f0120e36:	75 65                	jne    f0120e9d <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120e38:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120e3c:	75 17                	jne    f0120e55 <alloc_block_FF+0x1be>
f0120e3e:	83 ec 04             	sub    $0x4,%esp
f0120e41:	68 a4 1a 13 f0       	push   $0xf0131aa4
f0120e46:	68 db 00 00 00       	push   $0xdb
f0120e4b:	68 55 1a 13 f0       	push   $0xf0131a55
f0120e50:	e8 e4 f4 fd ff       	call   f0100339 <_panic>
f0120e55:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0120e5b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e5e:	89 50 04             	mov    %edx,0x4(%eax)
f0120e61:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e64:	8b 40 04             	mov    0x4(%eax),%eax
f0120e67:	85 c0                	test   %eax,%eax
f0120e69:	74 0c                	je     f0120e77 <alloc_block_FF+0x1e0>
f0120e6b:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0120e70:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120e73:	89 10                	mov    %edx,(%eax)
f0120e75:	eb 08                	jmp    f0120e7f <alloc_block_FF+0x1e8>
f0120e77:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e7a:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120e7f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e82:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120e87:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e8a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120e90:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120e95:	40                   	inc    %eax
f0120e96:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120e9b:	eb 6e                	jmp    f0120f0b <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120e9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ea1:	74 06                	je     f0120ea9 <alloc_block_FF+0x212>
f0120ea3:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120ea7:	75 17                	jne    f0120ec0 <alloc_block_FF+0x229>
f0120ea9:	83 ec 04             	sub    $0x4,%esp
f0120eac:	68 c8 1a 13 f0       	push   $0xf0131ac8
f0120eb1:	68 df 00 00 00       	push   $0xdf
f0120eb6:	68 55 1a 13 f0       	push   $0xf0131a55
f0120ebb:	e8 79 f4 fd ff       	call   f0100339 <_panic>
f0120ec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ec3:	8b 10                	mov    (%eax),%edx
f0120ec5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ec8:	89 10                	mov    %edx,(%eax)
f0120eca:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ecd:	8b 00                	mov    (%eax),%eax
f0120ecf:	85 c0                	test   %eax,%eax
f0120ed1:	74 0b                	je     f0120ede <alloc_block_FF+0x247>
f0120ed3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ed6:	8b 00                	mov    (%eax),%eax
f0120ed8:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120edb:	89 50 04             	mov    %edx,0x4(%eax)
f0120ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ee1:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120ee4:	89 10                	mov    %edx,(%eax)
f0120ee6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120eec:	89 50 04             	mov    %edx,0x4(%eax)
f0120eef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ef2:	8b 00                	mov    (%eax),%eax
f0120ef4:	85 c0                	test   %eax,%eax
f0120ef6:	75 08                	jne    f0120f00 <alloc_block_FF+0x269>
f0120ef8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120efb:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120f00:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120f05:	40                   	inc    %eax
f0120f06:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120f0f:	75 17                	jne    f0120f28 <alloc_block_FF+0x291>
f0120f11:	83 ec 04             	sub    $0x4,%esp
f0120f14:	68 37 1a 13 f0       	push   $0xf0131a37
f0120f19:	68 e1 00 00 00       	push   $0xe1
f0120f1e:	68 55 1a 13 f0       	push   $0xf0131a55
f0120f23:	e8 11 f4 fd ff       	call   f0100339 <_panic>
f0120f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f2b:	8b 00                	mov    (%eax),%eax
f0120f2d:	85 c0                	test   %eax,%eax
f0120f2f:	74 10                	je     f0120f41 <alloc_block_FF+0x2aa>
f0120f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f34:	8b 00                	mov    (%eax),%eax
f0120f36:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120f39:	8b 52 04             	mov    0x4(%edx),%edx
f0120f3c:	89 50 04             	mov    %edx,0x4(%eax)
f0120f3f:	eb 0b                	jmp    f0120f4c <alloc_block_FF+0x2b5>
f0120f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f44:	8b 40 04             	mov    0x4(%eax),%eax
f0120f47:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f4f:	8b 40 04             	mov    0x4(%eax),%eax
f0120f52:	85 c0                	test   %eax,%eax
f0120f54:	74 0f                	je     f0120f65 <alloc_block_FF+0x2ce>
f0120f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f59:	8b 40 04             	mov    0x4(%eax),%eax
f0120f5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120f5f:	8b 12                	mov    (%edx),%edx
f0120f61:	89 10                	mov    %edx,(%eax)
f0120f63:	eb 0a                	jmp    f0120f6f <alloc_block_FF+0x2d8>
f0120f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f68:	8b 00                	mov    (%eax),%eax
f0120f6a:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120f6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f7b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120f82:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120f87:	48                   	dec    %eax
f0120f88:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				set_block_data(new_block_va, remaining_size, 0);
f0120f8d:	83 ec 04             	sub    $0x4,%esp
f0120f90:	6a 00                	push   $0x0
f0120f92:	ff 75 b4             	pushl  -0x4c(%ebp)
f0120f95:	ff 75 b0             	pushl  -0x50(%ebp)
f0120f98:	e8 cb fc ff ff       	call   f0120c68 <set_block_data>
f0120f9d:	83 c4 10             	add    $0x10,%esp
f0120fa0:	e9 95 00 00 00       	jmp    f012103a <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0120fa5:	83 ec 04             	sub    $0x4,%esp
f0120fa8:	6a 01                	push   $0x1
f0120faa:	ff 75 b8             	pushl  -0x48(%ebp)
f0120fad:	ff 75 bc             	pushl  -0x44(%ebp)
f0120fb0:	e8 b3 fc ff ff       	call   f0120c68 <set_block_data>
f0120fb5:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120fbc:	75 17                	jne    f0120fd5 <alloc_block_FF+0x33e>
f0120fbe:	83 ec 04             	sub    $0x4,%esp
f0120fc1:	68 37 1a 13 f0       	push   $0xf0131a37
f0120fc6:	68 e8 00 00 00       	push   $0xe8
f0120fcb:	68 55 1a 13 f0       	push   $0xf0131a55
f0120fd0:	e8 64 f3 fd ff       	call   f0100339 <_panic>
f0120fd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fd8:	8b 00                	mov    (%eax),%eax
f0120fda:	85 c0                	test   %eax,%eax
f0120fdc:	74 10                	je     f0120fee <alloc_block_FF+0x357>
f0120fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fe1:	8b 00                	mov    (%eax),%eax
f0120fe3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fe6:	8b 52 04             	mov    0x4(%edx),%edx
f0120fe9:	89 50 04             	mov    %edx,0x4(%eax)
f0120fec:	eb 0b                	jmp    f0120ff9 <alloc_block_FF+0x362>
f0120fee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ff1:	8b 40 04             	mov    0x4(%eax),%eax
f0120ff4:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ffc:	8b 40 04             	mov    0x4(%eax),%eax
f0120fff:	85 c0                	test   %eax,%eax
f0121001:	74 0f                	je     f0121012 <alloc_block_FF+0x37b>
f0121003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121006:	8b 40 04             	mov    0x4(%eax),%eax
f0121009:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012100c:	8b 12                	mov    (%edx),%edx
f012100e:	89 10                	mov    %edx,(%eax)
f0121010:	eb 0a                	jmp    f012101c <alloc_block_FF+0x385>
f0121012:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121015:	8b 00                	mov    (%eax),%eax
f0121017:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f012101c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012101f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121028:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012102f:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121034:	48                   	dec    %eax
f0121035:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
	            }
	            return va;
f012103a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012103d:	e9 0f 01 00 00       	jmp    f0121151 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0121042:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121047:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012104a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012104e:	74 07                	je     f0121057 <alloc_block_FF+0x3c0>
f0121050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121053:	8b 00                	mov    (%eax),%eax
f0121055:	eb 05                	jmp    f012105c <alloc_block_FF+0x3c5>
f0121057:	b8 00 00 00 00       	mov    $0x0,%eax
f012105c:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0121061:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121066:	85 c0                	test   %eax,%eax
f0121068:	0f 85 e9 fc ff ff    	jne    f0120d57 <alloc_block_FF+0xc0>
f012106e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121072:	0f 85 df fc ff ff    	jne    f0120d57 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0121078:	8b 45 08             	mov    0x8(%ebp),%eax
f012107b:	83 c0 08             	add    $0x8,%eax
f012107e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0121081:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0121088:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012108b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012108e:	01 d0                	add    %edx,%eax
f0121090:	48                   	dec    %eax
f0121091:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0121094:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121097:	ba 00 00 00 00       	mov    $0x0,%edx
f012109c:	f7 75 d8             	divl   -0x28(%ebp)
f012109f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01210a2:	29 d0                	sub    %edx,%eax
f01210a4:	c1 e8 0c             	shr    $0xc,%eax
f01210a7:	83 ec 0c             	sub    $0xc,%esp
f01210aa:	50                   	push   %eax
f01210ab:	e8 d7 85 fe ff       	call   f0109687 <sbrk>
f01210b0:	83 c4 10             	add    $0x10,%esp
f01210b3:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f01210b6:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f01210ba:	75 0a                	jne    f01210c6 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f01210bc:	b8 00 00 00 00       	mov    $0x0,%eax
f01210c1:	e9 8b 00 00 00       	jmp    f0121151 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01210c6:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01210cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01210d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01210d3:	01 d0                	add    %edx,%eax
f01210d5:	48                   	dec    %eax
f01210d6:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01210d9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01210dc:	ba 00 00 00 00       	mov    $0x0,%edx
f01210e1:	f7 75 cc             	divl   -0x34(%ebp)
f01210e4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01210e7:	29 d0                	sub    %edx,%eax
f01210e9:	8d 50 fc             	lea    -0x4(%eax),%edx
f01210ec:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01210ef:	01 d0                	add    %edx,%eax
f01210f1:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
			end_block->info = 1;
f01210f6:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f01210fb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121101:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121108:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012110b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012110e:	01 d0                	add    %edx,%eax
f0121110:	48                   	dec    %eax
f0121111:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0121114:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121117:	ba 00 00 00 00       	mov    $0x0,%edx
f012111c:	f7 75 c4             	divl   -0x3c(%ebp)
f012111f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121122:	29 d0                	sub    %edx,%eax
f0121124:	83 ec 04             	sub    $0x4,%esp
f0121127:	6a 01                	push   $0x1
f0121129:	50                   	push   %eax
f012112a:	ff 75 d0             	pushl  -0x30(%ebp)
f012112d:	e8 36 fb ff ff       	call   f0120c68 <set_block_data>
f0121132:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0121135:	83 ec 0c             	sub    $0xc,%esp
f0121138:	ff 75 d0             	pushl  -0x30(%ebp)
f012113b:	e8 f8 09 00 00       	call   f0121b38 <free_block>
f0121140:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0121143:	83 ec 0c             	sub    $0xc,%esp
f0121146:	ff 75 08             	pushl  0x8(%ebp)
f0121149:	e8 49 fb ff ff       	call   f0120c97 <alloc_block_FF>
f012114e:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0121151:	c9                   	leave  
f0121152:	c3                   	ret    

f0121153 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0121153:	55                   	push   %ebp
f0121154:	89 e5                	mov    %esp,%ebp
f0121156:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0121159:	8b 45 08             	mov    0x8(%ebp),%eax
f012115c:	83 e0 01             	and    $0x1,%eax
f012115f:	85 c0                	test   %eax,%eax
f0121161:	74 03                	je     f0121166 <alloc_block_BF+0x13>
f0121163:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0121166:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f012116a:	77 07                	ja     f0121173 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f012116c:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0121173:	a1 34 ee 71 f0       	mov    0xf071ee34,%eax
f0121178:	85 c0                	test   %eax,%eax
f012117a:	75 73                	jne    f01211ef <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f012117c:	8b 45 08             	mov    0x8(%ebp),%eax
f012117f:	83 c0 10             	add    $0x10,%eax
f0121182:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0121185:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f012118c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012118f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121192:	01 d0                	add    %edx,%eax
f0121194:	48                   	dec    %eax
f0121195:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121198:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012119b:	ba 00 00 00 00       	mov    $0x0,%edx
f01211a0:	f7 75 e0             	divl   -0x20(%ebp)
f01211a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211a6:	29 d0                	sub    %edx,%eax
f01211a8:	c1 e8 0c             	shr    $0xc,%eax
f01211ab:	83 ec 0c             	sub    $0xc,%esp
f01211ae:	50                   	push   %eax
f01211af:	e8 d3 84 fe ff       	call   f0109687 <sbrk>
f01211b4:	83 c4 10             	add    $0x10,%esp
f01211b7:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f01211ba:	83 ec 0c             	sub    $0xc,%esp
f01211bd:	6a 00                	push   $0x0
f01211bf:	e8 c3 84 fe ff       	call   f0109687 <sbrk>
f01211c4:	83 c4 10             	add    $0x10,%esp
f01211c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01211ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01211cd:	2b 45 d8             	sub    -0x28(%ebp),%eax
f01211d0:	83 ec 08             	sub    $0x8,%esp
f01211d3:	50                   	push   %eax
f01211d4:	ff 75 d8             	pushl  -0x28(%ebp)
f01211d7:	e8 9f f8 ff ff       	call   f0120a7b <initialize_dynamic_allocator>
f01211dc:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f01211df:	83 ec 0c             	sub    $0xc,%esp
f01211e2:	68 93 1a 13 f0       	push   $0xf0131a93
f01211e7:	e8 9f fd fd ff       	call   f0100f8b <cprintf>
f01211ec:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f01211ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f01211f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f01211fd:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0121204:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f012120b:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121210:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121213:	e9 1d 01 00 00       	jmp    f0121335 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0121218:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012121b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f012121e:	83 ec 0c             	sub    $0xc,%esp
f0121221:	ff 75 a8             	pushl  -0x58(%ebp)
f0121224:	e8 ee f6 ff ff       	call   f0120917 <get_block_size>
f0121229:	83 c4 10             	add    $0x10,%esp
f012122c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f012122f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121232:	83 c0 08             	add    $0x8,%eax
f0121235:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121238:	0f 87 ef 00 00 00    	ja     f012132d <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f012123e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121241:	83 c0 18             	add    $0x18,%eax
f0121244:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121247:	77 1d                	ja     f0121266 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0121249:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012124c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012124f:	0f 86 d8 00 00 00    	jbe    f012132d <alloc_block_BF+0x1da>
				{
					best_va = va;
f0121255:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121258:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f012125b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012125e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121261:	e9 c7 00 00 00       	jmp    f012132d <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f0121266:	8b 45 08             	mov    0x8(%ebp),%eax
f0121269:	83 c0 08             	add    $0x8,%eax
f012126c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012126f:	0f 85 9d 00 00 00    	jne    f0121312 <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f0121275:	83 ec 04             	sub    $0x4,%esp
f0121278:	6a 01                	push   $0x1
f012127a:	ff 75 a4             	pushl  -0x5c(%ebp)
f012127d:	ff 75 a8             	pushl  -0x58(%ebp)
f0121280:	e8 e3 f9 ff ff       	call   f0120c68 <set_block_data>
f0121285:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f0121288:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012128c:	75 17                	jne    f01212a5 <alloc_block_BF+0x152>
f012128e:	83 ec 04             	sub    $0x4,%esp
f0121291:	68 37 1a 13 f0       	push   $0xf0131a37
f0121296:	68 2c 01 00 00       	push   $0x12c
f012129b:	68 55 1a 13 f0       	push   $0xf0131a55
f01212a0:	e8 94 f0 fd ff       	call   f0100339 <_panic>
f01212a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212a8:	8b 00                	mov    (%eax),%eax
f01212aa:	85 c0                	test   %eax,%eax
f01212ac:	74 10                	je     f01212be <alloc_block_BF+0x16b>
f01212ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212b1:	8b 00                	mov    (%eax),%eax
f01212b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01212b6:	8b 52 04             	mov    0x4(%edx),%edx
f01212b9:	89 50 04             	mov    %edx,0x4(%eax)
f01212bc:	eb 0b                	jmp    f01212c9 <alloc_block_BF+0x176>
f01212be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212c1:	8b 40 04             	mov    0x4(%eax),%eax
f01212c4:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01212c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212cc:	8b 40 04             	mov    0x4(%eax),%eax
f01212cf:	85 c0                	test   %eax,%eax
f01212d1:	74 0f                	je     f01212e2 <alloc_block_BF+0x18f>
f01212d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212d6:	8b 40 04             	mov    0x4(%eax),%eax
f01212d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01212dc:	8b 12                	mov    (%edx),%edx
f01212de:	89 10                	mov    %edx,(%eax)
f01212e0:	eb 0a                	jmp    f01212ec <alloc_block_BF+0x199>
f01212e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212e5:	8b 00                	mov    (%eax),%eax
f01212e7:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01212ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01212f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01212ff:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121304:	48                   	dec    %eax
f0121305:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
					return va;
f012130a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012130d:	e9 01 04 00 00       	jmp    f0121713 <alloc_block_BF+0x5c0>
				}
				else
				{
					if (best_blk_size > blk_size)
f0121312:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121315:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121318:	76 13                	jbe    f012132d <alloc_block_BF+0x1da>
					{
						internal = 1;
f012131a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f0121321:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121324:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0121327:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012132a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f012132d:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121332:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121335:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121339:	74 07                	je     f0121342 <alloc_block_BF+0x1ef>
f012133b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012133e:	8b 00                	mov    (%eax),%eax
f0121340:	eb 05                	jmp    f0121347 <alloc_block_BF+0x1f4>
f0121342:	b8 00 00 00 00       	mov    $0x0,%eax
f0121347:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f012134c:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121351:	85 c0                	test   %eax,%eax
f0121353:	0f 85 bf fe ff ff    	jne    f0121218 <alloc_block_BF+0xc5>
f0121359:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012135d:	0f 85 b5 fe ff ff    	jne    f0121218 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0121363:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121367:	0f 84 26 02 00 00    	je     f0121593 <alloc_block_BF+0x440>
f012136d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0121371:	0f 85 1c 02 00 00    	jne    f0121593 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f0121377:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012137a:	2b 45 08             	sub    0x8(%ebp),%eax
f012137d:	83 e8 08             	sub    $0x8,%eax
f0121380:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0121383:	8b 45 08             	mov    0x8(%ebp),%eax
f0121386:	8d 50 08             	lea    0x8(%eax),%edx
f0121389:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012138c:	01 d0                	add    %edx,%eax
f012138e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0121391:	8b 45 08             	mov    0x8(%ebp),%eax
f0121394:	83 c0 08             	add    $0x8,%eax
f0121397:	83 ec 04             	sub    $0x4,%esp
f012139a:	6a 01                	push   $0x1
f012139c:	50                   	push   %eax
f012139d:	ff 75 f0             	pushl  -0x10(%ebp)
f01213a0:	e8 c3 f8 ff ff       	call   f0120c68 <set_block_data>
f01213a5:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f01213a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213ab:	8b 40 04             	mov    0x4(%eax),%eax
f01213ae:	85 c0                	test   %eax,%eax
f01213b0:	75 68                	jne    f012141a <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01213b2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01213b6:	75 17                	jne    f01213cf <alloc_block_BF+0x27c>
f01213b8:	83 ec 04             	sub    $0x4,%esp
f01213bb:	68 70 1a 13 f0       	push   $0xf0131a70
f01213c0:	68 45 01 00 00       	push   $0x145
f01213c5:	68 55 1a 13 f0       	push   $0xf0131a55
f01213ca:	e8 6a ef fd ff       	call   f0100339 <_panic>
f01213cf:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f01213d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01213d8:	89 10                	mov    %edx,(%eax)
f01213da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01213dd:	8b 00                	mov    (%eax),%eax
f01213df:	85 c0                	test   %eax,%eax
f01213e1:	74 0d                	je     f01213f0 <alloc_block_BF+0x29d>
f01213e3:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f01213e8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01213eb:	89 50 04             	mov    %edx,0x4(%eax)
f01213ee:	eb 08                	jmp    f01213f8 <alloc_block_BF+0x2a5>
f01213f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01213f3:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01213f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01213fb:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121400:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121403:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012140a:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012140f:	40                   	inc    %eax
f0121410:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121415:	e9 dc 00 00 00       	jmp    f01214f6 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f012141a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012141d:	8b 00                	mov    (%eax),%eax
f012141f:	85 c0                	test   %eax,%eax
f0121421:	75 65                	jne    f0121488 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121423:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121427:	75 17                	jne    f0121440 <alloc_block_BF+0x2ed>
f0121429:	83 ec 04             	sub    $0x4,%esp
f012142c:	68 a4 1a 13 f0       	push   $0xf0131aa4
f0121431:	68 4a 01 00 00       	push   $0x14a
f0121436:	68 55 1a 13 f0       	push   $0xf0131a55
f012143b:	e8 f9 ee fd ff       	call   f0100339 <_panic>
f0121440:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0121446:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121449:	89 50 04             	mov    %edx,0x4(%eax)
f012144c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012144f:	8b 40 04             	mov    0x4(%eax),%eax
f0121452:	85 c0                	test   %eax,%eax
f0121454:	74 0c                	je     f0121462 <alloc_block_BF+0x30f>
f0121456:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f012145b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012145e:	89 10                	mov    %edx,(%eax)
f0121460:	eb 08                	jmp    f012146a <alloc_block_BF+0x317>
f0121462:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121465:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f012146a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012146d:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121472:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121475:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012147b:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121480:	40                   	inc    %eax
f0121481:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121486:	eb 6e                	jmp    f01214f6 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f0121488:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012148c:	74 06                	je     f0121494 <alloc_block_BF+0x341>
f012148e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121492:	75 17                	jne    f01214ab <alloc_block_BF+0x358>
f0121494:	83 ec 04             	sub    $0x4,%esp
f0121497:	68 c8 1a 13 f0       	push   $0xf0131ac8
f012149c:	68 4f 01 00 00       	push   $0x14f
f01214a1:	68 55 1a 13 f0       	push   $0xf0131a55
f01214a6:	e8 8e ee fd ff       	call   f0100339 <_panic>
f01214ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01214ae:	8b 10                	mov    (%eax),%edx
f01214b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214b3:	89 10                	mov    %edx,(%eax)
f01214b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214b8:	8b 00                	mov    (%eax),%eax
f01214ba:	85 c0                	test   %eax,%eax
f01214bc:	74 0b                	je     f01214c9 <alloc_block_BF+0x376>
f01214be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01214c1:	8b 00                	mov    (%eax),%eax
f01214c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01214c6:	89 50 04             	mov    %edx,0x4(%eax)
f01214c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01214cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01214cf:	89 10                	mov    %edx,(%eax)
f01214d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01214d7:	89 50 04             	mov    %edx,0x4(%eax)
f01214da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214dd:	8b 00                	mov    (%eax),%eax
f01214df:	85 c0                	test   %eax,%eax
f01214e1:	75 08                	jne    f01214eb <alloc_block_BF+0x398>
f01214e3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214e6:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01214eb:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01214f0:	40                   	inc    %eax
f01214f1:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f01214f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01214fa:	75 17                	jne    f0121513 <alloc_block_BF+0x3c0>
f01214fc:	83 ec 04             	sub    $0x4,%esp
f01214ff:	68 37 1a 13 f0       	push   $0xf0131a37
f0121504:	68 51 01 00 00       	push   $0x151
f0121509:	68 55 1a 13 f0       	push   $0xf0131a55
f012150e:	e8 26 ee fd ff       	call   f0100339 <_panic>
f0121513:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121516:	8b 00                	mov    (%eax),%eax
f0121518:	85 c0                	test   %eax,%eax
f012151a:	74 10                	je     f012152c <alloc_block_BF+0x3d9>
f012151c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012151f:	8b 00                	mov    (%eax),%eax
f0121521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121524:	8b 52 04             	mov    0x4(%edx),%edx
f0121527:	89 50 04             	mov    %edx,0x4(%eax)
f012152a:	eb 0b                	jmp    f0121537 <alloc_block_BF+0x3e4>
f012152c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012152f:	8b 40 04             	mov    0x4(%eax),%eax
f0121532:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121537:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012153a:	8b 40 04             	mov    0x4(%eax),%eax
f012153d:	85 c0                	test   %eax,%eax
f012153f:	74 0f                	je     f0121550 <alloc_block_BF+0x3fd>
f0121541:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121544:	8b 40 04             	mov    0x4(%eax),%eax
f0121547:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012154a:	8b 12                	mov    (%edx),%edx
f012154c:	89 10                	mov    %edx,(%eax)
f012154e:	eb 0a                	jmp    f012155a <alloc_block_BF+0x407>
f0121550:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121553:	8b 00                	mov    (%eax),%eax
f0121555:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f012155a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012155d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121563:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121566:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012156d:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121572:	48                   	dec    %eax
f0121573:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			set_block_data(new_block_va, remaining_size, 0);
f0121578:	83 ec 04             	sub    $0x4,%esp
f012157b:	6a 00                	push   $0x0
f012157d:	ff 75 d0             	pushl  -0x30(%ebp)
f0121580:	ff 75 cc             	pushl  -0x34(%ebp)
f0121583:	e8 e0 f6 ff ff       	call   f0120c68 <set_block_data>
f0121588:	83 c4 10             	add    $0x10,%esp
			return best_va;
f012158b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012158e:	e9 80 01 00 00       	jmp    f0121713 <alloc_block_BF+0x5c0>
	}
	else if(internal == 1)
f0121593:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0121597:	0f 85 9d 00 00 00    	jne    f012163a <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f012159d:	83 ec 04             	sub    $0x4,%esp
f01215a0:	6a 01                	push   $0x1
f01215a2:	ff 75 ec             	pushl  -0x14(%ebp)
f01215a5:	ff 75 f0             	pushl  -0x10(%ebp)
f01215a8:	e8 bb f6 ff ff       	call   f0120c68 <set_block_data>
f01215ad:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f01215b0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01215b4:	75 17                	jne    f01215cd <alloc_block_BF+0x47a>
f01215b6:	83 ec 04             	sub    $0x4,%esp
f01215b9:	68 37 1a 13 f0       	push   $0xf0131a37
f01215be:	68 58 01 00 00       	push   $0x158
f01215c3:	68 55 1a 13 f0       	push   $0xf0131a55
f01215c8:	e8 6c ed fd ff       	call   f0100339 <_panic>
f01215cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215d0:	8b 00                	mov    (%eax),%eax
f01215d2:	85 c0                	test   %eax,%eax
f01215d4:	74 10                	je     f01215e6 <alloc_block_BF+0x493>
f01215d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215d9:	8b 00                	mov    (%eax),%eax
f01215db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01215de:	8b 52 04             	mov    0x4(%edx),%edx
f01215e1:	89 50 04             	mov    %edx,0x4(%eax)
f01215e4:	eb 0b                	jmp    f01215f1 <alloc_block_BF+0x49e>
f01215e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215e9:	8b 40 04             	mov    0x4(%eax),%eax
f01215ec:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01215f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215f4:	8b 40 04             	mov    0x4(%eax),%eax
f01215f7:	85 c0                	test   %eax,%eax
f01215f9:	74 0f                	je     f012160a <alloc_block_BF+0x4b7>
f01215fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215fe:	8b 40 04             	mov    0x4(%eax),%eax
f0121601:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121604:	8b 12                	mov    (%edx),%edx
f0121606:	89 10                	mov    %edx,(%eax)
f0121608:	eb 0a                	jmp    f0121614 <alloc_block_BF+0x4c1>
f012160a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012160d:	8b 00                	mov    (%eax),%eax
f012160f:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121614:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121617:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012161d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121620:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121627:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012162c:	48                   	dec    %eax
f012162d:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		return best_va;
f0121632:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121635:	e9 d9 00 00 00       	jmp    f0121713 <alloc_block_BF+0x5c0>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f012163a:	8b 45 08             	mov    0x8(%ebp),%eax
f012163d:	83 c0 08             	add    $0x8,%eax
f0121640:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0121643:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f012164a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012164d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121650:	01 d0                	add    %edx,%eax
f0121652:	48                   	dec    %eax
f0121653:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0121656:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121659:	ba 00 00 00 00       	mov    $0x0,%edx
f012165e:	f7 75 c4             	divl   -0x3c(%ebp)
f0121661:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121664:	29 d0                	sub    %edx,%eax
f0121666:	c1 e8 0c             	shr    $0xc,%eax
f0121669:	83 ec 0c             	sub    $0xc,%esp
f012166c:	50                   	push   %eax
f012166d:	e8 15 80 fe ff       	call   f0109687 <sbrk>
f0121672:	83 c4 10             	add    $0x10,%esp
f0121675:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0121678:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f012167c:	75 0a                	jne    f0121688 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f012167e:	b8 00 00 00 00       	mov    $0x0,%eax
f0121683:	e9 8b 00 00 00       	jmp    f0121713 <alloc_block_BF+0x5c0>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0121688:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f012168f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121692:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121695:	01 d0                	add    %edx,%eax
f0121697:	48                   	dec    %eax
f0121698:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f012169b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012169e:	ba 00 00 00 00       	mov    $0x0,%edx
f01216a3:	f7 75 b8             	divl   -0x48(%ebp)
f01216a6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01216a9:	29 d0                	sub    %edx,%eax
f01216ab:	8d 50 fc             	lea    -0x4(%eax),%edx
f01216ae:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01216b1:	01 d0                	add    %edx,%eax
f01216b3:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
				end_block->info = 1;
f01216b8:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f01216bd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				
			
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f01216c3:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f01216ca:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01216cd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01216d0:	01 d0                	add    %edx,%eax
f01216d2:	48                   	dec    %eax
f01216d3:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01216d6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01216d9:	ba 00 00 00 00       	mov    $0x0,%edx
f01216de:	f7 75 b0             	divl   -0x50(%ebp)
f01216e1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01216e4:	29 d0                	sub    %edx,%eax
f01216e6:	83 ec 04             	sub    $0x4,%esp
f01216e9:	6a 01                	push   $0x1
f01216eb:	50                   	push   %eax
f01216ec:	ff 75 bc             	pushl  -0x44(%ebp)
f01216ef:	e8 74 f5 ff ff       	call   f0120c68 <set_block_data>
f01216f4:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f01216f7:	83 ec 0c             	sub    $0xc,%esp
f01216fa:	ff 75 bc             	pushl  -0x44(%ebp)
f01216fd:	e8 36 04 00 00       	call   f0121b38 <free_block>
f0121702:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0121705:	83 ec 0c             	sub    $0xc,%esp
f0121708:	ff 75 08             	pushl  0x8(%ebp)
f012170b:	e8 43 fa ff ff       	call   f0121153 <alloc_block_BF>
f0121710:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0121713:	c9                   	leave  
f0121714:	c3                   	ret    

f0121715 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0121715:	55                   	push   %ebp
f0121716:	89 e5                	mov    %esp,%ebp
f0121718:	53                   	push   %ebx
f0121719:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f012171c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121723:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f012172a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012172e:	74 1e                	je     f012174e <merging+0x39>
f0121730:	ff 75 08             	pushl  0x8(%ebp)
f0121733:	e8 df f1 ff ff       	call   f0120917 <get_block_size>
f0121738:	83 c4 04             	add    $0x4,%esp
f012173b:	89 c2                	mov    %eax,%edx
f012173d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121740:	01 d0                	add    %edx,%eax
f0121742:	3b 45 10             	cmp    0x10(%ebp),%eax
f0121745:	75 07                	jne    f012174e <merging+0x39>
		prev_is_free = 1;
f0121747:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f012174e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121752:	74 1e                	je     f0121772 <merging+0x5d>
f0121754:	ff 75 10             	pushl  0x10(%ebp)
f0121757:	e8 bb f1 ff ff       	call   f0120917 <get_block_size>
f012175c:	83 c4 04             	add    $0x4,%esp
f012175f:	89 c2                	mov    %eax,%edx
f0121761:	8b 45 10             	mov    0x10(%ebp),%eax
f0121764:	01 d0                	add    %edx,%eax
f0121766:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0121769:	75 07                	jne    f0121772 <merging+0x5d>
		next_is_free = 1;
f012176b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0121772:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121776:	0f 84 cc 00 00 00    	je     f0121848 <merging+0x133>
f012177c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121780:	0f 84 c2 00 00 00    	je     f0121848 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0121786:	ff 75 08             	pushl  0x8(%ebp)
f0121789:	e8 89 f1 ff ff       	call   f0120917 <get_block_size>
f012178e:	83 c4 04             	add    $0x4,%esp
f0121791:	89 c3                	mov    %eax,%ebx
f0121793:	ff 75 10             	pushl  0x10(%ebp)
f0121796:	e8 7c f1 ff ff       	call   f0120917 <get_block_size>
f012179b:	83 c4 04             	add    $0x4,%esp
f012179e:	01 c3                	add    %eax,%ebx
f01217a0:	ff 75 0c             	pushl  0xc(%ebp)
f01217a3:	e8 6f f1 ff ff       	call   f0120917 <get_block_size>
f01217a8:	83 c4 04             	add    $0x4,%esp
f01217ab:	01 d8                	add    %ebx,%eax
f01217ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01217b0:	6a 00                	push   $0x0
f01217b2:	ff 75 ec             	pushl  -0x14(%ebp)
f01217b5:	ff 75 08             	pushl  0x8(%ebp)
f01217b8:	e8 ab f4 ff ff       	call   f0120c68 <set_block_data>
f01217bd:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f01217c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01217c4:	75 17                	jne    f01217dd <merging+0xc8>
f01217c6:	83 ec 04             	sub    $0x4,%esp
f01217c9:	68 37 1a 13 f0       	push   $0xf0131a37
f01217ce:	68 7d 01 00 00       	push   $0x17d
f01217d3:	68 55 1a 13 f0       	push   $0xf0131a55
f01217d8:	e8 5c eb fd ff       	call   f0100339 <_panic>
f01217dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217e0:	8b 00                	mov    (%eax),%eax
f01217e2:	85 c0                	test   %eax,%eax
f01217e4:	74 10                	je     f01217f6 <merging+0xe1>
f01217e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217e9:	8b 00                	mov    (%eax),%eax
f01217eb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01217ee:	8b 52 04             	mov    0x4(%edx),%edx
f01217f1:	89 50 04             	mov    %edx,0x4(%eax)
f01217f4:	eb 0b                	jmp    f0121801 <merging+0xec>
f01217f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217f9:	8b 40 04             	mov    0x4(%eax),%eax
f01217fc:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121801:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121804:	8b 40 04             	mov    0x4(%eax),%eax
f0121807:	85 c0                	test   %eax,%eax
f0121809:	74 0f                	je     f012181a <merging+0x105>
f012180b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012180e:	8b 40 04             	mov    0x4(%eax),%eax
f0121811:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121814:	8b 12                	mov    (%edx),%edx
f0121816:	89 10                	mov    %edx,(%eax)
f0121818:	eb 0a                	jmp    f0121824 <merging+0x10f>
f012181a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012181d:	8b 00                	mov    (%eax),%eax
f012181f:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121824:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121827:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012182d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121830:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121837:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012183c:	48                   	dec    %eax
f012183d:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0121842:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121843:	e9 ea 02 00 00       	jmp    f0121b32 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0121848:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012184c:	74 3b                	je     f0121889 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f012184e:	83 ec 0c             	sub    $0xc,%esp
f0121851:	ff 75 08             	pushl  0x8(%ebp)
f0121854:	e8 be f0 ff ff       	call   f0120917 <get_block_size>
f0121859:	83 c4 10             	add    $0x10,%esp
f012185c:	89 c3                	mov    %eax,%ebx
f012185e:	83 ec 0c             	sub    $0xc,%esp
f0121861:	ff 75 10             	pushl  0x10(%ebp)
f0121864:	e8 ae f0 ff ff       	call   f0120917 <get_block_size>
f0121869:	83 c4 10             	add    $0x10,%esp
f012186c:	01 d8                	add    %ebx,%eax
f012186e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121871:	83 ec 04             	sub    $0x4,%esp
f0121874:	6a 00                	push   $0x0
f0121876:	ff 75 e8             	pushl  -0x18(%ebp)
f0121879:	ff 75 08             	pushl  0x8(%ebp)
f012187c:	e8 e7 f3 ff ff       	call   f0120c68 <set_block_data>
f0121881:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121884:	e9 a9 02 00 00       	jmp    f0121b32 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0121889:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012188d:	0f 84 2d 01 00 00    	je     f01219c0 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0121893:	83 ec 0c             	sub    $0xc,%esp
f0121896:	ff 75 10             	pushl  0x10(%ebp)
f0121899:	e8 79 f0 ff ff       	call   f0120917 <get_block_size>
f012189e:	83 c4 10             	add    $0x10,%esp
f01218a1:	89 c3                	mov    %eax,%ebx
f01218a3:	83 ec 0c             	sub    $0xc,%esp
f01218a6:	ff 75 0c             	pushl  0xc(%ebp)
f01218a9:	e8 69 f0 ff ff       	call   f0120917 <get_block_size>
f01218ae:	83 c4 10             	add    $0x10,%esp
f01218b1:	01 d8                	add    %ebx,%eax
f01218b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f01218b6:	83 ec 04             	sub    $0x4,%esp
f01218b9:	6a 00                	push   $0x0
f01218bb:	ff 75 e4             	pushl  -0x1c(%ebp)
f01218be:	ff 75 10             	pushl  0x10(%ebp)
f01218c1:	e8 a2 f3 ff ff       	call   f0120c68 <set_block_data>
f01218c6:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f01218c9:	8b 45 10             	mov    0x10(%ebp),%eax
f01218cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f01218cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01218d3:	74 06                	je     f01218db <merging+0x1c6>
f01218d5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01218d9:	75 17                	jne    f01218f2 <merging+0x1dd>
f01218db:	83 ec 04             	sub    $0x4,%esp
f01218de:	68 fc 1a 13 f0       	push   $0xf0131afc
f01218e3:	68 8d 01 00 00       	push   $0x18d
f01218e8:	68 55 1a 13 f0       	push   $0xf0131a55
f01218ed:	e8 47 ea fd ff       	call   f0100339 <_panic>
f01218f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218f5:	8b 50 04             	mov    0x4(%eax),%edx
f01218f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01218fb:	89 50 04             	mov    %edx,0x4(%eax)
f01218fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121901:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121904:	89 10                	mov    %edx,(%eax)
f0121906:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121909:	8b 40 04             	mov    0x4(%eax),%eax
f012190c:	85 c0                	test   %eax,%eax
f012190e:	74 0d                	je     f012191d <merging+0x208>
f0121910:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121913:	8b 40 04             	mov    0x4(%eax),%eax
f0121916:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121919:	89 10                	mov    %edx,(%eax)
f012191b:	eb 08                	jmp    f0121925 <merging+0x210>
f012191d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121920:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121925:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121928:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012192b:	89 50 04             	mov    %edx,0x4(%eax)
f012192e:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121933:	40                   	inc    %eax
f0121934:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		LIST_REMOVE(&freeBlocksList, next_block);
f0121939:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012193d:	75 17                	jne    f0121956 <merging+0x241>
f012193f:	83 ec 04             	sub    $0x4,%esp
f0121942:	68 37 1a 13 f0       	push   $0xf0131a37
f0121947:	68 8e 01 00 00       	push   $0x18e
f012194c:	68 55 1a 13 f0       	push   $0xf0131a55
f0121951:	e8 e3 e9 fd ff       	call   f0100339 <_panic>
f0121956:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121959:	8b 00                	mov    (%eax),%eax
f012195b:	85 c0                	test   %eax,%eax
f012195d:	74 10                	je     f012196f <merging+0x25a>
f012195f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121962:	8b 00                	mov    (%eax),%eax
f0121964:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121967:	8b 52 04             	mov    0x4(%edx),%edx
f012196a:	89 50 04             	mov    %edx,0x4(%eax)
f012196d:	eb 0b                	jmp    f012197a <merging+0x265>
f012196f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121972:	8b 40 04             	mov    0x4(%eax),%eax
f0121975:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f012197a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012197d:	8b 40 04             	mov    0x4(%eax),%eax
f0121980:	85 c0                	test   %eax,%eax
f0121982:	74 0f                	je     f0121993 <merging+0x27e>
f0121984:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121987:	8b 40 04             	mov    0x4(%eax),%eax
f012198a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012198d:	8b 12                	mov    (%edx),%edx
f012198f:	89 10                	mov    %edx,(%eax)
f0121991:	eb 0a                	jmp    f012199d <merging+0x288>
f0121993:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121996:	8b 00                	mov    (%eax),%eax
f0121998:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f012199d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219a0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01219a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219a9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01219b0:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01219b5:	48                   	dec    %eax
f01219b6:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01219bb:	e9 72 01 00 00       	jmp    f0121b32 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01219c0:	8b 45 10             	mov    0x10(%ebp),%eax
f01219c3:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f01219c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01219ca:	74 79                	je     f0121a45 <merging+0x330>
f01219cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01219d0:	74 73                	je     f0121a45 <merging+0x330>
f01219d2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01219d6:	74 06                	je     f01219de <merging+0x2c9>
f01219d8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01219dc:	75 17                	jne    f01219f5 <merging+0x2e0>
f01219de:	83 ec 04             	sub    $0x4,%esp
f01219e1:	68 c8 1a 13 f0       	push   $0xf0131ac8
f01219e6:	68 94 01 00 00       	push   $0x194
f01219eb:	68 55 1a 13 f0       	push   $0xf0131a55
f01219f0:	e8 44 e9 fd ff       	call   f0100339 <_panic>
f01219f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01219f8:	8b 10                	mov    (%eax),%edx
f01219fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01219fd:	89 10                	mov    %edx,(%eax)
f01219ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a02:	8b 00                	mov    (%eax),%eax
f0121a04:	85 c0                	test   %eax,%eax
f0121a06:	74 0b                	je     f0121a13 <merging+0x2fe>
f0121a08:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a0b:	8b 00                	mov    (%eax),%eax
f0121a0d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121a10:	89 50 04             	mov    %edx,0x4(%eax)
f0121a13:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a16:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121a19:	89 10                	mov    %edx,(%eax)
f0121a1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a1e:	8b 55 08             	mov    0x8(%ebp),%edx
f0121a21:	89 50 04             	mov    %edx,0x4(%eax)
f0121a24:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a27:	8b 00                	mov    (%eax),%eax
f0121a29:	85 c0                	test   %eax,%eax
f0121a2b:	75 08                	jne    f0121a35 <merging+0x320>
f0121a2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a30:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121a35:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121a3a:	40                   	inc    %eax
f0121a3b:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121a40:	e9 ce 00 00 00       	jmp    f0121b13 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121a45:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121a49:	74 65                	je     f0121ab0 <merging+0x39b>
f0121a4b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121a4f:	75 17                	jne    f0121a68 <merging+0x353>
f0121a51:	83 ec 04             	sub    $0x4,%esp
f0121a54:	68 a4 1a 13 f0       	push   $0xf0131aa4
f0121a59:	68 95 01 00 00       	push   $0x195
f0121a5e:	68 55 1a 13 f0       	push   $0xf0131a55
f0121a63:	e8 d1 e8 fd ff       	call   f0100339 <_panic>
f0121a68:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0121a6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a71:	89 50 04             	mov    %edx,0x4(%eax)
f0121a74:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a77:	8b 40 04             	mov    0x4(%eax),%eax
f0121a7a:	85 c0                	test   %eax,%eax
f0121a7c:	74 0c                	je     f0121a8a <merging+0x375>
f0121a7e:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121a83:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121a86:	89 10                	mov    %edx,(%eax)
f0121a88:	eb 08                	jmp    f0121a92 <merging+0x37d>
f0121a8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a8d:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121a92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a95:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121a9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121a9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121aa3:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121aa8:	40                   	inc    %eax
f0121aa9:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121aae:	eb 63                	jmp    f0121b13 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0121ab0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121ab4:	75 17                	jne    f0121acd <merging+0x3b8>
f0121ab6:	83 ec 04             	sub    $0x4,%esp
f0121ab9:	68 70 1a 13 f0       	push   $0xf0131a70
f0121abe:	68 98 01 00 00       	push   $0x198
f0121ac3:	68 55 1a 13 f0       	push   $0xf0131a55
f0121ac8:	e8 6c e8 fd ff       	call   f0100339 <_panic>
f0121acd:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121ad3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ad6:	89 10                	mov    %edx,(%eax)
f0121ad8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121adb:	8b 00                	mov    (%eax),%eax
f0121add:	85 c0                	test   %eax,%eax
f0121adf:	74 0d                	je     f0121aee <merging+0x3d9>
f0121ae1:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121ae6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121ae9:	89 50 04             	mov    %edx,0x4(%eax)
f0121aec:	eb 08                	jmp    f0121af6 <merging+0x3e1>
f0121aee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121af1:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121af6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121af9:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121afe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b01:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121b08:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121b0d:	40                   	inc    %eax
f0121b0e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		}
		set_block_data(va, get_block_size(va), 0);
f0121b13:	83 ec 0c             	sub    $0xc,%esp
f0121b16:	ff 75 10             	pushl  0x10(%ebp)
f0121b19:	e8 f9 ed ff ff       	call   f0120917 <get_block_size>
f0121b1e:	83 c4 10             	add    $0x10,%esp
f0121b21:	83 ec 04             	sub    $0x4,%esp
f0121b24:	6a 00                	push   $0x0
f0121b26:	50                   	push   %eax
f0121b27:	ff 75 10             	pushl  0x10(%ebp)
f0121b2a:	e8 39 f1 ff ff       	call   f0120c68 <set_block_data>
f0121b2f:	83 c4 10             	add    $0x10,%esp
	}
}
f0121b32:	90                   	nop
f0121b33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121b36:	c9                   	leave  
f0121b37:	c3                   	ret    

f0121b38 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121b38:	55                   	push   %ebp
f0121b39:	89 e5                	mov    %esp,%ebp
f0121b3b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0121b3e:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121b43:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121b46:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121b4b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121b4e:	73 1b                	jae    f0121b6b <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0121b50:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121b55:	83 ec 04             	sub    $0x4,%esp
f0121b58:	ff 75 08             	pushl  0x8(%ebp)
f0121b5b:	6a 00                	push   $0x0
f0121b5d:	50                   	push   %eax
f0121b5e:	e8 b2 fb ff ff       	call   f0121715 <merging>
f0121b63:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121b66:	e9 8b 00 00 00       	jmp    f0121bf6 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f0121b6b:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121b70:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121b73:	76 18                	jbe    f0121b8d <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0121b75:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121b7a:	83 ec 04             	sub    $0x4,%esp
f0121b7d:	ff 75 08             	pushl  0x8(%ebp)
f0121b80:	50                   	push   %eax
f0121b81:	6a 00                	push   $0x0
f0121b83:	e8 8d fb ff ff       	call   f0121715 <merging>
f0121b88:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121b8b:	eb 69                	jmp    f0121bf6 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121b8d:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121b92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121b95:	eb 39                	jmp    f0121bd0 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0121b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b9a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121b9d:	73 29                	jae    f0121bc8 <free_block+0x90>
f0121b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121ba2:	8b 00                	mov    (%eax),%eax
f0121ba4:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121ba7:	76 1f                	jbe    f0121bc8 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0121ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121bac:	8b 00                	mov    (%eax),%eax
f0121bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0121bb1:	83 ec 04             	sub    $0x4,%esp
f0121bb4:	ff 75 08             	pushl  0x8(%ebp)
f0121bb7:	ff 75 f0             	pushl  -0x10(%ebp)
f0121bba:	ff 75 f4             	pushl  -0xc(%ebp)
f0121bbd:	e8 53 fb ff ff       	call   f0121715 <merging>
f0121bc2:	83 c4 10             	add    $0x10,%esp
			break;
f0121bc5:	90                   	nop
		}
	}
}
f0121bc6:	eb 2e                	jmp    f0121bf6 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121bc8:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121bcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121bd0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121bd4:	74 07                	je     f0121bdd <free_block+0xa5>
f0121bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121bd9:	8b 00                	mov    (%eax),%eax
f0121bdb:	eb 05                	jmp    f0121be2 <free_block+0xaa>
f0121bdd:	b8 00 00 00 00       	mov    $0x0,%eax
f0121be2:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0121be7:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121bec:	85 c0                	test   %eax,%eax
f0121bee:	75 a7                	jne    f0121b97 <free_block+0x5f>
f0121bf0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121bf4:	75 a1                	jne    f0121b97 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121bf6:	90                   	nop
f0121bf7:	c9                   	leave  
f0121bf8:	c3                   	ret    

f0121bf9 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121bf9:	55                   	push   %ebp
f0121bfa:	89 e5                	mov    %esp,%ebp
f0121bfc:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f0121bff:	ff 75 08             	pushl  0x8(%ebp)
f0121c02:	e8 10 ed ff ff       	call   f0120917 <get_block_size>
f0121c07:	83 c4 04             	add    $0x4,%esp
f0121c0a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121c0d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121c14:	eb 17                	jmp    f0121c2d <copy_data+0x34>
f0121c16:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121c19:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c1c:	01 c2                	add    %eax,%edx
f0121c1e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121c21:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c24:	01 c8                	add    %ecx,%eax
f0121c26:	8a 00                	mov    (%eax),%al
f0121c28:	88 02                	mov    %al,(%edx)
f0121c2a:	ff 45 fc             	incl   -0x4(%ebp)
f0121c2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121c30:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121c33:	72 e1                	jb     f0121c16 <copy_data+0x1d>
}
f0121c35:	90                   	nop
f0121c36:	c9                   	leave  
f0121c37:	c3                   	ret    

f0121c38 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121c38:	55                   	push   %ebp
f0121c39:	89 e5                	mov    %esp,%ebp
f0121c3b:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121c3e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121c42:	75 23                	jne    f0121c67 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121c44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121c48:	74 13                	je     f0121c5d <realloc_block_FF+0x25>
f0121c4a:	83 ec 0c             	sub    $0xc,%esp
f0121c4d:	ff 75 0c             	pushl  0xc(%ebp)
f0121c50:	e8 42 f0 ff ff       	call   f0120c97 <alloc_block_FF>
f0121c55:	83 c4 10             	add    $0x10,%esp
f0121c58:	e9 e4 06 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
		return NULL;
f0121c5d:	b8 00 00 00 00       	mov    $0x0,%eax
f0121c62:	e9 da 06 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
	}

	if(new_size == 0)
f0121c67:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121c6b:	75 18                	jne    f0121c85 <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121c6d:	83 ec 0c             	sub    $0xc,%esp
f0121c70:	ff 75 08             	pushl  0x8(%ebp)
f0121c73:	e8 c0 fe ff ff       	call   f0121b38 <free_block>
f0121c78:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121c7b:	b8 00 00 00 00       	mov    $0x0,%eax
f0121c80:	e9 bc 06 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
	}


	if(new_size < 8) new_size = 8;
f0121c85:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121c89:	77 07                	ja     f0121c92 <realloc_block_FF+0x5a>
f0121c8b:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121c92:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c95:	83 e0 01             	and    $0x1,%eax
f0121c98:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121c9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c9e:	83 c0 08             	add    $0x8,%eax
f0121ca1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121ca4:	83 ec 0c             	sub    $0xc,%esp
f0121ca7:	ff 75 08             	pushl  0x8(%ebp)
f0121caa:	e8 68 ec ff ff       	call   f0120917 <get_block_size>
f0121caf:	83 c4 10             	add    $0x10,%esp
f0121cb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121cb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121cb8:	83 e8 08             	sub    $0x8,%eax
f0121cbb:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121cbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cc1:	83 e8 04             	sub    $0x4,%eax
f0121cc4:	8b 00                	mov    (%eax),%eax
f0121cc6:	83 e0 fe             	and    $0xfffffffe,%eax
f0121cc9:	89 c2                	mov    %eax,%edx
f0121ccb:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cce:	01 d0                	add    %edx,%eax
f0121cd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121cd3:	83 ec 0c             	sub    $0xc,%esp
f0121cd6:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121cd9:	e8 39 ec ff ff       	call   f0120917 <get_block_size>
f0121cde:	83 c4 10             	add    $0x10,%esp
f0121ce1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121ce4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121ce7:	83 e8 08             	sub    $0x8,%eax
f0121cea:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121ced:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121cf0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121cf3:	75 08                	jne    f0121cfd <realloc_block_FF+0xc5>
	{
		 return va;
f0121cf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cf8:	e9 44 06 00 00       	jmp    f0122341 <realloc_block_FF+0x709>

	}


	if(new_size < cur_size)
f0121cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d00:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121d03:	0f 83 d5 03 00 00    	jae    f01220de <realloc_block_FF+0x4a6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121d09:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121d0c:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121d0f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121d12:	83 ec 0c             	sub    $0xc,%esp
f0121d15:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121d18:	e8 13 ec ff ff       	call   f0120930 <is_free_block>
f0121d1d:	83 c4 10             	add    $0x10,%esp
f0121d20:	84 c0                	test   %al,%al
f0121d22:	0f 84 3b 01 00 00    	je     f0121e63 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121d28:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121d2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121d2e:	01 d0                	add    %edx,%eax
f0121d30:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121d33:	83 ec 04             	sub    $0x4,%esp
f0121d36:	6a 01                	push   $0x1
f0121d38:	ff 75 f0             	pushl  -0x10(%ebp)
f0121d3b:	ff 75 08             	pushl  0x8(%ebp)
f0121d3e:	e8 25 ef ff ff       	call   f0120c68 <set_block_data>
f0121d43:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121d46:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d49:	83 e8 04             	sub    $0x4,%eax
f0121d4c:	8b 00                	mov    (%eax),%eax
f0121d4e:	83 e0 fe             	and    $0xfffffffe,%eax
f0121d51:	89 c2                	mov    %eax,%edx
f0121d53:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d56:	01 d0                	add    %edx,%eax
f0121d58:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121d5b:	83 ec 04             	sub    $0x4,%esp
f0121d5e:	6a 00                	push   $0x0
f0121d60:	ff 75 cc             	pushl  -0x34(%ebp)
f0121d63:	ff 75 c8             	pushl  -0x38(%ebp)
f0121d66:	e8 fd ee ff ff       	call   f0120c68 <set_block_data>
f0121d6b:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121d6e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121d72:	74 06                	je     f0121d7a <realloc_block_FF+0x142>
f0121d74:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121d78:	75 17                	jne    f0121d91 <realloc_block_FF+0x159>
f0121d7a:	83 ec 04             	sub    $0x4,%esp
f0121d7d:	68 c8 1a 13 f0       	push   $0xf0131ac8
f0121d82:	68 f6 01 00 00       	push   $0x1f6
f0121d87:	68 55 1a 13 f0       	push   $0xf0131a55
f0121d8c:	e8 a8 e5 fd ff       	call   f0100339 <_panic>
f0121d91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121d94:	8b 10                	mov    (%eax),%edx
f0121d96:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121d99:	89 10                	mov    %edx,(%eax)
f0121d9b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121d9e:	8b 00                	mov    (%eax),%eax
f0121da0:	85 c0                	test   %eax,%eax
f0121da2:	74 0b                	je     f0121daf <realloc_block_FF+0x177>
f0121da4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121da7:	8b 00                	mov    (%eax),%eax
f0121da9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121dac:	89 50 04             	mov    %edx,0x4(%eax)
f0121daf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121db2:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121db5:	89 10                	mov    %edx,(%eax)
f0121db7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121dba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121dbd:	89 50 04             	mov    %edx,0x4(%eax)
f0121dc0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121dc3:	8b 00                	mov    (%eax),%eax
f0121dc5:	85 c0                	test   %eax,%eax
f0121dc7:	75 08                	jne    f0121dd1 <realloc_block_FF+0x199>
f0121dc9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121dcc:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121dd1:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121dd6:	40                   	inc    %eax
f0121dd7:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121ddc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121de0:	75 17                	jne    f0121df9 <realloc_block_FF+0x1c1>
f0121de2:	83 ec 04             	sub    $0x4,%esp
f0121de5:	68 37 1a 13 f0       	push   $0xf0131a37
f0121dea:	68 f7 01 00 00       	push   $0x1f7
f0121def:	68 55 1a 13 f0       	push   $0xf0131a55
f0121df4:	e8 40 e5 fd ff       	call   f0100339 <_panic>
f0121df9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121dfc:	8b 00                	mov    (%eax),%eax
f0121dfe:	85 c0                	test   %eax,%eax
f0121e00:	74 10                	je     f0121e12 <realloc_block_FF+0x1da>
f0121e02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e05:	8b 00                	mov    (%eax),%eax
f0121e07:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121e0a:	8b 52 04             	mov    0x4(%edx),%edx
f0121e0d:	89 50 04             	mov    %edx,0x4(%eax)
f0121e10:	eb 0b                	jmp    f0121e1d <realloc_block_FF+0x1e5>
f0121e12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e15:	8b 40 04             	mov    0x4(%eax),%eax
f0121e18:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121e1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e20:	8b 40 04             	mov    0x4(%eax),%eax
f0121e23:	85 c0                	test   %eax,%eax
f0121e25:	74 0f                	je     f0121e36 <realloc_block_FF+0x1fe>
f0121e27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e2a:	8b 40 04             	mov    0x4(%eax),%eax
f0121e2d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121e30:	8b 12                	mov    (%edx),%edx
f0121e32:	89 10                	mov    %edx,(%eax)
f0121e34:	eb 0a                	jmp    f0121e40 <realloc_block_FF+0x208>
f0121e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e39:	8b 00                	mov    (%eax),%eax
f0121e3b:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121e40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121e49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121e53:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121e58:	48                   	dec    %eax
f0121e59:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121e5e:	e9 73 02 00 00       	jmp    f01220d6 <realloc_block_FF+0x49e>
		}
		else
		{
			if(remaining_size>=16)
f0121e63:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121e67:	0f 86 69 02 00 00    	jbe    f01220d6 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121e6d:	83 ec 04             	sub    $0x4,%esp
f0121e70:	6a 01                	push   $0x1
f0121e72:	ff 75 f0             	pushl  -0x10(%ebp)
f0121e75:	ff 75 08             	pushl  0x8(%ebp)
f0121e78:	e8 eb ed ff ff       	call   f0120c68 <set_block_data>
f0121e7d:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121e80:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e83:	83 e8 04             	sub    $0x4,%eax
f0121e86:	8b 00                	mov    (%eax),%eax
f0121e88:	83 e0 fe             	and    $0xfffffffe,%eax
f0121e8b:	89 c2                	mov    %eax,%edx
f0121e8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e90:	01 d0                	add    %edx,%eax
f0121e92:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121e95:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121e9a:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121e9d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121ea1:	75 68                	jne    f0121f0b <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121ea3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121ea7:	75 17                	jne    f0121ec0 <realloc_block_FF+0x288>
f0121ea9:	83 ec 04             	sub    $0x4,%esp
f0121eac:	68 70 1a 13 f0       	push   $0xf0131a70
f0121eb1:	68 06 02 00 00       	push   $0x206
f0121eb6:	68 55 1a 13 f0       	push   $0xf0131a55
f0121ebb:	e8 79 e4 fd ff       	call   f0100339 <_panic>
f0121ec0:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121ec6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ec9:	89 10                	mov    %edx,(%eax)
f0121ecb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ece:	8b 00                	mov    (%eax),%eax
f0121ed0:	85 c0                	test   %eax,%eax
f0121ed2:	74 0d                	je     f0121ee1 <realloc_block_FF+0x2a9>
f0121ed4:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121ed9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121edc:	89 50 04             	mov    %edx,0x4(%eax)
f0121edf:	eb 08                	jmp    f0121ee9 <realloc_block_FF+0x2b1>
f0121ee1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ee4:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121ee9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121eec:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121ef1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ef4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121efb:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121f00:	40                   	inc    %eax
f0121f01:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121f06:	e9 b0 01 00 00       	jmp    f01220bb <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121f0b:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121f10:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121f13:	76 68                	jbe    f0121f7d <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121f15:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121f19:	75 17                	jne    f0121f32 <realloc_block_FF+0x2fa>
f0121f1b:	83 ec 04             	sub    $0x4,%esp
f0121f1e:	68 70 1a 13 f0       	push   $0xf0131a70
f0121f23:	68 0b 02 00 00       	push   $0x20b
f0121f28:	68 55 1a 13 f0       	push   $0xf0131a55
f0121f2d:	e8 07 e4 fd ff       	call   f0100339 <_panic>
f0121f32:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121f38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f3b:	89 10                	mov    %edx,(%eax)
f0121f3d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f40:	8b 00                	mov    (%eax),%eax
f0121f42:	85 c0                	test   %eax,%eax
f0121f44:	74 0d                	je     f0121f53 <realloc_block_FF+0x31b>
f0121f46:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121f4b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121f4e:	89 50 04             	mov    %edx,0x4(%eax)
f0121f51:	eb 08                	jmp    f0121f5b <realloc_block_FF+0x323>
f0121f53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f56:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121f5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f5e:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121f63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f66:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121f6d:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121f72:	40                   	inc    %eax
f0121f73:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121f78:	e9 3e 01 00 00       	jmp    f01220bb <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0121f7d:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121f82:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121f85:	73 68                	jae    f0121fef <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121f87:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121f8b:	75 17                	jne    f0121fa4 <realloc_block_FF+0x36c>
f0121f8d:	83 ec 04             	sub    $0x4,%esp
f0121f90:	68 a4 1a 13 f0       	push   $0xf0131aa4
f0121f95:	68 10 02 00 00       	push   $0x210
f0121f9a:	68 55 1a 13 f0       	push   $0xf0131a55
f0121f9f:	e8 95 e3 fd ff       	call   f0100339 <_panic>
f0121fa4:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0121faa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fad:	89 50 04             	mov    %edx,0x4(%eax)
f0121fb0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fb3:	8b 40 04             	mov    0x4(%eax),%eax
f0121fb6:	85 c0                	test   %eax,%eax
f0121fb8:	74 0c                	je     f0121fc6 <realloc_block_FF+0x38e>
f0121fba:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121fbf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121fc2:	89 10                	mov    %edx,(%eax)
f0121fc4:	eb 08                	jmp    f0121fce <realloc_block_FF+0x396>
f0121fc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fc9:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121fce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fd1:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121fd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fd9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121fdf:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121fe4:	40                   	inc    %eax
f0121fe5:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121fea:	e9 cc 00 00 00       	jmp    f01220bb <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0121fef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121ff6:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121ffe:	e9 8a 00 00 00       	jmp    f012208d <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0122003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122006:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0122009:	73 7a                	jae    f0122085 <realloc_block_FF+0x44d>
f012200b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012200e:	8b 00                	mov    (%eax),%eax
f0122010:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0122013:	73 70                	jae    f0122085 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0122015:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122019:	74 06                	je     f0122021 <realloc_block_FF+0x3e9>
f012201b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012201f:	75 17                	jne    f0122038 <realloc_block_FF+0x400>
f0122021:	83 ec 04             	sub    $0x4,%esp
f0122024:	68 c8 1a 13 f0       	push   $0xf0131ac8
f0122029:	68 1a 02 00 00       	push   $0x21a
f012202e:	68 55 1a 13 f0       	push   $0xf0131a55
f0122033:	e8 01 e3 fd ff       	call   f0100339 <_panic>
f0122038:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012203b:	8b 10                	mov    (%eax),%edx
f012203d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122040:	89 10                	mov    %edx,(%eax)
f0122042:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122045:	8b 00                	mov    (%eax),%eax
f0122047:	85 c0                	test   %eax,%eax
f0122049:	74 0b                	je     f0122056 <realloc_block_FF+0x41e>
f012204b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012204e:	8b 00                	mov    (%eax),%eax
f0122050:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122053:	89 50 04             	mov    %edx,0x4(%eax)
f0122056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122059:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012205c:	89 10                	mov    %edx,(%eax)
f012205e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122061:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122064:	89 50 04             	mov    %edx,0x4(%eax)
f0122067:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012206a:	8b 00                	mov    (%eax),%eax
f012206c:	85 c0                	test   %eax,%eax
f012206e:	75 08                	jne    f0122078 <realloc_block_FF+0x440>
f0122070:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122073:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122078:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012207d:	40                   	inc    %eax
f012207e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
							break;
f0122083:	eb 36                	jmp    f01220bb <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0122085:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f012208a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012208d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122091:	74 07                	je     f012209a <realloc_block_FF+0x462>
f0122093:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122096:	8b 00                	mov    (%eax),%eax
f0122098:	eb 05                	jmp    f012209f <realloc_block_FF+0x467>
f012209a:	b8 00 00 00 00       	mov    $0x0,%eax
f012209f:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f01220a4:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f01220a9:	85 c0                	test   %eax,%eax
f01220ab:	0f 85 52 ff ff ff    	jne    f0122003 <realloc_block_FF+0x3cb>
f01220b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01220b5:	0f 85 48 ff ff ff    	jne    f0122003 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f01220bb:	83 ec 04             	sub    $0x4,%esp
f01220be:	6a 00                	push   $0x0
f01220c0:	ff 75 d8             	pushl  -0x28(%ebp)
f01220c3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01220c6:	e8 9d eb ff ff       	call   f0120c68 <set_block_data>
f01220cb:	83 c4 10             	add    $0x10,%esp
				return va;
f01220ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01220d1:	e9 6b 02 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
			}
			
		}
		return va;
f01220d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01220d9:	e9 63 02 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
	}

	if(new_size > cur_size)
f01220de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01220e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01220e4:	0f 86 4d 02 00 00    	jbe    f0122337 <realloc_block_FF+0x6ff>
	{
		if(is_free_block(next_va))
f01220ea:	83 ec 0c             	sub    $0xc,%esp
f01220ed:	ff 75 e4             	pushl  -0x1c(%ebp)
f01220f0:	e8 3b e8 ff ff       	call   f0120930 <is_free_block>
f01220f5:	83 c4 10             	add    $0x10,%esp
f01220f8:	84 c0                	test   %al,%al
f01220fa:	0f 84 37 02 00 00    	je     f0122337 <realloc_block_FF+0x6ff>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0122100:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122103:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0122106:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0122109:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012210c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012210f:	76 38                	jbe    f0122149 <realloc_block_FF+0x511>
			{
				void *new_va = alloc_block_FF(new_size); //new allocation
f0122111:	83 ec 0c             	sub    $0xc,%esp
f0122114:	ff 75 0c             	pushl  0xc(%ebp)
f0122117:	e8 7b eb ff ff       	call   f0120c97 <alloc_block_FF>
f012211c:	83 c4 10             	add    $0x10,%esp
f012211f:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0122122:	83 ec 08             	sub    $0x8,%esp
f0122125:	ff 75 c0             	pushl  -0x40(%ebp)
f0122128:	ff 75 08             	pushl  0x8(%ebp)
f012212b:	e8 c9 fa ff ff       	call   f0121bf9 <copy_data>
f0122130:	83 c4 10             	add    $0x10,%esp
				free_block(va); //set it free
f0122133:	83 ec 0c             	sub    $0xc,%esp
f0122136:	ff 75 08             	pushl  0x8(%ebp)
f0122139:	e8 fa f9 ff ff       	call   f0121b38 <free_block>
f012213e:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0122141:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0122144:	e9 f8 01 00 00       	jmp    f0122341 <realloc_block_FF+0x709>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0122149:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012214c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f012214f:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0122152:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0122156:	0f 87 a0 00 00 00    	ja     f01221fc <realloc_block_FF+0x5c4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f012215c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122160:	75 17                	jne    f0122179 <realloc_block_FF+0x541>
f0122162:	83 ec 04             	sub    $0x4,%esp
f0122165:	68 37 1a 13 f0       	push   $0xf0131a37
f012216a:	68 38 02 00 00       	push   $0x238
f012216f:	68 55 1a 13 f0       	push   $0xf0131a55
f0122174:	e8 c0 e1 fd ff       	call   f0100339 <_panic>
f0122179:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012217c:	8b 00                	mov    (%eax),%eax
f012217e:	85 c0                	test   %eax,%eax
f0122180:	74 10                	je     f0122192 <realloc_block_FF+0x55a>
f0122182:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122185:	8b 00                	mov    (%eax),%eax
f0122187:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012218a:	8b 52 04             	mov    0x4(%edx),%edx
f012218d:	89 50 04             	mov    %edx,0x4(%eax)
f0122190:	eb 0b                	jmp    f012219d <realloc_block_FF+0x565>
f0122192:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122195:	8b 40 04             	mov    0x4(%eax),%eax
f0122198:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f012219d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221a0:	8b 40 04             	mov    0x4(%eax),%eax
f01221a3:	85 c0                	test   %eax,%eax
f01221a5:	74 0f                	je     f01221b6 <realloc_block_FF+0x57e>
f01221a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221aa:	8b 40 04             	mov    0x4(%eax),%eax
f01221ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01221b0:	8b 12                	mov    (%edx),%edx
f01221b2:	89 10                	mov    %edx,(%eax)
f01221b4:	eb 0a                	jmp    f01221c0 <realloc_block_FF+0x588>
f01221b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221b9:	8b 00                	mov    (%eax),%eax
f01221bb:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01221c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01221c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221cc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01221d3:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01221d8:	48                   	dec    %eax
f01221d9:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f01221de:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01221e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01221e4:	01 d0                	add    %edx,%eax
f01221e6:	83 ec 04             	sub    $0x4,%esp
f01221e9:	6a 01                	push   $0x1
f01221eb:	50                   	push   %eax
f01221ec:	ff 75 08             	pushl  0x8(%ebp)
f01221ef:	e8 74 ea ff ff       	call   f0120c68 <set_block_data>
f01221f4:	83 c4 10             	add    $0x10,%esp
f01221f7:	e9 36 01 00 00       	jmp    f0122332 <realloc_block_FF+0x6fa>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f01221fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01221ff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0122202:	01 d0                	add    %edx,%eax
f0122204:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0122207:	83 ec 04             	sub    $0x4,%esp
f012220a:	6a 01                	push   $0x1
f012220c:	ff 75 f0             	pushl  -0x10(%ebp)
f012220f:	ff 75 08             	pushl  0x8(%ebp)
f0122212:	e8 51 ea ff ff       	call   f0120c68 <set_block_data>
f0122217:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f012221a:	8b 45 08             	mov    0x8(%ebp),%eax
f012221d:	83 e8 04             	sub    $0x4,%eax
f0122220:	8b 00                	mov    (%eax),%eax
f0122222:	83 e0 fe             	and    $0xfffffffe,%eax
f0122225:	89 c2                	mov    %eax,%edx
f0122227:	8b 45 08             	mov    0x8(%ebp),%eax
f012222a:	01 d0                	add    %edx,%eax
f012222c:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f012222f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122233:	74 06                	je     f012223b <realloc_block_FF+0x603>
f0122235:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0122239:	75 17                	jne    f0122252 <realloc_block_FF+0x61a>
f012223b:	83 ec 04             	sub    $0x4,%esp
f012223e:	68 c8 1a 13 f0       	push   $0xf0131ac8
f0122243:	68 44 02 00 00       	push   $0x244
f0122248:	68 55 1a 13 f0       	push   $0xf0131a55
f012224d:	e8 e7 e0 fd ff       	call   f0100339 <_panic>
f0122252:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122255:	8b 10                	mov    (%eax),%edx
f0122257:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012225a:	89 10                	mov    %edx,(%eax)
f012225c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012225f:	8b 00                	mov    (%eax),%eax
f0122261:	85 c0                	test   %eax,%eax
f0122263:	74 0b                	je     f0122270 <realloc_block_FF+0x638>
f0122265:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122268:	8b 00                	mov    (%eax),%eax
f012226a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f012226d:	89 50 04             	mov    %edx,0x4(%eax)
f0122270:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122273:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0122276:	89 10                	mov    %edx,(%eax)
f0122278:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012227b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012227e:	89 50 04             	mov    %edx,0x4(%eax)
f0122281:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122284:	8b 00                	mov    (%eax),%eax
f0122286:	85 c0                	test   %eax,%eax
f0122288:	75 08                	jne    f0122292 <realloc_block_FF+0x65a>
f012228a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012228d:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122292:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0122297:	40                   	inc    %eax
f0122298:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f012229d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01222a1:	75 17                	jne    f01222ba <realloc_block_FF+0x682>
f01222a3:	83 ec 04             	sub    $0x4,%esp
f01222a6:	68 37 1a 13 f0       	push   $0xf0131a37
f01222ab:	68 45 02 00 00       	push   $0x245
f01222b0:	68 55 1a 13 f0       	push   $0xf0131a55
f01222b5:	e8 7f e0 fd ff       	call   f0100339 <_panic>
f01222ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222bd:	8b 00                	mov    (%eax),%eax
f01222bf:	85 c0                	test   %eax,%eax
f01222c1:	74 10                	je     f01222d3 <realloc_block_FF+0x69b>
f01222c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222c6:	8b 00                	mov    (%eax),%eax
f01222c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01222cb:	8b 52 04             	mov    0x4(%edx),%edx
f01222ce:	89 50 04             	mov    %edx,0x4(%eax)
f01222d1:	eb 0b                	jmp    f01222de <realloc_block_FF+0x6a6>
f01222d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222d6:	8b 40 04             	mov    0x4(%eax),%eax
f01222d9:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01222de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222e1:	8b 40 04             	mov    0x4(%eax),%eax
f01222e4:	85 c0                	test   %eax,%eax
f01222e6:	74 0f                	je     f01222f7 <realloc_block_FF+0x6bf>
f01222e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222eb:	8b 40 04             	mov    0x4(%eax),%eax
f01222ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01222f1:	8b 12                	mov    (%edx),%edx
f01222f3:	89 10                	mov    %edx,(%eax)
f01222f5:	eb 0a                	jmp    f0122301 <realloc_block_FF+0x6c9>
f01222f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222fa:	8b 00                	mov    (%eax),%eax
f01222fc:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0122301:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122304:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012230a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012230d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122314:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0122319:	48                   	dec    %eax
f012231a:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				set_block_data(next_new_va, remaining_size, 0);
f012231f:	83 ec 04             	sub    $0x4,%esp
f0122322:	6a 00                	push   $0x0
f0122324:	ff 75 bc             	pushl  -0x44(%ebp)
f0122327:	ff 75 b8             	pushl  -0x48(%ebp)
f012232a:	e8 39 e9 ff ff       	call   f0120c68 <set_block_data>
f012232f:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0122332:	8b 45 08             	mov    0x8(%ebp),%eax
f0122335:	eb 0a                	jmp    f0122341 <realloc_block_FF+0x709>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0122337:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f012233e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122341:	c9                   	leave  
f0122342:	c3                   	ret    

f0122343 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0122343:	55                   	push   %ebp
f0122344:	89 e5                	mov    %esp,%ebp
f0122346:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0122349:	83 ec 04             	sub    $0x4,%esp
f012234c:	68 34 1b 13 f0       	push   $0xf0131b34
f0122351:	68 58 02 00 00       	push   $0x258
f0122356:	68 55 1a 13 f0       	push   $0xf0131a55
f012235b:	e8 d9 df fd ff       	call   f0100339 <_panic>

f0122360 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0122360:	55                   	push   %ebp
f0122361:	89 e5                	mov    %esp,%ebp
f0122363:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0122366:	83 ec 04             	sub    $0x4,%esp
f0122369:	68 5c 1b 13 f0       	push   $0xf0131b5c
f012236e:	68 61 02 00 00       	push   $0x261
f0122373:	68 55 1a 13 f0       	push   $0xf0131a55
f0122378:	e8 bc df fd ff       	call   f0100339 <_panic>
f012237d:	66 90                	xchg   %ax,%ax
f012237f:	90                   	nop

f0122380 <__moddi3>:
f0122380:	55                   	push   %ebp
f0122381:	57                   	push   %edi
f0122382:	56                   	push   %esi
f0122383:	53                   	push   %ebx
f0122384:	83 ec 2c             	sub    $0x2c,%esp
f0122387:	8b 74 24 40          	mov    0x40(%esp),%esi
f012238b:	8b 7c 24 44          	mov    0x44(%esp),%edi
f012238f:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0122393:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0122397:	89 d8                	mov    %ebx,%eax
f0122399:	85 ff                	test   %edi,%edi
f012239b:	0f 88 d3 00 00 00    	js     f0122474 <__moddi3+0xf4>
f01223a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01223a8:	00 
f01223a9:	85 c0                	test   %eax,%eax
f01223ab:	0f 88 ab 00 00 00    	js     f012245c <__moddi3+0xdc>
f01223b1:	89 0c 24             	mov    %ecx,(%esp)
f01223b4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01223b8:	89 74 24 10          	mov    %esi,0x10(%esp)
f01223bc:	89 fb                	mov    %edi,%ebx
f01223be:	8b 14 24             	mov    (%esp),%edx
f01223c1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01223c5:	89 d0                	mov    %edx,%eax
f01223c7:	89 54 24 18          	mov    %edx,0x18(%esp)
f01223cb:	89 ca                	mov    %ecx,%edx
f01223cd:	8b 0c 24             	mov    (%esp),%ecx
f01223d0:	89 34 24             	mov    %esi,(%esp)
f01223d3:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01223d7:	85 d2                	test   %edx,%edx
f01223d9:	75 15                	jne    f01223f0 <__moddi3+0x70>
f01223db:	89 c7                	mov    %eax,%edi
f01223dd:	39 d8                	cmp    %ebx,%eax
f01223df:	76 5b                	jbe    f012243c <__moddi3+0xbc>
f01223e1:	89 f0                	mov    %esi,%eax
f01223e3:	89 da                	mov    %ebx,%edx
f01223e5:	f7 f7                	div    %edi
f01223e7:	89 d3                	mov    %edx,%ebx
f01223e9:	89 d8                	mov    %ebx,%eax
f01223eb:	31 d2                	xor    %edx,%edx
f01223ed:	eb 09                	jmp    f01223f8 <__moddi3+0x78>
f01223ef:	90                   	nop
f01223f0:	39 fa                	cmp    %edi,%edx
f01223f2:	76 1c                	jbe    f0122410 <__moddi3+0x90>
f01223f4:	89 f0                	mov    %esi,%eax
f01223f6:	89 fa                	mov    %edi,%edx
f01223f8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f01223fc:	85 c9                	test   %ecx,%ecx
f01223fe:	74 07                	je     f0122407 <__moddi3+0x87>
f0122400:	f7 d8                	neg    %eax
f0122402:	83 d2 00             	adc    $0x0,%edx
f0122405:	f7 da                	neg    %edx
f0122407:	83 c4 2c             	add    $0x2c,%esp
f012240a:	5b                   	pop    %ebx
f012240b:	5e                   	pop    %esi
f012240c:	5f                   	pop    %edi
f012240d:	5d                   	pop    %ebp
f012240e:	c3                   	ret    
f012240f:	90                   	nop
f0122410:	0f bd c2             	bsr    %edx,%eax
f0122413:	83 f0 1f             	xor    $0x1f,%eax
f0122416:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f012241a:	75 6c                	jne    f0122488 <__moddi3+0x108>
f012241c:	39 fa                	cmp    %edi,%edx
f012241e:	72 05                	jb     f0122425 <__moddi3+0xa5>
f0122420:	3b 0c 24             	cmp    (%esp),%ecx
f0122423:	77 0e                	ja     f0122433 <__moddi3+0xb3>
f0122425:	8b 34 24             	mov    (%esp),%esi
f0122428:	29 ce                	sub    %ecx,%esi
f012242a:	19 d3                	sbb    %edx,%ebx
f012242c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0122430:	89 34 24             	mov    %esi,(%esp)
f0122433:	8b 04 24             	mov    (%esp),%eax
f0122436:	8b 54 24 14          	mov    0x14(%esp),%edx
f012243a:	eb bc                	jmp    f01223f8 <__moddi3+0x78>
f012243c:	85 c9                	test   %ecx,%ecx
f012243e:	75 0b                	jne    f012244b <__moddi3+0xcb>
f0122440:	b8 01 00 00 00       	mov    $0x1,%eax
f0122445:	31 d2                	xor    %edx,%edx
f0122447:	f7 f1                	div    %ecx
f0122449:	89 c1                	mov    %eax,%ecx
f012244b:	89 d8                	mov    %ebx,%eax
f012244d:	31 d2                	xor    %edx,%edx
f012244f:	f7 f1                	div    %ecx
f0122451:	8b 04 24             	mov    (%esp),%eax
f0122454:	f7 f1                	div    %ecx
f0122456:	89 d3                	mov    %edx,%ebx
f0122458:	eb 8f                	jmp    f01223e9 <__moddi3+0x69>
f012245a:	66 90                	xchg   %ax,%ax
f012245c:	89 c8                	mov    %ecx,%eax
f012245e:	89 da                	mov    %ebx,%edx
f0122460:	f7 d8                	neg    %eax
f0122462:	83 d2 00             	adc    $0x0,%edx
f0122465:	f7 da                	neg    %edx
f0122467:	89 04 24             	mov    %eax,(%esp)
f012246a:	89 54 24 04          	mov    %edx,0x4(%esp)
f012246e:	e9 45 ff ff ff       	jmp    f01223b8 <__moddi3+0x38>
f0122473:	90                   	nop
f0122474:	f7 de                	neg    %esi
f0122476:	83 d7 00             	adc    $0x0,%edi
f0122479:	f7 df                	neg    %edi
f012247b:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0122482:	ff 
f0122483:	e9 21 ff ff ff       	jmp    f01223a9 <__moddi3+0x29>
f0122488:	b8 20 00 00 00       	mov    $0x20,%eax
f012248d:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0122491:	29 f8                	sub    %edi,%eax
f0122493:	89 c6                	mov    %eax,%esi
f0122495:	89 44 24 14          	mov    %eax,0x14(%esp)
f0122499:	89 f9                	mov    %edi,%ecx
f012249b:	d3 e2                	shl    %cl,%edx
f012249d:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01224a1:	89 e8                	mov    %ebp,%eax
f01224a3:	89 f1                	mov    %esi,%ecx
f01224a5:	d3 e8                	shr    %cl,%eax
f01224a7:	09 d0                	or     %edx,%eax
f01224a9:	89 04 24             	mov    %eax,(%esp)
f01224ac:	89 ea                	mov    %ebp,%edx
f01224ae:	89 f9                	mov    %edi,%ecx
f01224b0:	d3 e2                	shl    %cl,%edx
f01224b2:	89 d7                	mov    %edx,%edi
f01224b4:	89 da                	mov    %ebx,%edx
f01224b6:	d3 e2                	shl    %cl,%edx
f01224b8:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01224bc:	d3 e5                	shl    %cl,%ebp
f01224be:	8b 44 24 10          	mov    0x10(%esp),%eax
f01224c2:	89 f1                	mov    %esi,%ecx
f01224c4:	d3 e8                	shr    %cl,%eax
f01224c6:	09 d0                	or     %edx,%eax
f01224c8:	d3 eb                	shr    %cl,%ebx
f01224ca:	89 da                	mov    %ebx,%edx
f01224cc:	f7 34 24             	divl   (%esp)
f01224cf:	89 d3                	mov    %edx,%ebx
f01224d1:	f7 e7                	mul    %edi
f01224d3:	89 c6                	mov    %eax,%esi
f01224d5:	89 d1                	mov    %edx,%ecx
f01224d7:	39 d3                	cmp    %edx,%ebx
f01224d9:	72 29                	jb     f0122504 <__moddi3+0x184>
f01224db:	74 33                	je     f0122510 <__moddi3+0x190>
f01224dd:	89 e8                	mov    %ebp,%eax
f01224df:	29 f0                	sub    %esi,%eax
f01224e1:	19 cb                	sbb    %ecx,%ebx
f01224e3:	89 de                	mov    %ebx,%esi
f01224e5:	8a 4c 24 14          	mov    0x14(%esp),%cl
f01224e9:	d3 e6                	shl    %cl,%esi
f01224eb:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01224ef:	89 f9                	mov    %edi,%ecx
f01224f1:	d3 e8                	shr    %cl,%eax
f01224f3:	09 c6                	or     %eax,%esi
f01224f5:	89 f0                	mov    %esi,%eax
f01224f7:	89 f9                	mov    %edi,%ecx
f01224f9:	d3 eb                	shr    %cl,%ebx
f01224fb:	89 da                	mov    %ebx,%edx
f01224fd:	e9 f6 fe ff ff       	jmp    f01223f8 <__moddi3+0x78>
f0122502:	66 90                	xchg   %ax,%ax
f0122504:	29 f8                	sub    %edi,%eax
f0122506:	1b 14 24             	sbb    (%esp),%edx
f0122509:	89 d1                	mov    %edx,%ecx
f012250b:	89 c6                	mov    %eax,%esi
f012250d:	eb ce                	jmp    f01224dd <__moddi3+0x15d>
f012250f:	90                   	nop
f0122510:	39 c5                	cmp    %eax,%ebp
f0122512:	72 f0                	jb     f0122504 <__moddi3+0x184>
f0122514:	89 d9                	mov    %ebx,%ecx
f0122516:	eb c5                	jmp    f01224dd <__moddi3+0x15d>

f0122518 <__udivdi3>:
f0122518:	55                   	push   %ebp
f0122519:	57                   	push   %edi
f012251a:	56                   	push   %esi
f012251b:	53                   	push   %ebx
f012251c:	83 ec 1c             	sub    $0x1c,%esp
f012251f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0122523:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0122527:	8b 7c 24 38          	mov    0x38(%esp),%edi
f012252b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012252f:	89 ca                	mov    %ecx,%edx
f0122531:	89 f8                	mov    %edi,%eax
f0122533:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0122537:	85 f6                	test   %esi,%esi
f0122539:	75 2d                	jne    f0122568 <__udivdi3+0x50>
f012253b:	39 cf                	cmp    %ecx,%edi
f012253d:	77 65                	ja     f01225a4 <__udivdi3+0x8c>
f012253f:	89 fd                	mov    %edi,%ebp
f0122541:	85 ff                	test   %edi,%edi
f0122543:	75 0b                	jne    f0122550 <__udivdi3+0x38>
f0122545:	b8 01 00 00 00       	mov    $0x1,%eax
f012254a:	31 d2                	xor    %edx,%edx
f012254c:	f7 f7                	div    %edi
f012254e:	89 c5                	mov    %eax,%ebp
f0122550:	31 d2                	xor    %edx,%edx
f0122552:	89 c8                	mov    %ecx,%eax
f0122554:	f7 f5                	div    %ebp
f0122556:	89 c1                	mov    %eax,%ecx
f0122558:	89 d8                	mov    %ebx,%eax
f012255a:	f7 f5                	div    %ebp
f012255c:	89 cf                	mov    %ecx,%edi
f012255e:	89 fa                	mov    %edi,%edx
f0122560:	83 c4 1c             	add    $0x1c,%esp
f0122563:	5b                   	pop    %ebx
f0122564:	5e                   	pop    %esi
f0122565:	5f                   	pop    %edi
f0122566:	5d                   	pop    %ebp
f0122567:	c3                   	ret    
f0122568:	39 ce                	cmp    %ecx,%esi
f012256a:	77 28                	ja     f0122594 <__udivdi3+0x7c>
f012256c:	0f bd fe             	bsr    %esi,%edi
f012256f:	83 f7 1f             	xor    $0x1f,%edi
f0122572:	75 40                	jne    f01225b4 <__udivdi3+0x9c>
f0122574:	39 ce                	cmp    %ecx,%esi
f0122576:	72 0a                	jb     f0122582 <__udivdi3+0x6a>
f0122578:	3b 44 24 08          	cmp    0x8(%esp),%eax
f012257c:	0f 87 9e 00 00 00    	ja     f0122620 <__udivdi3+0x108>
f0122582:	b8 01 00 00 00       	mov    $0x1,%eax
f0122587:	89 fa                	mov    %edi,%edx
f0122589:	83 c4 1c             	add    $0x1c,%esp
f012258c:	5b                   	pop    %ebx
f012258d:	5e                   	pop    %esi
f012258e:	5f                   	pop    %edi
f012258f:	5d                   	pop    %ebp
f0122590:	c3                   	ret    
f0122591:	8d 76 00             	lea    0x0(%esi),%esi
f0122594:	31 ff                	xor    %edi,%edi
f0122596:	31 c0                	xor    %eax,%eax
f0122598:	89 fa                	mov    %edi,%edx
f012259a:	83 c4 1c             	add    $0x1c,%esp
f012259d:	5b                   	pop    %ebx
f012259e:	5e                   	pop    %esi
f012259f:	5f                   	pop    %edi
f01225a0:	5d                   	pop    %ebp
f01225a1:	c3                   	ret    
f01225a2:	66 90                	xchg   %ax,%ax
f01225a4:	89 d8                	mov    %ebx,%eax
f01225a6:	f7 f7                	div    %edi
f01225a8:	31 ff                	xor    %edi,%edi
f01225aa:	89 fa                	mov    %edi,%edx
f01225ac:	83 c4 1c             	add    $0x1c,%esp
f01225af:	5b                   	pop    %ebx
f01225b0:	5e                   	pop    %esi
f01225b1:	5f                   	pop    %edi
f01225b2:	5d                   	pop    %ebp
f01225b3:	c3                   	ret    
f01225b4:	bd 20 00 00 00       	mov    $0x20,%ebp
f01225b9:	89 eb                	mov    %ebp,%ebx
f01225bb:	29 fb                	sub    %edi,%ebx
f01225bd:	89 f9                	mov    %edi,%ecx
f01225bf:	d3 e6                	shl    %cl,%esi
f01225c1:	89 c5                	mov    %eax,%ebp
f01225c3:	88 d9                	mov    %bl,%cl
f01225c5:	d3 ed                	shr    %cl,%ebp
f01225c7:	89 e9                	mov    %ebp,%ecx
f01225c9:	09 f1                	or     %esi,%ecx
f01225cb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01225cf:	89 f9                	mov    %edi,%ecx
f01225d1:	d3 e0                	shl    %cl,%eax
f01225d3:	89 c5                	mov    %eax,%ebp
f01225d5:	89 d6                	mov    %edx,%esi
f01225d7:	88 d9                	mov    %bl,%cl
f01225d9:	d3 ee                	shr    %cl,%esi
f01225db:	89 f9                	mov    %edi,%ecx
f01225dd:	d3 e2                	shl    %cl,%edx
f01225df:	8b 44 24 08          	mov    0x8(%esp),%eax
f01225e3:	88 d9                	mov    %bl,%cl
f01225e5:	d3 e8                	shr    %cl,%eax
f01225e7:	09 c2                	or     %eax,%edx
f01225e9:	89 d0                	mov    %edx,%eax
f01225eb:	89 f2                	mov    %esi,%edx
f01225ed:	f7 74 24 0c          	divl   0xc(%esp)
f01225f1:	89 d6                	mov    %edx,%esi
f01225f3:	89 c3                	mov    %eax,%ebx
f01225f5:	f7 e5                	mul    %ebp
f01225f7:	39 d6                	cmp    %edx,%esi
f01225f9:	72 19                	jb     f0122614 <__udivdi3+0xfc>
f01225fb:	74 0b                	je     f0122608 <__udivdi3+0xf0>
f01225fd:	89 d8                	mov    %ebx,%eax
f01225ff:	31 ff                	xor    %edi,%edi
f0122601:	e9 58 ff ff ff       	jmp    f012255e <__udivdi3+0x46>
f0122606:	66 90                	xchg   %ax,%ax
f0122608:	8b 54 24 08          	mov    0x8(%esp),%edx
f012260c:	89 f9                	mov    %edi,%ecx
f012260e:	d3 e2                	shl    %cl,%edx
f0122610:	39 c2                	cmp    %eax,%edx
f0122612:	73 e9                	jae    f01225fd <__udivdi3+0xe5>
f0122614:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0122617:	31 ff                	xor    %edi,%edi
f0122619:	e9 40 ff ff ff       	jmp    f012255e <__udivdi3+0x46>
f012261e:	66 90                	xchg   %ax,%ax
f0122620:	31 c0                	xor    %eax,%eax
f0122622:	e9 37 ff ff ff       	jmp    f012255e <__udivdi3+0x46>
f0122627:	90                   	nop

f0122628 <__umoddi3>:
f0122628:	55                   	push   %ebp
f0122629:	57                   	push   %edi
f012262a:	56                   	push   %esi
f012262b:	53                   	push   %ebx
f012262c:	83 ec 1c             	sub    $0x1c,%esp
f012262f:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0122633:	8b 74 24 34          	mov    0x34(%esp),%esi
f0122637:	8b 7c 24 38          	mov    0x38(%esp),%edi
f012263b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012263f:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0122643:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0122647:	89 f3                	mov    %esi,%ebx
f0122649:	89 fa                	mov    %edi,%edx
f012264b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012264f:	89 34 24             	mov    %esi,(%esp)
f0122652:	85 c0                	test   %eax,%eax
f0122654:	75 1a                	jne    f0122670 <__umoddi3+0x48>
f0122656:	39 f7                	cmp    %esi,%edi
f0122658:	0f 86 a2 00 00 00    	jbe    f0122700 <__umoddi3+0xd8>
f012265e:	89 c8                	mov    %ecx,%eax
f0122660:	89 f2                	mov    %esi,%edx
f0122662:	f7 f7                	div    %edi
f0122664:	89 d0                	mov    %edx,%eax
f0122666:	31 d2                	xor    %edx,%edx
f0122668:	83 c4 1c             	add    $0x1c,%esp
f012266b:	5b                   	pop    %ebx
f012266c:	5e                   	pop    %esi
f012266d:	5f                   	pop    %edi
f012266e:	5d                   	pop    %ebp
f012266f:	c3                   	ret    
f0122670:	39 f0                	cmp    %esi,%eax
f0122672:	0f 87 ac 00 00 00    	ja     f0122724 <__umoddi3+0xfc>
f0122678:	0f bd e8             	bsr    %eax,%ebp
f012267b:	83 f5 1f             	xor    $0x1f,%ebp
f012267e:	0f 84 ac 00 00 00    	je     f0122730 <__umoddi3+0x108>
f0122684:	bf 20 00 00 00       	mov    $0x20,%edi
f0122689:	29 ef                	sub    %ebp,%edi
f012268b:	89 fe                	mov    %edi,%esi
f012268d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0122691:	89 e9                	mov    %ebp,%ecx
f0122693:	d3 e0                	shl    %cl,%eax
f0122695:	89 d7                	mov    %edx,%edi
f0122697:	89 f1                	mov    %esi,%ecx
f0122699:	d3 ef                	shr    %cl,%edi
f012269b:	09 c7                	or     %eax,%edi
f012269d:	89 e9                	mov    %ebp,%ecx
f012269f:	d3 e2                	shl    %cl,%edx
f01226a1:	89 14 24             	mov    %edx,(%esp)
f01226a4:	89 d8                	mov    %ebx,%eax
f01226a6:	d3 e0                	shl    %cl,%eax
f01226a8:	89 c2                	mov    %eax,%edx
f01226aa:	8b 44 24 08          	mov    0x8(%esp),%eax
f01226ae:	d3 e0                	shl    %cl,%eax
f01226b0:	89 44 24 04          	mov    %eax,0x4(%esp)
f01226b4:	8b 44 24 08          	mov    0x8(%esp),%eax
f01226b8:	89 f1                	mov    %esi,%ecx
f01226ba:	d3 e8                	shr    %cl,%eax
f01226bc:	09 d0                	or     %edx,%eax
f01226be:	d3 eb                	shr    %cl,%ebx
f01226c0:	89 da                	mov    %ebx,%edx
f01226c2:	f7 f7                	div    %edi
f01226c4:	89 d3                	mov    %edx,%ebx
f01226c6:	f7 24 24             	mull   (%esp)
f01226c9:	89 c6                	mov    %eax,%esi
f01226cb:	89 d1                	mov    %edx,%ecx
f01226cd:	39 d3                	cmp    %edx,%ebx
f01226cf:	0f 82 87 00 00 00    	jb     f012275c <__umoddi3+0x134>
f01226d5:	0f 84 91 00 00 00    	je     f012276c <__umoddi3+0x144>
f01226db:	8b 54 24 04          	mov    0x4(%esp),%edx
f01226df:	29 f2                	sub    %esi,%edx
f01226e1:	19 cb                	sbb    %ecx,%ebx
f01226e3:	89 d8                	mov    %ebx,%eax
f01226e5:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f01226e9:	d3 e0                	shl    %cl,%eax
f01226eb:	89 e9                	mov    %ebp,%ecx
f01226ed:	d3 ea                	shr    %cl,%edx
f01226ef:	09 d0                	or     %edx,%eax
f01226f1:	89 e9                	mov    %ebp,%ecx
f01226f3:	d3 eb                	shr    %cl,%ebx
f01226f5:	89 da                	mov    %ebx,%edx
f01226f7:	83 c4 1c             	add    $0x1c,%esp
f01226fa:	5b                   	pop    %ebx
f01226fb:	5e                   	pop    %esi
f01226fc:	5f                   	pop    %edi
f01226fd:	5d                   	pop    %ebp
f01226fe:	c3                   	ret    
f01226ff:	90                   	nop
f0122700:	89 fd                	mov    %edi,%ebp
f0122702:	85 ff                	test   %edi,%edi
f0122704:	75 0b                	jne    f0122711 <__umoddi3+0xe9>
f0122706:	b8 01 00 00 00       	mov    $0x1,%eax
f012270b:	31 d2                	xor    %edx,%edx
f012270d:	f7 f7                	div    %edi
f012270f:	89 c5                	mov    %eax,%ebp
f0122711:	89 f0                	mov    %esi,%eax
f0122713:	31 d2                	xor    %edx,%edx
f0122715:	f7 f5                	div    %ebp
f0122717:	89 c8                	mov    %ecx,%eax
f0122719:	f7 f5                	div    %ebp
f012271b:	89 d0                	mov    %edx,%eax
f012271d:	e9 44 ff ff ff       	jmp    f0122666 <__umoddi3+0x3e>
f0122722:	66 90                	xchg   %ax,%ax
f0122724:	89 c8                	mov    %ecx,%eax
f0122726:	89 f2                	mov    %esi,%edx
f0122728:	83 c4 1c             	add    $0x1c,%esp
f012272b:	5b                   	pop    %ebx
f012272c:	5e                   	pop    %esi
f012272d:	5f                   	pop    %edi
f012272e:	5d                   	pop    %ebp
f012272f:	c3                   	ret    
f0122730:	3b 04 24             	cmp    (%esp),%eax
f0122733:	72 06                	jb     f012273b <__umoddi3+0x113>
f0122735:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0122739:	77 0f                	ja     f012274a <__umoddi3+0x122>
f012273b:	89 f2                	mov    %esi,%edx
f012273d:	29 f9                	sub    %edi,%ecx
f012273f:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0122743:	89 14 24             	mov    %edx,(%esp)
f0122746:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012274a:	8b 44 24 04          	mov    0x4(%esp),%eax
f012274e:	8b 14 24             	mov    (%esp),%edx
f0122751:	83 c4 1c             	add    $0x1c,%esp
f0122754:	5b                   	pop    %ebx
f0122755:	5e                   	pop    %esi
f0122756:	5f                   	pop    %edi
f0122757:	5d                   	pop    %ebp
f0122758:	c3                   	ret    
f0122759:	8d 76 00             	lea    0x0(%esi),%esi
f012275c:	2b 04 24             	sub    (%esp),%eax
f012275f:	19 fa                	sbb    %edi,%edx
f0122761:	89 d1                	mov    %edx,%ecx
f0122763:	89 c6                	mov    %eax,%esi
f0122765:	e9 71 ff ff ff       	jmp    f01226db <__umoddi3+0xb3>
f012276a:	66 90                	xchg   %ax,%ax
f012276c:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0122770:	72 ea                	jb     f012275c <__umoddi3+0x134>
f0122772:	89 d9                	mov    %ebx,%ecx
f0122774:	e9 62 ff ff ff       	jmp    f01226db <__umoddi3+0xb3>
